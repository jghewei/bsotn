/*******************************************************************************
*   COPYRIGHT (C) 2011 PMC-SIERRA, INC. ALL RIGHTS RESERVED.
* --------------------------------------------------------------------------
*  This software embodies materials and concepts which are proprietary and
*  confidential to PMC-Sierra, Inc.
*  PMC-Sierra distributes this software to its customers pursuant to the
*  terms and conditions of the Software License Agreement
*  contained in the text file software.lic that is distributed along with
*  the software. This software can only be utilized if all
*  terms and conditions of the Software License Agreement are
*  accepted. If there are any questions, concerns, or if the
*  Software License Agreement text file, software.lic, is missing please
*  contact PMC-Sierra for assistance.
* --------------------------------------------------------------------------
*   DESCRIPTION :
*    Implements the indirect access functions for each indirect register
*    within the SDH_PMG.
*
*   NOTES:
*    This file is auto generated. Do not edit this file.
*
*******************************************************************************/
/*
** Include Files
*/
#include "sdh_pmg_loc.h"

/*
** Local Enumerated Types
*/

/*
** Local Constants
*/
/* RTTP indirect memory constants */
#define RTTP_SLICE_MAX_NUM          3
#define RTTP_IADDR_MAX              PMC_RTTP_INDIRECT_REG_EXPECTED_TRACE(63)

#define RTTP_IND_READ               1
#define RTTP_IND_WRITE              0
#define RTTP_IND_BUSY_COMPLETE      0
#define RTTP_POLL_ITERATIONS        250
#define RTTP_USEC_DELAY_TICKS       1



/* SBER indirect memory constants */
#define SBER_SLICE_MAX_NUM          3
#define SBER_IADDR_MAX              PMC_SBER_INDIRECT_REG_SF_BERM_SET_INTEGRATION_PERIOD_1

#define SBER_IND_READ               1
#define SBER_IND_WRITE              0
#define SBER_IND_BUSY_COMPLETE      0
#define SBER_POLL_ITERATIONS        250
#define SBER_USEC_DELAY_TICKS       1






/*
** Local Macro Definitions
*/
/*
** Local Structures and Unions
*/

/*
** Local Variables
*/


/*******************************************************************************
* _rttp_indirect_access
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Performs an indirect access command for RTTP_INDIRECT indirect memory
*
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   iaddr        - indirect memory address to access
*   access_type  - indirect access type
*                    RTTP_IND_WRITE: Write
*                    RTTP_IND_READ:  Read
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR _rttp_indirect_access(sdh_pmg_handle_t *h,
                                      UINT32 index_a,
                                      UINT32 iaddr,
                                      UINT32 access_type)
{
    /* declare buffer */
    rttp_buffer_t b[1];

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (iaddr > RTTP_IADDR_MAX) ||
        ((access_type != RTTP_IND_WRITE) && 
         (access_type != RTTP_IND_READ)))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }
    
    /* init buffer */
    rttp_buffer_init(b, h, index_a);

    /* update fields */
    rttp_field_IADDR_set(b, h, index_a, iaddr);

    /* indicate read or write operation */
    rttp_field_RWB_set(b, h, index_a, access_type);

    /* flush buffer */
    rttp_buffer_flush( b );

    PMC_RETURN(PMC_SUCCESS);
} /* _rttp_indirect_access */


/*******************************************************************************
* _rttp_indirect_read
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Performs an indirect read access for RTTP_INDIRECT indirect memory
*
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   iaddr        - indirect memory address to access
*   *b           - pointer to buffer containing read data
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR _rttp_indirect_read(sdh_pmg_handle_t *h,
                                      UINT32 index_a,
                                      UINT32 iaddr,
                                      rttp_indirect_buffer_t *b)
{
    UINT32 result;
    UINT32 rttp_rst, chn_low_pwr, top_rst;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (b == NULL) || 
        (index_a > 3) ||
        (iaddr > RTTP_IADDR_MAX))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    rttp_rst = sdh_pmg_field_CH_RTTP_U_SW_RST_get(NULL, h, (3-index_a));
    chn_low_pwr = sdh_pmg_field_CH_LOW_PWR_get(NULL, h, (3-index_a));
    top_rst = sdh_pmg_field_TOP_SW_RST_get(NULL, h);
    if (rttp_rst | chn_low_pwr | top_rst) {
        PMC_RETURN(PMC_ERR_FAIL);
    }

    /* poll BUSY bit to ensure register is ready indirect access */
    result = rttp_field_BUSY_poll(NULL, 
                                      h, index_a, 
                                      RTTP_IND_BUSY_COMPLETE, 
                                      PMC_POLL_EQUAL,
                                      RTTP_POLL_ITERATIONS, 
                                      NULL, 
                                      RTTP_USEC_DELAY_TICKS);
    
    if (result != PMC_SUCCESS) 
    {
        LOG("rttp_field_BUSY_poll failed...");
        PMC_RETURN(result);
    }
    
    /* initiate the indirect read access */
    result = _rttp_indirect_access(h, index_a, iaddr, RTTP_IND_READ);
    if (result != PMC_SUCCESS) PMC_RETURN(result);

    /* poll BUSY bit to ensure data is ready to be read */
    result = rttp_field_BUSY_poll(NULL, 
                                      h, index_a, 
                                      RTTP_IND_BUSY_COMPLETE, 
                                      PMC_POLL_EQUAL,
                                      RTTP_POLL_ITERATIONS, 
                                      NULL, 
                                      RTTP_USEC_DELAY_TICKS);
    if (result != PMC_SUCCESS) 
    {
        LOG("rttp_field_BUSY_poll failed...");
        PMC_RETURN(result);
    }

    /* read indirect access data from indirect data registers */
    b->data[0] = rttp_field_DATA_get(NULL, h, index_a);
    b->mask[0] = RTTP_REG_IND_DATA_BIT_DATA_MSK;

    PMC_RETURN(PMC_SUCCESS);
} /* _rttp_indirect_read */


/*******************************************************************************
* _rttp_indirect_read_modify_write
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Performs an indirect read/modify/write access for RTTP_INDIRECT indirect memory
*
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   iaddr        - indirect memory address to access
*   *b           - pointer to buffer for data to be written
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR _rttp_indirect_read_modify_write(sdh_pmg_handle_t *h,
                                      UINT32 index_a,
                                      UINT32 iaddr,
                                      rttp_indirect_buffer_t *b)
{
    rttp_indirect_buffer_t tmp_b;
    UINT32 access_data;
    UINT32 result;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (b == NULL) || 
        (index_a > 3) ||
        (iaddr > RTTP_IADDR_MAX))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* read and update the data of indirect data registers */
    result = _rttp_indirect_read(h, index_a, iaddr, (rttp_indirect_buffer_t *)&tmp_b);
    if (result != PMC_SUCCESS) PMC_RETURN(result);

    access_data = tmp_b.data[0];

    access_data = (access_data & ~(b->mask[0])) | (b->data[0]);

    /* write indirect access data to indirect data registers */
    rttp_field_DATA_set(NULL, h, index_a, access_data);

    /* initiate the indirect write access */
    result = _rttp_indirect_access(h, index_a, iaddr, RTTP_IND_WRITE);
    if (result != PMC_SUCCESS) PMC_RETURN(result);

    /* poll BUSY bit to ensure indirect write access completes */
    result = rttp_field_BUSY_poll(NULL, 
                        h, index_a, 
                        RTTP_IND_BUSY_COMPLETE, 
                        PMC_POLL_EQUAL,
                        RTTP_POLL_ITERATIONS, 
                        NULL, 
                        RTTP_USEC_DELAY_TICKS);
    if (result != PMC_SUCCESS) 
    {
        LOG("rttp_field_BUSY_poll failed...");
        PMC_RETURN(result);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* _rttp_indirect_read_modify_write */



/*******************************************************************************
* rttp_indirect_TRACE_MISMATCH_UNSTBL_STAT_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies TRACE_MISMATCH_UNSTBL_STAT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   *b           - pointer to RTTP_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR rttp_indirect_TRACE_MISMATCH_UNSTBL_STAT_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      rttp_indirect_TRACE_MISMATCH_UNSTBL_STAT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_RTTP_INDIRECT_REG_TRACE_MISMATCH_UNSTBL_STAT;

    result = _rttp_indirect_read_modify_write(h, index_a, iaddr, (rttp_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* rttp_indirect_TRACE_MISMATCH_UNSTBL_STAT_buffer_apply */



/*******************************************************************************
* rttp_indirect_TRACE_MISMATCH_UNSTBL_STAT_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves TRACE_MISMATCH_UNSTBL_STAT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   *b           - pointer to RTTP_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR rttp_indirect_TRACE_MISMATCH_UNSTBL_STAT_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      rttp_indirect_TRACE_MISMATCH_UNSTBL_STAT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_RTTP_INDIRECT_REG_TRACE_MISMATCH_UNSTBL_STAT;

    /*
    PMC_OS_MUTEX_LOCK(rttp_indirect_lock);
    */
    result = _rttp_indirect_read(h, index_a, iaddr, (rttp_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(rttp_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(rttp_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* rttp_indirect_TRACE_MISMATCH_UNSTBL_STAT_buffer_apply */




/*******************************************************************************
* rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_EN_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies TRACE_MISMATCH_UNSTBL_INT_EN data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   *b           - pointer to RTTP_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_EN_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_EN_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_RTTP_INDIRECT_REG_TRACE_MISMATCH_UNSTBL_INT_EN;

    result = _rttp_indirect_read_modify_write(h, index_a, iaddr, (rttp_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_EN_buffer_apply */



/*******************************************************************************
* rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_EN_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves TRACE_MISMATCH_UNSTBL_INT_EN data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   *b           - pointer to RTTP_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_EN_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_EN_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_RTTP_INDIRECT_REG_TRACE_MISMATCH_UNSTBL_INT_EN;

    /*
    PMC_OS_MUTEX_LOCK(rttp_indirect_lock);
    */
    result = _rttp_indirect_read(h, index_a, iaddr, (rttp_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(rttp_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(rttp_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_EN_buffer_apply */




/*******************************************************************************
* rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_STAT_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies TRACE_MISMATCH_UNSTBL_INT_STAT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   *b           - pointer to RTTP_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_STAT_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_STAT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_RTTP_INDIRECT_REG_TRACE_MISMATCH_UNSTBL_INT_STAT;

    result = _rttp_indirect_read_modify_write(h, index_a, iaddr, (rttp_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_STAT_buffer_apply */



/*******************************************************************************
* rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_STAT_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves TRACE_MISMATCH_UNSTBL_INT_STAT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   *b           - pointer to RTTP_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_STAT_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_STAT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_RTTP_INDIRECT_REG_TRACE_MISMATCH_UNSTBL_INT_STAT;

    /*
    PMC_OS_MUTEX_LOCK(rttp_indirect_lock);
    */
    result = _rttp_indirect_read(h, index_a, iaddr, (rttp_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(rttp_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(rttp_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* rttp_indirect_TRACE_MISMATCH_UNSTBL_INT_STAT_buffer_apply */




/*******************************************************************************
* rttp_indirect_TRACE_CFG_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies TRACE_CFG data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   *b           - pointer to RTTP_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR rttp_indirect_TRACE_CFG_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      rttp_indirect_TRACE_CFG_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_RTTP_INDIRECT_REG_TRACE_CFG;

    result = _rttp_indirect_read_modify_write(h, index_a, iaddr, (rttp_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* rttp_indirect_TRACE_CFG_buffer_apply */



/*******************************************************************************
* rttp_indirect_TRACE_CFG_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves TRACE_CFG data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   *b           - pointer to RTTP_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR rttp_indirect_TRACE_CFG_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      rttp_indirect_TRACE_CFG_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_RTTP_INDIRECT_REG_TRACE_CFG;

    /*
    PMC_OS_MUTEX_LOCK(rttp_indirect_lock);
    */
    result = _rttp_indirect_read(h, index_a, iaddr, (rttp_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(rttp_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(rttp_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* rttp_indirect_TRACE_CFG_buffer_apply */




/*******************************************************************************
* rttp_indirect_CAPTURED_TRACE_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies CAPTURED_TRACE data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   trace_byte   - RTTP slice instance trace_byte=0:63 to access
*   *b           - pointer to RTTP_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR rttp_indirect_CAPTURED_TRACE_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      UINT32 trace_byte,
                                      rttp_indirect_CAPTURED_TRACE_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (trace_byte > 63) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_RTTP_INDIRECT_REG_CAPTURED_TRACE (trace_byte);

    result = _rttp_indirect_read_modify_write(h, index_a, iaddr, (rttp_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* rttp_indirect_CAPTURED_TRACE_buffer_apply */



/*******************************************************************************
* rttp_indirect_CAPTURED_TRACE_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves CAPTURED_TRACE data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   trace_byte   - RTTP slice instance trace_byte=0:63 to access
*   *b           - pointer to RTTP_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR rttp_indirect_CAPTURED_TRACE_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      UINT32 trace_byte,
                                      rttp_indirect_CAPTURED_TRACE_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (trace_byte > 63) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_RTTP_INDIRECT_REG_CAPTURED_TRACE (trace_byte);

    /*
    PMC_OS_MUTEX_LOCK(rttp_indirect_lock);
    */
    result = _rttp_indirect_read(h, index_a, iaddr, (rttp_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(rttp_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(rttp_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* rttp_indirect_CAPTURED_TRACE_buffer_apply */




/*******************************************************************************
* rttp_indirect_ACCEPTED_TRACE_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies ACCEPTED_TRACE data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   trace_byte   - RTTP slice instance trace_byte=0:63 to access
*   *b           - pointer to RTTP_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR rttp_indirect_ACCEPTED_TRACE_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      UINT32 trace_byte,
                                      rttp_indirect_ACCEPTED_TRACE_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (trace_byte > 63) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_RTTP_INDIRECT_REG_ACCEPTED_TRACE (trace_byte);

    result = _rttp_indirect_read_modify_write(h, index_a, iaddr, (rttp_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* rttp_indirect_ACCEPTED_TRACE_buffer_apply */



/*******************************************************************************
* rttp_indirect_ACCEPTED_TRACE_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves ACCEPTED_TRACE data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   trace_byte   - RTTP slice instance trace_byte=0:63 to access
*   *b           - pointer to RTTP_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR rttp_indirect_ACCEPTED_TRACE_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      UINT32 trace_byte,
                                      rttp_indirect_ACCEPTED_TRACE_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (trace_byte > 63) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_RTTP_INDIRECT_REG_ACCEPTED_TRACE (trace_byte);

    /*
    PMC_OS_MUTEX_LOCK(rttp_indirect_lock);
    */
    result = _rttp_indirect_read(h, index_a, iaddr, (rttp_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(rttp_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(rttp_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* rttp_indirect_ACCEPTED_TRACE_buffer_apply */




/*******************************************************************************
* rttp_indirect_EXPECTED_TRACE_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies EXPECTED_TRACE data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   trace_byte   - RTTP slice instance trace_byte=0:63 to access
*   *b           - pointer to RTTP_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR rttp_indirect_EXPECTED_TRACE_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      UINT32 trace_byte,
                                      rttp_indirect_EXPECTED_TRACE_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (trace_byte > 63) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_RTTP_INDIRECT_REG_EXPECTED_TRACE (trace_byte);

    result = _rttp_indirect_read_modify_write(h, index_a, iaddr, (rttp_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* rttp_indirect_EXPECTED_TRACE_buffer_apply */



/*******************************************************************************
* rttp_indirect_EXPECTED_TRACE_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves EXPECTED_TRACE data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - RTTP slice instance index_a=0:3 to access
*   trace_byte   - RTTP slice instance trace_byte=0:63 to access
*   *b           - pointer to RTTP_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR rttp_indirect_EXPECTED_TRACE_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      UINT32 trace_byte,
                                      rttp_indirect_EXPECTED_TRACE_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (trace_byte > 63) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_RTTP_INDIRECT_REG_EXPECTED_TRACE (trace_byte);

    /*
    PMC_OS_MUTEX_LOCK(rttp_indirect_lock);
    */
    result = _rttp_indirect_read(h, index_a, iaddr, (rttp_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(rttp_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(rttp_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* rttp_indirect_EXPECTED_TRACE_buffer_apply */





/*******************************************************************************
* _sber_indirect_access
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Performs an indirect access command for SBER_INDIRECT indirect memory
*
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   iaddr        - indirect memory address to access
*   access_type  - indirect access type
*                    SBER_IND_WRITE: Write
*                    SBER_IND_READ:  Read
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR _sber_indirect_access(sdh_pmg_handle_t *h,
                                      UINT32 index_a,
                                      UINT32 iaddr,
                                      UINT32 access_type)
{
    /* declare buffer */
    sber_buffer_t b[1];

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (iaddr > SBER_IADDR_MAX) ||
        ((access_type != SBER_IND_WRITE) && 
         (access_type != SBER_IND_READ)))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }
    
    /* init buffer */
    sber_buffer_init(b, h, index_a);

    /* update fields */
    sber_field_IADDR_set(b, h, index_a, iaddr);

    /* indicate read or write operation */
    sber_field_RWB_set(b, h, index_a, access_type);

    /* flush buffer */
    sber_buffer_flush( b );

    PMC_RETURN(PMC_SUCCESS);
} /* _sber_indirect_access */


/*******************************************************************************
* _sber_indirect_read
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Performs an indirect read access for SBER_INDIRECT indirect memory
*
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   iaddr        - indirect memory address to access
*   *b           - pointer to buffer containing read data
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR _sber_indirect_read(sdh_pmg_handle_t *h,
                                      UINT32 index_a,
                                      UINT32 iaddr,
                                      sber_indirect_buffer_t *b)
{
    UINT32 result;
    UINT32 sber_rst, chn_low_pwr, top_rst;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (b == NULL) || 
        (index_a > 3) ||
        (iaddr > SBER_IADDR_MAX))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    sber_rst = sdh_pmg_field_CH_SBER_U_SW_RST_get(NULL, h, (3-index_a));
    chn_low_pwr = sdh_pmg_field_CH_LOW_PWR_get(NULL, h, (3-index_a));
    top_rst = sdh_pmg_field_TOP_SW_RST_get(NULL, h);
    if (sber_rst | chn_low_pwr | top_rst) {
        PMC_RETURN(PMC_ERR_FAIL);
    }

    /* poll BUSY bit to ensure register is ready indirect access */
    result = sber_field_BUSY_poll(NULL, 
                                      h, index_a, 
                                      SBER_IND_BUSY_COMPLETE, 
                                      PMC_POLL_EQUAL,
                                      SBER_POLL_ITERATIONS, 
                                      NULL, 
                                      SBER_USEC_DELAY_TICKS);
    
    if (result != PMC_SUCCESS) 
    {
        LOG("sber_field_BUSY_poll failed...");
        PMC_RETURN(result);
    }
    
    /* initiate the indirect read access */
    result = _sber_indirect_access(h, index_a, iaddr, SBER_IND_READ);
    if (result != PMC_SUCCESS) PMC_RETURN(result);

    /* poll BUSY bit to ensure data is ready to be read */
    result = sber_field_BUSY_poll(NULL, 
                                      h, index_a, 
                                      SBER_IND_BUSY_COMPLETE, 
                                      PMC_POLL_EQUAL,
                                      SBER_POLL_ITERATIONS, 
                                      NULL, 
                                      SBER_USEC_DELAY_TICKS);
    if (result != PMC_SUCCESS) 
    {
        LOG("sber_field_BUSY_poll failed...");
        PMC_RETURN(result);
    }

    /* read indirect access data from indirect data registers */
    b->data[0] = sber_field_DATA_get(NULL, h, index_a);
    b->mask[0] = SBER_REG_IND_DATA_BIT_DATA_MSK;

    PMC_RETURN(PMC_SUCCESS);
} /* _sber_indirect_read */


/*******************************************************************************
* _sber_indirect_read_modify_write
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Performs an indirect read/modify/write access for SBER_INDIRECT indirect memory
*
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   iaddr        - indirect memory address to access
*   *b           - pointer to buffer for data to be written
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR _sber_indirect_read_modify_write(sdh_pmg_handle_t *h,
                                      UINT32 index_a,
                                      UINT32 iaddr,
                                      sber_indirect_buffer_t *b)
{
    sber_indirect_buffer_t tmp_b;
    UINT32 access_data;
    UINT32 result;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (b == NULL) || 
        (index_a > 3) ||
        (iaddr > SBER_IADDR_MAX))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* read and update the data of indirect data registers */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)&tmp_b);
    if (result != PMC_SUCCESS) PMC_RETURN(result);

    access_data = tmp_b.data[0];

    access_data = (access_data & ~(b->mask[0])) | (b->data[0]);

    /* write indirect access data to indirect data registers */
    sber_field_DATA_set(NULL, h, index_a, access_data);

    /* initiate the indirect write access */
    result = _sber_indirect_access(h, index_a, iaddr, SBER_IND_WRITE);
    if (result != PMC_SUCCESS) PMC_RETURN(result);

    /* poll BUSY bit to ensure indirect write access completes */
    result = sber_field_BUSY_poll(NULL, 
                        h, index_a, 
                        SBER_IND_BUSY_COMPLETE, 
                        PMC_POLL_EQUAL,
                        SBER_POLL_ITERATIONS, 
                        NULL, 
                        SBER_USEC_DELAY_TICKS);
    if (result != PMC_SUCCESS) 
    {
        LOG("sber_field_BUSY_poll failed...");
        PMC_RETURN(result);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* _sber_indirect_read_modify_write */



/*******************************************************************************
* sber_indirect_SD_SF_BERM_STAT_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies SD_SF_BERM_STAT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_SF_BERM_STAT_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_SF_BERM_STAT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_SF_BERM_STAT;

    result = _sber_indirect_read_modify_write(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_SF_BERM_STAT_buffer_apply */



/*******************************************************************************
* sber_indirect_SD_SF_BERM_STAT_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SD_SF_BERM_STAT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_SF_BERM_STAT_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_SF_BERM_STAT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_SF_BERM_STAT;

    /*
    PMC_OS_MUTEX_LOCK(sber_indirect_lock);
    */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_SF_BERM_STAT_buffer_apply */




/*******************************************************************************
* sber_indirect_SD_SF_BERM_INT_EN_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies SD_SF_BERM_INT_EN data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_SF_BERM_INT_EN_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_SF_BERM_INT_EN_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_SF_BERM_INT_EN;

    result = _sber_indirect_read_modify_write(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_SF_BERM_INT_EN_buffer_apply */



/*******************************************************************************
* sber_indirect_SD_SF_BERM_INT_EN_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SD_SF_BERM_INT_EN data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_SF_BERM_INT_EN_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_SF_BERM_INT_EN_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_SF_BERM_INT_EN;

    /*
    PMC_OS_MUTEX_LOCK(sber_indirect_lock);
    */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_SF_BERM_INT_EN_buffer_apply */




/*******************************************************************************
* sber_indirect_SD_SF_BERM_INT_STAT_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies SD_SF_BERM_INT_STAT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_SF_BERM_INT_STAT_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_SF_BERM_INT_STAT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_SF_BERM_INT_STAT;

    result = _sber_indirect_read_modify_write(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_SF_BERM_INT_STAT_buffer_apply */



/*******************************************************************************
* sber_indirect_SD_SF_BERM_INT_STAT_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SD_SF_BERM_INT_STAT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_SF_BERM_INT_STAT_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_SF_BERM_INT_STAT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_SF_BERM_INT_STAT;

    /*
    PMC_OS_MUTEX_LOCK(sber_indirect_lock);
    */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_SF_BERM_INT_STAT_buffer_apply */




/*******************************************************************************
* sber_indirect_SD_BERM_BER_TH_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies SD_BERM_BER_TH data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_BERM_BER_TH_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_BERM_BER_TH_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_BERM_BER_TH;

    result = _sber_indirect_read_modify_write(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_BERM_BER_TH_buffer_apply */



/*******************************************************************************
* sber_indirect_SD_BERM_BER_TH_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SD_BERM_BER_TH data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_BERM_BER_TH_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_BERM_BER_TH_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_BERM_BER_TH;

    /*
    PMC_OS_MUTEX_LOCK(sber_indirect_lock);
    */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_BERM_BER_TH_buffer_apply */




/*******************************************************************************
* sber_indirect_SD_BERM_SET_TH_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies SD_BERM_SET_TH data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_BERM_SET_TH_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_BERM_SET_TH_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_BERM_SET_TH;

    result = _sber_indirect_read_modify_write(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_BERM_SET_TH_buffer_apply */



/*******************************************************************************
* sber_indirect_SD_BERM_SET_TH_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SD_BERM_SET_TH data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_BERM_SET_TH_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_BERM_SET_TH_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_BERM_SET_TH;

    /*
    PMC_OS_MUTEX_LOCK(sber_indirect_lock);
    */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_BERM_SET_TH_buffer_apply */




/*******************************************************************************
* sber_indirect_SD_BERM_CLEAR_TH_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies SD_BERM_CLEAR_TH data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_BERM_CLEAR_TH_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_BERM_CLEAR_TH_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_BERM_CLEAR_TH;

    result = _sber_indirect_read_modify_write(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_BERM_CLEAR_TH_buffer_apply */



/*******************************************************************************
* sber_indirect_SD_BERM_CLEAR_TH_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SD_BERM_CLEAR_TH data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_BERM_CLEAR_TH_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_BERM_CLEAR_TH_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_BERM_CLEAR_TH;

    /*
    PMC_OS_MUTEX_LOCK(sber_indirect_lock);
    */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_BERM_CLEAR_TH_buffer_apply */




/*******************************************************************************
* sber_indirect_SD_PATH_MONING_EN_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies SD_PATH_MONING_EN data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_PATH_MONING_EN_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_PATH_MONING_EN_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_PATH_MONING_EN;

    result = _sber_indirect_read_modify_write(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_PATH_MONING_EN_buffer_apply */



/*******************************************************************************
* sber_indirect_SD_PATH_MONING_EN_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SD_PATH_MONING_EN data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_PATH_MONING_EN_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_PATH_MONING_EN_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_PATH_MONING_EN;

    /*
    PMC_OS_MUTEX_LOCK(sber_indirect_lock);
    */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_PATH_MONING_EN_buffer_apply */




/*******************************************************************************
* sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_2_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies SD_BERM_SET_INTEGRATION_PERIOD_2 data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_2_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_2_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_BERM_SET_INTEGRATION_PERIOD_2;

    result = _sber_indirect_read_modify_write(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_2_buffer_apply */



/*******************************************************************************
* sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_2_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SD_BERM_SET_INTEGRATION_PERIOD_2 data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_2_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_2_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_BERM_SET_INTEGRATION_PERIOD_2;

    /*
    PMC_OS_MUTEX_LOCK(sber_indirect_lock);
    */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_2_buffer_apply */




/*******************************************************************************
* sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_1_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies SD_BERM_SET_INTEGRATION_PERIOD_1 data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_1_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_1_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_BERM_SET_INTEGRATION_PERIOD_1;

    result = _sber_indirect_read_modify_write(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_1_buffer_apply */



/*******************************************************************************
* sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_1_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SD_BERM_SET_INTEGRATION_PERIOD_1 data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_1_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_1_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SD_BERM_SET_INTEGRATION_PERIOD_1;

    /*
    PMC_OS_MUTEX_LOCK(sber_indirect_lock);
    */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SD_BERM_SET_INTEGRATION_PERIOD_1_buffer_apply */




/*******************************************************************************
* sber_indirect_SF_BERM_BER_TH_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies SF_BERM_BER_TH data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SF_BERM_BER_TH_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SF_BERM_BER_TH_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SF_BERM_BER_TH;

    result = _sber_indirect_read_modify_write(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SF_BERM_BER_TH_buffer_apply */



/*******************************************************************************
* sber_indirect_SF_BERM_BER_TH_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SF_BERM_BER_TH data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SF_BERM_BER_TH_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SF_BERM_BER_TH_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SF_BERM_BER_TH;

    /*
    PMC_OS_MUTEX_LOCK(sber_indirect_lock);
    */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SF_BERM_BER_TH_buffer_apply */




/*******************************************************************************
* sber_indirect_SF_BERM_SET_TH_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies SF_BERM_SET_TH data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SF_BERM_SET_TH_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SF_BERM_SET_TH_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SF_BERM_SET_TH;

    result = _sber_indirect_read_modify_write(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SF_BERM_SET_TH_buffer_apply */



/*******************************************************************************
* sber_indirect_SF_BERM_SET_TH_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SF_BERM_SET_TH data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SF_BERM_SET_TH_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SF_BERM_SET_TH_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SF_BERM_SET_TH;

    /*
    PMC_OS_MUTEX_LOCK(sber_indirect_lock);
    */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SF_BERM_SET_TH_buffer_apply */




/*******************************************************************************
* sber_indirect_SF_BERM_CLEAR_TH_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies SF_BERM_CLEAR_TH data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SF_BERM_CLEAR_TH_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SF_BERM_CLEAR_TH_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SF_BERM_CLEAR_TH;

    result = _sber_indirect_read_modify_write(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SF_BERM_CLEAR_TH_buffer_apply */



/*******************************************************************************
* sber_indirect_SF_BERM_CLEAR_TH_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SF_BERM_CLEAR_TH data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SF_BERM_CLEAR_TH_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SF_BERM_CLEAR_TH_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SF_BERM_CLEAR_TH;

    /*
    PMC_OS_MUTEX_LOCK(sber_indirect_lock);
    */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SF_BERM_CLEAR_TH_buffer_apply */




/*******************************************************************************
* sber_indirect_SF_PATH_MONING_EN_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies SF_PATH_MONING_EN data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SF_PATH_MONING_EN_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SF_PATH_MONING_EN_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SF_PATH_MONING_EN;

    result = _sber_indirect_read_modify_write(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SF_PATH_MONING_EN_buffer_apply */



/*******************************************************************************
* sber_indirect_SF_PATH_MONING_EN_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SF_PATH_MONING_EN data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SF_PATH_MONING_EN_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SF_PATH_MONING_EN_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SF_PATH_MONING_EN;

    /*
    PMC_OS_MUTEX_LOCK(sber_indirect_lock);
    */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SF_PATH_MONING_EN_buffer_apply */




/*******************************************************************************
* sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_2_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies SF_BERM_SET_INTEGRATION_PERIOD_2 data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_2_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_2_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SF_BERM_SET_INTEGRATION_PERIOD_2;

    result = _sber_indirect_read_modify_write(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_2_buffer_apply */



/*******************************************************************************
* sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_2_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SF_BERM_SET_INTEGRATION_PERIOD_2 data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_2_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_2_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SF_BERM_SET_INTEGRATION_PERIOD_2;

    /*
    PMC_OS_MUTEX_LOCK(sber_indirect_lock);
    */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_2_buffer_apply */




/*******************************************************************************
* sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_1_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies SF_BERM_SET_INTEGRATION_PERIOD_1 data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_1_buffer_apply(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_1_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SF_BERM_SET_INTEGRATION_PERIOD_1;

    result = _sber_indirect_read_modify_write(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_1_buffer_apply */



/*******************************************************************************
* sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_1_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SF_BERM_SET_INTEGRATION_PERIOD_1 data buffer to the device.
*
* INPUTS:
*   *h           - pointer to SDH_PMG handle instance to be operated on
*   index_a      - SBER slice instance index_a=0:3 to access
*   *b           - pointer to SBER_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_1_buffer_retrieve(sdh_pmg_handle_t * h,  
                                      UINT32 index_a,
                                      sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_1_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SBER_INDIRECT_REG_SF_BERM_SET_INTEGRATION_PERIOD_1;

    /*
    PMC_OS_MUTEX_LOCK(sber_indirect_lock);
    */
    result = _sber_indirect_read(h, index_a, iaddr, (sber_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
        PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
    PMC_OS_MUTEX_UNLOCK(sber_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* sber_indirect_SF_BERM_SET_INTEGRATION_PERIOD_1_buffer_apply */




