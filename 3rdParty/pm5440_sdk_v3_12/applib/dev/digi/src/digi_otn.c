/*******************************************************************************
*   COPYRIGHT (C) 2011 PMC-SIERRA, INC. ALL RIGHTS RESERVED.
* --------------------------------------------------------------------------
*  This software embodies materials and concepts which are proprietary and
*  confidential to PMC-Sinrra, Inc.
*  PMC-Sierra distributes this software to its customers pursuant to the
*  terms and conditions of the Software License Agreement
*  contained in the text file software.lic that is distributed along with
*  the software. This software can only be utilized if all
*  terms and conditions of the Software License Agreement are
*  accepted. If there are any questions, concerns, or if the
*  Software License Agreement text file, software.lic, is missing please
*  contact PMC-Sierra for assistance.
* --------------------------------------------------------------------------
*   DESCRIPTION : This file contains C functions for operating OTN features.
*
*   NOTES:
*
*******************************************************************************/
/*
** Include Files
*/

#include "digi_loc.h"
#include "digi_api.h"
#include "odu_struct.h"

/*
** Local Enumerated Types
*/

/*
** Local Constants
*/

#define DIGI_MSTAT_COUNT_NUM    65

/**/

/*
** Local Macro Definitions
*/
#define DIGI_MSTATX_FIELD_GET(field_name, field_index)                                  \
do{                                                                                     \
    PMC_ASSERT(field_index<DIGI_MSTAT_COUNT_NUM, DIGI_ERR_CODE_ASSERT, 0, 0);                 \
    counts_ptr->field_name##_lsb = enet_fege_mstatx_retrieve(h, field_index, FALSE);    \
    counts_ptr->field_name##_msb = enet_fege_mstatx_retrieve(h, field_index, TRUE);     \
}while(0)

#define DIGI_MSTATX_COUNTS_RETRIEVE()\
    DIGI_MSTATX_FIELD_GET(rx_frames_ok,                  0);\
    DIGI_MSTATX_FIELD_GET(rx_octets_ok,                  1);\
    DIGI_MSTATX_FIELD_GET(rx_frames,                     2);\
    DIGI_MSTATX_FIELD_GET(rx_octets,                     3);\
    DIGI_MSTATX_FIELD_GET(rx_unicast_frms_ok,            4);\
    DIGI_MSTATX_FIELD_GET(rx_broadcast_frms_ok,          5);\
    DIGI_MSTATX_FIELD_GET(rx_multicast_frms_ok,          6);\
    DIGI_MSTATX_FIELD_GET(rx_tagged_frms_ok,             7);\
    DIGI_MSTATX_FIELD_GET(rx_mac_pause_ctrl_frm_ok,      8);\
    DIGI_MSTATX_FIELD_GET(rx_mac_ctrl_frms_ok,           9);\
    DIGI_MSTATX_FIELD_GET(rx_fcs_err,                   10);\
    DIGI_MSTATX_FIELD_GET(rx_reserved,                  11);\
    DIGI_MSTATX_FIELD_GET(rx_symbol_err,                12);\
    DIGI_MSTATX_FIELD_GET(rx_layer1_err,                13);\
    DIGI_MSTATX_FIELD_GET(rx_in_range_length_err,       14);\
    DIGI_MSTATX_FIELD_GET(rx_long_length_err,           15);\
    DIGI_MSTATX_FIELD_GET(rx_long_length_crc_err,       16);\
    DIGI_MSTATX_FIELD_GET(rx_short_length_error,        17);\
    DIGI_MSTATX_FIELD_GET(rx_short_length_crc_error,    18);\
    DIGI_MSTATX_FIELD_GET(rx_frms_64_octs,              19);\
    DIGI_MSTATX_FIELD_GET(rx_frms_65_to_127_octs,       20);\
    DIGI_MSTATX_FIELD_GET(rx_frms_128_to_255_octs,      21);\
    DIGI_MSTATX_FIELD_GET(rx_frms_256_to_511_octs,      22);\
    DIGI_MSTATX_FIELD_GET(rx_frms_512_to_1023_octs,     23);\
    DIGI_MSTATX_FIELD_GET(rx_frms_1024_to_1518_octs,    24);\
    DIGI_MSTATX_FIELD_GET(rx_frms_1519_to_max,          25);\
    DIGI_MSTATX_FIELD_GET(rx_station_addr_fltr,         26);\
    DIGI_MSTATX_FIELD_GET(rx_variable,                  27);\
    DIGI_MSTATX_FIELD_GET(rx_frms_1519_to_1522_octs,    28);\
    DIGI_MSTATX_FIELD_GET(rx_frms_1523_to_1548_octs,    29);\
    DIGI_MSTATX_FIELD_GET(rx_frms_1549_to_2000_octs,    30);\
    DIGI_MSTATX_FIELD_GET(rx_frms_2001_to_2500_octs,    31);\
    DIGI_MSTATX_FIELD_GET(rx_frms_2501_to_max,          32);\
    DIGI_MSTATX_FIELD_GET(tx_frames_ok,                 33);\
    DIGI_MSTATX_FIELD_GET(tx_octets_ok,                 34);\
    DIGI_MSTATX_FIELD_GET(tx_octets,                    35);\
    DIGI_MSTATX_FIELD_GET(tx_tagged_frms_ok,            36);\
    DIGI_MSTATX_FIELD_GET(tx_mac_pause_ctrl_frms,       37);\
    DIGI_MSTATX_FIELD_GET(tx_fcs_err,                   38);\
    DIGI_MSTATX_FIELD_GET(tx_short_length_err,          39);\
    DIGI_MSTATX_FIELD_GET(tx_long_length_err,           40);\
    DIGI_MSTATX_FIELD_GET(tx_system_err,                41);\
    DIGI_MSTATX_FIELD_GET(tx_mac_err,                   42);\
    DIGI_MSTATX_FIELD_GET(tx_jumbo_frms,                43);\
    DIGI_MSTATX_FIELD_GET(tx_mac_ctrl_frms_ok,          44);\
    DIGI_MSTATX_FIELD_GET(tx_unicast_frms_ok,           45);\
    DIGI_MSTATX_FIELD_GET(tx_broadcast_frms_ok,         46);\
    DIGI_MSTATX_FIELD_GET(tx_multicast_frms_ok,         47);\
    DIGI_MSTATX_FIELD_GET(tx_unicast_frms_attempted,    48);\
    DIGI_MSTATX_FIELD_GET(tx_broadcast_frms_attempted,  49);\
    DIGI_MSTATX_FIELD_GET(tx_multicast_frms_attempted,  50);\
    DIGI_MSTATX_FIELD_GET(tx_frms_64_octs,              51);\
    DIGI_MSTATX_FIELD_GET(tx_frms_65_to_127_octs,       52);\
    DIGI_MSTATX_FIELD_GET(tx_frms_128_to_255_octs,      53);\
    DIGI_MSTATX_FIELD_GET(tx_frms_256_to_511_octs,      54);\
    DIGI_MSTATX_FIELD_GET(tx_frms_512_to_1023_octs,     55);\
    DIGI_MSTATX_FIELD_GET(tx_frms_1024_to_1518_octs,    56);\
    DIGI_MSTATX_FIELD_GET(tx_frms_1519_to_max,          57);\
    DIGI_MSTATX_FIELD_GET(tx_variable,                  58);\
    DIGI_MSTATX_FIELD_GET(rx_jumbo_frms_ok,             59);\
    DIGI_MSTATX_FIELD_GET(tx_frms_1519_to_1522_octs,    60);\
    DIGI_MSTATX_FIELD_GET(tx_frms_1523_to_1548_octs,    61);\
    DIGI_MSTATX_FIELD_GET(tx_frms_1549_to_2000_octs,    62);\
    DIGI_MSTATX_FIELD_GET(tx_frms_2001_to_2500_octs,    63);\
    DIGI_MSTATX_FIELD_GET(tx_frms_2501_to_max,          64);\

/*
** Local Structures and Unions
*/

/*
** Local Variables
*/

/*
** Log Messaging
*/

/*
** Forward References 
*/
#ifndef DOXYGEN_PUBLIC_ONLY
PRIVATE BOOL digi_otn_is_stg3b_present(digi_handle_t        *digi_handle,
                                       digi_otn_odu_chnl_t  *chnl_ptr);
PRIVATE BOOL8 digi_di_rcp_pmon_is_selected(UINT32                   di_rcp_pdu);

PRIVATE PMC_ERROR digi_di_rcp_fw_pmon_cfg(digi_handle_t         *digi_handle,
                                          digi_di_rcp_pmon_cfg_t cfg);
                                            
PRIVATE UINT32 digi_otn_server_chnl_num_internal_get(digi_handle_t              *digi_handle,
                                                     digi_otn_server_chnl_t     *chnl_handle);
PRIVATE UINT32 digi_otn_server_stream_num_internal_get(digi_handle_t              *digi_handle,
                                                       digi_otn_server_chnl_t     *chnl_handle);
PRIVATE odu_struct_odu_level_t digi_otn_odu_level_internal_get(digi_handle_t              *digi_handle,
                                                      digi_otn_odu_chnl_t        *chnl_handle);
PRIVATE PMC_ERROR digi_otn_pmon_ptr_get(digi_handle_t                            *digi_handle,
                                        digi_otn_odu_chnl_t                      *chnl_handle,
                                        digi_pmon_t                              *fw_pmon_ptr,
                                        digi_pmon_coreotn_odukt_counters_t      **tcm_pptr,
                                        digi_pmon_coreotn_odukp_counters_t      **pm_pptr,
                                        digi_pmon_coreotn_odukp_prbs_counter_t  **prbs_pptr);
PRIVATE PMC_ERROR digi_otn_server_pmon_chnl_retrieve_internal(digi_handle_t                *digi_handle,
                                                              digi_otn_server_chnl_t       *chnl_handle,
                                                              digi_otn_server_pmon_chnl_t  *pmon_table_ptr);
PRIVATE PMC_ERROR digi_otn_odu_pmon_retrieve(digi_handle_t              *digi_handle,
                                             odu_struct_odu_level_t      odu_level,
                                             digi_otn_pmon_t            *pmon_table_ptr);

PRIVATE PMC_ERROR digi_otn_server_int_enable_internal(digi_handle_t        *digi_handle,
                                                      digi_int_type_t       int_type,
                                                      lineotn_int_t        *int_table_ptr,
                                                      BOOL                  enable);

PRIVATE PMC_ERROR digi_otn_odu_int_framer_chnl_enable_internal(digi_handle_t             *digi_handle,
                                                               digi_otn_odu_chnl_t       *chnl_handle,
                                                               coreotn_int_framer_chnl_t *int_table_ptr,
                                                               BOOL                       enable);

PRIVATE PMC_ERROR digi_otn_odu_int_framer_chnl_stage_enable(digi_handle_t             *digi_handle,
                                                            digi_otn_odu_chnl_t       *chnl_handle,
                                                            odu_struct_odu_level_t     odu_level,
                                                            coreotn_int_framer_chnl_t *int_table_ptr,
                                                            BOOL                       enable);

PRIVATE PMC_ERROR digi_otn_odu_int_stg3b_chnl_enable_internal(digi_handle_t             *digi_handle,
                                                              digi_otn_odu_chnl_t       *chnl_handle,
                                                              coreotn_int_framer_chnl_t *int_table_ptr,
                                                              BOOL                       enable);

PRIVATE PMC_ERROR digi_otn_odu_int_pid_chnl_enable_internal(digi_handle_t                 *digi_handle,
                                                            digi_otn_odu_chnl_t           *chnl_handle,
                                                            digi_otn_int_tcm_num_t         tcm_num,
                                                            odu_rfrm_int_pid_chnl_t       *int_table_ptr,
                                                            BOOL                           enable);

PRIVATE PMC_ERROR digi_otn_odu_int_pid_chnl_stage_enable(digi_handle_t                 *digi_handle,
                                                         odu_struct_odu_level_t         odu_level,
                                                         UINT32                         pool_id,
                                                         odu_rfrm_int_pid_chnl_t       *int_table_ptr,
                                                         BOOL                           enable);

PRIVATE PMC_ERROR digi_otn_odu_int_prbs_chnl_enable_internal(digi_handle_t              *digi_handle,
                                                             digi_otn_odu_chnl_t        *chnl_handle,
                                                             coreotn_int_prbs_chnl_t    *int_table_ptr,
                                                             BOOL                        enable);

PRIVATE PMC_ERROR digi_otn_server_int_chnl_retrieve(digi_handle_t            *digi_handle,
                                                    digi_int_type_t           int_type,
                                                    digi_otn_int_t           *int_table_ptr);

PRIVATE PMC_ERROR digi_otn_odu_int_chnl_stage_retrieve(digi_handle_t             *digi_handle,
                                                       digi_otn_odu_chnl_t       *chnl_handle,
                                                       odu_struct_odu_level_t     odu_level,
                                                       digi_otn_int_filter_t     *int_filter_ptr,
                                                       digi_otn_int_t            *int_table_ptr);

PRIVATE PMC_ERROR digi_otn_lineotn_int_enabled_get(digi_handle_t            *digi_handle,
                                                   digi_otn_int_t           *int_table_ptr);

PRIVATE PMC_ERROR digi_otn_server_int_enabled_get(digi_handle_t            *digi_handle,
                                                  digi_otn_server_chnl_t   *chnl_handle,
                                                  digi_int_type_t           int_type,
                                                  digi_otn_int_t           *int_table_ptr);

PRIVATE PMC_ERROR digi_otn_coreotn_int_enabled_get(digi_handle_t            *digi_handle,
                                                   digi_otn_int_t           *int_table_ptr);

PRIVATE PMC_ERROR digi_otn_odu_int_chnl_stage_enabled_get(digi_handle_t             *digi_handle,
                                                          digi_otn_odu_chnl_t       *chnl_handle,
                                                          odu_struct_odu_level_t     odu_level,
                                                          digi_otn_int_t            *int_table_ptr);


PRIVATE PMC_ERROR digi_otn_server_int_chnl_enabled_check_internal(digi_handle_t                 *digi_handle,
                                                                 digi_int_type_t                int_type,
                                                                 digi_otn_int_t                *int_en_table_ptr,
                                                                 digi_otn_server_int_summary_t *int_summary_ptr);


PRIVATE PMC_ERROR digi_otn_server_int_chnl_enabled_check_helper(digi_handle_t            *digi_handle,
                                                                digi_otn_server_chnl_t   *chnl_handle,
                                                                lineotn_handle_t         *lineotn_handle,
                                                                lineotn_int_chnl_t       *int_en_table_ptr,
                                                                digi_int_type_t           int_type,
                                                                BOOL                     *int_found_ptr);
PRIVATE PMC_ERROR digi_otn_server_int_ddeg_chnl_enabled_check(digi_handle_t          *digi_handle,
                                                              digi_otn_server_chnl_t *chnl_handle,
                                                              lineotn_int_chnl_t     *int_en_table_ptr,
                                                              BOOL8 is_line,
                                                              BOOL                   *int_found_ptr);
PRIVATE PMC_ERROR digi_otn_pmon_ddeg_hw_blk_get(digi_handle_t *digi_handle,
                                                odu_struct_frm_id_t odu_frm_id,
                                                odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                digi_pmon_ddeg_hw_block_t *ddeg_hw_blk);

PRIVATE PMC_ERROR digi_otn_odu_int_pid_chnl_ddeg_enable(digi_handle_t             *digi_handle,
                                                        odu_struct_odu_level_t     odu_level,
                                                        coreotn_int_source_t       source, 
                                                        UINT32                     start_pid,
                                                        UINT32                     end_pid,
                                                        odu_rfrm_int_pid_chnl_t   *int_table_ptr,
                                                        odu_rfrm_int_pid_chnl_t   *int_en_table_ptr,
                                                        BOOL                       enable);
PRIVATE PMC_ERROR digi_otn_odu_int_pid_range_get(digi_handle_t          *digi_handle,
                                                 odu_struct_odu_level_t  odu_level,
                                                 UINT32                  pool_id,
                                                 UINT32                 *pid_start,
                                                 UINT32                 *pid_end);
PRIVATE PMC_ERROR digi_otn_ddeg_int_latch(digi_handle_t             *digi_handle,
                                          digi_otn_odu_chnl_t       *chnl_handle,
                                          digi_int_type_t            int_type);

PRIVATE PMC_ERROR digi_otn_odu_int_ddeg_cfg(digi_handle_t             *digi_handle,
                                            digi_pmon_ddeg_mode_t      ddeg_mode,        
                                            odu_struct_odu_level_t     odu_level,
                                            coreotn_int_source_t       source, 
                                            BOOL                       is_tcm,
                                            UINT32                     start_chnl,
                                            UINT32                     end_chnl,
                                            BOOL                       enable);
PRIVATE PMC_ERROR digi_otn_server_int_enabled_check_internal(digi_handle_t            *digi_handle,
                                                             digi_int_type_t           int_type,
                                                             digi_otn_server_chnl_t   *chnl_handle,
                                                             digi_otn_int_t           *int_en_table_ptr,
                                                             BOOL                     *int_found_ptr);
PRIVATE PMC_ERROR digi_otn_server_int_chnl_ddeg_enable(digi_handle_t             *digi_handle,
                                                       coreotn_int_source_t       source, 
                                                       UINT32                     start_chnl,
                                                       UINT32                     end_chnl,
                                                       lineotn_int_chnl_t        *int_table_ptr,
                                                       lineotn_int_chnl_t        *int_en_table_ptr,
                                                       BOOL                       enable);
PRIVATE PMC_ERROR digi_otn_server_int_ddeg_cfg(digi_handle_t             *digi_handle,
                                               digi_pmon_ddeg_mode_t      ddeg_mode,        
                                               coreotn_int_source_t       source, 
                                               UINT32                     start_chnl,
                                               UINT32                     end_chnl,
                                               BOOL                       enable);
PRIVATE PMC_ERROR digi_otn_server_int_ddeg_retrieve(digi_handle_t *digi_handle,
                                                    digi_int_type_t int_type,
                                                    digi_otn_int_t *int_table_ptr);
PRIVATE PMC_ERROR digi_otn_server_int_ddeg_chnl_retrieve(digi_handle_t            *digi_handle,
                                                         UINT32                    chnl_num,
                                                         coreotn_int_source_t      source,
                                                         lineotn_int_chnl_t       *int_en_table_ptr,
                                                         lineotn_int_chnl_t       *int_table_ptr);
PRIVATE BOOL digi_otn_int_filt_is_otn_server(digi_otn_int_filter_t   *int_filter_ptr);
PRIVATE BOOL digi_otn_int_filt_is_otn_odu(digi_otn_int_filter_t   *int_filter_ptr);
PRIVATE BOOL digi_otn_int_filt_is_otn_stg3b(digi_otn_int_filter_t   *int_filter_ptr);
PRIVATE BOOL digi_otn_int_filt_is_ohp(digi_otn_int_filter_t   *int_filter_ptr);
PRIVATE BOOL digi_otn_int_filt_is_rcp(digi_otn_int_filter_t   *int_filter_ptr);
PRIVATE PMC_ERROR digi_otn_odu_int_chnl_filt_retrieve_internal(digi_handle_t              *digi_handle,
                                                               digi_otn_odu_chnl_t        *chnl_handle,
                                                               digi_otn_int_filter_t      *int_filter_ptr,
                                                               coreotn_int_chnl_t         *filt_table_ptr,
                                                               digi_otn_odu_int_chnl_t    *int_table_ptr);
PRIVATE PMC_ERROR digi_otn_server_int_chnl_filt_retrieve_internal(digi_handle_t            *digi_handle,
                                                                  digi_otn_server_chnl_t   *chnl_handle,
                                                                  lineotn_int_chnl_t       *filt_table_ptr,
                                                                  lineotn_int_chnl_t       *int_table_ptr);
PRIVATE PMC_ERROR digi_otn_int_filt_retrieve_internal(digi_handle_t           *digi_handle,
                                                      digi_otn_int_filter_t   *int_filter_ptr,
                                                      BOOL8 yield_on_true,
                                                      digi_otn_int_t          *int_table_ptr);

PRIVATE PMC_ERROR digi_otn_cal_entries_get(digi_handle_t * digi_handle,
                                            BOOL rx_db,
                                            UINT32 ch_id,
                                            odu_struct_frm_id_t frm_id,  
                                            UINT32 *cal_entry_ptr,
                                            UINT32 *num_cal_entries);
PRIVATE PMC_ERROR digi_otn_cal_entries_count_get(digi_handle_t * digi_handle,
                                                 BOOL rx_db,
                                                 UINT32 ch_id,
                                                 odu_struct_frm_id_t frm_id,  
                                                 UINT32 *num_cal_entries);
PRIVATE BOOL digi_otn_odu_int_prbs_is_prov(digi_handle_t            *digi_handle,
                                           digi_otn_odu_chnl_t      *chnl_handle,
                                           UINT32                   *prbs_chnl_ptr,
                                           coreotn_prbs_inst_t      *prbs_inst_ptr, 
                                           coreotn_int_prbs_chnl_t **prbs_en_pptr);

PRIVATE PMC_ERROR digi_otn_odu_int_prbs_info_get(digi_handle_t          *digi_handle,
                                                 digi_otn_odu_chnl_t    *chnl_handle,
                                                 UINT32                 *prbs_chnl_ptr,
                                                 coreotn_prbs_inst_t    *prbs_inst_ptr);

PRIVATE odu_struct_t *digi_otn_framer_odu_struct_get(digi_handle_t *digi_handle,
                                                     digi_otn_odu_chnl_t *chnl_ptr,
                                                     UINT32 *ch_id,
                                                     odu_struct_frm_id_t *frm_id);

PRIVATE PMC_ERROR digi_otn_otu_handle_get(digi_handle_t *digi_handle,
                                          digi_otn_server_chnl_def_t *otn_server_ptr,
                                          lineotn_handle_t **hndl);

PRIVATE PMC_ERROR digi_otn_odu_deg_chnl_get(digi_handle_t                  *digi_handle,
                                           digi_otn_odu_chnl_t            *chnl_ptr,
                                           odu_struct_odu_frm_pm_tcm_id_t  pm_tcm_num,
                                           UINT32                         *deg_chnl_ptr);

PRIVATE PMC_ERROR digi_otn_odu_int_en_ohp_get(digi_handle_t              *digi_handle,
                                              odu_ohp_inst_t              ohp,
                                              odu_ohp_int_chnl_t        **ohp_en_pptr);

PRIVATE PMC_ERROR digi_otn_odu_int_ohp_chnl_enable_internal(digi_handle_t             *digi_handle,
                                                            odu_ohp_inst_t              ohp,
                                                            digi_otn_odu_chnl_t       *chnl_handle,
                                                            odu_ohp_int_chnl_t *int_table_ptr,
                                                            BOOL                       enable);

PRIVATE PMC_ERROR digi_otn_odu_int_ohp_one_chnl_enable(digi_handle_t             *digi_handle,
                                                       odu_ohp_inst_t             ohp,
                                                       digi_otn_odu_chnl_t       *chnl_handle,
                                                       odu_struct_odu_level_t     odu_level,
                                                       odu_ohp_int_chnl_t        *int_table_ptr,
                                                       BOOL                       enable);

PRIVATE PMC_ERROR digi_otn_odu_int_ri_rcp_chnl_enable_internal(digi_handle_t             *digi_handle,
                                                               digi_otn_odu_chnl_t       *chnl_handle,
                                                               odu_ri_rcp_int_chnl_t     *int_table_ptr,
                                                               BOOL                       enable);

PRIVATE PMC_ERROR digi_otn_odu_int_ri_rcp_one_chnl_enable(digi_handle_t             *digi_handle,
                                                          digi_otn_odu_chnl_t       *chnl_handle,
                                                          odu_struct_odu_level_t     odu_level,
                                                          odu_ri_rcp_int_chnl_t     *int_table_ptr,
                                                          BOOL                       enable);

PRIVATE odu_ohp_int_t *digi_otn_ohp_int_ptr_get(odu_ohp_inst_t              ohp,
                                                digi_otn_int_t             *otn_int_table_ptr);

PRIVATE PMC_ERROR digi_otn_odu_int_rcp_clear(digi_handle_t        *digi_handle,
                                             odu_rcp_inst_t        rcp_inst,
                                             odu_rcp_int_t        *int_table_ptr);

PRIVATE PMC_ERROR digi_otn_odu_ddeg_mode_internal_get(digi_handle_t           *digi_handle,
                                                      digi_otn_ddeg_mode_t     ddeg_mode,
                                                      BOOL                    *ddeg_configured,
                                                      digi_otn_ddeg_mon_seg_t *mon_seg);
PRIVATE PMC_ERROR digi_otn_server_int_filt_retrieve_internal(digi_handle_t           *digi_handle,
                                                             digi_otn_int_filter_t   *int_filter_ptr,
                                                             BOOL8 yield_on_true,
                                                             digi_otn_int_t          *int_table_ptr);
PRIVATE PMC_ERROR digi_otn_odu_int_filt_retrieve_internal(digi_handle_t          *digi_handle,
                                                          digi_otn_int_filter_t  *int_filter_ptr,
                                                          BOOL8 yield_on_true,
                                                          digi_otn_int_t         *int_table_ptr);

PRIVATE PMC_ERROR digi_otn_odu_maint_sig_set_internal(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      UINT8 direction,
                                                      coreotn_maint_sig_type_t force_alarm_sig,
                                                      BOOL odukp_pck); 

PRIVATE PMC_ERROR digi_otn_server_int_ddeg_init(digi_handle_t           *digi_handle,
                                                digi_pmon_ddeg_t        *ddeg_ptr,
                                                BOOL8 is_line,
                                                digi_pmon_ddeg_stage_t  *ddeg_stage_ptr);

PRIVATE void digi_otn_server_int_ddeg_get(digi_handle_t *digi_handle,
                                          BOOL8 is_line,
                                          digi_pmon_ddeg_stage_t **ddeg_pptr);                                           

PRIVATE PMC_ERROR digi_otn_ohp_rcp_int_filt_retrieve(digi_handle_t *digi_handle,
                                                     digi_otn_int_filter_t *int_filter_ptr,
                                                     BOOL8 yield_on_true,
                                                     digi_otn_int_t *int_table_ptr);

PRIVATE PMC_ERROR digi_otn_odu_int_filter_create(digi_handle_t *digi_handle,
                                                 coreotn_int_framer_chnl_t  *framer_filt_table_ptr,
                                                 odu_rfrm_int_pid_chnl_t    *pid_filt_table_ptr,
                                                 coreotn_int_chnl_t         **filt_table_pptr);

PRIVATE PMC_ERROR digi_otn_odu_int_ddeg_get(digi_handle_t           *digi_handle,
                                            odu_struct_odu_level_t   odu_level,
                                            digi_pmon_ddeg_stage_t **ddeg_pptr);

PRIVATE PMC_ERROR digi_otn_int_clear_internal(digi_handle_t       *digi_handle,
                                              digi_otn_int_t      *int_table_ptr);

PRIVATE void digi_otn_set_input_fo2(digi_handle_t *digi_handle,
                                    util_global_switch_data_t *input_ptr,
                                    digi_mapping_mode_t *mode_ptr,
                                    hostmsg_opsa_subsystem_cfg_t *subsystem_ptr,
                                    UINT32 *chnl_ptr,
                                    BOOL8 *bmp_mode_ptr);
#endif /*DOXYGEN_PUBLIC_ONLY */


/*
** Public Functions
*/

/*
**  Exported Interface Functions - Start
*/

/*******************************************************************************
* digi_otn_odu_defect_actions_ctrl_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Controls whethere or not a defect will contribute to consequential action
*   declarations globally.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*   defect_action_wr_mask  - Per bit mask to control which values will get set  \n
*                            Bit 0 -- write dLTC_ACT_DIS bit
*                            Bit 1 -- write dAIS_ACT_DIS bit
*                            Bit 2 -- write dOCI_ACT_DIS bit
*                            Bit 3 -- write dLCK_ACT_DIS bit
*   defect_action_values   - Values for defect control to be written \n
*                            Bit 0 -- dLTC_ACT_DIS
*                                    0 -- dLTC contributes to aBDI consequential
*                                         action declaration\n
*                                    1 -- dLTC does not contribute to aBDI
*                                         consequential action declaration\n
*                            Bit 1 -- dAIS_ACT_DIS\n
*                                    0 -- dAIS contributes to aBDI and aTSF
*                                         consequential action declaration\n
*                                    1 -- dAIS does not contribute to aBDI and 
*                                         aTSF consequential action declaration\n
*                            Bit 2 -- dOCI_ACT_DIS\n
*                                    0 -- dOCI contributes to aBDI, aTSF and 
*                                         aAIS consequential action declarations\n
*                                    1 -- dOCI does not contribute to aBDI, aTSF 
*                                         and aAIS consequential action 
*                                         declarations\n
*                            Bit 3 -- dLCK_ACT_DIS\n
*                                    0 -- dLCK contributes to aBDI, aTSF and 
*                                         aAIS consequential action declarations\n
*                                    1 -- dLCK does not contribute to aBDI, aTSF,
*                                         and aAIS consequential action 
*                                         declarations
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_defect_actions_ctrl_set(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      UINT8 defect_action_wr_mask,
                                                      UINT8 defect_action_values)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_defect_actions_ctrl_set(digi_handle->coreotn_handle,
                                                (odu_struct_t *)chnl_ptr,
                                                defect_action_values,
                                                defect_action_wr_mask,
                                                ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
    
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_defect_actions_ctrl_set */

/*******************************************************************************
* digi_otn_odu_defect_actions_ctrl_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Controls whethere or not a defect will contribute to consequential action
*   declarations globally.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*
* OUTPUTS:
*   defect_action_values   - Bit 0 -- dLTC_ACT_DIS\n
*                                    0 -- dLTC contributes to aBDI consequential
*                                         action declaration\n
*                                    1 -- dLTC does not contribute to aBDI
*                                         consequential action declaration\n
*                            Bit 1 -- dAIS_ACT_DIS\n
*                                    0 -- dAIS contributes to aBDI and aTSF
*                                         consequential action declaration\n
*                                    1 -- dAIS does not contribute to aBDI and 
*                                         aTSF consequential action declaration\n
*                            Bit 2 -- dOCI_ACT_DIS\n
*                                    0 -- dOCI contributes to aBDI, aTSF and 
*                                         aAIS consequential action declarations\n
*                                    1 -- dOCI does not contribute to aBDI, aTSF 
*                                         and aAIS consequential action 
*                                         declarations\n
*                            Bit 3 -- dLCK_ACT_DIS\n
*                                    0 -- dLCK contributes to aBDI, aTSF and 
*                                         aAIS consequential action declarations\n
*                                    1 -- dLCK does not contribute to aBDI, aTSF,
*                                         and aAIS consequential action 
*                                         declarations

*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_defect_actions_ctrl_get(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      UINT8 *defect_action_values)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_defect_actions_ctrl_get(digi_handle->coreotn_handle,
                                                (odu_struct_t *)chnl_ptr,
                                                ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                                defect_action_values);
    
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_defect_actions_ctrl_get */


/*******************************************************************************
* digi_otn_odu_pm_tcmi_bw_act_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures the generation of backward consequential actions
*   for TCM1 to TCM6 or Floating TCM layer.
*
*   When calling this API, ensure that the insertion source of BDI, BEI/BIAE
*   overhead field is set to the local Rx framer by calling 
*   digi_otn_odu_bdi_bei_biae_insert_cfg() with source == 0.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle to be operated on
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                           
*   pm_tcm_num          - PM or TCMi field instance: \n
*                         0         -- PM \n
*                         1 to 6    -- TCM1 to TCM6 \n
*                         7         -- Floating TCM1 \n
*                         8         -- PM NIM (non-intrusive monitoring)
*   bw_dis              - Controls whether or not backward consequential actions
*                         will be detected and processed. \n
*                         0 -- aBDI, aBEI and aBIAE consequential actions are
*                              detected and processed normally. \n
*                         1 -- aBDI, aBEI, and aBIAE consequential actions are
*                              disabled.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_pm_tcmi_bw_act_set(digi_handle_t *digi_handle,
                                                 digi_otn_odu_chnl_t *chnl_ptr,
                                                 odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                 UINT8 bw_dis)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_pm_tcmi_bw_act_set(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr,
                                           pm_tcm_num,
                                           bw_dis,
                                           ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
                                          
    PMC_ATOMIC_RETURN(digi_handle,result);
    
} /* digi_otn_odu_pm_tcmi_bw_act_set */

/*******************************************************************************
* digi_otn_odu_pm_tcmi_bw_act_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function extracts the mode of backward consequential actions generation
*   for PM or TCMi layer.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle to be operated on
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                           
*   pm_tcm_num          - PM or TCMi field instance: \n
*                         0         -- PM \n
*                         1 to 6    -- TCM1 to TCM6 \n
*                         7         -- Floating TCM1 \n
*                         8         -- PM NIM (non-intrusive monitoring)
*
* OUTPUTS:
*   *bw_dis             - retreived value for the mode of backward action disable
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_pm_tcmi_bw_act_get(digi_handle_t *digi_handle,
                                                 digi_otn_odu_chnl_t *chnl_ptr,
                                                 odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                 UINT8 *bw_dis)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_pm_tcmi_bw_act_get(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr,
                                           pm_tcm_num,
                                           ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                           bw_dis);
                                               
    PMC_ATOMIC_RETURN(digi_handle,result);
    
} /* digi_otn_odu_pm_tcmi_bw_act_get */

/*******************************************************************************
* digi_otn_odu_tcmi_ltc_to_ais_tsf_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   configures if a loss of tandem connection defect will contribute to the
*   generation of AIS and TSF consequenctial action for a TCM layer, 
*   a floating TCM or PM NIM layer.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                          
*   pm_tcm_num      - PM or TCMi field instance:\n
*                     1 to 6    -- TCM1 to TCM6\n
*                     7         -- Floating TCM\n
*                     8         -- PM NIM
*   dLTC_dis       - Controls whether or not dLTC defect contributes to
*                     declaration of AIS consequential action\n
*                     0 -- dLTC defect contributes to the aAIS and aTSF
*                          consequential action declaration.\n
*                     1 -- dLTC defect does not contribute to aAIS and aTSF
*                          consequential action declaration.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tcmi_ltc_to_ais_tsf_set(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                      BOOL8 dLTC_dis)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tcmi_ltc_to_ais_tsf_set(digi_handle->coreotn_handle,
                                                (odu_struct_t *)chnl_ptr,
                                                pm_tcm_num,
                                                dLTC_dis,
                                                ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tcmi_ltc_to_ais_tsf_set */

/*******************************************************************************
* digi_otn_odu_tcmi_ltc_to_ais_tsf_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retreives the mode for generation of AIS consequenctial action for a TCM 
*   layer, a floating TCM or PM NIM layer.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                          
*   pm_tcm_num      - PM or TCMi field instance:\n
*                     1 to 6    -- TCM1 to TCM6\n
*                     7         -- Floating TCM\n
*                     8         -- PM NIM
*
* OUTPUTS:
*   dLTC_dis        - mode for generation of AIS and TSF conseqeuntial action 
*                     from dLTC\n
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tcmi_ltc_to_ais_tsf_get(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                      BOOL8 *dLTC_dis)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(dLTC_dis    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tcmi_ltc_to_ais_tsf_get(digi_handle->coreotn_handle,
                                                (odu_struct_t *)chnl_ptr,
                                                pm_tcm_num,
                                                ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                                dLTC_dis);
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tcmi_ltc_to_ais_tsf_get */

/*******************************************************************************
* digi_otn_odu_pm_tcmi_tsd_tsf_dis_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   configures whether or not aTSD and aTSF consequential actions are generated  
*   as a result of TSD or TSF defect detection.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                          
*   pm_tcm_num      - PM or TCMi field instance:\n
*                     0         -- PM \n
*                     1 to 6    -- TCM1 to TCM6\n
*                     7         -- Floating TCM\n
*                     8         -- PM NIM
*   defect_ctrl     - determines which defect control to configure
*                     0 -- aTSD consequential action
*                     1 -- aTSF consequential action
*                     2 -- both aTSD and aTSF consequential actions
*   tsd_dis         - Controls the aTSD consequential action \n
*                     0 -- The aTSD consequential action is detected and
*                          processed normally. \n
*                     1 -- The aTSD consequential action is disabled.
*   tsf_dis         - Controls the aTSF consequential action \n
*                     0 -- The aTSF consequential action is detected and
*                          processed normally. \n
*                     1 -- The aTSF consequential action is disabled.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_pm_tcmi_tsd_tsf_dis_set(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                      UINT8 defect_ctrl,
                                                      UINT8 tsd_dis,
                                                      UINT8 tsf_dis)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_pm_tcmi_tsd_tsf_dis_set(digi_handle->coreotn_handle,
                                                (odu_struct_t *)chnl_ptr,
                                                pm_tcm_num,
                                                defect_ctrl,
                                                tsd_dis, tsf_dis,
                                                ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
    
} /* digi_otn_odu_pm_tcmi_tsd_tsf_dis_set */

/*******************************************************************************
* digi_otn_odu_pm_tcmi_tsd_tsf_dis_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function retreives the current configuration of aTSD and aTSF defect 
*   generation and detection control.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                          
*   pm_tcm_num      - PM or TCMi field instance:\n
*                     1 to 6    -- TCM1 to TCM6\n
*                     7         -- Floating TCM\n
*                     8         -- PM NIM
*
* OUTPUTS:
*   *tsd_dis        - current configuration to disable the aTSD consequential action \n
*   *tsf_dis        - current configuration to disable the aTSF consequential action \n
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_pm_tcmi_tsd_tsf_dis_get(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                      UINT8 *tsd_dis,
                                                      UINT8 *tsf_dis)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_pm_tcmi_tsd_tsf_dis_get(digi_handle->coreotn_handle,
                                                (odu_struct_t *)chnl_ptr,
                                                pm_tcm_num, 
                                                ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                                tsd_dis, tsf_dis);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
    
} /* digi_otn_odu_pm_tcmi_tsd_tsf_dis_get */

/*******************************************************************************
* digi_otn_odu_pm_tcmi_ais_dis_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   configures whether or not aAIS consequential actions are generated.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                          
*   pm_tcm_num      - PM or TCMi field instance:\n
*                     1 to 6    -- TCM1 to TCM6\n
*                     7         -- Floating TCM\n
*                     8         -- PM NIM
*   ais_dis             - enables or disables aAIS consequential action
*                         0 -- aAIS consequential action is detected and 
*                              processed normally. \n
*                         1 -- aAIS consequential action is disabled. \n
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_pm_tcmi_ais_dis_set(digi_handle_t *digi_handle,
                                                  digi_otn_odu_chnl_t *chnl_ptr,
                                                  odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                  UINT8 ais_dis)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_ais_dis_set(digi_handle->coreotn_handle,
                                    (odu_struct_t *)chnl_ptr,
                                    pm_tcm_num,
                                    ais_dis,
                                    ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
    
} /* digi_otn_odu_pm_tcmi_ais_dis_set */

/*******************************************************************************
* digi_otn_odu_pm_tcmi_ais_dis_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   configures whether or not aAIS consequential actions are generated.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                          
*   pm_tcm_num      - PM or TCMi field instance:\n
*                     1 to 6    -- TCM1 to TCM6\n
*                     7         -- Floating TCM\n
*                     8         -- PM NIM
*
* OUTPUTS:
*   ais_dis         - current configuration to generate aAIS consequential action \n
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_pm_tcmi_ais_dis_get(digi_handle_t *digi_handle,
                                                  digi_otn_odu_chnl_t *chnl_ptr,
                                                  odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                  UINT8 *ais_dis)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr     != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(ais_dis      != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_ais_dis_get(digi_handle->coreotn_handle,
                                    (odu_struct_t *)chnl_ptr,
                                    pm_tcm_num, 
                                    ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                    ais_dis);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
    
} /* digi_otn_odu_pm_tcmi_ais_dis_get */

/*******************************************************************************
* digi_otn_odu_ebc_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves COREOTN ODUk far/near end counters for PM and TCM.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                          
*   pm_tcm_num      - PM or TCMi field instance:\n
*                     0         -- PM\n
*                     1 to 6    -- TCM1 to TCM6\n
*
* OUTPUTS:
*   *pm_ebc  - COREOTN ODUkP far/near end counters for a PM layer of an ODUk
*              channel, only valid for PM \n
*   *tcm_ebc - COREOTN ODUkT far/near end counters for a TCM layer of an ODUk
*              channel, only valid for TCM1 to TCM6 \n
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_ebc_get(digi_handle_t *digi_handle,
                                      digi_otn_odu_chnl_t *chnl_ptr,
                                      odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                      digi_pmon_coreotn_odukp_counters_t *pm_ebc,
                                      digi_pmon_coreotn_odukt_counters_t *tcm_ebc)
{
    UINT32 *ebc;
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr     != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    if (pm_tcm_num > ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_TCM6)
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);
    }
    
    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if (pm_tcm_num == ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM)
    {
        PMC_ASSERT(pm_ebc     != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
        ebc = (UINT32 *)pm_ebc;
    }
    else
    {
        PMC_ASSERT(tcm_ebc    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
        ebc = (UINT32 *)tcm_ebc;
    }

    result = odu_struct_ebc_get(digi_handle->coreotn_handle,
                                    (odu_struct_t *)chnl_ptr,
                                    pm_tcm_num,
                                    ebc);

    PMC_ATOMIC_RETURN(digi_handle,result);
    
} /* digi_otn_odu_ebc_get */

/*******************************************************************************
* digi_otn_odu_rx_pm_tcm_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retreives received PM&TCM overhead byte.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                          
*
* OUTPUTS:
*   *pm_tcm_val     - received PM&TCM overhead byte \n
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_pm_tcm_get(digi_handle_t *digi_handle,
                                            digi_otn_odu_chnl_t *chnl_ptr,
                                            UINT8 *pm_tcm_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(pm_tcm_val  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_rx_pm_tcm_get(digi_handle->coreotn_handle,
                                      (odu_struct_t *)chnl_ptr,
                                      pm_tcm_val);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
    
} /* digi_otn_odu_rx_pm_tcm_get */


/*******************************************************************************
* digi_otn_odu_maint_sig_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Used to force a maintenance signal on a particular channel.  Maintenance
*   signals can be inserted at every ODU-sink and ODU-source.  When OCI
*   is inserted it will always insert with nominal timing (except when
*   inserting at TFRMs at the ingress of the ODUKSW).
*   
*   For Sink (RX):
*      Maintenance signal is forced before any TCM processing. All layers (TCM/PM)
*      will see the maintenance signal.
*
*      To insert a maintenance signal at RFRMs at the egress of the ODUKSW, call
*      digi_otn_get_chnl_ptr_for_tcm_apps() to get the "switch facing" pointer,
*      and provide that channel pointer to this API.  It is only valid to insert 
*      at an RFRM at the egress of the ODUKSW when an ODUKSW connection is present.
*
*   For Source (TX:
*      Maintenance signal is forced at ODUkP/ODU[i][j] Mux adaptation layer 
*      (on top of all TCM/PM layers)
*
*      To insert a maintenance signal at TFRMs at the ingress of the ODUKSW, call
*      digi_otn_get_chnl_ptr_for_tcm_apps() to get the "switch facing" pointer,
*      and provide that channel pointer to this API.  In this application, if
*      you wish to insert TCMs on top of the maintenance signal for monitoring
*      the switch connection use digi_otn_odu_odukp_pck_maint_sig_set().
*
*   To remove the maintenance signal, call this function with force_alarm_sig = 0   
*
*   For "transmit path" framers (framers going to LINEOTN/SYSOTN): 
*       - for direction==1 (HO/MO/LO source) CORE_OTN_ODUK_AIS_NOMINAL
*         CORE_OTN_ODUK_LCK_NOMINAL and CORE_OTN_ODUK_OCI will be at
*         nominal timing.  CORE_OTN_ODUK_AIS/CORE_OTN_ODUK_LCK will be
*         at ingress rate.
*       - For direction==0 (a sink at the egress of the ODUKSW) CORE_OTN_ODUK_AIS_NOMINAL
*         CORE_OTN_ODUK_LCK_NOMINAL and CORE_OTN_ODUK_OCI will be at
*         nominal timing.  CORE_OTN_ODUK_AIS/CORE_OTN_ODUK_LCK will be
*         at ingress rate.
*   For "receive path" framers  (framers from LINEOTN/SYSOTN):
*       - For direction==1 (a source at ingress of ODUKSW) replacement is always at
*         ingress rate
*       - For direction==0 (HO/MO/LO sink), replacement is always
*         at nominal.
*
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                           
*   direction           - direction of the signal insertion \n
*                         0 -- Sink \n
*                         1 -- Source
*   force_alarm_sig     - enum,requested maintenance signal:
*                         CORE_OTN_NO_MAINT_SIG 
*                         CORE_OTN_ODUK_AIS 
*                         CORE_OTN_ODUK_LCK 
*                         CORE_OTN_ODUK_OCI 
*                         CORE_OTN_ODUK_AIS_NOMINAL
*                         CORE_OTN_ODUK_LCK_NOMINAL
*
* OUTPUTS:
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_maint_sig_set(digi_handle_t *digi_handle,
                                            digi_otn_odu_chnl_t *chnl_ptr,
                                            UINT8 direction,
                                            coreotn_maint_sig_type_t force_alarm_sig)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = digi_otn_odu_maint_sig_set_internal(digi_handle,
                                                 chnl_ptr,
                                                 direction,
                                                 force_alarm_sig,
                                                 FALSE);

    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_maint_sig_set */



/*******************************************************************************
* digi_otn_odu_odukp_pck_maint_sig_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Used to force a maintenance signal on a particular channel.  This is a 
*   special API for forcing maintenance at the ODUkP source packet adaptation
*   (on top of the PM layer, but before ODUkT adaptation).  Use this API
*   if you want all TCMs to remain operational on top of the maintenance signal.
*   
*   To remove the maintenance signal, call this function with force_alarm_sig = 0
*
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                           
*   force_alarm_sig     - enum,requested maintenance signal: 
*                         CORE_OTN_NO_MAINT_SIG 
*                         CORE_OTN_ODUK_AIS 
*                         CORE_OTN_ODUK_LCK 
*                         CORE_OTN_ODUK_OCI 
*
* OUTPUTS:
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_odukp_pck_maint_sig_set(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      coreotn_maint_sig_type_t force_alarm_sig)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = digi_otn_odu_maint_sig_set_internal(digi_handle,
                                                 chnl_ptr,
                                                 1, /*TX*/
                                                 force_alarm_sig,
                                                 TRUE);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_odukp_pck_maint_sig_set */

/*******************************************************************************
* digi_otn_odu_odukp_pck_maint_sig_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Used to retrieve a maintenance signal on a particular channel. This is a 
*   special API for forcing maintenance at the ODUkP source packet adaptation
*   (on top of the PM layer, but before ODUkT adaptation). 
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                           
*
* OUTPUTS:
*   *force_alarm_sig    - enum,requested maintenance signal: 
*                         CORE_OTN_NO_MAINT_SIG 
*                         CORE_OTN_ODUK_AIS 
*                         CORE_OTN_ODUK_LCK 
*                         CORE_OTN_ODUK_OCI
*                         CORE_OTN_ODUK_AIS_NOMINAL
*                         CORE_OTN_ODUK_LCK_NOMINAL
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_odukp_pck_maint_sig_get(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      coreotn_maint_sig_type_t *force_alarm_sig)
{
    PMC_ERROR result = PMC_SUCCESS;
    odu_struct_t *odu_ptr = (odu_struct_t *)chnl_ptr;
    BOOL sig_is_nominal = FALSE;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(force_alarm_sig != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_odukp_pck_maint_sig_get(digi_handle->coreotn_handle,
                                                (odu_struct_t *)chnl_ptr,
                                                force_alarm_sig);

    if (odu_ptr->switch_data.oduk_data.lineotn_src)
    {
        if (odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_HO_ODU)
        {
            sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, 
                                                          COREOTN_TX_HO_LINE, 
                                                          odu_ptr->switch_data.oduk_data.channel);
        }
        else if (odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_MO_ODU)
        {
            sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, 
                                                          COREOTN_TX_MO_LINE, 
                                                          odu_ptr->switch_data.oduk_data.channel);
        }
        else if (odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_LO_ODU)
        {
            sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, 
                                                          COREOTN_TX_LO_LINE, 
                                                          odu_ptr->switch_data.oduk_data.channel);
        }
    }
    else
    {
        if (odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_HO_ODU)
        {
            sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, 
                                                          COREOTN_TX_HO_SYS, 
                                                          odu_ptr->switch_data.oduk_data.channel);
        }
        else if (odu_ptr->mem_ptr->odu_level ==  ODU_STRUCT_LEVEL_MO_ODU)
        {
            sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, 
                                                          COREOTN_TX_MO_SYS, 
                                                          odu_ptr->switch_data.oduk_data.channel);
        }
    }

    if ((CORE_OTN_ODUK_AIS == *force_alarm_sig) && sig_is_nominal)
    {
        *force_alarm_sig = CORE_OTN_ODUK_AIS_NOMINAL;
    }
    else if ((CORE_OTN_ODUK_LCK == *force_alarm_sig) && sig_is_nominal)
    {
        *force_alarm_sig = CORE_OTN_ODUK_LCK_NOMINAL;
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_odukp_pck_maint_sig_get */


/*******************************************************************************
* digi_otn_odu_chnl_sd_sf_ssf_prop_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Sets defect consequent action controls for an ODU channel.
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance
*   *chnl_ptr               - pointer to ODU framer channel handle to be  
*                             operated on
*   chnl_defect_action_msk  - bit mask\n
*                             Bit 0 -- sf_sd_prop: controls the propagation of
*                                      signal fail and signal degrade status.\n
*                                      0 -- Signal fail and signal degrade 
*                                          /maint status is propagated transparently\n
*                                      1 -- Signal fail and signal degrade 
*                                           status is terminated\n\n
*                             Bit 1 -- ssf_prop: controls the propagation of
*                                      signal fail and signal degrade status.\n
*                                      0 -- Signal fail and signal degrade 
*                                           status is propagated transparently\n
*                                      1 -- Signal fail and signal degrade 
*                                           status is terminated
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_chnl_sd_sf_ssf_prop_set(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      UINT8 chnl_defect_action_msk)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_chnl_sd_sf_ssf_prop_set(digi_handle->coreotn_handle,
                                                (odu_struct_t *)chnl_ptr,
                                                chnl_defect_action_msk,
                                                ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_chnl_sd_sf_ssf_prop_set */

/*******************************************************************************
* digi_otn_odu_chnl_lof_lom_act_dis_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Sets dLOFLOM consequent action control for the ODU framer channel.
*
*   For RFRMs at the egress of the ODUKSW, this configuration is reserved
*   for internal use (LOF_LOM_ACT_DIS must be set to 1).
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                           
*   lof_lom_act_dis     - controls enabling/disabling of dLOFLOM consequenct 
*                         action\n
*                         0 -- dLOFLOM defect causes nominal rate ODUk-AIS to 
*                              be inserted in the channel.\n
*                         1 -- dLOFLOM defect does not cause ODUk-AIS to be 
*                              inserted in the channel.
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_chnl_lof_lom_act_dis_set(digi_handle_t *digi_handle,
                                                       digi_otn_odu_chnl_t *chnl_ptr,
                                                       BOOL8 lof_lom_act_dis)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_chnl_lof_lom_act_dis_set(digi_handle->coreotn_handle,
                                                 (odu_struct_t *)chnl_ptr,
                                                 lof_lom_act_dis,
                                                 ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
                                                 
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_chnl_lof_lom_act_dis_set */

/*******************************************************************************
* digi_otn_odu_chnl_lof_lom_act_dis_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Sets dLOFLOM consequent action control for the ODU framer channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                           
*   lof_lom_act_dis     - controls enabling/disabling of dLOFLOM consequenct 
*                         action\n
*                         0 -- dLOFLOM defect causes nominal rate ODUk-AIS to 
*                              be inserted in the channel.\n
*                         1 -- dLOFLOM defect does not cause ODUk-AIS to be 
*                              inserted in the channel.
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_chnl_lof_lom_act_dis_get(digi_handle_t *digi_handle,
                                                       digi_otn_odu_chnl_t *chnl_ptr,
                                                       BOOL8 *lof_lom_act_dis)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    /*
    odu_struct_chnl_lof_lom_act_dis_get(coreotn_handle_t *coreotn_handle,
                                                     odu_struct_t *odu_struct,
                                                     odu_struct_ext_mode_t ext_mode,
                                                     BOOL8 *lof_lom_act_dis) */
    result = odu_struct_chnl_lof_lom_act_dis_get(digi_handle->coreotn_handle,
                                                 (odu_struct_t *)chnl_ptr,
                                                 ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                                 lof_lom_act_dis);
                                                 
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_chnl_lof_lom_act_dis_get */

/*******************************************************************************
* digi_otn_odu_tx_pm_tcmi_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Provisions PM or TCMi layer in an ODU framer channel.\n\n
*
*   For Source (TX)
*      Must provide the parent TCM/PM/DCI! Note, if this node is the start of
*      the path (a source after muxing or mapping), then the PM layer
*      is automatically provisioned by the driver. It is required that
*      to have awareness of the PM layer being provisioned before calling
*      this function.
*      If this is the first TCM then for parent_tcm_num provide 
*      ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_DCI.
*
*   To deprovision a TCM/PM, call this function with source_mode =
*   ODU_STRUCT_PM_TCM_TT_TRANSPARENT
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                           
*   pm_tcm_num          - PM or TCMi instance. 
*                         See odu_struct_odu_frm_pm_tcm_id_t.
*   pool_assign_mode    - mode to assign TCM POOL ID resources. \n
*                         0 -- SW Driver assigns Pool ID for specified PM NIM/TCMi \n
*                         1 -- pool_id specifies the Pool ID used for specified
*                              PM NIM/TCMi.
*   tcm_pool_id         - pool id of the TCM resource. 
*                         Only valid if pool_assign_mode == 1. 
*                         Not used if pm_tcm_num is set to DIGI_ODU_FRM_MESSAGE_TYPE_PM
*                         Set to 0 when pool_assign_mode == 0 or DIGI_ODU_FRM_MESSAGE_TYPE_PM
*                         is used.
*   parent_tcm_num      - PM/TCMi instance of the parent of this current layer.
*                         This argument is used to control consequential action
*                         generation downstream. \n
*                         Set to DIGI_ODU_FRM_MESSAGE_TYPE_DCI if consequential 
*                         action generation among layers is not considered.
*   source_mode         - Mode of the source (see odu_struct_pm_tcm_mode_t)
*
* OUTPUTS:
*   *assigned_pool_id   - assigned pool id returned to the user when this 
*                         function is called with 'pool_assign_mode' set to 0.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_pm_tcmi_set(digi_handle_t *digi_handle,
                                             digi_otn_odu_chnl_t *chnl_ptr,
                                             odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                             UINT8 pool_assign_mode,
                                             UINT8 tcm_pool_id,
                                             odu_struct_odu_frm_pm_tcm_id_t parent_tcm_num,
                                             odu_struct_pm_tcm_mode_t source_mode,
                                             UINT16 *assigned_pool_id)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
   
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_pm_tcmi_set(digi_handle->coreotn_handle,
                                      (odu_struct_t *)chnl_ptr,
                                       pm_tcm_num,
                                       pool_assign_mode,
                                       tcm_pool_id, 
                                       parent_tcm_num,
                                       source_mode,
                                       ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE,
                                       assigned_pool_id);
                                       
    PMC_LOG_TRACE("assigned_pool_id: %u\n", *assigned_pool_id);                                                                        
    
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_odu_tx_pm_tcmi_set */



/*******************************************************************************
* digi_otn_odu_rx_pm_tcmi_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Provisions or deprovisions PM or TCMi layer in an ODU framer channel. After calling this 
*   API, digi_otn_odu_rx_pm_tcmi_activate() must be called always to activate the newly
*   provisioned layer or deactive the newly deprovisioned layer.
*
*   For Sink (RX)
*      Must always provide a parent TCM that is a monitor or operational
*      TCM.  It is not valid to provide a non-intrusive-monitor as a
*      parent.  If this is first TCM layer provisioned, then for
*      parent_tcm_num provide ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_DCI.  In a TCM is
*      inserted or removed from the layering heirarchy, the parent TCM
*      is automatically updated for all TCMs.
*
*   pm_tcm_num == ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_FLOATING_TCM can be used to
*   provision a non-intrusive monitor, that monitors the same TCMi level as
*   an already operational TCM, but at a different point in the TCM layering
*   heirarchy.
*  
*   To deprovision a TCM/PM, call this function with sink_mode =
*   ODU_STRUCT_PM_TCM_TT_TRANSPARENT
* ---------------------------------------------------------------------------  
*      **Note on PM/PM-NIM difference**
*        when provisioning the PM layer with mode pm_tcm_num ==
*        ODU_RFRM_MESSAGE_TYPE_PM, this will always operate on the PM
*        layer as the last layer to be processed.  Provisioning with this
*        type does not consume a pool id.
*        Provisioning with pm_tcm_num == ODU_RFRM_MESSAGE_TYPE_PM_NIM
*        will always consume a pool_id, but it may be placed anywhere
*        in the layering heirarchy.
*        As such there are two possible ways to provision the PM layer
*        as a NIM at the last layer (but one consumes a pool id and
*        one does not)
* ---------------------------------------------------------------------------  
*     **Note on Provisioning Non-intrusive Monitors**
*       When provisioning a non-intructive monitor (ODU_RFRM_MESSAGE_TYPE_PM_NIM
*       or TCM-NIM), it will always stay connected to the operational parent
*       that it was provisioned with.  The only exception is if the operation
*       parent is deprovisioned.  The PM layer provisioned as
*       pm_tcm_num = ODU_RFRM_MESSAGE_TYPE_PM, sink_mode = 
*       ODU_STRUCT_PM_TCM_NON_INTRUSIVE_MONITOR is also an exception as it will
*       always stay the stay layer.
*     
*       For example:
*          - provision TCM1 as a NIM connected to DCI parent
*          - provision TCM2 as OPERATIONAL connected to DCI parent
*          - Layering heirarchy will be:
*                DCI -> TCM1-NIM -> TCM2
*  ---------------------------------------------------------------------------      
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                           
*   pm_tcm_num          - PM or TCMi instance. 
*                         See odu_struct_odu_frm_pm_tcm_id_t.
*   pool_assign_mode    - mode to assign TCM POOL ID resources. \n
*                         0 -- SW Driver assigns Pool ID for specified PM NIM/TCMi \n
*                         1 -- pool_id specifies the Pool ID used for specified
*                              PM NIM/TCMi.
*   tcm_pool_id         - pool id of the TCM resource. 
*                         Only valid if pool_assign_mode == 1.
*                         Not used if pm_tcm_num is set to DIGI_ODU_FRM_MESSAGE_TYPE_PM
*   float_tcmi_src      - TCMi instance if pm_tcm_num is set to
*                         DIGI_ODU_FRM_MESSAGE_TYPE_FLOATING_TCM
*   parent_tcm_num      - PM/TCMi instance of the parent of this current layer.
*                         This argument is used to control consequential action
*                         generation downstream. \n
*                         Set to DIGI_ODU_FRM_MESSAGE_TYPE_DCI if consequential 
*                         action generation among layers is not considered.
*   sink_mode           - Mode of the sink (see odu_struct_pm_tcm_mode).
*                         Note, when provisioning pm_tcm_num instance
*                         DIGI_ODU_FRM_MESSAGE_TYPE_PM_NIM or DIGI_ODU_FRM_MESSAGE_TYPE_FLOATING_TCM
*                         you must provide sink_mode == ODU_STRUCT_PM_TCM_NON_INTRUSIVE_MONITOR
*
*
* OUTPUTS:
*   *assigned_pool_id   - assigned pool id returned to the user when this 
*                         function is called with 'pool_assign_mode' set to 0.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_pm_tcmi_set(digi_handle_t *digi_handle,
                                             digi_otn_odu_chnl_t *chnl_ptr,
                                             odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                             UINT8 pool_assign_mode,
                                             UINT8 tcm_pool_id, 
                                             UINT8 float_tcmi_src,
                                             odu_struct_odu_frm_pm_tcm_id_t parent_tcm_num,
                                             odu_struct_pm_tcm_mode_t sink_mode,
                                             UINT16 *assigned_pool_id)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
   
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_rx_pm_tcmi_set(digi_handle->coreotn_handle,
                                       (odu_struct_t *)chnl_ptr,
                                       pm_tcm_num,
                                       pool_assign_mode,
                                       tcm_pool_id, float_tcmi_src,
                                       parent_tcm_num,
                                       sink_mode,
                                       ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE,
                                       assigned_pool_id);                                                                                  
    
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_odu_rx_pm_tcmi_set */

/*******************************************************************************
* digi_otn_odu_rx_pm_tcmi_layer_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function retrieves the current layer hierarchy information on receive
*   path of ODU channel.
*
*   The first item in the output array indicates the root of the hierarchy.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on
*
* OUTPUTS:
*   *tcm_layers     - pointer to storage of layer hierarchy on ODU_RFRM upto 9 layers
*   *num_layers     - total number of layers on this channel.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_pm_tcmi_layer_get(digi_handle_t *digi_handle,
                                                   digi_otn_odu_chnl_t *chnl_ptr,
                                                   odu_struct_odu_frm_layer_struct_t (*tcm_layers)[ODU_SINK_MAX_PM_TCM_LAYERS],
                                                   UINT32 *num_layers)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_rx_odu_pm_tcmi_layer_get(digi_handle->coreotn_handle,
                                                 (odu_struct_t *)chnl_ptr,
                                                 tcm_layers, num_layers);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_pm_tcmi_layer_get */     

/*******************************************************************************
* digi_otn_odu_tx_pm_tcmi_layer_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function retrieves the current layer hierarchy information on transmit
*   path of ODU channel.
*
*   The first item in the output array indicates the root of the hierarchy.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on
*
* OUTPUTS:
*   *tcm_layers     - pointer to storage of layer hierarchy on ODU_TFRM upto 9 layers
*   *num_layers     - total number of layers on this channel.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_pm_tcmi_layer_get(digi_handle_t *digi_handle,
                                                   digi_otn_odu_chnl_t *chnl_ptr,
                                                   odu_struct_odu_frm_layer_struct_t (*tcm_layers)[ODU_SOURCE_MAX_PM_TCM_LAYERS],
                                                   UINT32 *num_layers)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_tx_odu_pm_tcmi_layer_get(digi_handle->coreotn_handle,
                                                 (odu_struct_t *)chnl_ptr,
                                                 tcm_layers, num_layers);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_pm_tcmi_layer_get */                                                 

/*******************************************************************************
* digi_otn_odu_rx_pm_tcmi_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function activates or deactives PM or TCMi layer in the ODU channel.
*
*   If you wish to *hitlessly* insert a TCM within the TCM layering heirarchy
*   without seeing a hit on the downstream PM/TCM layers, then there must be a delay
*   in between digi_otn_odu_rx_pm_tcmi_set() and digi_otn_odu_rx_pm_tcmi_activate().
*   This time is required to clear any stale defects that exist in a newly 
*   provisioned TCM layer before it is connected to the existing TCM/PM hierarchy.
*
*   If TTI detection is enabled before TCM activation, 3 
*   multiframes are required to clear dTIM: 
*       minimum required wait time = 3*256*ODU frame period* 
*
*   If TTI detection is disabled, 5 frames are required to clear dBDI:
*       minimum required wait time = 5*ODU frame period* 
*
*   *ODU frame periods can be found in table 7-4 in G.709. 
*
*   No wait is required for:
*      - deprovisioning a TCM
*      - Provisioning a NIM (as it is not connected to a downstream layer)
*
*   Recommended sequence to ensure hitless insertion:
*     1) digi_otn_odu_rx_pm_tcmi_set()
*     2) configure TCM related consequential actions (LTC_ACT_DIS, TIM_DET_MON,
*        expected TTI, STAT)
*     3) wait if "hitless insertion" is required (see above for wait time calculation.
*        For example, the worse case wait time is 3*256*98.354us = 75.54 ms for 
*        ODU0s with TTI detection enabled)
*     4) digi_otn_odu_rx_pm_tcmi_activate()
*
*   Prior to calling this API, digi_otn_odu_rx_pm_tcmi_set() must be called always.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                           
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_pm_tcmi_activate(digi_handle_t *digi_handle,
                                                  digi_otn_odu_chnl_t *chnl_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_rx_pm_tcmi_activate(digi_handle->coreotn_handle,
                                            (odu_struct_t *)chnl_ptr);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_pm_tcmi_activate */

/*******************************************************************************
* digi_otn_odu_rx_tcmi_mode_update
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Changes the mode of an operational TCM/PM.  Support hitless transition
*   between the following modes without having to deprovision the TCM/PM layer:
*      ODU_STRUCT_PM_TCM_TT_OPERATIONAL -> ODU_STRUCT_PM_TCM_TT_MONITOR
*      ODU_STRUCT_PM_TCM_TT_MONITOR -> ODU_STRUCT_PM_TCM_TT_OPERATIONAL
*      ODU_STRUCT_PM_TCM_TT_OPERATIONAL -> ODU_STRUCT_PM_TCM_ NON_INTRUSIVE_MONITOR
*      ODU_STRUCT_PM_TCM_ NON_INTRUSIVE_MONITOR-> ODU_STRUCT_PM_TCM_TT_OPERATIONAL
*      ODU_STRUCT_PM_TCM_TT_MONITOR -> ODU_STRUCT_PM_TCM_ NON_INTRUSIVE_MONITOR
*      ODU_STRUCT_PM_TCM_ NON_INTRUSIVE_MONITOR-> ODU_STRUCT_PM_TCM_TT_MONITOR 
*      ODU_STRUCT_PM_TCM_TT_OPERATIONAL_TCMOH_NOT_ZEROED  -> ODU_STRUCT_PM_TCM_TT_MONITOR
*      ODU_STRUCT_PM_TCM_TT_MONITOR -> ODU_STRUCT_PM_TCM_TT_OPERATIONAL_TCMOH_NOT_ZEROED
*      ODU_STRUCT_PM_TCM_TT_OPERATIONAL_TCMOH_NOT_ZEROED -> ODU_STRUCT_PM_TCM_ NON_INTRUSIVE_MONITOR
*      ODU_STRUCT_PM_TCM_ NON_INTRUSIVE_MONITOR-> ODU_STRUCT_PM_TCM_TT_OPERATIONAL_TCMOH_NOT_ZEROED
*
*  It's not valid to call this API with pm_tcm_num == DIGI_ODU_FRM_MESSAGE_TYPE_FLOATING_TCM
*  or pm_tcm_num == ODU_RFRM_MESSAGE_TYPE_PM_NIM because these must always stay 
*  provisioned as type ODU_STRUCT_PM_TCM_NON_INTRUSIVE_MONITOR.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                           
*   pm_tcm_num          - PM or TCMi field instance: \n
*                         0         -- PM \n
*                         1 to 6    -- TCM1 to TCM6 \n
*   sink_mode           - Mode of the sink (see odu_struct_pm_tcm_mode_t)
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS
*   PMC_ERROR - If called for a PM/TCM that is not provisioned
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_tcmi_mode_update(digi_handle_t *digi_handle,
                                                  digi_otn_odu_chnl_t *chnl_ptr,
                                                  odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                  odu_struct_pm_tcm_mode_t sink_mode)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
   
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
                   
    result = odu_struct_rx_tcmi_mode_update(digi_handle->coreotn_handle,
                                            (odu_struct_t *)chnl_ptr,
                                            pm_tcm_num,
                                            sink_mode);
    
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_odu_rx_tcmi_mode_update */


/*******************************************************************************
* digi_otn_odu_tcmi_resource_transition
* ______________________________________________________________________________
*
* DESCRIPTION: 
*    This API is used to transition between a TCMi-NIM provisioned resource to 
*    a floating TCM resource monitoring the same TCM level with the same 
*    pool id (visa-versa).  No changes in the TCM layering heirarchy are 
*    supported with this API.
*
*  For example:
*     DIGI_OTN_TCM_NUM_TCM1 as NIM -> DIGI_OTN_TCM_FLOATING_TCM (monitoring TCM1)
*       - or -
*     DIGI_OTN_TCM_FLOATING_TCM (monitoring TCM1) -> DIGI_OTN_TCM_NUM_TCM1 as NIM
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated on    
*   pool_id              - Pool id of the TCM resource to transition (if the 
*                          resource is currently provisioned as a TCMi-NIM
*                          resource, it will transition to a floating TCM resource.  
*                          If currently provisioned as a floating TCM resource, 
*                          it will transition to a TCMi-NIM resource)
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS
*   PMC_ERROR - If no TCM is provisioned for that resource or if resource is not
*                                 provisioned as a NIM or floating NIM
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tcmi_resource_transition(digi_handle_t *digi_handle,
                                                       digi_otn_odu_chnl_t *chnl_ptr,
                                                       UINT32 pool_id)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
   
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
                   
    result = odu_struct_rx_tcmi_resource_transition(digi_handle->coreotn_handle,
                                                    (odu_struct_t *)chnl_ptr,
                                                    pool_id);
    
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_odu_tcmi_resource_transition */


/*******************************************************************************
* digi_otn_odu_rx_pm_tcmi_nim_parent_update
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API reconnects the specified PM or TCM layer in NON_INTRUSIVE_MODE
*   to a new parent layer.
*   It is expected that the new parent has already been provisioned and added
*   to the layer hierarchy prior to calling this API.
*
*   It is not valid to call this API with 'pm_tcm_num' == ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM
*   or 'new_parent_tcm_num' == ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM as PM must 
*   always be the last layer in the hierarchy. Also it is invalid to call this 
*   API with 'pm_tcm_num' == ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_DCI as DCI is the 
*   ultimate parent of the layer hierarchy.
*   It is not valid to call this API when the tcm_mode of 'new_parent_tcm_num'
*   is in ODU_STRUCT_PM_TCM_NON_INTRUSIVE_MONITOR.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                           
*   pm_tcm_num          - Enum, PM or TCMi field instance: \n
*                         See odu_struct_odu_frm_pm_tcm_id_t.
*   new_parent_tcm_num  - Enum, PM or TCMi field instance: \n
*                         See odu_struct_odu_frm_pm_tcm_id_t.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS
*   PMC_ERROR - If called for a PM/TCM that is not provisioned
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_pm_tcmi_nim_parent_update(digi_handle_t *digi_handle,
                                                           digi_otn_odu_chnl_t *chnl_ptr,
                                                           odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                           odu_struct_odu_frm_pm_tcm_id_t new_parent_tcm_num)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
   
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
                   
    result = odu_struct_rx_pm_tcmi_parent_update(digi_handle->coreotn_handle,
                                                 (odu_struct_t *)chnl_ptr,
                                                 pm_tcm_num,
                                                 new_parent_tcm_num);
    
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_odu_rx_pm_tcmi_nim_parent_update */



/*
** ODU OH configurations
*/
/*******************************************************************************
* digi_otn_odu_pm_tcm_res_src_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   configures the source of PM&TCM reserved field of an ODU Framer channel.
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance
*   *chnl_ptr               - pointer to ODU framer channel handle to be operated 
*                             on
*   pm_tcm_res_src          - Enum for PM_TCM_RES source. See digi_otn_odu_oh_ins_src_t\n
*                             Note: DIGI_OTN_ODU_OH_INS_ODU_RCP is not valid for
*                                   PM_TCM insertion.
*   pm_tcm_res_force_val    - For 'pm_tcm_res_src' == DIGI_OTN_ODU_OH_INS_REGISTER_FORCE,
*                             the value to be inserted into PM&TCM field of
*                             PM or TCMi layer\n
*                             Valid range: 0 - 1
*                             For all other sources, set to 0.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_pm_tcm_res_src_set(digi_handle_t *digi_handle,
                                                 digi_otn_odu_chnl_t *chnl_ptr,
                                                 digi_otn_odu_oh_ins_src_t pm_tcm_res_src,
                                                 UINT8 pm_tcm_res_force_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    if (pm_tcm_res_src > LAST_DIGI_OTN_ODU_OH_INS_SRC)
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);
    }
    
    result = odu_struct_pm_tcm_res_src_set(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr,
                                           (odu_struct_odu_oh_ins_src_t)pm_tcm_res_src, 
                                           pm_tcm_res_force_val,
                                           ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_pm_tcm_res_src_set */

/*******************************************************************************
* digi_otn_odu_pm_tcm_res_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retreives the source and the value of PM&TCM reserved field of an ODU Framer 
*   channel. The insertion source retrevied by this API indicates whether or not
*   register forcing is the insertion source. The value retreived from this API 
*   is the current register value in transmit PM_TCM field.
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance
*   *chnl_ptr               - pointer to ODU framer channel handle to be operated 
*                             on
*
* OUTPUTS:
*   *pm_tcm_res_src         - retreived insertion source for PM&TCM reserved field
*                             0 -- source is not register forcing
*                             1 -- source is register forcing
*   *pm_tcm_res_val         - retreived PM&TCM reserved field
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_pm_tcm_res_get(digi_handle_t *digi_handle,
                                             digi_otn_odu_chnl_t *chnl_ptr,
                                             UINT8 *pm_tcm_res_src,
                                             UINT8 *pm_tcm_res_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr       != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(pm_tcm_res_src != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(pm_tcm_res_val != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_oh_ins_src_get(digi_handle->coreotn_handle,
                                          (odu_struct_t *)chnl_ptr,
                                          ODU_STRUCT_ODU_OH_PM_TCM_RES,
                                          ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                          pm_tcm_res_src);
    
    if (PMC_SUCCESS == result)
    {                                         
        result = odu_struct_pm_tcm_res_get(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr,
                                           ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                           pm_tcm_res_val);
    }                                           
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_pm_tcm_res_get */

/*******************************************************************************
* digi_otn_odu_ftfl_src_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   configures the source of FTFL field of an ODU framer channel.\n\n
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                            
*   ftfl_source         - Enum for PM/TCMi FTFL source. See digi_otn_odu_oh_ins_src_t\n
*                         Note: DIGI_OTN_ODU_OH_INS_ODU_RCP is not valid for
*                               FTFL insertion.
*   ftfl_force_field    - Only valid when source = 1.\n
*                         0 -- force both backward and forward field\n
*                         1 -- force backward field\n
*                         2 -- force forward field
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_ftfl_src_set(digi_handle_t *digi_handle,
                                           digi_otn_odu_chnl_t *chnl_ptr,
                                           digi_otn_odu_oh_ins_src_t ftfl_source,
                                           UINT8 ftfl_force_field)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_ftfl_src_set(digi_handle->coreotn_handle,
                                     (odu_struct_t *)chnl_ptr,
                                     (odu_struct_odu_oh_ins_src_t)ftfl_source,
                                     ftfl_force_field,
                                     ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
                                     
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_ftfl_src_set */

/*******************************************************************************
* digi_otn_odu_tx_ftfl_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Configures the forced value of the transmitted FTFL field for an ODU framer 
*   channel.\n\n
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                         
*   fwd_id          - Forward Indication Field.
*                     One byte field
*                     Byte 0 of the FTFL message
*   fwd_op_id       - Forward Operator Identifier Field
*                     9 byte field
*                     Byte 9:1 of the FTFL message
*   bwd_id          - Backward Indication Field.
*                     One byte field
*                     Byte 128 of the FTFL message
*   bwd_op_id       - Backward Operator Identifier Field.
*                     9 byte field
*                     Byte 137:129 of the FTFL message
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_ftfl_set(digi_handle_t *digi_handle,
                                       digi_otn_odu_chnl_t *chnl_ptr,
                                       UINT8 fwd_id,
                                       UINT8 fwd_op_id[9],
                                       UINT8 bwd_id,
                                       UINT8 bwd_op_id[9])
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_ftfl_set(digi_handle->coreotn_handle,
                                    (odu_struct_t *)chnl_ptr,
                                    fwd_id,
                                    fwd_op_id,
                                    bwd_id,
                                    bwd_op_id,
                                    ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
                                        
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_ftfl_set */

/*******************************************************************************
* digi_otn_odu_tx_ftfl_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves the transmitted FTFL field of an ODU framer channel.\n\n
*   The insertion source retrevied by this API indicates whether or not
*   register forcing is the insertion source. The value retreived from this API 
*   is the current register value in transmit FTFL field.
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance
*   *chnl_ptr               - pointer to ODU framer channel handle to be operated 
*                             on
*
* OUTPUTS:
*   *ftfl_src               - retrieved insertion source for FTFL.
*                             0 -- source is not register forcing
*                             1 -- source is backward field register forcing
*                             2 -- source is forward field register forcing
*                             3 -- source is backward and forward field register forcing
*   *ftfl                   - 20 bytes of retrieved FTFL field value
*                             Byte 0: forward fault type identifier
*                             Byte 1 -- 9: forward operator identifier
*                             Byte 10: backward fault type identifier
*                             Byte 11 -- 19: backward operator identifier 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_ftfl_get(digi_handle_t *digi_handle,
                                          digi_otn_odu_chnl_t *chnl_ptr,
                                          UINT8 *ftfl_src,
                                          UINT8 *ftfl)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(ftfl_src    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(ftfl        != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_oh_ins_src_get(digi_handle->coreotn_handle,
                                          (odu_struct_t *)chnl_ptr,
                                          ODU_STRUCT_ODU_OH_FTFL,
                                          ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                          ftfl_src);
                                          
    if (PMC_SUCCESS == result)
    {                                          
        result = odu_struct_tx_ftfl_get(digi_handle->coreotn_handle,
                                        (odu_struct_t *)chnl_ptr,
                                        ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                        ftfl);
    }                                        
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_ftfl_get */

/*******************************************************************************
* digi_otn_odu_rx_accepted_ftfl_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves the accepted FTFL field from an ODU framer channel
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*
* OUTPUTS:
*   ftfl                - retrieved FTFL field value
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_accepted_ftfl_get(digi_handle_t *digi_handle,
                                                   digi_otn_odu_chnl_t *chnl_ptr,
                                                   UINT8 *ftfl)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(ftfl        != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_rx_ftfl_get(digi_handle->coreotn_handle,
                                    (odu_struct_t *)chnl_ptr,
                                    ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                    ftfl);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_accepted_ftfl_get */

/*******************************************************************************
* digi_otn_odu_tx_tcm_act_src_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API configures the insertion source and the value of the transmitted 
*   TCM ACT field of an ODU framer channel.
*
*   When configured for 'tcm_act_source' = DIGI_OTN_ODU_OH_INS_INCOMING, 
*   the value transferred on TCM_ACT bytes will be from highest to lowest priority: \n
*       -- Data from the External Overhead Port (if enabled) \n
*       -- Register forcing \n
*       -- Data from incoming ODUk frame
*
*   If external overhead port is enabled to insert TCM_ACT bytes, the value 
*   inserted from register using this API will be overwritten and have no effect. 
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*   tcm_act_source         - Enum for TCM ACT source. See digi_otn_odu_oh_ins_src_t\n
*                            Note: DIGI_OTN_ODU_OH_INS_ODU_RCP is invalid for
*                                  TCM_ACT insertion.
*   tcm_act_force_val      - For 'tcm_act_source' == DIGI_OTN_ODU_OH_INS_REGISTER_FORCE,
*                            the value to be inserted into TCM_ACT field\n
*                            Valid range: 0 - 0xFF \n
*                            For all other sources, set to 0.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_tcm_act_src_set(digi_handle_t *digi_handle,
                                                 digi_otn_odu_chnl_t *chnl_ptr,
                                                 digi_otn_odu_oh_ins_src_t tcm_act_source,
                                                 UINT8 tcm_act_force_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    if (tcm_act_source > LAST_DIGI_OTN_ODU_OH_INS_SRC)
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);
    }
    
    result = odu_struct_tcm_act_src_set(digi_handle->coreotn_handle,
                                        (odu_struct_t *)chnl_ptr,
                                        (odu_struct_odu_oh_ins_src_t)tcm_act_source, 
                                        tcm_act_force_val,
                                        ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
                                      
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_tcm_act_src_set */

/*******************************************************************************
* digi_otn_odu_tx_tcm_act_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves transmitted TCM ACT field from an ODU framer channel.
*   The insertion source retrevied by this API indicates whether or not
*   register forcing is the insertion source. The value retreived from this API 
*   is the current register value in transmit TCM_ACT field.
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance
*   *chnl_ptr               - pointer to ODU framer channel handle to be operated 
*                            on
*   tcm_act_val             - The value extracted from TCM_ACT field of ODU framer
*                             channel.
*                          
* OUTPUTS:   
*   *tcm_act_src            - retrieved insertion source of TCM_ACT
*                             0 -- source is not register forcing
*                             1 -- source is register forcing              
*   *tcm_act_val            - retrieved TCM ACT value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_tcm_act_get(digi_handle_t *digi_handle,
                                             digi_otn_odu_chnl_t *chnl_ptr,
                                             UINT8 *tcm_act_src,
                                             UINT8 *tcm_act_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(tcm_act_src != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(tcm_act_val != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_tx_oh_ins_src_get(digi_handle->coreotn_handle,
                                          (odu_struct_t *)chnl_ptr,
                                          ODU_STRUCT_ODU_OH_TCM_ACT,
                                          ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                          tcm_act_src);

    if (PMC_SUCCESS == result)
    {                                          
        result = odu_struct_tcm_act_get(digi_handle->coreotn_handle,
                                        (odu_struct_t *)chnl_ptr, 
                                        ODU_STRUCT_STREAM_TX,
                                        ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                        tcm_act_val);
    }                                        
                                    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_tcm_act_get */

/*******************************************************************************
* digi_otn_odu_rx_accepted_tcm_act_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves receive accepted TCM ACT field from an ODU framer channel.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*   tcm_act_val            - The value extracted from TCM_ACT field of ODU framer
*                            channel.
*                          
* OUTPUTS:                 
*   tcm_act_val            - retrieved TCM ACT value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_accepted_tcm_act_get(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      UINT8 *tcm_act_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(tcm_act_val != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tcm_act_get(digi_handle->coreotn_handle,
                                    (odu_struct_t *)chnl_ptr, 
                                    ODU_STRUCT_STREAM_RX,
                                    ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                    tcm_act_val);
                                    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_accepted_tcm_act_get */

/*******************************************************************************
* digi_otn_odu_aps_pcc_src_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Configures the source and the value of APS/PCC field of a operational 
*   connection monitoring layer for an ODU framer channel.
*
*   When configured for 'aps_pcc_source' = DIGI_OTN_ODU_OH_INS_INCOMING, 
*   the value transferred on APS_PCC bytes will be from highest to lowest priority: \n
*       -- Data from the External Overhead Port (if enabled) \n
*       -- Register forcing \n
*       -- Data from incoming ODUk frame
*
*   If external overhead port is enabled to insert APS_PCC bytes, the value 
*   inserted from register using this API will be overwritten and have no effect. 
*
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                          
*   mon_level           - PM or TCMi layer number\n
*                         0 -- PM\n
*                         1 to 6 -- TCM1 to TCM6\n
*                         7 -- ODUk server layer trail
*   aps_pcc_source      - Enum for APS/PCC source. See digi_otn_odu_oh_ins_src_t\n
*                         Note: DIGI_OTN_ODU_OH_INS_ODU_RCP is invalid for
*                               APS_PCC insertion.
*   aps_pcc_force_val   - For 'aps_pcc_source' == DIGI_OTN_ODU_OH_INS_REGISTER_FORCE,
*                         the value to be inserted into APS/PCC field. \n
*                         Valid range: 0x0 - 0xFFFFFFFF \n 
*                         For all other sources, set to 0.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_aps_pcc_src_set(digi_handle_t *digi_handle,
                                              digi_otn_odu_chnl_t *chnl_ptr,
                                              UINT8 mon_level,
                                              digi_otn_odu_oh_ins_src_t aps_pcc_source,
                                              UINT32 aps_pcc_force_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    if (aps_pcc_source > LAST_DIGI_OTN_ODU_OH_INS_SRC)
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);
    }
    
    result = odu_struct_aps_pcc_src_set(digi_handle->coreotn_handle,
                                        (odu_struct_t *)chnl_ptr,
                                        mon_level,
                                        (odu_struct_odu_oh_ins_src_t)aps_pcc_source, 
                                        aps_pcc_force_val,
                                        ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
                                    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_aps_pcc_src_set */

/*******************************************************************************
* digi_otn_odu_tx_aps_pcc_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retreives the value of APS/PCC field of a operational connection
*   monitoring layer for a transmit ODU framer channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                          
*   mon_level           - PM or TCMi layer number\n
*                         0 -- PM\n
*                         1 to 6 -- TCM1 to TCM6\n
*                         7 -- ODUk server layer trail
*
* OUTPUTS:
*   *aps_pcc_force_val  - extracted value of APS/PCC field.
*                         
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_aps_pcc_get(digi_handle_t *digi_handle,
                                             digi_otn_odu_chnl_t *chnl_ptr,
                                             UINT8 mon_level,
                                             UINT32 *aps_pcc_force_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle       != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr          != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(aps_pcc_force_val != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_aps_pcc_get(digi_handle->coreotn_handle,
                                       (odu_struct_t *)chnl_ptr,
                                       mon_level,
                                       ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                       aps_pcc_force_val);
                                    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_aps_pcc_get */

/*******************************************************************************
* digi_otn_odu_tx_aps_pcc_src_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retreives the insertion source of APS/PCC field of a operational connection
*   monitoring layer for a transmit ODU framer channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                          
*   mon_level           - PM or TCMi layer number\n
*                         0 -- PM\n
*                         1 to 6 -- TCM1 to TCM6\n
*                         7 -- ODUk server layer trail
*
* OUTPUTS:
*   *aps_pcc_source    - extracted insertion source of APS/PCC field.
*                         
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_aps_pcc_src_get(digi_handle_t *digi_handle,
                                                 digi_otn_odu_chnl_t *chnl_ptr,
                                                 UINT8 mon_level,
                                                 UINT8 *aps_pcc_source)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_aps_pcc_src_get(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr,
                                           mon_level,
                                           ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                           aps_pcc_source);
                                    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_aps_pcc_src_get */

/*******************************************************************************
* digi_otn_odu_rx_aps_pcc_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retreives the value of APS/PCC field of a operational connection
*   monitoring layer for a receive ODU framer channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                          
*   mon_level           - PM or TCMi layer number\n
*                         0 -- PM\n
*                         1 to 6 -- TCM1 to TCM6\n
*                         7 -- ODUk server layer trail
*
* OUTPUTS:
*   *aps_pcc_force_val  - extracted value of APS/PCC field.
*                         
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_aps_pcc_get(digi_handle_t *digi_handle,
                                             digi_otn_odu_chnl_t *chnl_ptr,
                                             UINT8 mon_level,
                                             UINT32 *aps_pcc_force_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle       != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr          != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(aps_pcc_force_val != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_rx_aps_pcc_get(digi_handle->coreotn_handle,
                                       (odu_struct_t *)chnl_ptr,
                                       mon_level,
                                       ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                       aps_pcc_force_val);
                                    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_aps_pcc_get */

/*******************************************************************************
* digi_otn_odu_tx_res1_src_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API configures the insertion source and the value of RES1 field for 
*   an ODU framer channel.
*
*   When configured for 'res1_source' = DIGI_OTN_ODU_OH_INS_INCOMING, 
*   the value transferred on RES1 bytes will be from highest to lowest priority: \n
*       -- Data from the External Overhead Port (if enabled) \n
*       -- Register forcing \n
*       -- Data from incoming ODUk frame
*
*   If external overhead port is enabled to insert RES1 bytes, the value 
*   inserted from register using this API will be overwritten and have no effect. 
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                          
*   res1_source     - Enum for RES1 source. See digi_otn_odu_oh_ins_src_t \n
*                     Note: DIGI_OTN_ODU_OH_INS_ODU_RCP is invalid for
*                           RES1 insertion.
*   res1_force_val  - For 'res1_source' == DIGI_OTN_ODU_OH_INS_REGISTER_FORCE, 
*                     the value to be inserted into bits[15:0] of RES field\n
*                     Valid range: 0x0 - 0xFFFF \n
*                     For all other sources, set to 0.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_res1_src_set(digi_handle_t *digi_handle,
                                              digi_otn_odu_chnl_t *chnl_ptr,
                                              digi_otn_odu_oh_ins_src_t res1_source,
                                              UINT16 res1_force_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    if (res1_source > LAST_DIGI_OTN_ODU_OH_INS_SRC)
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);
    }
    
    result = odu_struct_tx_res1_src_set(digi_handle->coreotn_handle,
                                        (odu_struct_t *)chnl_ptr,
                                        (odu_struct_odu_oh_ins_src_t)res1_source, 
                                        res1_force_val,
                                        ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_res1_src_set */

/*******************************************************************************
* digi_otn_odu_tx_res2_src_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API configures the insertion source and the value of RES field in 
*   Row 4, Column 9 - 14 of an ODU framer channel.
*
*   When configured for 'res2_source' = DIGI_OTN_ODU_OH_INS_INCOMING, 
*   the value transferred on RES2 bytes will be from highest to lowest priority: \n
*       -- Data from the External Overhead Port (if enabled) \n
*       -- Register forcing \n
*       -- Data from incoming ODUk frame
*
*   If external overhead port is enabled to insert RES2 bytes, the value 
*   inserted from register using this API will be overwritten and have no effect. 
*
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                          
*   res2_source         - Enum for RES2 source. See digi_otn_odu_oh_ins_src_t \n
*                         Note: DIGI_OTN_ODU_OH_INS_ODU_RCP is invalid for
*                               RES2 insertion.
*   res2_force_val      - For 'res2_source' == DIGI_OTN_ODU_OH_INS_REGISTER_FORCE, 
*                         6 bytes RES field. \n   
*                         For all other sources, set to 0. 
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_res2_src_set(digi_handle_t *digi_handle,
                                              digi_otn_odu_chnl_t *chnl_ptr,
                                              digi_otn_odu_oh_ins_src_t res2_source,
                                              UINT8 res2_force_val[6])
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    if (res2_source > LAST_DIGI_OTN_ODU_OH_INS_SRC)
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);
    }
    
    result = odu_struct_tx_res2_src_set(digi_handle->coreotn_handle,
                                        (odu_struct_t *)chnl_ptr,
                                        (odu_struct_odu_oh_ins_src_t)res2_source, 
                                        res2_force_val,
                                        ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_res2_src_set */

/*******************************************************************************
* digi_otn_odu_tx_res1_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves transmitted RES OH in row 2 of an ODU framer channel.
*   The insertion source retrevied by this API indicates whether or not
*   register forcing is the insertion source. The value retreived from this API 
*   is the current register value in transmit RES1 field.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*                          
* OUTPUTS:                
*   *res1_src              - retreived insertion source of RES1
*                            0 -- source is not register forcing
*                            1 -- source is register forcing 
*   *res1_val              - retrieved RES1 field value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_res1_get(digi_handle_t *digi_handle,
                                          digi_otn_odu_chnl_t *chnl_ptr,
                                          UINT8 *res1_src,
                                          UINT16 *res1_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(res1_src    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(res1_val    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_oh_ins_src_get(digi_handle->coreotn_handle,
                                          (odu_struct_t *)chnl_ptr,
                                          ODU_STRUCT_ODU_OH_RES1,
                                          ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                          res1_src);

    if (PMC_SUCCESS == result)
    {
        result = odu_struct_res1_get(digi_handle->coreotn_handle,
                                     (odu_struct_t *)chnl_ptr, 
                                     ODU_STRUCT_STREAM_TX,
                                     ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                     res1_val);
    }                                     
                                    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_res1_get */

/*******************************************************************************
* digi_otn_odu_tx_res2_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves transmitted RES bytes from row 4 of an ODU framer channel.
*   The insertion source retrevied by this API indicates whether or not
*   register forcing is the insertion source. The value retreived from this API 
*   is the current register value in transmit RES2 field.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*                          
* OUTPUTS:      
*   *res2_src              - retrieved insertion source of RES2
*                            0 -- source is not register forcing
*                            1 -- source is register forcing       
*   *res2_val              - retrieved RES2 value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_res2_get(digi_handle_t *digi_handle,
                                          digi_otn_odu_chnl_t *chnl_ptr,
                                          UINT8 *res2_src,
                                          UINT8 *res2_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!= NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr   != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(res2_src   != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(res2_val   != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_oh_ins_src_get(digi_handle->coreotn_handle,
                                          (odu_struct_t *)chnl_ptr,
                                          ODU_STRUCT_ODU_OH_RES2,
                                          ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                          res2_src);

    if (PMC_SUCCESS == result)
    {                                          
        result = odu_struct_res2_get(digi_handle->coreotn_handle,
                                     (odu_struct_t *)chnl_ptr, 
                                     ODU_STRUCT_STREAM_TX,
                                     ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                     res2_val);
    }                                     
                                    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_res2_get */

/*******************************************************************************
* digi_otn_odu_rx_res1_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves receive RES OH in row 2 of an ODU framer channel.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*                          
* OUTPUTS:                 
*   *res1_val              - retrieved RES1 field value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_res1_get(digi_handle_t *digi_handle,
                                          digi_otn_odu_chnl_t *chnl_ptr,
                                          UINT16 *res1_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(res1_val    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_res1_get(digi_handle->coreotn_handle,
                                 (odu_struct_t *)chnl_ptr, 
                                 ODU_STRUCT_STREAM_RX,
                                 ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                 res1_val);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_res1_get */

/*******************************************************************************
* digi_otn_odu_rx_res2_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves receive RES bytes from row 4 of an ODU framer channel.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*                          
* OUTPUTS:                 
*   *res2_val              - retrieved RES2 value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_res2_get(digi_handle_t *digi_handle,
                                          digi_otn_odu_chnl_t *chnl_ptr,
                                          UINT8 *res2_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(res2_val    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_res2_get(digi_handle->coreotn_handle,
                                 (odu_struct_t *)chnl_ptr, 
                                 ODU_STRUCT_STREAM_RX,
                                 ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                 res2_val);
                                     
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_res2_get */

/*******************************************************************************
* digi_otn_odu_tx_exp_src_set
* ______________________________________________________________________________
* 
* DESCRIPTION: 
*   This API configures the insertion source and the value of transmitted EXP 
*   field for an ODU framer channel.
*
*   When configured for 'exp_source' = DIGI_OTN_ODU_OH_INS_INCOMING, 
*   the value transferred on EXP bytes will be from highest to lowest priority: \n
*       -- Data from the External Overhead Port (if enabled) \n
*       -- Register forcing \n
*       -- Data from incoming ODUk frame
*
*   If external overhead port is enabled to insert EXP bytes, the value 
*   inserted from register using this API will be overwritten and have no effect. 
*
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                          
*   exp_source      - Enum for EXP source. See digi_otn_odu_oh_ins_src_t\n
*                     Note: DIGI_OTN_ODU_OH_INS_ODU_RCP is invalid for
*                           EXP insertion.
*   exp_force_val   - For 'exp_source' == DIGI_OTN_ODU_OH_INS_REGISTER_FORCE, 
*                     the value to be inserted into EXP bytes\n
*                     Valid range: 0x0 - 0xFFFF \n
*                     For all other sources, set to 0.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_exp_src_set(digi_handle_t *digi_handle,
                                             digi_otn_odu_chnl_t *chnl_ptr,
                                             digi_otn_odu_oh_ins_src_t exp_source,
                                             UINT16 exp_force_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    if (exp_source > LAST_DIGI_OTN_ODU_OH_INS_SRC)
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);
    }
    
    result = odu_struct_tx_exp_src_set(digi_handle->coreotn_handle,
                                       (odu_struct_t *)chnl_ptr,
                                       (odu_struct_odu_oh_ins_src_t)exp_source, 
                                       exp_force_val,
                                       ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
                                   
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_exp_src_set */

/*******************************************************************************
* digi_otn_odu_rx_exp_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves EXP field for an ODU framer channel.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*
* OUTPUTS:
*   *exp_val               - retrieved EXP field value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_exp_get(digi_handle_t *digi_handle,
                                         digi_otn_odu_chnl_t *chnl_ptr,
                                         UINT16 *exp_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(exp_val     != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_exp_get(digi_handle->coreotn_handle,
                                (odu_struct_t *)chnl_ptr, 
                                ODU_STRUCT_STREAM_RX,
                                ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                exp_val);
                                
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_exp_get */

/*******************************************************************************
* digi_otn_odu_tx_exp_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves EXP field for an ODU framer channel.
*   The insertion source retrevied by this API indicates whether or not
*   register forcing is the insertion source. The value retreived from this API 
*   is the current register value in transmit EXP field.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*
* OUTPUTS:
*   *exp_src               - retrieved insertion source of EXP
*                            0 -- source is not register forcing
*                            1 -- source is register forcing
*   *exp_val               - retrieved EXP field value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_exp_get(digi_handle_t *digi_handle,
                                         digi_otn_odu_chnl_t *chnl_ptr,
                                         UINT8 *exp_src,
                                         UINT16 *exp_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle !=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(exp_src     !=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(exp_val     !=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_oh_ins_src_get(digi_handle->coreotn_handle,
                                          (odu_struct_t *)chnl_ptr,
                                          ODU_STRUCT_ODU_OH_EXP,
                                          ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                          exp_src);
    
    if (PMC_SUCCESS == result)
    {
        result = odu_struct_exp_get(digi_handle->coreotn_handle,
                                    (odu_struct_t *)chnl_ptr, 
                                    ODU_STRUCT_STREAM_TX,
                                    ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                    exp_val);
    }                                   
                                
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_exp_get */

/*******************************************************************************
* digi_otn_odu_tx_gcc1_src_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   configures the insertion source of GCC1 field for an ODU framer channel.
*
*   When configured for 'gcc1_source' = DIGI_OTN_ODU_OH_INS_INCOMING, 
*   the value transferred on GCC1 bytes will be from highest to lowest priority: \n
*       -- Data from the External Overhead Port (if enabled) \n
*       -- Register forcing \n
*       -- Data from incoming ODUk frame
*
*   If external overhead port is enabled to insert GCC1 bytes, the value 
*   inserted from register using this API will be overwritten and have no effect. 
*
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                          
*   gcc1_source         - Enum for GCC1 source. See digi_otn_odu_oh_ins_src_t.\n
*                         Note: DIGI_OTN_ODU_OH_INS_ODU_RCP is invalid for
*                               GCC1 insertion.
*   gcc1_force_val      - For 'gcc1_source' = DIGI_OTN_ODU_OH_INS_REGISTER_FORCE,
*                         the value to be inserted into row 4 GCC1 field.\n
*                         Valid range: 0x0 - 0xFFFFFFFF \n
*                         For all other sources, set to 0.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_gcc1_src_set(digi_handle_t *digi_handle,
                                              digi_otn_odu_chnl_t *chnl_ptr,
                                              digi_otn_odu_oh_ins_src_t gcc1_source,
                                              UINT16 gcc1_force_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if (gcc1_source > LAST_DIGI_OTN_ODU_OH_INS_SRC)
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);
    }
    
    result = odu_struct_tx_gcc1_src_set(digi_handle->coreotn_handle,
                                        (odu_struct_t *)chnl_ptr,
                                        (odu_struct_odu_oh_ins_src_t)gcc1_source, 
                                        gcc1_force_val,
                                        ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
                                        
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_gcc1_src_set */

/*******************************************************************************
* digi_otn_odu_tx_gcc2_src_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API configures the insertion source and the value of GCC2 field for 
*   an ODU framer channel.
*
*   When configured for 'gcc2_source' = DIGI_OTN_ODU_OH_INS_INCOMING, 
*   the value transferred on GCC2 bytes will be from highest to lowest priority: \n
*       -- Data from the External Overhead Port (if enabled) \n
*       -- Register forcing \n
*       -- Data from incoming ODUk frame
*
*   If external overhead port is enabled to insert GCC2 bytes, the value 
*   inserted from register using this API will be overwritten and have no effect. 
*
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                            
*   gcc2_source         - GCC2 source\n
*                         0 -- Incoming GCC2 value\n
*                         1 -- Force GCC2 value
*   gcc2_force_val      - The value to be inserted into row 4 GCC2 field.\n
*                         Valid range: 0x0 - 0xFFFFFFFF
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_gcc2_src_set(digi_handle_t *digi_handle,
                                              digi_otn_odu_chnl_t *chnl_ptr,
                                              digi_otn_odu_oh_ins_src_t gcc2_source,
                                              UINT16 gcc2_force_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    if (gcc2_source > LAST_DIGI_OTN_ODU_OH_INS_SRC)
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);
    }
    
    result = odu_struct_tx_gcc2_src_set(digi_handle->coreotn_handle,
                                        (odu_struct_t *)chnl_ptr,
                                        (odu_struct_odu_oh_ins_src_t)gcc2_source, 
                                        gcc2_force_val,
                                        ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
                                    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_gcc2_src_set */

/*******************************************************************************
* digi_otn_odu_rx_accepted_gcc1_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves GCC1 field for an ODU framer channel.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*
* OUTPUTS:
*   *gcc1_val               - retrieved GCC1 field value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_accepted_gcc1_get(digi_handle_t *digi_handle,
                                                   digi_otn_odu_chnl_t *chnl_ptr,
                                                   UINT16 *gcc1_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(gcc1_val    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_gcc1_get(digi_handle->coreotn_handle,
                                 (odu_struct_t *)chnl_ptr, 
                                 ODU_STRUCT_STREAM_RX,
                                 ODU_STRUCT_EXTRACT_FROM_DEVICE, gcc1_val);
                                 
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_accepted_gcc1_get */

/*******************************************************************************
* digi_otn_odu_rx_accepted_gcc2_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves the accepted GCC2 field of an ODU framer channel.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*
* OUTPUTS:
*   *gcc2_val              - retrieved GCC2 field value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_accepted_gcc2_get(digi_handle_t *digi_handle,
                                                   digi_otn_odu_chnl_t *chnl_ptr,
                                                   UINT16 *gcc2_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(gcc2_val    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_gcc2_get(digi_handle->coreotn_handle,
                                 (odu_struct_t *)chnl_ptr, 
                                 ODU_STRUCT_STREAM_RX,
                                 ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                 gcc2_val);
                                     
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_accepted_gcc2_get */

/*******************************************************************************
* digi_otn_odu_tx_gcc1_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves transmitted GCC1 field for an ODU framer channel.
*   The insertion source retrevied by this API indicates whether or not
*   register forcing is the insertion source. The value retreived from this API 
*   is the current register value in transmit GCC1 field.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*
* OUTPUTS:
*   gcc1_src               - retrieved insertion source of GCC1
*                            0 -- source is not register forcing
*                            1 -- source is register forcing
*   gcc1_val               - retrieved GCC1 field value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_gcc1_get(digi_handle_t *digi_handle,
                                          digi_otn_odu_chnl_t *chnl_ptr,
                                          UINT8 *gcc1_src,
                                          UINT16 *gcc1_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(gcc1_src    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(gcc1_val    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_oh_ins_src_get(digi_handle->coreotn_handle,
                                          (odu_struct_t *)chnl_ptr,
                                          ODU_STRUCT_ODU_OH_GCC1,
                                          ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                          gcc1_src);
                                          
    if (PMC_SUCCESS == result)
    {    
        result = odu_struct_gcc1_get(digi_handle->coreotn_handle,
                                     (odu_struct_t *)chnl_ptr, 
                                     ODU_STRUCT_STREAM_TX,
                                     ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                     gcc1_val);
    }                                     
                                 
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_gcc1_get */

/*******************************************************************************
* digi_otn_odu_tx_gcc2_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves the transmitted GCC2 field of an ODU framer channel.
*   The insertion source retrevied by this API indicates whether or not
*   register forcing is the insertion source. The value retreived from this API 
*   is the current register value in transmit GCC2 field.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*
* OUTPUTS:
*   gcc2_src               - retrieved insertion source of GCC2
*                            0 -- source is not register forcing
*                            1 -- source is register forcing
*   gcc2_val               - retrieved GCC2 field value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_gcc2_get(digi_handle_t *digi_handle,
                                          digi_otn_odu_chnl_t *chnl_ptr,
                                          UINT8 *gcc2_src,
                                          UINT16 *gcc2_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(gcc2_src    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(gcc2_val    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_oh_ins_src_get(digi_handle->coreotn_handle,
                                          (odu_struct_t *)chnl_ptr,
                                          ODU_STRUCT_ODU_OH_GCC2,
                                          ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                          gcc2_src);

    if (PMC_SUCCESS == result)
    {                                          
        result = odu_struct_gcc2_get(digi_handle->coreotn_handle,
                                     (odu_struct_t *)chnl_ptr, 
                                     ODU_STRUCT_STREAM_TX,
                                     ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                     gcc2_val);
    }                                     
                                     
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_gcc2_get */


/*******************************************************************************
* digi_otn_odu_tim_det_mon_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures TIM_DET_MO field for an ODU framer channel.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                       
*   pm_tcm_num      - PM or TCMi layer. See odu_struct_odu_frm_pm_tcm_id_t.
*   tim_det_mo      - TTI mismatch detection mode for the layer specified
*                     by 'pm_tcm_num'\n
*                     0 -- dTIM defect detection is disabled\n
*                     1 -- the expected SAPI field is used to determine dTIM 
*                         defect\n
*                     2 -- the expected DAPI field is used to determine dTIM 
*                         defect\n
*                     3 -- both the expected SAPI and DAPI fields are used
*                         to determine dTIM defect
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tim_det_mon_set(digi_handle_t *digi_handle,
                                              digi_otn_odu_chnl_t *chnl_ptr,
                                              odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                              UINT8 tim_det_mo)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tim_det_mon_set(digi_handle->coreotn_handle,
                                        (odu_struct_t *)chnl_ptr,
                                        pm_tcm_num,
                                        tim_det_mo,
                                        ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
    
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_odu_tim_det_mon_set */

/*******************************************************************************
* digi_otn_odu_tim_det_mon_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retrieves TIM_DET_MO field of PM or TCMi layer for an ODU framer channel.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*   pm_tcm_num             - PM or TCMi layer. See odu_struct_odu_frm_pm_tcm_id_t.
*
* OUTPUTS:
*   *tim_det_mo            - retrieved TTI mismatch detection mode for
*                            PM or TCMi layer
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tim_det_mon_get(digi_handle_t                  *digi_handle,
                                              digi_otn_odu_chnl_t            *chnl_ptr,
                                              odu_struct_odu_frm_pm_tcm_id_t  pm_tcm_num,
                                              UINT8                          *tim_det_mo)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(tim_det_mo  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tim_det_mon_get(digi_handle->coreotn_handle,
                                        (odu_struct_t *)chnl_ptr,
                                        pm_tcm_num,
                                        ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                        tim_det_mo);
                                        
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tim_det_mon_get */

/*******************************************************************************
* digi_otn_odu_tim_act_dis_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Configures TIM_DET_MO field for an ODU framer channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                         
*   pm_tcm_num          - PM or TCMi layer. See odu_struct_odu_frm_pm_tcm_id_t.
*   tim_act_dis         - controls TTI consequent action disable for the layer
*                         specified by 'pm_tcm_num'\n
*                         0 -- dTIM defect contributes to the aTSF and the aAIS
*                              consequential action declarations\n
*                         1 -- dTIM defect does not contribute to the aTSF and
*                              the aAIS consequential action declarations
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tim_act_dis_set(digi_handle_t *digi_handle,
                                              digi_otn_odu_chnl_t *chnl_ptr,
                                              odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                              BOOL8 tim_act_dis)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
     
    result = odu_struct_tim_act_dis_set(digi_handle->coreotn_handle,
                                        (odu_struct_t *)chnl_ptr,
                                        pm_tcm_num,
                                        tim_act_dis,
                                        ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
                                        
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tim_act_dis_set */

/*******************************************************************************
* digi_otn_odu_tim_act_dis_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retrieves TIM_ACT_DIS field for an ODU framer channel.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*   pm_tcm_num             - PM or TCMi layer. See odu_struct_odu_frm_pm_tcm_id_t.
*
* OUTPUTS:
*   *tim_act_dis           - retrieved value of TIM_ACT_DIS
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tim_act_dis_get(digi_handle_t *digi_handle,
                                              digi_otn_odu_chnl_t *chnl_ptr,
                                              odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                              BOOL8 *tim_act_dis)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(tim_act_dis != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tim_act_dis_get(digi_handle->coreotn_handle,
                                        (odu_struct_t *)chnl_ptr,
                                        pm_tcm_num,
                                        ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                        tim_act_dis);
                                        
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tim_act_dis_get */

/*******************************************************************************
* digi_otn_odu_bei_biae_set
* ______________________________________________________________________________
* 
* DESCRIPTION: 
*   Configures the forced BEI/BIAE field for an ODU framer channel.
*   Before calling this API, it is nessecary to call
*   digi_otn_odu_bdi_bei_biae_insert_cfg() with source = 2.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                            
*   pm_tcm_num          - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t.
*   force_val           - For source == 2 (otherwise set to 0)\n
*                         The value to be inserted into BEI/BIAE field of
*                         PM or TCMi layer\n
*                         Valid range: 0x0 - 0xF
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_bei_biae_set(digi_handle_t *digi_handle,
                                           digi_otn_odu_chnl_t *chnl_ptr,
                                           odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                           UINT8 force_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_bdi_bei_biae_set(digi_handle->coreotn_handle,
                                         (odu_struct_t *)chnl_ptr,
                                         pm_tcm_num,
                                         1, 0,
                                         force_val,
                                         ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_bei_biae_set */

/*******************************************************************************
* digi_otn_odu_bei_biae_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retrieves BEI/BIAE field for an ODU framer channel.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                        
*   pm_tcm_num      - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t.
*
* OUTPUTS:
*   *bei_biae_val   - value read from BEI/BIAE field of the specified PM or
*                     TCMi layer for the ODU framer channel
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_bei_biae_get(digi_handle_t *digi_handle,
                                           digi_otn_odu_chnl_t *chnl_ptr,
                                           odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                           UINT8 *bei_biae_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_bei_biae_get(digi_handle->coreotn_handle,
                                     (odu_struct_t *)chnl_ptr,
                                     pm_tcm_num,
                                     ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                     bei_biae_val);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_bei_biae_get */

/*******************************************************************************
* digi_otn_odu_bdi_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Configures the source of BDI field and the forced value for an ODU framer 
*   channel to be used in case of register insertion of BDI into ODU framer.
*
*   Before calling this API, it is nessecary to call
*   digi_otn_odu_bdi_bei_biae_insert_cfg() with source = 2.
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance
*   *chnl_ptr          - pointer to ODU framer channel handle to be operated on                    
*   pm_tcm_num         - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t.
*   force_val          - For source == 2 (otherwise set to 0)\n
*                        The value to be inserted into BDI field of
*                        PM or TCMi layer\n
*                        Valid range: 0 - 1
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_bdi_set(digi_handle_t *digi_handle,
                                      digi_otn_odu_chnl_t *chnl_ptr,
                                      odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                      UINT8 force_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_bdi_bei_biae_set(digi_handle->coreotn_handle,
                                         (odu_struct_t *)chnl_ptr,
                                         pm_tcm_num,
                                         0, force_val, 0,
                                         ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
                                             
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_bdi_set */

/*******************************************************************************
* digi_otn_odu_bdi_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retrieves BDI field for an ODU framer channel.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                           
*   pm_tcm_num      - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t.
*
* OUTPUTS:
*   *bdi_val        - BDI value retrieved.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_bdi_get(digi_handle_t *digi_handle,
                                      digi_otn_odu_chnl_t *chnl_ptr,
                                      odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                      UINT8 *bdi_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_bdi_get(digi_handle->coreotn_handle,
                                (odu_struct_t *)chnl_ptr,
                                pm_tcm_num,
                                ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                bdi_val);
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_bdi_get */

 
/*******************************************************************************
* digi_otn_odu_rcp_en_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retrieves status of bdi_bei_biae insert for an ODU framer channel.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                           
*
* OUTPUTS:
*   *rcp_en        - status of bdi_bei_biae insert.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rcp_en_get(digi_handle_t *digi_handle,
                                         digi_otn_odu_chnl_t *chnl_ptr,
                                         UINT32 *rcp_en)
{
    PMC_ERROR result = PMC_SUCCESS;
    odu_struct_t *odu_struct = NULL;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    odu_struct = (odu_struct_t *)chnl_ptr;
    
    result = odu_struct_rcp_en_get(digi_handle->coreotn_handle, odu_struct, rcp_en);
    
    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_odu_rcp_en_get */


/*******************************************************************************
* digi_otn_odu_tx_stat_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Configures the source of STAT field and the forced value for an ODU framer 
*   channel to be used in case of register insertion of STAT into ODU framer.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                         
*   pm_tcm_num      - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t.
*   force_val       - For source == 2 (otherwise set to 0)\n
*                     The value to be inserted into STAT field of
*                     PM or TCMi layer\n
*                     Valid range: 0x0 - 0x7
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_stat_set(digi_handle_t *digi_handle,
                                          digi_otn_odu_chnl_t *chnl_ptr,
                                          odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                          UINT8 force_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_stat_set(digi_handle->coreotn_handle,
                                 (odu_struct_t *)chnl_ptr,
                                 pm_tcm_num,
                                 force_val,
                                 ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_stat_set */

/*******************************************************************************
* digi_otn_odu_tx_stat_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retrieves the TX STAT field of PM or TCMI layer for an ODU framer channel.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*   pm_tcm_num             - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t.
*                          
* OUTPUTS:                 
*   *stat_val              - retrieved STAT field value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_stat_get(digi_handle_t *digi_handle,
                                          digi_otn_odu_chnl_t *chnl_ptr,
                                          odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                          UINT8 *stat_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_stat_get(digi_handle->coreotn_handle,
                                 (odu_struct_t *)chnl_ptr, 
                                 ODU_STRUCT_STREAM_TX,
                                 pm_tcm_num,
                                 ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                 stat_val);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_stat_get */


/*******************************************************************************
* digi_otn_odu_tx_all_tcm_iae_force
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Forces an IAE event at all operational TCMs for this channel (inserts 010
*   into STAT field for 16 multiframes) 
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                         
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_all_tcm_iae_force(digi_handle_t *digi_handle,
                                                   digi_otn_odu_chnl_t *chnl_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_all_tcm_iae_force(digi_handle->coreotn_handle,
                                          (odu_struct_t *)chnl_ptr);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_all_tcm_iae_force */

/*******************************************************************************
* digi_otn_odu_rx_accepted_stat_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retrieves the STAT field of PM or TCMI layer for an ODU framer channel.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
*   pm_tcm_num             - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t.
*                          
* OUTPUTS:                 
*   *stat_val              - retrieved STAT field value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_accepted_stat_get(digi_handle_t *digi_handle,
                                                   digi_otn_odu_chnl_t *chnl_ptr,
                                                   odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                   UINT8 *stat_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_stat_get(digi_handle->coreotn_handle,
                                 (odu_struct_t *)chnl_ptr, 
                                 ODU_STRUCT_STREAM_RX,
                                 pm_tcm_num,
                                 ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                 stat_val);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_accepted_stat_get */


/*******************************************************************************
* digi_otn_odu_delay_measure_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Set-up DIGI to act as a delay measurement "source" or a delay measurement
*   "feedthrough".  Note, you must provision the TCM/PM layer that you
*   want to perform a delay measurement with before calling this API.
*       
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                          
*   pm_tcm_num      - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t.
*   dm_mode         - see digi_otn_dm_mode_t.
*                     DIGI_OTN_DM_SOURCE or DIGI_OTN_DM_FEEDTHROUGH.
*                     (calling with DIGI_OTN_DM_FEEDTHROUGH will
*                     disable the DM state machine)
*   dm_val          - If dm_mode == DIGI_OTN_DM_SOURCE, this will
*                     set the initial value for dmx_val
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_delay_measure_init(digi_handle_t *digi_handle,
                                                 digi_otn_odu_chnl_t *chnl_ptr,
                                                 odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                 digi_otn_dm_mode_t dm_mode,
                                                 UINT32 dm_val)
{
    
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if( (dm_mode != DIGI_OTN_DM_SOURCE && dm_mode != DIGI_OTN_DM_FEEDTHROUGH) ||
         chnl_ptr == NULL ||
         (dm_val != 0 && dm_val != 1) ) {
        result = DIGI_ERR_INVALID_ARG;
    }

    if(result == PMC_SUCCESS) 
    {
        result = odu_struct_delay_measure_init(digi_handle->coreotn_handle,
                                                ((odu_struct_t *)chnl_ptr),
                                                pm_tcm_num,
                                                (odu_struct_dm_mode_t)dm_mode,
                                                ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE,
                                                dm_val);
                                                
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_odu_delay_measure_init */

/*******************************************************************************
* digi_otn_odu_delay_measure_mode_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Get delay measurement mode and its initial value.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                          
*   pm_tcm_num      - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t.
*
* OUTPUTS:
*   dm_mode         - see digi_otn_dm_mode_t.
*                     DIGI_OTN_DM_SOURCE or DIGI_OTN_DM_FEEDTHROUGH.
*   dm_val          - If *dm_mode == DIGI_OTN_DM_SOURCE, dmx_val returned.
*                     otherwise 0 returned.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_delay_measure_mode_get(digi_handle_t *digi_handle,
                                                     digi_otn_odu_chnl_t *chnl_ptr,
                                                     odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                     digi_otn_dm_mode_t *dm_mode,
                                                     UINT32 *dm_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    odu_struct_dm_mode_t local_dm_mode;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_delay_measure_mode_get(digi_handle->coreotn_handle,
                                               ((odu_struct_t *)chnl_ptr),
                                               pm_tcm_num,
                                               &local_dm_mode,
                                               dm_val);
                                               
    if (result == PMC_SUCCESS)
    {
        if(local_dm_mode == ODU_STRUCT_DM_FEEDTHROUGH)
        {
            *dm_mode = DIGI_OTN_DM_FEEDTHROUGH;
        }
        else
        {
            *dm_mode = DIGI_OTN_DM_SOURCE;
        }
    }
                                                
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_delay_measure_mode_get */

/*******************************************************************************
* digi_otn_odu_delay_measure_go
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API is used to set start a delay measure.  This function must be called
*   after digi_otn_odu_delay_measure_init().  This API is only valid to use
*   on the DIGI that has been provisioned with dm_mode == DIGI_OTN_DM_SOURCE
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                          
*   pm_tcm_num      - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_delay_measure_go(digi_handle_t *digi_handle,
                                                digi_otn_odu_chnl_t *chnl_ptr,
                                                odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num)
{


    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if(result == PMC_SUCCESS) {
        
        result = odu_struct_pm_tcmi_delay_measure_go(digi_handle->coreotn_handle,
                                                     (odu_struct_t *)chnl_ptr,
                                                     pm_tcm_num);
        
    }

    PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);

} /* digi_otn_odu_delay_measure_go */

/*******************************************************************************
* digi_otn_odu_get_delay_measure_count
* ______________________________________________________________________________
*
* DESCRIPTION:
*   When a delay measurement has completed, this API can be used to access
*   the measured DM count.     
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                          
*   pm_tcm_num      - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t.
*
* OUTPUTS:
*   *dm_count           - delay measurement result in ODUk frame periods
*                         When measure counter isnot ready, *dm_count is set 
*                         to 0xFFFF_FFFF and it value should be ignored.
*                         If delay measurement is not started ahead, *dm_count
*                         is set to 0xFFFF_FFFE.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_get_delay_measure_count(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                      UINT32 *dm_count)

{

    PMC_ERROR result = PMC_SUCCESS;
    UINT32 block_mode = 1;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if(result == PMC_SUCCESS) {

        result = odu_struct_pm_tcmi_get_delay_measure_count(digi_handle->coreotn_handle,
                                                            ((odu_struct_t *)chnl_ptr),
                                                            pm_tcm_num,
                                                            block_mode,
                                                            dm_count);
        
        
    }

    PMC_ATOMIC_RETURN(digi_handle,result);


} /* digi_otn_odu_get_delay_measure_count */

/*******************************************************************************
* digi_otn_odu_get_delay_measure_count_no_block
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Function same as digi_otn_odu_get_delay_measure_count, except that it
*   works in no-blocking mode.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                          
*   pm_tcm_num      - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t.
*
* OUTPUTS:
*   *dm_count           - delay measurement result in ODUk frame periods
*                         When measure counter isnot ready, *dm_count is set 
*                         to 0xFFFF_FFFF and it value should be ignored.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_get_delay_measure_count_no_block(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                      UINT32 *dm_count)

{

    PMC_ERROR result = PMC_SUCCESS;
    UINT32 block_mode = 0;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if (result == PMC_SUCCESS) 
    {
        result = odu_struct_pm_tcmi_get_delay_measure_count(digi_handle->coreotn_handle,
                                                            ((odu_struct_t *)chnl_ptr),
                                                            pm_tcm_num,
                                                            block_mode,
                                                            dm_count);
        
        
    }

    PMC_ATOMIC_RETURN(digi_handle,result);


} /* digi_otn_odu_get_delay_measure_count_no_block */

/*******************************************************************************
* digi_otn_msi_mode_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function sets the mode for configuring MSI field.\n\n
*
*   This function will modify the MSI mode for the MUX and DEMUX. If the MSI
*   mode is DIGI_OTN_MSI_CFG_AUTO during the call to digi_otn_server_lo_prov()
*   or digi_otn_server_lo_prov_asym(), then SWDRV will automatically
*   configure the tx MSI/expected MSI.  If the MSI mode is DIGI_OTN_MSI_CFG_MANUAL
*   when calling digi_otn_server_lo_prov() or digi_otn_server_lo_prov_asym(),
*   then MSI bytes will not be configure.
*
*   digi_otn_opu_rx_expected_msi_set() and digi_otn_opu_tx_msi_set() can be
*   called at anytime to overwrite the MSI bytes, regardless of the MSI mode.
*   
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   msi_cfg_mode        - Enum for MSI configuration mode. See digi_otn_msi_cfg_mode_t. \n
*                         -- DIGI_OTN_MSI_CFG_AUTO\n 
*                         -- DIGI_OTN_MSI_CFG_MANUAL\n
*                            
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_msi_mode_set( digi_handle_t *digi_handle,
                                        digi_otn_msi_cfg_mode_t msi_cfg_mode)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    result = coreotn_msi_cfg_mode_set(digi_handle->coreotn_handle,
                                      (util_global_otn_msi_cfg_mode_t) msi_cfg_mode);
                                                         
    
    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_msi_mode_set */


/*******************************************************************************
* digi_otn_msi_mode_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function gets the mode for configuring MSI field.\n\n
*   This function must be called after digi_device_init().\n\n
*   The value returned from this API is a global configuration mode that will 
*   apply to all channels.
*   
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.                            
*
* OUTPUTS:
*   *msi_cfg_mode        - Enum for MSI configuration mode. See digi_otn_msi_cfg_mode_t. \n
*                         -- DIGI_OTN_MSI_CFG_AUTO\n 
*                         -- DIGI_OTN_MSI_CFG_MANUAL\n
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_msi_mode_get( digi_handle_t *digi_handle,
                                        digi_otn_msi_cfg_mode_t *msi_cfg_mode)
{
    PMC_ERROR result = PMC_SUCCESS;
    util_global_otn_msi_cfg_mode_t msi_mode;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    result = coreotn_msi_cfg_mode_get(digi_handle->coreotn_handle,
                                      &msi_mode);

    *msi_cfg_mode = (digi_otn_msi_cfg_mode_t)(msi_mode);
                                                         
    
    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_msi_mode_get */


/*******************************************************************************
* digi_otn_opu_rx_expected_msi_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Configures expected MSI value for tributary slots used by
*   the OPU layer of the framer channel.
*
*   Before calling this API you must call digi_otn_msi_mode_set() with
*   DIGI_OTN_MSI_CFG_MANUAL.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on    
*   ts_port             - tributary port of the HO channel whose MSI value
*                         to be changed
*                         Valid range:
*                          HO ODU1 with 1G25 TS: 0 -- 1
*                          HO ODU1 with 2G5 TS : 0
*                          HO ODU2 with 1G25 TS: 0 -- 7
*                          HO ODU3 with 2G5 TS : 0 -- 15
*                          HO ODU4 with 1G25 TS: 0 -- 79                        
*   exp_msi             - expected MSI value
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_opu_rx_expected_msi_set(digi_handle_t *digi_handle,
                                                  digi_otn_odu_chnl_t *chnl_ptr,
                                                  UINT8 ts_port,
                                                  UINT8 exp_msi)
{
    
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_rx_expected_msi_set(digi_handle->coreotn_handle,
                                            (odu_struct_t *)chnl_ptr,
                                            ts_port,
                                            exp_msi,
                                            ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);                                         
    
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_opu_rx_expected_msi_set */


/*******************************************************************************
* digi_otn_opu_rx_expected_msi_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retreives expected multiplex structure identifier to indicate ODTU content 
*   of tributary slots occupied by a LO ODU channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                        
*
* OUTPUTS:
*   *msi_val             - Array of MSI values for the HO channel
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_opu_rx_expected_msi_get(digi_handle_t *digi_handle,
                                                  digi_otn_odu_chnl_t *chnl_ptr,
                                                  UINT8 msi_val[UTIL_GLOBAL_MAX_NUM_TS])
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    /* from the channel pointer, we get the calendar entries of the channel
    ** with this we get MSI value of all calendar entries
    */
    result = odu_struct_rx_expected_msi_get(digi_handle->coreotn_handle,
                                            (odu_struct_t *)chnl_ptr,
                                            (odu_struct_ext_mode_t)ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                            msi_val);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_opu_rx_expected_msi_get */

/*******************************************************************************
* digi_otn_opu_rx_expected_msi_per_ts_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retreives expected multiplex structure identifier to indicate ODTU content 
*   of the specified tributary slot within a HO or MO ODU channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on  
*   ts_port             - tributary port number. 
*                         Valid range:  
*                           HO ODU1 with 1G25 TS: 0 -- 1
*                           HO ODU1 with 2G5 TS : 0
*                           HO ODU2 with 1G25 TS: 0 -- 7
*                           HO ODU3 with 2G5 TS : 0 -- 15
*                           HO ODU4 with 1G25 TS: 0 -- 79 
*
* OUTPUTS:
*   *msi_val           - MSI value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_opu_rx_expected_msi_per_ts_get(digi_handle_t *digi_handle,
                                                         digi_otn_odu_chnl_t *chnl_ptr,
                                                         UINT8 ts_port,
                                                         UINT8* msi_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_rx_expected_msi_per_ts_get(digi_handle->coreotn_handle,
                                                   (odu_struct_t *)chnl_ptr,
                                                   (odu_struct_ext_mode_t)ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                                   ts_port, msi_val);

    PMC_ATOMIC_RETURN(digi_handle, result);                                                   
} /* digi_otn_opu_rx_expected_msi_per_ts_get */


/*******************************************************************************
* digi_otn_opu_tx_msi_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Configures expected MSI value for tributary slots used by
*   the OPU layer of the framer channel.
*
*   This function is valid on HO ODU channel and channelized MO ODU channel.
*   This function cannot be used on the unchannelized MO or LO ODU channels. 
*
*   Before calling this API you must call digi_otn_msi_mode_set() with
*   DIGI_OTN_MSI_CFG_MANUAL.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on
*   ts_port             - tributary port of a HO/MO channel whose MSI value
*                         to be updated
*                         Valid range:
*                          HO ODU1 with 1G25 TS: 0 -- 1
*                          HO ODU1 with 2G5 TS : 0
*                          HO ODU2 with 1G25 TS: 0 -- 7
*                          HO ODU3 with 2G5 TS : 0 -- 15
*                          HO ODU4 with 1G25 TS: 0 -- 79
*   msi_byte            - MSI byte for the specified tributary port
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_opu_tx_msi_set(digi_handle_t *digi_handle,
                                         digi_otn_odu_chnl_t *chnl_ptr,
                                         UINT8 ts_port,
                                         UINT8 msi_byte)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_tx_msi_set(digi_handle->coreotn_handle,
                                   (odu_struct_t *)chnl_ptr,
                                   ts_port,
                                   msi_byte,
                                   (odu_struct_target_t)ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);                                   
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_opu_tx_msi_set */

/*******************************************************************************
* digi_otn_opu_tx_msi_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retrieves MSI value of a single tributary slot or all tributary slots of 
*   the ODU channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on
*                         
*
* OUTPUTS:
*   *msi_val             - retrieved PSI bytes
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_opu_tx_msi_get(digi_handle_t *digi_handle,
                                         digi_otn_odu_chnl_t *chnl_ptr,
                                         UINT8 *msi_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(msi_val     != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_msi_get(digi_handle->coreotn_handle,
                                   (odu_struct_t *)chnl_ptr,
                                   ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                   msi_val);
               
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_opu_tx_msi_get */

/*******************************************************************************
* digi_otn_opu_tx_msi_per_ts_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retrieves MSI value of a single tributary slot of the ODU channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on
*   ts_port             - tributary port within a HO or MO whose MSI value to be
*                         extracted.
*                         Valid range:
*                          HO ODU1 with 1G25 TS: 0 -- 1
*                          HO ODU1 with 2G5 TS : 0
*                          HO ODU2 with 1G25 TS: 0 -- 7
*                          HO ODU3 with 2G5 TS : 0 -- 15
*                          HO ODU4 with 1G25 TS: 0 -- 79                       
*
* OUTPUTS:
*   *msi_val             - retrieved PSI bytes
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_opu_tx_msi_per_ts_get(digi_handle_t *digi_handle,
                                                digi_otn_odu_chnl_t *chnl_ptr,
                                                UINT8 ts_port,
                                                UINT8 *msi_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_msi_per_ts_get(digi_handle->coreotn_handle,
                                          (odu_struct_t *)chnl_ptr,
                                          ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                          ts_port, msi_val);
                                          
    PMC_ATOMIC_RETURN(digi_handle, result);
                                              
} /* digi_otn_opu_tx_msi_per_ts_get */

/*******************************************************************************
* digi_otn_opu_rx_accepted_msi_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retrieves accepted MSI value of all tributary slots of the ODU channel.
*
*   **There are special considerations for retreiving accepted MSI for partially
*   filled HOs (not all tribslots are occupied)**.
*
*   Calling digi_otn_opu_rx_accepted_msi_get() on a partially filled HO requires
*   waiting for the MSI acceptance on unused tribslots.
*   This delay can be avoided by calling digi_otn_opu_rx_partial_ho_accept_msi_init()
*   prior to this API.
*   
*     1) digi_otn_opu_rx_partial_ho_accept_msi_init() with init_msi == TRUE
*     2) wait for MSI acceptance process with the following delays:
*         HO ODU4 = 2692us
*         HO ODU3 = 3108us
*         HO ODU2 = 12484us
*         HO ODU1 = 50147us
*     3) Retrieve MSI using digi_otn_opu_rx_accepted_msi_get()
*     4) digi_otn_opu_rx_partial_ho_accept_msi_init() with init_msi == FALSE
*
*   If digi_otn_opu_rx_accepted_msi_get() is called without calling
*   digi_otn_opu_rx_partial_ho_accept_msi_init() first, the wait for MSI acceptance
*   will occur inside digi_otn_opu_rx_accepted_msi_get().
* 
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                         
*
* OUTPUTS:
*   *msi_val            - Array of MSI bytes for all tribslots in HO
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_opu_rx_accepted_msi_get(digi_handle_t *digi_handle,
                                                  digi_otn_odu_chnl_t *chnl_ptr,
                                                  UINT8 *msi_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(msi_val     != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_rx_accpt_msi_get(digi_handle->coreotn_handle,
                                         (odu_struct_t *)chnl_ptr,
                                         ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                         msi_val);
    
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_opu_rx_accepted_msi_get */


/*******************************************************************************
* digi_otn_opu_rx_partial_ho_accept_msi_init
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Sets special configuration so that MSI can be retrieved on unused tribslots
*   within an partially filled (or empty) HO.  This must be called prior to 
*   calling digi_otn_opu_rx_accepted_msi_get() to avoid waiting for the MSI
*   acceptance process.
*
*   Sequence:
*     1) digi_otn_opu_rx_partial_ho_accept_msi_init() with init_msi == TRUE
*     2) wait for MSI acceptance process with the following delays:
*         HO ODU4 = 2692us
*         HO ODU3 = 3108us
*         HO ODU2 = 12484us
*         HO ODU1 = 50147us
*     3) Retrieve MSI using digi_otn_opu_rx_accepted_msi_get()
*     4) digi_otn_opu_rx_partial_ho_accept_msi_init() with init_msi == FALSE
*         
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on
*   init_msi            - TRUE : Prepare the DMX to accept MSI on
*                                unused tribslots
*                         FALSE : remove work-around required to
*                                 receive MSI on unused tribslots           
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_opu_rx_partial_ho_accept_msi_init(digi_handle_t *digi_handle,
                                                            digi_otn_odu_chnl_t *chnl_ptr,
                                                            BOOL init_msi)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_rx_partial_ho_accept_msi_init(digi_handle->coreotn_handle,
                                                      (odu_struct_t *)chnl_ptr,
                                                      init_msi);
    
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_opu_rx_partial_ho_accept_msi_init */


/*******************************************************************************
* digi_otn_opu_rx_accepted_msi_per_ts_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retrieves accepted MSI value of a single tributary slot or all tributary 
*   slots of the ODU channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on      
*   ts_port             - tributary port of a HO/MO channel whose MSI is to be
*                         retrieved.                   
*                         Valid range: 
*                           HO ODU1 with 1G25 TS: 0 -- 1
*                           HO ODU1 with 2G5 TS : 0
*                           HO ODU2 with 1G25 TS: 0 -- 7
*                           HO ODU3 with 2G5 TS : 0 -- 15
*                           HO ODU4 with 1G25 TS: 0 -- 79
* OUTPUTS:
*   *msi_val              - retrieved PSI bytes
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_opu_rx_accepted_msi_per_ts_get(digi_handle_t *digi_handle,
                                                         digi_otn_odu_chnl_t *chnl_ptr,
                                                         UINT8 ts_port,
                                                         UINT8 *msi_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_rx_accpt_msi_per_ts_get(digi_handle->coreotn_handle,
                                                (odu_struct_t *)chnl_ptr,
                                                ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                                ts_port,
                                                msi_val);
                                                   
    PMC_ATOMIC_RETURN(digi_handle, result);                                                   
} /* digi_otn_opu_rx_accepted_msi_per_ts_get */                                                  

/*******************************************************************************
* digi_otn_odu_tx_tti_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   configures the transmitted TTI field of an ODU framer channel.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                            
*   pm_tcm_num      - PM or TCMi field instance: \n
*                     0      -- PM \n
*                     1 to 6 -- TCM1 to TCM6
*   tti_oh_ins      - enum, selects which TTI field will be inserted to the 
*                     corresponding TCM.
*                     See odu_struct_tti_oh_ins_t.
*   sapi            - SAPI characters (16 bytes)
*   dapi            - DAPI characters (16 bytes)
*   op_spec         - OPERATOR SPECIFIC characters (32 bytes)
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_tti_set(digi_handle_t *digi_handle,
                                         digi_otn_odu_chnl_t *chnl_ptr,
                                         odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                         odu_struct_tti_oh_ins_t tti_oh_ins,
                                         UINT8 sapi[16],
                                         UINT8 dapi[16],
                                         UINT8 op_spec[32])
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
     
    result = odu_struct_tx_tti_set(digi_handle->coreotn_handle,
                                   (odu_struct_t *)chnl_ptr,
                                   pm_tcm_num,
                                   tti_oh_ins,
                                   sapi, dapi, op_spec);                                  
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_tti_set */

/*******************************************************************************
* digi_otn_odu_tx_tti_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   retrieves the transmitted TTI field from an ODU framer channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on 
*   pm_tcm_num          - PM or TCMi field instance: \n
*                          0      -- PM \n
*                          1 to 6 -- TCM1 to TCM6                          
*                           
* OUTPUTS:                  
*   *sapi_ptr           - retrieved SAPI field
*   *dapi_ptr           - retrieved DAPI field
*   *op_spec_ptr        - retrieved OP_SPEC field
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tx_tti_get(digi_handle_t *digi_handle,
                                         digi_otn_odu_chnl_t *chnl_ptr,
                                         odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                         UINT8 *sapi_ptr,
                                         UINT8 *dapi_ptr,
                                         UINT8 *op_spec_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(sapi_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(dapi_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(op_spec_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_tti_get(digi_handle->coreotn_handle,
                                   (odu_struct_t *)chnl_ptr,
                                   pm_tcm_num,
                                   sapi_ptr, dapi_ptr, op_spec_ptr);
                                      
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tx_tti_get */

/*******************************************************************************
* digi_otn_odu_rx_expected_tti_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   configures the receive expected TTI field of an ODU framer channel.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                         
*   pm_tcm_num      - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t. 
*   sapi            - SAPI characters (16 bytes)
*   dapi            - DAPI characters (16 bytes)
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_expected_tti_set(digi_handle_t *digi_handle,
                                                  digi_otn_odu_chnl_t *chnl_ptr,
                                                  odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                  UINT8 sapi[16],
                                                  UINT8 dapi[16])
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_rx_exp_tti_set(digi_handle->coreotn_handle,
                                       (odu_struct_t *)chnl_ptr,
                                       pm_tcm_num,
                                       sapi, dapi);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_expected_tti_set */

/*******************************************************************************
* digi_otn_odu_rx_accepted_tti_lock
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Help retrieving the received accepted TTI field. 
*   This function only needs to be called once for a digi chip. It covers all
*   CORE OTN ODU Rx framers.
*   Typical sequences:
*     digi_otn_odu_rx_accepted_tti_lock(..., TRUE);
*     A series of digi_otn_odu_rx_accepted_tti_get().
*     digi_otn_odu_rx_accepted_tti_lock(..., FALSE);
* 
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   set                 - TRUE: lock TII\n
*                         FALSE: unlock TTI\n                          
*                          
* OUTPUTS:                 
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*   After calling the function, the caller must wait at least 6.3 ms for the 
*   lock operation to start to take effect!
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_accepted_tti_lock(digi_handle_t *digi_handle,
                                                  BOOL8 set)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    result = odu_struct_rx_accepted_tti_lock(digi_handle->coreotn_handle, set);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_accepted_tti_lock */

/*******************************************************************************
* digi_otn_odu_rx_accepted_tti_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves the received accepted TTI field from an ODU framer channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                            
*   pm_tcm_num          - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t.
*                          
* OUTPUTS:                 
*   *sapi_ptr           - retrieved SAPI field value
*   *dapi_ptr           - retrieved DAPI field value
*   *op_spec_ptr        - retrieved OP_SPEC field value
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_accepted_tti_get(digi_handle_t *digi_handle,
                                                  digi_otn_odu_chnl_t *chnl_ptr,
                                                  odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                  UINT8 *sapi_ptr,
                                                  UINT8 *dapi_ptr,
                                                  UINT8 *op_spec_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(sapi_ptr    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(dapi_ptr    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(op_spec_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_rx_accpt_tti_get(digi_handle->coreotn_handle,
                                         (odu_struct_t *)chnl_ptr,
                                         pm_tcm_num,
                                         sapi_ptr, dapi_ptr, op_spec_ptr);
                                      
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_accepted_tti_get */

/*******************************************************************************
* digi_otn_odu_rx_expected_tti_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves the expected TTI field from an ODU framer channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                            
*   pm_tcm_num          - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t.
*                          
* OUTPUTS:                 
*   *sapi_ptr           - retrieved SAPI field value
*   *dapi_ptr           - retrieved DAPI field value
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rx_expected_tti_get(digi_handle_t *digi_handle,
                                                  digi_otn_odu_chnl_t *chnl_ptr,
                                                  odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                  UINT8 *sapi_ptr,
                                                  UINT8 *dapi_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(sapi_ptr    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(dapi_ptr    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_rx_exp_tti_get(digi_handle->coreotn_handle,
                                       (odu_struct_t *)chnl_ptr,
                                       pm_tcm_num,
                                       sapi_ptr, dapi_ptr);
                                      
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_rx_expected_tti_get */

/*******************************************************************************
* digi_otn_opu_tx_pt_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   configures transmit PT field in the OPU layer of a framer channel.
*
*   G.709 "Table 15-8 - Payload type code points" dictates that
*   PT should change when inserting NULL frame or PRBS.  Note, that the
*   SW does not modify the TX/RX PT when inserting PRBS or NULL frame
*   (programming the RX/TX PT is the responsibility of the user).
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                   
*   pt_val          - PT value
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_opu_tx_pt_set(digi_handle_t *digi_handle,
                                        digi_otn_odu_chnl_t *chnl_ptr,
                                        UINT8 pt_val)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_pt_set(digi_handle->coreotn_handle,
                                  (odu_struct_t *)chnl_ptr,
                                  pt_val,
                                  ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_opu_tx_pt_set */

/*******************************************************************************
* digi_otn_opu_tx_pt_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves transmit PT field from the OPU layer of a framer channel.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on
*                            
* OUTPUTS:
*   *pt_val         - retrieved PT field value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_opu_tx_pt_get(digi_handle_t *digi_handle,
                                        digi_otn_odu_chnl_t *chnl_ptr,
                                        UINT8 *pt_val)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(pt_val      != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tx_pt_get(digi_handle->coreotn_handle,
                                  (odu_struct_t *)chnl_ptr,
                                  (odu_struct_ext_mode_t)ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE,
                                  pt_val);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_opu_tx_pt_get */

/*******************************************************************************
* digi_otn_opu_rx_expected_pt_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   configures receive expected PT field in the OPU layer of a framer channel.
*
*   G.709 "Table 15-8 - Payload type code points" dictates that
*   PT should change when inserting NULL frame or PRBS.  Note, that the
*   SW does not modify the TX/RX PT when inserting PRBS or NULL frame
*   (programming the RX/TX PT is the responsibility of the user).
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                         
*   pt_val          - PT value. Refer to Table 15-8 of G.709 for standards 
*                     defined values. 
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_opu_rx_expected_pt_set(digi_handle_t *digi_handle,
                                                 digi_otn_odu_chnl_t *chnl_ptr,
                                                 UINT8 pt_val)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_rx_expected_pt_set(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr,
                                           pt_val);
                                               
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_opu_rx_expected_pt_set */

/*******************************************************************************
* digi_otn_opu_rx_accepted_pt_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves receive accepted PT field from the OPU layer of a framer channel.\n\n
*
*   This API is only valid for ODU framers provisioned with tributary slot
*   payload DIGI_ODU_TS_1G25 or DIGI_ODU_TS_2G5.  In invalid cases a SW
*   assertion will be raised.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on
*                            
* OUTPUTS:
*   *accpt_pt_val       - retrieved PT field value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_opu_rx_accepted_pt_get(digi_handle_t *digi_handle,
                                                 digi_otn_odu_chnl_t *chnl_ptr,
                                                 UINT8 *accpt_pt_val)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr     != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(accpt_pt_val != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_rx_accepted_pt_get(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr,
                                           accpt_pt_val);
  
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_opu_rx_accepted_pt_get */

/*******************************************************************************
* digi_otn_opu_rx_expected_pt_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   retrieves receive expected PT field from the OPU layer of a framer channel.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_ptr              - pointer to ODU framer channel handle to be operated 
*                            on
* OUTPUTS:
*   *exp_pt_val            - retrieved PT field value.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_opu_rx_expected_pt_get(digi_handle_t *digi_handle,
                                                 digi_otn_odu_chnl_t *chnl_ptr,
                                                 UINT8 *exp_pt_val)
{
   
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_rx_expected_pt_get(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr,
                                           exp_pt_val);
  
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_opu_rx_expected_pt_get */


/*******************************************************************************
* digi_otn_odu_tcmi_maint_sig_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
* 
*   Used to force a maintenance signal at a particular TCM layer.
*
*   For Sink (RX):
*      The TCM layer provided will get sunk and then maintance signal will
*      will be applied for downstream layers.  You must provide an
*      operation TCM to this API.  It is not valid to provide the PM
*      layer to this API.  To force a maintenance signal before TCM
*      layer processing, use digi_otn_odu_maint_sig_set() 
*
*   For Source (TX):
*      The maintenance signal will be forced at ODUkT apadtation layer
*      (See G.798 14.5.1.2.1 ODUkT to ODUk adaptation source function).
*      Only valid to insert ODUk-LCK).  Note, when forcing LCK at a
*      particular TCM, LCK generation occurs before overhead insertion.
*      Therefore, if forcing LCK at a TCM, that TCM will remain operational
*      and all parent TCMs will see LCK.
*
*   To remove the maintenance signal, call this function with 
*   maint_sig == 0
*
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                       
*   direction       - direction of the signal insertion \n
*                     0 -- Sink \n
*                     1 -- Source
*   pm_tcm_num      - TCMi field instance: \n
*                     1 to 6    -- TCM1 to TCM6
*                     (must provide an operational TCM
*                      not valid to provide PM layer. To
*                      insert on top of PM provide first layer TCM
*                      or use TX digi_otn_odu_odukp_pck_maint_sig_set.
*   maint_sig       - enum,requested maintenance signal: 
*                     CORE_OTN_NO_MAINT_SIG 
*                     CORE_OTN_ODUK_AIS 
*                     CORE_OTN_ODUK_LCK 
*                     CORE_OTN_ODUK_OCI
* OUTPUTS:
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tcmi_maint_sig_set(digi_handle_t *digi_handle,
                                                    digi_otn_odu_chnl_t *chnl_ptr,
                                                    UINT8 direction,
                                                    odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                    coreotn_maint_sig_type_t maint_sig)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tcm_maint_sig_set(digi_handle->coreotn_handle,
                                          (odu_struct_t *)chnl_ptr,
                                          (odu_struct_stream_dir_t)direction,
                                          pm_tcm_num, 
                                          maint_sig,
                                          ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_pm_tcmi_maint_sig_set */

/*******************************************************************************
* digi_otn_odu_tcmi_maint_sig_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Gets the forced insertion of ODUk maintenance signals at a particular
*   TCM layer
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                       
*   direction       - direction of the signal insertion \n
*                     0 -- Sink \n
*                     1 -- Source
*   pm_tcm_num      - PM or TCMi field instance: \n
*                     0         -- PM \n
*                     1 to 6    -- TCM1 to TCM6
* OUTPUTS:
*   maint_sig       - maintenance signal that is forced
*                     CORE_OTN_NO_MAINT_SIG 
*                     CORE_OTN_ODUK_AIS 
*                     CORE_OTN_ODUK_LCK 
*                     CORE_OTN_ODUK_OCI
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tcmi_maint_sig_get(digi_handle_t *digi_handle,
                                                 digi_otn_odu_chnl_t *chnl_ptr,
                                                 UINT8 direction,
                                                 odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                 coreotn_maint_sig_type_t *maint_sig)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    if (direction > 1)
    {
        PMC_ATOMIC_RETURN(digi_handle,COREOTN_ERR_INVALID_ARG);
    }
    
    if (direction == 0)
    {  
        /* for SINK */

        result = odu_struct_rx_tcm_maint_sig_get(digi_handle->coreotn_handle,
                                                 (odu_struct_t *)chnl_ptr,
                                                 pm_tcm_num,
                                                 ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                                 maint_sig);



    }
    else {

        /* for SOURCE */
        result = odu_struct_tx_tcm_maint_sig_get(digi_handle->coreotn_handle,
                                                 (odu_struct_t *)chnl_ptr,
                                                 pm_tcm_num,
                                                 ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                                 maint_sig);

                                                  
    }                                                    
                                                 
    PMC_ATOMIC_RETURN(digi_handle,result);                                                 
} /* digi_otn_odu_tcmi_maint_sig_get */
                  



/*******************************************************************************
* digi_otn_odu_maint_sig_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Gets the channelized maintenance signal insertion.  For sink, this is
*   the maintenance signal that's applied prior to TCM processing. For
*   source, this is the maintenance signal applied before TCM sourcing.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                       
*   direction       - direction of the signal insertion \n
*                     0 : Sink \n
*                     1 : Source
*
* OUTPUTS:
*   maint_sig       - maintenance signal that's forced \n
*                     0 : CORE_OTN_NO_MAINT_SIG \n
*                     1 : CORE_OTN_ODUK_AIS \n
*                     2 : CORE_OTN_ODUK_LCK \n
*                     3 : CORE_OTN_ODUK_OCI 
*                     4 : CORE_OTN_ODUK_OCI_NOMINAL
*                     5 : CORE_OTN_ODUK_LCK_NOMINAL
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_maint_sig_get(digi_handle_t *digi_handle,
                                            digi_otn_odu_chnl_t *chnl_ptr,
                                            UINT8 direction,
                                            coreotn_maint_sig_type_t *maint_sig)
{
    PMC_ERROR result = PMC_SUCCESS;
    odu_struct_t *odu_ptr;
    BOOL sig_is_nominal = FALSE;
    coreotn_maint_sig_type_t maint_sig_reg;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    odu_ptr = (odu_struct_t *)chnl_ptr;
    
    if (direction > 1)
    {
        PMC_ATOMIC_RETURN(digi_handle,COREOTN_ERR_INVALID_ARG);
    }

    result = odu_struct_maint_sig_get(digi_handle->coreotn_handle,
                                      odu_ptr,
                                      (odu_struct_stream_dir_t)direction,
                                      &maint_sig_reg);
                   
    if(direction == 1)
    {
                    
        if (odu_ptr->switch_data.oduk_data.lineotn_src)
        {
            if(odu_ptr->mem_ptr->odu_level ==  ODU_STRUCT_LEVEL_HO_ODU)
            {
                sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_HO_LINE, odu_ptr->switch_data.oduk_data.channel);
            }
            else if(odu_ptr->mem_ptr->odu_level ==  ODU_STRUCT_LEVEL_MO_ODU)
            {
                sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_MO_LINE, odu_ptr->switch_data.oduk_data.channel);
            }
            else if(odu_ptr->mem_ptr->odu_level ==  ODU_STRUCT_LEVEL_LO_ODU)
            {
                sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_LO_LINE, odu_ptr->switch_data.oduk_data.channel);
            }
        }
        else
        {
            if(odu_ptr->mem_ptr->odu_level ==  ODU_STRUCT_LEVEL_HO_ODU)
            {
                sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_HO_SYS, odu_ptr->switch_data.oduk_data.channel);
            }
            else if(odu_ptr->mem_ptr->odu_level ==  ODU_STRUCT_LEVEL_MO_ODU)
            {
                sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_MO_SYS, odu_ptr->switch_data.oduk_data.channel);
            }
        }
    }
    else
    {
        /*need to consider line/sys facing RFRMs at egress or ODUKSW*/
        if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_3B_ODU)
        {
            if(DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
            {
                sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_RX_SYS, odu_ptr->switch_data.oduk_data.channel);
            }
            else
            {
                sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_RX_LINE, odu_ptr->switch_data.oduk_data.channel);
            }
        }
        else if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC)
        {
            sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_RX_LINE, odu_ptr->switch_data.oduk_data.channel);
        }
    }

    if (CORE_OTN_ODUK_AIS == maint_sig_reg && sig_is_nominal)
    {
        *maint_sig = CORE_OTN_ODUK_AIS_NOMINAL;
    }
    else if(CORE_OTN_ODUK_LCK == maint_sig_reg && sig_is_nominal)
    {
        *maint_sig = CORE_OTN_ODUK_LCK_NOMINAL;
    }
    else
    {
        *maint_sig = maint_sig_reg;
    }

                                                 
    PMC_ATOMIC_RETURN(digi_handle,result);                                                 
} /* digi_otn_odu_maint_sig_get */



/*******************************************************************************
* digi_otn_odu_pm_tcmi_mode_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function retrieves the operational mode of PM or TCMi layer from an
*   ODU framer channel
*
*   Prior to calling this API, the layer must have been configured with
*   digi_otn_pm_tcmi_set() API. 
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                      
*   direction       - direction  \n
*                     0 -- transmit \n
*                     1 -- receive
*   pm_tcm_num      - PM or TCMi instance. See odu_struct_odu_frm_pm_tcm_id_t.                     
*
* OUTPUTS:
*   *mode           - functional mode of layer source function.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_pm_tcmi_mode_get(digi_handle_t *digi_handle,
                                               digi_otn_odu_chnl_t *chnl_ptr,
                                               UINT8 direction,
                                               odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                               odu_struct_pm_tcm_mode_t *mode)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr    != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    PMC_ASSERT(mode        != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    if (direction == 0)
    {
        result = odu_struct_tx_pm_tcmi_mode_get(digi_handle->coreotn_handle,
                                                (odu_struct_t *)chnl_ptr,
                                                pm_tcm_num,
                                                ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                                mode);
    }
    else {
        result = odu_struct_rx_pm_tcmi_mode_get(digi_handle->coreotn_handle,
                                                (odu_struct_t *)chnl_ptr,
                                                pm_tcm_num,
                                                ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                                mode);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);   
} /* digi_otn_odu_pm_tcmi_mode_get */

/*******************************************************************************
* digi_otn_odu_tcm_pool_id_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the pool ID associated with the TCM instance of given ODU channel.
*
*   Prior to calling this API, digi_otn_odu_rx_pm_tcmi_set() or 
*   digi_otn_odu_tx_pm_tcmi_set() must have been called to provision a layer 
*   with a pooled resource. Calling this API for a unprovisioned layer will 
*   return 'ODU_STRUCT_UNASSIGNED_POOL_ID'.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                      
*   direction       - direction  \n
*                     0 -- Sink (receive) \n
*                     1 -- Source (transmit)
*   pm_tcm_num      - PM or TCMi field instance: \n
*                     1 to 6    -- TCM1 to TCM6 \n
*                     7         -- Floating TCM \n 
*                     8         -- PM_NIM
*
* OUTPUTS:
*   *tcm_pool_id    - pool id of TCM resource inside the odu struct
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_tcm_pool_id_get(digi_handle_t *digi_handle,
                                              digi_otn_odu_chnl_t *chnl_ptr,
                                              UINT8 direction,
                                              odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                              UINT16 *tcm_pool_id)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_tcm_pool_id_from_instance_get(digi_handle->coreotn_handle,
                                                      (odu_struct_t *)chnl_ptr,
                                                      (odu_struct_stream_dir_t)direction,
                                                      pm_tcm_num, tcm_pool_id);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_tcm_pool_id_get */   

/*
** Status retrieval APIs
*/

/*******************************************************************************
* digi_otn_opu_null_payload_status_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function retrieves whether or not the ODU channel is configured with 
*   NULL payload.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on 
*
* OUTPUTS:
*   *null_status    - indicates if the ODU channel has NULL payload or not.
*                     TRUE  -- the channel has NULL payload.
*                     FALSE -- the channel does not have NULL payload.
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_opu_null_payload_status_get(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      BOOL8 *null_status)
{
    PMC_ERROR result = PMC_SUCCESS;
    util_global_odu_line_payload_t payload_format;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_otn_opu_payload_get(digi_handle->coreotn_handle,
                                            (odu_struct_t *)chnl_ptr,
                                            &payload_format);

    if (PMC_SUCCESS == result)
    {
        if (UTIL_GLOBAL_ODU_NULL == payload_format)
        {
            *null_status = TRUE; 
        }
        else {
            *null_status = FALSE;
        }                                                 
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_opu_null_payload_status_get */


/*******************************************************************************
* digi_otn_server_line_tx_rx_dsi_lane_align
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The function realigns RX/TX post-MLD lanes associated to LINEOTN server 
*   channel to allow SFIS OTU DIAGNOSTIC/FACILITY loopback for asymetric RX/TX
*   lanes.
*
*   Note that this API should be called only for diagnostic purpose. DSI lanes
*   alignment should be unconfigured after loopback unconfiguration.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *otn_server_ptr        - Pointer to a resource allocation
*                            context for the LINEOTN server configured against the
*                            specified serdes port.
*   enable                 - when TRUE RX/TX post-dsi lanes are aligned
*                            when FALSE, RX/TX post-dsi lanes are reconfigures
*                            as per initial setting 
*
* OUTPUTS:
*  None.
*
* RETURNS:
*   PMC_SUCCESS            - when API execution is successful otherwise a 
*                            descriptive error is returned. 
*
* NOTES:
*  None.
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_line_tx_rx_dsi_lane_align(digi_handle_t          *digi_handle,
                                                           digi_otn_server_chnl_t *otn_server_ptr,
                                                           BOOL8                   enable)
{
    PMC_ERROR rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t* otn_server_def_ptr=NULL;
    digi_post_mld_dsi_ctxt_t *p_post_mld_lanes = NULL;
    digi_serdes_port_t* port_ctxt_ptr = NULL;
    digi_serdes_port_rate_prov_state_t serdes_port_prov_state; 
    digi_serdes_prov_state_t prov_state;
 

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);

    if (PMC_SUCCESS != digi_otn_server_chnl_handle_validate(digi_handle, otn_server_ptr))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }

    otn_server_def_ptr = (digi_otn_server_chnl_def_t*)(otn_server_ptr);

    PMC_ASSERT(otn_server_def_ptr->dci_chnl< DIGI_SERDES_XFI_LANES_MAX, DIGI_ERR_INVALID_ARG, otn_server_def_ptr->dci_chnl, 0);
    PMC_ASSERT(otn_server_def_ptr->dsi_base_chnl < DIGI_SERDES_XFI_LANES_MAX || 17==otn_server_def_ptr->dsi_base_chnl, DIGI_ERR_INVALID_ARG, otn_server_def_ptr->dsi_base_chnl, 0);
    PMC_ASSERT(otn_server_def_ptr->dsi_serdes_type <  (UINT8)LAST_LINE_OTN_DSI_TYPE , DIGI_ERR_INVALID_ARG, otn_server_def_ptr->dsi_base_chnl, 0);
    
    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_server_def_ptr);

    /* retrieve DSI lanes provisioning status */
    if (PMC_SUCCESS == rc) {
        rc = digi_by_port_uid_post_mld_prov_state_get(digi_handle, 
                                                 otn_server_def_ptr->port_uid,
                                                 &prov_state);

    }

    /* serdes port associated to otn server channel */
    if (PMC_SUCCESS == rc) 
    { 
        port_ctxt_ptr = digi_port_ctxt_no_type_find(digi_handle, otn_server_def_ptr->port_uid);
        
        if (port_ctxt_ptr == NULL) {

            PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, otn_server_def_ptr->port_uid, 0);
            
        }         
    }

    /* check that port is not in loopback mode */
    if (PMC_SUCCESS == rc) 
    {        
        if (prov_state != DIGI_SERDES_PROV_STATE_LINEOTN)
        {
            rc = DIGI_ERR_INVALID_ARG;
        }
        else
        {
            /* check if we have an active loopback on this segment */
            /* CHECK SERDES LOOPBACK */
            serdes_port_prov_state = digi_serdes_port_prov_status_get(digi_handle, ((digi_serdes_port_def_t*)(port_ctxt_ptr))->port_uid); 
            if (DIGI_SERDES_PORT_RATE_STATE_PROV_FACILITY_LPBK == serdes_port_prov_state || DIGI_SERDES_PORT_RATE_STATE_PROV_DIAG_LPBK == serdes_port_prov_state) 
            { 
                rc = DIGI_ERR_LOOPBACK_STILL_ACTIVE; 
            } 
            /* CHECK LINEOTN LOOPBACK */
            if (PMC_SUCCESS == rc)
            {
                if (TRUE == otn_server_def_ptr->loopback_enabled)
                {
                    rc = DIGI_ERR_LOOPBACK_STILL_ACTIVE; 
                }
            }
        }
    }

    /* unconfigure post-dsi lanes in LIFD */
    if (PMC_SUCCESS == rc)
    {
        /* last step - update the prov state with unassigned status */
        p_post_mld_lanes=digi_first_post_mld_dsi_find(digi_handle,otn_server_def_ptr->port_uid);
        
        if( p_post_mld_lanes != NULL )
        {
            if( DIGI_SERDES_PROV_STATE_LINEOTN == p_post_mld_lanes->prov_state )  /* port found - check that it is configured and assigned to lineotn */
            {
                
                rc = digi_serdes_port_lifd_sifd_subsytem_disable(digi_handle,
                                                                 otn_server_def_ptr->port_uid);
                /* We should never get here as this means our state is corrupt */
                PMC_ASSERT(PMC_SUCCESS == rc, rc, 0, 0);
                
                if (0 && PMC_SUCCESS == rc) {
                    rc = digi_post_mld_prov_state_set(digi_handle,otn_server_def_ptr->port_uid,DIGI_SERDES_PROV_STATE_UNASSIGNED); /* if this is lineotn port - unassign it  */
                    if(PMC_SUCCESS == rc)
                    {
                        
                        rc = digi_serdes_port_rate_state_set(digi_handle, 
                                                             port_ctxt_ptr, 
                                                             LAST_DIGI_SERDES_PORT_MODE, 
                                                             DIGI_SERDES_PROV_STATE_UNASSIGNED, 
                                                             DIGI_SERDES_PORT_RATE_STATE_DEPROV);
                        
                    }
                    else
                        rc = DIGI_ERR_INVALID_ARG; /* this is not a lineotn port/dsi lane or,serdes is not initialized or,already provisioned as lineotn - exit */
                    
                }
            }
            else
                rc = DIGI_ERR_NO_DSI_ALLOC_PROV; 
        }
    }

    /* allign RX/TX post-dsi lanes or 
       configure them back according to initial setting */
    if (PMC_SUCCESS == rc)
    {
        if ( TRUE == enable)
        {
            rc = digi_serdes_port_lifd_mux_align_rx_tx_cfg(digi_handle, 
                                                           (digi_serdes_port_def_t*)port_ctxt_ptr,
                                                           XIFD_DSIS_OTN);
        }    
        else
        {
            rc = digi_serdes_port_lifd_sifd_mux_cfg(digi_handle, 
                                                    (digi_serdes_port_def_t*)port_ctxt_ptr,
                                                    XIFD_DSIS_OTN);
        }
    }

    PMC_ATOMIC_RETURN(digi_handle, rc);
} /*digi_otn_server_line_tx_rx_dsi_lane_align*/


/*******************************************************************************
* digi_otn_pm_status_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  Function reads the PM/TCM status values set via functions:
*  digi_otn_odu_int_pm_chnl_enable/disable, digi_otn_odu_int_pid_enable/
*  disable and digi_otn_odu_int_defect_enable/disable. These status values
*  may be set in interrupts and determine the setting of other interrupts.
*  The values read back are read from SW storage and not from register 
*  values.
*
* INPUTS:
*  *digi_handle         - pointer to DIGI handle instance.
*  chnl_handle          - Reference to the chanel handle whose status is
*                         being retrieved.  NULL if ODU level is specified
*                         in odu_level.
*  odu_level            - ODU level to be reference. Only used if
*                         chnl_handle is NULL otherwise ignored.
*
* OUTPUTS:
*   *pm_table_ptr        - Pointer to table to hold interrupt status values
*
* RETURNS:
*  PMC_SUCCESS            - Table successfully populated.
*  PMC_ERROR              - Otherwise
*
* NOTES:
*  None.
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_pm_status_get(digi_handle_t *digi_handle,
                                        digi_otn_odu_chnl_t *chnl_handle,
                                        odu_struct_odu_level_t odu_level,
                                        util_global_otn_pm_status_t *pm_table_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    coreotn_int_chnl_info_t chnl_info;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != pm_table_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Enable interrupts */
    PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));

    if (NULL != chnl_handle)
    {
        chnl_info.odu_level = ((odu_struct_t *)chnl_handle)->mem_ptr->odu_level;
    }
    else
    {
        chnl_info.odu_level = odu_level;
    }

    if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    { 
        chnl_info.source = COREOTN_INT_SOURCE_SYS; 
    }
    else
    {
        chnl_info.source = COREOTN_INT_SOURCE_LINE; 
    }


    result = coreotn_pm_status_get(digi_handle->coreotn_handle,
                                   &chnl_info,
                                   pm_table_ptr);
    

    PMC_ATOMIC_RETURN(digi_handle, result);
}

/*
** OTN_PRBS APIs
*/ 

/* LCOV_EXCL_START */
/*******************************************************************************
* digi_otn_prbs_dlss_status_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function is used to retreive the state of PRBS DLSS defects on the 
*   PRBS channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on 
*   prbs_chnl           - prbs channel ID
*                         Valid range: 0 - 11
*
* OUTPUTS:
*   *dlss_stat          - current state of PRBS dlss defect for the prbs channel
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_prbs_dlss_status_get(digi_handle_t* digi_handle,
                                               digi_otn_odu_chnl_t *chnl_ptr,
                                               UINT32 prbs_chnl, 
                                               UINT8 *dlss_stat)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle); 

    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_prbs_dlss_status_get(digi_handle->coreotn_handle,
                                             (odu_struct_t *)chnl_ptr,
                                             prbs_chnl, dlss_stat);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_prbs_dlss_status_get */
/* LCOV_EXCL_STOP */

/*******************************************************************************
*  digi_otn_prbs_chnl_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Initialize PRBS block to generate or monitor the pattern on the channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on 
*   prbs_chid           - channel ID to be provisioned 
*                         Valid range: 0 - 11
*   prbs_operation      - mode of operation \n
*                         0 -- PRBS monitor \n
*                         1 -- PRBS generator
*   mode                - operational mode \n
*                         0 -- disable \n
*                         1 -- enable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_prbs_chnl_init(digi_handle_t *digi_handle,
                                         digi_otn_odu_chnl_t *chnl_ptr,  
                                         UINT32 prbs_chid,
                                         UINT32 prbs_operation,
                                         UINT32 mode)
{
    /* variable declaration */
    PMC_ERROR                result = PMC_SUCCESS;
    UINT32                   prbs_chnl;
    coreotn_prbs_inst_t      prbs_inst;
    coreotn_int_prbs_chnl_t *prbs_en_ptr;  
    BOOL8                   prbs_gen_enbl = FALSE;
    UINT32 *null_chan_en = NULL;
    UINT32 *prbs_null_chan_en = NULL;
    UINT32 mapotn_chnl;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));    

    if (PMC_SUCCESS == result)
    {
        result = odu_struct_prbs_inst_get(digi_handle->coreotn_handle,
                                          (odu_struct_t *)chnl_ptr,
                                          &prbs_inst);
    }
    
    if (mode == 0 && prbs_operation == 1)
    {
        result = coreotn_prbs_chnl_prov_get(digi_handle->coreotn_handle,
                                            prbs_inst,
                                            prbs_chid,
                                            &prbs_gen_enbl);
    }

    if (PMC_SUCCESS == result)
    {                                     
        result = coreotn_prbs_chnl_init(digi_handle->coreotn_handle,
                                        prbs_inst, 
                                        prbs_chid,
                                        ((odu_struct_t *)chnl_ptr)->switch_data.oduk_data.channel,
                                        prbs_operation,
                                        mode);      
    }

    if(prbs_inst == COREOTN_FO2_PRBS &&
       prbs_operation == 1)
    {
        mapotn_chnl = ((odu_struct_t *)chnl_ptr)->switch_data.oduk_data.channel;

        /*call API to retrieve spare context that lives in COREOTN*/
        coreotn_mapotn_null_frame_mode_ptr_get(digi_handle->coreotn_handle,
                                               &null_chan_en,
                                               &prbs_null_chan_en);

        if(mode == 1)
        {
            prbs_null_chan_en[mapotn_chnl/32] = prbs_null_chan_en[mapotn_chnl/32] | (1 << (mapotn_chnl % 32));
        }
        else
        {
            prbs_null_chan_en[mapotn_chnl/32] = prbs_null_chan_en[mapotn_chnl/32] & ~(1 << (mapotn_chnl % 32));
        }

        
        result = mapotn_null_frame_cfg(digi_handle->mapotn_handle,
                                       mapotn_chnl, 
                                       UTIL_GLOBAL_DIR_TX,
                                       null_chan_en,
                                       prbs_null_chan_en);


    }
    
   
    /* Disable PRBS interrupts if disabling monitoring mode */
    if ((FALSE == mode) && (0 == prbs_operation) && (PMC_SUCCESS == result))
    {
        if (digi_otn_odu_int_prbs_is_prov(digi_handle,
                                          chnl_ptr,
                                          &prbs_chnl,
                                          &prbs_inst,
                                          &prbs_en_ptr))
        {
            /* Disable interrupts */
            result = coreotn_int_prbs_chnl_enable(digi_handle->coreotn_handle,
                                                  prbs_chnl,
                                                  prbs_inst,
                                                  DIGI_INT_ALL_INTS,
                                                  prbs_en_ptr,
                                                  DIGI_DISABLE);
        }

    }

    if (PMC_SUCCESS == result)
    {
        if (1 == prbs_operation)
        {

            if (PMC_SUCCESS == result)
            {
                if ((prbs_gen_enbl == TRUE && mode == 0) || mode == 1)
                {                                           
                    result = odu_struct_prbs_tfrm_cfg(digi_handle->coreotn_handle,
                                                          (odu_struct_t *)chnl_ptr,
                                                          0 != mode ? TRUE : FALSE);
                }
            }
            
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_prbs_chnl_init */       

/*******************************************************************************
*  digi_otn_prbs_pattern_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Provisions a channel with the specified PRBS pattern.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on
*   prbs_chid           - channel ID that carries PRBS pattern
*                         Valid range: 0 - 11
*   prbs_pattern        - PRBS pattern to transmit. See coreotn_prbs_pattern_t. \n
*                         0 -- OTN_INVERTED_PRBS_11 \n
*                         1 -- OTN_INVERTED_PRBS_31 \n
*                         2 -- OTN_PRBS_11 \n 
*                         3 -- OTN_PRBS_31
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_prbs_pattern_cfg(digi_handle_t *digi_handle,
                                           digi_otn_odu_chnl_t *chnl_ptr, 
                                           UINT32 prbs_chid,
                                           digi_otn_prbs_pattern_t prbs_pattern)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;
    coreotn_prbs_inst_t prbs_inst;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_prbs_inst_get(digi_handle->coreotn_handle,
                                      (odu_struct_t *)chnl_ptr,
                                      &prbs_inst);
                                      
    if (PMC_SUCCESS == result)
    {
        result = coreotn_prbs_pattern_cfg(digi_handle->coreotn_handle,
                                          prbs_inst,
                                          prbs_chid, 
                                          ((odu_struct_t *)chnl_ptr)->switch_data.oduk_data.channel, 
                                          (coreotn_prbs_pattern_t)prbs_pattern);                                      
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);    
} /* digi_otn_prbs_pattern_cfg */

/*******************************************************************************
*  digi_otn_prbs_ber_thres_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures the defect threshold count for the given PRBS channel. 
*   If the bit error rate goes over the programmed threshold in a gvien LCLK 
*   one second interval, the PRBS monitor will enter out of lock state.
*
* INPUTS:
*   *digi_handle          - pointer to DIGI handle instance
*   *chnl_ptr             - pointer to ODU framer channel handle to be operated on
*   prbs_ber_lo_thres     - lower 32 bits of the defect threshold count for the 
*                           given PRBS channel. 
*   prbs_ber_hi_thres     - upper 3 bits of the defect threshold count for the 
*                           given PRBS channel. 
*   prbs_reseed_thres     - number of bit errors detected before PRBS monitor reseed
*   prbs_reseed_interval  - number of cycles between re-seed attempts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_prbs_ber_thres_cfg(digi_handle_t *digi_handle,
                                             digi_otn_odu_chnl_t *chnl_ptr, 
                                             UINT32 prbs_ber_lo_thres, 
                                             UINT32 prbs_ber_hi_thres,
                                             UINT16 prbs_reseed_thres,
                                             UINT16 prbs_reseed_interval)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;
    coreotn_prbs_inst_t prbs_inst;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_prbs_inst_get(digi_handle->coreotn_handle,
                                      (odu_struct_t *)chnl_ptr,
                                      &prbs_inst);
                                      
    if (PMC_SUCCESS == result)
    {
        result = coreotn_prbs_ber_thres_cfg(digi_handle->coreotn_handle,
                                            prbs_inst,
                                            prbs_ber_lo_thres, 
                                            prbs_ber_hi_thres,
                                            prbs_reseed_thres,
                                            prbs_reseed_interval);
    }
                                                
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_prbs_ber_thres_cfg */

/*******************************************************************************
*  digi_otn_prbs_chnl_bit_err_inject
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Injecst a single bit error into the PRBS pattern for the channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on
*   prbs_chid           - channel ID that carries PRBS pattern
*                         Valid range: 0 - 11
*   insert_err          - control whether or not a single bit error will be 
*                         inserted in the PRBS pattern. \n
*                         1 -- a single bit erro is inserted once into the PRBS
*                              pattern for the channel \n
*                         0 -- defect insertion is disabled.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_prbs_chnl_bit_err_inject(digi_handle_t *digi_handle,
                                                   digi_otn_odu_chnl_t *chnl_ptr,
                                                   UINT32 prbs_chid, 
                                                   UINT32 insert_err)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;
    coreotn_prbs_inst_t prbs_inst;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_prbs_inst_get(digi_handle->coreotn_handle,
                                      (odu_struct_t *)chnl_ptr,
                                      &prbs_inst);
                                      
    if (PMC_SUCCESS == result)
    {
        result = coreotn_prbs_chnl_bit_err_inject(digi_handle->coreotn_handle,
                                                  prbs_inst,
                                                  prbs_chid, insert_err);
    }
                                                      
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_prbs_chnl_bit_err_inject */

/*******************************************************************************
*  digi_otn_prbs_chnl_defect_cnt_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retreives defect count for the PRBS channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on
*   prbs_chid           - channel ID that carries PRBS pattern
*                         Valid range: 0 - 11 
*
* OUTPUTS:
*   defect_cnt          - defect count for the given PRBS channel.
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_prbs_chnl_defect_cnt_get(digi_handle_t *digi_handle,
                                                   digi_otn_odu_chnl_t *chnl_ptr, 
                                                   UINT32 prbs_chid, 
                                                   UINT32 *defect_cnt)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;
    coreotn_prbs_inst_t prbs_inst;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_prbs_inst_get(digi_handle->coreotn_handle,
                                      (odu_struct_t *)chnl_ptr,
                                      &prbs_inst);
                                      
    if (PMC_SUCCESS == result)
    {
        result = coreotn_prbs_chnl_defect_cnt_get(digi_handle->coreotn_handle,
                                                  prbs_inst, 
                                                  prbs_chid, defect_cnt);
    }
                                                 
    PMC_ATOMIC_RETURN(digi_handle,result);    
} /* digi_otn_prbs_chnl_defect_cnt_get */   
  
/*******************************************************************************
*  digi_otn_chnl_prbs_pattern_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Provisions a channel with the specified PRBS pattern.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on
*   prbs_chid           - channel ID that carries PRBS pattern
*                         Valid range: 0 - 11
*
* OUTPUTS:
*   *prbs_pattern       - current PRBS pattern being transmitted. 
*                         See coreotn_prbs_pattern_t. \n
*                         0 -- OTN_INVERTED_PRBS_11 \n
*                         1 -- OTN_INVERTED_PRBS_31 \n
*                         2 -- OTN_PRBS_11 \n 
*                         3 -- OTN_PRBS_31
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_chnl_prbs_pattern_get(digi_handle_t *digi_handle,
                                                digi_otn_odu_chnl_t *chnl_ptr, 
                                                UINT32 prbs_chid,
                                                digi_otn_prbs_pattern_t *prbs_pattern)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;
    coreotn_prbs_inst_t prbs_inst;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check for invalid pointers */
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    result = odu_struct_prbs_inst_get(digi_handle->coreotn_handle,
                                      (odu_struct_t *)chnl_ptr,
                                      &prbs_inst);
                                      
    if (PMC_SUCCESS == result)
    {
        result = coreotn_prbs_pattern_get(digi_handle->coreotn_handle,
                                          (coreotn_prbs_inst_t)prbs_inst,
                                          prbs_chid, 
                                          ((odu_struct_t *)chnl_ptr)->switch_data.oduk_data.channel, 
                                          (coreotn_prbs_pattern_t *)prbs_pattern);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_chnl_prbs_pattern_get */                                          


/*******************************************************************************
* FUNCTION: digi_otn_odu_prbs_chid_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieve PRBS instance and channel, or returns that PRBS is not provisioned
*   on this ODU channel.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to check interrupts
*
* OUTPUTS:
*   prbs_chid       - channel ID that carries PRBS pattern (will be a
*                     value between 0-11).  Only valid if API returns
*                     PMC_SUCCESS.
*
* RETURNS:
*   PMC_SUCCESS                - PRBS is configured for this channel handle 
*   DIGI_ERR_PRBS_NOT_PROV     - PRBS not configured for this channel handle
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_prbs_chid_get(digi_handle_t          *digi_handle,
                                            digi_otn_odu_chnl_t    *chnl_handle,
                                            UINT32                 *prbs_chid)
{

    PMC_ERROR                   result = PMC_SUCCESS;
    UINT32                      dci_chnl;
    UINT32                      prbs_chnl;
    coreotn_prbs_inst_t         prbs_inst;
    BOOL                        prbs_chnl_valid;

    PMC_ATOMIC_ENTRY(digi_handle);

     /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, 
                                       (&((odu_struct_t *)chnl_handle)->switch_data));

    /* Retrieve prbs instance for this ODU channel */
    if (PMC_SUCCESS == result)
    {
        result = odu_struct_prbs_inst_get(digi_handle->coreotn_handle,
                                          (odu_struct_t *) chnl_handle,
                                          &prbs_inst);
    }

    /* Retrieve the PRBS channel for this ODU channel */
    if (PMC_SUCCESS == result)
    {
        dci_chnl = digi_otn_odu_chnl_num_internal_get(digi_handle, 
                                                      chnl_handle);

        result = coreotn_prbs_mon_or_gen_chnl_get(digi_handle->coreotn_handle,
                                                  prbs_inst,
                                                  dci_chnl,
                                                  &prbs_chnl,
                                                  &prbs_chnl_valid);
    }
       
    if (PMC_SUCCESS == result)
    {
        if (TRUE == prbs_chnl_valid)
        {
            *prbs_chid = prbs_chnl;
        }
        else
        {
            result = DIGI_ERR_PRBS_NOT_PROV;
        }
    }


    
    PMC_ATOMIC_RETURN(digi_handle, result);

} /* digi_otn_odu_prbs_chid_get */



/*******************************************************************************
*  digi_otn_get_chnl_ptr_for_tcm_apps
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retreives a digi_otn_odu_chnl_t pointer to facilitate provisioning
*   PM/TCMs over the packet fabric.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_in_ptr        - Three options for monitoring over the packet fabric:
*                          1) Monitoring from FO1 framers over the packet
*                             fabric (monitoring on LO from the LINE
*                             interface or the SYS interface).
*                             Provide the *lowest order* util_global_oduk_port_data_t
*                             in the path.
*                          2) Monitoring from FO2 framers over the packet
*                             fabric (monitoring on channels sourced and
*                             received by the mapper).
*                             Provide the mapper channel context pointer (digi_mapper_chnl_def__t)
*                          3) For SYSOTN mode only.  For monitoring
*                             TCMs over the switch fabric for traffic sourced
*                             from the LINE interface.  Provide the
*                             channel context pointer return by digi_otn_server_ho_prov
*                             that conects the LINE segement with the ODUKSW
* 
* OUTPUTS:
*   *chnl_out_ptr       - util_global_oduk_port_data_t assosiated with the FO1 or
*                         FO2 instance.  Should be used for any PM/TCM
*                         or consequential action related config operations
*                         required on these interfaces.
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_get_chnl_ptr_for_tcm_apps(digi_handle_t *digi_handle,
                                                    digi_otn_odu_chnl_t *chnl_in_ptr,
                                                    digi_otn_odu_chnl_t **chnl_out_ptr)
{

      
    PMC_ERROR   rc = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_in_ptr)->switch_data));
    
    /* check that user switch handle belongs to digi context */           
    rc = digi_oduksw_chnl_validate(digi_handle, chnl_in_ptr);

    if (PMC_SUCCESS == rc)
    {
        rc = digi_otn_get_chnl_ptr_for_tcm_apps_internal(digi_handle,
                                                         chnl_in_ptr,
                                                         chnl_out_ptr);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_get_chnl_ptr_for_tcm_apps */

/*******************************************************************************
*  digi_otn_get_chnl_ptr_for_stg3b
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retreives a digi_otn_odu_chnl_t pointer to facilitate Stage 3B interrupt
*   management
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_in_ptr        - ODU channel handle
* 
* OUTPUTS:
*   *chnl_out_ptr       - Stage 3b channel handle
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_get_chnl_ptr_for_stg3b(digi_handle_t          *digi_handle,
                                                 digi_otn_odu_chnl_t    *chnl_in_ptr,
                                                 digi_otn_odu_chnl_t   **chnl_out_ptr)
{
    PMC_ERROR       rc = PMC_SUCCESS;
    odu_struct_t   *stg3b_pool_ptr;
    UINT32          chnl_id;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_in_ptr  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_out_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_in_ptr)->switch_data));

    stg3b_pool_ptr = digi_handle->handle_pool.s3b_odu_struct;
    chnl_id        = digi_otn_odu_chnl_num_internal_get(digi_handle, chnl_in_ptr);

    if (TRUE == digi_otn_is_stg3b_present(digi_handle, chnl_in_ptr))
    {
        *chnl_out_ptr = &stg3b_pool_ptr[chnl_id];
    }
    else
    {
        rc = DIGI_ERR_STG3B_NOT_PRESENT;
    }

    
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_get_chnl_ptr_for_stg3b*/

/*******************************************************************************
* digi_otn_otu_consq_action_cfg
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Enables/Disables the requested consequential action per defect setting.
*   In order to enable/disable a consequential action at least one relevant defect
*   bit/s should appear in the defect bit mask variable.
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   cons_action_type       - enum, requedted consequential action: \n
*                            LINE_OTN_A_TSF \n
*                            LINE_OTN_A_SSF \n
*                            LINE_OTN_A_TSD \n
*                            LINE_OTN_A_IAE \n
*                            LINE_OTN_A_SSD \n
*                            LINE_OTN_A_AIS \n
*                            LINE_OTN_A_BEI \n
*                            LINE_OTN_A_BIAE\n
*                            LINE_OTN_A_BDI \n
*                            LINE_OTN_A_FFAIL \n
*
*   defect_bm              - unsigned,relevant defect bit mask based on the following bits: \n
*                            LINE_OTN_D_LOS_P\n
*                            LINE_OTN_D_LOL_P\n
*                            LINE_OTN_D_LOFLANE\n
*                            LINE_OTN_D_AIS\n
*                            LINE_OTN_D_LOF\n
*                            LINE_OTN_D_LOM\n
*                            LINE_OTN_D_TIM\n
*                            LINE_OTN_D_IAE\n
*                            LINE_OTN_D_DEG\n
*                            LINE_OTN_N_BIPV\n
*                            LINE_OTN_IAE\n
*                            LINE_OTN_D_BDI_FROM_SSF\n
*                            LINE_OTN_D_TSF_FROM_SSF\n
*                            LINE_OTN_D_SSF_FROM_TSF\n
*                            LINE_OTN_D_AIS_FROM_TSF\n
*                            LINE_OTN_D_SSD_FROM_TSD\n\n
*                            or a pre-defined activation bit masks which set all relevant bits: \n
*                            LINE_OTN_A_TSF_ACT \n
*                            LINE_OTN_A_SSF_ACT \n
*                            LINE_OTN_A_BDI_ACT \n
*                            LINE_OTN_N_BEI_ACT \n
*                            LINE_OTN_N_BIAE_ACT \n
*                            LINE_OTN_A_TSD_ACT \n
*                            LINE_OTN_A_SSD_ACT \n
*                            LINE_OTN_A_IAE_ACT \n
*                            LINE_OTN_A_AIS_ACT \n
*                            LINE_OTN_A_FFAIL_ACT \n
*
*   set_defects           - boolean, TRUE -- set the defect to active mode
*                                    FALSE -- reset defect to non-active mode
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_consq_action_cfg  ( digi_handle_t             *digi_handle,
                                                  digi_otn_server_chnl_t    *otn_server_ptr,
                                                  lineotn_action_type_t     cons_action_type,
                                                  UINT32                    defect_bm,
                                                  BOOL                      set_defects)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(cons_action_type < LAST_LINE_OTN_ACT_TYPE, DIGI_ERR_INVALID_ARG, cons_action_type, 0);
    PMC_ASSERT(defect_bm > 0, DIGI_ERR_INVALID_ARG, defect_bm, 0);

     /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS != rc)
    {
        PMC_ATOMIC_RETURN(digi_handle, rc);
    }
    
    rc = lineotn_consq_action_cfg(linesys_handle,
                                  otn_srvr_ptr->dsi_base_chnl,
                                  (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                  cons_action_type,
                                  defect_bm,
                                  set_defects);


    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_consq_action_cfg */

/*******************************************************************************
* digi_otn_otu_consq_action_cfg_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function checks to see if a certain defect bit mask is configured in HW 
*   for a user specified consequential action.
*   user should provide a defect bit mask containing at least one defect bit set
*   and the requested consequential action to check this defect against.
*   Results are returned in a user pre allocated bit mask where every set bit 
*   stands for an activated defect bit.
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   cons_action_type       - enum, requedted consequential action: \n
*                            LINE_OTN_A_TSF \n
*                            LINE_OTN_A_SSF \n
*                            LINE_OTN_A_TSD \n
*                            LINE_OTN_A_IAE \n
*                            LINE_OTN_A_SSD \n
*                            LINE_OTN_A_AIS \n
*                            LINE_OTN_A_BEI \n
*                            LINE_OTN_A_BIAE\n
*                            LINE_OTN_A_BDI \n
*                            LINE_OTN_A_FFAIL \n
*
*   defect_bm              - unsigned,requested defect bit mask to check for based on the following bits: \n
*                            LINE_OTN_D_LOS_P\n
*                            LINE_OTN_D_LOL_P\n
*                            LINE_OTN_D_LOFLANE\n
*                            LINE_OTN_D_AIS\n
*                            LINE_OTN_D_LOF\n
*                            LINE_OTN_D_LOM\n
*                            LINE_OTN_D_TIM\n
*                            LINE_OTN_D_IAE\n
*                            LINE_OTN_D_DEG\n
*                            LINE_OTN_N_BIPV\n
*                            LINE_OTN_IAE\n
*                            LINE_OTN_D_BDI_FROM_SSF\n
*                            LINE_OTN_D_TSF_FROM_SSF\n
*                            LINE_OTN_D_SSF_FROM_TSF\n
*                            LINE_OTN_D_AIS_FROM_TSF\n
*                            LINE_OTN_D_SSD_FROM_TSD\n\n
*                            or a pre-defined activation bit masks which set all relevant bits: \n
*                            LINE_OTN_A_TSF_ACT \n
*                            LINE_OTN_A_SSF_ACT \n
*                            LINE_OTN_A_BDI_ACT \n
*                            LINE_OTN_N_BEI_ACT \n
*                            LINE_OTN_N_BIAE_ACT \n
*                            LINE_OTN_A_TSD_ACT \n
*                            LINE_OTN_A_SSD_ACT \n
*                            LINE_OTN_A_IAE_ACT \n
*                            LINE_OTN_A_AIS_ACT \n
*                            LINE_OTN_A_FFAIL_ACT \n
*
* OUTPUTS:
*   *defects_set_bm        - pointer to unsigned,pre allocated by user,contains the 
*                            defect bit mask for defects that are set for the consequential action. 
*                            Bit mask will made out of the following bits:\n
*                            LINE_OTN_D_LOS_P\n
*                            LINE_OTN_D_LOL_P\n
*                            LINE_OTN_D_LOFLANE\n
*                            LINE_OTN_D_AIS\n
*                            LINE_OTN_D_LOF\n
*                            LINE_OTN_D_LOM\n
*                            LINE_OTN_D_TIM\n
*                            LINE_OTN_D_IAE\n
*                            LINE_OTN_D_DEG\n
*                            LINE_OTN_N_BIPV\n
*                            LINE_OTN_IAE\n
*                            LINE_OTN_D_BDI_FROM_SSF\n
*                            LINE_OTN_D_TSF_FROM_SSF\n
*                            LINE_OTN_D_SSF_FROM_TSF\n
*                            LINE_OTN_D_AIS_FROM_TSF\n
*                            LINE_OTN_D_SSD_FROM_TSD\n
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_consq_action_cfg_get  ( digi_handle_t             *digi_handle,
                                                      digi_otn_server_chnl_t    *otn_server_ptr,
                                                      lineotn_action_type_t     cons_action_type,
                                                      UINT32                    defect_bm,
                                                      UINT32                    *defects_set_bm )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != defects_set_bm, DIGI_ERR_INVALID_ARG, 0, 0);

    PMC_ASSERT(cons_action_type < LAST_LINE_OTN_ACT_TYPE, DIGI_ERR_INVALID_ARG, cons_action_type, 0);
    PMC_ASSERT(defect_bm > 0, DIGI_ERR_INVALID_ARG, defect_bm, 0);

     /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {        
        rc = lineotn_consq_action_cfg_get(linesys_handle,
                                          otn_srvr_ptr->dsi_base_chnl,
                                          (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                          cons_action_type,
                                          defect_bm,
                                          defects_set_bm);
    }
        
        
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_consq_action_cfg_get */

/*******************************************************************************
* digi_otn_otu_mfas_oh_ins_cfg
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Enables/Disables the requested mfas field OH insertion.
*   This function allows the user to set an mfas value to be inserted as an OH
*   field. By setting the mfas insertion type the user can choose an insertion
*   method out of 3 insertion methods specified bellow.
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   mfas_ins_type          - enum, requested insertion type: \n
*                            LINE_OTN_MFAS_INS_TYPE_UNMODIFIED: mfas will not be inserted \n\n
*                            LINE_OTN_MFAS_INS_TYPE_USER_VALUE: user value mfas will be
*                            inserted \n\n
*                            LINE_OTN_MFAS_INS_TYPE_UPSTREAM_VALUE: mfas field is inserted
*                            via a freewheeling counter based on the upstream MFAS. \n
*
*   mfas_value             - unsigned,user defined mfas value \n
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_SM_OH_INS_FAILED  - Internally generated error code
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*   1. For gracefully updating the OH field this function should be invoked
*      after a dsi stream is provisioned and before it is acativated.\n
*   2. Invoking this function before a dsi stream is provisioned will result
*      in failure and an error status will be returned.\n
*   3. Invoking this function after a dsi stream is active (operational) might
*      cause a burst of alarms.\n
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_mfas_oh_ins_cfg        ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       lineotn_mfas_ins_type_t   mfas_ins_type,
                                                       UINT32                    mfas_value )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(mfas_ins_type < LAST_LINE_OTN_OH_MFAS_INS_TYPE, DIGI_ERR_INVALID_ARG, mfas_ins_type, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        
        rc = lineotn_mfas_oh_ins_cfg(linesys_handle,
                                     otn_srvr_ptr->dsi_base_chnl,
                                     (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                     mfas_ins_type,
                                     mfas_value );
    }
        
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_mfas_oh_ins_cfg */


/*******************************************************************************
* digi_otn_otu_mfas_oh_ins_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Returns the MFAS OH insertion type and value fields
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
* OUTPUTS:
*   *mfas_ins_type         - enum, requested insertion type: \n
*                            LINE_OTN_MFAS_INS_TYPE_UNMODIFIED: mfas will not be inserted \n\n
*                            LINE_OTN_MFAS_INS_TYPE_USER_VALUE: user value mfas will be
*                            inserted \n\n
*                            LINE_OTN_MFAS_INS_TYPE_UPSTREAM_VALUE: mfas field is inserted
*                            via a freewheeling counter based on the upstream MFAS. \n
*
*   *mfas_value            - unsigned,user defined mfas value \n
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*   1. Invoking this function before a dsi stream is provisioned will result
*      in failure and an error status will be returned.\n
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_mfas_oh_ins_get        ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       lineotn_mfas_ins_type_t   *mfas_ins_type,
                                                       UINT32                    *mfas_value )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

     /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
    
        rc = lineotn_mfas_oh_ins_get(linesys_handle,
                                     otn_srvr_ptr->dsi_base_chnl,
                                     (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                     mfas_ins_type,
                                     mfas_value );
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_mfas_oh_ins_get */


/*******************************************************************************
* digi_otn_otu_bip8_oh_ins_cfg
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Enables/Disables the requested bip8 field OH insertion.
*   This function allows the user to set a bip8 value to be inserted as an OH
*   field. By setting the bip8 insertion type the user can choose an insertion
*   method out of 5 insertion methods specified bellow.
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   bip8_ins_type          - enum, requested insertion type: \n
*                            LINE_OTN_BIP8_INS_DISABLED: bip8 will not be inserted \n\n
*                            LINE_OTN_BIP8_INS_TYPE_ENABLED:  The calculated
*                            bip8 value is inserted \n\n
*                            LINE_OTN_BIP8_INS_TYPE_UPSTREAM_XOR_USER_VALUE: calculated
*                            value insertion is disabled and the upstream SM bip8 value
*                            in the frame is XOR'd with the bip8 user value \n\n
*                            LINE_OTN_BIP8_INS_TYPE_CALCULATED_XOR_USER_VALUE:
*                            calculated SM bip8 value is XOR'd with the bip8
*                            user value \n\n
*                            LINE_OTN_BIP8_INS_TYPE_USER_VALUE:
*                            bip8 constant user value insertion \n
*
*   bip8_value             - unsigned,user defined bip8 value \n
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_SM_OH_INS_FAILED  - Internally generated error code
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*   1. For gracefully updating the OH field this function should be invoked
*      after a dsi stream is provisioned and before it is acativated.\n
*   2. Invoking this function before a dsi stream is provisioned will result
*      in failure and an error status will be returned.\n
*   3. Invoking this function after a dsi stream is active (operational) might
*      cause a burst of alarms.\n
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_bip8_oh_ins_cfg        ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       lineotn_bip8_ins_type_t   bip8_ins_type,
                                                       UINT32                    bip8_value )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(bip8_ins_type < LAST_LINE_OTN_OH_BIP8_INS_TYPE, DIGI_ERR_INVALID_ARG, bip8_ins_type, 0);

     /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        
        rc = lineotn_bip8_oh_ins_cfg(linesys_handle,
                                     otn_srvr_ptr->dsi_base_chnl,
                                     (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                     bip8_ins_type,
                                     bip8_value);        
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_bip8_oh_ins_cfg */


/*******************************************************************************
* digi_otn_otu_bip8_oh_ins_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Returns the bip8 OH insertion type and value fields
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
* OUTPUTS:
*   *bip8_ins_type          - enum, requested insertion type: \n
*                            LINE_OTN_BIP8_INS_DISABLED: bip8 will not be inserted \n\n
*                            LINE_OTN_BIP8_INS_TYPE_ENABLED:  The calculated
*                            bip8 value is inserted \n\n
*                            LINE_OTN_BIP8_INS_TYPE_UPSTREAM_XOR_USER_VALUE: calculated
*                            value insertion is disabled and the upstream SM bip8 value
*                            in the frame is XOR'd with the bip8 user value \n\n
*                            LINE_OTN_BIP8_INS_TYPE_CALCULATED_XOR_USER_VALUE:
*                            calculated SM bip8 value is XOR'd with the bip8
*                            user value \n\n
*                            LINE_OTN_BIP8_INS_TYPE_USER_VALUE:
*                            bip8 constant user value insertion \n
*
*   *bip8_value             - unsigned,user defined bip8 value \n
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*   1. Invoking this function before a dsi stream is provisioned will result
*      in failure and an error status will be returned.\n
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_bip8_oh_ins_get        ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       lineotn_bip8_ins_type_t   *bip8_ins_type,
                                                       UINT32                    *bip8_value )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    
    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        rc = lineotn_bip8_oh_ins_get(linesys_handle,
                                     otn_srvr_ptr->dsi_base_chnl,
                                     (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                     bip8_ins_type,
                                     bip8_value);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_bip8_oh_ins_get */


/*******************************************************************************
* digi_otn_otu_iae_oh_ins_cfg
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Enables/Disables the requested iae field OH insertion.
*   This function allows the user to set an iae  value to be inserted as an OH
*   field. By setting the iae insertion type the user can choose an insertion
*   method out of 3 insertion methods specified bellow.
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*   iae_ins_type           - enum, requested insertion type:\n
*                            LINE_OTN_IAE_INS_TYPE_UNMODIFIED:  value insertion is
*                            disabled and the iae field passes through unmodified from
*                            the upstream \n\n
*                            LINE_OTN_IAE_INS_TYPE_USER_VALUE: user value iae will be
*                            inserted \n\n
*                            LINE_OTN_IAE_INS_TYPE_DETECTED_VALUE: iae field contains
*                            the value detected by the OTUk/ODUk_A So function \n\n
*   iae_value              - unsigned,user defined iea value\n
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_SM_OH_INS_FAILED  - Internally generated error code
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*   1. For gracefully updating the OH field this function should be invoked
*      after a dsi stream is provisioned and before it is acativated.\n
*   2. Invoking this function before a dsi stream is provisioned will result
*      in failure and an error status will be returned.\n
*   3. Invoking this function after a dsi stream is active (operational) might
*      cause a burst of alarms.\n
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_iae_oh_ins_cfg         ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       lineotn_iae_ins_type_t    iae_ins_type,
                                                       UINT32                    iae_value )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(iae_ins_type < LAST_LINE_OTN_OH_IAE_INS_TYPE, DIGI_ERR_INVALID_ARG, iae_ins_type, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        rc = lineotn_iae_oh_ins_cfg(linesys_handle,
                                    otn_srvr_ptr->dsi_base_chnl,
                                    (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                    iae_ins_type,
                                    iae_value);
    }
        

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_iae_oh_ins_cfg */


/*******************************************************************************
* digi_otn_otu_iae_oh_ins_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Returns the IAE OH insertion type and valid fields
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
* OUTPUTS:
*   *iae_ins_type           - enum, insertion type:\n
*                            LINE_OTN_IAE_INS_TYPE_UNMODIFIED:  value insertion is
*                            disabled and the iae field passes through unmodified from
*                            the upstream \n\n
*                            LINE_OTN_IAE_INS_TYPE_USER_VALUE: user value iae will be
*                            inserted \n\n
*                            LINE_OTN_IAE_INS_TYPE_DETECTED_VALUE: iae field contains
*                            the value detected by the OTUk/ODUk_A So function \n\n
*   *iae_value              - unsigned,user defined iea value\n
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*   1. Invoking this function before a dsi stream is provisioned will result
*      in failure and an error status will be returned.\n
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_iae_oh_ins_get         ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       lineotn_iae_ins_type_t    *iae_ins_type,
                                                       UINT32                    *iae_value )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    
    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        
        rc = lineotn_iae_oh_ins_get(linesys_handle,
                                    otn_srvr_ptr->dsi_base_chnl,
                                    (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                    iae_ins_type,
                                    iae_value);
    }
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_iae_oh_ins_get */


/*******************************************************************************
* digi_otn_otu_bkwd_oh_ins_cfg
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Enables/Disables the requested backward error indication (BEI BIAE,BDI)field OH
*   insertion.
*   This function allows the user to set a backward indication value to be inserted
*   as an OH field for either BEI_BIAE or BDI. By setting the bkwd_ins_type type the user
*   can choose an insertion method out of 3 insertion methods specified bellow.
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   bkwd_ctrl_ins_field    - enum,requested backward error field: \n
*                            LINE_OTN_SO_BEI_BIAE \n
*                            LINE_OTN_SO_BDI \n
*
*   bkwd_ins_type          - enum, requested insertion type: \n
*                            LINE_OTN_BKWD_INS_TYPE_UNMODIFIED:
*                            BDI/BEI/BIAE field passes through unmodified from
*                            the upstream \n\n
*                            LINE_OTN_BKWD_INS_TYPE_USER_VALUE: user value BDI/BEI/BIAE
*                            is inserted \n\n
*                            LINE_OTN_BKWD_INS_TYPE_CONSQ_ACT_VALUE:  BDI/BEI/BIAE field
*                            contains the backwards consequential action value from the
*                            OTUk_Sk \n
*
*   bkwd_value             - unsigned,user defined backward indication value\n
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_SM_OH_INS_FAILED  - Internally generated error code
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*   1. For gracefully updating the OH field this function should be invoked
*      after a dsi stream is provisioned and before it is acativated.\n
*   2. Invoking this function before a dsi stream is provisioned will result
*      in failure and an error status will be returned.\n
*   3. Invoking this function after a dsi stream is active (operational) might
*      cause a burst of alarms.\n
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_bkwd_oh_ins_cfg        ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       lineotn_bkwd_oh_field_t   bkwd_ctrl_ins_field,
                                                       lineotn_bkwd_ins_type_t   bkwd_ins_type,
                                                       UINT32                    bkwd_value )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(bkwd_ins_type < LAST_LINE_OTN_OH_BKWD_INS_TYPE, DIGI_ERR_INVALID_ARG, bkwd_ins_type, 0);
    PMC_ASSERT((UINT32)bkwd_ctrl_ins_field< (UINT32)LAST_LINE_OTN_OH_BKWD_INS_TYPE, DIGI_ERR_INVALID_ARG, bkwd_ctrl_ins_field, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        rc = lineotn_bkwd_oh_ins_cfg(linesys_handle,
                                     otn_srvr_ptr->dsi_base_chnl,
                                     (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                     bkwd_ctrl_ins_field,
                                     bkwd_ins_type,
                                     bkwd_value);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_bkwd_oh_ins_cfg */

/*******************************************************************************
* digi_otn_otu_bkwd_oh_ins_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Returns  requested backward error indication (BEI BIAE,BDI) OH insertion type and value
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   bkwd_ctrl_ins_field    - enum,requested backward error field: \n
*                            LINE_OTN_SO_BEI_BIAE \n
*                            LINE_OTN_SO_BDI \n
*
* OUTPUTS:
*   *bkwd_ins_type         - enum, requested insertion type: \n
*                            LINE_OTN_BKWD_INS_TYPE_UNMODIFIED:
*                            BDI/BEI/BIAE field passes through unmodified from
*                            the upstream \n\n
*                            LINE_OTN_BKWD_INS_TYPE_USER_VALUE: user value BDI/BEI/BIAE
*                            is inserted \n\n
*                            LINE_OTN_BKWD_INS_TYPE_CONSQ_ACT_VALUE:  BDI/BEI/BIAE field
*                            contains the backwards consequential action value from the
*                            OTUk_Sk \n
*
*   *bkwd_value            - unsigned,user defined backward indication value\n
*
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*   1. Invoking this function before a dsi stream is provisioned will result
*      in failure and an error status will be returned.\n
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_bkwd_oh_ins_get        ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       lineotn_bkwd_oh_field_t   bkwd_ctrl_ins_field,
                                                       lineotn_bkwd_ins_type_t   *bkwd_ins_type,
                                                       UINT32                    *bkwd_value )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT((UINT32)bkwd_ctrl_ins_field< (UINT32)LAST_LINE_OTN_OH_BKWD_INS_TYPE, DIGI_ERR_INVALID_ARG, bkwd_ctrl_ins_field, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        rc = lineotn_bkwd_oh_ins_get(linesys_handle,
                                     otn_srvr_ptr->dsi_base_chnl,
                                     (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                     bkwd_ctrl_ins_field,
                                     bkwd_ins_type,
                                     bkwd_value);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_bkwd_oh_ins_get */


/*******************************************************************************
* digi_otn_otu_oh_ins_cfg
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Enables/Disables the requested OH insertion field.
*   This function handles a set of OH fields (listed below)
*   that have only 2 insertion options (either they are inserted or not).
*   Also, it allows to the user to specify an insertion value for the insertion
*   fields.
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   ctrl_ins_field         - enum,requested control insertion field: \n
*                            LINE_OTN_SO_FAS_F6 (first 3 FAS bytes) \n
*                            LINE_OTN_SO_FAS_28 (last 3 FAS bytes) \n
*                            LINE_OTN_SO_RES7 \n
*                            LINE_OTN_SO_RES8 \n
*                            LINE_OTN_SO_GCC0 \n
*                            LINE_OTN_SO_RES13 \n
*                            LINE_OTN_SO_RES14 \n
*
*   ctrl_ins_type          - enum, requested insertion type: \n
*                            LINE_OTN_INS_TYPE_UNMODIFIED:
*                            field passes through unmodified from the upstream \n\n
*                            LINE_OTN_INS_TYPE_USER_VALUE: user value
*                            is inserted \n
*
*   ctrl_field_value       - unsigned,user defined insertion field value\n
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_SM_OH_INS_FAILED  - Internally generated error code
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*   1. For gracefully updating the OH field this function should be invoked
*      after a dsi stream is provisioned and before it is acativated.\n
*   2. Invoking this function before a dsi stream is provisioned will result
*      in failure and an error status will be returned.\n
*   3. Invoking this function after a dsi stream is active (operational) might
*      cause a burst of alarms.\n
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_oh_ins_cfg             ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       lineotn_oh_field_t        ctrl_ins_field,
                                                       lineotn_oh_ins_type_t     ctrl_ins_type,
                                                       UINT32                    ctrl_field_value )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(ctrl_ins_type < LAST_LINE_OTN_OH_INS_TYPE, DIGI_ERR_INVALID_ARG, ctrl_ins_type, 0);
    PMC_ASSERT(ctrl_ins_field!=LINE_OTN_SO_TTI &&
               ctrl_ins_field< LAST_LINE_OTN_OH_FIELD, DIGI_ERR_INVALID_ARG, ctrl_ins_field, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {        
        rc = lineotn_oh_ins_cfg(linesys_handle,
                                otn_srvr_ptr->dsi_base_chnl,
                                (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                ctrl_ins_field,
                                ctrl_ins_type,
                                ctrl_field_value);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_oh_ins_cfg */





/*******************************************************************************
* digi_otn_otu_oh_ins_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Returns the configuration for the requested OH field: the inserted value and
*   the type of insertion (unmodified or user value)
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   ctrl_ins_field         - enum,requested control insertion field: \n
*                            LINE_OTN_SO_FAS_F6 (first 3 FAS bytes) \n
*                            LINE_OTN_SO_FAS_28 (last 3 FAS byte) \n
*                            LINE_OTN_SO_RES7 \n
*                            LINE_OTN_SO_RES8 \n
*                            LINE_OTN_SO_GCC0 \n
*                            LINE_OTN_SO_RES13 \n
*                            LINE_OTN_SO_RES14 \n
*
*
* OUTPUTS:
*   ctrl_ins_type          - enum, requested insertion type: \n
*                            LINE_OTN_INS_TYPE_UNMODIFIED:
*                            field passes through unmodified from the upstream \n\n
*                            LINE_OTN_INS_TYPE_USER_VALUE: user value
*                            is inserted \n
*
*   ctrl_field_value       - unsigned,user defined insertion field value\n
*
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*   1. For gracefully updating the OH field this function should be invoked
*      after a dsi stream is provisioned and before it is acativated.\n
*   2. Invoking this function before a dsi stream is provisioned will result
*      in failure and an error status will be returned.\n
*   3. Invoking this function after a dsi stream is active (operational) might
*      cause a burst of alarms.\n
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_oh_ins_get             ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       lineotn_oh_field_t        ctrl_ins_field,
                                                       lineotn_oh_ins_type_t     *ctrl_ins_type,
                                                       UINT32                    *ctrl_field_value )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(ctrl_ins_field!=LINE_OTN_SO_TTI &&
               ctrl_ins_field< LAST_LINE_OTN_OH_FIELD, DIGI_ERR_INVALID_ARG, ctrl_ins_field, 0);
    PMC_ASSERT(NULL != ctrl_ins_type, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != ctrl_field_value, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        
        rc = lineotn_oh_ins_get(linesys_handle,
                                otn_srvr_ptr->dsi_base_chnl,
                                (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                ctrl_ins_field,
                                ctrl_ins_type,
                                ctrl_field_value);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_oh_ins_get */

/*******************************************************************************
* digi_otn_otu_oh_extract_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Returns the a requested OH extracted field from rx side per requested dsi
*   stream. The value returned contains the extracted SM overhead field for a
*   single OTUk frame.
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   extract_field          - enum,requested sm extracted field: \n
*                            LINE_OTN_EXT_SK_SM_TTI \n
*                            LINE_OTN_EXT_SK_SM_BIP8 \n
*                            LINE_OTN_EXT_SK_SM_BEI_BIAE \n
*                            LINE_OTN_EXT_SK_SM_BDI \n
*                            LINE_OTN_EXT_SK_SM_IAE \n
*                            LINE_OTN_EXT_SK_SM_RES \n
*                            LINE_OTN_EXT_SK_RES \n
*                            LINE_OTN_EXT_SK_GCC0 \n
*
* OUTPUTS:
*   extracted_val_ptr      - pointer to user allocated unsigned in which
*                            the extracted value will be returned. \n
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_OH_EXT_FAILED  - Internally generated error code
*
* NOTES:
*   1. The value returned contains the extracted SM overhead field for a
*      SINGLE !!! OTUk frame.\n
*   2. While accessing OH register values, this register is will not be updated
*      by the device HW.\n
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_oh_extract_get         ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       lineotn_oh_extract_t      extract_field,
                                                       UINT32                    *extracted_val_ptr )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    PMC_ASSERT(NULL != extracted_val_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(extract_field < LAST_LINE_OTN_OH_EXT_FIELD, DIGI_ERR_INVALID_ARG, extract_field, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        
        rc = lineotn_oh_extract_get(linesys_handle,
                                    otn_srvr_ptr->dsi_base_chnl,
                                    (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                    extract_field,
                                    extracted_val_ptr);
    }
        
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_oh_extract_get */

/*******************************************************************************
* digi_otn_otu_force_mi_active_cfg
* ______________________________________________________________________________
*
* DESCRIPTION: 
*  Forces the a requested mi active configuration.
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   mi_active_type         - enum,requested mi active configuration: \n
*                            LINE_OTN_MI_ACTIVE_DISABLED: no mi active \n
*                            LINE_OTN_MI_ACTIVE_ENABLED : mi active on OTUk TT \n
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_SM_OH_INS_FAILED  - Internally generated error code
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_force_mi_active_cfg( digi_handle_t             *digi_handle,
                                                   digi_otn_server_chnl_t    *otn_server_ptr,
                                                   lineotn_mi_active_type_t  mi_active_type )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(mi_active_type < LAST_LINE_OTN_MI_ACTIVE_TYPE, DIGI_ERR_INVALID_ARG, mi_active_type, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);

    if (PMC_SUCCESS == rc)
    {
                
        rc = lineotn_force_mi_active_cfg(linesys_handle,
                                         otn_srvr_ptr->dsi_base_chnl,
                                         (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                         mi_active_type);
    }
        
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_force_mi_active_cfg */


/*******************************************************************************
* digi_otn_otu_force_maintenance_sig_cfg
* ______________________________________________________________________________
*
* DESCRIPTION: 
*  Forces the a requested maintenance signal insertion.
*
*  LINE_OTN_ODUK_AIS_NOMINAL/LINE_OTN_ODUK_LCK_NOMINAL is only relevant for
*  the maint_sig_dir==LINE_OTN_TX_DIR.  For maint_sig_dir==LINE_OTN_RX_DIR,
*  the maintenance signal is always replaced at nominal.
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   maint_sig_type         - enum,requested maintenance signal: \n
*                            LINE_OTN_NO_MAINT_SIG \n
*                            LINE_OTN_ODUK_AIS \n
*                            LINE_OTN_ODUK_LCK \n
*                            LINE_OTN_ODUK_OCI \n
*                            LINE_OTN_ODUK_AIS_NOMINAL \n
*                            LINE_OTN_ODUK_LCK_NOMINAL
*
*   maint_sig_dir          - enum,requested maintenance signal direction: \n
*                            LINE_OTN_RX_DIR \n
*                            LINE_OTN_TX_DIR \n
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_SM_OH_INS_FAILED  - Internally generated error code
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_force_maintenance_sig_cfg( digi_handle_t             *digi_handle,
                                                         digi_otn_server_chnl_t    *otn_server_ptr,
                                                         lineotn_maint_sig_type_t  maint_sig_type,
                                                         lineotn_dir_t             maint_sig_dir )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    odu_struct_t *ho_odu_ptr = NULL;
    BOOL8 new_sig_is_nominal = FALSE;
    BOOL8 old_sig_is_nominal = FALSE;
    BOOL8 ho_unchannelized;
    BOOL8 nominal_tx_unchannelized;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(maint_sig_dir < LAST_LINE_OTN_DIR, DIGI_ERR_INVALID_ARG, maint_sig_dir, 0);
    PMC_ASSERT(maint_sig_type < LAST_LINE_OTN_MAINT_SIG, DIGI_ERR_INVALID_ARG, maint_sig_type, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    if (LINE_OTN_ODUK_AIS_NOMINAL == maint_sig_type)
    {
        maint_sig_type = LINE_OTN_ODUK_AIS;
        new_sig_is_nominal = TRUE;
    }
    else if (LINE_OTN_ODUK_LCK_NOMINAL == maint_sig_type)
    {
        maint_sig_type = LINE_OTN_ODUK_LCK;
        new_sig_is_nominal = TRUE;
    }
    else if (LINE_OTN_ODUK_OCI == maint_sig_type)
    {
        new_sig_is_nominal = TRUE;
    }
    else
    {
        new_sig_is_nominal = FALSE;
    }

    if (maint_sig_dir == LINE_OTN_TX_DIR)
    {
        ho_odu_ptr = otn_srvr_ptr->odu_struct_ptr;

        if(ho_odu_ptr == NULL)
        {
            PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_OTN_OTU_MAINT_SIG);
        }

        if(ho_odu_ptr->switch_data.oduk_data.lineotn_src)
        {
            old_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, LINEOTN_TX, otn_srvr_ptr->dci_chnl);
            digi_otn_channel_nominal_set(digi_handle, LINEOTN_TX, otn_srvr_ptr->dci_chnl, new_sig_is_nominal);
        }
        else
        {
            old_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, SYSOTN_TX,  otn_srvr_ptr->dci_chnl);
            digi_otn_channel_nominal_set(digi_handle, SYSOTN_TX,  otn_srvr_ptr->dci_chnl, new_sig_is_nominal);
        }

    }
    
    if(rc == PMC_SUCCESS)
    {
        rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
        if (PMC_SUCCESS == rc)
        {
            rc = lineotn_force_maintenance_sig_cfg(linesys_handle,
                                                   otn_srvr_ptr->dsi_base_chnl,
                                                   (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                                   maint_sig_type,
                                                   maint_sig_dir);
        }
        
        if (PMC_SUCCESS == rc && maint_sig_dir == LINE_OTN_TX_DIR)
        {     

             ho_unchannelized = DIGI_IS_ODU_CHNL_HO_UNCHANNELIZED(digi_handle, ho_odu_ptr);
             
             if(ho_unchannelized)
             {
                    /*if forcing with OCI, the replacement signal must always be done using 
                    the local reference clock (disable the OPSA workaround)*/
                    if(rc == PMC_SUCCESS &&
                       new_sig_is_nominal &&
                       !old_sig_is_nominal)
                    {
                        
                        if(ho_odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_LO_ODU &&
                           DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
                        {
                            digi_opsa_cfg_mpmo_one_port_drop(digi_handle,
                                                             OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_CTL,
                                                             ho_odu_ptr->switch_data.oduk_data.channel);   

                        }
                        else
                        {
                            digi_opsa_cfg_mpmo_one_port_drop(digi_handle,
                                                             OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_FO1,
                                                             ho_odu_ptr->switch_data.oduk_data.channel);      

                        }
                        /*
                         * Set the FIFO_CLRB to 0 to empty the ODUkSW 
                         * while nominal is being forced towords the line 
                         * or system side SerDes, when nominal replacement
                         * is removed, FIFO_CLRB is set back to 1 after 
                         * the digi_opsa_cfg_mpmo_one_port_add call to 
                         * complete the operation 
                         */
                        coreotn_mpmo_fifo_clear(digi_handle->coreotn_handle,
                                                1,
                                                ho_odu_ptr);



                        if(rc == PMC_SUCCESS)
                        {
                            rc = odu_struct_tx_maint_sig_dummy_rfrm_cfg(digi_handle->coreotn_handle,
                                                                        ho_odu_ptr->mem_ptr->odu_level,
                                                                        ho_odu_ptr->mem_ptr->chnl_id,
                                                                        TRUE);
                                
                        }
                    }
                    else if(rc == PMC_SUCCESS &&
                            !new_sig_is_nominal &&
                            old_sig_is_nominal)
                    {
                        /* this case is to handle transitioning to from a nominal maintenance signal, to a non-nominal
                        maintenance signal, ormaintenance signal */

                        nominal_tx_unchannelized = digi_otn_nominal_tx_unchannelized_get(digi_handle, ho_odu_ptr);

                        if(nominal_tx_unchannelized == FALSE &&
                           rc ==  PMC_SUCCESS)
                        {
                            rc = digi_otn_remove_nominal_replacement(digi_handle,
                                                                     ho_odu_ptr);

                        }

                          
                        if(rc == PMC_SUCCESS &&
                           digi_otn_remove_dummy_maintenance_signal_get(digi_handle, ho_odu_ptr))
                        {
                            rc = odu_struct_tx_maint_sig_dummy_rfrm_cfg(digi_handle->coreotn_handle,
                                                                        ho_odu_ptr->mem_ptr->odu_level,
                                                                        ho_odu_ptr->mem_ptr->chnl_id,
                                                                        FALSE);
                        }


                    } /*else if(rc == PMC_SUCCESS && !new_sig_is_nominal && old_sig_is_nominal)*/
           
              }

        } /* PMC_SUCCESS == rc && maint_sig_dir == LINE_OTN_TX_DIR) */
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_force_maintenance_sig_cfg */

/*******************************************************************************
* digi_otn_maintenance_sig_state_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*  inquires about the maintenance signal state for the requested otn channel in the
*  requested direction.
*
*  LINE_OTN_ODUK_AIS_NOMINAL/LINE_OTN_ODUK_LCK_NOMINAL will only be returned
*  for maint_sig_dir==LINE_OTN_TX_DIR.  Maintenance signals in the RX
*  path are always done nominal and will always return LINE_OTN_ODUK_AIS
*  or LINE_OTN_ODUK_LCK.
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   maint_sig_dir          - enum,requested maintenance signal direction: \n
*                            LINE_OTN_RX_DIR \n
*                            LINE_OTN_TX_DIR \n
* OUTPUTS:
*   maint_sig_type_ptr     - pre- allocated user enum,maintenance signal set: \n
*                            LINE_OTN_NO_MAINT_SIG \n
*                            LINE_OTN_ODUK_AIS \n
*                            LINE_OTN_ODUK_LCK \n
*                            LINE_OTN_ODUK_OCI \n
*                            LINE_OTN_ODUK_AIS_NOMINAL \n
*                            LINE_OTN_ODUK_LCK_NOMINAL \n
*                            LAST_LINE_OTN_MAINT_SIG : on error \n
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS  - Internally generated error code
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_maintenance_sig_state_get( digi_handle_t             *digi_handle,
                                                     digi_otn_server_chnl_t    *otn_server_ptr,
                                                     lineotn_dir_t             maint_sig_dir,
                                                     lineotn_maint_sig_type_t  *maint_sig_type_ptr )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    lineotn_maint_sig_type_t maint_sig_reg;
    BOOL sig_is_nominal = FALSE;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(maint_sig_dir < LAST_LINE_OTN_DIR, DIGI_ERR_INVALID_ARG, maint_sig_dir, 0);
    PMC_ASSERT(NULL != maint_sig_type_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        
        rc = lineotn_maintenance_sig_state_get(linesys_handle,
                                               otn_srvr_ptr->dsi_base_chnl,
                                               (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                               maint_sig_dir,
                                               &maint_sig_reg);
    }
    

    if(maint_sig_dir == LINE_OTN_TX_DIR)
    {
        if (otn_srvr_ptr->sys_line_src == TRUE)
        {
            sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, SYSOTN_TX, otn_srvr_ptr->dci_chnl);
        }
        else
        {
            sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, LINEOTN_TX, otn_srvr_ptr->dci_chnl);
        }
    }
 
    if (LINE_OTN_ODUK_AIS == maint_sig_reg && sig_is_nominal)
    {
        *maint_sig_type_ptr = LINE_OTN_ODUK_AIS_NOMINAL;
    }
    else if(LINE_OTN_ODUK_LCK == maint_sig_reg && sig_is_nominal)
    {
        *maint_sig_type_ptr = LINE_OTN_ODUK_LCK_NOMINAL;
    }
    else
    {
        *maint_sig_type_ptr = maint_sig_reg;
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_maintenance_sig_state_get */


/*******************************************************************************
* digi_otn_otu_mi_admin_state_cfg
* ______________________________________________________________________________
*
* DESCRIPTION: 
*  Forces the a requested mi admin signal LCK insertion.
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr       - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   admin_state_dir        - enum,requested maintenance signal direction: \n
*                            LINE_OTN_RX_DIR \n
*                            LINE_OTN_TX_DIR \n
*
*   admin_state            - boolean,TRUE: enable the mi admin state signal \n
*                                   FALSE: Disable the mi admin state signal
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_SM_OH_INS_FAILED  - Internally generated error code
*
* NOTES:
*   1. mi admin signal is masked if the maintainance signal function.\n
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_mi_admin_state_cfg    ( digi_handle_t             *digi_handle,
                                                      digi_otn_server_chnl_t    *otn_server_ptr,
                                                      lineotn_dir_t             admin_state_dir,
                                                      lineotn_mi_admin_state_t  admin_state )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(admin_state_dir < LAST_LINE_OTN_DIR, DIGI_ERR_INVALID_ARG, admin_state_dir, 0);
    PMC_ASSERT(admin_state < LAST_LINE_OTN_MI_ADMIN_STATE, DIGI_ERR_INVALID_ARG, admin_state, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        
        rc = lineotn_mi_admin_state_cfg(linesys_handle,
                                        otn_srvr_ptr->dsi_base_chnl,
                                        (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                        admin_state_dir,
                                        admin_state);
    }
    
    
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_mi_admin_state_cfg */

#ifdef PMC_DEPRECATED
/*******************************************************************************
* digi_otn_otu_sm_deg_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function sets SK SM DEG fields per requested dsi stream.
*   This is a SK (Rx) only function.
*
* INPUTS:
*   digi_handle         - pointer to digi handle instance.
*
*   *otn_server_ptr     - Pointer to a resource allocation
*                         context for the OTN server configured against the
*                         specified serdes port.
*
*   deg_field           - enum,SK DEG fields:  \n
*                         LINE_OTN_OTU_SK_SM_DEG_M: the degraded defect
*                         consecutive one second monitoring
*                         intervals for the SM channel. \n\n
*                         LINE_OTN_OTU_SK_SM_DEG_THR: the degraded defect
*                         one second errored block count for the SM channel. \n
*
*   deg_value           - UINT32, 0..32 bit values per field bits.
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_sm_deg_set             ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       lineotn_sk_sm_deg_t       deg_field,
                                                       UINT32                    deg_value )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(deg_field < LAST_LINE_OTN_SM_DEG, DIGI_ERR_INVALID_ARG, deg_field, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);
    
    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS != rc)
    {
        PMC_ATOMIC_RETURN(digi_handle, rc);
    }
    
    rc = lineotn_sm_deg_set(linesys_handle,
                            otn_srvr_ptr->dsi_base_chnl,
                            (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                            deg_field,
                            deg_value);


    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_sm_deg_set */

/*******************************************************************************
* digi_otn_otu_sm_deg_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function gets SK SM DEG fields per requested dsi stream.
*   This is a SK (Rx) only function.
*
* INPUTS:
*   digi_handle         - pointer to digi handle instance.
*
*   *otn_server_ptr     - Pointer to a resource allocation
*                         context for the OTN server configured against the
*                         specified serdes port.
*
*   deg_field           - enum,SK DEG fields:  \n
*                         LINE_OTN_OTU_SK_SM_DEG_M: the degraded defect
*                         consecutive one second monitoring
*                         intervals for the SM channel. \n\n
*                         LINE_OTN_OTU_SK_SM_DEG_THR: the degraded defect
*                         one second errored block count for the SM channel. \n
*
*
* OUTPUTS:
*   *deg_value          - pointer to pre allocated UINT32,0..32 bit values per field bits.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*   1. Invoking this function will cause a read into device registers.\n
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_sm_deg_get             ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       lineotn_sk_sm_deg_t       deg_field,
                                                       UINT32                    *deg_value )
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != deg_value, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(deg_field < LAST_LINE_OTN_SM_DEG, DIGI_ERR_INVALID_ARG, deg_field, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        
        rc = lineotn_sm_deg_get(linesys_handle,
                                otn_srvr_ptr->dsi_base_chnl,
                                (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                deg_field,
                                deg_value);
    }


    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_sm_deg_get */
#endif /* PMC_DEPRECATED */

/*******************************************************************************
* digi_otn_otu_sm_so_tti_set
* ______________________________________________________________________________
*
* DESCRIPTION: PRELIMINARY
*   This function sets the all fields (SAPI/DAPI/OP) in the OTU_SO_SM_TTI
*   registers per the requested dsi stream (0..11). The function works in a
*   read/modify/write of all the TTI values.
*   user is expected to provide ALL of the values to be written to the registers.
*
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr       - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   ctrl_ins_type          - enum, requested insertion type: \n
*                            LINE_OTN_INS_TYPE_UNMODIFIED:
*                            field passes through unmodified from the upstream \n\n
*                            LINE_OTN_INS_TYPE_USER_VALUE: user value
*                            is inserted \n
*
*   tti_data               - 64xUINT8 unsigned array containing all
*                            tti all values (SAPI/DAPI/OP). \n
*                            sapi_data is the first 16 bytes. \n
*                            dapi_data is the second 16 bytes \n
*                            op_data is the last 32 bytes. \n
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*   1. For gracefully updating the OH field this function should be invoked
*      after a dsi stream is provisioned and before it is acativated.\n
*   2. Invoking this function before a dsi stream is provisioned will result
*      in failure and an error status will be returned.\n
*   3. Invoking this function after a dsi stream is active (operational) might
*      cause a burst of alarms.\n
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_sm_so_tti_set          ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       lineotn_oh_ins_type_t     ctrl_ins_type,
                                                       UINT8                     tti_data[64] )


{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != tti_data, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(ctrl_ins_type < LAST_LINE_OTN_OH_INS_TYPE, DIGI_ERR_INVALID_ARG, ctrl_ins_type, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);
    
    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        
        rc = lineotn_sm_so_tti_set(linesys_handle,
                                   otn_srvr_ptr->dsi_base_chnl,
                                   (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                   ctrl_ins_type,
                                   (UINT32*)tti_data);
    }
    
    
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_sm_so_tti_set */


/*******************************************************************************
* digi_otn_otu_sm_so_tti_get
* ______________________________________________________________________________
*
* DESCRIPTION: PRELIMINARY
*   This function gets the all fields (SAPI/DAPI/OP) in the OTU_SO_SM_TTI
*   registers per the requested dsi stream (0..11). 
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
* OUTPUTS:
*   tti_data               - pre allocated 64xUINT8 unsigned array.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*   1. Invoking this function before a dsi stream is provisioned will result
*      in failure and an error status will be returned.\n
*   2. Invoking this function will cause a read into device registers.\n
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_sm_so_tti_get          ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       UINT8                     tti_data[64] )


{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != tti_data, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        
        rc = lineotn_sm_so_tti_get(linesys_handle,
                                   otn_srvr_ptr->dsi_base_chnl,
                                   (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                   (UINT32*)tti_data);
    }
    

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_sm_so_tti_get */


/*******************************************************************************
* digi_otn_otu_sm_exp_tti_set
* ______________________________________________________________________________
*
* DESCRIPTION: PRELIMINARY
*   This function sets the all fields (SAPI/DAPI/OP) in the OTU_SK_SM_EXP_TTI
*   registers per the requested dsi stream (0..11). The function works in a
*   read/modify/write of all the TTI values.
*   user is expected to provide ALL of the values to be written to the registers.
*
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   tti_data               - 64xUINT8 unsigned array containing all
*                            tti all values (SAPI/DAPI/OP). \n\n
*                            sapi_data is the first 16 bytes. \n
*                            dapi_data is the second 16 bytes \n
*                            op_data is the last 32 bytes. \n
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_sm_exp_tti_set         ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       UINT8                     tti_data[64] )


{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != tti_data, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        
        rc = lineotn_sm_exp_tti_set(linesys_handle,
                                    otn_srvr_ptr->dsi_base_chnl,
                                    (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                    (UINT32*)tti_data);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_sm_exp_tti_set */

/*******************************************************************************
* digi_otn_otu_sm_exp_tti_get
* ______________________________________________________________________________
*
* DESCRIPTION: PRELIMINARY
*   This function gets the all fields (SAPI/DAPI/OP) in the OTU_SK_SM_EXP_TTI
*   registers per the requested dsi stream (0..11). 
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
* OUTPUTS:
*   tti_data               - pre allocated 64xUINT8 unsigned array.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*   1. Invoking this function before a dsi stream is provisioned will result
*      in failure and an error status will be returned.\n
*   2. Invoking this function will cause a read into device registers.\n
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_sm_exp_tti_get         ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       UINT8                     tti_data[64] )


{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != tti_data, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        
        rc = lineotn_sm_exp_tti_get(linesys_handle,
                                    otn_srvr_ptr->dsi_base_chnl,
                                    (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                    (UINT32*)tti_data);
        
    }
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_sm_exp_tti_get */

/*******************************************************************************
* digi_otn_otu_sm_accepted_tti_get
* ______________________________________________________________________________
*
* DESCRIPTION: PRELIMINARY
*   This function reads the accepted TTI register per requested dsi stream (0..11)
*   intto a user buffer. This is a SK (Rx) only function.
*
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
* OUTPUTS:
*   tti_data_buf           - pointer to 64xUINT8 array containing user
*                            buffer to which the tti values will be copied to.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_OH_EXT_FAILED  - Internally generated error code
* NOTES:
*   1. While accessing accepted tti register values, this register is will not be updated
*      by the device HW.\n
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_sm_accepted_tti_get    ( digi_handle_t             *digi_handle,
                                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                                       UINT8                     tti_data_buf[64] )
{   
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != tti_data_buf, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);
    
    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
        
        rc = lineotn_sm_accepted_tti_get(linesys_handle,
                                         otn_srvr_ptr->dsi_base_chnl,
                                         (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                         (UINT32*)tti_data_buf);
        
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_sm_accepted_tti_get */

/*******************************************************************************
* digi_otn_exp_tti_tim_det_mode_set
* ______________________________________________________________________________
*
* DESCRIPTION: PRELIMINARY
*   This function sets OTU_SK_SM_EXP_TTI dTIM detection mode registers per the 
*   requested dsi stream (0..11). 
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*
*   *otn_server_ptr        - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   exp_tti_tim_det_mode   - enum, dTIM detection mode:\n
*    OTU_SK_SM_DTIM_DET_DISABLED    : dTIM defect detection is disabled \n
*    OTU_SK_SM_DTIM_DET_SAPI        : The expected SAPI field is used when determining the dTIM defect \n
*    OTU_SK_SM_DTIM_DET_DAPI        : The expected DAPI field is used when determining the dTIM defect n\
*    OTU_SK_SM_DTIM_DET_BOTH        : Both the expected SAPI field and the expected DAPI field are 
*                                     used when determining the dTIM defect \n
* OUTPUTS:
*   None
*
* RETURNS:
*       0 - PMC_SUCCESS
*       LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_exp_tti_tim_det_mode_set( digi_handle_t             *digi_handle,
                                                    digi_otn_server_chnl_t    *otn_server_ptr,
                                                    lineotn_sk_tim_det_mode_t exp_tti_tim_det_mode )
{

    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(exp_tti_tim_det_mode < LAST_LINE_OTN_SK_SM_DTIM_DET, DIGI_ERR_INVALID_ARG, exp_tti_tim_det_mode, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {        
        rc = lineotn_exp_tti_tim_det_mode_set(linesys_handle,
                                              otn_srvr_ptr->dsi_base_chnl,
                                              (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                              exp_tti_tim_det_mode);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);


} /* digi_otn_exp_tti_tim_det_mode_set */

/*******************************************************************************
* digi_otn_exp_tti_tim_det_mode_get
* ______________________________________________________________________________
*
* DESCRIPTION: PRELIMINARY
*   This function gets OTU_SK_SM_EXP_TTI dTIM detection mode 
*   registers per the requested dsi stream (0..11). 
*
* INPUTS:
*   digi_handle           - pointer to digi handle instance.
*
*   *otn_server_ptr       - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
* OUTPUTS:
*   *exp_tti_tim_det_mode - pointer to pre allocated enum, dTIM detection mode:\n
*    OTU_SK_SM_DTIM_DET_DISABLED    : dTIM defect detection is disabled \n
*    OTU_SK_SM_DTIM_DET_SAPI        : The expected SAPI field is used when determining the dTIM defect \n
*    OTU_SK_SM_DTIM_DET_DAPI        : The expected DAPI field is used when determining the dTIM defect \n
*    OTU_SK_SM_DTIM_DET_BOTH        : Both the expected SAPI field and the expected DAPI field are 
*                                     used when determining the dTIM defect \n
* RETURNS:
*       0 - PMC_SUCCESS
*       LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_exp_tti_tim_det_mode_get( digi_handle_t             *digi_handle,
                                                    digi_otn_server_chnl_t    *otn_server_ptr,
                                                    lineotn_sk_tim_det_mode_t *exp_tti_tim_det_mode )
{

    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != exp_tti_tim_det_mode, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
    
        rc = lineotn_exp_tti_tim_det_mode_get(linesys_handle,
                                              otn_srvr_ptr->dsi_base_chnl,
                                              (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                              exp_tti_tim_det_mode);
    }
        
    PMC_ATOMIC_RETURN(digi_handle,rc);

} /* digi_otn_exp_tti_tim_det_mode_get */

/*******************************************************************************
* digi_otn_otu_ebc_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   retrieve LINEOTN otu framer far/near end counters. 
*
* INPUTS:
*   digi_handle           - pointer to digi handle instance.
*
*   *otn_server_ptr       - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
* OUTPUTS:
*   *ebc - LINEOTN otu framer far/near end counters\n
* RETURNS:
*       0 - PMC_SUCCESS
*       LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_ebc_get( digi_handle_t             *digi_handle,
                                       digi_otn_server_chnl_t    *otn_server_ptr,
                                       digi_pmon_lineotn_otu_frm_counters_t *ebc )
{

    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != ebc, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    if (PMC_SUCCESS == rc)
    {
    
        rc = lineotn_ebc_get(linesys_handle,
                             otn_srvr_ptr->dsi_base_chnl,
                             (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                             (lineotn_otu_frm_counters_t *)ebc);
    }
        
    PMC_ATOMIC_RETURN(digi_handle,rc);

} /* digi_otn_otu_ebc_get */


/*******************************************************************************
* digi_otn_fec_type_get
* ______________________________________________________________________________
*
* DESCRIPTION: PRELIMINARY
*   This function gets the fec configuration mode per the requested dsi stream (0..11). 
*
* INPUTS:
*   digi_handle           - pointer to digi handle instance.
*
*   *otn_server_ptr       - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
* OUTPUTS:
*   *fec_type             - pointer to pre allocated enum, fec type:\n
*       DIGI_OTN_SERVER_FEC_NONE          : No FEC configured \n
*       DIGI_OTN_SERVER_FEC_I4            : FEC type I4 \n
*       DIGI_OTN_SERVER_FEC_I7            : FEC type I7 \n
*       DIGI_OTN_SERVER_FEC_G709          : FEC type RSFEC (G7.09) \n
*       DIGI_OTN_SERVER_FEC_SWIZZLE_100G  : FEC type Swizzle 100G \n 
*       DIGI_OTN_SERVER_FEC_SWIZZLE_40G   : FEC type Swizzle 40G  \n
*
* RETURNS:
*       0 - PMC_SUCCESS
*       LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_fec_type_get( digi_handle_t             *digi_handle,
                                        digi_otn_server_chnl_t    *otn_server_ptr,
                                        digi_otn_server_fec_t     *fec_type )
{

    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *handle_ptr = digi_handle->lineotn_handle;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != fec_type, DIGI_ERR_INVALID_ARG, 0, 0);
    
    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, otn_server_ptr, rc, TRUE);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);


    /*
     * If this is SYSOTN and then ensure that the sysotn handle is used.
     */
    if (otn_srvr_ptr->sys_line_src == TRUE)
    {
        handle_ptr = digi_handle->sysotn_handle;
    }

    rc = lineotn_fec_type_get(handle_ptr,
                              otn_srvr_ptr->dsi_base_chnl,
                              (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                              (lineotn_fec_t*)fec_type);


    PMC_ATOMIC_RETURN(digi_handle,rc);

} /* digi_otn_fec_type_get */

/*******************************************************************************
* digi_otn_fec_type_set
* ______________________________________________________________________________
*
* DESCRIPTION: PRELIMINARY
*   This function sets the fec configuration mode per the requested dsi stream (0..11). 
*   It can be used to change the FEC type on the fly from one type to another.
*
*   Please note that digi_pmon_fw_fec_cfg should be called after this function
*   so as to inform FW to configure PMON related items for FEC accordingly.
*
* INPUTS:
*   digi_handle           - pointer to digi handle instance.
*
*   *otn_server_ptr       - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   fec_type              - enum, fec type:\n
*       DIGI_OTN_SERVER_FEC_NONE          : No FEC configured \n
*       DIGI_OTN_SERVER_FEC_I4            : FEC type I4 \n
*       DIGI_OTN_SERVER_FEC_I7            : FEC type I7 \n
*       DIGI_OTN_SERVER_FEC_G709          : FEC type RSFEC (G7.09) \n
*       DIGI_OTN_SERVER_FEC_SWIZZLE_100G  : FEC type Swizzle 100G  \n
*       DIGI_OTN_SERVER_FEC_SWIZZLE_40G   : FEC type Swizzle 40G  \n
*       etc.
*
* OUTPUTS:
*   None
* RETURNS:
*       0 - PMC_SUCCESS
*       LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*       LINEOTN_ERR_STRONG_FEC_MIX_NOT_SUPPORTED - Internally generated error code* 
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_fec_type_set( digi_handle_t             *digi_handle,
                                        digi_otn_server_chnl_t    *otn_server_ptr,
                                        digi_otn_server_fec_t     fec_type )
{

    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *handle_ptr = digi_handle->lineotn_handle;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    rc = digi_otn_fec_type_validate(digi_handle, fec_type);
    PMC_ASSERT(PMC_SUCCESS == rc, rc, 0, 0);

    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, otn_server_ptr, rc, TRUE);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    /*
     * If this is SYSOTN and then ensure that the sysotn handle is used.
     */
    if (otn_srvr_ptr->sys_line_src == TRUE)
    {
        handle_ptr = digi_handle->sysotn_handle;
    }

    /* Set new FEC */
    if(PMC_SUCCESS == rc)
    {
    /* The procedure below will deprovision the previous FEC before provisioning the new one */
        rc = lineotn_fec_cfg(handle_ptr,
                             otn_srvr_ptr->dsi_base_chnl,
                             (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                             (lineotn_fec_t)fec_type);
    }

    if(PMC_SUCCESS == rc)
    {
        /* Activate the FEC */
        rc = lineotn_fec_act(handle_ptr,
                             otn_srvr_ptr->dsi_base_chnl,
                             (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);

} /* digi_otn_fec_type_set */


/*******************************************************************************
* digi_otn_fec_dec_passthru_set
* ______________________________________________________________________________
*
* DESCRIPTION: PRELIMINARY
*   This function will set the decoder state for a selected fec per dsi stream.
*   The function will change the decoder state WITHIN a specified fec block.
*   Setting the decoder state to disabled will cause traffic to go through the 
*   decoder keepind the fec latency, however, no error corrections or statistics
*   collection will be performed.
*   this function is required for implementation of MI_FECEn of G.798 .
*
* INPUTS:
*   digi_handle           - pointer to digi handle instance.
*
*   *otn_server_ptr       - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   fec_type              - enum, fec type (only fecs on this list are supported):\n
*       DIGI_OTN_SERVER_FEC_I4            : FEC type I4 \n
*       DIGI_OTN_SERVER_FEC_I7            : FEC type I7 \n
*       DIGI_OTN_SERVER_FEC_G709          : FEC type RSFEC (G7.09) \n
*       DIGI_OTN_SERVER_FEC_SWIZZLE_40G   : FEC type Swizzle 40G 
*       etc.
*
*   dec_passthru          - boolean, TRUE  :fec decoder is passed through \n
*                                  , FALSE :fec decoder is correcting errors \n
* OUTPUTS:
*   None
* 
* RETURNS:
*       0 - PMC_SUCCESS
*       LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
* 
* NOTES:
*   1) The I7 FEC does not support the passthru feature at 10G\n
* 
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_fec_dec_passthru_set( digi_handle_t             *digi_handle,
                                                digi_otn_server_chnl_t    *otn_server_ptr,
                                                digi_otn_server_fec_t     fec_type,
                                                BOOL                      dec_passthru ) 
{

    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(fec_type < LAST_DIGI_OTN_SERVER_FEC, DIGI_ERR_INVALID_ARG,fec_type, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);
    
    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  

    /* Set new FEC */
    if(PMC_SUCCESS == rc )
    {
        rc = lineotn_fec_dec_passthru_set( linesys_handle,
                                           otn_srvr_ptr->dsi_base_chnl,
                                           (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                           (lineotn_fec_t)fec_type,
                                           dec_passthru );
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);

} /* digi_otn_fec_dec_passthru_set */

/*******************************************************************************
* digi_otn_fec_dec_passthru_get
* ______________________________________________________________________________
*
* DESCRIPTION: PRELIMINARY
*   This function returns a TRUE boolean if fec decoder mode is in pass thruogh mode 
*   per requested otn server channel.
*
* INPUTS:
*   digi_handle           - pointer to digi handle instance.
*
*   *otn_server_ptr       - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
* OUTPUTS:
*   *fec_dec_in_passthru_mode  - pointer to pre allocated boolean, fec dec pass thru mode:\n
*                               ,TRUE           : fec decoder is in pass thru mode\n
*                               ,FALSE          : fec decoder is not in pass thru mode\n
* RETURNS:
*       0 - PMC_SUCCESS
*       LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_fec_dec_passthru_get( digi_handle_t             *digi_handle,
                                                digi_otn_server_chnl_t    *otn_server_ptr,
                                                BOOL                      *fec_dec_in_passthru_mode )
{

    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != fec_dec_in_passthru_mode, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    
    if (PMC_SUCCESS == rc)
    {
        
        rc = lineotn_fec_dec_passthru_get(linesys_handle,
                                          otn_srvr_ptr->dsi_base_chnl,
                                              (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                          fec_dec_in_passthru_mode);
    }
    PMC_ATOMIC_RETURN(digi_handle,rc);

} /* digi_otn_fec_dec_passthru_get */


/*******************************************************************************
* digi_otn_fec_rx_mode_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function configures the operation mode (enabled, passthru or bypassed) 
*   of a provisioned FEC DECODER per requested otn server channel.
*
* INPUTS:
*   digi_handle           - pointer to digi handle instance.
*
*   *otn_server_ptr       - Pointer to a resource allocation
*                           context for the OTN server configured against the
*                           specified serdes port.
*
*   fec_rx_mode          -  Rx FEC processing mode \n
*                           see digi_rx_fec_mode_t for a detailed description 
*
* OUTPUTS:
*   None
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
* 
* 
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_fec_rx_mode_set( digi_handle_t             *digi_handle,
                                           digi_otn_server_chnl_t    *otn_server_ptr,
                                           digi_fec_rx_mode_t         fec_rx_mode ) 
{

    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(fec_rx_mode < LAST_DIGI_FEC_RX, DIGI_ERR_INVALID_ARG,fec_rx_mode, 0);
  
    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);
  
    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  

    if(PMC_SUCCESS == rc )
    {
        rc = lineotn_fec_dec_mode_set( linesys_handle,
                                       otn_srvr_ptr->dsi_base_chnl,
                                       (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                       (lineotn_fec_dec_mode_t) fec_rx_mode );
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);

} /* digi_otn_fec_rx_mode_set */

/*******************************************************************************
* digi_otn_fec_rx_mode_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function returns the operation mode (enabled, passthru, bypassed) of a 
*   provisioned FEC DECODER per requested otn server channel.
*
* INPUTS:
*   digi_handle           - pointer to digi handle instance.
*
*   *otn_server_ptr       - Pointer to a resource allocation
*                           context for the OTN server configured against the
*                           specified serdes port.
*
* OUTPUTS:
*   *fec_rx_mode          - pointer to Rx FEC processing mode \n
*                           see digi_rx_fec_mode_t for a detailed description
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_fec_rx_mode_get( digi_handle_t             *digi_handle,
                                           digi_otn_server_chnl_t    *otn_server_ptr,
                                           digi_fec_rx_mode_t         *fec_rx_mode )
{

    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    lineotn_handle_t *linesys_handle;
    lineotn_fec_dec_mode_t fec_dec_mode = LAST_LINE_OTN_FEC_RX;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != fec_rx_mode, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
    
    if (PMC_SUCCESS == rc)
    {
        
        rc = lineotn_fec_dec_mode_get(linesys_handle,
                                      otn_srvr_ptr->dsi_base_chnl,
                                      (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                      &fec_dec_mode);
    }
    
    
    if (PMC_SUCCESS == rc)
    {
        switch(fec_dec_mode)
        {
            case LINE_OTN_FEC_RX_ENABLED:
                *fec_rx_mode = DIGI_FEC_RX_ENABLED;
                break;

            case LINE_OTN_FEC_RX_CORRECTION_DISABLED:
                *fec_rx_mode = DIGI_FEC_RX_CORRECTION_DISABLED;
                break;
            case LINE_OTN_FEC_RX_BYPASSED:
                *fec_rx_mode = DIGI_FEC_RX_BYPASSED;
                break;    

            default:
                rc = LINEOTN_ERR_INVALID_PARAMETERS;
        }
    }
    

    PMC_ATOMIC_RETURN(digi_handle,rc);

} /* digi_otn_fec_rx_mode_get */


#ifndef DOXYGEN_PUBLIC_ONLY

/*******************************************************************************
* digi_otn_fec_type_validate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function validate fec type regarding device type.
*
* INPUTS:
*   digi_handle           - pointer to digi handle instance.
*
*   fec_type              - enum, fec type:\n
*       DIGI_OTN_SERVER_FEC_NONE          : No FEC configured \n
*       DIGI_OTN_SERVER_FEC_I4            : FEC type I4 \n
*       DIGI_OTN_SERVER_FEC_I7            : FEC type I7 \n
*       DIGI_OTN_SERVER_FEC_G709          : FEC type RSFEC (G7.09) \n
*       DIGI_OTN_SERVER_FEC_SWIZZLE_100G  : FEC type Swizzle 100G  \n
*       DIGI_OTN_SERVER_FEC_SWIZZLE_40G   : FEC type Swizzle 40G  \n
*       etc.
*
* OUTPUTS:
*   None
* RETURNS:
*       PMC_SUCCESS or a descriptive error code.
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_fec_type_validate( digi_handle_t             *digi_handle,
                                             digi_otn_server_fec_t     fec_type )
{
    PMC_ERROR rc = PMC_SUCCESS;

    PMC_ENTRY();


    switch (fec_type)
    {
        /* passthru */
    case DIGI_OTN_SERVER_FEC_NONE:
    case DIGI_OTN_SERVER_FEC_I4:
    case DIGI_OTN_SERVER_FEC_I7:
    case DIGI_OTN_SERVER_FEC_G709:
    case DIGI_OTN_SERVER_FEC_SWIZZLE_100G:
    case DIGI_OTN_SERVER_FEC_SWIZZLE_40G:
        break;
        /* passthru */
    default:
        rc = DIGI_ERR_INVALID_ARG;
    }

    PMC_RETURN(rc);
}/* digi_otn_fec_type_validate */

/*******************************************************************************
* digi_lineotn_channel_num_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function gets the channel number.
*
* INPUTS:
    *digi_handle           - pointer to DIGI handle instance
*   *chnl_handle           - pointer to channel handle.
*
* OUTPUTS:
*   none
*
* RETURNS:
*   dsi_base_chnl           - base dsi stream number
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_lineotn_channel_num_get(digi_handle_t *digi_handle,
                                           digi_otn_server_chnl_t *chnl_handle)
{
    UINT32 dsi_base_chnl;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(chnl_handle);

    PMC_ENTRY();
   
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_handle, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);


    dsi_base_chnl = otn_srvr_ptr->dsi_base_chnl;
    
    PMC_RETURN(dsi_base_chnl);

} /* digi_lineotn_channel_num_get */

/*******************************************************************************
* digi_lineotn_dci_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function gets the dci number.
*
* INPUTS:
    *digi_handle           - pointer to DIGI handle instance
*   *chnl_handle           - pointer to channel handle.
*
* OUTPUTS:
*   none
*
* RETURNS:
*   dci_chnl               - DCI channel number
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_lineotn_dci_chnl_get(digi_handle_t          *digi_handle,
                                        digi_otn_server_chnl_t *chnl_handle)
{
    UINT32 dci_chnl;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(chnl_handle);

    PMC_ENTRY();
   
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_handle, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    dci_chnl = otn_srvr_ptr->dci_chnl;
    
    PMC_RETURN(dci_chnl);

} /* digi_lineotn_dci_chnl_get */

/*******************************************************************************
* digi_lineotn_loopback_cfg
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function configures the opsm loopback for an already provisioned dsi stream.
*
* INPUTS:
*   digi_handle           - pointer to digi handle instance.
*
*   *otn_server_ptr       - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
*   loopback_dir          - enum, loopback direction: \n
*                            LINE_OTN_RX_DIR \n
*                            LINE_OTN_TX_DIR \n
*
*   loopback_state        - enum, requsted loopback state:
*                            LINE_OTN_LOOPBACK_DISABLED  : loopback disabled \n
*                            LINE_OTN_LOOPBACK_ENABLED   : loopback enabled \n
* OUTPUTS:
*   None.
*
* RETURNS:
*       LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*       0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_lineotn_loopback_cfg(digi_handle_t             *digi_handle,
                                           digi_otn_server_chnl_t    *otn_server_ptr,
                                           lineotn_dir_t             loopback_dir,
                                           lineotn_loopback_state_t  loopback_state)
{

    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *server_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    digi_serdes_port_def_t *port_ctxt_ptr = NULL;
    digi_serdes_prov_state_t prov_state = DIGI_SERDES_PROV_STATE_NO_SERDES;
    BOOL is_sysotn = FALSE;
    UINT32 port_uid = DIGI_SERDES_PROV_STATE_UNASSIGNED;
    UINT32 i,dsi_stream;
    BOOL sfi51_mode = FALSE;
    BOOL loopback_enable = (LINE_OTN_LOOPBACK_ENABLED == loopback_state ? TRUE : FALSE);

    PMC_ATOMIC_ENTRY(digi_handle);
 
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(LAST_LINE_OTN_DIR > loopback_dir, DIGI_ERR_INVALID_ARG, loopback_dir, 0);
    PMC_ASSERT(LAST_LINE_OTN_LOOPBACK_STATE > loopback_state, DIGI_ERR_INVALID_ARG, loopback_state, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, server_ptr);
    
    /* validate loopback mode */    
    if (TRUE == server_ptr->loopback_enabled && loopback_state == LINE_OTN_LOOPBACK_ENABLED)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_LOOPBACK_ALREADY_PROV);
    } else if (FALSE == server_ptr->loopback_enabled && loopback_state == LINE_OTN_LOOPBACK_DISABLED)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_LOOPBACK_NOT_PROV);
    }
    
    port_uid = server_ptr->port_uid;
    PMC_ASSERT(port_uid != DIGI_SERDES_UNASSIGNED,DIGI_ERR_LOOPBACK_INVALID_PORT_UID,0,0);

    /* Check if serdes (line-side or system-side) is connected to lineotn or sysotn */
    for (dsi_stream = 0; dsi_stream < DIGI_SERDES_DSI_LANES_MAX; dsi_stream++) 
    {
        if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[dsi_stream].port_uid == port_uid)
        {
            prov_state = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[dsi_stream].prov_state;
            break;
        }
        if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[dsi_stream].port_uid == port_uid)
        {
            prov_state = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[dsi_stream].prov_state;
            break;
        }
    }
    is_sysotn = server_ptr->sys_line_src;
    PMC_LOG_TRACE("%s loopback cfg: handle = %p loopback_dir=%d loopback_state=%x enabled=%d prov state = %x\n",
                    (is_sysotn ? "sysotn" : "lineotn"),
                    otn_server_ptr, loopback_dir,loopback_state, server_ptr->loopback_enabled,prov_state);

    PMC_ASSERT(dsi_stream < DIGI_SERDES_DSI_LANES_MAX,DIGI_ERR_LOOPBACK_INVALID_PORT_PROV, port_uid, 0);

    /* If facility loopback - find the port context & enable loop timing */
    if (loopback_dir == LINE_OTN_RX_DIR) 
    {
        /* Find the serdes port context in can be line s16, line sfi5.1 or sys s16 */
        /* line-side s16 */
        for (i=0; i < DIGI_NUM_LINE_PORTS_MAX && port_ctxt_ptr == NULL; i++) {
            if (digi_handle->var.port_ctxt.line_port_ctxt[i].port_uid == port_uid) {
                port_ctxt_ptr = &(digi_handle->var.port_ctxt.line_port_ctxt[i]);
                break;
            }
        }
        /* sfi5.1 port ctxt */
        for (i=0; i < DIGI_NUM_SFI51_PORTS_MAX && port_ctxt_ptr == NULL; i++) {
            if (digi_handle->var.port_ctxt.sfi51_port_ctxt[i].port_uid == port_uid) {
                port_ctxt_ptr = &(digi_handle->var.port_ctxt.sfi51_port_ctxt[i]);
                sfi51_mode = TRUE;
                break;
            }
        }
        /* system-side s16 port ctxt */
        for (i=0; i < DIGI_NUM_SYS_PORTS_MAX && port_ctxt_ptr == NULL; i++) {
            if (digi_handle->var.port_ctxt.sys_port_ctxt[i].port_uid == port_uid) {
                port_ctxt_ptr = &(digi_handle->var.port_ctxt.sys_port_ctxt[i]);
                break;
            } 
        }
        PMC_ASSERT(port_ctxt_ptr != NULL, DIGI_ERR_LOOPBACK_INVALID_PORT_PROV, 0, 0);

        /* Facility loopback requires loop timing to be enabled */
        if (sfi51_mode)
        {
            /* Enable loop timing in d8 serdes */
            rc = digi_serdes_sfi51_loop_timing_cfg(digi_handle, port_ctxt_ptr, loopback_enable);
        }
        else 
        {
            /* Enable s16 loop timing (configure all serdes lane in ACB RX2TX mode without loopback) */
            rc = digi_loopback_serdes_port_acb_only_cfg(digi_handle, port_ctxt_ptr, loopback_enable);
        }
    }
     
    /* For both facility and diagnostic loopbacks */
    if (rc == PMC_SUCCESS)
    {
        /* for both rx and tx loopback */
        rc = lineotn_loopback_cfg((is_sysotn ? digi_handle->sysotn_handle : digi_handle->lineotn_handle),
                                  dsi_stream,
                                  loopback_dir,
                                  loopback_state);
    }
    if (rc == PMC_SUCCESS)
    {
        server_ptr->loopback_enabled = loopback_enable;
    }
    PMC_ATOMIC_RETURN(digi_handle, rc);
} /* digi_lineotn_loopback_cfg */

#endif /*DOXYGEN_PUBLIC_ONLY*/

/*******************************************************************************
* digi_lineotn_bergen_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Enables/Disables Bit Error Generator on 32-bit interfaces (BERGEN32)
*
*   Bit Error Rate Generator (BERGEN) blocks are available on each 10G, 32-bit\n
*   line-side interface. These blocks are typically used to evaluate FEC \n
*   performance. 
*
*   This function configures BERGEN for one or multiple lane interfaces. \n
*   It is possible to configure mutliple lanes of a same serdes port with \n
*   different BERGEN configurations by calling  this function multiple times.
*    
*   BERGEN functionanlity is only available on stream provisioned on LINE 32-bits \n
*   serdes port (S16). Therefore, It is not supported on stream provisioned on \n
*   SFI5.1 interface
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*   *otn_server_ptr        - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*   logical_lanes_msk  - it is the logical lane mask associated to \n
*                        the aggregated port. Use 0xF and 0x3FF to respectively \n
*                        enable all lanes for OTU3 and OTU4 stream. This field\n
*                        is ignored for an OTU2 streams.
*   bergen_lane_cfg_ptr    - Pointer to a bergen32 lane configuration. (see \n
*                            digi_bergen_lane_cfg_t type definition for details)
*   enable                 - boolean, TRUE  -- enable BERGENs on specified lanes 
*                                     FALSE -- disables BERGENs on specified lanes
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_lineotn_bergen_set(   digi_handle_t           *digi_handle,
                                            digi_otn_server_chnl_t  *otn_server_ptr,
                                            UINT32                   logical_lanes_msk,
                                            digi_bergen_lane_cfg_t  *bergen_lane_cfg_ptr,
                                            BOOL8                    enable)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);    
    otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != bergen_lane_cfg_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_LOG_TRACE("bergen set: otn_server_ptr=%p dsi_base_chnl = %x,lanes=%x enable = %d\n",
                otn_server_ptr, otn_srvr_ptr->dsi_base_chnl,logical_lanes_msk,enable);
    
    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, otn_server_ptr, rc, TRUE);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    if (otn_srvr_ptr->sys_line_src == TRUE)
    {
        rc = DIGI_ERR_SYSOTN_UNSUPPORTED;
    }
    if (PMC_SUCCESS == rc)
    {
        rc = lineotn_bergen_cfg_set(digi_handle->lineotn_handle,
                                    otn_srvr_ptr->dsi_base_chnl,
                                    logical_lanes_msk,
                                    bergen_lane_cfg_ptr->error_rate,
                                    bergen_lane_cfg_ptr->ringosc_enable,
                                    bergen_lane_cfg_ptr->bergen_mode,
                                    enable);
    }
    PMC_ATOMIC_RETURN(digi_handle,rc);

} /* digi_lineotn_bergen_set */

/*******************************************************************************
* digi_lineotn_bergen_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Get Configuration on Bit Error Generator on 32-bit interfaces (BERGEN32)
*
*   This function should be used a a specified lane. 
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*   *otn_server_ptr        - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*   logical_lane_idx       - it is the logical lane index associated to \n
*                            an aggregated port.This field is ignored for an\n
*                             OTU2 streams.
*
* OUTPUTS:
*   *bergen_lane_cfg_ptr    - Pointer to a bergen32 lane configuration. (see \n
*                            digi_bergen_lane_cfg_t type definition for details)\n
*                            Only valid when enable is TRUE
*   *enable                 - boolean, TRUE  --BERGEN is enabled 
*                                     FALSE -- BERGEN is disabled
*
* RETURNS:
*   0 - PMC_SUCCESS
*   LINEOTN_ERR_INVALID_PARAMETERS - Internally generated error code
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_lineotn_bergen_get(   digi_handle_t           *digi_handle,
                                            digi_otn_server_chnl_t  *otn_server_ptr,
                                            UINT32                   logical_lane_idx,
                                            digi_bergen_lane_cfg_t  *bergen_lane_cfg_ptr,
                                            BOOL8                    *enable)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);    
    otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    PMC_ASSERT(NULL != bergen_lane_cfg_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != enable, DIGI_ERR_INVALID_ARG, 0, 0);

    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, otn_server_ptr, rc, TRUE);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    if (otn_srvr_ptr->sys_line_src == TRUE)
    {
        rc = DIGI_ERR_SYSOTN_UNSUPPORTED;
    }
    if (PMC_SUCCESS == rc)
    {
        rc = lineotn_bergen_cfg_get(digi_handle->lineotn_handle,
                                    otn_srvr_ptr->dsi_base_chnl,
                                    logical_lane_idx,
                                    &bergen_lane_cfg_ptr->error_rate,
                                    &bergen_lane_cfg_ptr->ringosc_enable,
                                    &bergen_lane_cfg_ptr->bergen_mode,
                                    enable);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,rc);

} /* digi_lineotn_bergen_get */


/*******************************************************************************
* digi_lineotn_mld_dlom_to_ffail_mapping_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Enables/Disables lineotn mld dlom to ffail mapping
*
*
* INPUTS:
*   digi_handle            - pointer to digi handle instance.
*   *otn_server_ptr        - Pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*   enable                 - boolean, TRUE  -- dLOM is mapped to FFAIL.
*                                     FALSE -- dLOM is not mapped to FFAIL
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS: Opreation was successful
*   PMC_ERROR:  Otherwise
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_lineotn_mld_dlom_to_ffail_mapping_set(digi_handle_t   *digi_handle,
                                                            digi_otn_server_chnl_t *otn_server_ptr,
                                                            BOOL8 enable)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    UINT32 dsi_stream;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    
    dsi_stream = digi_otn_server_stream_num_get(digi_handle,
                                                otn_server_ptr);
    
    if (DIGI_OTN_SERVER_IS_LINE(otn_server_ptr)) 
    {
        if (digi_otn_server_stream_is_10g(digi_handle, otn_server_ptr))
        {
            /*In 10G mode of operation, DLOM_TO_FFAIL_MAPPING[x] corresponds to dLOM[x] and 10G lane x (x=0-11)*/
            dsi_stream = dsi_stream;
        }
        else if (digi_otn_server_stream_is_40g(digi_handle, otn_server_ptr))
        {
            /* In 40G mode of operation, DLOM_TO_FFAIL_MAPPING[y] corresponds to dLOM[y] and 40G slice z (y=3,7,11, z=0,1,2) */
            dsi_stream = dsi_stream + 3;  
        }
        else if (digi_otn_server_stream_is_100g(digi_handle, otn_server_ptr))
        {
            /* In 100G mode of operation, DLOM_TO_FFAIL_MAPPING[11] corresponds to dLOM[11] and the 100G stream. */
            dsi_stream = 11;
        }
        else
        {
            PMC_ASSERT(NULL, DIGI_ERR_INVALID_ARG, 0, 0);
        }
        rc = lineotn_mld_dlom_to_ffail_mapping_set(digi_handle->lineotn_handle,
                                                   dsi_stream,
                                                   enable);
        
        
    } 
    else 
    {
        rc = lineotn_mld_dlom_to_ffail_mapping_set(digi_handle->sysotn_handle,
                                                   dsi_stream,
                                                   enable);
        
    }
    
    PMC_ATOMIC_RETURN(digi_handle,rc);

} /* digi_lineotn_mld_dlom_to_ffail_mapping_set */

/*******************************************************************************
* digi_ri_rcp_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function performs Remote Information Ring Control Port bring up of the \n
*  DIGI device. That includes the initialization of the:
*    - SGMII Ethernet subsystem
*    - 1GB serdes (D8)
*    - The Remote Information ODU Ring Control Port 
*
*   This functions shall be called before enabling any insertion or extraction \n
*   from this port.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *digi_ri_rcp_cfg_ptr   - pointer to RI RCP configuration
*
* OUTPUTS:
*  None
*
* RETURNS:
*   PMC_SUCCESS           - when API execution is successful otherwise a 
*                           descriptive error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ri_rcp_init(digi_handle_t *digi_handle,
                                  digi_otn_odu_ri_rcp_cfg_t *digi_ri_rcp_cfg_ptr)
{
    PMC_ERROR   rc = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_ri_rcp_cfg_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check that DIGI device is initialized */
    if (FALSE == digi_device_init_status_get(digi_handle))
    {
        rc = DIGI_ERR_DEVICE_NOT_INIT;
    }

    /* check that coreotn is in energy running mode */
    digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_RUNNING,COREOTN_ODU_IF);

    /* Initialize D8 serdes instance */
    rc = digi_serdes_ge_port_internal_prov(digi_handle,DIGI_SERDES_INTF_RI_RCP);
    
    if (PMC_SUCCESS == rc)
    {
        /* Initialize  RCP port (which includes the */
        rc = coreotn_odu_rcp_init(
            digi_handle->coreotn_handle,
            ODU_RCP_RI_INST,
            (odu_rcp_init_cfg_t*) digi_ri_rcp_cfg_ptr);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_ri_rcp_init */

/*******************************************************************************
* digi_ri_rcp_uninit
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The function disables the Remote Information Ring Control Port
*
* INPUTS:
*   *digi_handle          - pointer to DIGI handle instance
*
* OUTPUTS:
*  None
*
* RETURNS:
*   PMC_SUCCESS           - when API execution is successful otherwise a 
*                           descriptive error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ri_rcp_uninit(digi_handle_t *digi_handle)
{
    PMC_ERROR   rc = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
   
    /* check that DIGI device is initialized */
    if (FALSE == digi_device_init_status_get(digi_handle))
    {
        rc = DIGI_ERR_DEVICE_NOT_INIT;
    }

    /* Initialize D8 serdes instance */
    rc = digi_serdes_ge_port_internal_deprov(digi_handle,DIGI_SERDES_INTF_RI_RCP);
    
    if (PMC_SUCCESS == rc)
    {
        /* Initialize  RCP port (which includes the */
        rc = coreotn_odu_rcp_uninit(
            digi_handle->coreotn_handle,
            ODU_RCP_RI_INST);
    }

    digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_OPTIMAL,COREOTN_ODU_IF);

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_ri_rcp_uninit */

/*******************************************************************************
* digi_ri_rcp_init_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function gets Remote Defects Information Ring Control Port status, inited or not.
*
*
* INPUTS:
*   *digi_handle          - pointer to DIGI handle instance
*
* OUTPUTS:
*   *digi_ri_rcp_cfg_ptr  - pointer to RI RCP configuration
*   enable                - RI RCP enabled(when inited) or disabled(when uninited)
*
* RETURNS:
*   PMC_SUCCESS           - when API execution is successful otherwise a 
*                           descriptive error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ri_rcp_init_get(digi_handle_t *digi_handle,
                                      digi_otn_odu_ri_rcp_cfg_t *digi_ri_rcp_cfg_ptr,
                                      BOOL *enable)
{
    PMC_ERROR   rc = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that DIGI device is initialized */
    if (FALSE == digi_device_init_status_get(digi_handle))
    {
        rc = DIGI_ERR_DEVICE_NOT_INIT;
    }

    if (PMC_SUCCESS == rc)
    {
        rc = coreotn_odu_rcp_init_get(digi_handle->coreotn_handle,
                                      ODU_RCP_RI_INST,
                                      (odu_rcp_init_cfg_t*) digi_ri_rcp_cfg_ptr,
                                      enable);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_ri_rcp_init_get */

/*******************************************************************************
* digi_otn_odu_ri_rcp_extract_cfg
* ______________________________________________________________________________
* 
* DESCRIPTION: 
*  Configures DI RCP extraction for an ODU framer channel. A RI_RCP PDU is \n
*  assembled  with the following information for the specified channel:
*    - The BDI/BEI/BIAE bits from the TCMs and PM layers are extracted. \n
*    - The four APS/PCC bytes from a single connection monitoring level are \n
*      extracted (one of ODUk Path, ODUk TCM1-6, or ODUk server layer trail \n
*      where the server layer trail is an OTUk or HO ODUk). \n
*    - The Server Signal Fail (SSF) over the 8 ODUk frame window where the \n
*      APS/PCC bytes are captured. 
*
*  Assembled RI_RCP DPU are sent to a the destination specified by a \n
*  digi_otn_odu_ri_rcp_dst_cfg_t structure.  digi_otn_odu_ri_rcp_dest_get \n
*  function can be used to retrieve a digi_otn_odu_ri_rcp_dst_cfg_t structure \n
*  from a provisioned ODU framer channel on this DIGI or on a remote DIGI.\n
*  The APS/PCC connection monitoring level can updated dynamically. \n
*  digi_otn_odu_ri_rcp_aps_pcc_cfg should be used to update this parameter.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle (digi_otn_odu_chnl_t) 
*                         for framers 1, 2, 3A or 3B or a mapper channel 
*                         handle (digi_mapper_chnl_t) for framer 4.
*                         The digi_otn_odu_chnl_t handle is provisioned by the 
*                         digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                         functions. The mapper channel handle is provisioned
*                         by the digi_otn_mapper_prov function. The 3B framer
*                         handle is retrieved by calling 
*                         digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                         channel handle as a parameter.
*   *ri_rcp_dst_cfg_ptr - pointer to ODU RI RCP destination configuration
*   aps_pcc_mon_level   - The APS/PCC connection monitoring level  (0 to 7)
*   enable              - RI_RCP extraction control. \n 
*                         TRUE: Enabled \n 
*                         FALSE: Disabled \n 
*                         When the is parameter is FALSE, aps_pcc_mon_level \n 
*                         and ri_rcp_dst_cfg_ptr parameters are ignored 
*   
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_ri_rcp_extract_cfg( digi_handle_t *digi_handle,
                                                  digi_otn_odu_chnl_t *chnl_ptr,
                                                  digi_otn_odu_ri_rcp_dst_cfg_t *ri_rcp_dst_cfg_ptr,
                                                  UINT8 aps_pcc_mon_level,
                                                  BOOL8 enable)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    odu_struct_t *odu_struct_ptr;
    UINT32 num_element;
    UINT32 cal_entries_per_ch[DIGI_SCHD_96_ENTRY];
    UINT32 num_cal_entries;
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id,i;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != ri_rcp_dst_cfg_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
        
    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    /* Retrieve the odu struct handle, channel ID & framer ID */
    odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);

    if (ODU_STRUCT_FRM_STGN == frm_id || ODU_STRUCT_FRM_STG1 == frm_id)
    {
        num_element = DIGI_NUM_HO_ODU_CHNL_MAX;
    } 
    else 
    {
        num_element = DIGI_NUM_LO_ODU_CHNL_MAX;
    }

    PMC_MEMSET(cal_entries_per_ch, 0, sizeof(cal_entries_per_ch));

    /*
     *  cal_entries - stores the calendar entries for one ch
     *  cal_entries_per_ch - stores the number of cal entries for each ch
     */
    for (i = 0; i < num_element && PMC_SUCCESS == rc; i++)
    {
        rc = digi_otn_cal_entries_count_get(digi_handle,
                                          TRUE, /* RX_DB=TRUE */
                                          i,
                                          frm_id,
                                          &num_cal_entries);
        cal_entries_per_ch[i] = num_cal_entries;
    } 
    
    if (PMC_SUCCESS == rc)
    {
        rc = odu_struct_ri_rcp_extract_cfg( digi_handle->coreotn_handle,
                                            odu_struct_ptr,
                                            ri_rcp_dst_cfg_ptr,
                                            aps_pcc_mon_level,
                                            cal_entries_per_ch,
                                            enable);
    }
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_odu_ri_rcp_extract_cfg */

/*******************************************************************************
* digi_otn_odu_ri_rcp_extract_cfg_get
* ______________________________________________________________________________
* 
* DESCRIPTION: 
*  Gets DI RCP extraction enable status of an ODU framer channel.
*
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle (digi_otn_odu_chnl_t) 
*                         for framers 1, 2, 3A or 3B or a mapper channel 
*                         handle (digi_mapper_chnl_t) for framer 4.
*                         The digi_otn_odu_chnl_t handle is provisioned by the 
*                         digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                         functions. The mapper channel handle is provisioned
*                         by the digi_otn_mapper_prov function. The 3B framer
*                         handle is retrieved by calling 
*                         digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                         channel handle as a parameter.
*   
* OUTPUTS:
*   *ri_rcp_dst_cfg_ptr - pointer to ODU RI RCP destination configuration
*   aps_pcc_mon_level   - The APS/PCC connection monitoring level  (0 to 7)
*   enable              - RI_RCP extraction control. \n 
*                         TRUE: Enabled \n 
*                         FALSE: Disabled \n 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_ri_rcp_extract_cfg_get(digi_handle_t *digi_handle,
                                                     digi_otn_odu_chnl_t *chnl_ptr,
                                                     digi_otn_odu_ri_rcp_dst_cfg_t *ri_rcp_dst_cfg_ptr,
                                                     UINT8 *aps_pcc_mon_level,
                                                     BOOL8 *enable)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    odu_struct_t *odu_struct_ptr;
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
        
    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    /* Retrieve the odu struct handle, channel ID & framer ID */
    odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);

    if (PMC_SUCCESS == rc)
    {
        rc = odu_struct_ri_rcp_extract_cfg_get( digi_handle->coreotn_handle,
                                                odu_struct_ptr,
                                                ri_rcp_dst_cfg_ptr,
                                                aps_pcc_mon_level,
                                                enable);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_odu_ri_rcp_extract_cfg_get */

/*******************************************************************************
* digi_otn_odu_ri_rcp_resize
* ______________________________________________________________________________
* 
* DESCRIPTION: 
*
*  This function resizes RCP for G.HAO. The datapath should be resized first 
*  when ramping down and RCP should be resized first when ramping up.
*  
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle (digi_otn_odu_chnl_t) 
*                         for framers 1, 2, 3A or 3B or a mapper channel 
*                         handle (digi_mapper_chnl_t) for framer 4.
*                         The digi_otn_odu_chnl_t handle is provisioned by the 
*                         digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                         functions. The mapper channel handle is provisioned
*                         by the digi_otn_mapper_prov function. The 3B framer
*                         handle is retrieved by calling 
*                         digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                         channel handle as a parameter.
*   resize              - number of slots to resize: +ve increase, -ve decrease
*   
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_ri_rcp_resize(digi_handle_t *digi_handle,
                                            digi_otn_odu_chnl_t *chnl_ptr,
                                            INT32 resize)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    odu_struct_t *odu_struct_ptr;
    UINT32 num_element;
    UINT32 cal_entries[DIGI_SCHD_96_ENTRY];
    UINT32 cal_entries_per_ch[DIGI_SCHD_96_ENTRY];
    UINT32 num_cal_entries;
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id,i;
    INT32 entries;
 
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
        
    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    /* Retrieve the odu struct handle, channel ID & framer ID */
    odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);

    if (ODU_STRUCT_FRM_STGN == frm_id || ODU_STRUCT_FRM_STG1 == frm_id)
    {
        num_element = DIGI_NUM_HO_ODU_CHNL_MAX;
    } 
    else 
    {
        num_element = DIGI_NUM_LO_ODU_CHNL_MAX;
    }

    PMC_MEMSET(cal_entries_per_ch, 0, sizeof(cal_entries_per_ch));

    PMC_LOG_TRACE("ri_rcp: ch = %d frm_id = %d resize = %d\n", ch_id,frm_id,resize);

    /*
     *  cal_entries - stores the calendar entries for one ch
     *  cal_entries_per_ch - stores the number of cal entries for each ch
     */
    for (i = 0; i < num_element && PMC_SUCCESS == rc; i++)
    {
        rc = digi_otn_cal_entries_get(digi_handle,
                                  TRUE, /* RX_DB=TRUE */
                                  i,
                                  frm_id,
                                  cal_entries, &num_cal_entries);
        cal_entries_per_ch[i] = num_cal_entries;
    } 
   
    if (rc == PMC_SUCCESS)
    {
        if (resize > 0)
        {
            /* Ramping up - rcp resized before data path */
            entries = (INT32)cal_entries_per_ch[ch_id] + resize;
        }
        else
        {
            UINT32 val = 0;

            /* Ramping down - datapath resized first */
            entries = (INT32)cal_entries_per_ch[ch_id];
            if( i < ( sizeof(cal_entries_per_ch)/sizeof(cal_entries_per_ch[0]) ) )
            {
                val = cal_entries_per_ch[i];
            }
            PMC_ASSERT(entries > 0, DIGI_ERR_INVALID_ARG,resize,val);
        }
        if (entries <= 0)
        {
            PMC_LOG_TRACE("ri_rcp: resize ch = %d frm_id = %d resize = %d not enough cal entries = %d\n", ch_id,frm_id,resize,entries);
            rc = DIGI_ERR_INVALID_ARG; 
        }
    }
    if (rc == PMC_SUCCESS)
    {
        cal_entries_per_ch[ch_id] = (UINT32)entries; 
        rc = odu_struct_ri_rcp_resize(digi_handle->coreotn_handle,
                                          odu_struct_ptr,
                                          cal_entries_per_ch);
    }
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_odu_ri_rcp_resize */

/*******************************************************************************
* digi_otn_odu_ri_rcp_aps_pcc_mon_level_cfg
* ______________________________________________________________________________
* 
* DESCRIPTION: 
*   Configures the APS/PCC connection monitoring for an ODU framer channel. This function 
*   shall be called on a channel where the DI RCP extraction has been already enabled using 
*   digi_otn_odu_ri_rcp_extract_cfg. 
*   
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle (digi_otn_odu_chnl_t) 
*                         for framers 1, 2, 3A or 3B or a mapper channel 
*                         handle (digi_mapper_chnl_t) for framer 4.
*                         The digi_otn_odu_chnl_t handle is provisioned by the 
*                         digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                         functions. The mapper channel handle is provisioned
*                         by the digi_otn_mapper_prov function. The 3B framer
*                         handle is retrieved by calling 
*                         digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                         channel handle as a parameter.
*   aps_pcc_mon_level   - The APS/PCC connection monitoring level  (0 to 7)
*   
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_ri_rcp_aps_pcc_mon_level_cfg( digi_handle_t *digi_handle,
                                                            digi_otn_odu_chnl_t *chnl_ptr,
                                                            UINT8 aps_pcc_mon_level)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    odu_struct_t* odu_struct_ptr;    
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id;
 
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
        
    /* Retrieve the odu struct handle, channel ID & framer ID */
    odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);

    rc = odu_struct_ri_rcp_aps_pcc_mon_level_cfg(digi_handle->coreotn_handle,
                                                 odu_struct_ptr,
                                                 aps_pcc_mon_level);
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_odu_ri_rcp_aps_pcc_mon_level_cfg */

/*******************************************************************************
* digi_otn_odu_ri_rcp_dest_get
* ______________________________________________________________________________
* 
* DESCRIPTION:
*  This function provides the RI_RCP destination configuration of a specified \n
*  ODU framer channel
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle (digi_otn_odu_chnl_t) 
*                         for framers 1, 2, 3A or 3B or a mapper channel 
*                         handle (digi_mapper_chnl_t) for framer 4.
*                         The digi_otn_odu_chnl_t handle is provisioned by the 
*                         digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                         functions. The mapper channel handle is provisioned
*                         by the digi_otn_mapper_prov function. The 3B framer
*                         handle is retrieved by calling 
*                         digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                         channel handle as a parameter.
*   
* OUTPUTS:
*   *ri_rcp_dst_cfg_ptr   - pointer to ODU RI RCP destination configuration
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_ri_rcp_dest_get( digi_handle_t *digi_handle,
                                               digi_otn_odu_chnl_t *chnl_ptr,
                                               digi_otn_odu_ri_rcp_dst_cfg_t *ri_rcp_dst_cfg_ptr)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    odu_struct_t* odu_struct_ptr;    
    UINT32 ch_id;
    odu_struct_frm_id_t frm_id;  
    
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    /* Retrieve the odu struct handle, channel ID & framer ID */
    odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);
    
    rc = odu_struct_ri_rcp_dest_get(digi_handle->coreotn_handle,
                                        odu_struct_ptr, 
                                        ri_rcp_dst_cfg_ptr);

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_odu_ri_rcp_dest_get */

/*******************************************************************************
* digi_otn_otu_fec_stat_intf_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function initializes 4-wire OTN FEC statistics interface. This function \n
*  shall be called before enabling collection of FEC statistics on a specific \n
*  stream.  digi_otn_otu_fec_stat_set can be used to enable statistic \n
*  collection and digi_otn_otu_fec_stat_intf_uninit is provided to disable the\n
*  interface.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *fec_stat_intf_cfg_ptr - pointer to FEC stat interface configuration
*
* OUTPUTS:
*  None
*
* RETURNS:
*   PMC_SUCCESS           - when API execution is successful otherwise a 
*                           descriptive error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_fec_stat_intf_init(digi_handle_t *digi_handle,
                                                 digi_fec_stat_intf_cfg_t *fec_stat_intf_cfg_ptr)
{
    
    PMC_ERROR   rc = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != fec_stat_intf_cfg_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* if this is the first time Lineotn is provisioned - change energy state */
    digi_lineotn_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RUNNING);
    
    rc = lineotn_fec_stat_intf_init(digi_handle->lineotn_handle,fec_stat_intf_cfg_ptr);
    
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_fec_stat_intf_init */


/*******************************************************************************
* digi_otn_otu_fec_stat_intf_uninit
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   The function disables the 4-wire OTN FEC statistics interface.
*
* INPUTS:
*   *digi_handle          - pointer to DIGI handle instance
*
* OUTPUTS:
*  None
*
* RETURNS:
*   PMC_SUCCESS           - when API execution is successful otherwise a 
*                           descriptive error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_fec_stat_intf_uninit(digi_handle_t *digi_handle)
{
    PMC_ERROR   rc = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that lineotn energy state  */
    rc = lineotn_fec_stat_intf_uninit(digi_handle->lineotn_handle);
    
    /* determine state of the LINEOTN SS and if no resources provisioned bring SS to lowpwr/reset state */
    if(PMC_SUCCESS==rc)
    {
        digi_lineotn_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_fec_stat_intf_uninit */

/*******************************************************************************
* digi_otn_otu_fec_stat_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function enables/disables a statistic collection on the 4-wire OTN FEC\n
*   statistics interface for a specified stream. This information sent on \n
*   this interface is intended to be used an off-chip CPLD/FPGA for calibration\n
*   purpose.
*   This functionality is not supported for stream provisionned:
*      - With RSFEC (G.709) or when FEC is bypassed
*      - On SFIS and SFI5.1 MLD interface 
*   This function validates that the specified stream has the proper \n
*   characteristic. In order to setup FEC statistic, it is required to resolve\n
*   the mapping  between logical lanes and physical lanes. To achieve it, \n
*   status values are read  in proper lane aggregators. Therefore, to successfully\n
*   enable  statistic collection, all RX lanes shall not be in LANE Loss of \n
*   Frame (LOF)
*
* INPUTS:
*   digi_handle     - pointer to digi handle instance.
*   *otn_server_ptr - Pointer to a resource allocation
*                     context for the OTN server configured against the
*                     specified serdes port.
*   enable           - boolean, TRUE: enable statistic collection\n
*                             , FALSE: disable enable statistic collection \n
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS   - when API execution is successful otherwise a 
*   descriptive error is returned.
*
* NOTES:
*   If not all RX lanes are defect free (absense of LOF), then a fixed 1:1 logical-lane
*   to physical lane relationship is established.  If the user desires to re-program
*   the logical-lane to physical lane relationship, they must first disable FEC statistic
*   collection and then re-enable it.

*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_fec_stat_set(digi_handle_t           *digi_handle,
                                           digi_otn_server_chnl_t  *otn_server_ptr,
                                           BOOL8 enable)
{
    digi_otn_server_chnl_def_t *otn_srvr_ptr;
    PMC_ERROR   rc = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, otn_server_ptr, rc, TRUE);
    otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    rc = lineotn_fec_stat_set(digi_handle->lineotn_handle,otn_srvr_ptr->dsi_base_chnl,enable);
    
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_otu_fec_stat_set */
  
/*******************************************************************************
* digi_otn_odu_bdi_bei_biae_insert_cfg
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   For REV A devices, calling this API with 'source' == 0 or 1 will impact the 
*   insertion source of BDI/BEI/BIAE for all channels to be changed.
*
*   Configures the source of BDI/BEI bits in the TX framer of a specified \n
*   channel. Options are:
*             - Local Rx Framer
*             - RI_RCP interface
*             - Force values at Tx Framer
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr        -pointer to ODU framer channel handle (digi_otn_odu_chnl_t) 
*                     for framers 1, 2, 3A or 3B or a mapper channel 
*                     handle (digi_mapper_chnl_t) for framer 4.
*                     The digi_otn_odu_chnl_t handle is provisioned by the 
*                     digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                     functions. The mapper channel handle is provisioned
*                     by the digi_otn_mapper_prov function. The 3B framer
*                     handle is retrieved by calling 
*                     digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                     channel handle as a parameter.
*   source          - Transmit BDI/BEI bits source: \n 
*                      0 : Local Rx Framer 
*                      1 : RI_RPC \n 
*                      2 : Force value at TX framer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_bdi_bei_biae_insert_cfg(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      UINT8 source)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    odu_struct_t* odu_struct_ptr;
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id;
    UINT32 cal_entries[DIGI_SCHD_96_ENTRY];
    UINT32 num_cal_entries;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if(source != 0 && source != 1 && source != 2){
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);
    }

    /* Retrieve the odu struct handle, channel ID & framer ID */
    odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);

    /* Determine the # of calendar entries */
    rc = digi_otn_cal_entries_get(digi_handle,
                                  FALSE, /* RX_DB=FALSE */
                                  ch_id,
                                  frm_id,
                                  cal_entries, &num_cal_entries);
    if (PMC_SUCCESS == rc)
    {    
          rc = odu_struct_bdi_bei_biae_insert_cfg(digi_handle->coreotn_handle,
                                                  odu_struct_ptr,                                            
                                                  num_cal_entries,
                                                  source);
    }


    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_odu_bdi_bei_biae_insert_cfg */


/*******************************************************************************
* digi_otn_odu_bdi_bei_biae_status_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   For REV A devices, calling this API to get insertion source of BDI/BEI/BIAE for all channels to be changed.
*
*   Get Configured source of BDI/BEI bits in the TX framer of a specified \n
*   channel. Options are:
*             - Local Rx Framer
*             - RI_RCP interface
*             - Force values at Tx Framer
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr        -pointer to ODU framer channel handle (digi_otn_odu_chnl_t) 
*                     for framers 1, 2, 3A or 3B or a mapper channel 
*                     handle (digi_mapper_chnl_t) for framer 4.
*                     The digi_otn_odu_chnl_t handle is provisioned by the 
*                     digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                     functions. The mapper channel handle is provisioned
*                     by the digi_otn_mapper_prov function. The 3B framer
*                     handle is retrieved by calling 
*                     digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                     channel handle as a parameter.

*
* OUTPUTS:
*   source          - Transmit BDI/BEI bits source: \n 
*                      0 : Local Rx Framer 
*                      1 : RI_RPC \n 
*                      2 : Force value at TX framer
*
* RETURNS:
*   PMC_SUCCESS when operation is successful otherwise a descriptive error 
*   code is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_bdi_bei_biae_status_get(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      UINT8 *source)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    odu_struct_t* odu_struct_ptr;
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    /* Retrieve the odu struct handle, channel ID & framer ID */
    odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);

    if (NULL != odu_struct_ptr)
    {
    odu_struct_bdi_bei_biae_status_get(digi_handle->coreotn_handle,
                                                  odu_struct_ptr,       
                                                  source);
    }
    else
    {
        rc = DIGI_ERR_INVALID_ARG;
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);

}/* digi_otn_odu_bdi_bei_biae_status_get */



/*******************************************************************************
* digi_otn_odu_ri_rcp_aps_insert_cfg
* ______________________________________________________________________________
* 
* DESCRIPTION: 
*   Configures the APS/PCC bytes  insertion for an ODU framer channel from the \n
*   RI RCP port. The insertion monitoring level is taken from the RI_RCP PDU \n
*   received on the port. 
* 
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle (digi_otn_odu_chnl_t) 
*                         for framers 1, 2, 3A or 3B or a mapper channel 
*                         handle (digi_mapper_chnl_t) for framer 4.
*                         The digi_otn_odu_chnl_t handle is provisioned by the 
*                         digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                         functions. The mapper channel handle is provisioned
*                         by the digi_otn_mapper_prov function. The 3B framer
*                         handle is retrieved by calling 
*                         digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                         channel handle as a parameter. 
*   source              - APS/PCC bytes source: \n 
*                         TRUE: RI_RPC \n 
*                         FALSE: non-selected 
*                                                                         
*    
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_ri_rcp_aps_insert_cfg( digi_handle_t *digi_handle,
                                                     digi_otn_odu_chnl_t *chnl_ptr,                                                     
                                                     BOOL8 source)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    odu_struct_t* odu_struct_ptr;
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id;
    UINT32 cal_entries[DIGI_SCHD_96_ENTRY];
    UINT32 num_cal_entries;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    /* Retrieve the odu struct handle, channel ID & framer ID */
    odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);
    
    /* APS insertion requires that OHP be enabled (it doesn't have to be configured) */
    rc = coreotn_ohp_cfg(digi_handle->coreotn_handle, TRUE);
    
    /* Determine the # of calendar entries */
    if (PMC_SUCCESS == rc)
    {
        rc = digi_otn_cal_entries_get(digi_handle,
                                      FALSE, /* RX_DB=FALSE */
                                      ch_id,
                                      frm_id,
                                      cal_entries, &num_cal_entries);
    }
        
    if (rc == PMC_SUCCESS)
    {
        rc = odu_struct_ri_rcp_aps_insert_cfg(digi_handle->coreotn_handle,
                                              odu_struct_ptr,  
                                              num_cal_entries,
                                              source);        
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_odu_ri_rcp_aps_insert_cfg */

/*******************************************************************************
* digi_otn_odu_ri_rcp_aps_insert_cfg_get
* ______________________________________________________________________________
* 
* DESCRIPTION: 
*   Gets the APS/PCC bytes insertion enable status for an ODU framer channel from the \n
*   RI RCP port. The insertion monitoring level is taken from the RI_RCP PDU \n
*   received on the port. 
* 
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle (digi_otn_odu_chnl_t) 
*                         for framers 1, 2, 3A or 3B or a mapper channel 
*                         handle (digi_mapper_chnl_t) for framer 4.
*                         The digi_otn_odu_chnl_t handle is provisioned by the 
*                         digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                         functions. The mapper channel handle is provisioned
*                         by the digi_otn_mapper_prov function. The 3B framer
*                         handle is retrieved by calling 
*                         digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                         channel handle as a parameter. 
*
*
* OUTPUTS:
*   source              - APS/PCC bytes source: \n 
*                         TRUE: RI_RPC \n 
*                         FALSE: non-selected 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_ri_rcp_aps_insert_cfg_get( digi_handle_t *digi_handle,
                                                        digi_otn_odu_chnl_t *chnl_ptr,                                                     
                                                        BOOL8 *source)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    odu_struct_t* odu_struct_ptr;
    odu_struct_frm_id_t frm_id;
    UINT32 ch_id;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != source, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check that user switch handle belongs to digi context */
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    /* Retrieve the odu struct handle, channel ID & framer ID */
    odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);

    if (rc == PMC_SUCCESS)
    {
        rc = odu_struct_ri_rcp_aps_insert_en_get(digi_handle->coreotn_handle,
                                                 odu_struct_ptr,
                                                 source);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_odu_ri_rcp_aps_insert_cfg_get */

/*******************************************************************************
* digi_di_rcp_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function performs Defects Information Ring Control Port bring up of the \n
*  DIGI device. That includes the initialization of the:
*    - SGMII Ethernet subsystem
*    - 1GB serdes (D8)
*    - The Defects Information ODU Ring Control Port 
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *digi_di_rcp_cfg_ptr   - pointer to DI RCP configuration
*
* OUTPUTS:
*  None
*
* RETURNS:
*   PMC_SUCCESS           - when API execution is successful otherwise a 
*                           descriptive error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_di_rcp_init(digi_handle_t    *digi_handle,
                                  odu_di_rcp_cfg_t *digi_di_rcp_cfg_ptr)
{
    PMC_ERROR   rc = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_di_rcp_cfg_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check that DIGI device is initialized */
    if (FALSE == digi_device_init_status_get(digi_handle))
    {
        rc = DIGI_ERR_DEVICE_NOT_INIT;
    }

    /* check if you have proper dDeg pre-requistes */
    if (DIGI_OTN_HARDWARE_DDEG != digi_handle->var.linesys_ddeg_mode)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_ODU_RCP_DI_HW_DDEG_ONLY);
    }

    /* enable D8 serdes instance */
    if (PMC_SUCCESS == rc)
    {
        rc = digi_serdes_ge_port_internal_prov(digi_handle,DIGI_SERDES_INTF_DI_RCP);
    }
    
    if (PMC_SUCCESS == rc)
    {
        /* Initialize DI RCP port */
        rc = coreotn_odu_rcp_init(digi_handle->coreotn_handle,
                                  ODU_RCP_DI_INST,
                                  (odu_rcp_init_cfg_t*) digi_di_rcp_cfg_ptr);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_di_rcp_init */

/*******************************************************************************
* digi_di_rcp_uninit
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The function disables the Defects Information Ring Control Port
*
* INPUTS:
*   *digi_handle          - pointer to DIGI handle instance
*
* OUTPUTS:
*  None
*
* RETURNS:
*   PMC_SUCCESS           - when API execution is successful otherwise a 
*                           descriptive error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_di_rcp_uninit(digi_handle_t *digi_handle)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    UINT32 pdu_msk;
    UINT16 sdh_cnt_sel_dummy;
    digi_di_rcp_pmon_cfg_t config;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that DIGI device is initialized */
    if (FALSE == digi_device_init_status_get(digi_handle))
    {
        rc = DIGI_ERR_DEVICE_NOT_INIT;
    }

    PMC_MEMSET((void *)&config, 0, sizeof(digi_di_rcp_pmon_cfg_t));

    /* disable dLOOMFI defect to DI_RCP*/
    if (PMC_SUCCESS == rc) {
        /* When disabling dLOOMFI, either LINEOTN or SYSOTN can be used as defect source.
           FW will disable dLOOMFI transfer regardless of defect source*/
        rc = digi_fw_coreotn_cfg_dloomfi_mon(digi_handle, FALSE, HOSTMSG_OTN_SERVER_SRC_LINE);
    }
    
    /* disable D8 serdes instance */
    if (PMC_SUCCESS == rc)
    {
        rc = digi_serdes_ge_port_internal_deprov(digi_handle,DIGI_SERDES_INTF_DI_RCP);
    }

    if (PMC_SUCCESS == rc)
    {
        /* Ininitialize RCP port */
        rc = coreotn_odu_rcp_uninit(digi_handle->coreotn_handle,
                                    ODU_RCP_DI_INST);
        
        if( PMC_SUCCESS == rc)
        {   
            /* shutoff PMON RCP transfer */
            odu_struct_odu_rcp_di_pdu_msk_get(digi_handle->coreotn_handle, &pdu_msk, &sdh_cnt_sel_dummy); 

            if (TRUE == digi_di_rcp_pmon_is_selected(pdu_msk))
            {
                config.enable = FALSE;
                config.sdh_cnt_sel = 0x0;
                config.no_cbrc_count = FALSE;   
                digi_di_rcp_fw_pmon_cfg(digi_handle, config);
            }
        }
    }
    
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_di_rcp_uninit */

/*******************************************************************************
* digi_di_rcp_init_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function gets Defects Information Ring Control Port status, inited or not.
*
* INPUTS:
*   *digi_handle          - pointer to DIGI handle instance           -
*
* OUTPUTS:
*   *digi_di_rcp_cfg_ptr  - pointer to DI RCP configuration 
*   enable                - DI RCP enabled(when inited) or disabled(when uninited)
*
* RETURNS:
*   PMC_SUCCESS           - when API execution is successful otherwise a 
*                           descriptive error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_di_rcp_init_get(digi_handle_t *digi_handle,
                                      odu_di_rcp_cfg_t *digi_di_rcp_cfg_ptr,
                                      BOOL *enable)
{
    PMC_ERROR   rc = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that DIGI device is initialized */
    if (FALSE == digi_device_init_status_get(digi_handle))
    {
        rc = DIGI_ERR_DEVICE_NOT_INIT;
    }

    /* check if you have proper dDeg pre-requistes */
    if (DIGI_OTN_HARDWARE_DDEG != digi_handle->var.linesys_ddeg_mode)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_ODU_RCP_DI_HW_DDEG_ONLY);
    }

    if (PMC_SUCCESS == rc)
    {
        /* Initialize DI RCP port */
        rc = coreotn_odu_rcp_init_get(digi_handle->coreotn_handle,
                                      ODU_RCP_DI_INST,
                                      (odu_rcp_init_cfg_t*)digi_di_rcp_cfg_ptr,
                                      enable);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_di_rcp_init_get */

/*******************************************************************************
* digi_di_rcp_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures Defect Information (DI) Ring Control Port (RCP) PDU transmission.
*
*   Function digi_di_rcp_sdh_counters_cfg should be called to configure SONET/SDH
*   B1, B2 and M0_M1 counts.
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*    di_rcp_pdu        - the DI RCP PDUs to enable or disable. Use digi_di_rcp_pdu_t bit masks
*                        to define which PDUs you want to enable by or-ing  masks. 
*                        Bit mask possible values are:
*                           DIGI_DI_RCP_CHNL_LINE_OTU_HO_ODUK                   > Line Side OTU + Channel based HO ODUk                     
*                           DIGI_DI_RCP_CHNL_SYS_OTU_HO_ODUK                    > System Side OTU + Channel based HO ODUk                   
*                           DIGI_DI_RCP_CHNL_PMON_HO_ODUK_RX_FRAMER_STG1        > Channel based HO ODUk Rx Framer Stage 1 (NEBC & FEBC)     
*                           DIGI_DI_RCP_CHNL_PMON_HO_ODUK_RX_FRAMER_STGN        > Channel based HO ODUk Rx Framer Stage N (NEBC & FEBC)     
*                           DIGI_DI_RCP_POOL_DEFECTS_HO_ODUK_RX_FRAMER_STG1     > Pool based HO ODUk Rx Framer Stage 1                      
*                           DIGI_DI_RCP_POOL_DEFECTS_HO_ODUK_RX_FRAMER_STGN     > Pool based HO ODUk Rx Framer Stage N                      
*                           DIGI_DI_RCP_POOL_PMON_HO_ODUK_RX_FRAMER_STG1        > Pool based HO ODUk Rx Framer Stage 1 (NEBC & FEBC)        
*                           DIGI_DI_RCP_POOL_PMON_HO_ODUK_RX_FRAMER_STGN        > Pool based HO ODUk Rx Framer Stage N (NEBC & FEBC)        
*                           DIGI_DI_RCP_CHNL_DEFECTS_ODUK_RX_FRAMER_STG2        > Channel based ODUk Rx Framer Stage 2                      
*                           DIGI_DI_RCP_CHNL_DEFECTS_ODUK_RX_FRAMER_STG3A       > Channel based ODUk Rx Framer Stage 3a                     
*                           DIGI_DI_RCP_CHNL_DEFECTS_ODUK_RX_FRAMER_STG3B       > Channel based ODUk Rx Framer Stage 3b                     
*                           DIGI_DI_RCP_CHNL_DEFECTS_ODUK_RX_FRAMER_STG4        > Channel based ODUk Rx Framer Stage 4                      
*                           DIGI_DI_RCP_CHNL_PMON_ODUK_RX_FRAMER_STG2           > Channel based ODUk Rx Framer Stage 2 (NEBC & FEBC)        
*                           DIGI_DI_RCP_CHNL_PMON_ODUK_RX_FRAMER_STG3A          > Channel based ODUk Rx Framer Stage 3a (NEBC & FEBC)       
*                           DIGI_DI_RCP_CHNL_PMON_ODUK_RX_FRAMER_STG3B          > Channel based ODUk Rx Framer Stage 3b (NEBC & FEBC)       
*                           DIGI_DI_RCP_CHNL_PMON_ODUK_RX_FRAMER_STG4           > Channel based ODUk Rx Framer Stage 4 (NEBC & FEBC)        
*                           DIGI_DI_RCP_POOL_DEFECTS_ODUK_RX_FRAMER_STG2        > Pool based ODUk Rx Framer Stage 2                         
*                           DIGI_DI_RCP_POOL_DEFECTS_ODUK_RX_FRAMER_STG3A       > Pool based ODUk Rx Framer Stage 3a                        
*                           DIGI_DI_RCP_POOL_DEFECTS_ODUK_RX_FRAMER_STG3B       > Pool based ODUk Rx Framer Stage 3b                        
*                           DIGI_DI_RCP_POOL_DEFECTS_ODUK_RX_FRAMER_STG4        > Pool based ODUk Rx Framer Stage 4                         
*                           DIGI_DI_RCP_POOL_PMON_ODUK_RX_FRAMER_STG2           > Pool based ODUk Rx Framer Stage 2 (NEBC & FEBC)           
*                           DIGI_DI_RCP_POOL_PMON_ODUK_RX_FRAMER_STG3A          > Pool based ODUk Rx Framer Stage 3a (NEBC & FEBC)          
*                           DIGI_DI_RCP_POOL_PMON_ODUK_RX_FRAMER_STG3B          > Pool based ODUk Rx Framer Stage 3b (NEBC & FEBC)          
*                           DIGI_DI_RCP_POOL_PMON_ODUK_RX_FRAMER_STG4           > Pool based ODUk Rx Framer Stage 4 (NEBC & FEBC)           
*                           DIGI_DI_RCP_GFPF                                    > GFP-F                                                     
*                           DIGI_DI_RCP_CLIENT                                  > Clients (ENET, SDH, FC1200, FC800, PRBS)                  
*                           DIGI_DI_RCP_SDH                                     > SDH B1 & B2 & M0/M1                                       
*                           DIGI_DI_RCP_PRBS_NTSE                               > PRBS nTSE                                                 
*                           DIGI_DI_RCP_ALL                                     > All PMON and all defects
*                         
*                        EX:   The following call enabled GFP-F and RCP clients PDUs transmission
*                                digi_di_rcp_cfg(digi_handle, DIGI_DI_RCP_GFPF | DIGI_DI_RCP_CLIENT, TRUE)
*                              
*                              You can also start form all and disable some PDUs.
*                        EX:   The following call disables all PDU transmission except RCP clients PDU one:
*                                digi_di_rcp_cfg(digi_handle, DIGI_DI_RCP_ALL ^  DIGI_DI_RCP_CLIENT, FALSE)
*   enable             - TRUE to enable transfer; FALSE to disable it
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS when operation is successful otherwise a descriptive error 
*   code is returned. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_di_rcp_cfg(digi_handle_t           *digi_handle,  
                                 UINT32                   di_rcp_pdu,
                                 BOOL8                    enable)
{
    
    PMC_ERROR rc = PMC_SUCCESS;    
    UINT32 pdu_msk;    UINT16 sdh_cnt_sel;
    hostmsg_otn_server_src_t dloomfi_defect_src;
    digi_di_rcp_pmon_cfg_t config, *config_ptr = &config;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_MEMSET(config_ptr, 0, sizeof(digi_di_rcp_pmon_cfg_t));
    if (PMC_SUCCESS == rc)
    {
        /* save PDU mask to determine if current operation concerns a PMON PDU */
        odu_struct_odu_rcp_di_pdu_msk_get(digi_handle->coreotn_handle, &pdu_msk, &sdh_cnt_sel);     
        
        /* call low layer function */    
        rc  = odu_struct_odu_di_rcp_cfg(digi_handle->coreotn_handle, di_rcp_pdu, enable);
        
        /* configure FW RCP PMON when operation concerned a PMON PDU */
        if (PMC_SUCCESS == rc)
        {
            odu_struct_odu_rcp_di_pdu_msk_get(digi_handle->coreotn_handle, &pdu_msk, &sdh_cnt_sel);            
            config.enable = enable;
            config.sdh_cnt_sel = sdh_cnt_sel;
            config.no_cbrc_count = FALSE;
            rc = digi_di_rcp_fw_pmon_cfg(digi_handle, config);   
        }
    }

    /* Configure FW to enable/disable dLOOMFI defect transfer to DI_RCP*/
    if (PMC_SUCCESS == rc)
    {
        if (DIGI_PROD_APP_SYSOTN_CARD == digi_handle->var.prod_app)
        {
            /* dLOOMFI defect source is SYSOTN and FMF2 Demux should be read*/
            dloomfi_defect_src = HOSTMSG_OTN_SERVER_SRC_SYS;

            /* Determine rate, dLOOMFI defect is only available at rate OTU4*/
            if ((UINT8)UTIL_GLOBAL_ODU4 == digi_handle->handle_pool.sysotn_server_chnl.oduk_type)
            {
                rc = digi_fw_coreotn_cfg_dloomfi_mon(digi_handle, enable, dloomfi_defect_src);
            }

        } else {
            /* dLOOMFI defect source is LINEOTN and FMF1 Demux should be read*/
            dloomfi_defect_src = HOSTMSG_OTN_SERVER_SRC_LINE;

            /* Determine rate, dLOOMFI defect is only available at rate OTU4*/
            if ((UINT8)UTIL_GLOBAL_ODU4 == digi_handle->handle_pool.otn_server_chnl[0].oduk_type)
            {
                rc = digi_fw_coreotn_cfg_dloomfi_mon(digi_handle, enable, dloomfi_defect_src);                   
            }     
        }
    }


    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_di_rcp_cfg */

/*******************************************************************************
* digi_di_rcp_sdh_counts_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures Ring Control Port (RCP) SONET/SDH (B1, B2) and OTN (NEBC & FEBC) 
*   counts in PDU transmission.
*
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   enable             - TRUE to enable transfer; FALSE to disable it
*   sdh_cnt_sel        - SDH counts select mask for channels 0 to 11. 
*                        when channel bit is 0 -> ingress count is selected
*                        when channel bit is 1 -> egress count is selected
*                        sdh_cnt_sel is ignored when PDU transmission is disabled 
*                        (enable == FALSE) and also ignored if no_sdh_counts == TRUE.
*   no_sdh_counts      - TRUE to stop SDH counts being sent to RCP port; counts are
*                        available through PMON.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS when operation is successful otherwise a descriptive error 
*   code is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_di_rcp_sdh_counts_cfg(digi_handle_t        *digi_handle, 
                                            BOOL8                 enable,
                                            UINT16                sdh_cnt_sel,
                                            BOOL8                 no_sdh_counts)
{
    
    PMC_ERROR rc = PMC_SUCCESS;    
    UINT32 pdu_msk;
    UINT16 sdh_cnt_sel_prev;
    BOOL8 is_pmon_selected_before;
    digi_di_rcp_pmon_cfg_t config;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_MEMSET((void *)&config, 0, sizeof(digi_di_rcp_pmon_cfg_t));

    /* check that SGH channels are valid */    
    if (TRUE == enable && 0 != (0xF000 & sdh_cnt_sel))
    {
        rc = DIGI_ERR_INVALID_ARG;
    }

    if (PMC_SUCCESS == rc)
    {
        /* save PDU mask to determine if current operation concerns a PMON PDU */
        odu_struct_odu_rcp_di_pdu_msk_get(digi_handle->coreotn_handle,
                                          &pdu_msk, &sdh_cnt_sel_prev);
        pdu_msk &= DIGI_DI_RCP_SDH;
        is_pmon_selected_before = digi_di_rcp_pmon_is_selected(pdu_msk);
        
        /* call low layer function */    
        rc  = odu_struct_odu_di_rcp_cfg(digi_handle->coreotn_handle, DIGI_DI_RCP_SDH, enable);
        
        /* configure FW RCP PMON when operation concerned a PMON PDU */
        if (PMC_SUCCESS == rc)
        {
            odu_struct_odu_rcp_di_pdu_msk_get(digi_handle->coreotn_handle,
                                              &pdu_msk, &sdh_cnt_sel_prev);
            pdu_msk &= DIGI_DI_RCP_SDH;
            
            if ((FALSE == is_pmon_selected_before &&
                 TRUE == digi_di_rcp_pmon_is_selected(pdu_msk) && 
                 TRUE == enable)
                ||
                (TRUE == enable && sdh_cnt_sel != sdh_cnt_sel_prev)
                ||
                (TRUE == is_pmon_selected_before &&
                 FALSE == digi_di_rcp_pmon_is_selected(pdu_msk) && 
                 FALSE == enable))
            {
                config.enable = enable;
                config.sdh_cnt_sel = sdh_cnt_sel;
                config.no_cbrc_count = no_sdh_counts;
                rc = digi_di_rcp_fw_pmon_cfg(digi_handle, config);         
            }
            if (PMC_SUCCESS == rc)
            {
                odu_struct_odu_rcp_di_sdh_cnt_sel_set(digi_handle->coreotn_handle, sdh_cnt_sel);
            }
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_di_rcp_sdh_counts_cfg */


/*******************************************************************************
* digi_di_rcp_otn_counts_cfg 
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures OTN PMON count retrieval through RCP port. Can be used to disable
*   OTN PMON count retrieval; by default OTN PMON count retrieval is enabled. 
*
*   digi_di_rcp_cfg() must be called prior to calling this function. 
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   no_otn_counts      - TRUE to stop OTN counts being sent to RCP port; counts are
*                        available through PMON.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS when operation is successful otherwise a descriptive error 
*   code is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_di_rcp_otn_counts_cfg(digi_handle_t *digi_handle, BOOL no_otn_counts)
{
    PMC_ERROR rc = PMC_SUCCESS;
    digi_di_rcp_pmon_cfg_t config, *config_ptr = &config;

    PMC_ATOMIC_ENTRY(digi_handle);
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_MEMSET(config_ptr, 0, sizeof(digi_di_rcp_pmon_cfg_t));

    config.enable = TRUE;
    config.sdh_cnt_sel = 0;
    config.no_cbrc_count = 0;
    config.no_otn_count = no_otn_counts;
    rc = digi_di_rcp_fw_pmon_cfg(digi_handle, config);         

    PMC_ATOMIC_RETURN(digi_handle,rc); 
} /* digi_di_rcp_otn_counts_cfg */

/*******************************************************************************
* digi_otn_ohp_init
* ______________________________________________________________________________
*
* DESCRIPTION:  
*   There are three ODU Overhead processors (OHPs). Each OHP contains two 
*   ports (port A and port B) which can connect to two different framers.
*   The first OHP (ODU_OHP_1) supports 12 channels and has a fixed 
*   connection to the stage 1 (HO) framer (PORT A) and the Stage N framer (PORT B). 
*   The second and third OHPs can be configured to connect to framer 2 (MO), 
*   framer 3A (LO), framer 3B (LO) or framer 4.\n\n
*
*   This function initializes a single OHP. The function should be called once
*   for each OHP that is needed. The configuration of each OHP is specified 
*   in a odu_ohp_cfg_t structure which has the following fields:\n
*   \code
*       ohp                 - Specifies which OHP (ODU_OHP_1, 
*                             ODU_OHP_2 or ODU_OHP_3) 
*       port_a_framer       - Port A framer connection 
*       port_a_src_addr     - Port A Source user ID (32 bits). 
*       port_a_dest_addr    - Port A Destination user id (32 bits) 
*       port_b_framer       - Port B framer connection
*       port_b_src_addr     - Port B Source user ID (32 bits). 
*       port_b_dest_addr    - Port B Destination user id (32 bits) 
*  \endcode
*  
*   If a port is unused, the value should be set to ODU_OHP_PORT_UNUSED. The OHP1 
*   port_a_framer value must either be ODU_OHP_PORT_FRAMER_1 or ODU_OHP_PORT_UNUSED.
*   The OHP1 port_b_framer value must either be ODU_OHP_PORT_FRAMER_N or 
*   ODU_OHP_UNUSED.\n\n
*
*   The ethernet source and destination addresses will consist of:\n
*   \code 
*       -32 bit source user ID
*       -32 bit dest user ID
*       -8 bit framer ID
*       -8 bit channel id.
*   \endcode 
*
*   
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance
*
*   *cfg_ptr                - DIGI OHP configuration
*
* OUTPUTS:
*
* RETURNS:
*   PMC_ERROR               - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_ohp_init(digi_handle_t *digi_handle,
                                   odu_ohp_cfg_t *cfg_ptr)
{
    
    PMC_ERROR rc = PMC_SUCCESS;
    digi_ge_serdes_id_t ge_intf;

    PMC_ATOMIC_ENTRY(digi_handle);
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != cfg_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(cfg_ptr->ohp >= ODU_OHP_1 && cfg_ptr->ohp <= ODU_OHP_3, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(cfg_ptr->port_a_framer < ODU_OHP_PORT_FRAMER_LAST, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(cfg_ptr->port_b_framer < ODU_OHP_PORT_FRAMER_LAST, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE,0 , 0);
    
    /* check that DIGI device is initialized */
    if (FALSE == digi_device_init_status_get(digi_handle))
    {
        rc = DIGI_ERR_DEVICE_NOT_INIT;
    }

    digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_RUNNING,COREOTN_ODU_IF);

    switch(cfg_ptr->ohp)
    {
        case ODU_OHP_1: 
            ge_intf = DIGI_SERDES_INTF_OHP_0; 
            break;
        case ODU_OHP_2: 
            ge_intf = DIGI_SERDES_INTF_OHP_1; 
            break;
        case ODU_OHP_3: 
            ge_intf = DIGI_SERDES_INTF_OHP_2; 
            break;
        default:
            PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);
    }

    if (PMC_SUCCESS == rc)
    {
        /* Initialize D8 serdes instance */
         rc = digi_serdes_ge_port_internal_prov(digi_handle,ge_intf); 
    }

    if (PMC_SUCCESS == rc)
    {
        rc = coreotn_ohp_init(digi_handle->coreotn_handle,cfg_ptr);

        if (PMC_SUCCESS == rc)
        {

            (void)digi_fw_coreotn_ohp_en( digi_handle, (UINT8)(cfg_ptr->ohp),
                                          TRUE,
                                          (BOOL8)( (cfg_ptr->port_a_framer) != ODU_OHP_PORT_UNUSED),
                                          (BOOL8)( (cfg_ptr->port_b_framer) != ODU_OHP_PORT_UNUSED)
                                        );
        }
    }
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_ohp_init */

/*******************************************************************************
* digi_otn_ohp_uninit
* ______________________________________________________________________________
*
* DESCRIPTION:  
*   This function resets one OHP. The function should be called once for each 
*   of the three OHPs.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   ohp             - Specifies which OHP block to reset (see odu_ohp_inst_t)
* OUTPUTS:
*
* RETURNS:
*   PMC_ERROR       - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_ohp_uninit(digi_handle_t *digi_handle,
                                     odu_ohp_inst_t ohp)
{
    PMC_ERROR rc;
    digi_ge_serdes_id_t ge_intf;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(ohp >= ODU_OHP_1 && ohp <= ODU_OHP_3, DIGI_ERR_INVALID_ARG,0,0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that DIGI device is initialized */
    if (FALSE == digi_device_init_status_get(digi_handle))
    {
        rc = DIGI_ERR_DEVICE_NOT_INIT;
    }

    switch(ohp)
    {
        case ODU_OHP_1: 
            ge_intf = DIGI_SERDES_INTF_OHP_0; 
            break;
        case ODU_OHP_2: 
            ge_intf = DIGI_SERDES_INTF_OHP_1; 
            break;
        case ODU_OHP_3: 
            ge_intf = DIGI_SERDES_INTF_OHP_2; 
            break;
        default:
            PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);
    }
    
    (void)digi_fw_coreotn_ohp_en( digi_handle, (UINT8)ohp, 
                                          FALSE, FALSE, FALSE );
    
    rc = digi_serdes_ge_port_internal_deprov(digi_handle,ge_intf);
    
    if (PMC_SUCCESS == rc)
    {
        rc = coreotn_ohp_uninit(digi_handle->coreotn_handle,ohp);
    }

    digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_OPTIMAL,COREOTN_ODU_IF);

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_ohp_uninit */

/*******************************************************************************
* digi_otn_ohp_init_get
* ______________________________________________________________________________
*
* DESCRIPTION:  
*   Gets OHP config and init status(inited or uninited)
*   
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance
*   ohp                     - enumeration of the three OHPs
*
* OUTPUTS:
*   cfg_ptr                - Configuration structure for the OHP port.
*                            Its content is invalid when it is uninited.
*   enable                 - TRUE when OHP inited or FALSE when OHP uninited
*
* RETURNS:
*   PMC_ERROR               - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_ohp_init_get(digi_handle_t *digi_handle,
                                       odu_ohp_inst_t ohp,
                                       odu_ohp_cfg_t *cfg_ptr,
                                       BOOL *enable)
{
    
    PMC_ERROR rc = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(ohp >= ODU_OHP_1 && ohp <= ODU_OHP_3, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE,0 , 0);

    /* check that DIGI device is initialized */
    if (FALSE == digi_device_init_status_get(digi_handle))
    {
        rc = DIGI_ERR_DEVICE_NOT_INIT;
    }

    if (PMC_SUCCESS == rc)
    {
        rc = coreotn_ohp_init_get(digi_handle->coreotn_handle,ohp,cfg_ptr,enable);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_ohp_init_get */

/*******************************************************************************
* digi_otn_ohp_ch_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function enables or disables the overhead extraction/insertion 
*   for a particular channel.
*
*   The ODUk overhead data consists of 4 rows of 16 bytes each for a 
*   total of 64 bytes (16 32-bit words).  The OHP can extract all 
*   overhead bytes except the BIP-8 from PM/TCMs and JC1, JC2 and JC3. 
*   OTUk overhead (Row 1, bytes 7-14) are only extracted by stage 1 
*   framers. The OHP can insert all bytes except the BIP-8 bytes 
*   from SM, PM and TCMs. OTUk overhead (Row 1, bytes 1-14) can only 
*   be inserted by stage 1 framers.\n\n
*
*
*   A bit mask is used to indicate which words should be inserted or 
*   extracted. Each bit in the mask indicates whether the corresponding 
*   overhead word (32 bits) should be inserted/extracted. The OHP 
*   supports extracting or inserting a maximum of 10 words. There is a
*   separate mask for insertion (insert_mask) and extraction (extract_mask).\n\n
*
* \code          
*             ODUk Word         ODUk fields
*             ---------     ---------------------
*                 0         {FAS, FAS, FAS, FAS}
*                 1         {FAS, FAS, MFAS, 0x00}
*                 2:        {SM_TTI, SM_BW_INFO, GCC0_0, GCC0_1}
*                 3:        {RES, RES, JC4, 0x00}
*                 4:        {RES, RES, PM&TCM, TCM_ACT}
*                 5:        {0x00, 0x00, 0x00, 0x00}
*                 6:        {TCM6_TTI, TCM6_BW_INFO, TCM5_TTI, TCM5_BW_INFO}
*                 7:        {TCM4_TTI, TCM4_BW_INFO, FTFL, JC5}
*                 8:        {0x00, 0x00, 0x00, 0x00}
*                 9:        {TCM3_TTI, TCM3_BW_INFO, TCM2_TTI, TCM2_BW_INFO}
*                10:        {TCM1_TTI, TCM1_BW_INFO, PM_TTI, PM_BW_INFO}
*                11:        {EXP, EXP, JC6, 0x00}
*                12:        {GCC1_0, GCC1_1, GCC2_0, GCC2_1}
*                13:        {APS, APS, APS, APS, APS}
*                14:        {RES, RES, RES, RES}
*                15:        {RES, RES, PSI, OMFI}
* \endcode
*   To enable extraction/insertion of GCC0_0 and/or GCC0_1, the  
*   digi_otn_otu_oh_ins_cfg function should be called to disable the 
*   over-writing of the two fields.\n\n
*
*   The extraction and insertion ethernet packets include destination 
*   and source addresses. \n
* \code
*   The destination address consists of:
*       -Destination user id (32 bit) 
*       -Framer ID (8 bit) The OHP input port.
*       -Channel ID (8 bit)
*   The source address consists of:
*       -source user id (32 bit)
*       -framer ID (8 bit) The OHP input port.
*       -Channel ID (8 bit)
*  
*  Framer ID is as follows: 
*
*   Framer ID   Framer 
*   ---------  -------
*       0      Framer 1
*       1      Framer 2
*       2      Framer 3A
*       3      Framer 3B
*       4      Framer 4
*       5      Framer N
*
*
* \endcode           
*
*  The destination user id and source user id are configured using the 
*  digi_otn_ohp_init function. \n
*
*  The framer number and channel ID corresponding to a channel handle 
*  can be retrieved using the funtion digi_otn_ohp_channel_framer_num_get.\n
*
* The external data source identifies the individual overhead bytes or 
* masked overhead bytes (ie. *_BW_INFO notated bytes) with TX_INS_ENn 
* fields of the Insertion Port Ethernet Packet.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance
*
*   *chnl_ptr        - ODU framer channel handle (digi_otn_odu_chnl_t) for
*                      framers 1, 2, 3A or 3B or a mapper channel 
*                      handle (digi_mapper_chnl_t) for framer 4.
*                      The digi_otn_odu_chnl_t handle is provisioned by the 
*                      digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                      functions. The mapper channel handle is provisioned
*                      by the digi_otn_mapper_prov function. The 3B framer
*                      handle is retrieved by calling 
*                      digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                      channel handle as a parameter.
*
*   extract_mask     - Extraction mask (16 bits). Each bit indicates 
*                      whether the corresponding overhead word should be 
*                      extracted. Exactly 10 bits must be set to 1.
*                      (corresponding to the extraction of 10 words).
*
*   insert_mask      - Insertion mask (16 bits). Each bit indicates 
*                      whether the corresponding overhead word will be 
*                      inserted. A maximum of 10 bits can be set to 1.
*                      (corresponding to the insertion of 10 words).
*
*   enable           - Enable (when TRUE) or disable (when FALSE) the overhead 
*                      insertion/extraction for this channel.
* OUTPUTS:
*
* RETURNS:
*   PMC_ERROR       - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_ohp_ch_cfg(digi_handle_t       *digi_handle,
                                     digi_otn_odu_chnl_t *chnl_ptr,
                                     UINT16               extract_mask,
                                     UINT16               insert_mask,
                                     BOOL                 enable)
{
    PMC_ERROR rc = PMC_SUCCESS;
    odu_struct_t *odu_struct_ptr = NULL;
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id,i;
    UINT32 cal_entries[ODU_OHP_SCHED_SIZE_MAX];
    UINT32 num_cal_entries;
    UINT32 extract_cnt = 0;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if (PMC_SUCCESS == rc)
    {
        /* Retrieve the odu struct handle, channel ID & framer ID */
        odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);
        
        PMC_LOG_TRACE("ohp: ch = %d frm_id = %d extract =%x insert %x enable=%d\n", 
                      ch_id,frm_id,extract_mask,insert_mask,enable );
        
        
        rc = digi_otn_cal_entries_get(digi_handle,
                                      TRUE, /* RX_DB=TRUE */
                                      ch_id,
                                      frm_id,
                                      cal_entries, &num_cal_entries);
    }

    if (rc == PMC_SUCCESS && num_cal_entries == 0)
    {
        rc  = DIGI_ERR_OTN_NO_SCHEDULE;
    }

    /* make sure the extract mask has exactly 10 bits set (only check if enable = true) */
    if (enable && PMC_SUCCESS == rc)
    {
        for(i=0;i < 16;i++)
        {
            if (extract_mask & (1 << i))
                extract_cnt++;
        }

        if (extract_cnt != 10)
        {
            rc = DIGI_ERR_OHP_INVALID_EXTRACT_MASK;
        }
    }

    if (rc == PMC_SUCCESS)
    {
        rc = coreotn_ohp_ch_cfg(digi_handle->coreotn_handle, odu_struct_ptr,
                                extract_mask, insert_mask,
                                num_cal_entries,cal_entries,
                                enable);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc); 
} /* digi_otn_ohp_ch_cfg */

/*******************************************************************************
* digi_otn_ohp_ch_cfg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function gets enable/disable status and mask of the overhead 
*   extraction/insertion for a particular channel.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance
*
*   *chnl_ptr        - ODU framer channel handle (digi_otn_odu_chnl_t) for
*                      framers 1, 2, 3A or 3B or a mapper channel 
*                      handle (digi_mapper_chnl_t) for framer 4.
*                      The digi_otn_odu_chnl_t handle is provisioned by the 
*                      digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                      functions. The mapper channel handle is provisioned
*                      by the digi_otn_mapper_prov function. The 3B framer
*                      handle is retrieved by calling 
*                      digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                      channel handle as a parameter.
*
* OUTPUTS:
*   extract_mask     - Extraction mask (16 bits). Each bit indicates 
*                      whether the corresponding overhead word should be 
*                      extracted. Exactly 10 bits must be set to 1.
*                      (corresponding to the extraction of 10 words).
*
*   insert_mask      - Insertion mask (16 bits). Each bit indicates 
*                      whether the corresponding overhead word will be 
*                      inserted. A maximum of 10 bits can be set to 1.
*                      (corresponding to the insertion of 10 words).
*
*   enable           - Enable (when TRUE) or disable (when FALSE) the overhead 
*                      insertion/extraction for this channel.
*
* RETURNS:
*   PMC_ERROR       - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_ohp_ch_cfg_get(digi_handle_t       *digi_handle,
                                         digi_otn_odu_chnl_t *chnl_ptr,
                                         UINT16              *extract_mask,
                                         UINT16              *insert_mask,
                                         BOOL                *enable)
{
    PMC_ERROR rc = PMC_SUCCESS;
    odu_struct_t *odu_struct_ptr = NULL;
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if (PMC_SUCCESS == rc)
    {
        /* Retrieve the odu struct handle, channel ID & framer ID */
        odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);
    }

    if (rc == PMC_SUCCESS)
    {
        rc = coreotn_ohp_ch_cfg_get(digi_handle->coreotn_handle, odu_struct_ptr,
                                    extract_mask, insert_mask,
                                    enable);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc); 
} /* digi_otn_ohp_ch_cfg_get */

/*******************************************************************************
* digi_otn_ohp_ch_insert_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function enables overhead insertion for a particular channel.
*   Note - for normal OHP operation, digi_otn_ohp_ch_cfg should be used
*   to enable both insertion and extraction at the same time.
*
*   The ODUk overhead data consists of 4 rows of 16 bytes each for a 
*   total of 64 bytes (16 32-bit words).  The OHP can extract all 
*   overhead bytes except the BIP-8 from PM/TCMs and JC1, JC2 and JC3. 
*   OTUk overhead (Row 1, bytes 7-14) are only extracted by stage 1 
*   framers. The OHP can insert all bytes except the BIP-8 bytes 
*   from SM, PM and TCMs. OTUk overhead (Row 1, bytes 1-14) can only 
*   be inserted by stage 1 framers.\n\n
*
*
*   A bit mask is used to indicate which words should be inserted.
*   Each bit in the mask indicates whether the corresponding 
*   overhead word (32 bits) should be inserted/extracted. The OHP 
*   supports inserting a maximum of 10 words.  \n\n
*
* \code          
*             ODUk Word         ODUk fields
*             ---------     ---------------------
*                 0         {FAS, FAS, FAS, FAS}
*                 1         {FAS, FAS, MFAS, 0x00}
*                 2:        {SM_TTI, SM_BW_INFO, GCC0_0, GCC0_1}
*                 3:        {RES, RES, JC4, 0x00}
*                 4:        {RES, RES, PM&TCM, TCM_ACT}
*                 5:        {0x00, 0x00, 0x00, 0x00}
*                 6:        {TCM6_TTI, TCM6_BW_INFO, TCM5_TTI, TCM5_BW_INFO}
*                 7:        {TCM4_TTI, TCM4_BW_INFO, FTFL, JC5}
*                 8:        {0x00, 0x00, 0x00, 0x00}
*                 9:        {TCM3_TTI, TCM3_BW_INFO, TCM2_TTI, TCM2_BW_INFO}
*                10:        {TCM1_TTI, TCM1_BW_INFO, PM_TTI, PM_BW_INFO}
*                11:        {EXP, EXP, JC6, 0x00}
*                12:        {GCC1_0, GCC1_1, GCC2_0, GCC2_1}
*                13:        {APS, APS, APS, APS, APS}
*                14:        {RES, RES, RES, RES}
*                15:        {RES, RES, PSI, OMFI}
* \endcode
*   To enable insertion of GCC0_0 and/or GCC0_1, the  
*   digi_otn_otu_oh_ins_cfg function should be called to disable the 
*   over-writing of the two fields.\n\n
*
*   The insertion ethernet packets include destination 
*   and source addresses. \n
* \code
*   The destination address consists of:
*       -Destination user id (32 bit) 
*       -Framer ID (8 bit) The OHP input port.
*       -Channel ID (8 bit)
*   The source address consists of:
*       -source user id (32 bit)
*       -framer ID (8 bit) The OHP input port.
*       -Channel ID (8 bit)
*  
*  Framer ID is as follows: 
*
*   Framer ID   Framer 
*   ---------  -------
*       0      Framer 1
*       1      Framer 2
*       2      Framer 3A
*       3      Framer 3B
*       4      Framer 4
*       5      Framer N
*
*
* \endcode           
*
*  The destination user id and source user id are configured using the 
*  digi_otn_ohp_init function. \n
*
*  The framer number and channel ID corresponding to a channel handle 
*  can be retrieved using the funtion digi_otn_ohp_channel_framer_num_get.\n
*
* The external data source identifies the individual overhead bytes or 
* masked overhead bytes (ie. *_BW_INFO notated bytes) with TX_INS_ENn 
* fields of the Insertion Port Ethernet Packet.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance
*
*   *chnl_ptr        - ODU framer channel handle (digi_otn_odu_chnl_t) for
*                      framers 1, 2, 3A or 3B or a mapper channel 
*                      handle (digi_mapper_chnl_t) for framer 4.
*                      The digi_otn_odu_chnl_t handle is provisioned by the 
*                      digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                      functions. The mapper channel handle is provisioned
*                      by the digi_otn_mapper_prov function. The 3B framer
*                      handle is retrieved by calling 
*                      digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                      channel handle as a parameter.
*
*   insert_mask      - Insertion mask (16 bits). Each bit indicates 
*                      whether the corresponding overhead word will be 
*                      inserted. A maximum of 10 bits can be set to 1.
*                      (corresponding to the insertion of 10 words).
*
*   enable           - Enable (when TRUE) or disable (when FALSE) the overhead 
*                      insertion/extraction for this channel.
* OUTPUTS:
*
* RETURNS:
*   PMC_ERROR       - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_ohp_ch_insert_cfg(digi_handle_t       *digi_handle,
                                            digi_otn_odu_chnl_t *chnl_ptr,
                                            UINT16               insert_mask,
                                            BOOL                 enable)
{
    PMC_ERROR rc = PMC_SUCCESS;
    odu_struct_t *odu_struct_ptr = NULL;
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id;
    UINT32 cal_entries[ODU_OHP_SCHED_SIZE_MAX];
    UINT32 num_cal_entries;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if (PMC_SUCCESS == rc)
    {
        /* Retrieve the odu struct handle, channel ID & framer ID */
        odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);
        
        PMC_LOG_TRACE("ohp: ch = %d frm_id = %d insert mask %x enable=%d\n", 
                      ch_id,frm_id,insert_mask,enable);
        
        
        rc = digi_otn_cal_entries_get(digi_handle,
                                      FALSE, /* RX_DB=FALSE */
                                      ch_id,
                                      frm_id,
                                      cal_entries, &num_cal_entries);
    }

    if (rc == PMC_SUCCESS && num_cal_entries == 0)
    {
        rc  = DIGI_ERR_OTN_NO_SCHEDULE;
    }

    if (rc == PMC_SUCCESS)
    {
        rc = coreotn_ohp_ch_unidir_cfg(digi_handle->coreotn_handle, odu_struct_ptr,
                                       insert_mask,
                                       num_cal_entries,cal_entries,
                                       TRUE,
                                       enable);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc); 
} /* digi_otn_ohp_ch_insert_cfg */

/*******************************************************************************
* digi_otn_ohp_ch_insert_cfg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function gets overhead insertion for a particular channel.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance
*
*   *chnl_ptr        - ODU framer channel handle (digi_otn_odu_chnl_t) for
*                      framers 1, 2, 3A or 3B or a mapper channel 
*                      handle (digi_mapper_chnl_t) for framer 4.
*                      The digi_otn_odu_chnl_t handle is provisioned by the 
*                      digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                      functions. The mapper channel handle is provisioned
*                      by the digi_otn_mapper_prov function. The 3B framer
*                      handle is retrieved by calling 
*                      digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                      channel handle as a parameter.
*
*
* OUTPUTS:
*   insert_mask      - Insertion mask (16 bits). Each bit indicates 
*                      whether the corresponding overhead word will be 
*                      inserted. A maximum of 10 bits can be set to 1.
*                      (corresponding to the insertion of 10 words).
*   enable           - Enable (when TRUE) or disable (when FALSE) the overhead 
*                      insertion/extraction for this channel.
*
* RETURNS:
*   PMC_ERROR       - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_ohp_ch_insert_cfg_get(digi_handle_t       *digi_handle,
                                                digi_otn_odu_chnl_t *chnl_ptr,
                                                UINT16              *insert_mask,
                                                BOOL                *enable)
    {
    PMC_ERROR rc = PMC_SUCCESS;
    odu_struct_t *odu_struct_ptr = NULL;
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if (PMC_SUCCESS == rc)
    {
        /* Retrieve the odu struct handle, channel ID & framer ID */
        odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);
    }

    if (rc == PMC_SUCCESS)
    {
        rc = coreotn_ohp_ch_unidir_cfg_get(digi_handle->coreotn_handle, odu_struct_ptr,
                                           TRUE,
                                           insert_mask,
                                           enable);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc); 
} /* digi_otn_ohp_ch_insert_cfg_get */

/*******************************************************************************
* digi_otn_ohp_ch_extract_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function enables or disables the overhead extraction for a particular 
*   channel. NOTE: For normal operation, digi_otn_ohp_ch_cfg should be used to
*   enable both insertion and extractation.
*
*   The ODUk overhead data consists of 4 rows of 16 bytes each for a 
*   total of 64 bytes (16 32-bit words).  The OHP can extract all 
*   overhead bytes except the BIP-8 from PM/TCMs and JC1, JC2 and JC3. 
*   OTUk overhead (Row 1, bytes 7-14) are only extracted by stage 1 
*   framers. The OHP can insert all bytes except the BIP-8 bytes 
*   from SM, PM and TCMs. OTUk overhead (Row 1, bytes 1-14) can only 
*   be inserted by stage 1 framers.\n\n
*
*
*   A bit mask is used to indicate which words should be extracted. Each bit 
*   in the mask indicates whether the corresponding overhead word (32 bits) 
*   should be extracted. The OHP supports extracting 10 words.\n\n
*
* \code          
*             ODUk Word         ODUk fields
*             ---------     ---------------------
*                 0         {FAS, FAS, FAS, FAS}
*                 1         {FAS, FAS, MFAS, 0x00}
*                 2:        {SM_TTI, SM_BW_INFO, GCC0_0, GCC0_1}
*                 3:        {RES, RES, JC4, 0x00}
*                 4:        {RES, RES, PM&TCM, TCM_ACT}
*                 5:        {0x00, 0x00, 0x00, 0x00}
*                 6:        {TCM6_TTI, TCM6_BW_INFO, TCM5_TTI, TCM5_BW_INFO}
*                 7:        {TCM4_TTI, TCM4_BW_INFO, FTFL, JC5}
*                 8:        {0x00, 0x00, 0x00, 0x00}
*                 9:        {TCM3_TTI, TCM3_BW_INFO, TCM2_TTI, TCM2_BW_INFO}
*                10:        {TCM1_TTI, TCM1_BW_INFO, PM_TTI, PM_BW_INFO}
*                11:        {EXP, EXP, JC6, 0x00}
*                12:        {GCC1_0, GCC1_1, GCC2_0, GCC2_1}
*                13:        {APS, APS, APS, APS, APS}
*                14:        {RES, RES, RES, RES}
*                15:        {RES, RES, PSI, OMFI}
* \endcode
*   To enable extraction/insertion of GCC0_0 and/or GCC0_1, the  
*   digi_otn_otu_oh_ins_cfg function should be called to disable the 
*   over-writing of the two fields.\n\n
*
*   The extraction ethernet packets include destination and source addresses. \n
* \code
*   The destination address consists of:
*       -Destination user id (32 bit) 
*       -Framer ID (8 bit) The OHP input port.
*       -Channel ID (8 bit)
*   The source address consists of:
*       -source user id (32 bit)
*       -framer ID (8 bit) The OHP input port.
*       -Channel ID (8 bit)
*  
*  Framer ID is as follows: 
*
*   Framer ID   Framer 
*   ---------  -------
*       0      Framer 1
*       1      Framer 2
*       2      Framer 3A
*       3      Framer 3B
*       4      Framer 4
*       5      Framer N
*
*
* \endcode           
*
*  The destination user id and source user id are configured using the 
*  digi_otn_ohp_init function. \n
*
*  The framer number and channel ID corresponding to a channel handle 
*  can be retrieved using the funtion digi_otn_ohp_channel_framer_num_get.\n
*
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance
*
*   *chnl_ptr        - ODU framer channel handle (digi_otn_odu_chnl_t) for
*                      framers 1, 2, 3A or 3B or a mapper channel 
*                      handle (digi_mapper_chnl_t) for framer 4.
*                      The digi_otn_odu_chnl_t handle is provisioned by the 
*                      digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                      functions. The mapper channel handle is provisioned
*                      by the digi_otn_mapper_prov function. The 3B framer
*                      handle is retrieved by calling 
*                      digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                      channel handle as a parameter.
*
*   extract_mask     - Extraction mask (16 bits). Each bit indicates 
*                      whether the corresponding overhead word should be 
*                      extracted. Exactly 10 bits must be set to 1.
*                      (corresponding to the extraction of 10 words).
*
*   enable           - Enable (when TRUE) or disable (when FALSE) the overhead 
*                      insertion/extraction for this channel.
* OUTPUTS:
*
* RETURNS:
*   PMC_ERROR       - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_ohp_ch_extract_cfg(digi_handle_t       *digi_handle,
                                             digi_otn_odu_chnl_t *chnl_ptr,
                                             UINT16               extract_mask,
                                             BOOL                 enable)
{
    PMC_ERROR rc = PMC_SUCCESS;
    odu_struct_t *odu_struct_ptr = NULL;
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id,i;
    UINT32 cal_entries[ODU_OHP_SCHED_SIZE_MAX];
    UINT32 num_cal_entries;
    UINT32 extract_cnt = 0;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if (PMC_SUCCESS == rc)
    {
        /* Retrieve the odu struct handle, channel ID & framer ID */
        odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);
        
        PMC_LOG_TRACE("ohp: ch = %d: frm_id = %d,extract mask = %x, enable=%d\n", 
                      ch_id,frm_id,extract_mask,enable);
        
        
        rc = digi_otn_cal_entries_get(digi_handle,
                                      TRUE, /* RX_DB=TRUE */
                                      ch_id,
                                      frm_id,
                                      cal_entries, &num_cal_entries);
    }

    if (rc == PMC_SUCCESS && num_cal_entries == 0)
    {
        rc  = DIGI_ERR_OTN_NO_SCHEDULE;
    }

    /* make sure the extract mask has exactly 10 bits set (only check if enable = true) */
    if (enable && PMC_SUCCESS == rc)
    {
        for(i=0;i < 16;i++)
        {
            if (extract_mask & (1 << i))
                extract_cnt++;
        }

        if (extract_cnt != 10)
        {
            rc = DIGI_ERR_OHP_INVALID_EXTRACT_MASK;
        }
    }

    if (rc == PMC_SUCCESS)
    {
        rc = coreotn_ohp_ch_unidir_cfg(digi_handle->coreotn_handle, odu_struct_ptr,
                                       extract_mask,
                                       num_cal_entries,cal_entries,
                                       FALSE,
                                       enable);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc); 
} /* digi_otn_ohp_ch_extract_cfg */

/*******************************************************************************
* digi_otn_ohp_ch_extract_cfg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function gets enable or disable status of the overhead extraction for a particular 
*   channel. NOTE: For normal operation, digi_otn_ohp_ch_cfg should be used to
*   enable both insertion and extractation.
*
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance
*
*   *chnl_ptr        - ODU framer channel handle (digi_otn_odu_chnl_t) for
*                      framers 1, 2, 3A or 3B or a mapper channel 
*                      handle (digi_mapper_chnl_t) for framer 4.
*                      The digi_otn_odu_chnl_t handle is provisioned by the 
*                      digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                      functions. The mapper channel handle is provisioned
*                      by the digi_otn_mapper_prov function. The 3B framer
*                      handle is retrieved by calling 
*                      digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                      channel handle as a parameter.
*
* OUTPUTS:
*   extract_mask     - Extraction mask (16 bits). Each bit indicates 
*                      whether the corresponding overhead word should be 
*                      extracted. Exactly 10 bits must be set to 1.
*                      (corresponding to the extraction of 10 words).
*
*   enable           - Enable (when TRUE) or disable (when FALSE) the overhead 
*                      insertion/extraction for this channel.
*
* RETURNS:
*   PMC_ERROR       - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_ohp_ch_extract_cfg_get(digi_handle_t       *digi_handle,
                                                 digi_otn_odu_chnl_t *chnl_ptr,
                                                 UINT16              *extract_mask,
                                                 BOOL                *enable)
{
    PMC_ERROR rc = PMC_SUCCESS;
    odu_struct_t *odu_struct_ptr = NULL;
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id;

    UINT32 extract_cnt = 0;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if (PMC_SUCCESS == rc)
    {
        /* Retrieve the odu struct handle, channel ID & framer ID */
        odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);
    }

    if (rc == PMC_SUCCESS)
    {
        rc = coreotn_ohp_ch_unidir_cfg_get(digi_handle->coreotn_handle, odu_struct_ptr,
                                           FALSE,
                                           extract_mask,
                                           enable);
    }

    PMC_ATOMIC_RETURN(digi_handle,rc); 
} /* digi_otn_ohp_ch_extract_cfg_get */

/*******************************************************************************
* digi_otn_ohp_ch_resize
* ______________________________________________________________________________
*
* DESCRIPTION: 
*
*
*  This function resizes OHP for G.HAO. The datapath should be resized before 
*  calling this function when ramping down and OHP should be resized first when
*  ramping up. \n\n
*   
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance
*
*   *chnl_ptr        - ODU framer channel handle (digi_otn_odu_chnl_t) for
*                      framer 2, 3A or 3B or a mapper channel 
*                      handle (digi_mapper_chnl_t) for framer 4.
*                      The digi_otn_odu_chnl_t handle is provisioned by the 
*                      digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                      functions. The mapper channel handle is provisioned
*                      by the digi_otn_mapper_prov function. The 3B framer
*                      handle is retrieved by calling 
*                      digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                      channel handle as a parameter.
*
* resize             - Number of time slots to resize: +ve increase, -ve decrease 
* OUTPUTS:
*
* RETURNS:
*   PMC_ERROR       - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_ohp_ch_resize(digi_handle_t *digi_handle,
                                        digi_otn_odu_chnl_t *chnl_ptr,
                                        INT32 resize)
{
    PMC_ERROR rc = PMC_SUCCESS;
    odu_struct_t *odu_struct_ptr;
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    /* Retrieve the odu struct handle, channel ID & framer ID */
    odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);

    PMC_LOG_TRACE("ohp: ch = %d frm_id = %d resize=%d\n", ch_id,frm_id,resize);
    if (rc == PMC_SUCCESS)
    {
        rc = coreotn_ohp_ch_resize(digi_handle->coreotn_handle, odu_struct_ptr, resize);
    }
    PMC_ATOMIC_RETURN(digi_handle,rc); 
} /* digi_otn_ohp_ch_resize */


/*******************************************************************************
* digi_otn_ohp_channel_framer_num_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   
*   This function returns the channel number and framer number corresponding to a 
*   particular channel handle. \n\n
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance
*
*   *chnl_ptr        - ODU framer channel handle (digi_otn_odu_chnl_t) for
*                      framer 2, 3A or 3B or a mapper channel 
*                      handle (digi_mapper_chnl_t) for framer 4.
*                      The digi_otn_odu_chnl_t handle is provisioned by the 
*                      digi_otn_server_ho_prov or digi_otn_server_lo_prov 
*                      functions. The mapper channel handle is provisioned
*                      by the digi_otn_mapper_prov function. The 3B framer
*                      handle is retrieved by calling 
*                      digi_otn_get_chnl_ptr_for_tcm_apps with the 3a 
*                      channel handle as a parameter.
*
* OUTPUTS:
*   framer_num_ptr  - the framer number  - See odu_ohp_port_framer_t
*   channel_num_ptr - channel number  
*
* RETURNS:
*   PMC_ERROR       - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_ohp_channel_framer_num_get(digi_handle_t *digi_handle,
                                                      util_global_switch_data_t *chnl_ptr,
                                                      UINT32 *channel_num_ptr,
                                                      odu_ohp_port_framer_t *framer_num_ptr)
{
    PMC_ERROR rc = PMC_SUCCESS;
    odu_struct_t *odu_struct_ptr = NULL;
    odu_struct_frm_id_t frm_id = LAST_ODU_STRUCT_FRM_ID;
    odu_ohp_port_framer_t ohp_frm_id = ODU_OHP_PORT_FRAMER_LAST;
    UINT32 ch_id;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, rc);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if (rc == PMC_SUCCESS)
    {
        /* Retrieve the odu struct handle, channel ID & framer ID */
        odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);
        if (odu_struct_ptr == NULL) 
        {
            rc = DIGI_ERR_INVALID_ARG;
        }
            
    }
    
    if (rc != PMC_SUCCESS)
    {
        PMC_ATOMIC_RETURN(digi_handle,rc); 
    }
    
    /* Translate from ODU struct frame IDs to OHP frame IDs */
    switch(frm_id) 
    {
        case ODU_STRUCT_FRM_STG1:   ohp_frm_id = ODU_OHP_PORT_FRAMER_1; break;
        case ODU_STRUCT_FRM_STG2:   ohp_frm_id = ODU_OHP_PORT_FRAMER_2; break;
        case ODU_STRUCT_FRM_STG3A:  ohp_frm_id = ODU_OHP_PORT_FRAMER_3A; break;
        case ODU_STRUCT_FRM_STG3B:  ohp_frm_id = ODU_OHP_PORT_FRAMER_3B; break;
        case ODU_STRUCT_FRM_STG4:   ohp_frm_id = ODU_OHP_PORT_FRAMER_4; break;
        case ODU_STRUCT_FRM_STGN:   ohp_frm_id = ODU_OHP_PORT_FRAMER_N; break;
        default:                    ohp_frm_id = ODU_OHP_PORT_FRAMER_LAST;break;
    }

    PMC_LOG_TRACE("ohp: ch = %d frm_id = %d\n", ch_id,ohp_frm_id);
    *channel_num_ptr = ch_id;
    *framer_num_ptr = ohp_frm_id; 
    PMC_ATOMIC_RETURN(digi_handle,rc); 
} /* digi_otn_ohp_channel_framer_num_get */



/*******************************************************************************
* digi_otn_odu_dplm_to_ssf_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Controls consequential actions asociated with DPLM
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on 
*                     DPLM is a HO based config, so you must provide the
*                     HO chnl_ptr
*   enable          - 1 : enable DPLM to SSF consequential action
*                     0 : disable DPLM to SSF consequential action
*
* OUTPUTS:
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_dplm_to_ssf_set(digi_handle_t *digi_handle, 
                                              digi_otn_odu_chnl_t *chnl_ptr,
                                              BOOL8 enable)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_otn_odu_dplm_to_ssf_set(digi_handle->coreotn_handle,
                                                (odu_struct_t *)chnl_ptr,
                                                ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE,
                                                enable);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_dplm_to_ssf_set */

/*******************************************************************************
* digi_otn_odu_dplm_to_ssf_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Gets consequential action associated with DPLM.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on 
*                     DPLM is a HO based config, so you must provide the
*                     HO chnl_ptr
*
* OUTPUTS:
*   enable          - 1 : DPLM to SSF consequential action is enabled
*                     0 : DPLM to SSF consequential action is disabled
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_dplm_to_ssf_get(digi_handle_t *digi_handle, 
                                              digi_otn_odu_chnl_t *chnl_ptr,
                                              BOOL8 *enable)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_otn_odu_dplm_to_ssf_get(digi_handle->coreotn_handle,
                                                (odu_struct_t *)chnl_ptr,
                                                ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                                enable);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_dplm_to_ssf_get */

/*******************************************************************************
* digi_otn_odu_dloomfi_to_ssf_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Controls consequential actions asociated with DLOOMFI
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on 
*                     DLOOMFI is a HO based config, so you must provide the
*                     HO chnl_ptr
*   enable          - 1 : enable DLOOMFI to SSF consequential action
*                     0 : disable DLOOMFI to SSF consequential action
*
* OUTPUTS:
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_dloomfi_to_ssf_set(digi_handle_t *digi_handle, 
                                                 digi_otn_odu_chnl_t *chnl_ptr,
                                                 BOOL8 enable)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_otn_odu_dloomfi_to_ssf_set(digi_handle->coreotn_handle,
                                                (odu_struct_t *)chnl_ptr,
                                                ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE,
                                                enable);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_dloomfi_to_ssf_set */


/*******************************************************************************
* digi_otn_odu_dloomfi_to_ssf_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Gets consequential action associated with DLOOMFI.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on 
*                     DLOOMFI is a HO based config, so you must provide the
*                     HO chnl_ptr
*
* OUTPUTS:
*   enable          - 1 : DLOOMFI to SSF consequential action is enabled
*                     0 : DLOOMFI to SSF consequential action is disabled
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_dloomfi_to_ssf_get(digi_handle_t *digi_handle, 
                                                 digi_otn_odu_chnl_t *chnl_ptr,
                                                 BOOL8 *enable)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_otn_odu_dloomfi_to_ssf_get(digi_handle->coreotn_handle,
                                                   (odu_struct_t *)chnl_ptr,
                                                   ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                                   enable);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_dloomfi_to_ssf_get */

/*******************************************************************************
* digi_otn_odu_dmsim_to_ssf_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Controls consequential action associated with DMSIM.
*   This is a global setting that applies to all ODU channels.
* 
*   Given the channel pointer, dMSIM to SSF consequential action is enabled
*   on the entire ODU level that is represented in the chanenl pointer.
*   When dMSIM to SSF consequential action is enabled for a HO channel, this
*   applies to all ODU channels in de-multiplexing Stage 1.
*   When dMSIM to SSF consequential action is enabled for a MO channel, this
*   applies to all ODU channels in de-multiplexing Stage 2.
*   It is invalid to enable dMSIM to SSF on a LO channel.
* 
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on 
*                     DMSIM is a HO based config, so you must provide the
*                     HO chnl_ptr
*   enable          - 1 : enable DMSIM to SSF consequential action
*                     0 : disable DMSIM to SSF consequential action
*
* OUTPUTS:
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_dmsim_to_ssf_set(digi_handle_t *digi_handle, 
                                               digi_otn_odu_chnl_t *chnl_ptr,
                                               BOOL8 enable)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_otn_odu_dmsim_to_ssf_set(digi_handle->coreotn_handle,
                                                 (odu_struct_t *)chnl_ptr,
                                                 ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE,
                                                 enable);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_dmsim_to_ssf_set */


/*******************************************************************************
* digi_otn_odu_dmsim_to_ssf_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Gets consequential action associated with DMSIM.
*   The setting of dmsim_to_ssf applies to all channels in the de-multiplexing
*   stage represented in the channel pointer.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on 
*                     DMSIM is a HO based config, so you must provide the
*                     HO chnl_ptr
*
* OUTPUTS:
*   enable          - 1 : DMSIM to SSF consequential action is enabled
*                     0 : DMSIM to SSF consequential action is disabled
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_dmsim_to_ssf_get(digi_handle_t *digi_handle, 
                                               digi_otn_odu_chnl_t *chnl_ptr,
                                               BOOL8 *enable)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    result = odu_struct_otn_odu_dmsim_to_ssf_get(digi_handle->coreotn_handle,
                                                 (odu_struct_t *)chnl_ptr,
                                                 ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                                 enable);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_dmsim_to_ssf_get */

/*******************************************************************************
* digi_otn_odu_deg_state_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retrieves firmware degrade state machine variables
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on
*   pm_tcm_num          - PM or TCMi layer. See odu_struct_odu_frm_pm_tcm_id_t.
*                          
* OUTPUTS:
*  digi_pmon_ddeg_state_ptr - pointer to storage for returned state.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_deg_state_get(digi_handle_t                  *digi_handle,
                                            digi_otn_odu_chnl_t            *chnl_ptr,
                                            odu_struct_odu_frm_pm_tcm_id_t  pm_tcm_num,
                                            digi_pmon_ddeg_state_t         *digi_pmon_ddeg_state_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    odu_struct_frm_id_t odu_frm_id;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk;
    UINT32 ddeg_chnl;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    /* argument checking */
    if (pm_tcm_num > ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM_NIM)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }

    if (PMC_SUCCESS == result)
    {
        /* if fw enhanced dDEG reporting is enabled */
        odu_frm_id = odu_struct_frm_id_get(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr);
                                           
        if (LAST_ODU_STRUCT_FRM_ID != odu_frm_id)
        {                            
            /* convert odu_frm_id to ddeg_hw_block */
            result = digi_otn_pmon_ddeg_hw_blk_get(digi_handle, odu_frm_id,
                                                   pm_tcm_num, &ddeg_hw_blk);
            
            if (PMC_SUCCESS == result && ddeg_hw_blk != DIGI_PMON_DDEG_HW_BLOCK_MAX_NUM)
            {
                result = digi_otn_odu_deg_chnl_get(digi_handle, chnl_ptr, pm_tcm_num, &ddeg_chnl);
        
                if (PMC_SUCCESS == result)
                {
                    result = digi_pmon_ddeg_state_get(digi_handle, 
                                                      ddeg_hw_blk,
                                                      ddeg_chnl,
                                                      digi_pmon_ddeg_state_ptr);
                }
            }                                                                       
        } 
    }
        
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_deg_state_get */

/*******************************************************************************
* digi_otn_otu_deg_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves firmware degrade state machine variables
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   otn_server_ptr      - pointer to a resource allocation
*                         context for the OTN server configured against the
*                         specified serdes port.pointer to ODU channel  
*
* OUTPUTS:
*  digi_pmon_ddeg_state_ptr - pointer to storage for returned state.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_deg_state_get(digi_handle_t *digi_handle,
                                            digi_otn_server_chnl_t *otn_server_ptr,
                                            digi_pmon_ddeg_state_t         *digi_pmon_ddeg_state_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk; 
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    
    /* get current mode */
    if (TRUE == DIGI_OTN_SERVER_IS_LINE(otn_server_ptr))
    {
        ddeg_hw_blk = DIGI_PMON_DDEG_LINEOTN;
    }
    else 
    {     
        ddeg_hw_blk = DIGI_PMON_DDEG_SYSOTN;
    }

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    result = digi_pmon_ddeg_state_get(digi_handle, 
                                      ddeg_hw_blk,
                                      otn_srvr_ptr->dci_chnl,
                                      digi_pmon_ddeg_state_ptr);
    
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_otu_deg_state_get */

/*******************************************************************************
* digi_otn_odu_deg_m_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures number of degraded monitoring intervals required to issue
*   dDEG (DEGM as defined in G.806). 
*
*   When hardware dDEG reporting is enabled, this API is used to configure
*   DEG_M value in the receive ODU channel represented in chnl_ptr.
*
*   When enhanced dDEG reporting is enabled, this API is used to set DEG_M 
*   value for bursty dDEG reporting via the firmware.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on    
*   pm_tcm_num          - PM or TCMi layer. See odu_struct_odu_frm_pm_tcm_id_t.
*   deg_m               - degrade defect consecutive one second monitoring
*                         intervals for the TCM or PM layer\n
*                         Valid range: 
*                          DIGI_OTN_HARDWARE_DDEG: 1-15 seconds
*                          DIGI_OTN_ENHANCED_DDEG or 
*                          DIGI_OTN_ENH_BURSTY_DDEG: 2-10 seconds
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_deg_m_set(digi_handle_t                 *digi_handle,
                                        digi_otn_odu_chnl_t           *chnl_ptr,                                       
                                        odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                        UINT8 deg_m)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk; 
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_chnl;
    UINT32 i;
    UINT32 chnl_msk_idx;
    UINT32 chnl_bit_idx;
    UINT16 tcm_pool_id;
    odu_struct_frm_id_t odu_frm_id;
    BOOL8 hw_enabled = coreotn_is_ddeg_hw_mode(digi_handle->coreotn_handle);

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);
    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));    

    /* argument checking */
    if (pm_tcm_num > ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM_NIM) 
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }        

    /* check requested range */
    if (PMC_SUCCESS == result) 
    {
        UINT32 min = UTIL_GLOBAL_DDEG_HW_M_INTERVAL_MIN;
        UINT32 max = UTIL_GLOBAL_DDEG_HW_M_INTERVAL_MAX;

        if (FALSE == hw_enabled)
        {
            min = UTIL_GLOBAL_DDEG_FW_M_INTERVAL_MIN;
            max = UTIL_GLOBAL_DDEG_FW_M_INTERVAL_MAX;
        }

        if (deg_m > max || deg_m < min)
        {
            result = DIGI_ERR_INVALID_ARG;
        }
    }
    
    if (PMC_SUCCESS == result)
    {      
                               
        if (FALSE == hw_enabled)
        {
            /* FW enhanced dDEG report is enabled; 
            ** this is to configure bursty mode DEG_M in firmware.
            */
            /* initialize channel mask */
            for (i = 0; i < 8; i++)
            {
                ddeg_chnl.chnl_bitmsk[i] = 0;
            }
               
            /* create a channel mask; only one channel at a time */
            if (pm_tcm_num == ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM)
            {
                chnl_msk_idx = (((odu_struct_t *)chnl_ptr)->switch_data.oduk_data.channel) / 32;
                chnl_bit_idx = (((odu_struct_t *)chnl_ptr)->switch_data.oduk_data.channel) % 32;
                
                ddeg_chnl.chnl_bitmsk[chnl_msk_idx] = (ddeg_chnl.chnl_bitmsk[chnl_msk_idx]) | (1 << chnl_bit_idx);
            }
            else {
                /* create pid mask */
                /* Replaced 0 with the equivalent odu_struct_stream_dir_t
                   value. */
                result = odu_struct_tcm_pool_id_from_instance_get(digi_handle->coreotn_handle,
                                                                  (odu_struct_t *)chnl_ptr, ODU_STRUCT_STREAM_RX,
                                                                  pm_tcm_num, &tcm_pool_id); 
                if (PMC_SUCCESS == result)
                {           
                    chnl_msk_idx = tcm_pool_id / 32;
                    chnl_bit_idx = tcm_pool_id % 32;
                    
                    ddeg_chnl.chnl_bitmsk[chnl_msk_idx] = (ddeg_chnl.chnl_bitmsk[chnl_msk_idx]) | (1 << chnl_bit_idx);
                }
            }
            
            if(PMC_SUCCESS == result)
            {
                /* get ODU_RFRM instance to access */
                odu_frm_id = odu_struct_frm_id_get(digi_handle->coreotn_handle,
                                                   (odu_struct_t *)chnl_ptr);
                
                if (LAST_ODU_STRUCT_FRM_ID != odu_frm_id)
                {                            
                    /* convert odu_frm_id to ddeg_hw_block */
                    result = digi_otn_pmon_ddeg_hw_blk_get(digi_handle, odu_frm_id,
                                                           pm_tcm_num, &ddeg_hw_blk);
                    
                    if (PMC_SUCCESS == result && ddeg_hw_blk != DIGI_PMON_DDEG_HW_BLOCK_MAX_NUM)
                    {                              
                        result = digi_pmon_ddeg_param_cfg(digi_handle,
                                                          DIGI_PMON_DDEG_MODE_BURSTY,
                                                          ddeg_hw_blk, ddeg_chnl,
                                                          deg_m, 0, 0, TRUE, FALSE, FALSE);
                    }                                                  
                }
            }
        }
        else 
        {     
            /* if hardware dDEG is enabled, read from register */
            result = odu_struct_deg_m_set(digi_handle->coreotn_handle,
                                          (odu_struct_t *)chnl_ptr,
                                          pm_tcm_num,
                                          deg_m,
                                          ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
        }
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_odu_deg_m_set */

/*******************************************************************************
* digi_otn_odu_deg_m_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retrieves degrade monitoring interval for an ODU framer channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on
*   pm_tcm_num          - PM or TCMi layer. See odu_struct_odu_frm_pm_tcm_id_t.
*                          
* OUTPUTS:                 
*   *deg_m              - retrieved dDEG monitoring interval.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_deg_m_get(digi_handle_t                  *digi_handle,
                                        digi_otn_odu_chnl_t            *chnl_ptr,
                                        odu_struct_odu_frm_pm_tcm_id_t  pm_tcm_num,
                                        UINT8                          *deg_m)
{
    PMC_ERROR result = PMC_SUCCESS;
    odu_struct_frm_id_t odu_frm_id;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk;
    digi_pmon_ddeg_param_t digi_pmon_ddeg_param_ptr;
    UINT32 ddeg_chnl;
    BOOL8 hw_enabled = coreotn_is_ddeg_hw_mode(digi_handle->coreotn_handle);

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);
    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));    
    
    /* argument checking */
    if (pm_tcm_num > ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM_NIM)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }

    if (PMC_SUCCESS == result)
    {
        /* if hardware dDEG reporting is enabled, then read from device */
        if (TRUE == hw_enabled)
        {                                      
            result = odu_struct_deg_m_get(digi_handle->coreotn_handle,
                                          (odu_struct_t *)chnl_ptr,
                                          pm_tcm_num,
                                          ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                          deg_m);
        }
        else {
            /* if fw enhanced dDEG reporting is enabled */
            odu_frm_id = odu_struct_frm_id_get(digi_handle->coreotn_handle,
                                               (odu_struct_t *)chnl_ptr);
                                               
            if (LAST_ODU_STRUCT_FRM_ID != odu_frm_id)
            {                            
                /* convert odu_frm_id to ddeg_hw_block */
                result = digi_otn_pmon_ddeg_hw_blk_get(digi_handle, odu_frm_id,
                                                       pm_tcm_num, &ddeg_hw_blk);
                
                if (PMC_SUCCESS == result && ddeg_hw_blk != DIGI_PMON_DDEG_HW_BLOCK_MAX_NUM)
                {      
                    result = digi_otn_odu_deg_chnl_get(digi_handle, chnl_ptr, pm_tcm_num, &ddeg_chnl);
            
                    if (PMC_SUCCESS == result)
                    {
                        result = digi_pmon_ddeg_param_get(digi_handle, 
                                                          DIGI_PMON_DDEG_MODE_BURSTY,
                                                          ddeg_hw_blk,
                                                          ddeg_chnl,
                                                          &digi_pmon_ddeg_param_ptr);
                    }
                 
                    if (PMC_SUCCESS == result)
                    {
                        *deg_m = digi_pmon_ddeg_param_ptr.mon_intvl;
                    }
                }                                                                       
            } 
        }
    }
        
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_deg_m_get */

/*******************************************************************************
* digi_otn_odu_deg_th_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures degrade defect one second errored block count threshold for an ODU 
*   framer channel.      
*
*   When hardware dDEG reporting(DIGI_OTN_HARDWARE_DDEG) or 
*   firmware bursty dDEG reporting(DIGI_OTN_ENH_BURSTY_DDEG) is enabled, 
*   this API is used to set one second errored block count threshold.
* 
* 
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on    
*   pm_tcm_num      - PM or TCMi layer. See odu_struct_odu_frm_pm_tcm_id_t.
*   deg_th          - degrade defect one second errored block count
*                     threshold in hardware or in firmware BURSTY dDEG reporting\n
*                     Valid range: 
*                     As stated in Table 6-2 of G.798, the following is the 
*                     maximum number of near-end errored blocks per second for  
*                     each ODUk rate. 
*                     For ODU4 rate, there can be up to 856164 errored blocks/s
*                     For ODU3 rate, there can be up to 329492 errored blocks/s
*                     For ODU2E rate, there can be up to 84983 errored blocks/s 
*                     For ODU2 rate, there can be up to 82026 errored blocks/s 
*                     For ODU1 rate, there can be up to 20421 errored blocks/s                    
*                     For ODU0 rate, there can be up to 10167 errored blocks/s
*                     For ODUFlex_CBR, there can be up to client_rate/121856 errored blocks/s
*                     For ODUFlex_GFP, there can be up to client_rate/122368 errored blocks/s
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_deg_th_set(digi_handle_t                 *digi_handle,
                                         digi_otn_odu_chnl_t           *chnl_ptr,
                                         odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                         UINT32                         deg_th)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_chnl;
    UINT32 i;
    UINT32 chnl_msk_idx;
    UINT32 chnl_bit_idx;
    UINT16 tcm_pool_id;
    odu_struct_frm_id_t odu_frm_id;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk;
    BOOL8 hw_enabled = coreotn_is_ddeg_hw_mode(digi_handle->coreotn_handle);

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);
    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));    

    /* argument checking */
    if (pm_tcm_num > ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM_NIM)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }

          
    if (PMC_SUCCESS == result)
    {                                 
        if (FALSE == hw_enabled)
        {
            /* FW enhanced dDEG report is enabled; 
            ** this is to configure bursty mode DEG_TH in firmware.
            */
            /* initialize channel mask */
            for (i = 0; i < 8; i++)
            {
                ddeg_chnl.chnl_bitmsk[i] = 0;
            }
               
            /* create a channel mask; only one channel at a time */
            if (pm_tcm_num == ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM)
            {
                chnl_msk_idx = (((odu_struct_t *)chnl_ptr)->switch_data.oduk_data.channel) / 32;
                chnl_bit_idx = (((odu_struct_t *)chnl_ptr)->switch_data.oduk_data.channel) % 32;
                
                ddeg_chnl.chnl_bitmsk[chnl_msk_idx] = (ddeg_chnl.chnl_bitmsk[chnl_msk_idx]) | (1 << chnl_bit_idx);
            }
            else {
                /* create pid mask */
                result = odu_struct_tcm_pool_id_from_instance_get(digi_handle->coreotn_handle,
                                                                  (odu_struct_t *)chnl_ptr, ODU_STRUCT_STREAM_RX,
                                                                  pm_tcm_num, &tcm_pool_id); 
                if (PMC_SUCCESS == result)
                {
                    chnl_msk_idx = tcm_pool_id / 32;
                    chnl_bit_idx = tcm_pool_id % 32;
                    
                    ddeg_chnl.chnl_bitmsk[chnl_msk_idx] = (ddeg_chnl.chnl_bitmsk[chnl_msk_idx]) | (1 << chnl_bit_idx);
                }
            }
            
            /* get ODU_RFRM instance to access */
            odu_frm_id = odu_struct_frm_id_get(digi_handle->coreotn_handle,
                                               (odu_struct_t *)chnl_ptr);
                                                   
            if (PMC_SUCCESS == result && LAST_ODU_STRUCT_FRM_ID != odu_frm_id)
            {                            
                /* convert odu_frm_id to ddeg_hw_block */
                result = digi_otn_pmon_ddeg_hw_blk_get(digi_handle, odu_frm_id,
                                                       pm_tcm_num, &ddeg_hw_blk);
                
                /* set bursty mode threshold first */
                if (PMC_SUCCESS == result && ddeg_hw_blk != DIGI_PMON_DDEG_HW_BLOCK_MAX_NUM)
                {                              
                    result = digi_pmon_ddeg_param_cfg(digi_handle,
                                                      DIGI_PMON_DDEG_MODE_BURSTY,
                                                      ddeg_hw_blk, ddeg_chnl,
                                                      0, deg_th, 0, FALSE, TRUE, FALSE);
                }                                                                                                     
            }
        } else 
        {     
            /* HW dDEG is enabled */
            result = odu_struct_deg_th_set(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr,
                                           pm_tcm_num,
                                           deg_th,
                                           ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
        }
    }                                       

    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_odu_deg_th_set */

/*******************************************************************************
* digi_otn_odu_deg_th_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Configures degrade defect one second errored block count threshold for an ODU 
*   framer channel.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on  
*   pm_tcm_num      - PM or TCMi layer. See odu_struct_odu_frm_pm_tcm_id_t.
*                          
* OUTPUTS:                 
*   *deg_th         - retrieved dDEG threshold.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_deg_th_get(digi_handle_t                 *digi_handle,
                                         digi_otn_odu_chnl_t           *chnl_ptr,
                                         odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                         UINT32                        *deg_th)
{
    PMC_ERROR result = PMC_SUCCESS;
    odu_struct_frm_id_t odu_frm_id;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk;
    digi_pmon_ddeg_param_t digi_pmon_ddeg_param_ptr;
    UINT32 ddeg_chnl;
    BOOL8 hw_enabled = coreotn_is_ddeg_hw_mode(digi_handle->coreotn_handle);

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);
    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));    

    /* initialize the output variables */
    *deg_th = 0;
    
    if (PMC_SUCCESS == result)
    {
        if (TRUE == hw_enabled)
        {
            /* when HW dDEG is enabled */
            result = odu_struct_deg_th_get(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr,
                                           pm_tcm_num,
                                           ODU_STRUCT_EXTRACT_FROM_DEVICE,
                                           deg_th);     
        }
        else {
                           
            /* get ODU_RFRM instance to access */
            odu_frm_id = odu_struct_frm_id_get(digi_handle->coreotn_handle,
                                               (odu_struct_t *)chnl_ptr);
                                                   
            if (LAST_ODU_STRUCT_FRM_ID != odu_frm_id)
            {                            
                /* convert odu_frm_id to ddeg_hw_block */
                result = digi_otn_pmon_ddeg_hw_blk_get(digi_handle, odu_frm_id,
                                                       pm_tcm_num, &ddeg_hw_blk);
                           
                if (PMC_SUCCESS == result)
                {
                    result = digi_otn_odu_deg_chnl_get(digi_handle, chnl_ptr, pm_tcm_num, &ddeg_chnl);
                }
            
                if (PMC_SUCCESS == result)
                {                                           
                    /* retrieve bursty deg threshold */
                    result = digi_pmon_ddeg_param_get(digi_handle, 
                                                      DIGI_PMON_DDEG_MODE_BURSTY,
                                                      ddeg_hw_blk, 
                                                      ddeg_chnl,
                                                      &digi_pmon_ddeg_param_ptr);
                    
                    if (PMC_SUCCESS == result)
                    {
                        *deg_th = digi_pmon_ddeg_param_ptr.set_threshold; 
                    }                                                                        
                } 
                
            } /* end of if (LAST_ODU_STRUCT_FRM_ID != odu_frm_id) */
        } /* end of else */                                 
    }    

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_deg_th_get */

/*******************************************************************************
* digi_otn_otu_deg_m_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures number of degraded monitoring intervals required to issue
*   dDEG (DEGM as defined in G.806). 
*
*   When hardware dDEG reporting is enabled, this API is used to configure
*   DEG_M value in the receive ODU channel represented in chnl_ptr.
*
*   When enhanced dDEG reporting is enabled, this API is used to set DEG_M 
*   value for bursty dDEG reporting via the firmware.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   otn_server_ptr      - pointer to a resource allocation
*                         context for the OTN server configured against the
*                         specified serdes port.pointer to ODU channel       
*   deg_m               - degrade defect consecutive one second monitoring
*                         intervals for the TCM or PM layer\n
*                         Valid range: 
*                          DIGI_OTN_HARDWARE_DDEG: 1-15 seconds
*                          DIGI_OTN_ENHANCED_DDEG or 
*                          DIGI_OTN_ENH_BURSTY_DDEG: 2-10 seconds
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_deg_m_set(digi_handle_t *digi_handle,
                                        digi_otn_server_chnl_t *otn_server_ptr,
                                        UINT8 deg_m)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk; 
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_chnl, *ddeg_chnl_ptr = &ddeg_chnl;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    digi_otn_ddeg_mode_t ddeg_mode;
    lineotn_handle_t *linesys_handle;
        
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    
    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    PMC_MEMSET(ddeg_chnl_ptr,0, sizeof(digi_pmon_ddeg_chnl_bitmsk_t));
    /* get current mode */
    ddeg_mode   = digi_handle->var.linesys_ddeg_mode;
    if (TRUE == DIGI_OTN_SERVER_IS_LINE(otn_server_ptr))
    {
        ddeg_hw_blk = DIGI_PMON_DDEG_LINEOTN;
        ddeg_chnl.chnl_bitmsk[0] = (0x1 << otn_srvr_ptr->dci_chnl);
    } else 
    {     
        ddeg_hw_blk = DIGI_PMON_DDEG_SYSOTN;
        ddeg_chnl.chnl_bitmsk[0] = 0x1;
    }
   
    /* check requested range */
    if (PMC_SUCCESS == result) 
    {
        UINT32 min, max;
        min = (DIGI_OTN_HARDWARE_DDEG == ddeg_mode)?1:2;
        max = (DIGI_OTN_HARDWARE_DDEG == ddeg_mode)?15:10;
        if (deg_m > max || deg_m < min)
        {
            result = DIGI_ERR_INVALID_ARG;
        }
    }
    
    if (PMC_SUCCESS == result)
    {      
                               
        if (ddeg_mode == DIGI_OTN_ENHANCED_DDEG ||
            ddeg_mode == DIGI_OTN_ENH_BURSTY_DDEG)
        {
            /* FW enhanced dDEG report is enabled; 
            ** this is to configure bursty mode DEG_M in firmware.
            */
            
            if (PMC_SUCCESS == result && ddeg_hw_blk != DIGI_PMON_DDEG_HW_BLOCK_MAX_NUM)
            {                              
                result = digi_pmon_ddeg_param_cfg(digi_handle,
                                                  DIGI_PMON_DDEG_MODE_BURSTY,
                                                  ddeg_hw_blk, ddeg_chnl,
                                                  deg_m, 0, 0, TRUE, FALSE, FALSE);
            }                                                          
        } else 
        {     
    
            result = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
            if (PMC_SUCCESS == result)
            {
                result = lineotn_sm_deg_set(linesys_handle,
                                            otn_srvr_ptr->dsi_base_chnl,
                                            (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                            LINE_OTN_OTU_SK_SM_DEG_M,
                                            deg_m);                          
            }
        }
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_otu_deg_m_set */

/*******************************************************************************
* digi_otn_otu_deg_m_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Retrieves degrade monitoring interval for an ODU framer channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   otn_server_ptr      - pointer to a resource allocation
*                         context for the OTN server configured against the
*                         specified serdes port.pointer to ODU channel       
* OUTPUTS:                 
*   *deg_m              - retrieved dDEG monitoring interval.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_deg_m_get(digi_handle_t *digi_handle,
                                        digi_otn_server_chnl_t *otn_server_ptr,
                                        UINT8 *deg_m)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk; 
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    digi_otn_ddeg_mode_t ddeg_mode;
    lineotn_handle_t *linesys_handle;
    digi_pmon_ddeg_param_t digi_pmon_ddeg_param_ptr;
    UINT32 deg_val;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);
    
    /* get current mode */
    ddeg_mode   = digi_handle->var.linesys_ddeg_mode;
    if (TRUE == DIGI_OTN_SERVER_IS_LINE(otn_server_ptr))
    {
        ddeg_hw_blk = DIGI_PMON_DDEG_LINEOTN;
    } else 
    {     
        ddeg_hw_blk = DIGI_PMON_DDEG_SYSOTN;
    }
    
    /* if hardware dDEG reporting is enabled, then read from device */
    if ((digi_otn_ddeg_mode_t)ddeg_mode == DIGI_OTN_HARDWARE_DDEG)
    {   
        result = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
        if (PMC_SUCCESS != result)
        {
            PMC_ATOMIC_RETURN(digi_handle, result);
        }
    
        result = lineotn_sm_deg_get(linesys_handle,
                                    otn_srvr_ptr->dsi_base_chnl,
                                    (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                    LINE_OTN_OTU_SK_SM_DEG_M,
                                    &deg_val);
        *deg_m = (UINT8) deg_val;
    } else 
    {
        result = digi_pmon_ddeg_param_get(digi_handle, 
                                          DIGI_PMON_DDEG_MODE_BURSTY,
                                          ddeg_hw_blk,
                                          otn_srvr_ptr->dci_chnl,
                                          &digi_pmon_ddeg_param_ptr);
                 
        if (PMC_SUCCESS == result)
        {
            *deg_m = digi_pmon_ddeg_param_ptr.mon_intvl;
        }
    }                                                                       
        
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_otu_deg_m_get */

/*******************************************************************************
* digi_otn_otu_deg_th_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures degrade defect one second errored block count threshold for an ODU 
*   framer channel.      
*
*   When hardware dDEG reporting(DIGI_OTN_HARDWARE_DDEG) or 
*   firmware bursty dDEG reporting(DIGI_OTN_ENH_BURSTY_DDEG) is enabled, 
*   this API is used to set one second errored block count threshold.
* 
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   otn_server_ptr      - pointer to a resource allocation
*                         context for the OTN server configured against the
*                         specified serdes port.pointer to ODU channel       
*   deg_th          - degrade defect one second errored block count
*                     threshold in hardware or in firmware BURSTY dDEG reporting\n
*                     Valid range: 
*                     As stated in Table 6-2 of G.798, the following is the 
*                     maximum number of near-end errored blocks per second for  
*                     each ODUk rate. 
*                     For OTU4 rate, there can be up to 856388 errored blocks/s
*                     For OTU3 rate, there can be up to 329492 errored blocks/s
*                     For ODU2 rate, there can be up to 82026 errored blocks/s 
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_deg_th_set(digi_handle_t *digi_handle,
                                         digi_otn_server_chnl_t *otn_server_ptr,
                                         UINT32 deg_th)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk; 
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_chnl, *ddeg_chnl_ptr = &ddeg_chnl;;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    digi_otn_ddeg_mode_t ddeg_mode;
    lineotn_handle_t *linesys_handle;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    
    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    PMC_MEMSET(ddeg_chnl_ptr,0, sizeof(digi_pmon_ddeg_chnl_bitmsk_t));
    /* get current mode */
    ddeg_mode   = digi_handle->var.linesys_ddeg_mode;
    if (TRUE == DIGI_OTN_SERVER_IS_LINE(otn_server_ptr))
    {
        ddeg_hw_blk = DIGI_PMON_DDEG_LINEOTN;
        ddeg_chnl.chnl_bitmsk[0] = (0x1 << otn_srvr_ptr->dci_chnl);
    } else 
    {     
        ddeg_hw_blk = DIGI_PMON_DDEG_SYSOTN;
        ddeg_chnl.chnl_bitmsk[0] = 0x1;
    }
    /* this API is valid only when hardware dDEG or FW enhanced dDEG reporting
    ** is enabled
    */
    if (ddeg_mode > DIGI_OTN_ENH_BURSTY_DDEG)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }
      
    if (ddeg_mode == DIGI_OTN_ENHANCED_DDEG ||
        ddeg_mode == DIGI_OTN_ENH_BURSTY_DDEG)
    {
        /* FW enhanced dDEG report is enabled; 
        ** this is to configure bursty mode DEG_TH in firmware.
        */
        
        /* set bursty mode threshold first */
        result = digi_pmon_ddeg_param_cfg(digi_handle,
                                          DIGI_PMON_DDEG_MODE_BURSTY,
                                          ddeg_hw_blk, ddeg_chnl,
                                          0, deg_th, 0, FALSE, TRUE, FALSE);            
    } else 
    {     
        result = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
        if (PMC_SUCCESS == result)
        {
            result = lineotn_sm_deg_set(linesys_handle,
                                        otn_srvr_ptr->dsi_base_chnl,
                                        (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                        LINE_OTN_OTU_SK_SM_DEG_THR,
                                        deg_th);                          
        }
    }

    
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_otu_deg_th_set */

/*******************************************************************************
* digi_otn_otu_deg_th_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Configures degrade defect one second errored block count threshold for an ODU 
*   framer channel.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *otn_server_ptr     - Pointer to a resource allocation
*                         context for the OTN server configured against the
*                         specified serdes port.
*                          
* OUTPUTS:                 
*   *deg_th         - retrieved dDEG threshold.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_deg_th_get(digi_handle_t *digi_handle,
                                         digi_otn_server_chnl_t *otn_server_ptr,
                                         UINT32 *deg_th)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk; 
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    digi_otn_ddeg_mode_t ddeg_mode;
    lineotn_handle_t *linesys_handle;
    digi_pmon_ddeg_param_t digi_pmon_ddeg_param_ptr;
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_chnl, *ddeg_chnl_ptr = &ddeg_chnl;;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle   , DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr  , DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != deg_th        , DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);
    
    PMC_MEMSET(ddeg_chnl_ptr,0, sizeof(digi_pmon_ddeg_chnl_bitmsk_t));
    /* initialize the output variables */
    *deg_th = 0;
    
    /* get current mode */
    ddeg_mode   = digi_handle->var.linesys_ddeg_mode;
    if (TRUE == DIGI_OTN_SERVER_IS_LINE(otn_server_ptr))
    {
        ddeg_hw_blk = DIGI_PMON_DDEG_LINEOTN;
        ddeg_chnl.chnl_bitmsk[0] = (0x1 << otn_srvr_ptr->dci_chnl);
    } else 
    {     
        ddeg_hw_blk = DIGI_PMON_DDEG_SYSOTN;
        ddeg_chnl.chnl_bitmsk[0] = 0x1;
    }

    if (ddeg_mode == DIGI_OTN_HARDWARE_DDEG)
    {
        result = digi_otn_otu_handle_get(digi_handle,otn_srvr_ptr, &linesys_handle);  
        if (PMC_SUCCESS == result)
        {
            result = lineotn_sm_deg_get(linesys_handle,
                                        otn_srvr_ptr->dsi_base_chnl,
                                        (lineotn_dsi_type_t)otn_srvr_ptr->dsi_serdes_type,
                                        LINE_OTN_OTU_SK_SM_DEG_THR,
                                        deg_th);
        }
    } else 
    {
        /* FW enhanced dDEG report is enabled; 
        ** this is to configure bursty mode DEG_TH in firmware.
        */
        /* retrieve bursty deg threshold */
        result = digi_pmon_ddeg_param_get(digi_handle, 
                                          DIGI_PMON_DDEG_MODE_BURSTY,
                                          ddeg_hw_blk, 
                                          otn_srvr_ptr->dci_chnl,
                                          &digi_pmon_ddeg_param_ptr);
        
        if (PMC_SUCCESS == result)
        {
            *deg_th = digi_pmon_ddeg_param_ptr.set_threshold; 
        }                                                                                         
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_otu_deg_th_get */


/*******************************************************************************
* FUNCTION: digi_otn_pmon_ddeg_mode_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves PMON DDEG modes to configure in FW based on the ddeg_mode
*   configured by user.
*
* INPUTS:
*   digi_handle             - Pointer to digi handle
*   ddeg_mode               - See digi_otn_ddeg_mode_t.  
*
* OUTPUTS:
*   pmon_ddeg_modes_ptr     - Array of PMON DDEG modes to configure
*   num_pmon_ddeg_ptr       - Number of PMON DDEG modes in array
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_pmon_ddeg_mode_get(digi_handle_t         *digi_handle,
                                              digi_otn_ddeg_mode_t   ddeg_mode,
                                              digi_pmon_ddeg_mode_t *pmon_ddeg_modes_ptr,
                                              UINT32                *num_pmon_ddeg_ptr)

{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle          != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(pmon_ddeg_modes_ptr  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(num_pmon_ddeg_ptr    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);


    switch (ddeg_mode)
    {
        case DIGI_OTN_ENH_BURSTY_DDEG:
            pmon_ddeg_modes_ptr[0] = DIGI_PMON_DDEG_MODE_ENH;
            pmon_ddeg_modes_ptr[1] = DIGI_PMON_DDEG_MODE_BURSTY;
            *num_pmon_ddeg_ptr     = 2;
            break;
        case DIGI_OTN_ENHANCED_DDEG:
            pmon_ddeg_modes_ptr[0] = DIGI_PMON_DDEG_MODE_ENH;
            *num_pmon_ddeg_ptr     = 1;
            break;
        default: 
            PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);   
    }


    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_pmon_ddeg_mode_get */



/*******************************************************************************
* digi_otn_odu_ddeg_mode_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Used to configure which dDEG monitoring will be used. 
*   When selecting dDEG monitoring mode, the mode will apply to all receive
*   framers in COREOTN subsystem. 
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   ddeg_mode       - See digi_otn_ddeg_mode_t.  
*   odu_segment     - selects the ODU segment to monitor.
*                     DIGI_OTN_DDEG_MON_LINE    -- COREOTN STG1/2/N/3A framers
*                     DIGI_OTN_DDEG_MON_CLIENT  -- COREOTN STG4 framer    
*   configure       - when TRUE DDEG block is configured otherwise it is unconfigured.
*                          
* OUTPUTS:                 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_ddeg_mode_set(digi_handle_t          *digi_handle,
                                            digi_otn_ddeg_mode_t    ddeg_mode,
                                            digi_otn_ddeg_mon_seg_t odu_segment,
                                            BOOL8                   configure)
                                            
                                            
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_mode_t pmon_ddeg_mode;
    digi_pmon_ddeg_mode_t pmon_ddeg_modes[2] = {DIGI_PMON_DDEG_MODE_MAX_NUM, DIGI_PMON_DDEG_MODE_MAX_NUM};
    UINT32 num_ddeg_to_cfg = 0;
    BOOL mon_coreotn_stg_4;
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_chnl_1;
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_tcm_6;
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_chnl_12;
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_tcm_72;
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_chnl_96;
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_tcm_256;
    UINT32 i;
    UINT32 itr;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    if (ddeg_mode >= LAST_DIGI_OTN_DDEG_MODE)
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);
    }
    if (TRUE == coreotn_odu_rcp_di_enable_get(digi_handle->coreotn_handle) && 
       DIGI_OTN_HARDWARE_DDEG  != ddeg_mode)
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_HW_DDEG_ODU_RCP_DI_ONLY);
    }

    if (odu_segment == DIGI_OTN_DDEG_MON_CLIENT)
    {
        mon_coreotn_stg_4 = TRUE;
    }
    else 
    {
        mon_coreotn_stg_4 = FALSE;
    }
    
    /* save to context */
    result = coreotn_ddeg_mon_segment_set(digi_handle->coreotn_handle,
                                          (coreotn_ddeg_mon_seg_t)odu_segment);

    if (PMC_SUCCESS == result)
    {                                          
        /* initialize channel mask */
        for (i = 0; i < 8; i++)
        {
            ddeg_chnl_1.chnl_bitmsk[i] = 0;
            ddeg_chnl_12.chnl_bitmsk[i] = 0;
            ddeg_chnl_96.chnl_bitmsk[i] = 0;
            ddeg_tcm_6.chnl_bitmsk[i] = 0;
            ddeg_tcm_72.chnl_bitmsk[i] = 0;
            ddeg_tcm_256.chnl_bitmsk[i] = 0;
        }
        
        /* for 1 channel framer. STGN */
        ddeg_chnl_1.chnl_bitmsk[0] = 0x1;
        
        /* for 6 pool id block: STGN */
        ddeg_tcm_6.chnl_bitmsk[0] = 0x3f;
        
        /* for 12 channel framer STG1_PM */
        ddeg_chnl_12.chnl_bitmsk[0] = 0xfff;
        
        /* for 72 pool id block STG1 TCM */
        for (i = 0; i < 2; i++)
        {
            /* TCM pool ids from 0 - 63 */
            ddeg_tcm_72.chnl_bitmsk[i] = 0xffff;
        }
                    
        ddeg_tcm_72.chnl_bitmsk[2] = 0xff;
        
        /* for 96 channel framers */
        /* this applies to STG2_PM and STG3A_PM */    
        for (i = 0; i < 3; i++)
        {
            ddeg_chnl_96.chnl_bitmsk[i] = 0xffff;
        }
        
        /* for 256 pool id blocks STG2 TCM and STG3A TCM */
        for (i = 0; i < 8; i++)
        {
            ddeg_tcm_256.chnl_bitmsk[i] = 0xffff;
        }
    }
    
    /* disable or enble TSD consequenctial action */
    if (PMC_SUCCESS == result)
    {
        result = odu_struct_ddeg_mode_set(digi_handle->coreotn_handle,
                                          (coreotn_ddeg_mode_t)ddeg_mode,
                                          configure,
                                          (UINT8)odu_segment);
    }
    
    if (PMC_SUCCESS == result)
    {
        if (ddeg_mode != DIGI_OTN_HARDWARE_DDEG)
        {  
            /* set the segment to be monitored by FW */
            result = digi_pmon_ddeg_coreotn_seg_cfg(digi_handle, mon_coreotn_stg_4);
           
            if (PMC_SUCCESS == result)
            {
                result = digi_otn_pmon_ddeg_mode_get(digi_handle,
                                                     ddeg_mode,
                                                     pmon_ddeg_modes,
                                                     &num_ddeg_to_cfg);
            }
            
            for (itr = 0; itr < num_ddeg_to_cfg; itr++)
            {
                pmon_ddeg_mode = pmon_ddeg_modes[itr];
                PMC_ATOMIC_YIELD(digi_handle,0);
                
                if (mon_coreotn_stg_4 != TRUE)
                {
                    if (PMC_SUCCESS == result)
                    {
                        result = digi_pmon_ddeg_param_cfg(digi_handle,
                                                          pmon_ddeg_mode,
                                                          DIGI_PMON_DDEG_COREOTN_STG_1_PM,
                                                          ddeg_chnl_12,
                                                          0, 0, 0, FALSE, FALSE, FALSE);
                    }
                    
                    if (PMC_SUCCESS == result)
                    {
                        result = digi_pmon_ddeg_param_cfg(digi_handle,
                                                          pmon_ddeg_mode,
                                                          DIGI_PMON_DDEG_COREOTN_STG_1_TCM,
                                                          ddeg_tcm_72,
                                                          0, 0, 0, FALSE, FALSE, FALSE);   
                    }
                
                    if (PMC_SUCCESS == result)
                    {
                        result = digi_pmon_ddeg_param_cfg(digi_handle,
                                                          pmon_ddeg_mode,
                                                          DIGI_PMON_DDEG_COREOTN_STG_2_PM,
                                                          ddeg_chnl_96,
                                                          0, 0, 0, FALSE, FALSE, FALSE);
                    }
                
                    if (PMC_SUCCESS == result)
                    {
                        result = digi_pmon_ddeg_param_cfg(digi_handle,
                                                          pmon_ddeg_mode,
                                                          DIGI_PMON_DDEG_COREOTN_STG_2_TCM,
                                                          ddeg_tcm_256,
                                                          0, 0, 0, FALSE, FALSE, FALSE);
                    }
                
                    if (PMC_SUCCESS == result)
                    {
                        result = digi_pmon_ddeg_param_cfg(digi_handle,
                                                          pmon_ddeg_mode,
                                                          DIGI_PMON_DDEG_COREOTN_STG_N_PM,
                                                          ddeg_chnl_1,
                                                          0, 0, 0, FALSE, FALSE, FALSE);
                    }
                
                    if (PMC_SUCCESS == result)
                    {
                        result = digi_pmon_ddeg_param_cfg(digi_handle,
                                                          pmon_ddeg_mode,
                                                          DIGI_PMON_DDEG_COREOTN_STG_N_TCM,
                                                          ddeg_tcm_6,
                                                          0, 0, 0, FALSE, FALSE, FALSE);   
                    }                                                                                                 
                
                    if (PMC_SUCCESS == result)
                    {
                        result = digi_pmon_ddeg_param_cfg(digi_handle,
                                                          pmon_ddeg_mode,
                                                          DIGI_PMON_DDEG_COREOTN_STG_3A_4_PM,
                                                          ddeg_chnl_96,
                                                          0, 0, 0, FALSE, FALSE, FALSE);
                    } 
                
                    if (PMC_SUCCESS == result)
                    {
                        result = digi_pmon_ddeg_param_cfg(digi_handle,
                                                          pmon_ddeg_mode,
                                                          DIGI_PMON_DDEG_COREOTN_STG_3A_4_PM,
                                                          ddeg_tcm_256,
                                                          0, 0, 0, FALSE, FALSE, FALSE);
                    } 
                }
                else 
                {
                    if (PMC_SUCCESS == result)
                    {
                        result = digi_pmon_ddeg_param_cfg(digi_handle,
                                                          pmon_ddeg_mode,
                                                          DIGI_PMON_DDEG_COREOTN_STG_3A_4_PM,
                                                          ddeg_chnl_96,
                                                          0, 0, 0, FALSE, FALSE, FALSE);
                    } 
                
                    if (PMC_SUCCESS == result)
                    {
                        result = digi_pmon_ddeg_param_cfg(digi_handle,
                                                          pmon_ddeg_mode,
                                                          DIGI_PMON_DDEG_COREOTN_STG_3A_4_PM,
                                                          ddeg_tcm_256,
                                                          0, 0, 0, FALSE, FALSE, FALSE);
                    }  
                
                    if (PMC_SUCCESS == result && ddeg_mode == DIGI_OTN_ENHANCED_DDEG)
                    {
                        if (PMC_SUCCESS == result)
                        {
                            result = digi_pmon_ddeg_param_cfg(digi_handle,
                                                              DIGI_PMON_DDEG_MODE_BURSTY,
                                                              DIGI_PMON_DDEG_COREOTN_STG_3A_4_PM,
                                                              ddeg_chnl_96,
                                                              0, 0, 0, FALSE, FALSE, FALSE);
                        } 
                    
                        if (PMC_SUCCESS == result)
                        {
                            result = digi_pmon_ddeg_param_cfg(digi_handle,
                                                              DIGI_PMON_DDEG_MODE_BURSTY,
                                                              DIGI_PMON_DDEG_COREOTN_STG_3A_4_PM,
                                                              ddeg_tcm_256,
                                                              0, 0, 0, FALSE, FALSE, FALSE);
                        }
                    }
                }      
            } /* end of else */
        } /* end of if (ddeg_mode != DIGI_OTN_HARDWARE_DDEG) */
    } /* end of if (PMC_SUCCESS == result) */
                                         
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_odu_ddeg_mode_set */

/*******************************************************************************
* digi_otn_odu_ddeg_mode_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API retrieves the current dDEG reporting mode.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance  
*    ddeg_mode      - See digi_otn_ddeg_mode_t.       
*                          
* OUTPUTS:                     
*   *ddeg_configured- when TRUE DDEG is configred, otherwise it is not configured.
*   *mon_seg        - enum for monitoring segment if ENHANCED_DDEG is enabled. 
*                     See digi_otn_ddeg_mon_seg_t. This doesn't apply to 
*                     DIGI_OTN_HARDWARE_DDEG.
*   
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_ddeg_mode_get(digi_handle_t           *digi_handle,
                                            digi_otn_ddeg_mode_t     ddeg_mode,
                                            BOOL                    *ddeg_configured,
                                            digi_otn_ddeg_mon_seg_t *mon_seg)
                                            
                                            
{
    PMC_ERROR result; 
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* call internal implementation that retrieve ddeg mode state and monitor segment*/
    result = digi_otn_odu_ddeg_mode_internal_get(digi_handle,
                                                 ddeg_mode,
                                                 ddeg_configured,
                                                 mon_seg);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_ddeg_mode_get */    

/*******************************************************************************
* digi_otn_otu_ddeg_mode_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Used to configure which dDEG monitoring will be used. 
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   ddeg_mode       - See digi_otn_ddeg_mode_t.  
*                          
* OUTPUTS:                 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_ddeg_mode_set(digi_handle_t        *digi_handle,
                                            digi_otn_ddeg_mode_t  ddeg_mode)
                                            
                                            
{
    PMC_ERROR result = PMC_SUCCESS;
    BOOL8 fw_ddeg_handling = FALSE;
        
    PMC_ATOMIC_ENTRY(digi_handle);

    if (ddeg_mode >= LAST_DIGI_OTN_DDEG_MODE)
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);
    }
     
    if (TRUE == coreotn_odu_rcp_di_enable_get(digi_handle->coreotn_handle) && 
        DIGI_OTN_HARDWARE_DDEG  != ddeg_mode)
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_HW_DDEG_ODU_RCP_DI_ONLY);
    }

    fw_ddeg_handling = (ddeg_mode == DIGI_OTN_HARDWARE_DDEG)?FALSE:TRUE;
    
    /* configure consequenctial action in LINEOTN */
    result = lineotn_ddeg_mode_set(digi_handle->lineotn_handle,fw_ddeg_handling);
    if (PMC_SUCCESS == result)
    {
        result = lineotn_ddeg_mode_set(digi_handle->sysotn_handle,fw_ddeg_handling);
    }

    digi_handle->var.linesys_ddeg_mode = ddeg_mode;    
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_otu_ddeg_mode_set */

/*******************************************************************************
* digi_otn_otu_ddeg_mode_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API retrieves the current dDEG reporting mode.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance       
*                          
* OUTPUTS:                 
*   *ddeg_mode      - See digi_otn_ddeg_mode_t.      
*   
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_ddeg_mode_get(digi_handle_t *digi_handle,
                                            digi_otn_ddeg_mode_t *ddeg_mode)
                                            
                                            
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    *ddeg_mode =  digi_handle->var.linesys_ddeg_mode;
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_otu_ddeg_mode_get */    

/*******************************************************************************
* digi_otn_odu_ddeg_mon_enable
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API is used to enable dDEG reporting via firmware.
*   
*   Prior to calling this API, the following APIs must have been called to 
*   properly configure dDEG monitoring variables and set the monitoring mode. 
*   - digi_otn_odu_ddeg_mode_set() to set ddeg_mode to DIGI_OTN_ENHANCED_DDEG or 
*     DIGI_OTN_ENH_BURSTY_DDEG. 
*   - digi_otn_odu_enhanced_ddeg_interval_set() to set monitoring interval. 
*   - digi_otn_odu_deg_m_set() to set DEG_M in bursty mode
*   - digi_otn_odu_deg_th_set() to set DEG threshold.
*   This API is for enabling FW dDEG only. For HW dDEG, 
*   digi_otn_odu_hw_ddeg_mon_enable() should be called.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU channel     
*    ddeg_mode      - See digi_otn_ddeg_mode_t  
*   pm_tcm_num      - enum for PM/TCMi instances. See odu_struct_odu_frm_pm_tcm_id_t
*                     ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_DCI is invalid.
*   enable          - enable or disable dDEG monitoring via firmware                      
*                          
* OUTPUTS:                 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_ddeg_mon_enable(digi_handle_t                 *digi_handle,
                                              digi_otn_odu_chnl_t           *chnl_ptr,
                                              digi_otn_ddeg_mode_t           ddeg_mode,
                                              odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                              BOOL                           enable)
                                            
                                            
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_mode_t fw_ddeg_mode = DIGI_PMON_DDEG_MODE_MAX_NUM;
    digi_pmon_ddeg_mode_t pmon_ddeg_modes[2];
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk;
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_chnl;
    UINT16 tcm_pool_id;
    UINT32 chnl_msk_idx;
    UINT32 chnl_bit_idx;
    UINT32 i;
    odu_struct_frm_id_t odu_frm_id;
    BOOL8 configured;
    UINT32 itr;
    UINT32 num_ddeg_to_cfg = 0;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);
    
    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    /* argument checking */
    if (pm_tcm_num > ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM_NIM || enable > 1)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }
    
    if (PMC_SUCCESS == result)
    {
        if (ddeg_mode == DIGI_OTN_HARDWARE_DDEG)
        { 
            PMC_ATOMIC_RETURN(digi_handle, COREOTN_ERR_ENH_DDEG_NOT_ENABLED);
        }
    }
    /* throw an error if the enhanced dDEG is not enabled */
    /* coreotn_ddeg_mode_get(coreotn_handle_t *coreotn_handle,
                                          coreotn_ddeg_mode_t *ddeg_mode) */
    result = coreotn_ddeg_mode_get(digi_handle->coreotn_handle, 
                                   (coreotn_ddeg_mode_t)ddeg_mode,
                                   &configured);
   
    if (PMC_SUCCESS == result)
    {
        if (FALSE == configured)
        {
            PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_DDEG_NOT_CONFIGURED);            
        }
    }
    
   
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_pmon_ddeg_mode_get(digi_handle,
                                             ddeg_mode,
                                             pmon_ddeg_modes,
                                             &num_ddeg_to_cfg);
    }



    /* initialize channel mask */
    for (i = 0; i < 8; i++)
    {
        ddeg_chnl.chnl_bitmsk[i] = 0;
    }
       
    /* create a channel mask; only one channel at a time */
    if (pm_tcm_num == ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM)
    {
        chnl_msk_idx = (((odu_struct_t *)chnl_ptr)->switch_data.oduk_data.channel) / 32;
        chnl_bit_idx = (((odu_struct_t *)chnl_ptr)->switch_data.oduk_data.channel) % 32;
        
        ddeg_chnl.chnl_bitmsk[chnl_msk_idx] = (ddeg_chnl.chnl_bitmsk[chnl_msk_idx]) | (1 << chnl_bit_idx);
    }
    else {
        /* create pid mask */
        result = odu_struct_tcm_pool_id_from_instance_get(digi_handle->coreotn_handle,
                                                          (odu_struct_t *)chnl_ptr, ODU_STRUCT_STREAM_RX,
                                                          pm_tcm_num, &tcm_pool_id); 
        if (PMC_SUCCESS == result)
        {
            chnl_msk_idx = tcm_pool_id / 32;
            chnl_bit_idx = tcm_pool_id % 32;
            
            ddeg_chnl.chnl_bitmsk[chnl_msk_idx] = (ddeg_chnl.chnl_bitmsk[chnl_msk_idx]) | (1 << chnl_bit_idx);
        }
    }
    
    /* get HW block to access */
    if (PMC_SUCCESS == result)
    {
        odu_frm_id = odu_struct_frm_id_get(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr);
    }                                          
    
    if (PMC_SUCCESS == result && LAST_ODU_STRUCT_FRM_ID != odu_frm_id)
    {
        /* convert to digi_pmon_ddeg_hw_block_t */
        result = digi_otn_pmon_ddeg_hw_blk_get(digi_handle, odu_frm_id, 
                                               pm_tcm_num, &ddeg_hw_blk);
                
        for (itr = 0; itr < num_ddeg_to_cfg; itr++)
        {
            fw_ddeg_mode = pmon_ddeg_modes[itr];
            if (PMC_SUCCESS == result && ddeg_hw_blk != DIGI_PMON_DDEG_HW_BLOCK_MAX_NUM)
            {             
                result = digi_pmon_ddeg_en_cfg(digi_handle, 
                                               fw_ddeg_mode, 
                                               ddeg_hw_blk,
                                               ddeg_chnl, enable);
            }                                           
        }
    }
                  
    /* save ddeg monitor status in coreotn context */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_ddeg_status_set(digi_handle->coreotn_handle, 
                                         (coreotn_ddeg_mode_t)ddeg_mode,
                                         enable);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_ddeg_mon_enable */

/*******************************************************************************
* digi_otn_otu_ddeg_mon_enable
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API is used to enable dDEG reporting via firmware.
*   
*   Prior to calling this API, the following APIs must have been called to 
*   properly configure dDEG monitoring variables and set the monitoring mode. 
*   - digi_otn_otu_ddeg_mode_set() to set ddeg_mode to DIGI_OTN_ENHANCED_DDEG or 
*     DIGI_OTN_ENH_BURSTY_DDEG. 
*   - digi_otn_otu_enhanced_ddeg_interval_set() to set monitoring interval. 
*   - digi_otn_otu_enhanced_ddeg_th_set() to set trhesholds in FW enhanced mode 
*   - digi_otn_otu_deg_m_set() to set DEG_M in bursty mode
*   - digi_otn_otu_deg_th_set() to set DEG threshold.
*   This API is for enabling FW dDEG only. For HW dDEG, 
*   digi_otn_odu_hw_ddeg_mon_enable() should be called.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   otn_server_ptr  - pointer to a resource allocation
*                     context for the OTN server configured against the
*                     specified serdes port.pointer to ODU channel       
*   enable          - enable or disable dDEG monitoring via firmware                      
*                          
* OUTPUTS:                 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_ddeg_mon_enable(digi_handle_t *digi_handle,
                                              digi_otn_server_chnl_t *otn_server_ptr,
                                              BOOL enable)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_mode_t fw_ddeg_mode;
    digi_pmon_ddeg_mode_t pmon_ddeg_modes[2];
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk;
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_chnl, *ddeg_chnl_ptr = &ddeg_chnl;;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    digi_otn_ddeg_mode_t ddeg_mode;
    UINT32 itr;
    UINT32 num_ddeg_to_cfg;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
     /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, otn_server_ptr, result, TRUE);

    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    PMC_MEMSET(ddeg_chnl_ptr,0, sizeof(digi_pmon_ddeg_chnl_bitmsk_t));
    ddeg_mode   = digi_handle->var.linesys_ddeg_mode;
    /* get current mode */
    if (TRUE == DIGI_OTN_SERVER_IS_LINE(otn_server_ptr))
    {
        ddeg_hw_blk = DIGI_PMON_DDEG_LINEOTN;
        ddeg_chnl.chnl_bitmsk[0] = (0x1 << otn_srvr_ptr->dci_chnl);
    } 
    else 
    {     
        ddeg_hw_blk = DIGI_PMON_DDEG_SYSOTN;
        ddeg_chnl.chnl_bitmsk[0] = 0x1;
    }

    if (PMC_SUCCESS == result && ddeg_mode == DIGI_OTN_HARDWARE_DDEG)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_ENH_DDEG_NOT_ENABLED);
    }
   
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_pmon_ddeg_mode_get(digi_handle,
                                             ddeg_mode,
                                             pmon_ddeg_modes,
                                             &num_ddeg_to_cfg);
    }
    
    
    for (itr = 0; (itr < num_ddeg_to_cfg) && (PMC_SUCCESS == result); itr++)
    {
        fw_ddeg_mode = pmon_ddeg_modes[itr];
        result = digi_pmon_ddeg_en_cfg(digi_handle, 
                                       fw_ddeg_mode, 
                                       ddeg_hw_blk,
                                       ddeg_chnl, enable);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_otu_ddeg_mon_enable */

  
/*******************************************************************************
* digi_otn_odu_enhanced_ddeg_interval_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Used to configure the monitoring interval for the enhanced dDEG report.
*   
*   Prior to calling this API, digi_otn_odu_ddeg_mode_set() must be called with 
*   'ddeg_mode' == DIGI_OTN_ENHANCED_DDEG to enable enhanced dDEG on all ODU
*   receive framers.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance    
*   *chnl_ptr       - pointer to ODU channel       
*   pm_tcm_num      - enum for PM/TCMi instances. See odu_struct_odu_frm_pm_tcm_id_t
*                     ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_DCI is invalid.           
*   mon_interval    - Monitoring interval for enhanced dDEG
*                     The following values are valid:
*                      0: 10ms  
*                      1: 100ms 
*                      2: 1000ms
*
* OUTPUTS:                 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_enhanced_ddeg_interval_set(digi_handle_t                 *digi_handle,
                                                         digi_otn_odu_chnl_t           *chnl_ptr,
                                                         odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                         UINT8                          mon_interval) 
{
    PMC_ERROR result = PMC_SUCCESS;
    odu_struct_frm_id_t odu_frm_id;
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_chnl;
    UINT16 tcm_pool_id;
    UINT32 chnl_msk_idx;
    UINT32 chnl_bit_idx;
    UINT32 i;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk;
    BOOL8 configured;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if ((mon_interval > 2) || (pm_tcm_num > ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM_NIM))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }

    /* throw an error if the enhanced dDEG is not configured */
    result = coreotn_ddeg_mode_get(digi_handle->coreotn_handle, 
                                   COREOTN_HARDWARE_DDEG,
                                   &configured);
                                          
    if (PMC_SUCCESS != result)
    {
        PMC_ATOMIC_RETURN(digi_handle, result);
    }

    if ((PMC_SUCCESS == result) && (TRUE == configured)) 
    {
        PMC_ATOMIC_RETURN(digi_handle, COREOTN_ERR_ENH_DDEG_NOT_ENABLED);
    }
    
    /* initialize channel mask */
    for (i = 0; i < 8; i++)
    {
        ddeg_chnl.chnl_bitmsk[i] = 0;
    }
       
    /* create a channel mask; only one channel at a time */
    if (pm_tcm_num == ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM)
    {
        chnl_msk_idx = (((odu_struct_t *)chnl_ptr)->switch_data.oduk_data.channel) / 32;
        chnl_bit_idx = (((odu_struct_t *)chnl_ptr)->switch_data.oduk_data.channel) % 32;
        
        ddeg_chnl.chnl_bitmsk[chnl_msk_idx] = (ddeg_chnl.chnl_bitmsk[chnl_msk_idx]) | (1 << chnl_bit_idx);
    }
    else {
        /* create pid mask */
        result = odu_struct_tcm_pool_id_from_instance_get(digi_handle->coreotn_handle,
                                                          (odu_struct_t *)chnl_ptr, ODU_STRUCT_STREAM_RX,
                                                          pm_tcm_num, &tcm_pool_id); 
        if (PMC_SUCCESS == result)
        {
            chnl_msk_idx = tcm_pool_id / 32;
            chnl_bit_idx = tcm_pool_id % 32;
            
            ddeg_chnl.chnl_bitmsk[chnl_msk_idx] = (ddeg_chnl.chnl_bitmsk[chnl_msk_idx]) | (1 << chnl_bit_idx);
        }
    }
    
    if (PMC_SUCCESS == result)
    {
        odu_frm_id = odu_struct_frm_id_get(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr);
    }                                          
    
    if (PMC_SUCCESS == result && LAST_ODU_STRUCT_FRM_ID != odu_frm_id)
    {
        /* convert to digi_pmon_ddeg_hw_block_t */
        result = digi_otn_pmon_ddeg_hw_blk_get(digi_handle, odu_frm_id, 
                                               pm_tcm_num, &ddeg_hw_blk);
                                               
        if (PMC_SUCCESS == result && ddeg_hw_blk != DIGI_PMON_DDEG_HW_BLOCK_MAX_NUM)
        {                                                             
            /* Based on the odu_frm_id, set ddeg_hw_block ; need to set for both pm and tcmi
            ** read from chnl_ptr->chnl_id and set ddeg_chnl mask
            ** set mon_intvl = mon_interval
            ** set mon_intvl_valid = TRUE 
            ** rest is FALSE*/ 
                                        
            result = digi_pmon_ddeg_param_cfg(digi_handle,
                                              DIGI_PMON_DDEG_MODE_ENH, ddeg_hw_blk,
                                              ddeg_chnl, mon_interval, 0, 0,
                                              TRUE, FALSE, FALSE);
        }        
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_enhanced_ddeg_interval_set */


/*******************************************************************************
* digi_otn_odu_enhanced_ddeg_interval_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Used to get the monitoring interval for the enhanced dDEG report.
*   It is nessecary to call digi_otn_odu_set_ddeg_mode with 
*   ddeg_mode == DIGI_OTN_ENHANCED_DDEG if you want to use the enhanced dDEG
*   feature.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance  
*   *chnl_ptr       - pointer to ODU channel                      
*   pm_tcm_num      - enum for PM/TCMi instances. See odu_struct_odu_frm_pm_tcm_id_t
*                     ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_DCI is invalid. 
*                          
* OUTPUTS:                 
*   mon_interval    - Monitoring interval for enhanced dDEG in milliseconds
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_enhanced_ddeg_interval_get(digi_handle_t                 *digi_handle,
                                                         digi_otn_odu_chnl_t           *chnl_ptr,
                                                         odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                         UINT8                         *mon_interval) 
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_param_t digi_pmon_ddeg_param;
    odu_struct_frm_id_t odu_frm_id;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk;
    UINT32 ddeg_chnl;
    BOOL8 configured;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);
    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    /* throw an error if the enhanced dDEG is not configured */
    result = coreotn_ddeg_mode_get(digi_handle->coreotn_handle, 
                                   COREOTN_ENHANCED_DDEG,
                                   &configured);
    
    if (PMC_SUCCESS == result)
    {
        if (FALSE == configured)
        {
            PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_DDEG_NOT_CONFIGURED);            
        }
    }
    
    /* retrieve the current ddeg interval configured in FW */
    if (PMC_SUCCESS == result)
    {
        odu_frm_id = odu_struct_frm_id_get(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr);
    }                                          
    
    if (PMC_SUCCESS == result && LAST_ODU_STRUCT_FRM_ID != odu_frm_id)
    {
        /* convert to digi_pmon_ddeg_hw_block_t */
        result = digi_otn_pmon_ddeg_hw_blk_get(digi_handle, odu_frm_id, 
                                               pm_tcm_num, &ddeg_hw_blk);
                             
        /* compute ddeg channel */ 
        if (PMC_SUCCESS == result && ddeg_hw_blk != DIGI_PMON_DDEG_HW_BLOCK_MAX_NUM)
        {                  
            result = digi_otn_odu_deg_chnl_get(digi_handle, chnl_ptr, pm_tcm_num, &ddeg_chnl);
            
            if (PMC_SUCCESS == result)
            {
                result = digi_pmon_ddeg_param_get(digi_handle, DIGI_PMON_DDEG_MODE_ENH,
                                                  ddeg_hw_blk, 
                                                  ddeg_chnl,
                                                  &digi_pmon_ddeg_param);
            }

            if (PMC_SUCCESS == result)
            {
                *mon_interval = digi_pmon_ddeg_param.mon_intvl;                                               
            }
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_enhanced_ddeg_interval_get */

/*******************************************************************************
* digi_otn_odu_enhanced_ddeg_th_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Used to configure the set the clear thresholds the enhanced dDEG report.
*   
*   Prior to calling this API, digi_otn_odu_ddeg_mode_set() must be called with 
*   'ddeg_mode' == DIGI_OTN_ENHANCED_DDEG to enable enhanced dDEG on all ODU
*   receive framers.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance    
*   *chnl_ptr       - pointer to ODU channel       
*   pm_tcm_num      - enum for PM/TCMi instances. See odu_struct_odu_frm_pm_tcm_id_t
*                     ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_DCI is invalid.           
*   set_threshold   - number of errored blocks required to declare a bad interval
*   clear_threshold - after the detection of a bad interval, this threshold \n
*                     is used to determine that an interval is good
*
* OUTPUTS:                 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_enhanced_ddeg_th_set(digi_handle_t                 *digi_handle,
                                                   digi_otn_odu_chnl_t           *chnl_ptr,
                                                   odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                   UINT32 set_threshold,
                                                   UINT32 clear_threshold) 
{
    PMC_ERROR result = PMC_SUCCESS;
    odu_struct_frm_id_t odu_frm_id;
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_chnl;
    UINT16 tcm_pool_id;
    UINT32 chnl_msk_idx;
    UINT32 chnl_bit_idx;
    UINT32 i;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk;
    BOOL8 configured;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);
    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));

    if (clear_threshold >= set_threshold)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }

    /* throw an error if the enhanced dDEG is not configured */
    result = coreotn_ddeg_mode_get(digi_handle->coreotn_handle, 
                                   COREOTN_HARDWARE_DDEG,
                                   &configured);
                                          
    if (PMC_SUCCESS != result)
    {
        PMC_ATOMIC_RETURN(digi_handle, result);
    }

    if ((PMC_SUCCESS == result) && (TRUE == configured)) 
    {
        PMC_ATOMIC_RETURN(digi_handle, COREOTN_ERR_ENH_DDEG_NOT_ENABLED);
    }
    
    /* initialize channel mask */
    for (i = 0; i < 8; i++)
    {
        ddeg_chnl.chnl_bitmsk[i] = 0;
    }
       
    /* create a channel mask; only one channel at a time */
    if (pm_tcm_num == ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM)
    {
        chnl_msk_idx = (((odu_struct_t *)chnl_ptr)->switch_data.oduk_data.channel) / 32;
        chnl_bit_idx = (((odu_struct_t *)chnl_ptr)->switch_data.oduk_data.channel) % 32;
        
        ddeg_chnl.chnl_bitmsk[chnl_msk_idx] = (ddeg_chnl.chnl_bitmsk[chnl_msk_idx]) | (1 << chnl_bit_idx);
    }
    else {
        /* create pid mask */
        result = odu_struct_tcm_pool_id_from_instance_get(digi_handle->coreotn_handle,
                                                          (odu_struct_t *)chnl_ptr, ODU_STRUCT_STREAM_RX,
                                                          pm_tcm_num, &tcm_pool_id); 
        if (PMC_SUCCESS == result)
        {
            chnl_msk_idx = tcm_pool_id / 32;
            chnl_bit_idx = tcm_pool_id % 32;
            
            ddeg_chnl.chnl_bitmsk[chnl_msk_idx] = (ddeg_chnl.chnl_bitmsk[chnl_msk_idx]) | (1 << chnl_bit_idx);
        }
    }
    
    if (PMC_SUCCESS == result)
    {
        odu_frm_id = odu_struct_frm_id_get(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr);
    }                                          
    
    if (PMC_SUCCESS == result && LAST_ODU_STRUCT_FRM_ID != odu_frm_id)
    {
        /* convert to digi_pmon_ddeg_hw_block_t */
        result = digi_otn_pmon_ddeg_hw_blk_get(digi_handle, odu_frm_id, 
                                               pm_tcm_num, &ddeg_hw_blk);
                                               
        if (PMC_SUCCESS == result && ddeg_hw_blk != DIGI_PMON_DDEG_HW_BLOCK_MAX_NUM)
        {                                                             
        /* Based on the odu_frm_id, set ddeg_hw_block ; need to set for both pm and tcmi
        ** read from chnl_ptr->chnl_id and set ddeg_chnl mask
        ** set mon_intvl = mon_interval
        ** set mon_intvl_valid = TRUE 
        ** rest is FALSE*/ 
                                        
            result = digi_pmon_ddeg_param_cfg(digi_handle,
                                              DIGI_PMON_DDEG_MODE_ENH, ddeg_hw_blk,
                                              ddeg_chnl, 
                                              0, set_threshold, clear_threshold,
                                              FALSE, TRUE, TRUE);
        }                 
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_enhanced_ddeg_th_set */

/*******************************************************************************
* digi_otn_odu_enhanced_ddeg_th_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Used to get the set and the clear thresholds for the enhanced dDEG report.
*
*   It is nessecary to call digi_otn_odu_set_ddeg_mode with 
*   ddeg_mode == DIGI_OTN_ENHANCED_DDEG if you want to use the enhanced dDEG
*   feature.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance  
*   *chnl_ptr       - pointer to ODU channel                      
*   pm_tcm_num      - enum for PM/TCMi instances. See odu_struct_odu_frm_pm_tcm_id_t
*                     ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_DCI is invalid. 
*                          
* OUTPUTS:                 
*   *set_threshold   - number of errored blocks required to declare a bad interval
*   *clear_threshold - after the detection of a bad interval, this threshold \n
*                      is used to determine that an interval is good
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_enhanced_ddeg_th_get(digi_handle_t                 *digi_handle,
                                                   digi_otn_odu_chnl_t           *chnl_ptr,
                                                   odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                   UINT32 *set_threshold,
                                                   UINT32 *clear_threshold)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_param_t digi_pmon_ddeg_param;
    odu_struct_frm_id_t odu_frm_id;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk;
    UINT32 ddeg_chnl;
    BOOL8 configured;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);
    /* check handle provisioning state */
    DIGI_SWITCH_DATA_HANDLE_PROV_CHECK(digi_handle, (&((odu_struct_t *)chnl_ptr)->switch_data));
    
    /* throw an error if the enhanced dDEG is not configured */
    result = coreotn_ddeg_mode_get(digi_handle->coreotn_handle, 
                                   COREOTN_ENHANCED_DDEG,
                                   &configured);
    
    if (PMC_SUCCESS == result)
    {
        if (FALSE == configured)
        {
            PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_DDEG_NOT_CONFIGURED);            
        }
    }
    
    /* retrieve the current ddeg interval configured in FW */
    if (PMC_SUCCESS == result)
    {
        odu_frm_id = odu_struct_frm_id_get(digi_handle->coreotn_handle,
                                           (odu_struct_t *)chnl_ptr);
    }                                          
    
    if (PMC_SUCCESS == result && LAST_ODU_STRUCT_FRM_ID != odu_frm_id)
    {
        /* convert to digi_pmon_ddeg_hw_block_t */
        result = digi_otn_pmon_ddeg_hw_blk_get(digi_handle, odu_frm_id, 
                                               pm_tcm_num, &ddeg_hw_blk);
                             
        /* compute ddeg channel */ 
        if (PMC_SUCCESS == result && ddeg_hw_blk != DIGI_PMON_DDEG_HW_BLOCK_MAX_NUM)
        {                  
            result = digi_otn_odu_deg_chnl_get(digi_handle, chnl_ptr, pm_tcm_num, &ddeg_chnl);
            
            if (PMC_SUCCESS == result)
            {
                result = digi_pmon_ddeg_param_get(digi_handle, DIGI_PMON_DDEG_MODE_ENH,
                                                  ddeg_hw_blk, 
                                                  ddeg_chnl,
                                                  &digi_pmon_ddeg_param);
            }

            if (PMC_SUCCESS == result)
            {
                *set_threshold = digi_pmon_ddeg_param.set_threshold;
                *clear_threshold = digi_pmon_ddeg_param.clear_threshold;
            }
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_enhanced_ddeg_th_get */

/*******************************************************************************
* digi_otn_otu_enhanced_ddeg_interval_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Used to configure the monitoring interval for the enhanced dDEG report.
*   
*   Prior to calling this API, digi_otn_otu_ddeg_mode_set() must be called with 
*   'ddeg_mode' == DIGI_OTN_ENHANCED_DDEG to enable enhanced dDEG on all ODU
*   receive framers.
*   Then digi_otn_otu_deg_m_set() needs to be called to configure monitoring 
*   interval
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance    
*   otn_server_ptr  - pointer to a resource allocation
*                     context for the OTN server configured against the
*                     specified serdes port.pointer to ODU channel       
*   mon_interval    - Monitoring interval for enhanced dDEG
*                     The following values are valid:
*                      0: 10ms  
*                      1: 100ms 
*                      2: 1000ms
*
* OUTPUTS:                 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_enhanced_ddeg_interval_set(digi_handle_t *digi_handle,
                                                         digi_otn_server_chnl_t *otn_server_ptr,
                                                         UINT8 mon_interval) 
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_chnl, *ddeg_chnl_ptr = &ddeg_chnl;;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    
    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, otn_server_ptr, result, TRUE);
    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    if (mon_interval > 2)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }

    /* if HW ddeg is on, return an error */
    if (DIGI_OTN_HARDWARE_DDEG == digi_handle->var.linesys_ddeg_mode)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_ENH_DDEG_NOT_ENABLED);
    }

    PMC_MEMSET(ddeg_chnl_ptr,0, sizeof(digi_pmon_ddeg_chnl_bitmsk_t));

    if (TRUE == DIGI_OTN_SERVER_IS_LINE(otn_server_ptr))
    {
        ddeg_hw_blk = DIGI_PMON_DDEG_LINEOTN;
        ddeg_chnl.chnl_bitmsk[0] = (0x1 << otn_srvr_ptr->dci_chnl);
    } else 
    {     
        ddeg_hw_blk = DIGI_PMON_DDEG_SYSOTN;
        ddeg_chnl.chnl_bitmsk[0] = 0x1;
    }
                                                  
    /* configure interval */
    result = digi_pmon_ddeg_param_cfg(digi_handle,
                                      DIGI_PMON_DDEG_MODE_ENH, ddeg_hw_blk,
                                      ddeg_chnl, mon_interval, 0, 0,
                                      TRUE, FALSE, FALSE);
        

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_otu_enhanced_ddeg_interval_set */

/*******************************************************************************
* digi_otn_otu_enhanced_ddeg_interval_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Used to get the monitoring interval for the enhanced dDEG report.
*   It is nessecary to call digi_otn_odu_set_ddeg_mode with 
*   ddeg_mode == DIGI_OTN_ENHANCED_DDEG if you want to use the enhanced dDEG
*   feature.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance  
*   otn_server_ptr  - pointer to a resource allocation
*                     context for the OTN server configured against the
*                     specified serdes port.pointer to ODU channel       
*                          
* OUTPUTS:                 
*   mon_interval    - Monitoring interval for enhanced dDEG in milliseconds
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_enhanced_ddeg_interval_get(digi_handle_t *digi_handle,
                                                         digi_otn_server_chnl_t *otn_server_ptr,
                                                         UINT8 *mon_interval) 
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_param_t digi_pmon_ddeg_param;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    
    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, otn_server_ptr, result, TRUE);
    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    /* if HW ddeg is on, return an error */
    if (DIGI_OTN_HARDWARE_DDEG == digi_handle->var.linesys_ddeg_mode)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_ENH_DDEG_NOT_ENABLED);
    }

    if (TRUE == DIGI_OTN_SERVER_IS_LINE(otn_server_ptr))
    {
        ddeg_hw_blk = DIGI_PMON_DDEG_LINEOTN;    
    } else 
    {     
        ddeg_hw_blk = DIGI_PMON_DDEG_SYSOTN;
    }
                                       
    result = digi_pmon_ddeg_param_get(digi_handle, DIGI_PMON_DDEG_MODE_ENH,
                                      ddeg_hw_blk, 
                                      otn_srvr_ptr->dci_chnl,
                                      &digi_pmon_ddeg_param);
    
    if (PMC_SUCCESS == result)
    {
        *mon_interval = digi_pmon_ddeg_param.mon_intvl; 
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_otu_enhanced_ddeg_interval_get */

/*******************************************************************************
* digi_otn_otu_enhanced_ddeg_th_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Used to configure the set anbd the clear thresholds for the enhanced dDEG report.
*   
*   Prior to calling this API, digi_otn_otu_ddeg_mode_set() must be called with 
*   'ddeg_mode' == DIGI_OTN_ENHANCED_DDEG to enable enhanced dDEG on all ODU
*   receive framers.
*
* 
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance    
*   otn_server_ptr  - pointer to a resource allocation
*                     context for the OTN server configured against the
*                     specified serdes port.pointer to ODU channel       
*   set_threshold   - number of errored blocks required to declare a bad interval
*   clear_threshold - after the detection of a bad interval, this threshold \n
*                     is used to determine that an interval is good
*
* OUTPUTS:                 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_enhanced_ddeg_th_set(digi_handle_t *digi_handle,
                                                   digi_otn_server_chnl_t *otn_server_ptr,
                                                   UINT32 set_threshold,
                                                   UINT32 clear_threshold)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_chnl_bitmsk_t ddeg_chnl, *ddeg_chnl_ptr = &ddeg_chnl;;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    
    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, otn_server_ptr, result, TRUE);
    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

    if (clear_threshold >= set_threshold)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }

    /* if HW ddeg is on, return an error */
    if (DIGI_OTN_HARDWARE_DDEG == digi_handle->var.linesys_ddeg_mode)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_ENH_DDEG_NOT_ENABLED);
    }

    PMC_MEMSET(ddeg_chnl_ptr,0, sizeof(digi_pmon_ddeg_chnl_bitmsk_t));

    if (TRUE == DIGI_OTN_SERVER_IS_LINE(otn_server_ptr))
    {
        ddeg_hw_blk = DIGI_PMON_DDEG_LINEOTN;
        ddeg_chnl.chnl_bitmsk[0] = (0x1 << otn_srvr_ptr->dci_chnl);
    } else 
    {     
        ddeg_hw_blk = DIGI_PMON_DDEG_SYSOTN;
        ddeg_chnl.chnl_bitmsk[0] = 0x1;
    }
                                                  
    /* configure interval */
    result = digi_pmon_ddeg_param_cfg(digi_handle,
                                      DIGI_PMON_DDEG_MODE_ENH, ddeg_hw_blk,
                                      ddeg_chnl, 0, set_threshold, clear_threshold,
                                      FALSE, TRUE, TRUE);
        
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_otu_enhanced_ddeg_th_set */

/*******************************************************************************
* digi_otn_otu_enhanced_ddeg_th_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Used to get the set and clear thresholds for the enhanced dDEG report.
*   It is nessecary to call digi_otn_odu_set_ddeg_mode with 
*   ddeg_mode == DIGI_OTN_ENHANCED_DDEG if you want to use the enhanced dDEG
*   feature.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance  
*   otn_server_ptr  - pointer to a resource allocation
*                     context for the OTN server configured against the
*                     specified serdes port.pointer to ODU channel       
*                          
* OUTPUTS:                 
*   *set_threshold   - number of errored blocks required to declare a bad interval
*   *clear_threshold - after the detection of a bad interval, this threshold \n
*                      is used to determine that an interval is good
*   
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_enhanced_ddeg_th_get(digi_handle_t *digi_handle,
                                                   digi_otn_server_chnl_t *otn_server_ptr,
                                                   UINT32 *set_threshold,
                                                   UINT32 *clear_threshold)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_pmon_ddeg_param_t digi_pmon_ddeg_param;
    digi_otn_ddeg_mode_t ddeg_mode;
    digi_pmon_ddeg_hw_block_t ddeg_hw_blk;
    digi_otn_server_chnl_def_t *otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otn_srvr_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    
    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, otn_server_ptr, result, TRUE);
    /* check handle provisioning state */
    DIGI_OTN_SERVER_CHNL_HANDLE_PROV_CHECK(digi_handle, otn_srvr_ptr);

     /* get current mode */
    ddeg_mode   = digi_handle->var.linesys_ddeg_mode;
    if (TRUE == DIGI_OTN_SERVER_IS_LINE(otn_server_ptr))
    {
        ddeg_hw_blk = DIGI_PMON_DDEG_LINEOTN;    
    } else 
    {     
        ddeg_hw_blk = DIGI_PMON_DDEG_SYSOTN;
    }
                                       
    /* if HW ddeg is on, return an error */
    if (ddeg_mode != DIGI_OTN_ENHANCED_DDEG)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_ENH_DDEG_NOT_ENABLED);
    }
    result = digi_pmon_ddeg_param_get(digi_handle, DIGI_PMON_DDEG_MODE_ENH,
                                      ddeg_hw_blk, 
                                      otn_srvr_ptr->dci_chnl,
                                      &digi_pmon_ddeg_param);
    
    if (PMC_SUCCESS == result)
    {
        *set_threshold = digi_pmon_ddeg_param.set_threshold;
        *clear_threshold = digi_pmon_ddeg_param.clear_threshold;
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_otu_enhanced_ddeg_th_get */

/*******************************************************************************
* digi_otn_otu_hw_ddeg_mon_enable
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enable/disable LCLK configuration to trigger capture of PMON data
*   for hardware dDEG.
*
*   Prior to calling this API, the following APIs must have been called to 
*   properly configure dDEG monitoring variables and set the monitoring mode. 
*   - digi_otn_otu_ddeg_mode_set() to set ddeg_mode to DIGI_OTN_HARDWARE_DDEG
*   - digi_otn_otu_deg_m_set() to set DEG_M in bursty mode
*   - digi_otn_otu_deg_th_set() to set DEG threshold.
*   digi_otn_otu_ddeg_mon_enable() should not be called if HW dDEG is used
*   since that API is only for enabling FW based enhanced and bursty dDEG.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   enable              - Enable or disable LCLK configuration for 
*                         hardware dDEG
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_otu_hw_ddeg_mon_enable(digi_handle_t           *digi_handle,
                                                 BOOL                     enable)
{
    PMC_ERROR               result = PMC_SUCCESS;
    digi_otn_ddeg_mode_t    ddeg_mode;
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_ATOMIC_ENTRY(digi_handle);

    /* if HW dDEG is configured then call FW to enable/disable LCLK */
    result = digi_otn_otu_ddeg_mode_get(digi_handle, &ddeg_mode);
 
    if ((PMC_SUCCESS == result) &&
        (DIGI_OTN_HARDWARE_DDEG != ddeg_mode))
    {
        result = DIGI_ERR_HW_DDEG_NOT_ENABLED;
    }

    if (PMC_SUCCESS == result)
    {
        result = digi_pmon_ddeg_cfg_hw_ddeg_lclk(digi_handle, enable);
    }
            

    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_otu_hw_ddeg_mon_enable */



/*******************************************************************************
* digi_otn_odu_hw_ddeg_mon_enable
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enable/disable LCLK configuration to trigger capture of PMON data
*   for hardware dDEG.
*
*   Prior to calling this API, the following APIs must have been called to 
*   properly configure dDEG monitoring variables and set the monitoring mode. 
*   - digi_otn_odu_ddeg_mode_set() to set ddeg_mode to DIGI_OTN_HARDWARE_DDEG
*   - digi_otn_odu_deg_m_set() to set DEG_M in bursty mode
*   - digi_otn_odu_deg_th_set() to set DEG threshold.
*   digi_otn_odu_ddeg_mon_enable() should not be called if HW dDEG is used
*   since that API is only for enabling FW based enhanced and bursty dDEG.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   enable              - Enable or disable LCLK configuration for 
*                         hardware dDEG
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_hw_ddeg_mon_enable(digi_handle_t           *digi_handle,
                                                 BOOL                     enable)
{
    PMC_ERROR result = PMC_SUCCESS;
    BOOL8 configured;
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_ATOMIC_ENTRY(digi_handle);

    /* if HW dDEG is configured then call FW to enable/disable LCLK */
    result = coreotn_ddeg_mode_get(digi_handle->coreotn_handle, (coreotn_ddeg_mode_t)DIGI_OTN_HARDWARE_DDEG, &configured);    
 
    if (PMC_SUCCESS == result)
    {
        if (FALSE == configured)
        {
            result = DIGI_ERR_HW_DDEG_NOT_ENABLED;
        }
    }

    if (PMC_SUCCESS == result)
    {
        result = digi_pmon_ddeg_cfg_hw_ddeg_lclk(digi_handle, enable);
    }
            
    /* save ddeg monitor status in coreotn context */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_ddeg_status_set(digi_handle->coreotn_handle, 
                                         (coreotn_ddeg_mode_t)COREOTN_HARDWARE_DDEG,
                                         enable);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_odu_hw_ddeg_mon_enable */

/*******************************************************************************
* FUNCTION: digi_otn_pmon_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves an aggregation PMON table with PMON counters 
*   over multiple channels.
*
*   digi_otn_server_pmon_chnl_get() and digi_otn_odu_pmon_chnl_get() can be used
*   to retrieve a specific chnl table from the aggregation table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*
* OUTPUTS:
*   pmon_table_ptr  - pointer to aggregation PMON table to store counters 
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_pmon_retrieve(digi_handle_t      *digi_handle,
                                        digi_otn_pmon_t    *pmon_table_ptr)
{
    PMC_ERROR                       result = PMC_SUCCESS;
    digi_otn_server_chnl_t         *server_handle;
    digi_otn_server_chnl_def_t     *server_def_handle;
    UINT32                          i;
    odu_struct_odu_level_t          odu_level[4];

    PMC_ATOMIC_ENTRY(digi_handle);

    result = digi_pmon_param_check(digi_handle, pmon_table_ptr); 

    if (PMC_SUCCESS == result)
    {
        PMC_MEMSET(pmon_table_ptr, 0, sizeof(digi_otn_pmon_t));
    }


    /* OTN Server - Line */
    if (PMC_SUCCESS == result)
    {
        for (i = 0; (i < DIGI_OTN_SERVER_CHNL_MAX) && (PMC_SUCCESS == result); i++)
        {
            server_handle = (digi_otn_server_chnl_def_t *) &digi_handle->handle_pool.otn_server_chnl[i];
            server_def_handle = (digi_otn_server_chnl_def_t *) server_handle;
           
            if (util_global_is_chnl_prov(server_def_handle))
            {
                pmon_table_ptr->otn_server_handle[i] = server_handle;
                result = digi_otn_server_pmon_chnl_retrieve_internal(digi_handle,
                                                                     server_handle,
                                                                     &pmon_table_ptr->otn_server_chnl[i]);
            }
        } /* end for */
    }
   


    /* OTN Server - System */
    if (PMC_SUCCESS == result)
    {
        for (i = 0; (i < DIGI_OTN_SERVER_SYS_CHNL_MAX) && (PMC_SUCCESS == result); i++)
        {
            server_handle = (digi_otn_server_chnl_def_t *) &digi_handle->handle_pool.sysotn_server_chnl;
            server_def_handle = (digi_otn_server_chnl_def_t *) server_handle;
           
            if (util_global_is_chnl_prov(server_def_handle))
            {
                pmon_table_ptr->sysotn_server_handle[i] = server_handle;
                result = digi_otn_server_pmon_chnl_retrieve_internal(digi_handle,
                                                                     server_handle,
                                                                     &pmon_table_ptr->sysotn_server_chnl[i]);
            }
        } /* end for */
    }




    odu_level[0] = ODU_STRUCT_LEVEL_HO_ODU;
    odu_level[1] = ODU_STRUCT_LEVEL_MO_ODU;
    odu_level[2] = ODU_STRUCT_LEVEL_LO_ODU;
    odu_level[3] = ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC;

    for (i = 0; (i < 4) && (PMC_SUCCESS == result); i++)
    {
        result = digi_otn_odu_pmon_retrieve(digi_handle,
                                            odu_level[i],
                                            pmon_table_ptr);
    } 




    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_pmon_retrieve */

/*******************************************************************************
* FUNCTION: digi_otn_server_pmon_chnl_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Given a channel handle and an aggregated PMON table, retrieve a pointer
*   to the corresponding channel PMON table.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to retrieve PMON on
*   pmon_table_ptr  - Aggregated PMON table
*
* OUTPUTS:
*   pmon_chnl_table_pptr - pointer to channel PMON table corresponding to channel
*                          handle. Set to NULL if channel has not been provisioned.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_pmon_chnl_get(digi_handle_t                *digi_handle,
                                               digi_otn_server_chnl_t       *chnl_handle,
                                               digi_otn_pmon_t              *pmon_table_ptr,
                                               digi_otn_server_pmon_chnl_t **pmon_chnl_table_pptr)
{
    PMC_ERROR       result = PMC_SUCCESS;
    UINT32          index;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != chnl_handle, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != pmon_table_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != pmon_chnl_table_pptr, DIGI_ERR_INVALID_ARG, 0, 0);

    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result, TRUE);

    /* Set return table to NULL */
    *pmon_chnl_table_pptr = NULL;

    /* Get index corresponding to handle */
    index = digi_lineotn_dci_chnl_get(digi_handle, chnl_handle);

    /* Set return table to channel table */
    if (pmon_table_ptr->otn_server_handle[index] == chnl_handle)
    {
        *pmon_chnl_table_pptr = &pmon_table_ptr->otn_server_chnl[index];
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_server_pmon_chnl_get */

/*******************************************************************************
* FUNCTION: digi_sysotn_server_pmon_chnl_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Given a channel handle and an aggregated PMON table, retrieve a pointer
*   to the corresponding channel PMON table.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to retrieve PMON on
*   pmon_table_ptr  - Aggregated PMON table
*
* OUTPUTS:
*   pmon_chnl_table_pptr - pointer to channel PMON table corresponding to channel
*                          handle. Set to NULL if channel has not been provisioned.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_sysotn_server_pmon_chnl_get(digi_handle_t                *digi_handle,
                                               digi_otn_server_chnl_t       *chnl_handle,
                                               digi_otn_pmon_t              *pmon_table_ptr,
                                               digi_otn_server_pmon_chnl_t **pmon_chnl_table_pptr)
{
    PMC_ERROR       result = PMC_SUCCESS;
    UINT32          index;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != chnl_handle, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != pmon_table_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != pmon_chnl_table_pptr, DIGI_ERR_INVALID_ARG, 0, 0);

    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result, TRUE);

    /* Set return table to NULL */
    *pmon_chnl_table_pptr = NULL;

    /* Get index corresponding to handle */
    index = digi_lineotn_dci_chnl_get(digi_handle, chnl_handle);

    /* Set return table to channel table */
    if (pmon_table_ptr->sysotn_server_handle[index] == chnl_handle)
    {
        *pmon_chnl_table_pptr = &pmon_table_ptr->sysotn_server_chnl[index];
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_sysotn_server_pmon_chnl_get */

/*******************************************************************************
* FUNCTION: digi_otn_odu_pmon_chnl_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Given a channel handle and an aggregated PMON table, retrieve a pointer
*   to the corresponding channel PMON table.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to retrieve PMON on
*   pmon_table_ptr  - Aggregated PMON table
*
* OUTPUTS:
*   pmon_chnl_table_pptr - pointer to channel PMON table corresponding to channel
*                          handle. Set to NULL if channel has not been provisioned.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_pmon_chnl_get(digi_handle_t                *digi_handle,
                                            digi_otn_odu_chnl_t          *chnl_handle,
                                            digi_otn_pmon_t              *pmon_table_ptr,
                                            digi_otn_odu_pmon_chnl_t    **pmon_chnl_table_pptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;
    UINT32                       index;
    odu_struct_odu_level_t       odu_level;
    digi_otn_odu_chnl_t        **table_handle[ODU_STRUCT_LEVEL_3B_ODU];
    digi_otn_odu_pmon_chnl_t    *table_pmon[ODU_STRUCT_LEVEL_3B_ODU];

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != chnl_handle, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != pmon_table_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != pmon_chnl_table_pptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result);

    /* Set up table with pointers to each odu level within the aggregated pmon table */
    table_handle[ODU_STRUCT_LEVEL_HO_ODU] = pmon_table_ptr->otn_odu_ho_handle;
    table_handle[ODU_STRUCT_LEVEL_MO_ODU] = pmon_table_ptr->otn_odu_mo_handle;
    table_handle[ODU_STRUCT_LEVEL_LO_ODU] = pmon_table_ptr->otn_odu_lo_handle;
    table_pmon[ODU_STRUCT_LEVEL_HO_ODU]   = pmon_table_ptr->otn_odu_ho_chnl;
    table_pmon[ODU_STRUCT_LEVEL_MO_ODU]   = pmon_table_ptr->otn_odu_mo_chnl;
    table_pmon[ODU_STRUCT_LEVEL_LO_ODU]   = pmon_table_ptr->otn_odu_lo_chnl;




    /* Set return table to NULL */
    *pmon_chnl_table_pptr = NULL;

    /* Get index corresponding to handle */
    index = digi_otn_odu_chnl_num_internal_get(digi_handle, chnl_handle);

    /* Get ODU level */
    odu_level = digi_otn_odu_level_internal_get(digi_handle, chnl_handle);
    PMC_ASSERT(odu_level < ODU_STRUCT_LEVEL_3B_ODU, DIGI_ERR_INVALID_ARG, odu_level, ODU_STRUCT_LEVEL_3B_ODU);

    /* Set return table to channel table */
    if (table_handle[odu_level][index] == chnl_handle)
    {
        *pmon_chnl_table_pptr = &table_pmon[odu_level][index];
    }

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_odu_pmon_chnl_get */


/*******************************************************************************
* FUNCTION: digi_otn_odu_chnl_num_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Given a HO/MO/LO otn odu channel handle, retrieves the channel number
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - OTN channel handle for HO/MO/LO framer
*
* OUTPUTS:
*
* RETURNS:
*   UINT32          - HO/MO/LO channel number
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_otn_odu_chnl_num_get(digi_handle_t              *digi_handle,
                                        digi_otn_odu_chnl_t        *chnl_handle)
{
    PMC_ERROR rc;
    UINT32  chnl = DIGI_OTN_ODU_CHNL_UNKNOWN;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    rc = NULL != chnl_handle ? digi_otn_odu_chnl_handle_validate(digi_handle, chnl_handle)  : DIGI_ERR_INVALID_ARG;
       
    if (PMC_SUCCESS == rc)
    {
        chnl = digi_otn_odu_chnl_num_internal_get(digi_handle,chnl_handle);
    }

    PMC_ATOMIC_RETURN(digi_handle,chnl);
} /* digi_otn_odu_chnl_num_get */

/*******************************************************************************
* FUNCTION: digi_otn_server_chnl_num_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Given an OTN server channel handle, retrieves the DCI channel number
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - OTN server channel handle
*
* OUTPUTS:
*
* RETURNS:
*   UINT32          - DCI channel number
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_otn_server_chnl_num_get(digi_handle_t              *digi_handle,
                                           digi_otn_server_chnl_t     *chnl_handle)
{
    PMC_ERROR rc;
    UINT32                          chnl = DIGI_OTN_ODU_CHNL_UNKNOWN;
   
    PMC_ATOMIC_ENTRY(digi_handle);
        
    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, rc, FALSE);

    if (PMC_SUCCESS == rc)
    {
        chnl =  digi_otn_server_chnl_num_internal_get(digi_handle,chnl_handle);
    }

    PMC_ATOMIC_RETURN(digi_handle,chnl);
} /* digi_otn_server_chnl_num_get */


/*******************************************************************************
* FUNCTION: digi_otn_server_stream_num_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Given an OTN server channel handle, retrieves the DSI stream number
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - OTN server channel handle
*
* OUTPUTS:
*
* RETURNS:
*   UINT32          - DSI stream number
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_otn_server_stream_num_get(digi_handle_t              *digi_handle,
                                             digi_otn_server_chnl_t     *chnl_handle)
{
    PMC_ERROR rc;
    UINT32                          chnl = DIGI_OTN_ODU_CHNL_UNKNOWN;
   
    PMC_ATOMIC_ENTRY(digi_handle);
        
    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, rc, FALSE);

    if (PMC_SUCCESS == rc)
    {
        chnl =  digi_otn_server_stream_num_internal_get(digi_handle, chnl_handle);
    }

    PMC_ATOMIC_RETURN(digi_handle,chnl);
} /* digi_otn_server_stream_num_get */

/*******************************************************************************
* FUNCTION: digi_otn_int_coreotn_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables Coreotn SS unchannelized interrupts based on bits that are set 
*   in the interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to interrupt table with bits set to
*                     enable interrupts.
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_int_coreotn_enable(digi_handle_t             *digi_handle,
                                             coreotn_int_t             *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    digi_otn_int_t          *int_en_table_ptr;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }

    /* Callback for interrupt table must be registered before enable ints */   
    if(!digi_int_is_cb_registered(digi_handle, DIGI_INT_TYPE_OTN))
    {
        result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
    }
    
    if (PMC_SUCCESS == result)
    {
        /* Get internal enabled interrupt table to check */
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);
    }

    /* enabled interrupts and update context interrupts enable table */
    if (PMC_SUCCESS == result)
    {  
        result = coreotn_int_enable(digi_handle->coreotn_handle,
                                    int_table_ptr,
                                    &int_en_table_ptr->coreotn,
                                    DIGI_ENABLE);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_int_coreotn_enable */

/*******************************************************************************
* FUNCTION: digi_otn_int_coreotn_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Disables Coreotn SS unchannelized interrupts based on bits that are set in the
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to interrupt table with bits set to
*                     enable interrupts.
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_int_coreotn_disable(digi_handle_t             *digi_handle,
                                              coreotn_int_t             *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    digi_otn_int_t          *int_en_table_ptr;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }
       
    if (PMC_SUCCESS == result)
    {  
        /* Get internal enabled interrupt table to check */
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);
    }
    
    /* enabled interrupts and update context interrupts enable table */
    if (PMC_SUCCESS == result)
    {  
        result = coreotn_int_enable(digi_handle->coreotn_handle,
                                    int_table_ptr,
                                    &int_en_table_ptr->coreotn,
                                    DIGI_DISABLE);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_int_coreotn_disable */


/*******************************************************************************
* FUNCTION: digi_otn_int_coreotn_filt_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves Coreotn SS unchannelized interrupt table.
*
*   The desired interrupt/status bits to retrieve (to reduce function execution
*   time) can be specified using the filter interrupt table input.
*
* INPUTS:
*   digi_handle        - pointer to DIGI handle instance.
*   filt_table_ptr     - filter interrupt table. 
*                        When NULL, all interrupts are retrieved.
*
* OUTPUTS:
*   int_table_ptr  - pointer to interrupt table to store interrupt
*                    information. 
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_int_coreotn_filt_retrieve(digi_handle_t  *digi_handle,
                                                    coreotn_int_t  *filt_table_ptr,
                                                    coreotn_int_t  *int_table_ptr)
{
    PMC_ERROR  result = PMC_SUCCESS;
 
    PMC_ATOMIC_ENTRY(digi_handle);

    if (TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        result = PMC_SUCCESS;
    }
    else if (NULL == int_table_ptr)
    {
        result = DIGI_ERR_INVALID_PTR;
    }
    else
    {
        PMC_MEMSET(int_table_ptr, 0, sizeof(coreotn_int_t)); 

        result = coreotn_int_retrieve(digi_handle->coreotn_handle, 
                                      filt_table_ptr,
                                      int_table_ptr);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_int_coreotn_filt_retrieve */

/*******************************************************************************
* FUNCTION: digi_otn_int_coreotn_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears Coreotn SS unchannelized interrupts based on bits that are set 
*   in the interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr      - pointer to interrupt table with bits to clear
*                        If NULL, clears all interrupts.
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_int_coreotn_clear(digi_handle_t        *digi_handle,
                                            coreotn_int_t        *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    digi_otn_int_t          *int_en_table_ptr = NULL;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }

    if (PMC_SUCCESS == result)
    {  
        /* Get internal enabled interrupt table to check */
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);
    }
    
    if (PMC_SUCCESS == result)
    {  
        result = coreotn_int_clear(digi_handle->coreotn_handle,
                                   int_table_ptr,
                                   &int_en_table_ptr->coreotn);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_int_coreotn_clear */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_rcp_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears DI_RCP block unchannelized interrupts based on bits that are set 
*   in the interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to interrupt table with bits set to
*                     enable interrupts.
*                     If NULL, clears all interrupts.
*   rcp_inst        - identify the RI or DI RCP instance.
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_rcp_clear(digi_handle_t        *digi_handle,
                                             odu_rcp_inst_t        rcp_inst,
                                             odu_rcp_int_t        *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    digi_otn_int_t          *int_en_table_ptr = NULL;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs parameters */
    if (LAST_ODU_RCP_INST  <= rcp_inst)
    {
        result = DIGI_ERR_INVALID_ARG;
    }

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }

    if (PMC_SUCCESS == result)
    {  
        /* Get internal enabled interrupt table to check */
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);
    }
    
    if (PMC_SUCCESS == result)
    {  
        result = coreotn_int_rcp_clear(digi_handle->coreotn_handle,
                                       rcp_inst,
                                       int_table_ptr,
                                       &int_en_table_ptr->di_rcp);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_rcp_clear */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ohp_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables OHP block channelized interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.   
*   ohp             - Specifies the OHP block 
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem and all ODU levels (HO/MO/LO)
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ohp_chnl_enable(digi_handle_t             *digi_handle,
                                                  odu_ohp_inst_t             ohp,
                                                  digi_otn_odu_chnl_t       *chnl_handle,
                                                  odu_ohp_int_chnl_t        *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result);

    /* call internal implementation of that enables or disabled OHP 
       channelized  interrupts */
    result = digi_otn_odu_int_ohp_chnl_enable_internal(digi_handle,
                                                       ohp,
                                                       chnl_handle,
                                                       int_table_ptr,
                                                       DIGI_ENABLE);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_ohp_chnl_enable */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ohp_chnl_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Disables OHP block channelized interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.   
*   ohp             - Specifies the OHP block 
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem and all ODU levels (HO/MO/LO)
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ohp_chnl_disable(digi_handle_t             *digi_handle,
                                                   odu_ohp_inst_t             ohp,
                                                   digi_otn_odu_chnl_t       *chnl_handle,
                                                   odu_ohp_int_chnl_t        *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result);

    /* call internal implementation of that enables or disabled OHP 
       channelized  interrupts */
    result = digi_otn_odu_int_ohp_chnl_enable_internal(digi_handle,
                                                       ohp,
                                                       chnl_handle,
                                                       int_table_ptr,
                                                       DIGI_DISABLE);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_ohp_chnl_disable */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ohp_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables OHP block unchannelized interrupts based on bits that are set 
*   in the interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   ohp             - Specifies the OHP block.
*   int_table_ptr   - pointer to interrupt table with bits set to
*                     enable interrupts.
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ohp_enable(digi_handle_t             *digi_handle,
                                             odu_ohp_inst_t             ohp,
                                             odu_ohp_int_t             *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    digi_otn_int_t          *int_en_table_ptr;
    odu_ohp_int_t           *ohp_int_en_table_ptr;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }

    /* Callback for interrupt table must be registered before enable ints */   
    if(!digi_int_is_cb_registered(digi_handle, DIGI_INT_TYPE_OTN) && 
       !digi_int_is_cb_registered(digi_handle, DIGI_INT_CHNL_TYPE_OTN_ODU))
    {
        result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
    }
    
    if (PMC_SUCCESS == result && ODU_OHP_LAST  <= ohp)
    {
        result = DIGI_ERR_INVALID_ARG;
    }

    if (PMC_SUCCESS == result)
    {
        /* Get internal enabled interrupt table to check */
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);
    }

    /* enabled interrupts and update context interrupts enable table */
    if (PMC_SUCCESS == result)
    {  
        ohp_int_en_table_ptr = digi_otn_ohp_int_ptr_get(ohp, int_en_table_ptr);
        
        if (NULL != ohp_int_en_table_ptr)
        {
            result = coreotn_int_ohp_enable(digi_handle->coreotn_handle,
                                            ohp,
                                            int_table_ptr,
                                            ohp_int_en_table_ptr,
                                            DIGI_ENABLE);
        }
    
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_ohp_enable */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ohp_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables OHP block unchannelized interrupts based on bits that are set in the
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   ohp             - Specifies the OHP block.
*   int_table_ptr   - pointer to interrupt table with bits set to
*                     enable interrupts.
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ohp_disable(digi_handle_t             *digi_handle,
                                              odu_ohp_inst_t             ohp,
                                              odu_ohp_int_t             *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    digi_otn_int_t              *int_en_table_ptr;
    odu_ohp_int_t              *ohp_int_en_table_ptr;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }

    if (ODU_OHP_LAST  <= ohp)
    {
        result = DIGI_ERR_INVALID_ARG;
    }

    if (PMC_SUCCESS == result)
    {  
        /* Get internal enabled interrupt table to check */
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);
    }
    
    /* enabled interrupts and update context interrupts enable table */
    if (PMC_SUCCESS == result)
    {  
        ohp_int_en_table_ptr = digi_otn_ohp_int_ptr_get(ohp, int_en_table_ptr);
        
        if (NULL != ohp_int_en_table_ptr)
        {
            result = coreotn_int_ohp_enable(digi_handle->coreotn_handle,
                                            ohp,
                                            int_table_ptr,
                                            ohp_int_en_table_ptr,
                                            DIGI_DISABLE);
        }
    
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_ohp_disable */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ohp_filt_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves OHP block unchannelized interrupt table.
*
*   The desired interrupt/status bits to retrieve (to reduce function execution
*   time) can be specified using the filter interrupt table input.
*
* INPUTS:
*   digi_handle        - pointer to DIGI handle instance.
*   ohp                - Specifies the OHP block.
*   filt_table_ptr     - filter interrupt table. 
*                        When NULL, all interrupts are retrieved.
*
* OUTPUTS:
*   int_table_ptr  - pointer to interrupt table to store interrupt
*                    information. 
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ohp_filt_retrieve(digi_handle_t              *digi_handle,
                                                    odu_ohp_inst_t              ohp,
                                                    odu_ohp_int_t              *filt_table_ptr,
                                                    odu_ohp_int_t              *int_table_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
 
    PMC_ATOMIC_ENTRY(digi_handle);    

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        result = PMC_SUCCESS;
    }
    else if (NULL == int_table_ptr)
    {
        result = DIGI_ERR_INVALID_PTR;
    }
    else if (ODU_OHP_LAST <= ohp)
    {
        result = DIGI_ERR_INVALID_ARG;
    }
    else
    {
        PMC_MEMSET(int_table_ptr, 0, sizeof(odu_ohp_int_t)); 
        /* enable interrupt caching, clear cache */
        pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, TRUE, TRUE);

        result = coreotn_int_ohp_retrieve(digi_handle->coreotn_handle, 
                                          ohp,
                                          filt_table_ptr,
                                          int_table_ptr);

        /* disable interrupt caching */
        pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, FALSE, FALSE);
    }

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_odu_int_ohp_filt_retrieve */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ohp_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears OHP unchannelized interrupts based on bits that are set in the given
*   interrupt table.
*
* INPUTS:
*   digi_handle        - pointer to DIGI handle instance.       
*   ohp                - Specifies which OHP block (see odu_ohp_inst_t)
*   int_table_ptr      - pointer to interrupt table with bits to clear
*                        If NULL, clears all interrupts.
*
* OUTPUTS:
*  NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ohp_clear(digi_handle_t     *digi_handle,
                                            odu_ohp_inst_t     ohp,
                                            odu_ohp_int_t     *int_table_ptr)
{      
    PMC_ERROR          result = PMC_SUCCESS;
    digi_otn_int_t    *int_en_table_ptr;
    odu_ohp_int_t     *ohp_int_en_table_ptr = NULL;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }

    
    if (PMC_SUCCESS == result && ODU_OHP_LAST  <= ohp)
    {
        result = DIGI_ERR_INVALID_ARG;
    }

    if (PMC_SUCCESS == result)
    {
        /* Get internal enabled interrupt table to check */
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);
        if (NULL != int_en_table_ptr)
        {
            ohp_int_en_table_ptr = digi_otn_ohp_int_ptr_get(ohp, int_en_table_ptr);
        }
    }
    
    if (PMC_SUCCESS == result &&
        NULL != ohp_int_en_table_ptr)
    {
        result = coreotn_int_ohp_clear(digi_handle->coreotn_handle,
                                       ohp,
                                       int_table_ptr,
                                       ohp_int_en_table_ptr);
    }
        
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_ohp_clear */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ri_rcp_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables RI_RCP block channelized interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.   
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem and all ODU levels (HO/MO/LO)
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ri_rcp_chnl_enable(digi_handle_t             *digi_handle,
                                                     digi_otn_odu_chnl_t       *chnl_handle,
                                                     odu_ri_rcp_int_chnl_t     *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result);

    result = digi_otn_odu_int_ri_rcp_chnl_enable_internal(digi_handle,
                                                          chnl_handle,
                                                          int_table_ptr,
                                                          DIGI_ENABLE);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_ri_rcp_chnl_enable */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ri_rcp_chnl_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Disables RI_RCP block channelized interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.   
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem and all ODU levels (HO/MO/LO)
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ri_rcp_chnl_disable(digi_handle_t             *digi_handle,
                                                      digi_otn_odu_chnl_t       *chnl_handle,
                                                      odu_ri_rcp_int_chnl_t     *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result);

    result = digi_otn_odu_int_ri_rcp_chnl_enable_internal(digi_handle,
                                                          chnl_handle,
                                                          int_table_ptr,
                                                          DIGI_DISABLE);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_ri_rcp_chnl_disable */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ri_rcp_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables RI_RCP block unchannelized interrupts based on bits that are set 
*   in the interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to interrupt table with bits set to
*                     enable interrupts.
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ri_rcp_enable(digi_handle_t          *digi_handle,
                                                odu_rcp_int_t          *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    digi_otn_int_t          *int_en_table_ptr = NULL;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }

    /* Callback for interrupt table must be registered before enable ints */   
    if(!digi_int_is_cb_registered(digi_handle, DIGI_INT_TYPE_OTN) && 
       !digi_int_is_cb_registered(digi_handle, DIGI_INT_CHNL_TYPE_OTN_ODU))
    {
        result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
    }
    
    if (PMC_SUCCESS == result)
    {
        /* Get internal enabled interrupt table to check */
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);
    }
    
    if (PMC_SUCCESS == result)
    {  
        result = coreotn_int_rcp_enable(digi_handle->coreotn_handle,
                                        ODU_RCP_RI_INST,
                                        int_table_ptr,
                                        &int_en_table_ptr->ri_rcp,
                                        DIGI_ENABLE);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_ri_rcp_enable */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ri_rcp_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables RI_RCP block unchannelized interrupts based on bits that are set in the
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to interrupt table with bits set to
*                     enable interrupts.
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ri_rcp_disable(digi_handle_t             *digi_handle,
                                                 odu_rcp_int_t             *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    digi_otn_int_t          *int_en_table_ptr = NULL;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }


    if (PMC_SUCCESS == result)
    {
        /* Get internal enabled interrupt table to check */
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);
    }

    if (PMC_SUCCESS == result)
    {  
        
        result = coreotn_int_rcp_enable(digi_handle->coreotn_handle,
                                        ODU_RCP_RI_INST,
                                        int_table_ptr,
                                        &int_en_table_ptr->ri_rcp,
                                        DIGI_DISABLE);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_ri_rcp_disable */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ri_rcp_filt_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves RI_RCP block unchannelized interrupt table.
*
*   The desired interrupt/status bits to retrieve (to reduce function execution
*   time) can be specified using the filter interrupt table input.
*
* INPUTS:
*   digi_handle             - pointer to DIGI handle instance.
*  filt_table_ptr           - filter interrupt table. 
*                             When NULL, all interrupts are retrieved.
*
* OUTPUTS:
*   int_table_ptr  - pointer to interrupt table to store interrupt
*                    information. 
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ri_rcp_filt_retrieve(digi_handle_t       *digi_handle,
                                                       odu_rcp_int_t       *filt_table_ptr,
                                                       odu_rcp_int_t       *int_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
 
    PMC_ATOMIC_ENTRY(digi_handle);    

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }

    if (PMC_SUCCESS == result)
    {
        PMC_MEMSET((void *)int_table_ptr, 0, sizeof(odu_rcp_int_t));   
        
        /* enable interrupt caching, clear cache */
        pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, TRUE, TRUE);

        result = coreotn_int_rcp_retrieve(digi_handle->coreotn_handle, 
                                          ODU_RCP_RI_INST,
                                          filt_table_ptr,
                                          int_table_ptr);

        /* disable interrupt caching */
        pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, FALSE, FALSE);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_ri_rcp_filt_retrieve */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ri_rcp_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears RI RCP block unchannelized interrupts based on bits that are set 
*   in the interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to interrupt table with bits set to
*                     enable interrupts.
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ri_rcp_clear(digi_handle_t        *digi_handle,
                                               odu_rcp_int_t        *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_rcp_clear(digi_handle, 
                                            ODU_RCP_RI_INST,
                                            int_table_ptr);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_ri_rcp_clear */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_di_rcp_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables DI RCP block unchannelized interrupts based on bits that are set 
*   in the interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to interrupt table with bits set to
*                     enable interrupts.
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_di_rcp_enable(digi_handle_t          *digi_handle,
                                                odu_rcp_int_t          *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    digi_otn_int_t          *int_en_table_ptr = NULL;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }

    /* Callback for interrupt table must be registered before enable ints */   
    if(!digi_int_is_cb_registered(digi_handle, DIGI_INT_TYPE_OTN) && 
       !digi_int_is_cb_registered(digi_handle, DIGI_INT_CHNL_TYPE_OTN_ODU))
    {
        result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
    }
    
    if (PMC_SUCCESS == result)
    {
        /* Get internal enabled interrupt table to check */
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);
    }

    if (PMC_SUCCESS == result)
    {  
        result = coreotn_int_rcp_enable(digi_handle->coreotn_handle,
                                        ODU_RCP_DI_INST,
                                        int_table_ptr,
                                        &int_en_table_ptr->di_rcp,
                                        DIGI_ENABLE);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_di_rcp_enable */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_di_rcp_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables DI RCP block unchannelized interrupts based on bits that are set in the
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to interrupt table with bits set to
*                     enable interrupts.
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_di_rcp_disable(digi_handle_t             *digi_handle,
                                                 odu_rcp_int_t             *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    digi_otn_int_t          *int_en_table_ptr = NULL;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }

    /* Get internal enabled interrupt table to check */
    result = digi_int_en_table_get(digi_handle,
                                   DIGI_INT_TYPE_OTN,
                                   (void**) &int_en_table_ptr);
    
    if (PMC_SUCCESS == result)
    {  
        
        result = coreotn_int_rcp_enable(digi_handle->coreotn_handle,
                                        ODU_RCP_DI_INST,
                                        int_table_ptr,
                                        &int_en_table_ptr->di_rcp,
                                        DIGI_DISABLE);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_di_rcp_disable */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_di_rcp_filt_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves DI RCP block unchannelized interrupt table.
*
*   The desired interrupt/status bits to retrieve (to reduce function execution
*   time) can be specified using the filter interrupt table input.
*
* INPUTS:
*   digi_handle             - pointer to DIGI handle instance.
*   filt_table_ptr          - filter interrupt table. 
*                             When NULL, all interrupts are retrieved.
*
* OUTPUTS:
*   int_table_ptr  - pointer to interrupt table to store interrupt
*                    information. 
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_di_rcp_filt_retrieve(digi_handle_t        *digi_handle,
                                                       odu_rcp_int_t        *filt_table_ptr,
                                                       odu_rcp_int_t        *int_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
 
    PMC_ATOMIC_ENTRY(digi_handle);    

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }

    if (PMC_SUCCESS == result)
    {
        PMC_MEMSET((void *)int_table_ptr, 0, sizeof(odu_rcp_int_t));   
    
        /* enable interrupt caching, clear cache */
        pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, TRUE, TRUE);

        result = coreotn_int_rcp_retrieve(digi_handle->coreotn_handle, 
                                          ODU_RCP_DI_INST,
                                          filt_table_ptr,
                                          int_table_ptr);

        /* disable interrupt caching */
        pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, FALSE, FALSE);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_di_rcp_filt_retrieve */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_di_rcp_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears DI RCP block unchannelized interrupts based on bits that are set 
*   in the interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to interrupt table with bits set to
*                     enable interrupts.
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_di_rcp_clear(digi_handle_t        *digi_handle,
                                               odu_rcp_int_t        *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_rcp_clear(digi_handle, 
                                            ODU_RCP_DI_INST,
                                            int_table_ptr);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_di_rcp_clear */


/*******************************************************************************
* FUNCTION: digi_ri_rcp_cfc_int_sel_set()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Select RI RCP CFC interrupt source and framer.
*   
*
* INPUTS:
*   digi_handle      - Pointer to DIGI handle.
*   framer_id        - framer from which CFC interrupts are extracted.
*   src_dir          - CFC framer direction: TX or RX.
*                      UTIL_GLOBAL_DIR_BOTH is not supported.  
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ri_rcp_cfc_int_sel_set(digi_handle_t           *digi_handle,
                                             odu_rcp_frm_id_t         framer_id,
                                             util_global_direction_t  src_dir)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    result = odu_struct_ri_rcp_cfc_int_sel_set(digi_handle->coreotn_handle,
                                               framer_id,
                                               src_dir);
    
    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_ri_rcp_cfc_int_src_sel_set */

/*******************************************************************************
* FUNCTION: digi_ri_rcp_cfc_int_sel_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables RI RCP channelized interrupts based on bits that are set in 
*   RI RCP interrupt table.
*   
*
* INPUTS:
*   digi_handle    - Pointer to DIGI handle
*
* OUTPUTS:
*   framer_id_ptr        - selected framer
*   src_dir_ptr          - framer direction: TX or RX.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_ri_rcp_cfc_int_sel_get(digi_handle_t           *digi_handle,
                                        odu_rcp_frm_id_t        *framer_id_ptr,
                                        util_global_direction_t *src_dir_ptr)
{
#ifdef PMC_TESTS 
    PMC_ATOMIC_ENTRY_VOID(digi_handle);
#else 
    PMC_ATOMIC_ENTRY(digi_handle);
#endif 

    odu_struct_ri_rcp_cfc_int_sel_get(digi_handle->coreotn_handle,
                                      framer_id_ptr,
                                      src_dir_ptr);
    
    PMC_ATOMIC_RETURN(digi_handle);
} /* digi_ri_rcp_cfc_int_sel_get */

/*******************************************************************************
* FUNCTION: digi_ri_rcp_cfc_int_type_sel_set()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Selects RI RCP CFC interrupt type: underflow or overflow interrupt.
*   
* INPUTS:
*   digi_handle      - Pointer to DIGI handle.
*   chnl_ptr         - Pointer to an OTN ODU channel
*   int_type         - interrupt type.  
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ri_rcp_cfc_int_type_sel_set(digi_handle_t             *digi_handle,
                                                  digi_otn_odu_chnl_t        *chnl_ptr,
                                                  odu_ri_rcp_cfc_int_type_t   int_type)
{
    PMC_ERROR result = PMC_SUCCESS;
    odu_struct_t *odu_struct_ptr;
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* Retrieve the odu struct handle, channel ID & framer ID */
    odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);

    if (NULL != odu_struct_ptr)
    {
        result = odu_struct_ri_rcp_cfc_int_type_sel_set(digi_handle->coreotn_handle,
                                                        odu_struct_ptr,
                                                        int_type);
    }
    else
    {
        result = DIGI_ERR_INVALID_ARG;
    }
    
    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_ri_rcp_cfc_int_type_sel_set */

/*******************************************************************************
* FUNCTION: digi_ri_rcp_cfc_int_type_sel_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns RI RCP CFC selected interrupt type: underflow or overflow interrupt.
*
* INPUTS:
*   digi_handle     - Pointer to DIGI handle
*   chnl_ptr        - Pointer to an OTN ODU channel
*
* OUTPUTS:
*   int_type_ptr     - interrupt type.  
*
* RETURNS:
*   None.
*
* NOTES:
*         
*******************************************************************************/
PUBLIC PMC_ERROR digi_ri_rcp_cfc_int_type_sel_get(digi_handle_t             *digi_handle,
                                                  digi_otn_odu_chnl_t       *chnl_ptr,
                                                  odu_ri_rcp_cfc_int_type_t *int_type_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    odu_struct_t *odu_struct_ptr;
    odu_struct_frm_id_t frm_id;  
    UINT32 ch_id;

    PMC_ATOMIC_ENTRY(digi_handle);
        
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check that user switch handle belongs to digi context */           
    DIGI_SWITCH_DATA_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    /* Retrieve the odu struct handle, channel ID & framer ID */
    odu_struct_ptr = digi_otn_framer_odu_struct_get(digi_handle, chnl_ptr, &ch_id, &frm_id);

    if (NULL != odu_struct_ptr)
    {
        result = odu_struct_ri_rcp_cfc_int_type_sel_get(digi_handle->coreotn_handle,
                                                        odu_struct_ptr,
                                                        int_type_ptr);
    }
    else
    {
        result = DIGI_ERR_INVALID_ARG;
    }
    
    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_ri_rcp_cfc_int_type_sel_get */

/*******************************************************************************
* digi_otn_fege_mstat_counter_access
* ______________________________________________________________________________
*
* DESCRIPTION:
*   API to access COREOTN FEGE Port counters.\n\n
*
*   When API called with action UTIL_GLOBAL_COUNTER_ACTION_TRIGGER,
*   the MSTATX is configured to ignore external LCLK and a local transfer
*   and clear of internal counters is performed.\n\n
*
*   When API called with action UTIL_GLOBAL_COUNTER_ACTION_RETRIEVE, the
*   counter holding registers are read from the device and populated to the
*   digi_pmon_coreotn_fege_mstat_t type function output.  The fields rx_lcv_lsb
*   and rx_lcv_msb are not recovered by this function and set to 0.  All other
*   counters are recovered.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   inst             - COREOTN FEGE Port Instance
*   action           - API operation to perform
*
* OUTPUTS:
*  *counts_ptr       - FEGE Port Counter values, pointer may be NULL if called
*                      with action UTIL_GLOBAL_COUNTER_ACTION_TRIGGER
*
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_otn_fege_mstat_counter_access(digi_handle_t *digi_handle,
                                               util_global_coreotn_sgmii_inst_t inst,
                                               util_global_counter_action_t action,
                                               digi_pmon_coreotn_fege_mstat_t *counts_ptr)
{
    enet_fege_handle_t *h;

#ifdef PMC_TESTS 
    PMC_ATOMIC_ENTRY_VOID(digi_handle);
#else 
    PMC_ATOMIC_ENTRY(digi_handle);
#endif

    h = coreotn_enet_fege_handle_get(digi_handle->coreotn_handle, inst);

    if(action == UTIL_GLOBAL_COUNTER_ACTION_TRIGGER)
    {
        enet_fege_mstatx_trigger(h);
    }
    else if(action == UTIL_GLOBAL_COUNTER_ACTION_RETRIEVE)
    {
        DIGI_MSTATX_COUNTS_RETRIEVE();
    }
    else
    {
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
    }

    PMC_ATOMIC_RETURN(digi_handle);

} /* digi_otn_fege_mstat_counter_access */


/*******************************************************************************
* FUNCTION: digi_otn_odu_cm_min_max_reprov()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Reprovisions the CM_MIN/CM_MAX values on an already operational channel.
*
*   If DIGI receives a Cm value less than CM_MIN or greater than CM_MAX,
*   DIGI will generate CM_OUT_LIMIT interrupt.  Changing
*   these values will have no impact on downstream consequential actions.
*
*   Note, CM_MIN and CM_MAX are limited to integer resolution, so the
*   precision of detecting -/+ ppm will be different than the ppm provided
*   (as limited by integer resolution).
*
* INPUTS:
*   digi_handle     - Pointer to DIGI handle
*   chnl_ptr        - Pointer to an OTN ODU channel
*   use_custom_ppm      - TRUE : use ppm_offset parameter to calculate
*                                CM_MIN and CM_MAX
*                         FALSE : use ppm ofsets defined in G.709
*   ppm_tolerance       - If use_custom_ppm is TRUE, this is
*                         the user defined +/- ppm tolerance 
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*         
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_cm_min_max_reprov(digi_handle_t * digi_handle,
                                                digi_otn_odu_chnl_t *chnl_ptr,
                                                BOOL use_custom_ppm,
                                                UINT32 ppm_tolerance)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
        
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    
    result =  odu_struct_otn_odu_cm_min_max_reprov(digi_handle->coreotn_handle,
                                                   (odu_struct_t *)chnl_ptr,
                                                   use_custom_ppm,
                                                   ppm_tolerance);

    
    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_odu_cm_min_max_reprov */

/*******************************************************************************
* digi_otn_server_sfis_odd_parity_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures OTN server client SFIS bits of odd parity such as
*   there are inverted or not.
*
*   Note that traffic will disrupt during the function execution.
*
*   Feature supported only for 40G and 100G SFI-S only.
*
* INPUTS:
*   digi_handle       - pointer to digi handle instance.
*   *otn_server_ptr   - Pointer to a resource allocation
*                       context for the OTN server configured against the
*                       specified serdes port.
*   dir               - direction concerned by the configuration: 
*                       >UTIL_GLOBAL_DIR_RX for SFIS RX interface odd parity bits.
*                       >UTIL_GLOBAL_DIR_TX for SFIS TX interface odd parity bits.
*                       >UTIL_GLOBAL_DIR_BOTH for SFIS RX and TX interfaces odd parity bits.
*   inv               - when TRUE all bits of odd parity are inverted
*                       when FALSE all bits of odd parity are processed normally
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS when function is successfully executed otherwise a descriptive 
*   error code is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_sfis_odd_parity_set(digi_handle_t             *digi_handle,
                                                     digi_otn_server_chnl_t    *otn_server_ptr,
                                                     util_global_direction_t    dir,
                                                     BOOL8                      inv)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);    
    otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    
    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, otn_server_ptr, rc, TRUE);

    /* call SS function that executes low-level operations */
    rc = lineotn_mld_sfis_odd_parity_set(digi_handle->lineotn_handle,
                                         otn_srvr_ptr->dsi_base_chnl,
                                         dir,
                                         inv);

    PMC_ATOMIC_RETURN(digi_handle, rc);
}/* digi_otn_sfis_odd_parity_set */

/*******************************************************************************
* digi_otn_server_sfis_odd_parity_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns OTN server client SFIS odd parity status: inverted or not.
*
*   Feature supported only for 40G and 100G SFI-S only.
*
* INPUTS:
*   digi_handle         - pointer to digi handle instance.
*   *otn_server_ptr     - Pointer to a resource allocation
*                         context for the OTN server configured against the
*                         specified serdes port.
*   dir                 - direction concerned by the configuration: RX or TX.
*
* OUTPUTS:
*   *inv_ptr            - when TRUE all bits of odd parity are inverted
*                         when FALSE all bits of odd parity are processed normally
*  
* RETURNS:
*   PMC_SUCCESS when function is successfully executed otherwise a descriptive 
*   error code is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_sfis_odd_parity_get(digi_handle_t             *digi_handle,
                                                     digi_otn_server_chnl_t    *otn_server_ptr,
                                                     util_global_direction_t    dir,
                                                     BOOL8                     *inv_ptr)
{
    PMC_ERROR   rc = PMC_SUCCESS;
    digi_otn_server_chnl_def_t *otn_srvr_ptr;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_INVALID_ARG, 0, 0);    
    otn_srvr_ptr =(digi_otn_server_chnl_def_t *)(otn_server_ptr);
    
    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, otn_server_ptr, rc, TRUE);

    /* call SS function that executes low-level operations */
    rc = lineotn_mld_sfis_odd_parity_get(digi_handle->lineotn_handle,
                                         otn_srvr_ptr->dsi_base_chnl,
                                         dir,
                                         inv_ptr);

    PMC_ATOMIC_RETURN(digi_handle, rc);
}/* digi_otn_server_sfis_odd_parity_get */


/*******************************************************************************
* FUNCTION: digi_otn_odu_level_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the odu level from an ODU channel handle 
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - OTN channel handle for HO/MO/LO framer
*
* OUTPUTS:
*
* RETURNS:
*   UINT32          - ODU level
*
* NOTES:
*
*******************************************************************************/
PUBLIC odu_struct_odu_level_t digi_otn_odu_level_get(digi_handle_t              *digi_handle,
                                                     digi_otn_odu_chnl_t        *chnl_handle)
{
    odu_struct_odu_level_t   odu_level;

#ifdef PMC_TESTS 
    PMC_ATOMIC_ENTRY_VOID(digi_handle);
#else 
    PMC_ATOMIC_ENTRY(digi_handle);
#endif
    
    odu_level = digi_otn_odu_level_internal_get(digi_handle, chnl_handle);

    PMC_ATOMIC_RETURN(digi_handle, odu_level);
} /* digi_otn_odu_level_get */

/*******************************************************************************
* FUNCTION: digi_otn_int_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves an aggregation interrupt table with interrupt bits
*   over multiple channels.
*
*   Note that OTN ODU interrupts (e.g. PM and TCM PID interrupts) will always
*   clear on retrieval due to a hardware limitation. This is different than the
*   rest of the system's interrupts which will always have an explict
*   int_clear() function. 
*
*   All other interrupts retrieved by this function will also have their 
*   interrupts automatically cleared to maintain consistent behaviour
*   with the OTN ODU.
*
*   digi_otn_server_int_chnl_get() and digi_otn_odu_int_chnl_get() can be used
*   to retrieve a specific chnl table from the aggregation table.
*
*   digi_otn_odu_int_start() must be used before calling this function to
*   retrieve the latest RFRM status.
*
*   digi_otn_ddeg_int_start() must be used before calling this function to
*   retrieve the latest dDEG status.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*
* OUTPUTS:
*   int_table_ptr  - pointer to aggregation interrupt table to store interrupt
*                    information
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_int_retrieve(digi_handle_t      *digi_handle,
                                       digi_otn_int_t     *int_table_ptr)
{
    PMC_ERROR                result = PMC_SUCCESS;
    digi_otn_int_filter_t    int_filter;


    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != int_table_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Mark all blocks for retrieval */
    result = digi_otn_odu_blk_filter_set(digi_handle,
                                         DIGI_INT_ALL_INTS,
                                         &int_filter.blocks);

    /* 
     * Enable the interrupt caching. Note that this should be done in the
     * PUBLIC functions to ensure that it does not need to be repeated in
     * the lower level private functions.
     */
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, TRUE,TRUE);

    /* 
     * Ensure the passed in interrupt table is reset to 0 for all entries.
     */
    PMC_MEMSET(int_table_ptr, 0, sizeof(digi_otn_int_t));

    if (PMC_SUCCESS == result)
    {
        result = digi_otn_int_filt_retrieve_internal(digi_handle,
                                                     &int_filter,
                                                     TRUE,
                                                     int_table_ptr);
    }

    /*#ifdef PMC_INTERNAL*/
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_int_clear_internal(digi_handle,
                                             int_table_ptr);

    }
    /*#endif*/
    /* 
     * Disable interrupt caching, don't clear its contents. This is done 
     * in the PUBLIC function to ensure it is handled before the function
     * completes.
     */
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle,
                                 FALSE, FALSE);

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_int_retrieve */

#ifndef DOXYGEN_PUBLIC_ONLY
/*******************************************************************************
* FUNCTION: digi_otn_odu_blk_filter_set()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   If a framer filter table is provided, check for sub blocks within the table
*   that are all-zero and update the block filter table accordingly so that
*   coreotn_int_chnl_retrieve() can quickly skip those sub blocks.
*
* INPUTS:
*   digi_handle           - Pointer to digi handle
*   filt_table_ptr        - pointer to filter table for coreotn framer status.
*                           DIGI_INT_ALL_INTS to retrieve all interrupt/status.
*
* OUTPUTS:
*   blk_filter_ptr        - Pointer to block filter bitmasks to be updated
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_blk_filter_set(digi_handle_t              *digi_handle,
                                              coreotn_int_chnl_t         *filt_table_ptr,
                                              UINT32                     *blk_filter_ptr)
{
    static coreotn_int_framer_chnl_t        zero_table;
    UINT32                                  i;
    void                                   *cmp_addr[10];
    UINT32                                  cmp_size[10];
    UINT32                                  blk_mask[10];
    
    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(blk_filter_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    /*
     * If the filter table is NULL then assign all subsysems to the block
     * filter as all subsystems will be check. This is the case if called
     * from digi_otn_int_retrieve where not filter table is provided.
     * Else go over the provided filter table and determine which subsystem
     * table has any values that are non-zero and set the block as enabled.
     * That way only the subsystems of interest will be checked.
     */
    if (IS_DIGI_INT_ALL_INTS(filt_table_ptr))
    {
        *blk_filter_ptr = DIGI_OTN_INT_FILTER_BLOCKS_OTN_MLD     |
                          DIGI_OTN_INT_FILTER_BLOCKS_OTN_SERVER  |
                          DIGI_OTN_INT_FILTER_BLOCKS_OTN_ODU     |
                          DIGI_OTN_INT_FILTER_BLOCKS_OTN_STG3B   |
                          DIGI_OTN_INT_FILTER_BLOCKS_TFRM        |
                          DIGI_OTN_INT_FILTER_BLOCKS_MPMO        |
                          DIGI_OTN_INT_FILTER_BLOCKS_MPMA        |
                          DIGI_OTN_INT_FILTER_BLOCKS_ODTU_DMX    |
                          DIGI_OTN_INT_FILTER_BLOCKS_ODTU_MUX    |
                          DIGI_OTN_INT_FILTER_BLOCKS_ODUKSC      |
                          DIGI_OTN_INT_FILTER_BLOCKS_ODUJAT      |
                          DIGI_OTN_INT_FILTER_BLOCKS_OHP         | 
                          DIGI_OTN_INT_FILTER_BLOCKS_RCP         |
                          DIGI_OTN_INT_FILTER_BLOCKS_PRBS;
    }
    else
    {
        /* Zero the table */
        PMC_MEMSET((void*) &zero_table, 0, sizeof(zero_table));

        *blk_filter_ptr = DIGI_OTN_INT_FILTER_BLOCKS_OTN_ODU | 
                          DIGI_OTN_INT_FILTER_BLOCKS_OTN_STG3B;

        blk_mask[0] = DIGI_OTN_INT_FILTER_BLOCKS_MPMO;
        blk_mask[1] = DIGI_OTN_INT_FILTER_BLOCKS_MPMA;  
        blk_mask[2] = DIGI_OTN_INT_FILTER_BLOCKS_ODTU_DMX;
        blk_mask[3] = DIGI_OTN_INT_FILTER_BLOCKS_ODTU_MUX;
        blk_mask[4] = DIGI_OTN_INT_FILTER_BLOCKS_ODUKSC;
        blk_mask[5] = DIGI_OTN_INT_FILTER_BLOCKS_ODUJAT; 
        blk_mask[6] = DIGI_OTN_INT_FILTER_BLOCKS_TFRM; 
        blk_mask[7] = DIGI_OTN_INT_FILTER_BLOCKS_PRBS; 
        blk_mask[8] = DIGI_OTN_INT_FILTER_BLOCKS_OHP; 
        blk_mask[9] = DIGI_OTN_INT_FILTER_BLOCKS_RCP; 

        cmp_addr[0] = &filt_table_ptr->framer_chnl.mpmo;  
        cmp_addr[1] = &filt_table_ptr->framer_chnl.mpma;
        cmp_addr[2] = &filt_table_ptr->framer_chnl.odtu_dmx;
        cmp_addr[3] = &filt_table_ptr->framer_chnl.odtu_mux;
        cmp_addr[4] = &filt_table_ptr->framer_chnl.oduksc;
        cmp_addr[5] = &filt_table_ptr->framer_chnl.odujat;
        cmp_addr[6] = &filt_table_ptr->framer_chnl.tfrm;
        cmp_addr[7] = &filt_table_ptr->prbs;
        cmp_addr[8] = &filt_table_ptr->ohp_chnl;
        cmp_addr[9] = &filt_table_ptr->ri_rcp_chnl;
        
        cmp_size[0] = sizeof(filt_table_ptr->framer_chnl.mpmo);  
        cmp_size[1] = sizeof(filt_table_ptr->framer_chnl.mpma);
        cmp_size[2] = sizeof(filt_table_ptr->framer_chnl.odtu_dmx);
        cmp_size[3] = sizeof(filt_table_ptr->framer_chnl.odtu_mux);
        cmp_size[4] = sizeof(filt_table_ptr->framer_chnl.oduksc);
        cmp_size[5] = sizeof(filt_table_ptr->framer_chnl.odujat);
        cmp_size[6] = sizeof(filt_table_ptr->framer_chnl.tfrm);
        cmp_size[7] = sizeof(filt_table_ptr->prbs);
        cmp_size[8] = sizeof(filt_table_ptr->ohp_chnl[0]) * COREOTN_NUM_ODU_OHP_INST;
        cmp_size[9] = sizeof(filt_table_ptr->ri_rcp_chnl);

        /* Enable block retrieval if there is at least one bit in the filter */
        for (i = 0; i < 10; i++)
        {
            if(PMC_MEMCMP(&zero_table, cmp_addr[i], cmp_size[i]) != 0)
            {
                *blk_filter_ptr |= blk_mask[i];
            }
        }
    }

    PMC_RETURN(PMC_SUCCESS);
} /* digi_otn_odu_blk_filter_set */
#endif /* DOXYGEN_PUBLIC_ONLY */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_chnl_filt_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves a channel interrupt table with interrupt bits for a specified
*   ODU channel.
*
*   The desired interrupt/status bits to retrieved (to reduce function execution
*   time) can be specified using the filter table input.
*
*   digi_otn_odu_int_start(COREOTN_LATCH_DEFECT_ODUKP) or 
*   digi_otn_odu_int_start(COREOTN_LATCH_DEFECT_ALL) needs to be called before
*   retrieving interrupts to trigger RFRM status transfer.
*
*   digi_otn_ddeg_int_start() must be used before calling this function to
*   retrieve the latest dDEG status.
*
* INPUTS:
*   digi_handle           - pointer to DIGI handle instance.
*   chnl_handle           - pointer to channel handle to retrieve interrupts
*   framer_filt_table_ptr - pointer to filter table for ODU framer status.
*                           Mark fields as TRUE within this table to indicate that
*                           the interrupt/status will be retrieved
*                           to the output table. DIGI_INT_ALL_INTS to retrieve all 
*                           interrupt/status. Applies to stage3b as well.
*   pid_filt_table_ptr    - pointer to filter table for ODU PID status.
*                           Mark fields as TRUE within this table to indicate that
*                           the interrupt/status will be retrieved
*                           to the output table. DIGI_INT_ALL_INTS to retrieve all 
*                           interrupt/status. Applies to stage3b as well.
*
* OUTPUTS:
*   int_table_ptr  - pointer to channel interrupt table to store interrupt
*                    information. 
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_chnl_filt_retrieve(digi_handle_t              *digi_handle,
                                                     digi_otn_odu_chnl_t        *chnl_handle,
                                                     coreotn_int_framer_chnl_t  *framer_filt_table_ptr,
                                                     odu_rfrm_int_pid_chnl_t    *pid_filt_table_ptr,
                                                     digi_otn_odu_int_chnl_t    *int_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    digi_otn_int_filter_t       int_filter;
    coreotn_int_chnl_t          filt_table;
    coreotn_int_chnl_t         *filt_table_ptr = &filt_table;
 
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != int_table_ptr, DIGI_ERR_INVALID_PTR, 0, 0);
    
    /* Copy framer and pid filter tables into a single coreotn table */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_filter_create(digi_handle,
                                                framer_filt_table_ptr,
                                                pid_filt_table_ptr,
                                                &filt_table_ptr);
    }

    /* Mark desired blocks for retrieval */
    result = digi_otn_odu_blk_filter_set(digi_handle,
                                         filt_table_ptr,
                                         &int_filter.blocks);

    /* 
     * Enable the interrupt caching. Note that this should be done in the
     * PUBLIC functions to ensure that it does not need to be repeated in
     * the lower level private functions.
     */
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, TRUE,TRUE);

    /* 
     * Ensure the passed in interrupt table is reset to 0 for all entries.
     */
    PMC_MEMSET(int_table_ptr, 0, sizeof(digi_otn_odu_int_chnl_t));
   
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_chnl_filt_retrieve_internal(digi_handle,
                                                              chnl_handle,
                                                              &int_filter,
                                                              filt_table_ptr,
                                                              int_table_ptr);
    }

    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, 
                                 FALSE,FALSE);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_chnl_filt_retrieve */


#ifndef DOXYGEN_PUBLIC_ONLY
/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ddeg_stage_chnl_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves enh dDeg int/status for a channel in  a specific stage in the
*   FW dDeg table.
*
* INPUTS:
*   digi_handle      - Pointer to digi handle
*   chnl_handle      - pointer to channel handle to retrieve interrupts
*   mon_seg          - Monitoring segment (stg1/stg2/stg3, or stg4)
*   int_en_table_ptr - Channelized enabled interrupt table
*
* OUTPUTS:
*   int_table_ptr    - Channelized interrupt table to return status
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ddeg_stage_chnl_retrieve(digi_handle_t            *digi_handle,
                                                           digi_otn_odu_chnl_t      *chnl_handle,
                                                           coreotn_ddeg_mon_seg_t    mon_seg,
                                                           coreotn_int_chnl_t       *int_en_table_ptr,
                                                           coreotn_int_chnl_t       *int_table_ptr)

{
    PMC_ERROR       result = PMC_SUCCESS;
    BOOL            retrieve_enh, retrieve_bursty, retrieve_valid;
    UINT32          i;
    UINT32          chnl_num;
    UINT32          pool_id;
    const UINT32    bursty_idx = DIGI_PMON_DDEG_MODE_BURSTY;
    const UINT32    enh_idx    = DIGI_PMON_DDEG_MODE_ENH;

    odu_struct_odu_level_t   odu_level;
    digi_pmon_ddeg_stage_t  *ddeg_ptr;

    PMC_ENTRY();
    PMC_ASSERT(digi_handle   != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_handle   != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_table_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
  
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* If ddeg has not been triggered, just return */
    if (FALSE == digi_handle->var.int_info_ary->ddeg_cache_valid)
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    result = digi_otn_odu_int_ddeg_scope_get(digi_handle,
                                             mon_seg,
                                             &retrieve_enh,
                                             &retrieve_bursty,
                                             &retrieve_valid);

    if (PMC_SUCCESS == result && FALSE == retrieve_valid)
    {
        /* Nothing to do */
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Get pointer to ddeg cache */
    if (PMC_SUCCESS == result)
    {
        odu_level = digi_otn_odu_level_internal_get(digi_handle, chnl_handle);
        result = digi_otn_odu_int_ddeg_get(digi_handle,
                                           odu_level,
                                           &ddeg_ptr);
    }

    if (PMC_SUCCESS == result)
    {
        chnl_num = digi_otn_odu_chnl_num_internal_get(digi_handle, chnl_handle);

        if (retrieve_enh)
        {
            int_table_ptr->framer_chnl.rfrm.ddeg_enh_pm_i =
                pmc_bitarray_is_bit_set(ddeg_ptr[enh_idx].i_ptr, chnl_num);
            int_table_ptr->framer_chnl.rfrm.ddeg_enh_pm_v =
                pmc_bitarray_is_bit_set(ddeg_ptr[enh_idx].v_ptr, chnl_num);
        }

        if (retrieve_bursty)
        {
            int_table_ptr->framer_chnl.rfrm.ddeg_bursty_pm_i =
                pmc_bitarray_is_bit_set(ddeg_ptr[bursty_idx].i_ptr, chnl_num);
            int_table_ptr->framer_chnl.rfrm.ddeg_bursty_pm_v =
                pmc_bitarray_is_bit_set(ddeg_ptr[bursty_idx].v_ptr, chnl_num);
        }
        
        /* TCM */
        for (i = 0; i < COREOTN_PIDS_PER_CHNL; i++)
        {
            pool_id = int_table_ptr->pid.rx_tcm_pool_ids[i];
            if(DIGI_OTN_IS_TCM_PID_VALID(pool_id))
            {
                if (retrieve_enh)
                {
                    int_table_ptr->pid.rx_tcm[i].ddeg_enh_i = 
                        pmc_bitarray_is_bit_set(ddeg_ptr[enh_idx].tcm_i_ptr, pool_id);
                    int_table_ptr->pid.rx_tcm[i].ddeg_enh_v =    
                        pmc_bitarray_is_bit_set(ddeg_ptr[enh_idx].tcm_v_ptr, pool_id);
                }

                if (retrieve_bursty)
                {
                    int_table_ptr->pid.rx_tcm[i].ddeg_bursty_i = 
                        pmc_bitarray_is_bit_set(ddeg_ptr[bursty_idx].tcm_i_ptr, pool_id);
                    int_table_ptr->pid.rx_tcm[i].ddeg_bursty_v =    
                        pmc_bitarray_is_bit_set(ddeg_ptr[bursty_idx].tcm_v_ptr, pool_id);
                }
            }
        }
    }

    PMC_RETURN(result);
} /* digi_otn_odu_int_ddeg_stage_chnl_retrieve */

/*
** Private functions
*/

/*******************************************************************************
* digi_otn_cal_entries_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method to retrieve the channel schedule for a 
*   particular framer.
*
* INPUTS:
*   *digi_handle  - pointer to odu ohp handle instance
*   rx_db          - RX database
*   ch_id          - Channel ID
*   frm_id         - Framer ID
*   rx_db          - rx or tx database
*
* OUTPUTS:
*   *cal_entry_ptr      - storage for an array of calendar entries occupied by
*                         the channel.
*   *num_cal_entries    - number of calendar entries 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_cal_entries_get(digi_handle_t * digi_handle,
                                           BOOL rx_db,
                                           UINT32 ch_id,
                                           odu_struct_frm_id_t frm_id,  
                                           UINT32 *cal_entry_ptr,
                                           UINT32 *num_cal_entries)
{
    PMC_ERROR result = PMC_SUCCESS;
    coreotn_handle_t *coreotn_handle;
    mapotn_handle_t *mapotn_handle;
    UINT32 num_of_recs = 0;
    UINT32 i;
    UINT32 db_ch_id;
    UINT32 db_entries[DIGI_NUM_LO_ODU_CHNL_MAX];

    PMC_ENTRY();
    
    coreotn_handle = digi_handle->coreotn_handle;
    mapotn_handle = digi_handle->mapotn_handle;

    

    /*
     * FRM_STG1/N/2/3a/3b - use coreotn db 
     * FRM_STG4 - use mapotn db 
     * If Framer Stage 1 & it's a SYSOTN application -> use lineotn db
     */

    if ((frm_id == ODU_STRUCT_FRM_STG1 || frm_id == ODU_STRUCT_FRM_STG2) && digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
    {
        /* Special case: framer Stage 1 when it's a SYSOTN application */
        for(i=0;i < DIGI_NUM_LO_ODU_CHNL_MAX;i++)
        {
            result = lineotn_sysotn_mode_db_entry_get(digi_handle->lineotn_handle, i, &db_ch_id);
            if (db_ch_id == ch_id)
                cal_entry_ptr[num_of_recs++] = i;
        }
    }
    else if (frm_id == ODU_STRUCT_FRM_STG4)
    {
        result = mapotn_db_entry_all_get(mapotn_handle,db_entries); 
        /*
         * db_entries contains number of slots per channel
         * -convert to cal_entry_ptr - list of slots that one 
         *  particular channel (ch_id) occupies 
         */  
        if (result == PMC_SUCCESS) 
        {
            for(i=0;i < DIGI_NUM_LO_ODU_CHNL_MAX;i++)
            {
                if (db_entries[i] == ch_id)
                    cal_entry_ptr[num_of_recs++] = i;
            }
        }
    }
    else 
    {
        result = coreotn_db_cal_entries_get(coreotn_handle, FALSE, rx_db, ch_id, frm_id, cal_entry_ptr, &num_of_recs);
    }

    PMC_LOG_TRACE("otn: ch: %d framer = %d, num of recs = %d\n", ch_id, frm_id, num_of_recs);
    for (i = 0; i < num_of_recs; i++)
    {
        PMC_LOG_TRACE("otn: cal_entry[%u] = %u\n", i, cal_entry_ptr[i]);
    }

    *num_cal_entries = num_of_recs;

    PMC_RETURN(result);

} /* digi_otn_cal_entries_get */

/*******************************************************************************
* digi_otn_cal_entries_count_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method to retrieve the number of calendar entries
*   for a given channel for a particular framer.
*
* INPUTS:
*   *digi_handle  - pointer to odu ohp handle instance
*   rx_db          - RX database
*   ch_id          - Channel ID
*   frm_id         - Framer ID
*   rx_db          - rx or tx database
*
* OUTPUTS:
*   *num_cal_entries    - number of calendar entries 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_cal_entries_count_get(digi_handle_t * digi_handle,
                                                 BOOL rx_db,
                                                 UINT32 ch_id,
                                                 odu_struct_frm_id_t frm_id,  
                                                 UINT32 *num_cal_entries)
{
    PMC_ERROR result = PMC_SUCCESS;
    coreotn_handle_t *coreotn_handle;
    mapotn_handle_t *mapotn_handle;
    UINT32 num_of_recs = 0;
    UINT32 i;
    UINT32 db_ch_id;
    UINT32 db_entries[DIGI_NUM_LO_ODU_CHNL_MAX];

    PMC_ENTRY();
    
    coreotn_handle = digi_handle->coreotn_handle;
    mapotn_handle = digi_handle->mapotn_handle;

    

    /*
     * FRM_STG1/N/2/3a/3b - use coreotn db 
     * FRM_STG4 - use mapotn db 
     * If Framer Stage 1 & it's a SYSOTN application -> use lineotn db
     */

    if ((frm_id == ODU_STRUCT_FRM_STG1 || frm_id == ODU_STRUCT_FRM_STG2) && digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
    {
        /* Special case: framer Stage 1 when it's a SYSOTN application */
        for(i=0;i < DIGI_NUM_LO_ODU_CHNL_MAX;i++)
        {
            result = lineotn_sysotn_mode_db_entry_get(digi_handle->lineotn_handle, i, &db_ch_id);
            if (db_ch_id == ch_id)
                num_of_recs++;
        }
    }
    else if (frm_id == ODU_STRUCT_FRM_STG3B && digi_handle->var.mux_stages == DIGI_OTN_MUX_STAGES_NONE)
    {
        /* NO muxing - use the HO database */
        result = coreotn_db_cal_entries_get(coreotn_handle, FALSE, rx_db, ch_id, ODU_STRUCT_FRM_STG1, NULL, &num_of_recs);
    }
    else if (frm_id == ODU_STRUCT_FRM_STG4)
    {
        result = mapotn_db_entry_all_get(mapotn_handle,db_entries); 
        /*
         * db_entries contains number of slots per channel
         * -convert to cal_entry_ptr - list of slots that one 
         *  particular channel (ch_id) occupies 
         */  
        if (result == PMC_SUCCESS) 
        {
            for(i=0;i < DIGI_NUM_LO_ODU_CHNL_MAX;i++)
            {
                if (db_entries[i] == ch_id)
                    num_of_recs++;
            }
        }
    }
    else 
    {
        result = coreotn_db_cal_entries_get(coreotn_handle, FALSE, rx_db, ch_id, frm_id, NULL, &num_of_recs);
    }

    *num_cal_entries = num_of_recs;

    PMC_RETURN(result);

} /* digi_otn_cal_entries_count_get */

/*******************************************************************************
* FUNCTION: digi_otn_odu_pmon_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves all OTN ODU PMON channel tables for a specified ODU level
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_level       - ODU level (HO/MO/LO)
*   pmon_table_ptr  - Pointer to OTN PMON table
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_pmon_retrieve(digi_handle_t              *digi_handle,
                                             odu_struct_odu_level_t      odu_level,
                                             digi_otn_pmon_t            *pmon_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    UINT32                      i;
    UINT32                      odu_max_chnl;
    odu_struct_t               *pool_ptr;
    odu_struct_t               *stg3b_pool_ptr;
    digi_otn_odu_chnl_t       **odu_handle_pptr;
    digi_otn_odu_pmon_chnl_t   *pmon_ptr;

    PMC_ENTRY(); /* Atomic entry/exit not required when retrieving inteerupts as expected to be 
                    in a callback or ISR that is thread-safe */
    
    stg3b_pool_ptr = digi_handle->handle_pool.s3b_odu_struct;
    
    switch (odu_level)
    {
      case ODU_STRUCT_LEVEL_HO_ODU:
        odu_max_chnl    = DIGI_OTN_SERVER_HO_CHNL_MAX;
        pool_ptr        = digi_handle->handle_pool.ho_odu_struct;
        odu_handle_pptr = pmon_table_ptr->otn_odu_ho_handle;
        pmon_ptr        = pmon_table_ptr->otn_odu_ho_chnl;
        break;
        
      case ODU_STRUCT_LEVEL_MO_ODU:
        odu_max_chnl     = DIGI_OTN_SERVER_MO_CHNL_MAX;
        pool_ptr         = digi_handle->handle_pool.mo_odu_struct;
        odu_handle_pptr  = pmon_table_ptr->otn_odu_mo_handle;
        pmon_ptr         = pmon_table_ptr->otn_odu_mo_chnl;
        break;
        
      case ODU_STRUCT_LEVEL_LO_ODU:
        odu_max_chnl     = DIGI_OTN_SERVER_LO_CHNL_MAX;
        pool_ptr         = digi_handle->handle_pool.lo_odu_struct;
        odu_handle_pptr  = pmon_table_ptr->otn_odu_lo_handle;
        pmon_ptr         = pmon_table_ptr->otn_odu_lo_chnl;
        break;
      
      case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
        odu_max_chnl     = DIGI_OTN_SERVER_HO_CHNL_MAX;
        pool_ptr         = digi_handle->handle_pool.sysotn_line_struct;
        odu_handle_pptr  = pmon_table_ptr->otn_odu_lo_mon_handle;
        pmon_ptr         = pmon_table_ptr->otn_odu_lo_mon_chnl;
        break;
      
      default:
        PMC_ASSERT(NULL, DIGI_ERR_CODE_ASSERT, 0, 0);
        break;
    } /* end switch */

    
    
    for (i = 0; (i < odu_max_chnl) && (PMC_SUCCESS == result); i++)
    {
        if (util_global_is_chnl_prov(&pool_ptr[i]))
        {
            odu_handle_pptr[i] = &pool_ptr[i];
            result = digi_otn_odu_pmon_chnl_retrieve_internal(digi_handle,
                                                              odu_handle_pptr[i],
                                                              &pmon_ptr[i].pmon);
        
            if ((PMC_SUCCESS == result) &&
                (TRUE == digi_otn_is_stg3b_present(digi_handle, odu_handle_pptr[i])))
            {
                pmon_ptr[i].stg3b_valid = TRUE;
                result = digi_otn_odu_pmon_chnl_retrieve_internal(digi_handle,
                                                                  &stg3b_pool_ptr[i],
                                                                  &pmon_ptr[i].stg3b);
            }
        }
    } /* end for */
   
    PMC_RETURN(result);
} /* digi_otn_odu_pmon_retrieve */

/*******************************************************************************
* FUNCTION: digi_otn_is_stg3b_present()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks if a stg3b framer is present on this OTN ODU channel
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_ptr        - Pointer to an OTN ODU channel
*
* OUTPUTS:
*
* RETURNS:
*   TRUE    - Stg3b framer is present
*   FALSE   - Stg3b framer is not present
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL digi_otn_is_stg3b_present(digi_handle_t        *digi_handle,
                                       digi_otn_odu_chnl_t  *chnl_ptr)
{
    PMC_ERROR               result = PMC_SUCCESS;
    odu_struct_odu_level_t  odu_level;
    odu_struct_odu_level_t  stg3b_odu_level;
    UINT32                  chnl_id;

    PMC_ENTRY();
   
    chnl_id   = digi_otn_odu_chnl_num_internal_get(digi_handle, chnl_ptr);
    odu_level = digi_otn_odu_level_internal_get(digi_handle, chnl_ptr);
    
    result = coreotn_stg3b_odu_level_get(digi_handle->coreotn_handle, chnl_id, &stg3b_odu_level);

    if (PMC_SUCCESS == result)
    {
        if (odu_level == stg3b_odu_level)
        {
            PMC_RETURN(TRUE);
        }
    }
    
    PMC_RETURN(FALSE);
} /* digi_otn_is_stg3b_present */

/*******************************************************************************
*  digi_otn_get_chnl_ptr_for_tcm_apps_internal
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retreives a digi_otn_odu_chnl_t pointer to facilitate provisioning
*   PM/TCMs over the packet fabric.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_in_ptr        - Three options for monitoring over the packet fabric:
*                          1) Monitoring from FO1 framers over the packet
*                             fabric (monitoring on LO from the LINE
*                             interface or the SYS interface).
*                             Provide the *lowest order* util_global_oduk_port_data_t
*                             in the path.
*                          2) Monitoring from FO2 framers over the packet
*                             fabric (monitoring on channels sourced and
*                             received by the mapper).
*                             Provide the mapper channel context pointer (digi_mapper_chnl_def__t)
*                          3) For SYSOTN mode only.  For monitoring
*                             TCMs over the switch fabric for traffic sourced
*                             from the LINE interface (more info
*                             to be provded later)
* OUTPUTS:
*   *chnl_out_ptr       - util_global_oduk_port_data_t assosiated with the FO1 or
*                         FO2 instance.  Should be used for any PM/TCM
*                         or consequential action related config operations
*                         required on these interfaces.
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_get_chnl_ptr_for_tcm_apps_internal(digi_handle_t *digi_handle,
                                                             digi_otn_odu_chnl_t *chnl_in_ptr,
                                                             digi_otn_odu_chnl_t **chnl_out_ptr)
{
      
    PMC_ERROR   rc = PMC_SUCCESS;
    odu_struct_t *odu_struct_ptr = NULL;

    util_global_oduk_port_data_t *local_input_pc_ptr = &(((util_global_switch_data_def_t *)chnl_in_ptr)->oduk_data);
    
    PMC_ENTRY();

    /* using the chnl_in_ptr.switch_data, determine if the source is COREOTN or MAPOTN */
    switch(local_input_pc_ptr->port_type)
    {
        case UTIL_GLOBAL_ODUK_PORT_COREOTN:
            odu_struct_ptr = (odu_struct_t *)chnl_in_ptr;
            PMC_ASSERT(NULL != odu_struct_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);

            if(odu_struct_ptr->mem_ptr->payload_format != UTIL_GLOBAL_ODU_UNCHANNELIZED)
            {
                rc = DIGI_ERR_NOT_PROVISONED;
                break;
            }

            if(digi_handle->handle_pool.s3b_odu_struct[local_input_pc_ptr->channel].mem_ptr != NULL)
                *chnl_out_ptr = (digi_otn_odu_chnl_t *)&(digi_handle->handle_pool.s3b_odu_struct[local_input_pc_ptr->channel]);
            else 
                rc = DIGI_ERR_NULL_HANDLE;
            break; 

        case UTIL_GLOBAL_ODUK_PORT_MAPOTN:
            *chnl_out_ptr = (digi_otn_odu_chnl_t *)&(digi_handle->handle_pool.s4_odu_struct[local_input_pc_ptr->channel]);
            break;

        case UTIL_GLOBAL_ODUK_PORT_ILKN1:
            /* this is used in SYSOTN mode for monitoring on the LINE interface */
            *chnl_out_ptr = (digi_otn_odu_chnl_t *)&(digi_handle->handle_pool.sysotn_line_struct[local_input_pc_ptr->channel]);
            break;
        default:
            rc = DIGI_ERR_INVALID_ARG;
            break;
            
    }
   
    PMC_LOG_TRACE("port_type: %u\nchannel: %u\noduk_chnl: %u\n",
                 local_input_pc_ptr->port_type,
                 local_input_pc_ptr->channel,
                 digi_handle->handle_pool.s4_odu_struct[local_input_pc_ptr->channel].switch_data.oduk_data.channel);

    PMC_RETURN(rc);

} /* digi_otn_get_chnl_ptr_for_tcm_apps_internal */

/*******************************************************************************
* digi_di_rcp_pmon_is_selected
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns TRUE when PMON PDU is selected in given mask.
*
* INPUTS:
*    pdu_msk        - the DI RCP PDUs enable mask.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   TRUE when DI RCP PMON PDU is enabled in mask, otherwise FALSE.
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL8 digi_di_rcp_pmon_is_selected(UINT32                   pdu_msk)
{
    PMC_ENTRY();

    if (((DIGI_DI_RCP_CHNL_PMON_HO_ODUK_RX_FRAMER_STG1 |
          DIGI_DI_RCP_CHNL_PMON_HO_ODUK_RX_FRAMER_STGN |
          DIGI_DI_RCP_POOL_PMON_HO_ODUK_RX_FRAMER_STG1 |
          DIGI_DI_RCP_POOL_PMON_HO_ODUK_RX_FRAMER_STGN |
          DIGI_DI_RCP_CHNL_PMON_ODUK_RX_FRAMER_STG2 |
          DIGI_DI_RCP_CHNL_PMON_ODUK_RX_FRAMER_STG3A |
          DIGI_DI_RCP_CHNL_PMON_ODUK_RX_FRAMER_STG3B |
          DIGI_DI_RCP_CHNL_PMON_ODUK_RX_FRAMER_STG4 |
          DIGI_DI_RCP_POOL_PMON_ODUK_RX_FRAMER_STG2 |
          DIGI_DI_RCP_POOL_PMON_ODUK_RX_FRAMER_STG3A |
          DIGI_DI_RCP_POOL_PMON_ODUK_RX_FRAMER_STG3B |
          DIGI_DI_RCP_POOL_PMON_ODUK_RX_FRAMER_STG4 |
          DIGI_DI_RCP_SDH |
          DIGI_DI_RCP_PRBS_NTSE) & pdu_msk) != 0)
    {
        PMC_RETURN(TRUE);
    }

    PMC_RETURN(FALSE);
} /* digi_di_rcp_pmon_is_selected */

/*******************************************************************************
* digi_di_rcp_fw_pmon_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns TRUE when PMON PDU is selected in given mask.
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*    cfg               - digi_di_rcp_pmon_cfg_t 
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS when operation is successfully executed, otherwise
*   a descriptive error code is returned.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_di_rcp_fw_pmon_cfg(digi_handle_t     *digi_handle,
                                          digi_di_rcp_pmon_cfg_t cfg)
{
    PMC_ERROR rc = PMC_SUCCESS;  
    UINT32 data[2], byte_val;

    PMC_ENTRY();
    
    /* if PMON PDU are enabled or disabled , activate FW PMON */
    
    /* format:
     * Word | bits 24..31 | bits 16..23 | bits 8..15 | bits 0..7 |
     *   0  |   enable    |no_otn_count |       sdh_cnt_sel      |
     *   1  |no_cbrc_count|  reserved   |       reserved         |
     */
    byte_val = cfg.enable;
    data[0]  = byte_val << 24;
    byte_val = cfg.no_otn_count;
    data[0]  |= byte_val << 16;
    byte_val = cfg.sdh_cnt_sel;
    data[0] |= byte_val;
    byte_val = cfg.no_cbrc_count;
    data[1] = byte_val << 24;

    {
        HOSTMSG_DECLARE_CFG_MSG_STAT(stat);
        rc = hostmsg_send_cfg_message((pmc_handle_t*)digi_handle,MODID_PMON,HOSTMSG_CMD_PMON_CFG_RCP_ST,data,2,stat);
    }
    
    PMC_RETURN(rc);    
} /* digi_di_rcp_fw_pmon_cfg */

/*******************************************************************************
* digi_otn_framer_odu_struct_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Return the odu_struct_ptr corresponding to the input channel ptr. If the 
*   input is an ODU framer channel handle for framers 1, 2, 3A or 3B, then the 
*   corresponding framer odu_struct handle will be returned. If the input is a 
*   mapotn handle, then the odu_struct corresponding to framer 4 will be returned.
*
* INPUTS:
*  *digi_handle      - pointer to digi handle instance
*  *chnl_ptr         - ODU framer channel handle (digi_otn_odu_chnl_t) for
*                      framers 1, 2, 3A or 3B or a mapper channel 
*                      handle (digi_mapper_chnl_t) for framer 4.
*
* OUTPUTS:
*  *ch_id           - Channel ID
*  *frm_id          - Framer id (see odu_struct_frm_id_t)
*
* RETURNS:
*   odu_struct_ptr - ODU struct handle
*
* NOTES:
*
*******************************************************************************/
PRIVATE odu_struct_t *digi_otn_framer_odu_struct_get(digi_handle_t *digi_handle,
                                                     digi_otn_odu_chnl_t *chnl_ptr,
                                                     UINT32 *ch_id,
                                                     odu_struct_frm_id_t *frm_id)
{
    odu_struct_t *odu_struct_ptr = (odu_struct_t *)chnl_ptr;


    PMC_ENTRY();
    PMC_ASSERT(NULL != odu_struct_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(odu_struct_ptr->switch_data.header.data_key == UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID, 
               DIGI_ERR_INVALID_DATA_KEY, odu_struct_ptr->switch_data.header.data_key,0);

    /* If chnl_ptr corresponds to a mapotn handle, use the stage 4 framer */
    if (odu_struct_ptr->switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_MAPOTN &&
        odu_struct_ptr->switch_data.oduk_data.odu_level != (util_global_odu_level_t)ODU_STRUCT_LEVEL_4_ODU &&
        odu_struct_ptr->switch_data.cpb_data.port_type != UTIL_GLOBAL_CPB_PORT_NOT_USED)
    {
        digi_mapper_chnl_def_t *chnl_ctxt_ptr = (digi_mapper_chnl_def_t *)odu_struct_ptr;
    
        *ch_id = chnl_ctxt_ptr->mapotn_chnl;
        odu_struct_ptr =  &digi_handle->handle_pool.s4_odu_struct[*ch_id];

        *frm_id = ODU_STRUCT_FRM_STG4;
        PMC_ASSERT(odu_struct_ptr->switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_MAPOTN, DIGI_ERR_INVALID_PORT_TYPE,
                   odu_struct_ptr->switch_data.oduk_data.port_type,0);
        PMC_ASSERT(odu_struct_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_4_ODU, DIGI_ERR_OTN_NO_STG4_FRAMER,0,0);
    }
    else 
    {
        *ch_id = odu_struct_ptr->switch_data.oduk_data.channel;
        *frm_id = odu_struct_frm_id_get(digi_handle->coreotn_handle,odu_struct_ptr);
    }
    PMC_RETURN(odu_struct_ptr);
} /* digi_otn_framer_odu_struct_get */


/*******************************************************************************
* FUNCTION: digi_otn_odu_chnl_num_internal_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Given a HO/MO/LO otn odu channel handle, retrieves the channel number
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - OTN channel handle for HO/MO/LO framer
*
* OUTPUTS:
*
* RETURNS:
*   UINT32          - HO/MO/LO channel number
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_otn_odu_chnl_num_internal_get(digi_handle_t              *digi_handle,
                                                 digi_otn_odu_chnl_t        *chnl_handle)
{
    UINT32  chnl;
    odu_struct_t *odu_ptr;
    PMC_ENTRY();
    
    odu_ptr = (odu_struct_t *)chnl_handle;
    chnl = odu_ptr->switch_data.oduk_data.channel;

    PMC_RETURN(chnl);
} /* digi_otn_odu_chnl_num_internal_get */

/*******************************************************************************
* FUNCTION: digi_otn_server_chnl_num_internal_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Given an OTN server channel handle, retrieves the channel number
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - OTN server channel handle
*
* OUTPUTS:
*
* RETURNS:
*   UINT32          - DCI Channel Number
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32 digi_otn_server_chnl_num_internal_get(digi_handle_t              *digi_handle,
                                                      digi_otn_server_chnl_t     *chnl_handle)
{
    UINT32                          chnl;
    digi_otn_server_chnl_def_t     *chnl_def_handle;
    PMC_ENTRY();
    
    chnl_def_handle = (digi_otn_server_chnl_def_t*) chnl_handle;
    chnl = chnl_def_handle->dci_chnl;

    PMC_RETURN(chnl);
} /* digi_otn_server_chnl_num_internal_get */

/*******************************************************************************
* FUNCTION: digi_otn_server_stream_num_internal_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Given an OTN server channel handle, retrieves the stream number
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - OTN server channel handle
*
* OUTPUTS:
*
* RETURNS:
*   UINT32          - DSI Stream Number
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32 digi_otn_server_stream_num_internal_get(digi_handle_t              *digi_handle,
                                                       digi_otn_server_chnl_t     *chnl_handle)
{
    UINT32                          chnl;
    digi_otn_server_chnl_def_t     *chnl_def_handle;
    PMC_ENTRY();
    
    chnl_def_handle = (digi_otn_server_chnl_def_t*) chnl_handle;
    chnl = chnl_def_handle->dsi_base_chnl;

    PMC_RETURN(chnl);
} /* digi_otn_server_stream_num_internal_get */


/*******************************************************************************
* FUNCTION: digi_otn_odu_level_internal_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the odu level from an ODU channel handle 
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - OTN channel handle for HO/MO/LO framer
*
* OUTPUTS:
*
* RETURNS:
*   UINT32          - ODU level
*
* NOTES:
*
*******************************************************************************/
PRIVATE odu_struct_odu_level_t digi_otn_odu_level_internal_get(digi_handle_t              *digi_handle,
                                                               digi_otn_odu_chnl_t        *chnl_handle)
{
    odu_struct_odu_level_t   odu_level;
    odu_struct_t            *odu_ptr;
    PMC_ENTRY();
    
    odu_ptr     = (odu_struct_t *)chnl_handle;
    odu_level   = odu_ptr->mem_ptr->odu_level;

    PMC_RETURN(odu_level);
} /* digi_otn_odu_level_internal_get */


/*******************************************************************************
* FUNCTION: digi_otn_pool_id_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Given a HO/MO/LO OTN channel handle, retrieves the pool id's
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - OTN channel handle for HO/MO/LO framer
*
* OUTPUTS:
*   pool_id_ptr     - Pointer to array of pool id's for channel handle
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_pool_id_get(digi_handle_t              *digi_handle,
                                      digi_otn_odu_chnl_t        *chnl_handle,
                                      UINT32                     *pool_id_ptr)
{
    PMC_ERROR        result = PMC_SUCCESS;
    odu_struct_t    *odu_ptr;
    UINT32           i;
    PMC_ENTRY();
    
    odu_ptr = (odu_struct_t *)chnl_handle;

    for (i = 0; i < LAST_DIGI_OTN_TCM_NUM; i++)
    {
        if (TRUE == digi_otn_is_tcm_pid_valid(digi_handle, chnl_handle, i))
        {
            pool_id_ptr[i] = odu_ptr->pool_id_array[i];
        }
        else
        {
            pool_id_ptr[i] = DIGI_OTN_TCM_PID_INVALID;
        }
        
    } /* end for */


    PMC_RETURN(result);
} /* digi_otn_pool_id_get */



/*******************************************************************************
* FUNCTION: digi_otn_pmon_ptr_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieve source pointers for OTN PMON based on HO/MO/LO channels and
*   LINE/SYS OTN sources
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to retrieve PMON on
*   fw_pmon_ptr     - Pointer to PMON FW shared memory
*
* OUTPUTS:
*   tcm_pptr        - TCM PMON table to access from shared memory
*   pm_pptr         - PM PMON table to access from shared memory
*   prbs_pptr       - PRBS PMON table to access from shared memory
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_pmon_ptr_get(digi_handle_t                            *digi_handle,
                                        digi_otn_odu_chnl_t                      *chnl_handle,
                                        digi_pmon_t                              *fw_pmon_ptr,
                                        digi_pmon_coreotn_odukt_counters_t      **tcm_pptr,
                                        digi_pmon_coreotn_odukp_counters_t      **pm_pptr,
                                        digi_pmon_coreotn_odukp_prbs_counter_t  **prbs_pptr)
{
    PMC_ERROR               result = PMC_SUCCESS;
    odu_struct_odu_level_t  odu_level;
    coreotn_handle_t       *coreotn_handle;
    coreotn_prbs_inst_t     prbs_inst;
    UINT32                  dci_chnl;
    UINT32                  prbs_chnl;
    BOOL                    prbs_chnl_valid;
    
    PMC_ENTRY();

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != fw_pmon_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != tcm_pptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != pm_pptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != prbs_pptr, DIGI_ERR_NULL_HANDLE, 0, 0);

    coreotn_handle = digi_handle->coreotn_handle;
    
    


    if (PMC_SUCCESS == result)
    {
        /* Determine if HO/MO/LO */
        odu_level = digi_otn_odu_level_internal_get(digi_handle, chnl_handle);

        if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == FALSE)
        {
            switch (odu_level)
            {
              case ODU_STRUCT_LEVEL_HO_ODU:
                *tcm_pptr     = fw_pmon_ptr->coreotn_stg1_tcm;
                *pm_pptr      = fw_pmon_ptr->coreotn_stg1_pm;
                *prbs_pptr    = fw_pmon_ptr->coreotn_stg1_prbs;
                prbs_inst     = COREOTN_FMF1_PRBS;
                break;

              case ODU_STRUCT_LEVEL_MO_ODU:
                *tcm_pptr     = fw_pmon_ptr->coreotn_stg2_tcm;
                *pm_pptr      = fw_pmon_ptr->coreotn_stg2_pm;
                *prbs_pptr    = fw_pmon_ptr->coreotn_stgn_prbs;
                prbs_inst     = COREOTN_FMF2_PRBS;
                break;

              case ODU_STRUCT_LEVEL_LO_ODU:
                *tcm_pptr     = fw_pmon_ptr->coreotn_stg3a_tcm;
                *pm_pptr      = fw_pmon_ptr->coreotn_stg3a_pm;
                *prbs_pptr    = NULL;
                prbs_inst     = LAST_COREOTN_PRBS_INST;
                break;

              case ODU_STRUCT_LEVEL_3B_ODU:
                *tcm_pptr     = fw_pmon_ptr->coreotn_stg3b_tcm;
                *pm_pptr      = fw_pmon_ptr->coreotn_stg3b_pm;
                *prbs_pptr    = NULL;
                prbs_inst     = LAST_COREOTN_PRBS_INST;
                break;

              case ODU_STRUCT_LEVEL_4_ODU:
                *tcm_pptr     = fw_pmon_ptr->coreotn_stg4_tcm;
                *pm_pptr      = fw_pmon_ptr->coreotn_stg4_pm;
                *prbs_pptr    = fw_pmon_ptr->coreotn_stg4_prbs;
                prbs_inst     = COREOTN_FO2_PRBS;
                break;

              case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
                result = DIGI_ERR_NO_SW_CONTENT;
                break;

              default:
                PMC_ASSERT(0, DIGI_ERR_CODE_ASSERT, odu_level, LAST_ODU_STRUCT_LEVEL);
                break;
            }
        }  
        else
        {
            /* SYSOTN */
            switch (odu_level)
            {
              case ODU_STRUCT_LEVEL_HO_ODU:
                *tcm_pptr     = fw_pmon_ptr->coreotn_stgn_tcm;
                *pm_pptr      = fw_pmon_ptr->coreotn_stgn_pm;
                *prbs_pptr    = fw_pmon_ptr->coreotn_stgn_prbs;
                prbs_inst     = COREOTN_FMF2_PRBS;
                break;

              case ODU_STRUCT_LEVEL_MO_ODU:
                *tcm_pptr     = fw_pmon_ptr->coreotn_stg3a_tcm;
                *pm_pptr      = fw_pmon_ptr->coreotn_stg3a_pm;
                *prbs_pptr    = NULL;
                prbs_inst     = LAST_COREOTN_PRBS_INST;
                break;

              case ODU_STRUCT_LEVEL_LO_ODU:
                *tcm_pptr     = fw_pmon_ptr->coreotn_stg1_tcm;
                *pm_pptr      = fw_pmon_ptr->coreotn_stg1_pm;
                *prbs_pptr    = fw_pmon_ptr->coreotn_stg1_prbs;
                prbs_inst     = COREOTN_FMF1_PRBS;
                break;
              
              case ODU_STRUCT_LEVEL_3B_ODU:
                *tcm_pptr     = fw_pmon_ptr->coreotn_stg3b_tcm;
                *pm_pptr      = fw_pmon_ptr->coreotn_stg3b_pm;
                *prbs_pptr    = NULL;
                prbs_inst     = LAST_COREOTN_PRBS_INST;
                break;

              case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
                *tcm_pptr     = fw_pmon_ptr->coreotn_stg2_tcm;
                *pm_pptr      = fw_pmon_ptr->coreotn_stg2_pm;
                *prbs_pptr    = NULL;
                prbs_inst     = COREOTN_FMF1_PRBS;
                break;
              
              case ODU_STRUCT_LEVEL_4_ODU:
                *tcm_pptr     = fw_pmon_ptr->coreotn_stg4_tcm;
                *pm_pptr      = fw_pmon_ptr->coreotn_stg4_pm;
                *prbs_pptr    = fw_pmon_ptr->coreotn_stg4_prbs;
                prbs_inst     = COREOTN_FO2_PRBS;
                break;

              default:
                PMC_ASSERT(0, DIGI_ERR_CODE_ASSERT, odu_level, LAST_ODU_STRUCT_LEVEL);
                break;
            }
        } /* end if */
    }

    if (PMC_SUCCESS == result)
    {
        /* Retrieve the PRBS channel attached to this ODU channel */
        dci_chnl = digi_otn_odu_chnl_num_internal_get(digi_handle, chnl_handle);
        coreotn_prbs_chnl_get(coreotn_handle, prbs_inst, dci_chnl, &prbs_chnl, &prbs_chnl_valid);

        if ((TRUE == prbs_chnl_valid) && (NULL != *prbs_pptr))
        {
            *prbs_pptr = &((*prbs_pptr)[prbs_chnl]);
        }
        else
        {
            *prbs_pptr = NULL;
        }
    }

    PMC_RETURN(result);
} /* digi_otn_pmon_ptr_get */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_filter_create()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Copy framer and pid filter tables into a single coreotn interrupt table.
*
* INPUTS:
*   digi_handle           - Pointer to digi handle
*   framer_filt_table_ptr - Framer filter interrupt table
*   pid_filt_table_ptr    - PID filter interrupt table
*
* OUTPUTS:
*   filt_table_pptr       - Coreotn filter interrupt table
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_filter_create(digi_handle_t              *digi_handle,
                                                 coreotn_int_framer_chnl_t  *framer_filt_table_ptr,
                                                 odu_rfrm_int_pid_chnl_t    *pid_filt_table_ptr,
                                                 coreotn_int_chnl_t         **filt_table_pptr)
{
    PMC_ERROR           result = PMC_SUCCESS;
    coreotn_int_chnl_t *filt_table_ptr;


    PMC_ENTRY();


    if (IS_DIGI_INT_ALL_INTS(framer_filt_table_ptr) &&
        IS_DIGI_INT_ALL_INTS(pid_filt_table_ptr))
   
    {
        *filt_table_pptr = DIGI_INT_ALL_INTS;
    }
    else
    {
        filt_table_ptr = *filt_table_pptr;
        PMC_MEMSET(filt_table_ptr, 0, sizeof(*filt_table_ptr));

        if (NULL != framer_filt_table_ptr)
        {
            PMC_MEMCPY(&filt_table_ptr->framer_chnl, framer_filt_table_ptr, sizeof(*framer_filt_table_ptr));
        }
        
        if (NULL != pid_filt_table_ptr)
        {
            PMC_MEMCPY(&filt_table_ptr->pid.rx_tcm[0], pid_filt_table_ptr, sizeof(odu_rfrm_int_pid_chnl_t));
        }
    }


    PMC_RETURN(result);
} /* digi_otn_odu_int_filter_create */


/*******************************************************************************
* FUNCTION: digi_otn_tcm_pid_valid_set()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Sets whether or not a given HO/MO/LO channel id's TCM PID slots contain
*   valid PID values or not.
*
*   The PID values in odu_struct_t are 8-bits, supporting the required 256
*   unique PIDs. This does not leave a slot for an invalid flag,
*   so this function tracks the PID validity in a bit array organized
*   by ODU level, channel id, and TCM PID slot.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - ODU channel handle
*   tcm_pid_slot    - TCM PID slot (0..6)
*   valid           - boolean to set if PID is valid or not.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_tcm_pid_valid_set(digi_handle_t           *digi_handle,
                                            digi_otn_odu_chnl_t     *chnl_handle,
                                            UINT32                   tcm_pid_slot,
                                            BOOL                     valid)
{
    PMC_ERROR                result = PMC_SUCCESS;
    odu_struct_odu_level_t   odu_level;
    UINT32                   chnl_id;

    PMC_ENTRY();
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    odu_level = digi_otn_odu_level_internal_get(digi_handle, chnl_handle);
    chnl_id   = digi_otn_odu_chnl_num_internal_get(digi_handle, chnl_handle);

    result = coreotn_tcm_pid_valid_set(digi_handle->coreotn_handle,
                                       odu_level,
                                       chnl_id,
                                       tcm_pid_slot,
                                       valid);


    PMC_RETURN(result);
} /* digi_otn_tcm_pid_valid_set */


/*******************************************************************************
* FUNCTION: digi_otn_is_tcm_pid_valid()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns if a TCM PID slot is valid given odu level, channel id, and tcm pid
*   slot number
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - ODU channel handle
*   tcm_pid_slot    - TCM PID slot (0..6)
*
* OUTPUTS:
*
* RETURNS:
*   TRUE    - TCM PID slot is valid
*   FALSE   - TCM PID slot is not valid
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL digi_otn_is_tcm_pid_valid(digi_handle_t           *digi_handle,
                                      digi_otn_odu_chnl_t     *chnl_handle,
                                      UINT32                   tcm_pid_slot)
{
    BOOL                     result;
    odu_struct_odu_level_t   odu_level;
    UINT32                   chnl_id;

    PMC_ENTRY();
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    odu_level = digi_otn_odu_level_internal_get(digi_handle, chnl_handle);
    chnl_id   = digi_otn_odu_chnl_num_internal_get(digi_handle, chnl_handle);

    result = coreotn_is_tcm_pid_valid(digi_handle->coreotn_handle,
                                      odu_level,
                                      chnl_id,
                                      tcm_pid_slot);


    PMC_RETURN(result);
} /* digi_otn_is_tcm_pid_valid */

/*******************************************************************************
* FUNCTION: digi_oduksw_mpmo_debug_latency_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the PKT_AGE from debug registers.  If the channel handle is invalid
*   for this feature an error will be returned.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   output_pc_ptr   - Pointer to channel handle for the ODUKSW outbound
*                     port to make the latency measurement on.
*
* OUTPUTS:
*   debug_latency_ptr  - Pointer to the recovered packet age for the channel.
*                        Units 3.125 nsecond ticks.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_oduksw_mpmo_debug_latency_get(digi_handle_t *digi_handle,
                                                    util_global_switch_data_t *output_pc_ptr,
                                                    UINT32 *debug_latency_ptr)
{

    UINT32 dummy = 0, debug_latency = 0;
    util_global_switch_data_def_t *output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;
    util_global_oduk_port_data_t *local_output_pc_ptr = &output_pc_data_ptr->oduk_data;
    mpmo_type_id_t mpmo_type = MPMO_NUM_TYPES;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(output_pc_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    result = digi_oduksw_chnl_validate(digi_handle, output_pc_ptr);

    if (PMC_SUCCESS == result)
    {
        output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;
        local_output_pc_ptr = &(output_pc_data_ptr->oduk_data);

        /* test if channel handle FO1, FO2 or CTL */
        switch(local_output_pc_ptr->port_type)
        {
        case UTIL_GLOBAL_ODUK_PORT_ILKN1:
            if(digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
            {
                /* ODUKSW port used by LINEOTN -> HO -> ODUKSW */
                mpmo_type = MPMO_COREOTN_CTL;
            }
            break;
        case UTIL_GLOBAL_ODUK_PORT_COREOTN:
            mpmo_type = MPMO_COREOTN_MUX_FRAMER;
            break;
        case UTIL_GLOBAL_ODUK_PORT_MAPOTN:
            mpmo_type = MPMO_COREOTN_TO_MAPOTN;
            break;
        default:
            /* If not FO1, FO2 or CTL, the delay measurement cannot be made */
            result = DIGI_ERR_INVALID_PORT_TYPE;
            break;
        }
    }
    
   
    if(PMC_SUCCESS==result)
    {
        result = coreotn_mpmo_debug_data_get(digi_handle->coreotn_handle,
                                             mpmo_type,
                                             local_output_pc_ptr->channel,
                                             &debug_latency,
                                             &dummy,
                                             &dummy);
        
        *debug_latency_ptr = debug_latency;
    }


    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_oduksw_mpmo_debug_latency_get */

/*******************************************************************************
* FUNCTION: digi_oduksw_mpmo_raw_latency_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the PKT_AGE using a raw retieval mechanism.  If the channel handle is 
*   invalid for this feature an error will be returned.\n\n
*
*   The raw retrieval mechanism is destructive to the flow of traffic on the
*   channel.  This API should be used for development purposes only.  It
*   should not be used for operational paths in fielded systems.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   output_pc_ptr   - Pointer to channel handle for the ODUKSW outbound
*                     port to make the latency measurement on.
*
* OUTPUTS:
*   minimum_raw_latency  - Pointer to the recovered packet age for the channel.
*                          Units are equal to 3.125 nseconds each
*   maximum_raw_latency  - Pointer to the recovered packet age for the channel.
*                          Units are equal to 3.125 nseconds each
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_oduksw_mpmo_raw_latency_get(digi_handle_t *digi_handle,
                                                  util_global_switch_data_t *output_pc_ptr,
                                                  UINT32 *minimum_raw_latency,
                                                  UINT32 *maximum_raw_latency)
{

    UINT32 min_latency = 0, max_latency = 0;
    util_global_switch_data_def_t *output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;
    util_global_oduk_port_data_t *local_output_pc_ptr = &output_pc_data_ptr->oduk_data;
    mpmo_type_id_t mpmo_type = MPMO_NUM_TYPES;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(output_pc_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    result = digi_oduksw_chnl_validate(digi_handle, output_pc_ptr);

    if (PMC_SUCCESS == result)
    {
        output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;
        local_output_pc_ptr = &(output_pc_data_ptr->oduk_data);


        /* test if channel handle FO1, FO2 or CTL */
        switch(local_output_pc_ptr->port_type)
        {
        case UTIL_GLOBAL_ODUK_PORT_ILKN1:
            if(digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
            {
                /* ODUKSW port used by LINEOTN -> HO -> ODUKSW */
                mpmo_type = MPMO_COREOTN_CTL;
            }
            break;
        case UTIL_GLOBAL_ODUK_PORT_COREOTN:
            mpmo_type = MPMO_COREOTN_MUX_FRAMER;
            break;
        case UTIL_GLOBAL_ODUK_PORT_MAPOTN:
            mpmo_type = MPMO_COREOTN_TO_MAPOTN;
            break;
        default:
            /* If not FO1, FO2 or CTL, the delay measurement cannot be made */
            result = DIGI_ERR_INVALID_PORT_TYPE;
            break;
        }
    }
    if(PMC_SUCCESS==result)
    {
        result = coreotn_mpmo_raw_latency_get(digi_handle->coreotn_handle,
                                              mpmo_type,
                                              local_output_pc_ptr->channel,
                                              &min_latency,
                                              &max_latency);
    
        *minimum_raw_latency = min_latency;
        *maximum_raw_latency = max_latency;
    }

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_oduksw_mpmo_raw_latency_get */


/*******************************************************************************
* FUNCTION: digi_otn_server_pmon_fec_link_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the valid set of links to retrieve for Line/Sys OTN FEC PMON.  
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to retrieve PMON on
*
* OUTPUTS:
* *fec_link         - Array of links to retrieve for FEC PMON
* *num_fec_link     - Number of valid links in returned array
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_pmon_fec_link_get(digi_handle_t           *digi_handle,
                                                    digi_otn_server_chnl_t  *chnl_handle,
                                                    UINT32                  *fec_link,
                                                    UINT32                  *num_fec_link)

{
    PMC_ERROR       result = PMC_SUCCESS;
    UINT32          link;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_handle  != NULL, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(fec_link     != NULL, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(num_fec_link != NULL, DIGI_ERR_INVALID_ARG, 0, 0);


    /* Determine DSI base channel stored in OTN server handle */
    link = digi_otn_server_stream_num_internal_get(digi_handle, chnl_handle);    

    if (DIGI_OTN_SERVER_IS_LINE(chnl_handle))
    {
        if (digi_otn_server_stream_is_10g(digi_handle, chnl_handle))
        {
            *num_fec_link = 1;
            fec_link[0]   = link;
        }
        else if (digi_otn_server_stream_is_40g(digi_handle, chnl_handle))
        {
            /* 40G counters will be on 3, 7, or 11 */
            *num_fec_link = 1;
            fec_link[0]   = link+3;
            
            /* Check that link is 0, 4, or 8 */
            PMC_ASSERT(link%4 == 0, DIGI_ERR_INVALID_ARG, link, 0);
        }
        else if (digi_otn_server_stream_is_100g(digi_handle, chnl_handle))
        {
            /* 100G counters will be the summation of counters on 3, 7, and 11 */
            *num_fec_link = 3;
            fec_link[0]   = 3;
            fec_link[1]   = 7;
            fec_link[2]   = 11;
        }
        else
        {
            PMC_ASSERT(NULL, DIGI_ERR_INVALID_ARG, 0, 0);
        }
    }
    else
    {
        /* SYSOTN only has one counter for FEC */
        *num_fec_link = 1;
        fec_link[0]   = 0;
    }
    
    PMC_RETURN(result);
} /* digi_otn_server_pmon_fec_link_get */






/*******************************************************************************
* FUNCTION: digi_otn_server_pmon_chnl_retrieve_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves a channel PMON table with PMON counters
*   for a single channel in the subsystem.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to retrieve PMON on
*
* OUTPUTS:
*   pmon_table_ptr  - pointer to channel PMON table to store counters 
*                     for a single channel
*
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_pmon_chnl_retrieve_internal(digi_handle_t                *digi_handle,
                                                              digi_otn_server_chnl_t       *chnl_handle,
                                                              digi_otn_server_pmon_chnl_t  *pmon_table_ptr)
{
    PMC_ERROR                                result = PMC_SUCCESS;
    UINT32                                   link, fec_link[3];
    UINT32                                   num_fec_link;
    UINT32                                   i, j;
    digi_pmon_t                             *fw_pmon_ptr = NULL;
    digi_pmon_lineotn_otu_frm_counters_t    *fw_otn_ptr = NULL; 
    digi_pmon_lineotn_fec_counters_fw_t     *fw_fec_ptr = NULL;
    UINT32                                  *pmon_fec_field_ptr;
    UINT32                                  *fw_fec_field_ptr;
    
    PMC_ENTRY();
    result = digi_pmon_chnl_param_check(digi_handle, chnl_handle, pmon_table_ptr); 

    if (PMC_SUCCESS == result)
    {
       result = digi_pmon_shared_mem_get(digi_handle, &fw_pmon_ptr); 
    }

    if (PMC_SUCCESS == result)
    {
        if (DIGI_OTN_SERVER_IS_LINE(chnl_handle))
        {
            fw_otn_ptr = fw_pmon_ptr->lineotn_otn;
            fw_fec_ptr = fw_pmon_ptr->lineotn_fec;
        }
        else
        {
            fw_otn_ptr = &fw_pmon_ptr->sysotn_otn;
            fw_fec_ptr = &fw_pmon_ptr->sysotn_fec;
        }
    }

    /* retrieve dci channel id associated to otn server channel */
    link = digi_otn_server_chnl_num_internal_get(digi_handle, chnl_handle);

    /* line/sys OTN PMON */
    if (PMC_SUCCESS == result)
    {
        PMC_MEMCPY(&pmon_table_ptr->framer,
                   &fw_otn_ptr[link],
                   sizeof(digi_pmon_lineotn_otu_frm_counters_t));
    }


    /* line/sys FEC PMON */
    if (PMC_SUCCESS == result)
    {
        /* Based on datarate, retrieve the links we need to sum FEC PMON counters */
        digi_otn_server_pmon_fec_link_get(digi_handle, chnl_handle, fec_link, &num_fec_link);

        for (i = 0; i < num_fec_link; i++)
        {
            pmon_fec_field_ptr = (UINT32 *) &pmon_table_ptr->fec;
            fw_fec_field_ptr   = (UINT32 *) &fw_fec_ptr[fec_link[i]];

            for (j = 0; j < sizeof(digi_pmon_lineotn_fec_counters_fw_t)/sizeof(UINT32); j++)
            {
                /* Sum FW field with channelized pmon table field */
                *pmon_fec_field_ptr += *fw_fec_field_ptr;

                /* Increment field ptrs to next UINT32 */
                pmon_fec_field_ptr++;
                fw_fec_field_ptr++;
            }
        } 
    }

    
    PMC_RETURN(result);
} /* digi_otn_server_pmon_chnl_retrieve_internal */

/*******************************************************************************
* FUNCTION: digi_otn_odu_pmon_chnl_retrieve_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves a channel PMON table with PMON counters
*   for a single channel in the subsystem.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to retrieve PMON on
*
* OUTPUTS:
*   pmon_table_ptr  - pointer to channel PMON table to store counters 
*                     for a single channel
*
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_pmon_chnl_retrieve_internal(digi_handle_t                  *digi_handle,
                                                          digi_otn_odu_chnl_t            *chnl_handle,
                                                          digi_otn_odu_pmon_chnl_data_t  *pmon_table_ptr)
{
    PMC_ERROR               result = PMC_SUCCESS;
    UINT32                  i;
    UINT32                  link;
    UINT32                  pool_id[LAST_DIGI_OTN_TCM_NUM];
    UINT32                  tcm_pid;
    digi_pmon_t            *fw_pmon_ptr;
    

    digi_pmon_coreotn_odukt_counters_t       *src_tcm = NULL;
    digi_pmon_coreotn_odukp_counters_t       *src_pm = NULL;
    digi_pmon_coreotn_odukp_prbs_counter_t   *src_prbs = NULL;
    
    
    PMC_ENTRY();
    result = digi_pmon_chnl_param_check(digi_handle, chnl_handle, pmon_table_ptr); 

    if (PMC_SUCCESS == result)
    {
       result = digi_pmon_shared_mem_get(digi_handle, &fw_pmon_ptr); 
    }
    
    if (PMC_SUCCESS == result)
    {
        /* Determine link of odu_struct */
        link = digi_otn_odu_chnl_num_internal_get(digi_handle, chnl_handle);    
    }

    if (PMC_SUCCESS == result)
    {
        /* Get pool id array link of odu_struct */
        (void)digi_otn_pool_id_get(digi_handle, chnl_handle, pool_id); 
    }

    if (PMC_SUCCESS == result)
    {
        result = digi_otn_pmon_ptr_get(digi_handle,
                                       chnl_handle,
                                       fw_pmon_ptr,
                                       &src_tcm,
                                       &src_pm,
                                       &src_prbs);
    }

    if (PMC_SUCCESS == result)
    {
        /* OTN TCM */
        for (i = 0; i < LAST_DIGI_OTN_TCM_NUM; i++)
        {
            /* Retrieve pool_ids configured on this channel */
            tcm_pid = pool_id[i];

            /* Store pool_id or DIGI_OTN_TCM_PID_INVALID */
            pmon_table_ptr->tcm_pool_ids[i] = tcm_pid;
           
            /* Check if pool id is valid */
            if (DIGI_OTN_IS_TCM_PID_VALID(tcm_pid))
            {
                PMC_MEMCPY(&pmon_table_ptr->tcm[i],
                           &src_tcm[tcm_pid],
                           sizeof(digi_pmon_coreotn_odukt_counters_t));
            } 
        }

        /* OTN PM */
        PMC_MEMCPY(&pmon_table_ptr->pm,
                   &src_pm[link],
                   sizeof(pmon_table_ptr->pm));
      
        /* OTN PRBS */
        if (NULL == src_prbs)
        {
            pmon_table_ptr->prbs_valid = FALSE;
        }
        else
        {
            pmon_table_ptr->prbs_valid = TRUE;
            PMC_MEMCPY(&pmon_table_ptr->prbs,
                       src_prbs,
                       sizeof(pmon_table_ptr->prbs));
        }
        
    }

    
    PMC_RETURN(result);
} /* digi_otn_odu_pmon_chnl_retrieve_internal */




/*******************************************************************************
* FUNCTION: digi_otn_odu_int_odu_range_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Returns a range of ODU levels (HO/MO/LO) based on channel handle. 
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - Channel handle, or DIGI_INT_ALL_CHNLS 
*
* OUTPUTS:
*   odu_list        - List of ODU levels to process
*   num_odu         - Number of ODU levels in the list
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_odu_range_get(digi_handle_t          *digi_handle,
                                                 digi_otn_odu_chnl_t    *chnl_handle,
                                                 odu_struct_odu_level_t *odu_list,
                                                 UINT32                 *num_odu)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(odu_list != NULL, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(num_odu  != NULL, DIGI_ERR_INVALID_ARG, 0, 0);
    /*
     * For DIGI_INT_ALL_CHNLS restrict to 3 levels (HO/MO/LO). 
     * For individual channels can access whatever ODU level is defined
     * for the particular channel.
     */
    if (IS_DIGI_INT_ALL_CHNLS(chnl_handle))
    {
        odu_list[0] = ODU_STRUCT_LEVEL_HO_ODU;
        odu_list[1] = ODU_STRUCT_LEVEL_MO_ODU;
        odu_list[2] = ODU_STRUCT_LEVEL_LO_ODU;
        *num_odu    = 3;
    }
    else
    {
        /* One channel case */
        /* Determine which ODU level channel handle is for */
        *odu_list = DIGI_OTN_ODU_LEVEL_GET(chnl_handle);
        *num_odu  = 1;
    }


    PMC_RETURN(result);
} /* digi_otn_odu_int_odu_range_get */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_pid_range_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Returns a range of TCM PIDs and checks for valid pool id input
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_level       - ODU level (HO/MO/LO/stg3b)
*   pool_id         - PID, or DIGI_OTN_INT_ALL_PIDS to specify all PIDs in the ODU level
*
* OUTPUTS:
*   pid_start       - Starting pool id 
*   pid_end         - Ending pool id 
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_pid_range_get(digi_handle_t          *digi_handle,
                                                 odu_struct_odu_level_t  odu_level,
                                                 UINT32                  pool_id,
                                                 UINT32                 *pid_start,
                                                 UINT32                 *pid_end)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    if (DIGI_OTN_INT_IS_ALL_PIDS(pool_id))
    {
        /* All PIDs case */
        *pid_start = 0;

        switch (odu_level)
        {

          case ODU_STRUCT_LEVEL_HO_ODU:
          case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
            *pid_end = TCM_POOL_SIZE_12;
            break;
          
          case ODU_STRUCT_LEVEL_MO_ODU:
          case ODU_STRUCT_LEVEL_LO_ODU:
          case ODU_STRUCT_LEVEL_3B_ODU:
          case ODU_STRUCT_LEVEL_4_ODU:
            *pid_end = TCM_POOL_SIZE_96;
            break;
            
          default:
            PMC_ASSERT(NULL, DIGI_ERR_CODE_ASSERT, odu_level, 0);
            break;
        } /* end switch */
        
    }
    else
    {
        switch (odu_level)
        {
          case ODU_STRUCT_LEVEL_HO_ODU:
          case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
            if (pool_id >= TCM_POOL_SIZE_12)
            {
                result = DIGI_OTN_ODU_PID_OUT_OF_RANGE;
            }
            break;
          
          case ODU_STRUCT_LEVEL_MO_ODU:
          case ODU_STRUCT_LEVEL_LO_ODU:
          case ODU_STRUCT_LEVEL_3B_ODU:
          case ODU_STRUCT_LEVEL_4_ODU:
            if (pool_id >= TCM_POOL_SIZE_96)
            {
                result = DIGI_OTN_ODU_PID_OUT_OF_RANGE;
            }
            break;
            
          default:
            PMC_ASSERT(NULL, DIGI_ERR_CODE_ASSERT, odu_level, 0);
            break;
        } /* end switch */
        
         if (PMC_SUCCESS == result)
         {
            *pid_start = pool_id;
            *pid_end   = pool_id + 1;
         }
         else
         {
            *pid_start = DIGI_OTN_TCM_PID_INVALID;
            *pid_end   = DIGI_OTN_TCM_PID_INVALID;
         }
    }


    PMC_RETURN(result);
} /* digi_otn_odu_int_pid_range_get */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_en_framer_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the specific framer enabled interrupt table from 
*   based on odu level (HO/MO/LO/stg3b/stg4)
*
* INPUTS:
*   digi_handle         - Pointer to digi handle
*   odu_level           - HO/MO/LO/stg3b/stg4 odu level
*
* OUTPUTS:
*   framer_en_pptr      - channelized enabled framer interrupt table
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_en_framer_get(digi_handle_t              *digi_handle,
                                                odu_struct_odu_level_t      odu_level,
                                                coreotn_int_framer_chnl_t **framer_en_pptr)
{
    PMC_ERROR               result = PMC_SUCCESS;
    digi_int_otn_t         *otn_en_table_ptr; 

    PMC_ENTRY();
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(framer_en_pptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    otn_en_table_ptr = digi_handle->var.enabled_otn_int;

    /* Determine which ODU level channel handle is for */
    switch (odu_level)
    {
      case ODU_STRUCT_LEVEL_HO_ODU:
        *framer_en_pptr = otn_en_table_ptr->framer_ho;    
        break;
        
      case ODU_STRUCT_LEVEL_MO_ODU:
        *framer_en_pptr = otn_en_table_ptr->framer_mo;    
        break;
        
      case ODU_STRUCT_LEVEL_LO_ODU:
        *framer_en_pptr = otn_en_table_ptr->framer_lo;    
        break;
      
      case ODU_STRUCT_LEVEL_3B_ODU:
        *framer_en_pptr = otn_en_table_ptr->framer_stg3b;    
        break;
      
      case ODU_STRUCT_LEVEL_4_ODU:
        *framer_en_pptr = otn_en_table_ptr->framer_stg4;    
        break;
      
      case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
        *framer_en_pptr = otn_en_table_ptr->framer_sysotn_line;    
        break;
    
      default:
        PMC_RETURN(DIGI_ERR_ODU_LEVEL_NOT_VALID);
        break;
    } /* end switch */

    PMC_RETURN(result);
} /* digi_otn_odu_int_en_framer_get */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_en_pid_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the specific TCM PID enabled interrupt table from 
*   based on odu level (HO/MO/LO)
*
* INPUTS:
*   digi_handle         - Pointer to digi handle
*   odu_level           - HO/MO/LO/stg3b/stg4 odu level
*
* OUTPUTS:
*   pid_en_pptr         - channelized enabled TCM PID interrupt table
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_en_pid_get(digi_handle_t            *digi_handle,
                                              odu_struct_odu_level_t    odu_level,
                                              odu_rfrm_int_pid_chnl_t **pid_en_pptr)
{
    PMC_ERROR           result = PMC_SUCCESS;
    digi_int_otn_t     *otn_en_table_ptr; 

    PMC_ENTRY();
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(pid_en_pptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);


    otn_en_table_ptr = digi_handle->var.enabled_otn_int;

    /* Determine which ODU level channel handle is for */
    switch (odu_level)
    {
      case ODU_STRUCT_LEVEL_HO_ODU:
        *pid_en_pptr = otn_en_table_ptr->pid_ho;    
        break;
        
      case ODU_STRUCT_LEVEL_MO_ODU:
        *pid_en_pptr = otn_en_table_ptr->pid_mo;    
        break;
        
      case ODU_STRUCT_LEVEL_LO_ODU:
        *pid_en_pptr = otn_en_table_ptr->pid_lo;    
        break;
      
      case ODU_STRUCT_LEVEL_3B_ODU:
        *pid_en_pptr = otn_en_table_ptr->pid_stg3b;    
        break;
      
      case ODU_STRUCT_LEVEL_4_ODU:
        *pid_en_pptr = otn_en_table_ptr->pid_stg4;    
        break;
      
      case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
        *pid_en_pptr = otn_en_table_ptr->pid_sysotn_line;    
        break;
    
      default:
        PMC_RETURN(DIGI_ERR_ODU_LEVEL_NOT_VALID);
        break;
    } /* end switch */

    PMC_RETURN(result);
} /* digi_otn_odu_int_en_pid_get */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_odu_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the specific odu interrupt table from within the aggregated 
*   interrupt table based on odu level (HO/MO/LO)
*
* INPUTS:
*   digi_handle         - Pointer to digi handle
*   odu_level           - HO/MO/LO odu level
*   int_table_ptr       - aggregated interrupt table
*
* OUTPUTS:
*   odu_handle_ppptr    - odu channel
*   odu_pptr            - channelized odu interrupt table
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_odu_get(digi_handle_t            *digi_handle,
                                          odu_struct_odu_level_t    odu_level,
                                          digi_otn_int_t           *int_table_ptr,
                                          digi_otn_odu_chnl_t    ***odu_handle_ppptr,
                                          digi_otn_odu_int_chnl_t **odu_pptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    digi_otn_odu_chnl_t       **handle_pptr;
    digi_otn_odu_int_chnl_t    *odu_table_ptr;

    PMC_ENTRY();
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_table_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Determine which ODU level channel handle is for */
    switch (odu_level)
    {
      case ODU_STRUCT_LEVEL_HO_ODU:
        handle_pptr   = int_table_ptr->otn_odu_ho_handle;
        odu_table_ptr = int_table_ptr->otn_odu_ho_chnl;
        break;
        
      case ODU_STRUCT_LEVEL_MO_ODU:
        handle_pptr   = int_table_ptr->otn_odu_mo_handle;
        odu_table_ptr = int_table_ptr->otn_odu_mo_chnl;
        break;
        
      case ODU_STRUCT_LEVEL_LO_ODU:
        handle_pptr   = int_table_ptr->otn_odu_lo_handle;
        odu_table_ptr = int_table_ptr->otn_odu_lo_chnl;
        break;
      
      case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
        handle_pptr   = int_table_ptr->otn_odu_lo_mon_handle;
        odu_table_ptr = int_table_ptr->otn_odu_lo_mon_chnl;
        break;
      default:
        PMC_RETURN(DIGI_ERR_ODU_LEVEL_NOT_VALID);
        break;
    } /* end switch */

    if (NULL != odu_handle_ppptr)
    {
        *odu_handle_ppptr = handle_pptr;
    }
    
    if (NULL != odu_pptr)
    {
        *odu_pptr = odu_table_ptr;
    }

    PMC_RETURN(result);
} /* digi_otn_odu_int_odu_get */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_en_ohp_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves OHP block enabled channelized interrupt table.
*
* INPUTS:
*   digi_handle      - Pointer to digi handle
*   ohp              - Specifies the OHP block 
*
* OUTPUTS:
*   ohp_en_pptr      - channelized enabled framer interrupt table
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_en_ohp_get(digi_handle_t              *digi_handle,
                                              odu_ohp_inst_t              ohp,
                                              odu_ohp_int_chnl_t        **ohp_en_pptr)
{
    PMC_ERROR               result = PMC_SUCCESS;
    digi_int_otn_t         *otn_en_table_ptr; 

    PMC_ENTRY();
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(ohp_en_pptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    otn_en_table_ptr = digi_handle->var.enabled_otn_int;

    /* Determine which OHP channel handle is for */
    switch (ohp)
    {
      case ODU_OHP_1:
        *ohp_en_pptr = otn_en_table_ptr->ohp_1;    
        break;
        
      case ODU_OHP_2:
        *ohp_en_pptr = otn_en_table_ptr->ohp_2;    
        break;
        
      case ODU_OHP_3:
        *ohp_en_pptr = otn_en_table_ptr->ohp_3;    
        break;
      
      default:
        PMC_RETURN(DIGI_ERR_ODU_LEVEL_NOT_VALID);
        break;
    } /* end switch */

    PMC_RETURN(result);
} /* digi_otn_odu_int_en_ohp_get */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_trigger_transfer()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Triggers a transfer of ODU_RFRM interrupt tables to the shadow registers
*   for reading by SW.
*
*   The trigger will transfer interrupts for all ODU_RFRMs, so all following
*   enabled_check() and retrieve() functions should always operate on
*   DIGI_INT_ALL_CHNLS. If we trigger the transfer and only look at a
*   single odu_level, there is a possiblity of missed interrupts in the other
*   RFRMs 
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   latch_defect    - latch defect mode 
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_trigger_transfer(digi_handle_t            *digi_handle, 
                                                   coreotn_latch_defect_t    latch_defect)
{
    PMC_ERROR               result = PMC_SUCCESS;
    UINT32                  start_bit, stop_bit;

    PMC_ENTRY();

    /* when ODU RCP DI is enabled, LCLK1 generators is setup by FW */
    if (FALSE == coreotn_odu_rcp_di_enable_get(digi_handle->coreotn_handle)) 
    {
        /* Skip interrupt retrieve if subsystem is not powered up */
        if (PMC_SUCCESS == result && 
            TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
        {
            PMC_RETURN(PMC_SUCCESS);
        }

        /* Clear trigger Transfer Done interrupt */
        if (PMC_SUCCESS == result)
        {
            result = coreotn_int_transfer_done_clr(digi_handle->coreotn_handle,latch_defect);
            PMC_ASSERT(result == PMC_SUCCESS , DIGI_ERR_NULL_HANDLE, 0, 0);
        }
    

        /* Trigger LCLK to COREOTN Interrupts */
        if (PMC_SUCCESS == result)
        {
            start_bit = DIGI_INT_COREOTN_LCLK1_TRIGGER;
            stop_bit  = DIGI_INT_COREOTN_LCLK1_TRIGGER;

            digi_pgmrclk_field_range_LCLK_OUT_EN_set(NULL, digi_handle, start_bit, stop_bit, DIGI_DISABLE);
            digi_pgmrclk_field_range_LCLK_OUT_MAN_PULS_EN_set(NULL, digi_handle, start_bit, stop_bit, DIGI_ENABLE);
            digi_pgmrclk_field_range_LCLK_OUT_EN_set(NULL, digi_handle, start_bit, stop_bit, DIGI_ENABLE);

            digi_pgmrclk_field_range_LCLK_OUT_MAN_PULS_set(NULL, digi_handle, start_bit, stop_bit, DIGI_ENABLE);
            digi_pgmrclk_field_range_LCLK_OUT_MAN_PULS_set(NULL, digi_handle, start_bit, stop_bit, DIGI_DISABLE);
            digi_pgmrclk_field_range_LCLK_OUT_MAN_PULS_EN_set(NULL, 
                                                              digi_handle,
                                                              start_bit, 
                                                              stop_bit, 
                                                              DIGI_DISABLE); 
        }

        /* Poll Transfer Done interrupt */
        if (PMC_SUCCESS == result)
        {
            result = coreotn_int_transfer_done_poll(digi_handle->coreotn_handle,latch_defect);
            PMC_ASSERT(result == PMC_SUCCESS , DIGI_ERR_NULL_HANDLE, 0, 0);
        }
    }

    PMC_RETURN(result);
} /* digi_otn_odu_int_trigger_transfer */

/*******************************************************************************
* FUNCTION: digi_otn_odu_handle_pool_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves a pointer to the ODU handle pool based on odu level
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_level       - odu level
*
* OUTPUTS:
*  odu_pool_pptr    - Pointer to odu handle pool
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_handle_pool_get(digi_handle_t           *digi_handle,
                                              odu_struct_odu_level_t   odu_level,
                                              odu_struct_t           **odu_pool_pptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(odu_pool_pptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    /* Determine which ODU level channel handle is for */
    switch (odu_level)
    {
      case ODU_STRUCT_LEVEL_HO_ODU:
        *odu_pool_pptr = digi_handle->handle_pool.ho_odu_struct;
        break;
        
      case ODU_STRUCT_LEVEL_MO_ODU:
        *odu_pool_pptr = digi_handle->handle_pool.mo_odu_struct;
        break;
        
      case ODU_STRUCT_LEVEL_LO_ODU:
        *odu_pool_pptr = digi_handle->handle_pool.lo_odu_struct;
        break;
      
      case ODU_STRUCT_LEVEL_3B_ODU:
        *odu_pool_pptr = digi_handle->handle_pool.s3b_odu_struct;
        break;
      
      case ODU_STRUCT_LEVEL_4_ODU:
        *odu_pool_pptr = digi_handle->handle_pool.s4_odu_struct;
        break;
      
      case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
        *odu_pool_pptr = digi_handle->handle_pool.sysotn_line_struct;
        break;
    
      default:
        result = DIGI_ERR_ODU_LEVEL_NOT_VALID;
        break;
    } /* end switch */


    PMC_RETURN(result);
} /* digi_otn_odu_handle_pool_get */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_link_range_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Determines the range of links to retrieve ODU interrupts based on channel
*  handle type and odu level
*
* INPUTS:
*   digi_handle     - Pointer to DIGI handle
*   chnl_handle     - Pointer to channel handle
*   odu_level       - ODU level of the channel
*
* OUTPUTS:
*   start_link      - Start link to retrieve
*   end_link        - End link to retrieve
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_link_range_get(digi_handle_t             *digi_handle,
                                                 void                      *chnl_handle,
                                                 odu_struct_odu_level_t     odu_level,
                                                 UINT32                    *start_link,
                                                 UINT32                    *end_link)
{
    PMC_ERROR            result = PMC_SUCCESS;
    UINT32               end_link_tbl[LAST_COREOTN_INT_SOURCE][LAST_ODU_STRUCT_LEVEL];
    coreotn_int_source_t line_sys;



    end_link_tbl[COREOTN_INT_SOURCE_LINE][ODU_STRUCT_LEVEL_HO_ODU] = DIGI_OTN_SERVER_HO_CHNL_MAX;
    end_link_tbl[COREOTN_INT_SOURCE_LINE][ODU_STRUCT_LEVEL_MO_ODU] = DIGI_OTN_SERVER_LO_CHNL_MAX;
    end_link_tbl[COREOTN_INT_SOURCE_LINE][ODU_STRUCT_LEVEL_LO_ODU] = DIGI_OTN_SERVER_LO_CHNL_MAX;
    end_link_tbl[COREOTN_INT_SOURCE_LINE][ODU_STRUCT_LEVEL_3B_ODU] = DIGI_OTN_SERVER_LO_CHNL_MAX;
    end_link_tbl[COREOTN_INT_SOURCE_LINE][ODU_STRUCT_LEVEL_4_ODU]  = DIGI_OTN_SERVER_LO_CHNL_MAX;
    end_link_tbl[COREOTN_INT_SOURCE_LINE][ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC]  = DIGI_OTN_SERVER_LO_CHNL_MAX;
    
    end_link_tbl[COREOTN_INT_SOURCE_SYS][ODU_STRUCT_LEVEL_HO_ODU] = DIGI_OTN_SERVER_SYS_CHNL_MAX;
    end_link_tbl[COREOTN_INT_SOURCE_SYS][ODU_STRUCT_LEVEL_MO_ODU] = DIGI_OTN_SERVER_LO_CHNL_MAX;
    end_link_tbl[COREOTN_INT_SOURCE_SYS][ODU_STRUCT_LEVEL_LO_ODU] = DIGI_OTN_SERVER_HO_CHNL_MAX;
    end_link_tbl[COREOTN_INT_SOURCE_SYS][ODU_STRUCT_LEVEL_3B_ODU] = DIGI_OTN_SERVER_LO_CHNL_MAX;
    end_link_tbl[COREOTN_INT_SOURCE_SYS][ODU_STRUCT_LEVEL_4_ODU]  = DIGI_OTN_SERVER_LO_CHNL_MAX;
    end_link_tbl[COREOTN_INT_SOURCE_SYS][ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC]  = DIGI_OTN_SERVER_HO_CHNL_MAX;


    PMC_ENTRY();

    if (IS_DIGI_INT_ALL_CHNLS(chnl_handle))
    {
        if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
        { 
            line_sys = COREOTN_INT_SOURCE_SYS;
        }
        else
        {
            line_sys = COREOTN_INT_SOURCE_LINE;
        }
        
        
        *start_link  = 0;
        *end_link    = end_link_tbl[line_sys][odu_level];
    }
    else
    {
        *start_link  = digi_otn_odu_chnl_num_internal_get(digi_handle,
                                                          (digi_otn_odu_chnl_t *) chnl_handle);
        *end_link    = *start_link + 1;
    }



    PMC_RETURN(result);
} /* digi_otn_odu_int_link_range_get */






/*******************************************************************************
* FUNCTION: digi_otn_int_register_cb()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Registers a callback for aggregation interrupt table processing.
*
*   This callback will be called when an active interrupt is found in any
*   OTN channel.
*
*   The callback will be called a minimum of zero times if no active interrupts
*   are found, or a maximum of one time if there is an interrupt in at least
*   one channel.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   token           - user token to be stored and passed back to callback\n
*                     Optional, can be NULL.
*   token_size      - token size in bytes\n
*                     Optional, can be 0.
*   user_cb         - callback to be registered against this interrupt type
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_int_register_cb(digi_handle_t      *digi_handle,
                                          void               *token,
                                          UINT32              token_size,
                                          digi_int_cb_fcn     user_cb)
{
    PMC_ERROR            result = PMC_SUCCESS;
    digi_int_type_t      int_type = DIGI_INT_TYPE_OTN;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);


    if (PMC_SUCCESS == result)
    {
        result = digi_int_callback_set(digi_handle,
                                       int_type,
                                       token,
                                       token_size,
                                       user_cb);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_int_register_cb */


/*******************************************************************************
* FUNCTION: digi_otn_server_int_chnl_register_cb()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Registers a callback for channel interrupt table processing.
*
*   For each OTN server channel where an active interrupt is found, the callback will be
*   called.
*
*   The callback is called a minimum of zero times if no active interrupts are
*   found, or a maximum of the number of channels in the subsystem if there is
*   an active interrupt in each of the channels.
*   
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   token           - user token to be stored and passed back to callback\n
*                     Optional, can be NULL.
*   token_size      - token size in bytes\n
*                     Optional, can be 0.
*   user_cb         - callback to be registered against this interrupt type
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_int_chnl_register_cb(digi_handle_t           *digi_handle,
                                                      void                    *token,
                                                      UINT32                   token_size,
                                                      digi_int_cb_fcn          user_cb)
{
    PMC_ERROR            result = PMC_SUCCESS;
    digi_int_type_t      int_type = DIGI_INT_CHNL_TYPE_OTN_SERVER;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    
    if (PMC_SUCCESS == result)
    {
        result = digi_int_callback_set(digi_handle,
                                       int_type,
                                       token,
                                       token_size,
                                       user_cb);
    }

   
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_server_int_chnl_register_cb */


/*******************************************************************************
* FUNCTION: digi_sysotn_server_int_chnl_register_cb()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Registers a callback for channel interrupt table processing.
*
*   For each SYSOTN server channel where an active interrupt is found, the callback will be
*   called.
*
*   The callback is called a minimum of zero times if no active interrupts are
*   found, or a maximum of the number of channels in the subsystem if there is
*   an active interrupt in each of the channels.
*   
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   token           - user token to be stored and passed back to callback\n
*                     Optional, can be NULL.
*   token_size      - token size in bytes\n
*                     Optional, can be 0.
*   user_cb         - callback to be registered against this interrupt type
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_sysotn_server_int_chnl_register_cb(digi_handle_t           *digi_handle,
                                                         void                    *token,
                                                         UINT32                   token_size,
                                                         digi_int_cb_fcn          user_cb)
{
    PMC_ERROR            result = PMC_SUCCESS;
    digi_int_type_t      int_type = DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    
    if (PMC_SUCCESS == result)
    {
        result = digi_int_callback_set(digi_handle,
                                       int_type,
                                       token,
                                       token_size,
                                       user_cb);
    }

   
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_sysotn_server_int_chnl_register_cb */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_chnl_register_cb()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Registers a callback for channel interrupt table processing.
*
*   For each OTN ODU channel where an active interrupt is found, the callback will be
*   called.
*
*   The callback is called a minimum of zero times if no active interrupts are
*   found, or a maximum of the number of channels in the subsystem if there is
*   an active interrupt in each of the channels.
*   
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   token           - user token to be stored and passed back to callback\n
*                     Optional, can be NULL.
*   token_size      - token size in bytes\n
*                     Optional, can be 0.
*   user_cb         - callback to be registered against this interrupt type
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_chnl_register_cb(digi_handle_t           *digi_handle,
                                                   void                    *token,
                                                   UINT32                   token_size,
                                                   digi_int_cb_fcn          user_cb)
{
    PMC_ERROR            result = PMC_SUCCESS;
    digi_int_type_t      int_type = DIGI_INT_CHNL_TYPE_OTN_ODU;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    
    if (PMC_SUCCESS == result)
    {
        result = digi_int_callback_set(digi_handle,
                                       int_type,
                                       token,
                                       token_size,
                                       user_cb);
    }

   
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_chnl_register_cb */



/*******************************************************************************
* FUNCTION: digi_otn_server_int_enable_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts based on bits that are set in the interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_type        - Interrupt type (LINEOTN or SYSOTN)
*   int_table_ptr   - pointer to interrupt table with bits set to enable
*                     interrupts
*   enable          - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_enable_internal(digi_handle_t        *digi_handle,
                                                      digi_int_type_t       int_type,
                                                      lineotn_int_t        *int_table_ptr,
                                                      BOOL                  enable)
{
    PMC_ERROR                    result = PMC_SUCCESS;

    lineotn_handle_t            *lineotn_handle;
    digi_otn_int_t              *int_en_table_ptr;
    lineotn_int_t               *otn_en_table_ptr = NULL;
    
    
    PMC_ENTRY();
    
    /* Get internal enabled aggregate interrupt table to update */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);

    }

   
    if (PMC_SUCCESS == result)
    {
        switch (int_type)
        {
          case DIGI_INT_CHNL_TYPE_OTN_SERVER:
            lineotn_handle   = digi_handle->lineotn_handle;
            otn_en_table_ptr = &int_en_table_ptr->lineotn;
            break;
            
          case DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS:
            lineotn_handle   = digi_handle->sysotn_handle;
            otn_en_table_ptr = &int_en_table_ptr->sysotn;
            break;
        
          default:
            PMC_ASSERT(NULL, DIGI_ERR_INVALID_ARG, 0, 0);
            break;
        } /* end switch */
    }
       
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == lineotn_start_state_test(lineotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Callback for interrupt table must be registered before enable ints */
    if (PMC_SUCCESS == result && TRUE == enable)
    {
        if(!digi_int_is_cb_registered(digi_handle, DIGI_INT_TYPE_OTN) && 
           !digi_int_is_cb_registered(digi_handle, int_type))
        {
            result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
        }
    }


    if (PMC_SUCCESS == result)
    {
        result = lineotn_int_enable(lineotn_handle,
                                    int_table_ptr,
                                    otn_en_table_ptr,
                                    enable);
    }
    
    PMC_RETURN(result);
} /* digi_otn_server_int_enable_internal */



/*******************************************************************************
* FUNCTION: digi_otn_server_int_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts based on bits that are set in the interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to interrupt table with bits set to enable
*                     interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_int_enable(digi_handle_t        *digi_handle,
                                            lineotn_int_t        *int_table_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    result = digi_otn_server_int_enable_internal(digi_handle,
                                                 DIGI_INT_CHNL_TYPE_OTN_SERVER,
                                                 int_table_ptr,
                                                 TRUE);

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_server_int_enable */


/*******************************************************************************
* FUNCTION: digi_otn_server_int_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Disables interrupts based on bits that are set in the interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to interrupt table with bits set to disable
*                     interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_int_disable(digi_handle_t        *digi_handle,
                                             lineotn_int_t        *int_table_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    result = digi_otn_server_int_enable_internal(digi_handle,
                                                 DIGI_INT_CHNL_TYPE_OTN_SERVER,
                                                 int_table_ptr,
                                                 FALSE);

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_server_int_disable */


/*******************************************************************************
* FUNCTION: digi_sysotn_server_int_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts based on bits that are set in the interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to interrupt table with bits set to enable
*                     interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_sysotn_server_int_enable(digi_handle_t        *digi_handle,
                                               lineotn_int_t        *int_table_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    result = digi_otn_server_int_enable_internal(digi_handle,
                                                 DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS,
                                                 int_table_ptr,
                                                 TRUE);

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_sysotn_server_int_enable */


/*******************************************************************************
* FUNCTION: digi_sysotn_server_int_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Disables interrupts based on bits that are set in the interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to interrupt table with bits set to disable
*                     interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_sysotn_server_int_disable(digi_handle_t        *digi_handle,
                                                lineotn_int_t        *int_table_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    result = digi_otn_server_int_enable_internal(digi_handle,
                                                 DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS,
                                                 int_table_ptr,
                                                 FALSE);

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_sysotn_server_int_disable */



/*******************************************************************************
* FUNCTION: digi_otn_server_int_chnl_enable_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem
*   int_type        - Interrupt type (LINEOTN or SYSOTN)
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*   enable          - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_chnl_enable_internal(digi_handle_t             *digi_handle,
                                                           digi_otn_server_chnl_t    *chnl_handle,   
                                                           digi_int_type_t            int_type,
                                                           lineotn_int_chnl_t        *int_table_ptr,
                                                           BOOL                       enable)
{
    PMC_ERROR                    result = PMC_SUCCESS;

    coreotn_int_source_t         source = LAST_COREOTN_INT_SOURCE;
    lineotn_handle_t            *lineotn_handle = NULL;
    UINT32                       start_link = 0;
    UINT32                       end_link = 0;
    UINT32                       i;
    digi_otn_int_t              *int_en_table_ptr;
    digi_otn_server_chnl_def_t  *handle_pool_ptr = NULL;
    lineotn_int_chnl_t          *otn_en_table_ptr = NULL;
    UINT32                       dsi_stream;
    
    PMC_ENTRY();
    result = digi_int_param_check(digi_handle, chnl_handle, int_type, int_table_ptr); 
    
    /* Get internal enabled aggregate interrupt table to update */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);

    }

   
    if (PMC_SUCCESS == result)
    {
        switch (int_type)
        {
          case DIGI_INT_CHNL_TYPE_OTN_SERVER:
            source           = COREOTN_INT_SOURCE_LINE;
            lineotn_handle   = digi_handle->lineotn_handle;
            handle_pool_ptr  = digi_handle->handle_pool.otn_server_chnl;
            otn_en_table_ptr = int_en_table_ptr->otn_server_chnl;
            break;
            
          case DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS:
            source           = COREOTN_INT_SOURCE_SYS;
            lineotn_handle   = digi_handle->sysotn_handle;
            handle_pool_ptr  = &digi_handle->handle_pool.sysotn_server_chnl;
            otn_en_table_ptr = int_en_table_ptr->sysotn_server_chnl;
            break;
        
          default:
            PMC_ASSERT(NULL, DIGI_ERR_INVALID_ARG, 0, 0);
            break;
        } /* end switch */
    }
       
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == lineotn_start_state_test(lineotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Callback for interrupt table must be registered before enable ints */
    if (PMC_SUCCESS == result && TRUE == enable)
    {
        if(!digi_int_is_cb_registered(digi_handle, DIGI_INT_TYPE_OTN) && 
           !digi_int_is_cb_registered(digi_handle, int_type))
        {
            result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
        }
    }


    /* Determine if are modfiying one channel or all channels */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_link_range_get(digi_handle,
                                         (void*) chnl_handle,
                                         int_type,
                                         &start_link,
                                         &end_link);
    }


    if (PMC_SUCCESS == result)
    {
        for (i = start_link; (i < end_link) && (PMC_SUCCESS == result); i++)
        {
            if (util_global_is_chnl_prov(&handle_pool_ptr[i]))
            {
                dsi_stream = handle_pool_ptr[i].dsi_base_chnl;

                /* Enable interrupts */
                result = lineotn_int_chnl_enable(lineotn_handle, 
                                                 dsi_stream,
                                                 int_table_ptr,
                                                 &otn_en_table_ptr[i],
                                                 enable);
               PMC_ATOMIC_YIELD(digi_handle,0);
                                       
            }
        }


        if (PMC_SUCCESS == result)
        {
            result = digi_otn_server_int_chnl_ddeg_enable(digi_handle,
                                                          source,
                                                          start_link,
                                                          end_link,
                                                          int_table_ptr,
                                                          otn_en_table_ptr,
                                                          enable);
        }
    }    
    PMC_RETURN(result);
} /* digi_otn_server_int_chnl_enable_internal */




/*******************************************************************************
* FUNCTION: digi_otn_server_int_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_int_chnl_enable(digi_handle_t             *digi_handle,
                                                 digi_otn_server_chnl_t    *chnl_handle,   
                                                 lineotn_int_chnl_t        *int_table_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;

    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result, TRUE);

    result = digi_otn_server_int_chnl_enable_internal(digi_handle,
                                                      chnl_handle,
                                                      DIGI_INT_CHNL_TYPE_OTN_SERVER,
                                                      int_table_ptr,
                                                      TRUE);

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_server_int_chnl_enable */


/*******************************************************************************
* FUNCTION: digi_otn_server_int_chnl_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Disables interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to disable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_int_chnl_disable(digi_handle_t             *digi_handle,
                                                  digi_otn_server_chnl_t    *chnl_handle,   
                                                  lineotn_int_chnl_t        *int_table_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;

    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result, TRUE);

    result = digi_otn_server_int_chnl_enable_internal(digi_handle,
                                                      chnl_handle,
                                                      DIGI_INT_CHNL_TYPE_OTN_SERVER,
                                                      int_table_ptr,
                                                      FALSE);

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_server_int_chnl_disable */


/*******************************************************************************
* FUNCTION: digi_sysotn_server_int_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_sysotn_server_int_chnl_enable(digi_handle_t             *digi_handle,
                                                    digi_otn_server_chnl_t    *chnl_handle,   
                                                    lineotn_int_chnl_t        *int_table_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result, 
                                      TRUE);
    if (TRUE == DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
    {
        /*
         * If this is SYSOTN then want to set the top level interrupt
         * enable register to ensure that SYSOTN interrupts will fire if
         * later enabled.  The mask used to set the register is a 
         * function of the cpuif_int_t passed to digi_int_init. The mask
         * determines how the interrupt will be routed.
         */
        lineotn_top_level_interrupt_set(digi_handle->sysotn_handle, TRUE);
    }
    result = digi_otn_server_int_chnl_enable_internal(digi_handle,
                                                      chnl_handle,
                                                      DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS,
                                                      int_table_ptr,
                                                      TRUE);

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_sysotn_server_int_chnl_enable */


/*******************************************************************************
* FUNCTION: digi_sysotn_server_int_chnl_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Disables interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to disable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_sysotn_server_int_chnl_disable(digi_handle_t             *digi_handle,
                                                     digi_otn_server_chnl_t    *chnl_handle,   
                                                     lineotn_int_chnl_t        *int_table_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    DIGI_OTN_SERVER_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result, TRUE);
    result = digi_otn_server_int_chnl_enable_internal(digi_handle,
                                                      chnl_handle,
                                                      DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS,
                                                      int_table_ptr,
                                                      FALSE);

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_sysotn_server_int_chnl_disable */




/*******************************************************************************
* FUNCTION: digi_otn_server_int_chnl_clear_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to clear interrupts on, or
*                     DIGI_INT_ALL_CHNLS to clear interrupts on all channels
*                     of the subsystem
*   int_type        - Interrupt type (LINEOTN or SYSOTN)
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     clear interrupts. DIGI_INT_ALL_INTS to clear all interrupts.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_chnl_clear_internal(digi_handle_t             *digi_handle,
                                                          digi_otn_server_chnl_t    *chnl_handle,   
                                                          digi_int_type_t            int_type,
                                                          lineotn_int_chnl_t        *int_table_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;

    coreotn_int_source_t         source;
    lineotn_handle_t            *lineotn_handle = NULL;
    UINT32                       start_link = 0;
    UINT32                       end_link = 0;
    UINT32                       i;
    digi_otn_int_t              *int_en_table_ptr;
    digi_otn_server_chnl_def_t  *handle_pool_ptr = NULL;
    lineotn_int_chnl_t          *otn_en_table_ptr = NULL;
    UINT32                       dsi_stream;
    
    
    PMC_ENTRY();

       
    /* Get internal enabled aggregate interrupt table to update */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);

    }


    if (PMC_SUCCESS == result)
    {
        switch (int_type)
        {
          case DIGI_INT_CHNL_TYPE_OTN_SERVER:
            source           = COREOTN_INT_SOURCE_LINE;
            lineotn_handle   = digi_handle->lineotn_handle;
            handle_pool_ptr  = digi_handle->handle_pool.otn_server_chnl;
            otn_en_table_ptr = int_en_table_ptr->otn_server_chnl;
            break;
            
          case DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS:
            source           = COREOTN_INT_SOURCE_SYS;
            lineotn_handle   = digi_handle->sysotn_handle;
            handle_pool_ptr  = &digi_handle->handle_pool.sysotn_server_chnl;
            otn_en_table_ptr = int_en_table_ptr->sysotn_server_chnl;
            break;
        
          default:
            PMC_ASSERT(NULL, DIGI_ERR_INVALID_ARG, 0, 0);
            break;
        } /* end switch */
    }

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == lineotn_start_state_test(lineotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }



    /* Determine if are modfiying one channel or all channels */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_link_range_get(digi_handle,
                                         (void*) chnl_handle,
                                         int_type,
                                         &start_link,
                                         &end_link);
    }




    for (i = start_link; (i < end_link) && (PMC_SUCCESS == result); i++)
    {
        dsi_stream = handle_pool_ptr[i].dsi_base_chnl;
        
        if (util_global_is_chnl_prov(&handle_pool_ptr[i]))
        {
            /* Clear interrupts */
            result = lineotn_int_chnl_clear(lineotn_handle, 
                                            dsi_stream,
                                            &otn_en_table_ptr[i],
                                            int_table_ptr);
        }
    }


    
    PMC_RETURN(result);
} /* digi_otn_server_int_chnl_clear_internal */


/*******************************************************************************
* FUNCTION: digi_otn_server_int_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears interrupts based on bits that are set in the aggregated 
*   interrupt table.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     clear interrupts
*                     DIGI_INT_ALL_INTS to clear all interrupts.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_int_clear(digi_handle_t    *digi_handle,
                                           digi_otn_int_t   *int_table_ptr)
{
    PMC_ERROR                result = PMC_SUCCESS;
    digi_int_type_t          int_type[2]; 
    digi_otn_server_chnl_t  *chnl_handle; 
    digi_otn_server_chnl_t **chnl_handle_pool[2];
    lineotn_int_chnl_t      *int_table_pool[2];

    UINT32                  start_link = 0;
    UINT32                  end_link   = 0;
    UINT32                  i, j;
    
    
    PMC_ENTRY();
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    int_type[0]         = DIGI_INT_CHNL_TYPE_OTN_SERVER;
    int_type[1]         = DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS;

    if (IS_DIGI_INT_ALL_INTS(int_table_ptr))
    {
        if (PMC_SUCCESS == result)
        {  
            result = digi_otn_lineotn_int_clear(digi_handle,
                                                DIGI_INT_ALL_CHNLS);
        }

        if (PMC_SUCCESS == result)
        {  
            result = digi_otn_sysotn_int_clear(digi_handle,
                                               DIGI_INT_ALL_CHNLS);
        }
    
        for (i = 0; i < 2; i++)
        {
            result = digi_otn_server_int_chnl_clear_internal(digi_handle,
                                                             DIGI_INT_ALL_CHNLS,
                                                             int_type[i],
                                                             DIGI_INT_ALL_INTS);
        }
    }
    else
    {
        if (PMC_SUCCESS == result)
        {  
            result = digi_otn_lineotn_int_clear(digi_handle,
                                                &int_table_ptr->lineotn);
        }

        if (PMC_SUCCESS == result)
        {  
            result = digi_otn_sysotn_int_clear(digi_handle,
                                               &int_table_ptr->sysotn);
        }
    
        chnl_handle_pool[0] = int_table_ptr->otn_server_handle;
        chnl_handle_pool[1] = int_table_ptr->sysotn_server_handle;

        int_table_pool[0]   = int_table_ptr->otn_server_chnl;
        int_table_pool[1]   = int_table_ptr->sysotn_server_chnl;
    
        for (i = 0; i < 2; i++)
        {
            /* Determine if are modfiying one channel or all channels */
            if (PMC_SUCCESS == result)
            {
                result = digi_int_link_range_get(digi_handle,
                                                 DIGI_INT_ALL_CHNLS,
                                                 int_type[i],
                                                 &start_link,
                                                 &end_link);
            }
            
            /* Clear interrupts */
            for (j = start_link; (j < end_link) && (PMC_SUCCESS == result); j++)
            {
                chnl_handle = chnl_handle_pool[i][j];
                
                if (NULL != chnl_handle)
                {
                    result = digi_otn_server_int_chnl_clear_internal(digi_handle,
                                                                     chnl_handle,
                                                                     int_type[i],
                                                                     &int_table_pool[i][j]);
                }
            }
        } /* end for */
    }



    PMC_RETURN(result);
} /* digi_otn_server_int_clear */



/*******************************************************************************
* FUNCTION: digi_otn_server_int_chnl_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears interrupts based on bits that are set in the channel
*   interrupt table.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to clear interrupts on, or
*                     DIGI_INT_ALL_CHNLS to clear interrupts on all channels
*                     of the subsystem
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     clear interrupts. DIGI_INT_ALL_INTS to clear all interrupts.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_int_chnl_clear(digi_handle_t             *digi_handle,
                                                digi_otn_server_chnl_t    *chnl_handle,   
                                                lineotn_int_chnl_t        *int_table_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    result = digi_otn_server_int_chnl_clear_internal(digi_handle,
                                                     chnl_handle,
                                                     DIGI_INT_CHNL_TYPE_OTN_SERVER,
                                                     int_table_ptr);


    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_server_int_chnl_clear */



/*******************************************************************************
* FUNCTION: digi_sysotn_server_int_chnl_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears interrupts based on bits that are set in the channel
*   interrupt table.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to clear interrupts on, or
*                     DIGI_INT_ALL_CHNLS to clear interrupts on all channels
*                     of the subsystem
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     clear interrupts. DIGI_INT_ALL_INTS to clear all interrupts.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_sysotn_server_int_chnl_clear(digi_handle_t             *digi_handle,
                                                   digi_otn_server_chnl_t    *chnl_handle,   
                                                   lineotn_int_chnl_t        *int_table_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    result = digi_otn_server_int_chnl_clear_internal(digi_handle,
                                                     chnl_handle,
                                                     DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS,
                                                     int_table_ptr);


    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_sysotn_server_int_chnl_clear */




/*******************************************************************************
* FUNCTION: digi_otn_server_int_chnl_ddeg_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables/disables enh and bursty ddeg, and updates the internal SW
*   enabled table.
*
*   Enhanced dDEG in SW enables FW enhanced DDEG and FW bursty dDEG.
*   Bursty dDEG in SW enables only FW bursty dDEG.
*
* INPUTS:
*   digi_handle       - Pointer to digi handle
*   source            - source of OTN datapath: line or system
*   start_chnl        - Start channel
*   end_chnl          - End channel
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to enable interrupts. If NULL, enables/disables
*                       all interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_chnl_ddeg_enable(digi_handle_t             *digi_handle,
                                                       coreotn_int_source_t       source, 
                                                       UINT32                     start_chnl,
                                                       UINT32                     end_chnl,
                                                       lineotn_int_chnl_t        *int_table_ptr,
                                                       lineotn_int_chnl_t        *int_en_table_ptr,
                                                       BOOL                       enable)
{
    PMC_ERROR                       result = PMC_SUCCESS;
    lineotn_handle_t               *lineotn_handle;
    digi_otn_ddeg_mode_t            ddeg_mode;
    UINT32                          i;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_table_ptr != NULL, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(int_en_table_ptr != NULL, DIGI_ERR_INVALID_ARG, 0, 0);


    switch (source)
    {
      case COREOTN_INT_SOURCE_LINE:
        lineotn_handle   = digi_handle->lineotn_handle;
        break;
        
      case COREOTN_INT_SOURCE_SYS:
        lineotn_handle   = digi_handle->sysotn_handle;
        break;
        
      default:
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
        break;
    } /* end switch */

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == lineotn_start_state_test(lineotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Obtain the scope of ddeg */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_otu_ddeg_mode_get(digi_handle, &ddeg_mode);
    }

    if ((PMC_SUCCESS == result) &&
        (DIGI_OTN_HARDWARE_DDEG == ddeg_mode)) 
    {
        /* Nothing to do for enh dDeg */
        PMC_RETURN(result);
    }



    /* Configure FW enhanced dDEG */
    if ((int_table_ptr->otu_frm.otu_sk_d_deg_enh_i) &&
        (PMC_SUCCESS == result))
    {
        result = digi_otn_server_int_ddeg_cfg(digi_handle,
                                              DIGI_PMON_DDEG_MODE_ENH,
                                              source,
                                              start_chnl,
                                              end_chnl,
                                              enable);
       
        /* Set internal table */
        for (i = start_chnl; (i < end_chnl) && (PMC_SUCCESS == result); i++)
        {
            int_en_table_ptr[i].otu_frm.otu_sk_d_deg_enh_i = enable;
        }
    }


    /* Configure FW bursty dDEG */
    if ((int_table_ptr->otu_frm.otu_sk_d_deg_bursty_i) &&
        (PMC_SUCCESS == result))
    {
        result = digi_otn_server_int_ddeg_cfg(digi_handle,
                                              DIGI_PMON_DDEG_MODE_BURSTY,
                                              source,
                                              start_chnl,
                                              end_chnl,
                                              enable);
        
        /* Set internal table */
        for (i = start_chnl; (i < end_chnl) && (PMC_SUCCESS == result); i++)
        {
            int_en_table_ptr[i].otu_frm.otu_sk_d_deg_bursty_i = enable;
        }
    }
    
   


    PMC_RETURN(result);
} /* digi_otn_server_int_chnl_ddeg_enable */




/*******************************************************************************
* FUNCTION: digi_otn_server_int_ddeg_cfg()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures the FW enhanced or bursty dDEG feature.   
*
* INPUTS:
*   digi_handle       - Pointer to digi handle
*   ddeg_mode         - FW Enhanced or FW bursty DDEG mode.
*   source            - source of OTN datapath: line or system
*   start_chnl        - Start channel
*   end_chnl          - End channel
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_ddeg_cfg(digi_handle_t             *digi_handle,
                                               digi_pmon_ddeg_mode_t      ddeg_mode,        
                                               coreotn_int_source_t       source, 
                                               UINT32                     start_chnl,
                                               UINT32                     end_chnl,
                                               BOOL                       enable)
{
    PMC_ERROR                       result = PMC_SUCCESS;
    digi_pmon_ddeg_chnl_bitmsk_t    chnl_bitmask;
    digi_pmon_ddeg_hw_block_t       ddeg_hw_block;
    UINT32                          i;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_MEMSET((void*)&chnl_bitmask, 0, sizeof(digi_pmon_ddeg_chnl_bitmsk_t));


    /* Create channel bit mask */
    for (i = start_chnl; i < end_chnl; i++)
    {
        pmc_bitarray_set_bit((pmc_bitarray_t *) &chnl_bitmask, i);
    } 

    switch (source)
    {
      case COREOTN_INT_SOURCE_LINE:
        ddeg_hw_block = DIGI_PMON_DDEG_LINEOTN;
        break;
        
      case COREOTN_INT_SOURCE_SYS:
        ddeg_hw_block = DIGI_PMON_DDEG_SYSOTN;
        break;
        
      default:
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
        break;
    } /* end switch */
    
   


    /* Configure FW */
    if (PMC_SUCCESS == result)
    {
        result = digi_pmon_ddeg_int_en_cfg(digi_handle,
                                           ddeg_mode,
                                           ddeg_hw_block,
                                           chnl_bitmask,
                                           enable);

    }
   

    PMC_RETURN(result);
} /* digi_otn_server_int_ddeg_cfg */


/*******************************************************************************
* FUNCTION: digi_otn_server_int_ddeg_init()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Populates the pointers in a dDeg stage structure to point to the desired
*   stage int/status in the FW dDeg table.
*
* INPUTS:
*  digi_handle     - Pointer to digi handle
*  ddeg_ptr        - FW dDeg int/status table that contains all stages
*  is_line         - TRUE this is set from LINEOTN. FALSE is SYSOTN side.
*                    NOTE: For non-sysotn application this should be called
*                    only once. For SYSOTN it is called twice.
*
* OUTPUTS:
*   ddeg_stage_ptr  - Table contain pointers to one stage of dDeg
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_ddeg_init(digi_handle_t           *digi_handle,
                                                digi_pmon_ddeg_t        *ddeg_ptr,
                                                BOOL8 is_line,
                                                digi_pmon_ddeg_stage_t  *ddeg_stage_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;
    UINT32          i;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(ddeg_ptr       != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(ddeg_stage_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    
    if (FALSE == is_line)
    { 
        for (i = 0; i < DIGI_PMON_DDEG_MODE_MAX_NUM; i++)
        {
            ddeg_stage_ptr[i].i_ptr = &ddeg_ptr[i].i_bit.sysotn_int;
            ddeg_stage_ptr[i].v_ptr = &ddeg_ptr[i].v_bit.sysotn_int;
        }
    }
    else
    {
        for (i = 0; i < DIGI_PMON_DDEG_MODE_MAX_NUM; i++)
        {
            ddeg_stage_ptr[i].i_ptr = &ddeg_ptr[i].i_bit.lineotn_int;
            ddeg_stage_ptr[i].v_ptr = &ddeg_ptr[i].v_bit.lineotn_int;
        }
    }
   

    PMC_RETURN(result);
} /* digi_otn_server_int_ddeg_init */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ddeg_init()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Populates the pointers in a dDeg stage structure to point to the desired
*   stage int/status in the FW dDeg table.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_level       - ODU stage to obtain pointers for
*   ddeg_ptr        - FW dDeg int/status table that contains all stages
*
* OUTPUTS:
*   ddeg_stage_ptr  - Table contain pointers to one stage of dDeg
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ddeg_init(digi_handle_t           *digi_handle,
                                            odu_struct_odu_level_t   odu_level,
                                            digi_pmon_ddeg_t        *ddeg_ptr,
                                            digi_pmon_ddeg_stage_t  *ddeg_stage_ptr)
{
    PMC_ERROR               result = PMC_SUCCESS;
    UINT32                  i;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle     != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(ddeg_stage_ptr  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);


    if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    { 
        for (i = 0; (i < DIGI_PMON_DDEG_MODE_MAX_NUM); i++)
        {
            switch (odu_level)
            {
              case ODU_STRUCT_LEVEL_HO_ODU:
                ddeg_stage_ptr[i].i_ptr        = &ddeg_ptr[i].i_bit.coreotn_stg_n_pm_int;
                ddeg_stage_ptr[i].v_ptr        = &ddeg_ptr[i].v_bit.coreotn_stg_n_pm_int;
                ddeg_stage_ptr[i].tcm_i_ptr    = &ddeg_ptr[i].i_bit.coreotn_stg_n_tcm_int;
                ddeg_stage_ptr[i].tcm_v_ptr    = &ddeg_ptr[i].v_bit.coreotn_stg_n_tcm_int;
                break;

              case ODU_STRUCT_LEVEL_MO_ODU:
              case ODU_STRUCT_LEVEL_4_ODU:
                ddeg_stage_ptr[i].i_ptr        = &ddeg_ptr[i].i_bit.coreotn_stg_3a_4_pm_int[0];
                ddeg_stage_ptr[i].v_ptr        = &ddeg_ptr[i].v_bit.coreotn_stg_3a_4_pm_int[0];
                ddeg_stage_ptr[i].tcm_i_ptr    = &ddeg_ptr[i].i_bit.coreotn_stg_3a_4_tcm_int[0];
                ddeg_stage_ptr[i].tcm_v_ptr    = &ddeg_ptr[i].v_bit.coreotn_stg_3a_4_tcm_int[0];
                break;

              case ODU_STRUCT_LEVEL_LO_ODU:
                ddeg_stage_ptr[i].i_ptr        = &ddeg_ptr[i].i_bit.coreotn_stg_1_pm_int;
                ddeg_stage_ptr[i].v_ptr        = &ddeg_ptr[i].v_bit.coreotn_stg_1_pm_int;
                ddeg_stage_ptr[i].tcm_i_ptr    = &ddeg_ptr[i].i_bit.coreotn_stg_1_tcm_int[0];
                ddeg_stage_ptr[i].tcm_v_ptr    = &ddeg_ptr[i].v_bit.coreotn_stg_1_tcm_int[0];
                break;

              case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
                ddeg_stage_ptr[i].i_ptr        = &ddeg_ptr[i].i_bit.coreotn_stg_2_pm_int[0];
                ddeg_stage_ptr[i].v_ptr        = &ddeg_ptr[i].v_bit.coreotn_stg_2_pm_int[0];
                ddeg_stage_ptr[i].tcm_i_ptr    = &ddeg_ptr[i].i_bit.coreotn_stg_2_tcm_int[0];
                ddeg_stage_ptr[i].tcm_v_ptr    = &ddeg_ptr[i].v_bit.coreotn_stg_2_tcm_int[0];
                break;
                
              default:
                break;
            }
        }
    }
    else
    {
        for (i = 0; i < DIGI_PMON_DDEG_MODE_MAX_NUM; i++)
        {
            switch (odu_level)
            {
              case ODU_STRUCT_LEVEL_HO_ODU:
                ddeg_stage_ptr[i].i_ptr        = &ddeg_ptr[i].i_bit.coreotn_stg_1_pm_int;
                ddeg_stage_ptr[i].v_ptr        = &ddeg_ptr[i].v_bit.coreotn_stg_1_pm_int;
                ddeg_stage_ptr[i].tcm_i_ptr    = &ddeg_ptr[i].i_bit.coreotn_stg_1_tcm_int[0];
                ddeg_stage_ptr[i].tcm_v_ptr    = &ddeg_ptr[i].v_bit.coreotn_stg_1_tcm_int[0];
                break;

              case ODU_STRUCT_LEVEL_MO_ODU:
                ddeg_stage_ptr[i].i_ptr        = &ddeg_ptr[i].i_bit.coreotn_stg_2_pm_int[0];
                ddeg_stage_ptr[i].v_ptr        = &ddeg_ptr[i].v_bit.coreotn_stg_2_pm_int[0];
                ddeg_stage_ptr[i].tcm_i_ptr    = &ddeg_ptr[i].i_bit.coreotn_stg_2_tcm_int[0];
                ddeg_stage_ptr[i].tcm_v_ptr    = &ddeg_ptr[i].v_bit.coreotn_stg_2_tcm_int[0];
                break;

              case ODU_STRUCT_LEVEL_LO_ODU:
              case ODU_STRUCT_LEVEL_4_ODU:
                ddeg_stage_ptr[i].i_ptr        = &ddeg_ptr[i].i_bit.coreotn_stg_3a_4_pm_int[0];
                ddeg_stage_ptr[i].v_ptr        = &ddeg_ptr[i].v_bit.coreotn_stg_3a_4_pm_int[0];
                ddeg_stage_ptr[i].tcm_i_ptr    = &ddeg_ptr[i].i_bit.coreotn_stg_3a_4_tcm_int[0];
                ddeg_stage_ptr[i].tcm_v_ptr    = &ddeg_ptr[i].v_bit.coreotn_stg_3a_4_tcm_int[0];
                break;
                
              default:
                break;
            }
        }
    }
   

    PMC_RETURN(result);
} /* digi_otn_odu_int_ddeg_init */



/*******************************************************************************
* FUNCTION: digi_otn_ddeg_init()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Populates the pointers in a dDeg otn and odu structures to point to the desired
*   stage int/status in the FW dDeg table.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_ddeg_init(digi_handle_t    *digi_handle)
{
    PMC_ERROR               result = PMC_SUCCESS;
    digi_int_info_ary_t    *int_info_ptr;
    UINT32                  odu_level;

    PMC_ENTRY();


    int_info_ptr = digi_handle->var.int_info_ary;
   

    /* 
     * Organize ddeg cache by lineotn and sysotn
     *  ddeg_cache: Input
     *  ddeg_server: Output
     */
    result = digi_otn_server_int_ddeg_init(digi_handle,
                                           int_info_ptr->ddeg_cache,
                                           TRUE,
                                           int_info_ptr->ddeg_server);
    /*
     * If this is a SYSOTN application then LINEOTN and SYSOTN dDEG
     * interupts can occur concurrently and both need to be initialized
     */
    if (TRUE == DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
    {
        result = digi_otn_server_int_ddeg_init(digi_handle,
                                               int_info_ptr->ddeg_cache,
                                               FALSE,
                                               int_info_ptr->ddeg_sys_server);
    }


    /* Organize the ddeg cache by stage: The ddeg cache coming from FW is organized by
     * i-bits and v-bits, with all the stages being defined as explicit fields within those
     * i/v bit structures. This makes it difficult to cleanly access into the stages in a 
     * generic manner. The ddeg_stage structure contains pointers to the correct i/v bit arrays,
     * but now organized in a way that can be indexed by odu stage.
     */
    for (odu_level = 0; (odu_level < LAST_ODU_STRUCT_LEVEL) && (PMC_SUCCESS == result); odu_level++)
    {
        result = digi_otn_odu_int_ddeg_init(digi_handle,
                                            (odu_struct_odu_level_t) odu_level,
                                            int_info_ptr->ddeg_cache,             /* input */
                                            int_info_ptr->ddeg_stage[odu_level]); /* output */
    } 


    PMC_RETURN(result);
} /* digi_otn_ddeg_init */



/*******************************************************************************
* FUNCTION: digi_otn_server_int_ddeg_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves a pointer to currently latched ddeg server status.
*
* INPUTS:
*  digi_handle     - Pointer to digi handle
*  is_line         - TRUE then being called from LINEOTN perspective.
*                    FALSE is SYSOTN.
*
* OUTPUTS:
*   ddeg_pptr       - dDEG server status
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_otn_server_int_ddeg_get(digi_handle_t           *digi_handle,
                                              BOOL8 is_line,
                                              digi_pmon_ddeg_stage_t **ddeg_pptr)
{
    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(ddeg_pptr   != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    if (TRUE == is_line)
    {
        *ddeg_pptr = digi_handle->var.int_info_ary->ddeg_server;
    }
    else
    {
        *ddeg_pptr = digi_handle->var.int_info_ary->ddeg_sys_server;
    }

    PMC_RETURN();
} /* digi_otn_server_int_ddeg_get */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ddeg_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves a pointer to currently latched ddeg ODU status.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_level       - ODU stage to obtain pointers for
*
* OUTPUTS:
*   ddeg_pptr       - dDEG ODU status
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_ddeg_get(digi_handle_t           *digi_handle,
                                            odu_struct_odu_level_t   odu_level,
                                            digi_pmon_ddeg_stage_t **ddeg_pptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(ddeg_pptr      != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
   
    
    /* Error check ODU level */
    if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    { 
        switch (odu_level)
        {
          case ODU_STRUCT_LEVEL_HO_ODU:
          case ODU_STRUCT_LEVEL_MO_ODU:
          case ODU_STRUCT_LEVEL_LO_ODU:
          case ODU_STRUCT_LEVEL_4_ODU:
            break;
            
          case ODU_STRUCT_LEVEL_3B_ODU:
          case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
          default:
            PMC_ASSERT(NULL, DIGI_ERR_INVALID_ARG, 0, 0);
            break;
        }
    }
    else
    {
        switch (odu_level)
        {
          case ODU_STRUCT_LEVEL_HO_ODU:
          case ODU_STRUCT_LEVEL_MO_ODU:
          case ODU_STRUCT_LEVEL_LO_ODU:
          case ODU_STRUCT_LEVEL_4_ODU:
            break;
            
          case ODU_STRUCT_LEVEL_3B_ODU:
          default:
            PMC_ASSERT(NULL, DIGI_ERR_INVALID_ARG, 0, 0);
            break;
        }
    }
    
   
    /* Return pointer to dDEG status for requested odu_level */
    *ddeg_pptr = digi_handle->var.int_info_ary->ddeg_stage[odu_level];


    PMC_RETURN(result);
} /* digi_otn_odu_int_ddeg_get */



/*******************************************************************************
* FUNCTION: digi_otn_server_int_ddeg_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves enh dDeg status from the FW dDeg table.
*
* INPUTS:
*  digi_handle      - Pointer to digi handle
*  int_type         - Whether this is LINE side or SYS side that needs to
*                     be checked for dDEG interrupts.
*
* OUTPUTS:
*   int_table_ptr    - Aggregated OTN interrupt table to return status
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_ddeg_retrieve(digi_handle_t *digi_handle,
                                                    digi_int_type_t int_type,
                                                    digi_otn_int_t *int_table_ptr)
{
    PMC_ERROR                       result = PMC_SUCCESS;
    UINT32                          start_chnl = 0;
    UINT32                          end_chnl = 0;
    UINT32                          i;
    lineotn_handle_t               *lineotn_handle;
    digi_otn_server_chnl_def_t     *handle_pool_ptr;
    lineotn_int_chnl_t             *otn_table_ptr;
    digi_otn_server_chnl_t         *chnl_ptr;
    coreotn_int_source_t            source;

    PMC_ENTRY();
    
    /* determine from odu struct line or source */
    /*
     * Note that the source variable is used as a reference to who the
     * caller is digi_otn_server_int_ddeg_chnl_retrieve. That is LINEOTN
     * or SYSOTN and is not relative to the source as it applies to 
     * COREOTN which would be how it is normally used.
     */
    if (DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS == int_type)
    { 
        lineotn_handle   = digi_handle->sysotn_handle;
        source           = COREOTN_INT_SOURCE_SYS;
        otn_table_ptr    = int_table_ptr->sysotn_server_chnl;
        handle_pool_ptr  = &digi_handle->handle_pool.sysotn_server_chnl;
    }
    else if (DIGI_INT_CHNL_TYPE_OTN_SERVER == int_type)
    {
        lineotn_handle   = digi_handle->lineotn_handle;
        source           = COREOTN_INT_SOURCE_LINE;
        otn_table_ptr    = int_table_ptr->otn_server_chnl;
        handle_pool_ptr  = digi_handle->handle_pool.otn_server_chnl;
    }
    else
    {
        result = DIGI_ERR_INVALID_ARG;
    }

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == lineotn_start_state_test(lineotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }



    /* Determine if are modfiying one channel or all channels */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_link_range_get(digi_handle,
                                         NULL,
                                         int_type,
                                         &start_chnl,
                                         &end_chnl);
    }

    for (i = start_chnl; (i < end_chnl) && (PMC_SUCCESS == result); i++)
    {
        chnl_ptr = &handle_pool_ptr[i];

        if (util_global_is_chnl_prov(chnl_ptr))
        {
            result = digi_otn_server_int_ddeg_chnl_retrieve(digi_handle, 
                                                            i,
                                                            source,
                                                            NULL, 
                                                            &otn_table_ptr[i]);
            
        }
    }

    PMC_RETURN(result);
} /* digi_otn_server_int_ddeg_retrieve */



/*******************************************************************************
* FUNCTION: digi_otn_server_int_ddeg_chnl_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves enh dDeg int/status for a channel in  a specific stage in the
*   FW dDeg table.
*
* INPUTS:
*   digi_handle      - Pointer to digi handle
*   chnl_num         - Channel number
*   source           - source of OTN datapath: line or system
*   int_en_table_ptr - Channelized enabled interrupt table
*
* OUTPUTS:
*   int_table_ptr    - Channelized interrupt table to return status
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_ddeg_chnl_retrieve(digi_handle_t            *digi_handle,
                                                         UINT32                    chnl_num,
                                                         coreotn_int_source_t      source,
                                                         lineotn_int_chnl_t       *int_en_table_ptr,
                                                         lineotn_int_chnl_t       *int_table_ptr)
{
    PMC_ERROR               result = PMC_SUCCESS;
    BOOL retrieve_enh = FALSE;
    BOOL retrieve_bursty = FALSE; 
    BOOL retrieve_valid = FALSE;
    digi_pmon_ddeg_stage_t *ddeg_ptr;

    PMC_ENTRY();


    PMC_ASSERT(digi_handle    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_table_ptr  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);


    /* If ddeg has not been triggered, just return */
    if (FALSE == digi_handle->var.int_info_ary->ddeg_cache_valid)
    {
        PMC_RETURN(PMC_SUCCESS);
    }
    
    if (PMC_SUCCESS == result)
    {
        BOOL8 is_line = TRUE;

        if (COREOTN_INT_SOURCE_SYS == source)
        {
            is_line = FALSE;
        }
        /* Get pointer to ddeg cache */
        digi_otn_server_int_ddeg_get(digi_handle,
                                     is_line,
                                     &ddeg_ptr);
    }


    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_ddeg_scope_get(digi_handle,
                                                 COREOTN_DDEG_MON_LINE,
                                                 &retrieve_enh,
                                                 &retrieve_bursty,
                                                 &retrieve_valid);
    }

    if (PMC_SUCCESS == result && FALSE == retrieve_valid)
    {
        if (DIGI_OTN_ENHANCED_DDEG == digi_handle->var.linesys_ddeg_mode)
        {
            retrieve_enh = TRUE;
            retrieve_valid = TRUE;
        }
        else if (DIGI_OTN_ENH_BURSTY_DDEG == digi_handle->var.linesys_ddeg_mode)
        {
            retrieve_bursty = TRUE;
            retrieve_enh = TRUE;
            retrieve_valid = TRUE;
        }
    }

    if (PMC_SUCCESS == result && TRUE == retrieve_valid)
    {
        if (retrieve_enh)
        {
            int_table_ptr->otu_frm.otu_sk_d_deg_enh_i = 
                pmc_bitarray_is_bit_set(ddeg_ptr[DIGI_PMON_DDEG_MODE_ENH].i_ptr, chnl_num);
            int_table_ptr->otu_frm.otu_sk_d_deg_enh_v = 
                pmc_bitarray_is_bit_set(ddeg_ptr[DIGI_PMON_DDEG_MODE_ENH].v_ptr, chnl_num);
        }

        if (retrieve_bursty)
        {
            int_table_ptr->otu_frm.otu_sk_d_deg_bursty_i = 
                pmc_bitarray_is_bit_set(ddeg_ptr[DIGI_PMON_DDEG_MODE_BURSTY].i_ptr, chnl_num);
            int_table_ptr->otu_frm.otu_sk_d_deg_bursty_v = 
                pmc_bitarray_is_bit_set(ddeg_ptr[DIGI_PMON_DDEG_MODE_BURSTY].v_ptr, chnl_num);
        }
    }
    else
    {
        int_table_ptr->otu_frm.otu_sk_d_deg_bursty_i = 0;
        int_table_ptr->otu_frm.otu_sk_d_deg_bursty_v = 0;        
    }

    PMC_RETURN(result);
} /* digi_otn_server_int_ddeg_chnl_retrieve */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_pm_stage_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts on an ODU RFRM PM channel for the specified framer.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem
*   odu_level       - Indicates whether to enable interrupts on HO/MO/LO
*   enable          - TRUE to enable specified interrupts, FALSE to disable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_pm_stage_enable(digi_handle_t             *digi_handle,
                                                   digi_otn_odu_chnl_t       *chnl_handle,
                                                   odu_struct_odu_level_t     odu_level,
                                                   BOOL                       enable)
{
    PMC_ERROR       result = PMC_SUCCESS;

    coreotn_int_chnl_info_t     chnl_info;
    coreotn_handle_t           *coreotn_handle;
    UINT32                      start_chnl = 0;
    UINT32                      end_chnl   = 0;
    UINT32                      i;
    odu_struct_t               *handle_pool_ptr;
    
    
    PMC_ENTRY();


    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Determine if we are modfiying one channel or all channels in odu level */
    if (PMC_SUCCESS == result)
    {
        /* Get range of channels to retrieve within ODU level */
        result = digi_otn_odu_int_link_range_get(digi_handle,
                                                 chnl_handle,
                                                 odu_level,
                                                 &start_chnl,
                                                 &end_chnl);
    }

    /* Get the pool pointer for ODU level */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_handle_pool_get(digi_handle, odu_level, &handle_pool_ptr);
    }

    /* Enable interrupts */
    PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));
    coreotn_handle      = digi_handle->coreotn_handle;
    chnl_info.odu_level = odu_level;

    if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    { 
        chnl_info.source = COREOTN_INT_SOURCE_SYS; 
    }
    else
    {
        chnl_info.source = COREOTN_INT_SOURCE_LINE; 
    }


    for (i = start_chnl; (i < end_chnl) && (PMC_SUCCESS == result); i++)
    {
        if (util_global_is_chnl_prov(&handle_pool_ptr[i]))
        {
            chnl_info.chnl_id = i;

            result = coreotn_int_pm_chnl_enable(digi_handle->coreotn_handle, 
                                                &chnl_info,
                                                enable);
        }
    }



    PMC_RETURN(result);
} /* digi_otn_odu_int_pm_stage_enable */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_pm_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts on an ODU RFRM PM channel.
*   Defects must be enabled per framer (HO/MO/LO) using
*   digi_otn_odu_int_defect_enable().
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem and all ODU levels (HO/MO/LO)
*   enable          - TRUE to enable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_pm_chnl_enable_internal(digi_handle_t          *digi_handle,
                                                           digi_otn_odu_chnl_t    *chnl_handle,
                                                           BOOL                    enable)
{
    PMC_ERROR                result = PMC_SUCCESS;
    UINT32                   i;
    UINT32                   num_odu;
    odu_struct_odu_level_t   odu_list[LAST_ODU_STRUCT_LEVEL];
    
    
    PMC_ENTRY();

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Callback for interrupt table must be registered before enable ints */
    if (PMC_SUCCESS == result && TRUE == enable)
    {
        if(!digi_int_is_cb_registered(digi_handle, DIGI_INT_TYPE_OTN) && 
           !digi_int_is_cb_registered(digi_handle, DIGI_INT_CHNL_TYPE_OTN_ODU))
        {
            result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
        }
    }


    /* Get range of odu levels (HO/MO/LO) to enable */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_odu_range_get(digi_handle,
                                                chnl_handle,
                                                odu_list,
                                                &num_odu);
    }

    /* Enable interrupts per odu level */
    for (i = 0; (PMC_SUCCESS == result) && (i < num_odu); i++)
    {
        result = digi_otn_odu_int_pm_stage_enable(digi_handle,
                                                  chnl_handle,
                                                  odu_list[i],
                                                  enable);
    } 



    PMC_RETURN(result);
} /* digi_otn_odu_int_pm_chnl_enable_internal */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_pm_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts on an ODU RFRM PM channel.
*   Defects must be enabled per framer (HO/MO/LO) using
*   digi_otn_odu_int_defect_enable().
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem and all ODU levels (HO/MO/LO)
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_pm_chnl_enable(digi_handle_t          *digi_handle,
                                                 digi_otn_odu_chnl_t    *chnl_handle)
{
    PMC_ERROR                result = PMC_SUCCESS;
    
    
    PMC_ATOMIC_ENTRY(digi_handle);

    result = digi_otn_odu_int_pm_chnl_enable_internal(digi_handle,
                                                      chnl_handle,
                                                      DIGI_ENABLE);


    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_pm_chnl_enable */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_pm_chnl_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Disables interrupts on an ODU RFRM PM channel.
*   Defects must be enabled per framer (HO/MO/LO) using
*   digi_otn_odu_int_defect_enable().
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to disable interrupts on all channels
*                     of the subsystem and all ODU levels (HO/MO/LO)
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_pm_chnl_disable(digi_handle_t          *digi_handle,
                                                  digi_otn_odu_chnl_t    *chnl_handle)
{
    PMC_ERROR                result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);


    result = digi_otn_odu_int_pm_chnl_enable_internal(digi_handle,
                                                      chnl_handle,
                                                      DIGI_DISABLE);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_pm_chnl_disable */







/*******************************************************************************
* FUNCTION: digi_otn_odu_int_pid_enable_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables/disables interrupts on an ODU RFRM TCM pool id.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_level       - Indicates whether to enable/disable interrupts on HO/MO/LO
*   pool_id         - Pool id
*   enable          - TRUE to enable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_pid_enable_internal(digi_handle_t             *digi_handle,
                                                       odu_struct_odu_level_t     odu_level,
                                                       UINT32                     pool_id,
                                                       BOOL                       enable)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    coreotn_int_chnl_info_t     chnl_info;

    PMC_ENTRY();

    if (odu_level >= LAST_ODU_STRUCT_LEVEL) 
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }


    PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));

    chnl_info.rx_pool_id[0] = pool_id;
    chnl_info.odu_level     = odu_level;

    if (TRUE == DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
    {
        chnl_info.source = COREOTN_INT_SOURCE_SYS;
    }
    else
    {
        chnl_info.source = COREOTN_INT_SOURCE_LINE;
    }

    result = coreotn_int_pid_chnl_enable(digi_handle->coreotn_handle, 
                                         &chnl_info,
                                         enable);

    PMC_RETURN(result);

} /* digi_otn_odu_int_pid_enable_internal */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_pid_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts on an ODU RFRM TCM pool id.
*   Defects must be enabled per framer (HO/MO/LO) using
*   digi_otn_odu_int_defect_enable().
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_level       - Indicates whether to enable interrupts on HO/MO/LO
*   pool_id         - Pool id
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_pid_enable(digi_handle_t             *digi_handle,
                                             odu_struct_odu_level_t     odu_level,
                                             UINT32                     pool_id)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    result = digi_otn_odu_int_pid_enable_internal(digi_handle,
                                                  odu_level,
                                                  pool_id,
                                                  DIGI_ENABLE);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_pid_enable */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_pid_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Disables interrupts on an ODU RFRM TCM pool id.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_level       - Indicates whether to disable interrupts on HO/MO/LO
*   pool_id         - Pool id
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_pid_disable(digi_handle_t             *digi_handle,
                                              odu_struct_odu_level_t     odu_level,
                                              UINT32                     pool_id)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    result = digi_otn_odu_int_pid_enable_internal(digi_handle,
                                                  odu_level,
                                                  pool_id,
                                                  DIGI_DISABLE);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_pid_disable */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_defect_enable_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables/disable specified defect.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_level       - Indicates whether to enable/disable interrupts on HO/MO/LO
*   defect          - Defect to enable/disable
*   enable          - TRUE to enable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_defect_enable_internal(digi_handle_t           *digi_handle,
                                                          odu_struct_odu_level_t   odu_level,
                                                          odu_rfrm_int_defect_t    defect,
                                                          BOOL                     enable)
{
    PMC_ERROR               result = PMC_SUCCESS;
    coreotn_int_chnl_info_t chnl_info;
    
    PMC_ENTRY();

    if (odu_level >= LAST_ODU_STRUCT_LEVEL) 
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }
    
    if (defect >= LAST_ODU_RFRM_INT_DEFECT) 
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }


    PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));

    chnl_info.odu_level     = odu_level;
    chnl_info.defect        = defect;
    /*
     * If this is a SYSOTN application then use the COREOTN SYS as the
     * source of the interrupt otherwuse use the COREOTN LINE.
     */
    if (TRUE == DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
    {
        chnl_info.source = COREOTN_INT_SOURCE_SYS;
    }
    else
    {
        chnl_info.source = COREOTN_INT_SOURCE_LINE;
    }
    result = coreotn_int_defect_enable(digi_handle->coreotn_handle, 
                                       &chnl_info,
                                       enable);


    PMC_RETURN(result);

} /* digi_otn_odu_int_defect_enable_internal */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_defect_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables specified defect. Channels must be enabled for a given framer
*   using digi_otn_odu_int_pm_chnl_enable() or digi_otn_odu_int_pid_enable().
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_level       - Indicates whether to enable interrupts on HO/MO/LO
*   defect          - Defect to enable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_defect_enable(digi_handle_t           *digi_handle,
                                                odu_struct_odu_level_t   odu_level,
                                                odu_rfrm_int_defect_t    defect)
{
    PMC_ERROR       result = PMC_SUCCESS;


    PMC_ATOMIC_ENTRY(digi_handle);

    result = digi_otn_odu_int_defect_enable_internal(digi_handle,
                                                     odu_level,
                                                     defect,
                                                     DIGI_ENABLE);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_defect_enable */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_defect_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Disables specified defect.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_level       - Indicates whether to disable interrupts on HO/MO/LO
*   defect          - Defect to disable 
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_defect_disable(digi_handle_t           *digi_handle,
                                                odu_struct_odu_level_t   odu_level,
                                                odu_rfrm_int_defect_t    defect)
{
    PMC_ERROR       result = PMC_SUCCESS;


    PMC_ATOMIC_ENTRY(digi_handle);


    result = digi_otn_odu_int_defect_enable_internal(digi_handle,
                                                     odu_level,
                                                     defect,
                                                     DIGI_DISABLE);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_defect_disable */








/*******************************************************************************
* FUNCTION: digi_otn_odu_int_framer_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables framer interrupts based on bits that are set in the channel
*   interrupt table.
*
*   Note: RFRM interrupts must be enabled using digi_otn_odu_int_defect_enable()
*         and digi_otn_odu_int_pm_chnl_enable(). See the ODU RFRM interrupt
*         table odu_rfrm_int_chnl_t for a list of affected interrupts.
*
*         Individual RFRM defects are enabled across all channels and PIDs in a
*         given framer. Similarly, a channel or PID will be enabled for all
*         RFRM defects across a framer. 
*
*         For example, the API digi_otn_odu_int_defect_enable() can be used to
*         enable the DAIS defect in the mid-order framer. Any enabled channel
*         or PID in the mid-order framer that is in the DAIS state will then
*         cause an interrupt. If a channel or PID is disabled, then no defects
*         on that channel or PID will cause an interrupt.
*
*         Non-RFRM interrupts behave normally.
*
*         
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem and all ODU levels (HO/MO/LO)
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_framer_chnl_enable(digi_handle_t             *digi_handle,
                                                     digi_otn_odu_chnl_t       *chnl_handle,
                                                     coreotn_int_framer_chnl_t *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result);

    result = digi_otn_odu_int_framer_chnl_enable_internal(digi_handle,
                                                          chnl_handle,
                                                          int_table_ptr,
                                                          DIGI_ENABLE);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_framer_chnl_enable */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_framer_chnl_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Disables framer interrupts based on bits that are set in the channel
*   interrupt table.
*
*   Note: RFRM interrupts must be enabled using digi_otn_odu_int_defect_disable()
*         and digi_otn_odu_int_pm_chnl_disable(). See the ODU RFRM interrupt
*         table odu_rfrm_int_chnl_t for a list of affected interrupts.
*
*         Individual RFRM defects are enabled across all channels and PIDs in a
*         given framer. Similarly, a channel or PID will be enabled for all
*         RFRM defects across a framer. 
*
*         For example, the API digi_otn_odu_int_defect_enable() can be used to
*         enable the DAIS defect in the mid-order framer. Any enabled channel
*         or PID in the mid-order framer that is in the DAIS state will then
*         cause an interrupt. If a channel or PID is disabled, then no defects
*         on that channel or PID will cause an interrupt.
*
*         Non-RFRM interrupts behave normally.
*
*
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to disable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to disable interrupts on all channels
*                     of the subsystem and all ODU levels (HO/MO/LO)
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_framer_chnl_disable(digi_handle_t             *digi_handle,
                                                      digi_otn_odu_chnl_t       *chnl_handle,
                                                      coreotn_int_framer_chnl_t *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result);

    result = digi_otn_odu_int_framer_chnl_enable_internal(digi_handle,
                                                          chnl_handle,
                                                          int_table_ptr,
                                                          DIGI_DISABLE);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_framer_chnl_disable */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_framer_chnl_enable_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables framer interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem and all ODU levels (HO/MO/LO)
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*   enable          - TRUE to enable, FALSE to disable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PUBLIC PMC_ERROR digi_otn_odu_int_framer_chnl_enable_internal(digi_handle_t             *digi_handle,
                                                                      digi_otn_odu_chnl_t       *chnl_handle,
                                                                      coreotn_int_framer_chnl_t *int_table_ptr,
                                                                      BOOL                       enable)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    digi_int_type_t          int_type = DIGI_INT_CHNL_TYPE_OTN_ODU;
    UINT32                   i;
    UINT32                   num_odu;
    odu_struct_odu_level_t   odu_list[LAST_ODU_STRUCT_LEVEL];
    
    
    PMC_ENTRY();
    result = digi_int_param_check(digi_handle, chnl_handle, int_type, int_table_ptr); 

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Callback for interrupt table must be registered before enable ints */
    if (PMC_SUCCESS == result && TRUE == enable)
    {
        if(!digi_int_is_cb_registered(digi_handle, DIGI_INT_TYPE_OTN) && 
           !digi_int_is_cb_registered(digi_handle, DIGI_INT_CHNL_TYPE_OTN_ODU))
        {
            result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
        }
    }


    /* Get range of odu levels (HO/MO/LO) to enable */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_odu_range_get(digi_handle,
                                                chnl_handle,
                                                odu_list,
                                                &num_odu);
    }

    /* Enable interrupts per odu level */
    for (i = 0; (PMC_SUCCESS == result) && (i < num_odu); i++)
    {
        result = digi_otn_odu_int_framer_chnl_stage_enable(digi_handle,
                                                           chnl_handle,
                                                           odu_list[i],
                                                           int_table_ptr,
                                                           enable);
    } 


    PMC_RETURN(result);
} /* digi_otn_odu_int_framer_chnl_enable_internal */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_framer_chnl_stage_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables framer interrupts in the specified HO/MO/LO stage based on bits that are
*   set in the channel interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem
*   odu_level       - Indicates whether to enable interrupts on HO/MO/LO
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*   enable          - TRUE to enable specified interrupts, FALSE to disable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_framer_chnl_stage_enable(digi_handle_t             *digi_handle,
                                                            digi_otn_odu_chnl_t       *chnl_handle,
                                                            odu_struct_odu_level_t     odu_level,
                                                            coreotn_int_framer_chnl_t *int_table_ptr,
                                                            BOOL                       enable)
{
    PMC_ERROR           result = PMC_SUCCESS;

    coreotn_int_chnl_info_t     chnl_info;
    coreotn_handle_t           *coreotn_handle;
    UINT32                      start_chnl = 0;
    UINT32                      end_chnl   = 0;
    UINT32                      i;
    coreotn_int_framer_chnl_t  *framer_en_ptr;
    odu_struct_t               *handle_pool_ptr;
    
    
    PMC_ENTRY();


    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Determine if we are modfiying one channel or all channels in odu level */
    if (PMC_SUCCESS == result)
    {
        /* Get range of channels to retrieve within ODU level */
        result = digi_otn_odu_int_link_range_get(digi_handle,
                                                 chnl_handle,
                                                 odu_level,
                                                 &start_chnl,
                                                 &end_chnl);
    }

    /* Get the pool pointer for ODU level */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_handle_pool_get(digi_handle, odu_level, &handle_pool_ptr);
    }


    /* Get specific ODU level framer enabled interrupt table */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_en_framer_get(digi_handle,
                                                odu_level,
                                                &framer_en_ptr);
    }

    PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));
    /* Enable interrupts */
    coreotn_handle      = digi_handle->coreotn_handle;
    chnl_info.odu_level = odu_level;

    if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    { 
        chnl_info.source = COREOTN_INT_SOURCE_SYS; 
    }
    else
    {
        chnl_info.source = COREOTN_INT_SOURCE_LINE; 
    }


    for (i = start_chnl; (i < end_chnl) && (PMC_SUCCESS == result); i++)
    {
        if (util_global_is_chnl_prov(&handle_pool_ptr[i]))
        {
            chnl_info.chnl_id = i;
            result = coreotn_int_framer_chnl_enable(coreotn_handle, 
                                                    &chnl_info,
                                                    int_table_ptr,
                                                    &framer_en_ptr[i], 
                                                    enable);
            PMC_ATOMIC_YIELD(digi_handle,0);
            if (PMC_SUCCESS == result)
            {
                result = digi_otn_odu_int_framer_chnl_ddeg_enable(digi_handle,
                                                                  odu_level,
                                                                  chnl_info.source,
                                                                  i,        /* start chnl */
                                                                  i + 1,    /* end chnl */
                                                                  int_table_ptr,
                                                                  framer_en_ptr,
                                                                  enable);
            }
        }
    }
                
    PMC_RETURN(result);
} /* digi_otn_odu_int_framer_chnl_stage_enable */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_framer_chnl_ddeg_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables/disables enh and bursty ddeg, and updates the internal SW
*   enabled table.
*
*   Enhanced dDEG in SW enables FW enhanced DDEG and FW bursty dDEG.
*   Bursty dDEG in SW enables only FW bursty dDEG.
*
* INPUTS:
*   digi_handle       - Pointer to digi handle
*   odu_level         - ODU level that is being modified. Stg3b is not valid.
*   source            - source of OTN datapath: line or system
*   start_chnl        - Start channel
*   end_chnl          - End channel
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to enable interrupts. If NULL, enables/disables
*                       all interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_framer_chnl_ddeg_enable(digi_handle_t             *digi_handle,
                                                          odu_struct_odu_level_t     odu_level,
                                                          coreotn_int_source_t       source, 
                                                          UINT32                     start_chnl,
                                                          UINT32                     end_chnl,
                                                          coreotn_int_framer_chnl_t *int_table_ptr,
                                                          coreotn_int_framer_chnl_t *int_en_table_ptr,
                                                          BOOL                       enable)
                                                           
{
    PMC_ERROR                       result = PMC_SUCCESS;
    BOOL                            update_enh, update_bursty, update_valid;
    UINT32                          i;
    coreotn_ddeg_mon_seg_t          mon_seg;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_table_ptr != NULL, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(int_en_table_ptr != NULL, DIGI_ERR_INVALID_ARG, 0, 0);


    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }


    if (ODU_STRUCT_LEVEL_3B_ODU == odu_level)
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }


    if (ODU_STRUCT_LEVEL_4_ODU == odu_level)
    {
        mon_seg = COREOTN_DDEG_MON_CLIENT;
    }
    else
    {
        mon_seg = COREOTN_DDEG_MON_LINE;
    }

    /* Obtain the scope of ddeg */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_ddeg_scope_get(digi_handle,
                                                 mon_seg,
                                                 &update_enh,
                                                 &update_bursty,
                                                 &update_valid);
    }


    if (FALSE == update_valid)
    {
        /* Nothing to do for enh dDeg */
        PMC_RETURN(result);
    }

    /* Configure FW enhanced dDEG */
    if ((update_enh) &&
        (int_table_ptr->rfrm.ddeg_enh_pm_i) &&
        (PMC_SUCCESS == result))
    {
        result = digi_otn_odu_int_ddeg_cfg(digi_handle,
                                           DIGI_PMON_DDEG_MODE_ENH,
                                           odu_level,
                                           source,
                                           FALSE, /* is_tcm */
                                           start_chnl,
                                           end_chnl,
                                           enable);
       
        /* Set internal table */
        for (i = start_chnl; (i < end_chnl) && (PMC_SUCCESS == result); i++)
        {
            int_en_table_ptr[i].rfrm.ddeg_enh_pm_i = enable;
        }
    }


    /* Configure FW bursty dDEG */
    if ((update_bursty) &&
        (int_table_ptr->rfrm.ddeg_bursty_pm_i) &&
        (PMC_SUCCESS == result))
    {
        result = digi_otn_odu_int_ddeg_cfg(digi_handle,
                                           DIGI_PMON_DDEG_MODE_BURSTY,
                                           odu_level,
                                           source,
                                           FALSE, /* is_tcm */
                                           start_chnl,
                                           end_chnl,
                                           enable);
        
        /* Set internal table */
        for (i = start_chnl; (i < end_chnl) && (PMC_SUCCESS == result); i++)
        {
            int_en_table_ptr[i].rfrm.ddeg_bursty_pm_i = enable;
        }
    }
    
   


    PMC_RETURN(result);
} /* digi_otn_odu_int_framer_chnl_ddeg_enable */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ddeg_cfg()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures the FW enhanced or bursty dDEG feature.   
*
* INPUTS:
*   digi_handle       - Pointer to digi handle
*   ddeg_mode         - FW Enhanced or FW bursty DDEG mode.
*   odu_level         - ODU level that is being modified. Stg3b is not valid.
*   source            - source of OTN datapath: line or system
*   is_tcm            - TRUE if configuring TCM, FALSE if configuring for framer
*   start_chnl        - Start channel
*   end_chnl          - End channel
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_ddeg_cfg(digi_handle_t             *digi_handle,
                                            digi_pmon_ddeg_mode_t      ddeg_mode,        
                                            odu_struct_odu_level_t     odu_level,
                                            coreotn_int_source_t       source, 
                                            BOOL                       is_tcm,
                                            UINT32                     start_chnl,
                                            UINT32                     end_chnl,
                                            BOOL                       enable)
{
    PMC_ERROR                       result = PMC_SUCCESS;
    digi_pmon_ddeg_chnl_bitmsk_t    chnl_bitmask;
    digi_pmon_ddeg_hw_block_t       ddeg_hw_block[LAST_ODU_STRUCT_LEVEL] = { DIGI_PMON_DDEG_HW_BLOCK_MAX_NUM };
    UINT32                          i;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(end_chnl > start_chnl, DIGI_ERR_CODE_ASSERT, 0, 0);
    PMC_MEMSET((void*)&chnl_bitmask, 0, sizeof(digi_pmon_ddeg_chnl_bitmsk_t));


    /* Create channel bit mask */
    for (i = start_chnl; i < end_chnl; i++)
    {
        pmc_bitarray_set_bit((pmc_bitarray_t *) &chnl_bitmask, i);
    } 

    switch (source)
    {
      case COREOTN_INT_SOURCE_LINE:
        if (TRUE == is_tcm)
        {
            ddeg_hw_block[ODU_STRUCT_LEVEL_HO_ODU] = DIGI_PMON_DDEG_COREOTN_STG_1_TCM;
            ddeg_hw_block[ODU_STRUCT_LEVEL_MO_ODU] = DIGI_PMON_DDEG_COREOTN_STG_2_TCM;
            ddeg_hw_block[ODU_STRUCT_LEVEL_LO_ODU] = DIGI_PMON_DDEG_COREOTN_STG_3A_4_TCM;
            ddeg_hw_block[ODU_STRUCT_LEVEL_4_ODU]  = DIGI_PMON_DDEG_COREOTN_STG_3A_4_TCM;
        }
        else
        {
            ddeg_hw_block[ODU_STRUCT_LEVEL_HO_ODU] = DIGI_PMON_DDEG_COREOTN_STG_1_PM;
            ddeg_hw_block[ODU_STRUCT_LEVEL_MO_ODU] = DIGI_PMON_DDEG_COREOTN_STG_2_PM;
            ddeg_hw_block[ODU_STRUCT_LEVEL_LO_ODU] = DIGI_PMON_DDEG_COREOTN_STG_3A_4_PM;
            ddeg_hw_block[ODU_STRUCT_LEVEL_4_ODU]  = DIGI_PMON_DDEG_COREOTN_STG_3A_4_PM;
        }
        break;
        
      case COREOTN_INT_SOURCE_SYS:
        if (TRUE == is_tcm)
        {
            ddeg_hw_block[ODU_STRUCT_LEVEL_HO_ODU] = DIGI_PMON_DDEG_COREOTN_STG_N_TCM;
            ddeg_hw_block[ODU_STRUCT_LEVEL_MO_ODU] = DIGI_PMON_DDEG_COREOTN_STG_3A_4_TCM;
            ddeg_hw_block[ODU_STRUCT_LEVEL_LO_ODU] = DIGI_PMON_DDEG_COREOTN_STG_1_TCM;
            ddeg_hw_block[ODU_STRUCT_LEVEL_4_ODU]  = DIGI_PMON_DDEG_COREOTN_STG_3A_4_TCM;
            ddeg_hw_block[ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC]  = DIGI_PMON_DDEG_COREOTN_STG_2_TCM;
        }
        else
        {
            ddeg_hw_block[ODU_STRUCT_LEVEL_HO_ODU] = DIGI_PMON_DDEG_COREOTN_STG_N_PM;
            ddeg_hw_block[ODU_STRUCT_LEVEL_MO_ODU] = DIGI_PMON_DDEG_COREOTN_STG_3A_4_PM;
            ddeg_hw_block[ODU_STRUCT_LEVEL_LO_ODU] = DIGI_PMON_DDEG_COREOTN_STG_1_PM;
            ddeg_hw_block[ODU_STRUCT_LEVEL_4_ODU]  = DIGI_PMON_DDEG_COREOTN_STG_3A_4_PM;
            ddeg_hw_block[ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC]  = DIGI_PMON_DDEG_COREOTN_STG_2_TCM;
        }
        break;
        
      default:
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
        break;
    } /* end switch */
    
   


    /* Configure FW */
    if (PMC_SUCCESS == result)
    {
        result = digi_pmon_ddeg_int_en_cfg(digi_handle,
                                           ddeg_mode,
                                           ddeg_hw_block[odu_level],
                                           chnl_bitmask,
                                           enable);

    }
   

    PMC_RETURN(result);
} /* digi_otn_odu_int_ddeg_cfg */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ddeg_scope_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Gets the scope of the configured enhanced dDEG, and returns what
*   needs to be operated on (if anything).
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   mon_seg         - Monitoring segment (stg1/stg2/stg3, or stg4)
*
* OUTPUTS:
*   enh_valid_ptr   - Returns TRUE if it is valid to operate on FW Enhanced dDeg
*   bursty_valid_ptr- Returns TRUE if it is valid to operate on FW bursty dDeg
*   valid_ptr       - Returns TRUE if there is anything to operate on for dDeg.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ddeg_scope_get(digi_handle_t             *digi_handle,
                                                 coreotn_ddeg_mon_seg_t     mon_seg,
                                                 BOOL                      *enh_valid_ptr,
                                                 BOOL                      *bursty_valid_ptr,
                                                 BOOL                      *valid_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    coreotn_ddeg_mon_seg_t      cfg_mon_seg;
    BOOL8                       enh_enabled;
    BOOL8                       bursty_enabled;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle      != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(enh_valid_ptr    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(bursty_valid_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(valid_ptr        != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    if (mon_seg >= LAST_COREOTN_DDEG_MON_SEG)
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    if (PMC_SUCCESS == result)
    {
        result = coreotn_ddeg_mode_get(digi_handle->coreotn_handle, COREOTN_ENH_BURSTY_DDEG, &bursty_enabled);
    }

    if (PMC_SUCCESS == result)
    {
        result = coreotn_ddeg_mode_get(digi_handle->coreotn_handle, COREOTN_ENHANCED_DDEG, &enh_enabled);
    }

    if (PMC_SUCCESS == result)
    {
        /* Nothing to do - configured for HW dDeg */
        *valid_ptr = FALSE;

        if (TRUE == bursty_enabled || TRUE == enh_enabled)
        {
            if (PMC_SUCCESS == result)
            {
                result = coreotn_ddeg_mon_segment_get(digi_handle->coreotn_handle, &cfg_mon_seg);
                
                /* Determine the configure ddeg path (lineotn or mapotn) */
                if (mon_seg != cfg_mon_seg)
                {
                    /* Nothing to do */
                    
                    PMC_RETURN(result);
                }
            }
            
            if (PMC_SUCCESS == result)
            {
                /* Determine configured ddeg mode */
                if (TRUE == bursty_enabled)
                {
                    *enh_valid_ptr    = TRUE;
                    *bursty_valid_ptr = TRUE;
                    *valid_ptr        = TRUE;
                }
                else if (TRUE == enh_enabled)
                {
                    *enh_valid_ptr    = TRUE;
                    *bursty_valid_ptr = FALSE;
                    *valid_ptr        = TRUE;
                }
            }
        }
    }
        
    PMC_RETURN(result);
} /* digi_otn_odu_int_ddeg_scope_get */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_stg3b_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables Stage 3b interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     in the Stage 3B ODU level
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_stg3b_chnl_enable(digi_handle_t             *digi_handle,
                                                    digi_otn_odu_chnl_t       *chnl_handle,
                                                    coreotn_int_framer_chnl_t *int_table_ptr)
{      
    PMC_ERROR                   result = PMC_SUCCESS;
        
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result);

    result = digi_otn_odu_int_stg3b_chnl_enable_internal(digi_handle,
                                                         chnl_handle,
                                                         int_table_ptr,
                                                         DIGI_ENABLE);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_stg3b_chnl_enable */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_stg3b_chnl_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Disables Stage 3b interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to disable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to disable interrupts on all channels
*                     in the Stage 3B ODU level
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     disable interrupts
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_stg3b_chnl_disable(digi_handle_t             *digi_handle,
                                                     digi_otn_odu_chnl_t       *chnl_handle,
                                                     coreotn_int_framer_chnl_t *int_table_ptr)
{      
    PMC_ERROR                   result = PMC_SUCCESS;
    
    
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result);

    result = digi_otn_odu_int_stg3b_chnl_enable_internal(digi_handle,
                                                         chnl_handle,
                                                         int_table_ptr,
                                                         DIGI_DISABLE);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_stg3b_chnl_disable */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_stg3b_chnl_enable_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables Stage 3b interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     in the Stage 3B ODU level
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*   enable          - TRUE to enable, FALSE to disable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_stg3b_chnl_enable_internal(digi_handle_t             *digi_handle,
                                                              digi_otn_odu_chnl_t       *chnl_handle,
                                                              coreotn_int_framer_chnl_t *int_table_ptr,
                                                              BOOL                       enable)
{      
    PMC_ERROR                   result = PMC_SUCCESS;
    digi_int_type_t             int_type = DIGI_INT_CHNL_TYPE_OTN_ODU;
    UINT32                      start_chnl = 0;
    UINT32                      end_chnl   = 0;
    UINT32                      i;
    coreotn_int_chnl_info_t     chnl_info;
    coreotn_handle_t           *coreotn_handle;
    coreotn_int_framer_chnl_t  *framer_en_ptr;
        
    PMC_ENTRY();

    result = digi_int_param_check(digi_handle, chnl_handle, int_type, int_table_ptr); 

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Callback for interrupt table must be registered before enable ints */
    if (PMC_SUCCESS == result && TRUE == enable)
    {
        if(!digi_int_is_cb_registered(digi_handle, DIGI_INT_TYPE_OTN) && 
           !digi_int_is_cb_registered(digi_handle, DIGI_INT_CHNL_TYPE_OTN_ODU))
        {
            result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
        }
    }

    
    /* Determine if we are modfiying one channel or all channels */
    if (PMC_SUCCESS == result)
    {
        /* Get range of channels to retrieve within ODU level */
        result = digi_otn_odu_int_link_range_get(digi_handle,
                                                 chnl_handle,
                                                 ODU_STRUCT_LEVEL_3B_ODU,
                                                 &start_chnl,
                                                 &end_chnl);
    }
    

    /* Get specific ODU level framer enabled interrupt table */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_en_framer_get(digi_handle,
                                                ODU_STRUCT_LEVEL_3B_ODU,
                                                &framer_en_ptr);
    }

    PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));
    /* Enable interrupts */
    coreotn_handle      = digi_handle->coreotn_handle;
    chnl_info.odu_level = ODU_STRUCT_LEVEL_3B_ODU;

    if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    { 
        chnl_info.source = COREOTN_INT_SOURCE_SYS; 
    }
    else
    {
        chnl_info.source = COREOTN_INT_SOURCE_LINE; 
    }

    for (i = start_chnl; (i < end_chnl) && (PMC_SUCCESS == result); i++)
    {
        chnl_info.chnl_id = i;
        result = coreotn_int_framer_chnl_enable(coreotn_handle, 
                                                &chnl_info,
                                                int_table_ptr,
                                                &framer_en_ptr[i], 
                                                enable);
        PMC_ATOMIC_YIELD(digi_handle,0);
    }


    PMC_RETURN(result);
} /* digi_otn_odu_int_stg3b_chnl_enable */





/*******************************************************************************
* FUNCTION: digi_otn_odu_int_pid_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables TCM PID interrupts based on bits that are set in the channel
*   interrupt table.
*
*   Note: RFRM interrupts must be enabled using digi_otn_odu_int_defect_enable()
*         and digi_otn_odu_int_pid_enable(). See the ODU RFRM PID interrupt
*         table odu_rfrm_int_pid_chnl_t for a list of affected interrupts.
*
*         Individual RFRM defects are enabled across all channels and PIDs in a
*         given framer. Similarly, a channel or PID will be enabled for all
*         RFRM defects across a framer. 
*
*         For example, the API digi_otn_odu_int_defect_enable() can be used to
*         enable the DAIS defect in the mid-order framer. Any enabled channel
*         or PID in the mid-order framer that is in the DAIS state will then
*         cause an interrupt. If a channel or PID is disabled, then no defects
*         on that channel or PID will cause an interrupt.
*
*         Non-RFRM interrupts behave normally.
*
*
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to enable interrupts on
*   tcm_num         - TCM number to enable
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_pid_chnl_enable(digi_handle_t                 *digi_handle,
                                                  digi_otn_odu_chnl_t           *chnl_handle,
                                                  digi_otn_int_tcm_num_t         tcm_num,
                                                  odu_rfrm_int_pid_chnl_t       *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    
    
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result);

    result = digi_otn_odu_int_pid_chnl_enable_internal(digi_handle,
                                                       chnl_handle,
                                                       tcm_num,
                                                       int_table_ptr,
                                                       DIGI_ENABLE);

    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_pid_chnl_enable */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_pid_chnl_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables TCM PID interrupts based on bits that are set in the channel
*   interrupt table.
*
*   Note: RFRM interrupts must be enabled using digi_otn_odu_int_defect_disable()
*         and digi_otn_odu_int_pid_disable(). See the ODU RFRM PID interrupt
*         table odu_rfrm_int_pid_chnl_t for a list of affected interrupts.
*
*         Individual RFRM defects are enabled across all channels and PIDs in a
*         given framer. Similarly, a channel or PID will be enabled for all
*         RFRM defects across a framer. 
*
*         For example, the API digi_otn_odu_int_defect_enable() can be used to
*         enable the DAIS defect in the mid-order framer. Any enabled channel
*         or PID in the mid-order framer that is in the DAIS state will then
*         cause an interrupt. If a channel or PID is disabled, then no defects
*         on that channel or PID will cause an interrupt.
*
*         Non-RFRM interrupts behave normally.
*
*
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to enable interrupts on
*   tcm_num         - TCM number to enable
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_pid_chnl_disable(digi_handle_t                 *digi_handle,
                                                   digi_otn_odu_chnl_t           *chnl_handle,
                                                   digi_otn_int_tcm_num_t         tcm_num,
                                                   odu_rfrm_int_pid_chnl_t       *int_table_ptr)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    
    
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result);

    result = digi_otn_odu_int_pid_chnl_enable_internal(digi_handle,
                                                       chnl_handle,
                                                       tcm_num,
                                                       int_table_ptr,
                                                       DIGI_DISABLE);

    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_pid_chnl_disable */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_pid_chnl_enable_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables TCM PID interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to enable interrupts on
*   tcm_num         - TCM number to enable
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*   enable          - TRUE to enable, FALSE to disable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_pid_chnl_enable_internal(digi_handle_t                 *digi_handle,
                                                            digi_otn_odu_chnl_t           *chnl_handle,
                                                            digi_otn_int_tcm_num_t         tcm_num,
                                                            odu_rfrm_int_pid_chnl_t       *int_table_ptr,
                                                            BOOL                           enable)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    odu_struct_odu_level_t   odu_level;
    digi_int_type_t          int_type = DIGI_INT_CHNL_TYPE_OTN_ODU;
    UINT32                   pool_id;
    UINT32                   pool_id_array[LAST_DIGI_OTN_TCM_NUM];


    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result);

    result = digi_int_param_check(digi_handle, NULL, int_type, int_table_ptr); 
    
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle, PMC_SUCCESS);
    }

    if (tcm_num >= LAST_DIGI_OTN_TCM_NUM)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }

    if (IS_DIGI_INT_ALL_CHNLS(chnl_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG); 
    }

    /* Callback for interrupt table must be registered before enable ints */
    if (PMC_SUCCESS == result &&  TRUE == enable)
    {
        if(!digi_int_is_cb_registered(digi_handle, DIGI_INT_TYPE_OTN) && 
           !digi_int_is_cb_registered(digi_handle, DIGI_INT_CHNL_TYPE_OTN_ODU))
        {
            result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
        }
    }

    /* Determine odu level of channel and retrieve assigned PIDs on channel */
    if (PMC_SUCCESS == result)
    {
        odu_level = digi_otn_odu_level_internal_get(digi_handle, chnl_handle);
        (void)digi_otn_pool_id_get(digi_handle, chnl_handle, pool_id_array);
    }

    /* Determine pool id from tcm_num */
    if (PMC_SUCCESS == result)
    {
        pool_id = pool_id_array[tcm_num];

        if (DIGI_OTN_IS_TCM_PID_VALID(pool_id))
        {
            result = digi_otn_odu_int_pid_chnl_stage_enable(digi_handle,
                                                            odu_level,
                                                            pool_id,
                                                            int_table_ptr,
                                                            enable);
        }
        else
        {
            result = DIGI_ERR_INT_TCM_NUM_NOT_PROV;
        }
    }

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_odu_int_pid_chnl_enable_internal */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_pid_chnl_stage_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts in the specified HO/MO/LO stage based on bits that are
*   set in the channel interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   odu_level       - Indicates whether to enable interrupts on HO/MO/LO/3b
*   pool_id         - Enable interrupts on this ODU level for specified pool_id
*                     DIGI_OTN_INT_ALL_PIDS for all pool_ids in ODU level.
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*   enable          - TRUE to enable specified interrupts, FALSE to disable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_pid_chnl_stage_enable(digi_handle_t                 *digi_handle,
                                                         odu_struct_odu_level_t         odu_level,
                                                         UINT32                         pool_id,
                                                         odu_rfrm_int_pid_chnl_t       *int_table_ptr,
                                                         BOOL                           enable)
{
    PMC_ERROR           result = PMC_SUCCESS;

    coreotn_int_chnl_info_t     chnl_info;
    coreotn_handle_t           *coreotn_handle;
    UINT32                      start_pid, end_pid;
    UINT32                      i;
    odu_rfrm_int_pid_chnl_t    *pid_en_ptr;
    
    
    PMC_ENTRY();

    
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Determine if we are modfiying one channel or all channels in odu level */
    if (PMC_SUCCESS == result)
    {
        /* Get range of channels to retrieve within ODU level */
        result = digi_otn_odu_int_pid_range_get(digi_handle,
                                                odu_level,
                                                pool_id,
                                                &start_pid,
                                                &end_pid);
    }



    /* Get specific ODU level PID enabled interrupt table */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_en_pid_get(digi_handle,
                                             odu_level,
                                             &pid_en_ptr);
    }
        
    PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));
    /* Enable interrupts */
    coreotn_handle      = digi_handle->coreotn_handle;
    chnl_info.odu_level = odu_level;

    /* determine from odu struct line or source */
    if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    { 
        chnl_info.source = COREOTN_INT_SOURCE_SYS; 
    }
    else
    {
        chnl_info.source = COREOTN_INT_SOURCE_LINE; 
    }

    for (i = start_pid; (i < end_pid) && (PMC_SUCCESS == result); i++)
    {
        chnl_info.rx_pool_id[0] = i;
        result = coreotn_int_pid_chnl_tbl_enable(coreotn_handle, 
                                                 &chnl_info,
                                                 int_table_ptr,
                                                 pid_en_ptr,
                                                 enable);
    }

    
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_pid_chnl_ddeg_enable(digi_handle,
                                                       odu_level,
                                                       chnl_info.source,
                                                       start_pid,
                                                       end_pid,
                                                       int_table_ptr,
                                                       pid_en_ptr,
                                                       enable);
    }

    PMC_RETURN(result);
} /* digi_otn_odu_int_pid_chnl_stage_enable */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_pid_chnl_ddeg_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables/disables enh and bursty ddeg, and updates the internal SW
*   enabled table.
*
*   Enhanced dDEG in SW enables FW enhanced DDEG and FW bursty dDEG.
*   Bursty dDEG in SW enables only FW bursty dDEG.
*
* INPUTS:
*   digi_handle       - Pointer to digi handle
*   odu_level         - ODU level that is being modified. Stg3b is not valid.
*   source            - source of OTN datapath: line or system
*   start_pid         - Start channel
*   end_pid           - End channel
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to enable interrupts. If NULL, enables/disables
*                       all interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_pid_chnl_ddeg_enable(digi_handle_t             *digi_handle,
                                                        odu_struct_odu_level_t     odu_level,
                                                        coreotn_int_source_t       source, 
                                                        UINT32                     start_pid,
                                                        UINT32                     end_pid,
                                                        odu_rfrm_int_pid_chnl_t   *int_table_ptr,
                                                        odu_rfrm_int_pid_chnl_t   *int_en_table_ptr,
                                                        BOOL                       enable)
                                                           
{
    PMC_ERROR result = PMC_SUCCESS;
    BOOL update_enh = FALSE;
    BOOL update_bursty = FALSE;
    BOOL update_valid = FALSE;
    UINT32 i;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_table_ptr != NULL, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(int_en_table_ptr != NULL, DIGI_ERR_INVALID_ARG, 0, 0);


    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    if (ODU_STRUCT_LEVEL_3B_ODU == odu_level)
    {
        /* Nothing to do */
        PMC_RETURN(result);
    }

    /* Obtain the scope of ddeg */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_ddeg_scope_get(digi_handle,
                                                 COREOTN_DDEG_MON_LINE,
                                                 &update_enh,
                                                 &update_bursty,
                                                 &update_valid);
    }


    if (FALSE == update_valid)
    {
        /* Nothing to do for enh dDeg */
        PMC_RETURN(result);
    }

    /* Configure FW enhanced dDEG */
    if ((update_enh) &&
        (int_table_ptr->ddeg_enh_i) &&
        (PMC_SUCCESS == result))
    {
        result = digi_otn_odu_int_ddeg_cfg(digi_handle,
                                           DIGI_PMON_DDEG_MODE_ENH,
                                           odu_level,
                                           source,
                                           TRUE, /* is_tcm */
                                           start_pid,
                                           end_pid,
                                           enable);
       
        /* Set internal table */
        for (i = start_pid; (i < end_pid) && (PMC_SUCCESS == result); i++)
        {
            int_en_table_ptr[i].ddeg_enh_i = enable;
        }
    }


    /* Configure FW bursty dDEG */
    if ((update_bursty) &&
        (int_table_ptr->ddeg_bursty_i) &&
        (PMC_SUCCESS == result))
    {
        result = digi_otn_odu_int_ddeg_cfg(digi_handle,
                                           DIGI_PMON_DDEG_MODE_BURSTY,
                                           odu_level,
                                           source,
                                           TRUE, /* is_tcm */
                                           start_pid,
                                           end_pid,
                                           enable);
        
        /* Set internal table */
        for (i = start_pid; (i < end_pid) && (PMC_SUCCESS == result); i++)
        {
            int_en_table_ptr[i].ddeg_bursty_i = enable;
        }
    }
    
   


    PMC_RETURN(result);
} /* digi_otn_odu_int_pid_chnl_ddeg_enable */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_prbs_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables OTN ODU PRBS interrupts based on bits that are set in the channel
*   interrupt table. PRBS must be enabled on the given channel first.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to enable interrupts on
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_prbs_chnl_enable(digi_handle_t             *digi_handle,
                                                   digi_otn_odu_chnl_t       *chnl_handle,
                                                   coreotn_int_prbs_chnl_t   *int_table_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result);

    result = digi_otn_odu_int_prbs_chnl_enable_internal(digi_handle,
                                                        chnl_handle,
                                                        int_table_ptr,
                                                        DIGI_ENABLE);

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_odu_int_prbs_chnl_enable */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_prbs_chnl_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Disables OTN ODU PRBS interrupts based on bits that are set in the channel
*   interrupt table. PRBS must be enabled on the given channel first.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to disable interrupts on
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_prbs_chnl_disable(digi_handle_t             *digi_handle,
                                                    digi_otn_odu_chnl_t       *chnl_handle,
                                                    coreotn_int_prbs_chnl_t   *int_table_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result);

    result = digi_otn_odu_int_prbs_chnl_enable_internal(digi_handle,
                                                        chnl_handle,
                                                        int_table_ptr,
                                                        DIGI_DISABLE);


    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_odu_int_prbs_chnl_disable */





/*******************************************************************************
* FUNCTION: digi_otn_odu_int_prbs_info_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieve PRBS instance and channel, or returns that PRBS is not provisioned
*   on this ODU channel.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to check interrupts
*
* OUTPUTS:
*   prbs_chnl_ptr   - PRBS channel
*   prbs_inst_ptr   - PRBS instance
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_prbs_info_get(digi_handle_t          *digi_handle,
                                                 digi_otn_odu_chnl_t    *chnl_handle,
                                                 UINT32                 *prbs_chnl_ptr,
                                                 coreotn_prbs_inst_t    *prbs_inst_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    UINT32                      dci_chnl;
    UINT32                      prbs_chnl;
    coreotn_prbs_inst_t         prbs_inst;
    BOOL                        prbs_chnl_valid;
    coreotn_handle_t           *coreotn_handle;

    PMC_ENTRY();
    
    coreotn_handle     = digi_handle->coreotn_handle;
    
    
    /* Retrieve prbs instance for this ODU channel */
    if (PMC_SUCCESS == result)
    {
        result = odu_struct_prbs_inst_get(coreotn_handle,
                                          (odu_struct_t *) chnl_handle,
                                          &prbs_inst);
    }

    /* Retrieve the PRBS channel for this ODU channel */
    if (PMC_SUCCESS == result)
    {
        dci_chnl = digi_otn_odu_chnl_num_internal_get(digi_handle, chnl_handle);
        result = coreotn_prbs_chnl_get(coreotn_handle, prbs_inst, dci_chnl, &prbs_chnl, &prbs_chnl_valid);
    }
       
    if (PMC_SUCCESS == result)
    {
        if (TRUE == prbs_chnl_valid)
        {
            *prbs_chnl_ptr = prbs_chnl;
            *prbs_inst_ptr = prbs_inst;
        }
        else
        {
            result = DIGI_ERR_INT_PRBS_NOT_PROV;
        }
    }


    PMC_RETURN(result);
} /* digi_otn_odu_int_prbs_info_get */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_prbs_is_prov()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the PRBS enabled interrupt table, and returns if PRBS is provisioned
*   on this channel
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to enable interrupts on
*
* OUTPUTS:
*   prbs_chnl_ptr   - PRBS channel
*   prbs_inst_ptr   - PRBS instance
*   prbs_en_pptr    - channelized enabled framer interrupt table
*
* RETURNS:
*   TRUE     - if PRBS is provisioned on the given channel
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL digi_otn_odu_int_prbs_is_prov(digi_handle_t            *digi_handle,
                                           digi_otn_odu_chnl_t      *chnl_handle,
                                           UINT32                   *prbs_chnl_ptr,
                                           coreotn_prbs_inst_t      *prbs_inst_ptr, 
                                           coreotn_int_prbs_chnl_t **prbs_en_pptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    UINT32                      prbs_chnl = 0;
    coreotn_prbs_inst_t         prbs_inst = LAST_COREOTN_PRBS_INST;
    coreotn_int_prbs_chnl_t    (*prbs_en_table_ptr)[COREOTN_PRBS_NUM_CHNL];

    PMC_ENTRY();

    prbs_en_table_ptr  = digi_handle->var.enabled_otn_int->prbs;



    
    /* Determine if PRBS is enabled for this chnl */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_prbs_info_get(digi_handle,
                                                chnl_handle,
                                                &prbs_chnl,
                                                &prbs_inst);
    }


    /* Return enabled PRBS table for provisioned PRBS on this channel */
    if (PMC_SUCCESS == result)
    {
        *prbs_en_pptr  = &prbs_en_table_ptr[prbs_inst][prbs_chnl];
        *prbs_chnl_ptr = prbs_chnl;
        *prbs_inst_ptr = prbs_inst;
    }
    else
    {
        PMC_RETURN(FALSE);
    }


    PMC_RETURN(TRUE);
} /* digi_otn_odu_int_prbs_is_prov */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_prbs_chnl_enable_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables/disables OTN ODU PRBS interrupts based on bits that are set in the
*   channel interrupt table and updates internal enabled interrupt table.
*   PRBS must be enabled on the given channel.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to enable/disable interrupts on
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable/disable interrupts
*   enable          - enable or disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_prbs_chnl_enable_internal(digi_handle_t              *digi_handle,
                                                             digi_otn_odu_chnl_t        *chnl_handle,
                                                             coreotn_int_prbs_chnl_t    *int_table_ptr,
                                                             BOOL                        enable)
{
    PMC_ERROR                result = PMC_SUCCESS;
    digi_int_type_t          int_type = DIGI_INT_CHNL_TYPE_OTN_ODU;
    UINT32                   prbs_chnl;
    coreotn_prbs_inst_t      prbs_inst;
    coreotn_int_prbs_chnl_t *prbs_en_ptr;
    
    
    PMC_ENTRY();
    result = digi_int_param_check(digi_handle, chnl_handle, int_type, int_table_ptr); 
    
    if (NULL == chnl_handle)
    {
        result = DIGI_ERR_INVALID_ARG;
    }

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }


    /* Callback for interrupt table must be registered before enable ints */
    if (PMC_SUCCESS == result && TRUE == enable)
    {
        if(!digi_int_is_cb_registered(digi_handle, DIGI_INT_TYPE_OTN) && 
           !digi_int_is_cb_registered(digi_handle, DIGI_INT_CHNL_TYPE_OTN_ODU))
        {
            result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
        }
    }


    if (PMC_SUCCESS == result)
    {
        if (digi_otn_odu_int_prbs_is_prov(digi_handle,
                                          chnl_handle,
                                          &prbs_chnl,
                                          &prbs_inst,
                                          &prbs_en_ptr))
        {
            result = coreotn_int_prbs_chnl_enable(digi_handle->coreotn_handle,
                                                  prbs_chnl,
                                                  prbs_inst,
                                                  int_table_ptr,
                                                  prbs_en_ptr,
                                                  enable);
        }
        else
        {
            result = DIGI_ERR_INT_PRBS_NOT_PROV;
        }
    }

    PMC_RETURN(result);
} /* digi_otn_odu_int_prbs_chnl_enable_internal */



/*******************************************************************************
* FUNCTION: digi_otn_lineotn_int_filt_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves LINEOTN related unchannelized interrupts to aggregated OTN
*   interrupt table   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   filt_table_ptr  - Pointer to filter structure indicating which blocks
*                     to retrieve
*
* OUTPUTS:
*   int_table_ptr  - pointer to aggregation interrupt table to store interrupt
*                    information
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_lineotn_int_filt_retrieve(digi_handle_t       *digi_handle,
                                                    lineotn_int_t       *filt_table_ptr,
                                                    lineotn_int_t       *int_table_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    PMC_ASSERT(digi_handle    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_table_ptr  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    result = lineotn_int_retrieve(digi_handle->lineotn_handle,
                                  filt_table_ptr,
                                  int_table_ptr);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_lineotn_int_filt_retrieve */



/*******************************************************************************
* FUNCTION: digi_otn_sysotn_int_filt_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SYSOTN related unchannelized interrupts to aggregated OTN
*   interrupt table   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   filt_table_ptr  - Pointer to filter structure indicating which blocks
*                     to retrieve
*
* OUTPUTS:
*   int_table_ptr  - pointer to aggregation interrupt table to store interrupt
*                    information
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_sysotn_int_filt_retrieve(digi_handle_t       *digi_handle,
                                                   lineotn_int_t       *filt_table_ptr,
                                                   lineotn_int_t       *int_table_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_table_ptr  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    result = lineotn_int_retrieve(digi_handle->sysotn_handle,
                                  filt_table_ptr,
                                  int_table_ptr);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_sysotn_int_filt_retrieve */



/*******************************************************************************
* FUNCTION: digi_otn_server_int_filt_retrieve_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves OTN server related interrupts to aggregated OTN interrupt table   
*
* INPUTS:
*  digi_handle      - Pointer to digi handle
*  int_filter_ptr   - Pointer to filter structure indicating which blocks
*                     to retrieve
*  yield_on_true    - Flag that if true calls PMC_ATOMIC_YIELD after the
*                     various interrupt retrieval functions are called.
*
* OUTPUTS:
*   int_table_ptr  - pointer to aggregation interrupt table to store interrupt
*                    information
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_filt_retrieve_internal(digi_handle_t *digi_handle,
                                                             digi_otn_int_filter_t *int_filter_ptr,
                                                             BOOL8 yield_on_true,
                                                             digi_otn_int_t *int_table_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();

    /* Check if OTN server is requested to be retrieved */
    if (FALSE == digi_otn_int_filt_is_otn_server(int_filter_ptr))
    {
        PMC_RETURN(result);
    }

    result = lineotn_int_retrieve(digi_handle->lineotn_handle,
                                  NULL,
                                  &int_table_ptr->lineotn);

    if (PMC_SUCCESS == result && 
        TRUE == DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
    {
        result = lineotn_int_retrieve(digi_handle->sysotn_handle,
                                  NULL,
                                  &int_table_ptr->sysotn);
    }

    if (PMC_SUCCESS == result && TRUE == yield_on_true)
    {
        PMC_ATOMIC_YIELD(digi_handle, 0);
    }


    if (PMC_SUCCESS == result)
    {
        result = digi_otn_server_int_chnl_retrieve(digi_handle,
                                                   DIGI_INT_CHNL_TYPE_OTN_SERVER,
                                                   int_table_ptr);

    }
    
    if (PMC_SUCCESS == result && TRUE == DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
    {
        result = digi_otn_server_int_chnl_retrieve(digi_handle,
                                                   DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS,
                                                   int_table_ptr);

        if (PMC_SUCCESS == result && TRUE == yield_on_true)
        {
            PMC_ATOMIC_YIELD(digi_handle, 0);
        }
    }
    /* 
     * Retrieve DDEG interrupts from FW structure to interrupt structure 
     * for line/sys 
     */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_server_int_ddeg_retrieve(digi_handle,
                                                   DIGI_INT_CHNL_TYPE_OTN_SERVER,
                                                   int_table_ptr);

        if (PMC_SUCCESS == result && 
            TRUE == DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
        {
            result = digi_otn_server_int_ddeg_retrieve(digi_handle,
                                                       DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS,
                                                       int_table_ptr);
        }
    }

    PMC_RETURN(result);
} /* digi_otn_server_int_filt_retrieve_internal */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_filt_retrieve_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves OTN ODU related interrupts to aggregated OTN interrupt table   
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   int_filter_ptr  - Pointer to filter structure indicating which blocks
*                     to retrieve
*   yield_on_true   - Call PMC_ATOMIC_YIELD if flag is TRUE and ignore
*                     otherwise.
*
* OUTPUTS:
*   int_table_ptr  - pointer to aggregation interrupt table to store interrupt
*                    information
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_filt_retrieve_internal(digi_handle_t          *digi_handle,
                                                          digi_otn_int_filter_t  *int_filter_ptr,
                                                          BOOL8 yield_on_true,
                                                          digi_otn_int_t         *int_table_ptr)
{
    PMC_ERROR                result = PMC_SUCCESS;
    UINT32                   i;
    UINT32                   num_odu;
    odu_struct_odu_level_t   odu_list[LAST_ODU_STRUCT_LEVEL];

    PMC_ENTRY();

    /* 
     * Skip interrupt retrieve if subsystem is not powered up 
     * Check if OTN ODU is requested to be retrieved 
     */
    if (TRUE == coreotn_start_state_test(digi_handle->coreotn_handle) ||
        FALSE == digi_otn_int_filt_is_otn_odu(int_filter_ptr))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    result = coreotn_int_retrieve(digi_handle->coreotn_handle, 
                                  DIGI_INT_ALL_CHNLS,
                                  &int_table_ptr->coreotn);

    if (PMC_SUCCESS == result && TRUE == yield_on_true)
    {
        PMC_ATOMIC_YIELD(digi_handle, 0);
    }

    /* Get range of ODU levels (HO/MO/LO) to retrieve */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_odu_range_get(digi_handle,
                                                DIGI_INT_ALL_CHNLS,
                                                odu_list,
                                                &num_odu);
    }

    /* Retrieve all interrupts per odu level */
    for (i = 0; PMC_SUCCESS == result && i < num_odu; i++)
    {
        result = digi_otn_odu_int_chnl_stage_retrieve(digi_handle,
                                                      DIGI_INT_ALL_CHNLS,
                                                      odu_list[i],
                                                      int_filter_ptr,
                                                      int_table_ptr);

        if (PMC_SUCCESS == result && TRUE == yield_on_true)
        {
            PMC_ATOMIC_YIELD(digi_handle, 0);
        }
    } 

    PMC_RETURN(result);
} /* digi_otn_odu_int_filt_retrieve_internal */



/*******************************************************************************
* FUNCTION: digi_otn_ohp_rcp_int_filt_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves OTN OHP and RCP related interrupts to aggregated OTN interrupt table   
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   int_filter_ptr  - Pointer to filter structure indicating which blocks
*                     to retrieve
*   yield_on_true   - Flag that indicates whether or not to use atomic
*                     yield if TRUE or not if FALSE.
*
* OUTPUTS:
*   int_table_ptr  - pointer to aggregation interrupt table to store interrupt
*                    information
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_ohp_rcp_int_filt_retrieve(digi_handle_t          *digi_handle,
                                                     digi_otn_int_filter_t  *int_filter_ptr,
                                                     BOOL8 yield_on_true,
                                                     digi_otn_int_t         *int_table_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;
    odu_ohp_inst_t  ohp;

    PMC_ENTRY();

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* retrieve OHP unchannelized interrupts */
    /* OHP channelized interrupts are retrieved in digi_otn_odu_int_chnl_stage_retrieve */
    if (TRUE == digi_otn_int_filt_is_ohp(int_filter_ptr))
    {
        for (ohp = ODU_OHP_1; ODU_OHP_LAST > ohp && PMC_SUCCESS == result; ohp = (odu_ohp_inst_t)((UINT32)ohp + 1))
        {
            result = coreotn_int_ohp_retrieve(digi_handle->coreotn_handle, 
                                              ohp,
                                              NULL,
                                              &int_table_ptr->ohp[(UINT32)ohp]);

        }

        if (PMC_SUCCESS == result && TRUE == yield_on_true)
        {
            PMC_ATOMIC_YIELD(digi_handle, 0);
        }
    }

    if (PMC_SUCCESS == result &&
        TRUE == digi_otn_int_filt_is_rcp(int_filter_ptr))
    {
        result = coreotn_int_rcp_retrieve(digi_handle->coreotn_handle, 
                                          ODU_RCP_DI_INST,
                                          NULL,
                                          &int_table_ptr->di_rcp);

        if (PMC_SUCCESS == result && TRUE == yield_on_true)
        {
            PMC_ATOMIC_YIELD(digi_handle, 0);
        }
    }
    
    if (PMC_SUCCESS == result)
    {
        result = coreotn_int_rcp_retrieve(digi_handle->coreotn_handle, 
                                          ODU_RCP_RI_INST,
                                          NULL,
                                          &int_table_ptr->ri_rcp);

        if (PMC_SUCCESS == result && TRUE == yield_on_true)
        {
            PMC_ATOMIC_YIELD(digi_handle, 0);
        }
    }

    PMC_RETURN(result);
} /* digi_otn_ohp_rcp_int_filt_retrieve */


/*******************************************************************************
* FUNCTION: digi_otn_int_filt_is_otn_server()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks if block filter mask contains OTN Server 
*
* INPUTS:
*   int_filter_ptr  - Pointer to filter structure indicating which blocks
*                     to retrieve
*
* OUTPUTS:
*
* RETURNS:
*   TRUE            - if block filter contains OTN Server
*   FALSE           - if block filter does not contain OTN Server
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL digi_otn_int_filt_is_otn_server(digi_otn_int_filter_t   *int_filter_ptr)
{
    PMC_ENTRY();
    PMC_ASSERT(int_filter_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_RETURN(coreotn_int_filt_check(int_filter_ptr->blocks, COREOTN_INT_FILTER_BLOCKS_OTN_SERVER));

} /* digi_otn_int_filt_is_otn_server */


/*******************************************************************************
* FUNCTION: digi_otn_int_filt_is_otn_odu()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks if block filter mask contains OTN ODU 
*
* INPUTS:
*   int_filter_ptr  - Pointer to filter structure indicating which blocks
*                     to retrieve
*
* OUTPUTS:
*
* RETURNS:
*   TRUE            - if block filter contains OTN ODU 
*   FALSE           - if block filter does not contain OTN ODU 
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL digi_otn_int_filt_is_otn_odu(digi_otn_int_filter_t   *int_filter_ptr)
{
    PMC_ENTRY();
    PMC_ASSERT(int_filter_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_RETURN(coreotn_int_filt_check(int_filter_ptr->blocks, COREOTN_INT_FILTER_BLOCKS_OTN_ODU));


} /* digi_otn_int_filt_is_otn_odu */


/*******************************************************************************
* FUNCTION: digi_otn_int_filt_is_otn_stg3b()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks if block filter mask contains OTN ODU Stage 3B
*
* INPUTS:
*   int_filter_ptr  - Pointer to filter structure indicating which blocks
*                     to retrieve
*
* OUTPUTS:
*
* RETURNS:
*   TRUE            - if block filter contains OTN ODU Stage 3B
*   FALSE           - if block filter does not contain OTN ODU Stage 3B
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL digi_otn_int_filt_is_otn_stg3b(digi_otn_int_filter_t   *int_filter_ptr)
{
    PMC_ENTRY();
    PMC_ASSERT(int_filter_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_RETURN(coreotn_int_filt_check(int_filter_ptr->blocks, COREOTN_INT_FILTER_BLOCKS_OTN_STG3B));


} /* digi_otn_int_filt_is_otn_stg3b */


/*******************************************************************************
* FUNCTION: digi_otn_int_filt_is_ohp()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks if block filter mask contains OHP
*
* INPUTS:
*   int_filter_ptr  - Pointer to filter structure indicating which blocks
*                     to retrieve
*
* OUTPUTS:
*
* RETURNS:
*   TRUE            - if block filter contains OHP
*   FALSE           - if block filter does not contain OHP
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL digi_otn_int_filt_is_ohp(digi_otn_int_filter_t   *int_filter_ptr)
{
    PMC_ENTRY();
    PMC_ASSERT(int_filter_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_RETURN(coreotn_int_filt_check(int_filter_ptr->blocks, COREOTN_INT_FILTER_BLOCKS_OHP));


} /* digi_otn_int_filt_is_ohp */


/*******************************************************************************
* FUNCTION: digi_otn_int_filt_is_rcp()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks if block filter mask contains RCP
*
* INPUTS:
*   int_filter_ptr  - Pointer to filter structure indicating which blocks
*                     to retrieve
*
* OUTPUTS:
*
* RETURNS:
*   TRUE            - if block filter contains RCP 
*   FALSE           - if block filter does not contain RCP 
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL digi_otn_int_filt_is_rcp(digi_otn_int_filter_t   *int_filter_ptr)
{
    PMC_ENTRY();
    PMC_ASSERT(int_filter_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_RETURN(coreotn_int_filt_check(int_filter_ptr->blocks, COREOTN_INT_FILTER_BLOCKS_RCP));


} /* digi_otn_int_filt_is_rcp */


/*******************************************************************************
* FUNCTION: digi_otn_int_filt_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves an aggregation interrupt table with interrupt bits
*   over multiple channels.
*
*   Filter structure limits which blocks to retrieve to decrease retrieval time.
*
*   Note that OTN ODU interrupts (e.g. PM and TCM PID interrupts) will always
*   clear on retrieval due to a hardware limitation. This is different than the
*   rest of the system's interrupts which will always have an explict
*   int_clear() function. 
*
*   digi_otn_server_int_chnl_get() and digi_otn_odu_int_chnl_get() can be used
*   to retrieve a specific chnl table from the aggregation table.
*
*   digi_otn_odu_int_start() must be used before calling this function to
*   retrieve the latest RFRM status.
*
*   digi_otn_ddeg_int_start() must be used before calling this function to
*   retrieve the latest dDEG status.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   int_filter_ptr  - Pointer to filter structure indicating which blocks
*                     to retrieve
*
* OUTPUTS:
*   int_table_ptr  - pointer to aggregation interrupt table to store interrupt
*                    information
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_int_filt_retrieve(digi_handle_t           *digi_handle,
                                            digi_otn_int_filter_t   *int_filter_ptr,
                                            digi_otn_int_t          *int_table_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != int_filter_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    if (NULL == int_filter_ptr)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INT_FILTER_TABLE_IS_NULL);
    }
    /* 
     * Enable the interrupt caching. Note that this should be done in the
     * PUBLIC functions to ensure that it does not need to be repeated in
     * the lower level private functions.
     */
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle,
                                 TRUE, TRUE);
    PMC_MEMSET(int_table_ptr, 0, sizeof(digi_otn_int_t));

    result = digi_otn_int_filt_retrieve_internal(digi_handle, 
                                                 int_filter_ptr,
                                                 FALSE,
                                                 int_table_ptr);
    /* 
     * Disable interrupt caching, don't clear its contents. This is done 
     * in the PUBLIC function to ensure it is handled before the function
     * completes.
     */
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, FALSE,FALSE);

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_int_filt_retrieve */


/*******************************************************************************
* FUNCTION: digi_otn_int_filt_retrieve_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves an aggregation interrupt table with interrupt bits
*   over multiple channels.
*
*   Filter structure limits which blocks to retrieve to decrease retrieval time.
*
*   Note that OTN ODU interrupts (e.g. PM and TCM PID interrupts) will always
*   clear on retrieval due to a hardware limitation. This is different than the
*   rest of the system's interrupts which will always have an explict
*   int_clear() function. 
*
*   digi_otn_server_int_chnl_get() and digi_otn_odu_int_chnl_get() can be used
*   to retrieve a specific chnl table from the aggregation table.
*   
*
* INPUTS:
*  digi_handle      - Pointer to digi handle
*  int_filter_ptr   - Pointer to filter structure indicating which blocks
*                     to retrieve
*  yield_on_true    - Flag that relates to where this function is called
*                     from as to whether or not PMC_ATOMIC_YIELD is called
*                     between the various subsystem retrievals occurs.
*
* OUTPUTS:
*   int_table_ptr  - pointer to aggregation interrupt table to store interrupt
*                    information
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_int_filt_retrieve_internal(digi_handle_t           *digi_handle,
                                                      digi_otn_int_filter_t   *int_filter_ptr,
                                                      BOOL8 yield_on_true,
                                                      digi_otn_int_t          *int_table_ptr)
{
    PMC_ERROR  result = PMC_SUCCESS;

    PMC_ENTRY();
    
    /* Retrieve all LINE/SYS OTN status */
    result = digi_otn_server_int_filt_retrieve_internal(digi_handle,
                                                        int_filter_ptr,
                                                        yield_on_true,
                                                        int_table_ptr);

    /* Retrieve all OTN ODU status */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_filt_retrieve_internal(digi_handle,
                                                         int_filter_ptr,
                                                         yield_on_true,
                                                         int_table_ptr);

    }
    /* Retrieve OHP and RCP status */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_ohp_rcp_int_filt_retrieve(digi_handle,
                                                    int_filter_ptr,
                                                    yield_on_true,
                                                    int_table_ptr);
    }

    PMC_RETURN(result);
} /* digi_otn_int_filt_retrieve_internal */


/*******************************************************************************
* FUNCTION: digi_otn_int_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Clears interrupts based on bits that are set in the aggregated 
*  interrupt table.
*  Depending on the desired behaviour this function should be proceeded by
*  a call to digi_otn_odu_int_start and followed by a call to 
*  digi_otn_odu_int_end if the desire is to ensure that ODU RFRM interrupts
*  are cleared before calling the next operation. Each time interrupts are
*  latched, digi_otn_odu_int_start, the ODU RFRM are effectively cleared.
*  If the call to this function is proceeded by a 
*  digi_otn_int_filt_retrieve was used digi_otn_odu_int_start/end then the
*  ODU RFRM interrupts were cleared in that operation.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   int_table_ptr   - pointer to aggregated interrupt table with bits set to
*                     clear interrupts. DIGI_INT_ALL_INTS to clear all interrupts.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_int_clear(digi_handle_t       *digi_handle,
                                    digi_otn_int_t      *int_table_ptr)
{
    PMC_ERROR               result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    result = digi_otn_int_clear_internal(digi_handle,
                                         int_table_ptr);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_int_clear */



/*******************************************************************************
* FUNCTION: digi_otn_lineotn_int_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves LINEOTN related unchannelized interrupts to aggregated OTN
*   interrupt table   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*
* OUTPUTS:
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     clear interrupts.
*                     DIGI_INT_ALL_INTS to clear all interrupts.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_lineotn_int_clear(digi_handle_t       *digi_handle,
                                            lineotn_int_t       *int_table_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;
    digi_otn_int_t *int_en_table_ptr;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);


    /* Get internal enabled interrupt table to update */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);

    }

    if (PMC_SUCCESS == result)
    {
        result = lineotn_int_clear(digi_handle->lineotn_handle,
                                   int_table_ptr,
                                   &int_en_table_ptr->lineotn);

    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_lineotn_int_clear */



/*******************************************************************************
* FUNCTION: digi_otn_sysotn_int_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves SYSOTN related unchannelized interrupts to aggregated OTN
*   interrupt table   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*
* OUTPUTS:
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     clear interrupts.
*                     DIGI_INT_ALL_INTS to clear all interrupts.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_sysotn_int_clear(digi_handle_t       *digi_handle,
                                           lineotn_int_t       *int_table_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;
    digi_otn_int_t *int_en_table_ptr;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Get internal enabled interrupt table to update */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);

    }

    if (PMC_SUCCESS == result)
    {
        result = lineotn_int_clear(digi_handle->sysotn_handle,
                                   int_table_ptr,
                                   &int_en_table_ptr->sysotn);

    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_sysotn_int_clear */



/*******************************************************************************
* FUNCTION: digi_otn_server_int_chnl_filt_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves a channel interrupt table with interrupt bits for a specified
*   line or sysotn channel.
*
*   digi_otn_ddeg_int_start() must be used before calling this function to
*   retrieve the latest dDEG status.
*
*   The desired interrupt/status bits to retrieved (to reduce function execution
*   time) can be specified using the filter table input.
*
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to retrieve interrupts
*   filt_table_ptr  - pointer to filter table. Mark fields as TRUE within this
*                     table to indicate that the interrupt/status will be retrieved
*                     to the output table. DIGI_INT_ALL_INTS to retrieve all 
*                     interrupt/status.
*
* OUTPUTS:
*   int_table_ptr  - pointer to channel interrupt table to store interrupt
*                    information. 
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_int_chnl_filt_retrieve(digi_handle_t            *digi_handle,
                                                        digi_otn_server_chnl_t   *chnl_handle,
                                                        lineotn_int_chnl_t       *filt_table_ptr,
                                                        lineotn_int_chnl_t       *int_table_ptr)
{
    PMC_ERROR result;
 
    PMC_ATOMIC_ENTRY(digi_handle);

    result = digi_otn_server_int_chnl_filt_retrieve_internal(digi_handle, chnl_handle,
                                                             filt_table_ptr, int_table_ptr);

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_server_int_chnl_filt_retrieve */


/*******************************************************************************
* FUNCTION: digi_otn_server_int_chnl_filt_retrieve_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves a channel interrupt table with interrupt bits for a specified
*   line or sysotn channel.
*
*   The desired interrupt/status bits to retrieved (to reduce function execution
*   time) can be specified using the filter table input.
*
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to retrieve interrupts
*   filt_table_ptr  - pointer to filter table. Mark fields as TRUE within this
*                     table to indicate that the interrupt/status will be retrieved
*                     to the output table. DIGI_INT_ALL_INTS to retrieve all 
*                     interrupt/status.
*
* OUTPUTS:
*   int_table_ptr  - pointer to channel interrupt table to store interrupt
*                    information. 
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_chnl_filt_retrieve_internal(digi_handle_t            *digi_handle,
                                                                  digi_otn_server_chnl_t   *chnl_handle,
                                                                  lineotn_int_chnl_t       *filt_table_ptr,
                                                                  lineotn_int_chnl_t       *int_table_ptr)
{
    PMC_ERROR                    result;
    digi_otn_server_chnl_def_t  *chnl_ptr = (digi_otn_server_chnl_def_t *) chnl_handle;
    UINT32                       dsi_stream;
    lineotn_handle_t            *line_sys_handle;
    coreotn_int_source_t         source;
 
    PMC_ENTRY();

    result = digi_int_chnl_param_check(digi_handle, chnl_handle, DIGI_INT_CHNL_TYPE_OTN_SERVER, int_table_ptr); 

    PMC_MEMSET(int_table_ptr, 0, sizeof(lineotn_int_chnl_t));   

    if (DIGI_OTN_SERVER_IS_LINE(chnl_handle))
    {
        line_sys_handle = digi_handle->lineotn_handle;
        source           = COREOTN_INT_SOURCE_LINE;
    } 
    else
    {
        line_sys_handle = digi_handle->sysotn_handle;
        source          = COREOTN_INT_SOURCE_SYS;
    }
    
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == lineotn_start_state_test(line_sys_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

   
    if (PMC_SUCCESS == result)
    {
        dsi_stream = chnl_ptr->dsi_base_chnl;
        result = lineotn_int_chnl_retrieve(line_sys_handle,
                                           dsi_stream,
                                           filt_table_ptr,
                                           int_table_ptr);
    }

    if (PMC_SUCCESS == result)
   {
        result = digi_otn_server_int_ddeg_chnl_retrieve(digi_handle, 
                                                        dsi_stream,
                                                        source,
                                                        NULL, /* unused */
                                                        int_table_ptr);
    }

    PMC_RETURN(result);
} /* digi_otn_server_int_chnl_filt_retrieve_internal */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_start()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Start OTN ODU interrupt processing.
*
*   This function triggers the ODU_RFRM interrupts to be transfered to
*   shadow registers for retrieval by SW. Interrupts are automatically cleared
*   so interrupts for all ODU levels and all channels must be captured between
*   digi_otn_odu_int_start() and digi_otn_odu_int_end().
*
*   This function must be called before processing channelized ODU interrupts
*   with digi_otn_odu_int_chnl_enabled_check().
*
*   Example call sequence:
*       // Check aggregated OTN interrupts
*       digi_otn_int_enabled_check()
*
*       // Aggregated OTN callback called    
*       Aggregated CB:
*           // Trigger beginning of ODU interrupt processing 
*           digi_otn_odu_int_start()
*
*           // Retrieve ODU interrupt summaries to determine which chnls/ODUs to process
*           digi_otn_odu_int_summary_get()
*
*           // Check channelized OTN ODU interrupts
*           digi_otn_odu_int_chnl_enabled_check()
*
*           // Channelized OTN ODU callback called for all active chnls
*           Channelized CB:
*               // Retrieve a filtered list of active ints for given chnl
*               digi_otn_odu_int_chnl_filt_retrieve()
*
*           // End ODU interrupt processing
*           digi_otn_odu_int_end()
*
*
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   latch_defect    - latch defect mode. Rev A must use COREOTN_LATCH_DEFECT_ALL 
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_start(digi_handle_t           *digi_handle, 
                                        coreotn_latch_defect_t   latch_defect)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    if ((TRUE == pmc_is_digi_rev_a_revision(&digi_handle->base)) &&
        (COREOTN_LATCH_DEFECT_ALL != latch_defect))
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INT_REV_A_LATCH_ALL_ONLY);
    }

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }


    /* Clear active combined interrupts */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_int_start(digi_handle->coreotn_handle, latch_defect, TRUE, TRUE);
    }

    /* Trigger transfer of ODU_RFRM interrupts into shadow registers */
    /* The trigger will transfer interrupts for all ODU_RFRMs, so the following
     * and retrieve() functions will always operate on DIGI_INT_ALL_CHNLS.
     * If we trigger the transfer and only look at a single odu_level,
     * there is a possiblity of missed interrupts in the other RFRMs */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_trigger_transfer(digi_handle, latch_defect);
        
    }

    /*
     * Call coreotn_int_start again but this time do not clear them to
     * handle the case that something may have occurred while the transfer
     * was underway.
     */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_int_start(digi_handle->coreotn_handle, latch_defect, TRUE, FALSE);
    }


    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_odu_int_start */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_end()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Ends OTN ODU interrupt processing.
*    
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   latch_defect    - latch defect mode. Rev A must use COREOTN_LATCH_DEFECT_ALL 
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_end(digi_handle_t           *digi_handle,
                                      coreotn_latch_defect_t   latch_defect)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    if ((TRUE == pmc_is_digi_rev_a_revision(&digi_handle->base)) &&
        (COREOTN_LATCH_DEFECT_ALL != latch_defect))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INT_REV_A_LATCH_ALL_ONLY);
    }
    
    if (PMC_SUCCESS == result)
    {
        result = coreotn_int_start(digi_handle->coreotn_handle, latch_defect, FALSE, TRUE);
    }
    

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_odu_int_end */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_chnl_filt_retrieve_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves a channel interrupt table with interrupt bits for a specified
*   ODU channel and filter table specifying requested blocks.
*
*   The desired interrupt/status bits to retrieved (to reduce function execution
*   time) can be specified using the filter table input.
*
* INPUTS:
*   digi_handle           - pointer to DIGI handle instance.
*   chnl_handle           - pointer to channel handle to retrieve interrupts
*   int_filter_ptr        - Pointer to filter structure indicating which blocks
*                           to retrieve
*   filt_table_ptr        - pointer to filter table for ODU status.
*                           Mark fields as TRUE within this table to indicate that
*                           the interrupt/status will be retrieved
*                           to the output table. DIGI_INT_ALL_INTS to retrieve all 
*                           interrupt/status. Applies to stage3b as well.
*
* OUTPUTS:
*   int_table_ptr  - pointer to channel interrupt table to store interrupt
*                    information. 
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_chnl_filt_retrieve_internal(digi_handle_t              *digi_handle,
                                                               digi_otn_odu_chnl_t        *chnl_handle,
                                                               digi_otn_int_filter_t      *int_filter_ptr,
                                                               coreotn_int_chnl_t         *filt_table_ptr,
                                                               digi_otn_odu_int_chnl_t    *int_table_ptr)
{
    PMC_ERROR                   result;
    coreotn_int_chnl_info_t     chnl_info;
    odu_struct_odu_level_t      odu_level;
    UINT32                      chnl_id;
    odu_struct_t               *stg3b_handle_pool_ptr;
    coreotn_ddeg_mon_seg_t      ddeg_mon; 
 
    PMC_ENTRY();
    
    result = digi_int_chnl_param_check(digi_handle, chnl_handle, DIGI_INT_CHNL_TYPE_OTN_ODU, int_table_ptr); 

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }
    PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));
    /* determine from odu struct line or source */
    if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    { 
        chnl_info.source = COREOTN_INT_SOURCE_SYS; 
    }
    else
    {
        chnl_info.source = COREOTN_INT_SOURCE_LINE; 
    }
    
    odu_level = digi_otn_odu_level_internal_get(digi_handle, chnl_handle);
    
    if (ODU_STRUCT_LEVEL_4_ODU == odu_level)
    {
        ddeg_mon = COREOTN_DDEG_MON_CLIENT;
    }
    else
    {
        ddeg_mon = COREOTN_DDEG_MON_LINE;
    }

    /* Gather Pool IDs */
    if (PMC_SUCCESS == result)
    {
        (void)digi_otn_pool_id_get(digi_handle, chnl_handle, chnl_info.rx_pool_id); 
    }

    /* Retrieve coreotn interrupts */
    if (PMC_SUCCESS == result)
    {
        chnl_id              = digi_otn_odu_chnl_num_internal_get(digi_handle, chnl_handle);

        chnl_info.chnl_id    = chnl_id;
        chnl_info.odu_level  = odu_level;
        chnl_info.blk_filter = int_filter_ptr->blocks; 
    }

    /* Retrieve interrupts */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_int_chnl_retrieve(digi_handle->coreotn_handle, 
                                           &chnl_info,
                                           filt_table_ptr,
                                           &int_table_ptr->status);
    }

    /* Retrieve ddeg interrupts */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_ddeg_stage_chnl_retrieve(digi_handle,
                                                           chnl_handle,
                                                           ddeg_mon,
                                                           NULL, /* unused */
                                                           &int_table_ptr->status);
    }
   
    /* Retrieve Stg 3b if needed */
    if (PMC_SUCCESS == result &&
        TRUE == digi_otn_int_filt_is_otn_stg3b(int_filter_ptr) &&
        TRUE == digi_otn_is_stg3b_present(digi_handle, chnl_handle))
    {
        int_table_ptr->stg3b_valid = TRUE;
        chnl_info.odu_level = ODU_STRUCT_LEVEL_3B_ODU;

        /* Get the pool pointer for Stage 3b ODU level */
        result = digi_otn_odu_handle_pool_get(digi_handle, ODU_STRUCT_LEVEL_3B_ODU, &stg3b_handle_pool_ptr);
    
    
        /* Gather Pool IDs */
        if (PMC_SUCCESS == result)
        {
            (void)digi_otn_pool_id_get(digi_handle, &stg3b_handle_pool_ptr[chnl_id], chnl_info.rx_pool_id); 
        }

        /* Retrieve stg3b coreotn interrupts */
        if (PMC_SUCCESS == result)
        {
            result = coreotn_int_chnl_retrieve(digi_handle->coreotn_handle, 
                                               &chnl_info,
                                               filt_table_ptr,
                                               &int_table_ptr->stg3b);
        }
    }
    else if (PMC_SUCCESS == result && 
             TRUE == DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) &&
             TRUE == digi_otn_int_filt_is_otn_stg3b(int_filter_ptr) &&
             ODU_STRUCT_LEVEL_LO_ODU == ((odu_struct_t *)chnl_handle)->mem_ptr->odu_level)
    {
        odu_struct_t *sysotn_line_ptr;
        int_table_ptr->stg3b_valid = TRUE;
        chnl_info.odu_level = ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC;

        /* Get the TCM SYSOTN pointer. */
        result = digi_otn_odu_handle_pool_get(digi_handle, 
                                              chnl_info.odu_level,
                                              &sysotn_line_ptr);

        if (PMC_SUCCESS == result)
        {
            /*
             * Retrieve the pool ids for the TCM SYSOTN odu level.
             */
            (void)digi_otn_pool_id_get(digi_handle, 
                                       &sysotn_line_ptr[chnl_id],
                                       chnl_info.rx_pool_id); 
        }
        /* 
         * Retrieve stg2 (TCM SYSOTN) coreotn interrupts and store 
         * them in the stg3b handle.
         */
        if (PMC_SUCCESS == result)
        {
            result = coreotn_int_chnl_retrieve(digi_handle->coreotn_handle, 
                                               &chnl_info,
                                               filt_table_ptr,
                                               &int_table_ptr->stg3b);
        }
    }

    PMC_RETURN(result);
} /* digi_otn_odu_int_chnl_filt_retrieve_internal */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ohp_chnl_filt_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves OHP block channel interrupt table with interrupt bits for a specified
*   ODU channel.
*
*   The desired interrupt/status bits to retrieved (to reduce function execution
*   time) can be specified using the filter table input.
*
* INPUTS:
*   digi_handle           - pointer to DIGI handle instance.        
*   ohp                   - Specifies the OHP block 
*   chnl_handle           - pointer to channel handle to retrieve interrupts
*   ohp_filt_table_ptr    - pointer to filter table for OHP interrupt.
*                           Mark fields as TRUE within this table to indicate that
*                           the interrupt/status will be retrieved
*                           to the output table. DIGI_INT_ALL_INTS to retrieve all 
*                           interrupt/status.
*
* OUTPUTS:
*   int_table_ptr  - pointer to channel interrupt table to store interrupt
*                    information. 
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ohp_chnl_filt_retrieve(digi_handle_t              *digi_handle,
                                                         odu_ohp_inst_t              ohp,
                                                         digi_otn_odu_chnl_t        *chnl_handle,
                                                         odu_ohp_int_chnl_t         *ohp_filt_table_ptr,
                                                         odu_ohp_int_chnl_t         *int_table_ptr)
{
    PMC_ERROR                   result;
    coreotn_int_chnl_info_t     chnl_info;
    UINT32                      chnl_id;
 
    PMC_ATOMIC_ENTRY(digi_handle);
    
    result = digi_int_chnl_param_check(digi_handle, chnl_handle, DIGI_INT_CHNL_TYPE_OTN_ODU, int_table_ptr);

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }

    /* Retrieve OHP channelized interrupts */
    if (PMC_SUCCESS == result)
    {
        PMC_MEMSET(int_table_ptr, 0, sizeof(odu_ohp_int_chnl_t));   
        PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));        
        /* determine from odu struct line or source */
        if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
        { 
            chnl_info.source = COREOTN_INT_SOURCE_SYS; 
        }
        else
        {
            chnl_info.source = COREOTN_INT_SOURCE_LINE; 
        }

        chnl_id             = digi_otn_odu_chnl_num_internal_get(digi_handle, chnl_handle);
        chnl_info.chnl_id   = chnl_id;
        chnl_info.odu_level = digi_otn_odu_level_internal_get(digi_handle, chnl_handle);
        result = coreotn_int_ohp_chnl_retrieve(digi_handle->coreotn_handle, 
                                               ohp,
                                               &chnl_info,
                                               ohp_filt_table_ptr,
                                               int_table_ptr);
    }
    
    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_odu_int_ohp_chnl_filt_retrieve */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ri_rcp_chnl_filt_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves RI RCP block channel interrupt table with interrupt bits for a specified
*   ODU channel.
*
*   The desired interrupt/status bits to retrieved (to reduce function execution
*   time) can be specified using the filter table input.
*
* INPUTS:
*   digi_handle               - pointer to DIGI handle instance.   
*   chnl_handle               - pointer to channel handle to retrieve interrupts
*   ri_rcp_filt_table_ptr     - pointer to filter table for RI RCP interrupt.
*                               Mark fields as TRUE within this table to indicate that
*                               the interrupt/status will be retrieved
*                               to the output table. DIGI_INT_ALL_INTS to retrieve all 
*                               interrupt/status.
*
* OUTPUTS:
*   int_table_ptr  - pointer to channel interrupt table to store interrupt
*                    information. 
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ri_rcp_chnl_filt_retrieve(digi_handle_t              *digi_handle,
                                                            digi_otn_odu_chnl_t        *chnl_handle,
                                                            odu_ri_rcp_int_chnl_t      *ri_rcp_filt_table_ptr,
                                                            odu_ri_rcp_int_chnl_t      *int_table_ptr)
{
    PMC_ERROR                   result;
    coreotn_int_chnl_info_t     chnl_info;
    UINT32                      chnl_id;
 
    PMC_ATOMIC_ENTRY(digi_handle);
    
    result = digi_int_chnl_param_check(digi_handle, chnl_handle, DIGI_INT_CHNL_TYPE_OTN_ODU, int_table_ptr); 

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }


    /* Retrieve RI RCP channelized interrupts */
    if (PMC_SUCCESS == result)
    {
        PMC_MEMSET(int_table_ptr, 0, sizeof(odu_ri_rcp_int_chnl_t));   
        PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));        
        /* determine from odu struct line or source */
        if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
        { 
            chnl_info.source = COREOTN_INT_SOURCE_SYS; 
        }
        else
        {
            chnl_info.source = COREOTN_INT_SOURCE_LINE; 
        }

        chnl_id             = digi_otn_odu_chnl_num_internal_get(digi_handle, chnl_handle);
        chnl_info.chnl_id   = chnl_id;
        chnl_info.odu_level = digi_otn_odu_level_internal_get(digi_handle, chnl_handle);
        result = coreotn_int_ri_rcp_chnl_retrieve(digi_handle->coreotn_handle, 
                                                  &chnl_info,
                                                  ri_rcp_filt_table_ptr,
                                                  int_table_ptr);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_ri_rcp_chnl_filt_retrieve */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_pm_summary_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves summary of OTN ODU PM interrupts.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_info_ptr   - structure descrbing the channel: chnl id, odu level
*                     lineotn/sysotn
*   summary_mask    - Bit mask of bits from digi_otn_odu_int_summary_mask_t
*                     to indicate what summary information to retrieve.
*
* OUTPUTS:
*   int_summary_ptr - Pointer to interrupt summary structure
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_pm_summary_get(digi_handle_t                 *digi_handle,
                                                  coreotn_int_chnl_info_t       *chnl_info_ptr,
                                                  UINT32                         summary_mask,
                                                  digi_otn_odu_int_summary_t    *int_summary_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle     != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_info_ptr   != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_summary_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    
    /* Retrieve bitmask of active channels from HW */
    if ((PMC_SUCCESS == result) && 
        ((DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL & summary_mask) || /* Active chnl list requires chnl bitmask */
         (DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL_BITMASK & summary_mask) ||
         (DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL_POPCOUNT & summary_mask))) /* Active chnl popcount requires chnl bitmask */
    {
        int_summary_ptr->mask |= DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL_BITMASK;

        result = coreotn_int_summary_get(digi_handle->coreotn_handle,
                                         chnl_info_ptr,
                                         ODU_RFRM_INT_SUMMARY_TYPE_ACTIVE_PM,
                                         int_summary_ptr->active_chnl_bitmask);
    }


    /* Get a population count of active channels */
    if ((PMC_SUCCESS == result) && 
        (DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL_POPCOUNT & summary_mask))
    {
        int_summary_ptr->mask |= DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL_POPCOUNT;
        int_summary_ptr->active_chnl_popcount = pmc_bitarray_pop_count(int_summary_ptr->active_chnl_bitmask, DIGI_ODU_CHNLS_MAX);
    }


    /* Find channel handles for active channels */
    if ((PMC_SUCCESS == result) && 
        (DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL & summary_mask))
    {
        /* Get active channels for this odu level */
        result = digi_otn_odu_int_active_chnl_get(digi_handle,
                                                  chnl_info_ptr->odu_level,
                                                  TRUE,
                                                  int_summary_ptr);
    }

    PMC_RETURN(result);
} /* digi_otn_odu_int_pm_summary_get */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_pid_summary_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves summary of OTN ODU PID interrupts.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_info_ptr   - structure descrbing the channel: chnl id, odu level
*                     lineotn/sysotn
*   summary_mask    - Bit mask of bits from digi_otn_odu_int_summary_mask_t
*                     to indicate what summary information to retrieve.
*
* OUTPUTS:
*   int_summary_ptr - Pointer to interrupt summary structure
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_pid_summary_get(digi_handle_t                 *digi_handle,
                                                   coreotn_int_chnl_info_t       *chnl_info_ptr,
                                                   UINT32                         summary_mask,
                                                   digi_otn_odu_int_summary_t    *int_summary_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle     != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_info_ptr   != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_summary_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    
    /* Retrieve bitmask of active PID TCMs from HW */
    if ((PMC_SUCCESS == result) && 
        ((DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL & summary_mask) || /* Active chnl list requires PID bitmask */
         (DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_PID_BITMASK & summary_mask) ||
         (DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_PID_POPCOUNT & summary_mask))) /* Active PID popcount requires PID bitmask */
    {
        int_summary_ptr->mask |= DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_PID_BITMASK;

        result = coreotn_int_summary_get(digi_handle->coreotn_handle,
                                         chnl_info_ptr,
                                         ODU_RFRM_INT_SUMMARY_TYPE_ACTIVE_PID,
                                         int_summary_ptr->active_pid_bitmask);
    }


    /* Get a population count of active PIDs */
    if ((PMC_SUCCESS == result) && 
        (DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_PID_POPCOUNT & summary_mask))
    {
        int_summary_ptr->mask |= DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_PID_POPCOUNT;
        int_summary_ptr->active_pid_popcount = pmc_bitarray_pop_count(int_summary_ptr->active_pid_bitmask, DIGI_ODU_PIDS_MAX);
    }

    PMC_RETURN(result);
} /* digi_otn_odu_int_pid_summary_get */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_comb_summary_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves summary of OTN ODU combined interrupts.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_info_ptr   - structure descrbing the channel: chnl id, odu level
*                     lineotn/sysotn
*   summary_mask    - Bit mask of bits from digi_otn_odu_int_summary_mask_t
*                     to indicate what summary information to retrieve.
*
* OUTPUTS:
*   int_summary_ptr - Pointer to interrupt summary structure
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_comb_summary_get(digi_handle_t                 *digi_handle,
                                                    coreotn_int_chnl_info_t       *chnl_info_ptr,
                                                    UINT32                         summary_mask,
                                                    digi_otn_odu_int_summary_t    *int_summary_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle     != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_info_ptr   != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_summary_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    
    /* Retrieve bitmask of active interrupts from HW */
    if ((PMC_SUCCESS == result) && 
        ((DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL & summary_mask) || /* Active chnl list requires int bitmask */
         (DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_INT_BITMASK & summary_mask) ||
         (DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_INT_POPCOUNT & summary_mask))) /* Active int popcount requires int bitmask */
    {
        int_summary_ptr->mask |= DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_INT_BITMASK;

        result = coreotn_int_summary_get(digi_handle->coreotn_handle,
                                         chnl_info_ptr,
                                         ODU_RFRM_INT_SUMMARY_TYPE_ACTIVE_INT,
                                         int_summary_ptr->active_int_bitmask);
    }


    /* Get a population count of active interrupts */
    if ((PMC_SUCCESS == result) && 
        (DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_INT_POPCOUNT & summary_mask))
    {
        int_summary_ptr->mask |= DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_INT_POPCOUNT;
        int_summary_ptr->active_int_popcount = pmc_bitarray_pop_count(int_summary_ptr->active_int_bitmask, LAST_ODU_RFRM_INT_DEFECT);
    }



    PMC_RETURN(result);
} /* digi_otn_odu_int_comb_summary_get */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_enabled_check_summary_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the interrupt summary information required for enabled_check
*   (if required).
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_level       - Indicates whether to check interrupts on HO/MO/LO
*
* OUTPUTS:
*   int_summary_ptr - Pointer to interrupt summary structure
*   
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_enabled_check_summary_get(digi_handle_t              *digi_handle,
                                                            odu_struct_odu_level_t      odu_level,
                                                            digi_otn_odu_int_summary_t *int_summary_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    coreotn_int_chnl_info_t     chnl_info;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle     != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_summary_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));
    chnl_info.odu_level = odu_level;
    
    /* Setup coreotn channel info */
    if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    { 
        chnl_info.source = COREOTN_INT_SOURCE_SYS; 
    }
    else
    {
        chnl_info.source = COREOTN_INT_SOURCE_LINE; 
    }


    /* enable interrupt caching, clear cache */
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, TRUE, TRUE);

    /* Retrieve PM active chnl bitmasks if they are not been available */
    if ((PMC_SUCCESS == result) &&
        (FALSE == (DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL_BITMASK & int_summary_ptr->mask)))
    {
        result = digi_otn_odu_int_pm_summary_get(digi_handle,
                                                 &chnl_info,
                                                 DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL_BITMASK,
                                                 int_summary_ptr);
    }
    
    /* Retrieve PID active chnl bitmasks if they are not been available */
    if ((PMC_SUCCESS == result) &&
        (FALSE == (DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_PID_BITMASK & int_summary_ptr->mask)))
    {
        result = digi_otn_odu_int_pid_summary_get(digi_handle,
                                                  &chnl_info,
                                                  DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_PID_BITMASK,
                                                  int_summary_ptr);
    }
    
    
    /* Retrieve active int bitmasks if they are not been available */
    if ((PMC_SUCCESS == result) &&
        (FALSE == (DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_INT_BITMASK & int_summary_ptr->mask)))
    {
        result = digi_otn_odu_int_comb_summary_get(digi_handle,
                                                   &chnl_info,
                                                   DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_INT_BITMASK,
                                                   int_summary_ptr);
    }

    /* disable interrupt caching */
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, FALSE, FALSE);


    PMC_RETURN(result);
} /* digi_otn_odu_int_enabled_check_summary_get */




/*******************************************************************************
* FUNCTION: digi_otn_odu_int_active_chnl_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves array of active channels based on active enabled PM and PID interrupts
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_level       - ODU level (HO/MO/LO)
*   pack_chnls      - TRUE to pack chnls sequentially in the summary table
*                     FALSE to place chnls in their corresponding indices in the table
*
* OUTPUTS:
*   int_summary_ptr - pointer to OTN ODU interrupt summary information
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_active_chnl_get(digi_handle_t                *digi_handle,
                                                  odu_struct_odu_level_t        odu_level,
                                                  BOOL                          pack_chnls,
                                                  digi_otn_odu_int_summary_t   *int_summary_ptr)
{
    PMC_ERROR               result = PMC_SUCCESS;
    UINT32                  summary_mask;
    coreotn_int_chnl_info_t chnl_info;
    UINT32                  start_chnl = 0;
    UINT32                  end_chnl = 0;
    UINT32                  i, j;
    BOOL                    int_found;
    odu_struct_t           *handle_pool_ptr;
    digi_otn_odu_chnl_t    *chnl_handle;

    PMC_ENTRY();
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_summary_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }
    PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));
    summary_mask        = int_summary_ptr->mask;
    chnl_info.odu_level = odu_level;
    
    /* Setup coreotn channel info */
    if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    { 
        chnl_info.source = COREOTN_INT_SOURCE_SYS; 
    }
    else
    {
        chnl_info.source = COREOTN_INT_SOURCE_LINE; 
    }




    /* Retrieve missing summary information if needed */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_enabled_check_summary_get(digi_handle,
                                                            odu_level,
                                                            int_summary_ptr);
    }


    /* Get the pool pointer for ODU level */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_handle_pool_get(digi_handle, odu_level, &handle_pool_ptr);
    }



    /* Retrieve active channels if they are not available */
    if ((PMC_SUCCESS == result) &&
        (FALSE == (DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL & summary_mask)))
    {
        /* Get range of channels to retrieve within ODU level */
        result = digi_otn_odu_int_link_range_get(digi_handle,
                                                 DIGI_INT_ALL_CHNLS,
                                                 odu_level,
                                                 &start_chnl,
                                                 &end_chnl);


        /* enable interrupt caching, clear cache */
        pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, TRUE, TRUE);

        /* For each chnl in handle_pool, check for active enabled ints */
        j = 0;
        for (i = start_chnl; (i < end_chnl) && (PMC_SUCCESS == result); i++)
        {
            int_found = FALSE;
            chnl_handle = &handle_pool_ptr[i];
    
            
            result = digi_otn_odu_int_chnl_stage_enabled_check(digi_handle,
                                                               chnl_handle,
                                                               odu_level,
                                                               int_summary_ptr,
                                                               &int_found);

            /* if int_found, then add chnl to active_chnl list */
            if ((PMC_SUCCESS == result) && (TRUE == int_found))
            {
                if (TRUE == pack_chnls)
                {
                    /* Store active chnls sequentially */
                    int_summary_ptr->active_chnl[j] = chnl_handle;
                }
                else
                {
                    /* Store active chnls by index */
                    int_summary_ptr->active_chnl[i] = chnl_handle;
                }
               
                /* Count active chnls */
                j++;
            }
        }

        /* disable interrupt caching */
        pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, FALSE, FALSE);

        int_summary_ptr->active_chnl_num = j;

        int_summary_ptr->mask |= DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL_NUM |
                                 DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL;
    }


    PMC_RETURN(result);
} /* digi_otn_odu_int_active_chnl_get */



/*******************************************************************************
* FUNCTION: digi_otn_server_int_summary_get_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves summary of OTN server interrupts for a given ODU level.  
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   int_type        - Line or sysotn
*   unused          - Unused
*
* OUTPUTS:
*   int_summary_ptr - Pointer to interrupt summary structure
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_summary_get_internal(digi_handle_t                   *digi_handle,
                                                           digi_int_type_t                  int_type,
                                                           UINT32                           unused,
                                                           digi_otn_server_int_summary_t   *int_summary_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;
    UINT32                       start_link = 0;
    UINT32                       end_link = 0;
    digi_otn_int_t              *int_en_table_ptr;
    UINT32                       i, j;
    digi_otn_server_chnl_def_t  *handle_pool_ptr;
    BOOL                         int_found;
    lineotn_handle_t            *lineotn_handle;

    PMC_ENTRY();

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != int_summary_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);

    if (PMC_SUCCESS == result)
    {
        switch (int_type)
        {
          case DIGI_INT_CHNL_TYPE_OTN_SERVER:
            handle_pool_ptr  = digi_handle->handle_pool.otn_server_chnl;
            lineotn_handle   = digi_handle->lineotn_handle;
            break;
            
          case DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS:
            handle_pool_ptr  = &digi_handle->handle_pool.sysotn_server_chnl;
            lineotn_handle   = digi_handle->sysotn_handle;
            break;
        
          default:
            PMC_ASSERT(NULL, DIGI_ERR_INVALID_ARG, 0, 0);
            break;
        } /* end switch */
    }

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == lineotn_start_state_test(lineotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    
    /* Get internal enabled aggregate interrupt table to update */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);

    }


    /* Get range of handles */ 
    if (PMC_SUCCESS == result)
    {
        result = digi_int_link_range_get(digi_handle,
                                         DIGI_INT_ALL_CHNLS,
                                         int_type,
                                         &start_link,
                                         &end_link);
    }


    /* enable interrupt caching, clear cache */
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, TRUE, TRUE);

    /* Find channels with active interrupts */
    j = 0;
    for (i = start_link; (i < end_link) && (PMC_SUCCESS == result); i++)
    {
        int_found = FALSE;

        result = digi_otn_server_int_enabled_check_internal(digi_handle,
                                                            int_type,
                                                            &handle_pool_ptr[i],
                                                            int_en_table_ptr,
                                                            &int_found);


        if ((TRUE == int_found) && (PMC_SUCCESS == result))
        {
            int_summary_ptr->active_chnl[j] = &handle_pool_ptr[i];
            j++;
        }
    }

    /* disable interrupt caching */
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, FALSE, FALSE);

    int_summary_ptr->active_chnl_num = j;

    int_summary_ptr->mask = DIGI_OTN_SERVER_INT_SUMMARY_MASK_ACTIVE_CHNL_NUM |
                            DIGI_OTN_SERVER_INT_SUMMARY_MASK_ACTIVE_CHNL;


    PMC_RETURN(result);
} /* digi_otn_server_int_summary_get_internal */




/*******************************************************************************
* FUNCTION: digi_otn_server_int_summary_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves summary of OTN server interrupts for a given ODU level.  
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   otn_server_type - Numeric value representing the server type to 
*                     retrieve. The valid values are: 
*                     DIGI_INT_CHNL_TYPE_OTN_SERVER or
*                     DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS.  Function defaults
*                     to DIGI_INT_CHNL_TYPE_OTN_SERVER.  If the value maps
*                     to DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS then that value
*                     is used.
*
* OUTPUTS:
*   int_summary_ptr - Pointer to interrupt summary structure
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_int_summary_get(digi_handle_t *digi_handle,
                                                 UINT32 otn_server_type,
                                                 digi_otn_server_int_summary_t *int_summary_ptr)
{
    PMC_ERROR   result;
    digi_int_type_t int_type = DIGI_INT_CHNL_TYPE_OTN_SERVER;

    PMC_ATOMIC_ENTRY(digi_handle);

    if (DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS == (digi_int_type_t)otn_server_type)
    {
        int_type = DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS;
    }
    
    result = digi_otn_server_int_summary_get_internal(digi_handle,
                                                      int_type,
                                                      0,
                                                      int_summary_ptr);
    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_server_int_summary_get */




/*******************************************************************************
* FUNCTION: digi_otn_odu_int_summary_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves summary of OTN ODU interrupts for a given ODU level.  
*
*   digi_otn_odu_int_start(COREOTN_LATCH_DEFECT_ODUKP),
*   digi_otn_odu_int_start(COREOTN_LATCH_DEFECT_STG4), or
*   digi_otn_odu_int_start(COREOTN_LATCH_DEFECT_ALL), or
*   needs to be called before retrieving the summary to trigger RFRM
*   status transfer.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_level       - ODU level to retrieve interrupt summary on (HO/MO/LO)
*   summary_mask    - Bit mask of bits from digi_otn_odu_int_summary_mask_t
*                     to indicate what summary information to retrieve.
*
* OUTPUTS:
*   int_summary_ptr - Pointer to interrupt summary structure
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_summary_get(digi_handle_t                 *digi_handle,
                                              odu_struct_odu_level_t         odu_level,
                                              UINT32                         summary_mask,
                                              digi_otn_odu_int_summary_t    *int_summary_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    coreotn_int_chnl_info_t     chnl_info;

    PMC_ATOMIC_ENTRY(digi_handle);
    

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    if (NULL == int_summary_ptr)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_NULL_HANDLE);
    }
    
    if (odu_level >= LAST_ODU_STRUCT_LEVEL)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }


    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }
    PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));
    /* Setup coreotn channel info */
    if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    { 
        chnl_info.source = COREOTN_INT_SOURCE_SYS; 
    }
    else
    {
        chnl_info.source = COREOTN_INT_SOURCE_LINE; 
    }

    chnl_info.odu_level = odu_level;

    PMC_MEMSET(int_summary_ptr, 0, sizeof(*int_summary_ptr));


    /* If active channel number is requested, request active_chnls as well */
    if (DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL_NUM & summary_mask)
    {
        summary_mask |= DIGI_OTN_ODU_INT_SUMMARY_MASK_ACTIVE_CHNL;
    }



    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_pid_summary_get(digi_handle,
                                                  &chnl_info,
                                                  summary_mask,
                                                  int_summary_ptr);
    }
   

    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_comb_summary_get(digi_handle,
                                                   &chnl_info,
                                                   summary_mask,
                                                   int_summary_ptr);
    }


    /* This must be last in the event that the user requests the active chnl_handles.
     * To retrieve active chnl handles, the pid bitmask and int bitmask must be first
     * retrieved in the previous two calls */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_pm_summary_get(digi_handle,
                                                 &chnl_info,
                                                 summary_mask,
                                                 int_summary_ptr);
    }
    
    
    if (PMC_SUCCESS == result)
    {
        int_summary_ptr->mask     |= DIGI_OTN_ODU_INT_SUMMARY_MASK_ODU_LEVEL;
        int_summary_ptr->odu_level = odu_level;    
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_summary_get */


/*******************************************************************************
* FUNCTION: digi_otn_server_int_chnl_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Given a channel handle and an aggregated interrupt table, retrieve a pointer
*   to the corresponding LINEOTN channel interrupt table.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to retrieve interrupt on
*   int_table_ptr   - Aggregated interrupt table
*
* OUTPUTS:
*   int_chnl_table_pptr  - pointer to channel interrupt table corresponding to channel
*                          handle. Set to NULL if channel has not been provisioned.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_int_chnl_get(digi_handle_t                *digi_handle,
                                              digi_otn_server_chnl_t       *chnl_handle,
                                              digi_otn_int_t               *int_table_ptr,
                                              lineotn_int_chnl_t          **int_chnl_table_pptr)
{
    PMC_ERROR       result = PMC_SUCCESS;
    UINT32          index;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != chnl_handle, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != int_table_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != int_chnl_table_pptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* Set return table to NULL */
    *int_chnl_table_pptr = NULL;

    /* Get index corresponding to handle */
    index = digi_lineotn_dci_chnl_get(digi_handle, chnl_handle);

    /* Set return table to channel table */
    if (int_table_ptr->otn_server_handle[index] == chnl_handle)
    {
        *int_chnl_table_pptr = &int_table_ptr->otn_server_chnl[index];
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_server_int_chnl_get */

/*******************************************************************************
* FUNCTION: digi_sysotn_server_int_chnl_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Given a channel handle and an aggregated interrupt table, retrieve a pointer
*   to the corresponding SYSOTN channel interrupt table.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to retrieve interrupt on
*   int_table_ptr   - Aggregated interrupt table
*
* OUTPUTS:
*   int_chnl_table_pptr  - pointer to channel interrupt table corresponding to channel
*                          handle. Set to NULL if channel has not been provisioned.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_sysotn_server_int_chnl_get(digi_handle_t                *digi_handle,
                                                 digi_otn_server_chnl_t       *chnl_handle,
                                                 digi_otn_int_t               *int_table_ptr,
                                                 lineotn_int_chnl_t          **int_chnl_table_pptr)
{
    PMC_ERROR       result = PMC_SUCCESS;
    UINT32          index;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != chnl_handle, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != int_table_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != int_chnl_table_pptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* Set return table to NULL */
    *int_chnl_table_pptr = NULL;

    /* Get index corresponding to handle */
    index = digi_lineotn_dci_chnl_get(digi_handle, chnl_handle);

    /* Set return table to channel table */
    if (int_table_ptr->sysotn_server_handle[index] == chnl_handle)
    {
        *int_chnl_table_pptr = &int_table_ptr->sysotn_server_chnl[index];
    }

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_sysotn_server_int_chnl_get */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_chnl_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Given a channel handle and an aggregated interrupt table, retrieve a pointer
*   to the corresponding channel interrupt table.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to retrieve interrupt on
*   int_table_ptr   - Aggregated interrupt table
*
* OUTPUTS:
*   int_chnl_table_pptr  - pointer to channel interrupt table corresponding to channel
*                          handle. Set to NULL if channel has not been provisioned.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_chnl_get(digi_handle_t                *digi_handle,
                                           digi_otn_odu_chnl_t          *chnl_handle,
                                           digi_otn_int_t               *int_table_ptr,
                                           digi_otn_odu_int_chnl_t     **int_chnl_table_pptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;
    UINT32                       index;
    odu_struct_odu_level_t       odu_level;
    digi_otn_odu_chnl_t        **table_handle[ODU_STRUCT_LEVEL_3B_ODU];
    digi_otn_odu_int_chnl_t     *table_int[ODU_STRUCT_LEVEL_3B_ODU];

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != chnl_handle, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != int_table_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != int_chnl_table_pptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* Set up table with pointers to each odu level within the aggregated int table */
    table_handle[ODU_STRUCT_LEVEL_HO_ODU] = int_table_ptr->otn_odu_ho_handle;
    table_handle[ODU_STRUCT_LEVEL_MO_ODU] = int_table_ptr->otn_odu_mo_handle;
    table_handle[ODU_STRUCT_LEVEL_LO_ODU] = int_table_ptr->otn_odu_lo_handle;
    table_int[ODU_STRUCT_LEVEL_HO_ODU]    = int_table_ptr->otn_odu_ho_chnl;
    table_int[ODU_STRUCT_LEVEL_MO_ODU]    = int_table_ptr->otn_odu_mo_chnl;
    table_int[ODU_STRUCT_LEVEL_LO_ODU]    = int_table_ptr->otn_odu_lo_chnl;

    /* Set return table to NULL */
    *int_chnl_table_pptr = NULL;

    /* Get index corresponding to handle */
    index = digi_otn_odu_chnl_num_internal_get(digi_handle, chnl_handle);

    /* Get ODU level */
    odu_level = digi_otn_odu_level_internal_get(digi_handle, chnl_handle);
    PMC_ASSERT(odu_level < ODU_STRUCT_LEVEL_3B_ODU, DIGI_ERR_INVALID_ARG, odu_level, ODU_STRUCT_LEVEL_3B_ODU);

    /* Set return table to channel table */
    if (table_handle[odu_level][index] == chnl_handle)
    {
        *int_chnl_table_pptr = &table_int[odu_level][index];
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_chnl_get */

/*******************************************************************************
* FUNCTION: digi_otn_server_int_chnl_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves an aggregation interrupt table with interrupt bits
*   over multiple channels.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_type        - Interrupt type (LINEOTN or SYSOTN)
*
* OUTPUTS:
*   int_table_ptr  - pointer to aggregation interrupt table to store interrupt
*                    information
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_chnl_retrieve(digi_handle_t            *digi_handle,
                                                    digi_int_type_t           int_type,
                                                    digi_otn_int_t           *int_table_ptr)
{
    PMC_ERROR                        result = PMC_SUCCESS;

    lineotn_handle_t                *lineotn_handle;
    UINT32                           start_link = 0;
    UINT32                           end_link = 0;
    UINT32                           i;
    digi_otn_server_chnl_def_t      *handle_pool_ptr;
    digi_otn_server_chnl_t          *chnl_ptr;
    digi_otn_server_chnl_t         **otn_handle_ptr;
    lineotn_int_chnl_t              *otn_table_ptr;
    UINT32                           dsi_stream;
    
    PMC_ENTRY();

    result = digi_int_param_check(digi_handle, DIGI_INT_ALL_CHNLS, int_type, int_table_ptr); 

    if (PMC_SUCCESS == result)
    {
        switch (int_type)
        {
          case DIGI_INT_CHNL_TYPE_OTN_SERVER:
            lineotn_handle   = digi_handle->lineotn_handle;
            handle_pool_ptr  = digi_handle->handle_pool.otn_server_chnl;
            otn_handle_ptr   = int_table_ptr->otn_server_handle;
            otn_table_ptr    = int_table_ptr->otn_server_chnl;
            break;
            
          case DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS:
            lineotn_handle   = digi_handle->sysotn_handle;
            handle_pool_ptr  = &digi_handle->handle_pool.sysotn_server_chnl;
            otn_handle_ptr   = int_table_ptr->sysotn_server_handle;
            otn_table_ptr    = int_table_ptr->sysotn_server_chnl;
            break;
        
          default:
            PMC_ASSERT(NULL, DIGI_ERR_INVALID_ARG, 0, 0);
            break;
        } /* end switch */
    }
    
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == lineotn_start_state_test(lineotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Determine if are modfiying one channel or all channels */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_link_range_get(digi_handle,
                                         NULL,
                                         int_type,
                                         &start_link,
                                         &end_link);
    }

    for (i = start_link; (i < end_link) && (PMC_SUCCESS == result); i++)
    {
        PMC_MEMSET(&otn_table_ptr[i], 0, sizeof(lineotn_int_chnl_t));
        otn_handle_ptr[i] = NULL;

        chnl_ptr   = &handle_pool_ptr[i];
        dsi_stream = handle_pool_ptr[i].dsi_base_chnl;

        if (util_global_is_chnl_prov(chnl_ptr))
        {
            otn_handle_ptr[i] = chnl_ptr; 
            result = lineotn_int_chnl_retrieve(lineotn_handle, 
                                               dsi_stream,
                                               DIGI_INT_ALL_INTS,
                                               &otn_table_ptr[i]);
        }
    }

    PMC_RETURN(result);
} /* digi_otn_server_int_chnl_retrieve */




/*******************************************************************************
* FUNCTION: digi_otn_odu_int_chnl_stage_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieve interrupts in the specified HO/MO/LO stage.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to retrieve interrupts
*   odu_level       - Indicates whether to retrieve interrupts on HO/MO/LO
*   int_filter_ptr  - Pointer to filter structure indicating which blocks
*                     to retrieve
*
* OUTPUTS:
*   int_table_ptr   - pointer to channel interrupt table to return status 
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_chnl_stage_retrieve(digi_handle_t             *digi_handle,
                                                       digi_otn_odu_chnl_t       *chnl_handle,
                                                       odu_struct_odu_level_t     odu_level,
                                                       digi_otn_int_filter_t     *int_filter_ptr,
                                                       digi_otn_int_t            *int_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    digi_int_type_t             int_type = DIGI_INT_CHNL_TYPE_OTN_ODU;

    UINT32                      start_chnl = 0;
    UINT32                      end_chnl = 0;
    UINT32                      i;
    digi_otn_odu_chnl_t       **odu_handle_pptr;
    odu_struct_t               *handle_pool_ptr;
    digi_otn_odu_int_chnl_t    *odu_ptr;
    odu_ohp_inst_t              ohp;
    
    
    PMC_ENTRY();

    result = digi_int_param_check(digi_handle, chnl_handle, int_type, int_table_ptr); 

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }


    if (PMC_SUCCESS == result)
    {
        /* Get range of channels to retrieve within ODU level */
        result = digi_otn_odu_int_link_range_get(digi_handle,
                                                 chnl_handle,
                                                 odu_level,
                                                 &start_chnl,
                                                 &end_chnl);
    }

    /* Get the pool pointer for ODU level */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_handle_pool_get(digi_handle, odu_level, &handle_pool_ptr);
    }
    
    /* Get the odu interrupt table for output */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_odu_get(digi_handle,
                                          odu_level,
                                          int_table_ptr,
                                          &odu_handle_pptr,
                                          &odu_ptr);
    }

    
    for (i = start_chnl; (i < end_chnl) && (PMC_SUCCESS == result); i++)
    {
        if (util_global_is_chnl_prov(&handle_pool_ptr[i]))
        {
            odu_handle_pptr[i] = (digi_otn_odu_chnl_t *) &handle_pool_ptr[i];
            result = digi_otn_odu_int_chnl_filt_retrieve_internal(digi_handle,
                                                                  &handle_pool_ptr[i],
                                                                  int_filter_ptr,    /* Block filter table */
                                                                  DIGI_INT_ALL_INTS, /* ODU filter table */
                                                                  &odu_ptr[i]);


            /* Retrieve ODU OHP channelized interrupts */
            /* try for OHP1, OHP2, OHP3 */
            if (TRUE == digi_otn_int_filt_is_ohp(int_filter_ptr))
            {
                for (ohp = ODU_OHP_1; ohp < ODU_OHP_LAST && PMC_SUCCESS == result; ohp = (odu_ohp_inst_t)((UINT32)ohp + 1))
                {
                    /* ignore returned error code because channel could not be mapped to OHP */
                    result = digi_otn_odu_int_ohp_chnl_filt_retrieve(digi_handle,
                                                                  ohp,
                                                                  &handle_pool_ptr[i],
                                                                  DIGI_INT_ALL_INTS,
                                                                  &odu_ptr[i].status.ohp_chnl[(UINT32)ohp]);
                }
            }

            /* Get the ri_rcp interrupt table for output */
            if (PMC_SUCCESS == result &&
                TRUE == digi_otn_int_filt_is_rcp(int_filter_ptr))
            {
                result = digi_otn_odu_int_ri_rcp_chnl_filt_retrieve(digi_handle,
                                                                    &handle_pool_ptr[i],
                                                                    DIGI_INT_ALL_INTS,
                                                                    &odu_ptr[i].status.ri_rcp_chnl); 
            }
        }
    }
    

    PMC_RETURN(result);
} /* digi_otn_odu_int_chnl_stage_retrieve */


/*******************************************************************************
* digi_otn_odu_ddeg_mode_internal_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API retrieves the current dDEG reporting mode.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance.
*    ddeg_mode      - See digi_otn_ddeg_mode_t.       
*                          
* OUTPUTS:                     
*   *ddeg_configured   - when TRUE DDEG is configured, otherwise it is disabled.
*   *mon_seg           - enum for monitoring segment if ENHANCED_DDEG is configured. 
*                        See digi_otn_ddeg_mon_seg_t. This doesn't apply to 
*                        DIGI_OTN_HARDWARE_DDEG.
*   
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_ddeg_mode_internal_get(digi_handle_t           *digi_handle,
                                                      digi_otn_ddeg_mode_t     ddeg_mode,
                                                      BOOL                    *ddeg_configured,
                                                      digi_otn_ddeg_mon_seg_t *mon_seg)
{
    PMC_ERROR result = PMC_SUCCESS;
    coreotn_ddeg_mon_seg_t coreotn_mon_seg;    
    BOOL8 configured;
    
    PMC_ENTRY();
    
    /* retreive the ddeg_mode */
    result = coreotn_ddeg_mode_get(digi_handle->coreotn_handle, (coreotn_ddeg_mode_t)ddeg_mode, (BOOL8 *)&configured);    
    
    if (PMC_SUCCESS == result && TRUE == configured)
    {
        result = coreotn_ddeg_mon_segment_get(digi_handle->coreotn_handle,
                                              &coreotn_mon_seg);
        *mon_seg = (digi_otn_ddeg_mon_seg_t)coreotn_mon_seg;                                              
    }                                              
    
    *ddeg_configured = configured;
    PMC_RETURN(result);
       
}/*digi_otn_odu_ddeg_mode_internal_get*/                                       
/*******************************************************************************
* FUNCTION: digi_otn_ddeg_int_latch()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Latches enh and bursty ddeg status from FW to the SW cache.
*
*   Enhanced dDEG in SW retreives FW enhanced DDEG and FW bursty dDEG.
*   Bursty dDEG in SW retrieves only FW bursty dDEG.
*
* INPUTS:
*   digi_handle       - Pointer to digi handle
*   chnl_handle       - Channel handle, or DIGI_INT_ALL_CHNLS 
*   int_type          - Interrupt type (LINEOTN or SYSOTN)
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_ddeg_int_latch(digi_handle_t             *digi_handle,
                                          digi_otn_odu_chnl_t       *chnl_handle,
                                          digi_int_type_t            int_type)
                                                           
{
    PMC_ERROR result = PMC_SUCCESS;
    BOOL retrieve_enh = FALSE;
    BOOL retrieve_bursty = FALSE;
    BOOL retrieve_valid = FALSE;
    UINT32 i;
    digi_pmon_ddeg_t           *ddeg_ptr;
    digi_otn_ddeg_mon_seg_t     mon_seg = LAST_DIGI_OTN_DDEG_MON_SEG;
    BOOL                        configured = FALSE;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);


    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }


    /* Obtain the scope of ddeg */    
    result = digi_otn_odu_ddeg_mode_internal_get(digi_handle, DIGI_OTN_ENHANCED_DDEG, &configured, &mon_seg);


    if (PMC_SUCCESS == result && FALSE == configured)
    {
        result = digi_otn_odu_ddeg_mode_internal_get(digi_handle, DIGI_OTN_ENH_BURSTY_DDEG, &configured, &mon_seg);
    }

    if (PMC_SUCCESS == result && TRUE == configured)
    {
        result = digi_otn_odu_int_ddeg_scope_get(digi_handle,
                                                 (coreotn_ddeg_mon_seg_t) mon_seg,
                                                 &retrieve_enh,
                                                 &retrieve_bursty,
                                                 &retrieve_valid);
    }

    if (PMC_SUCCESS == result && 
        (FALSE == configured || FALSE == retrieve_valid))
    {
        if (DIGI_OTN_ENHANCED_DDEG == digi_handle->var.linesys_ddeg_mode)
        {
            retrieve_enh = TRUE;
            retrieve_valid = TRUE;
        }
        else if (DIGI_OTN_ENH_BURSTY_DDEG == digi_handle->var.linesys_ddeg_mode)
        {
            retrieve_bursty = TRUE;
            retrieve_valid = TRUE;
        }
    }

    if (PMC_SUCCESS == result && FALSE == retrieve_valid)
    {
        /* Nothing to do for enh dDeg */
        PMC_RETURN(result);
    }
    
    /* disabling caching when accessing FW*/
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, FALSE, FALSE);

    /* Retrieve pointer to ddeg cache */
    if (PMC_SUCCESS == result)
    {
        ddeg_ptr = digi_handle->var.int_info_ary->ddeg_cache;
    }

    for (i = 0; i < DIGI_PMON_DDEG_MODE_MAX_NUM && PMC_SUCCESS == result; 
         i++)
    {
        digi_pmon_ddeg_mode_t ddeg_mode = DIGI_PMON_DDEG_MODE_ENH;

        if (i > 0)
        {
            ddeg_mode = DIGI_PMON_DDEG_MODE_BURSTY;
        }
        /* i_bit */
        result = digi_pmon_ddeg_int_get(digi_handle,
                                        ddeg_mode,
                                        1,                         
                                        &ddeg_ptr[i].i_bit);

        if (PMC_SUCCESS == result)
        {
            /* v_bit */
            result = digi_pmon_ddeg_int_get(digi_handle,
                                            ddeg_mode,
                                            0, 
                                            &ddeg_ptr[i].v_bit);
        }
    }

    /* re-enabling caching to continue interrupt retrival*/
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, TRUE, FALSE);

    PMC_RETURN(result);
} /* digi_otn_ddeg_int_latch */

/*******************************************************************************
* FUNCTION: digi_otn_ddeg_int_start()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Start OTN dDEG interrupt processing.
*
*  This function triggers all OTN (server and ODU) dDEG interrupts to be
*  transferred to the local cache for retrieval by SW. Interrupts are
*  automatically cleared so interrupts for all channels must be captured
*  between digi_otn_ddeg_int_start() and digi_otn_ddeg_int_end().
*
*   Example call sequence:
*       // Check aggregated OTN interrupts
*       digi_otn_int_enabled_check()
*
*       // Aggregated OTN callback called    
*       Aggregated CB:
*
*           // Trigger beginning of dDEG interrupt processing 
*           digi_otn_ddeg_int_start()
*
*
*
*           // Check and process OTN server interrupts and status
*
*
*
*           // Trigger beginning of ODU interrupt processing 
*           digi_otn_odu_int_start()
*
*           // Check and process OTN ODU interrupts and status
*
*           // End ODU interrupt processing
*           digi_otn_odu_int_end()
*
*
*
*           // End dDEG interrupt processing 
*           digi_otn_ddeg_int_end()
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   unused          - unused
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_ddeg_int_start(digi_handle_t           *digi_handle,
                                         UINT32                   unused)
{
    PMC_ERROR           result = PMC_SUCCESS;
    digi_int_type_t     int_type;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* Clear DDEG interrupts */
    result = digi_otn_odu_int_ddeg_clear(digi_handle);    

    /* Trigger transfer of DDEG interrupts from FW to SW cache */
    if (PMC_SUCCESS == result)
    {
        if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
        { 
            int_type = DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS;
        }
        else
        {
            int_type = DIGI_INT_CHNL_TYPE_OTN_SERVER;
        }

        result = digi_otn_ddeg_int_latch(digi_handle,
                                         DIGI_INT_ALL_CHNLS,
                                         int_type);
    }

    /* Mark SW cache as valid */
    if (PMC_SUCCESS == result)
    {
        digi_handle->var.int_info_ary->ddeg_cache_valid = TRUE;
    }

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_ddeg_int_start */


/*******************************************************************************
* FUNCTION: digi_otn_ddeg_int_end()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Ends OTN dDEG interrupt processing.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   unused          - unused
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_ddeg_int_end(digi_handle_t            *digi_handle,
                                       UINT32                    unused)
{
    PMC_ATOMIC_ENTRY(digi_handle);
    
    digi_handle->var.int_info_ary->ddeg_cache_valid = FALSE;

    PMC_ATOMIC_RETURN(digi_handle, PMC_SUCCESS);
} /* digi_otn_ddeg_int_end */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ddeg_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears enh dDeg IPI interrupts and sets IPI bit appropriate to indicate
*   to FW that SW is done operating on it.
*
*   The individual stage/chnl interrupts are cleared on read, so no explicit
*   clear is necessary.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ddeg_clear(digi_handle_t            *digi_handle)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();
    
    
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }


    /* Clear enh dDeg IPI interrupts */
    if (PMC_SUCCESS == result)
    {
        result = digi_pmon_ipi_int_clear(digi_handle,
                                         DIGI_PMON_IPI_TYPE_DDEG_ENH);
    }
    
    if (PMC_SUCCESS == result)
    {
        result = digi_pmon_ipi_int_clear(digi_handle,
                                         DIGI_PMON_IPI_TYPE_DDEG_BURSTY);
    }

    /* Mark IPI bit to indicate SW is finished with it */
    if (PMC_SUCCESS == result)
    {
        result = digi_pmon_ipi_bit_set(digi_handle,
                                       DIGI_PMON_IPI_TYPE_DDEG_ENH,
                                       DIGI_PMON_IPI_BITS_SW_DONE);

    }
    
    if (PMC_SUCCESS == result)
    {
        result = digi_pmon_ipi_bit_set(digi_handle,
                                       DIGI_PMON_IPI_TYPE_DDEG_BURSTY,
                                       DIGI_PMON_IPI_BITS_SW_DONE);
    }



    PMC_RETURN(result);
} /* digi_otn_odu_int_ddeg_clear */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ddeg_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Searches IPI interrupts fo enhanced dDeg.  
*
* INPUTS:
*  digi_handle       - Pointer to digi handle
*  mon_seg           - Monitoring segment (stg1/stg2/stg3, or stg4)
*
* OUTPUTS:
*   int_found_ptr     - Returns TRUE if an active interrupt is found
*  
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ddeg_enabled_check(digi_handle_t             *digi_handle,
                                                     coreotn_ddeg_mon_seg_t     mon_seg,  
                                                     BOOL                      *int_found_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;
    BOOL            update_enh, update_bursty, update_valid;

    PMC_ENTRY();
    
    
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Obtain the scope of ddeg */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_ddeg_scope_get(digi_handle,
                                                 mon_seg,
                                                 &update_enh,
                                                 &update_bursty,
                                                 &update_valid);
    }

    if (FALSE == update_valid && DIGI_OTN_HARDWARE_DDEG == digi_handle->var.linesys_ddeg_mode)
    {
        /* Nothing to do */
        PMC_RETURN(result);
    }

    if (PMC_SUCCESS == result &&
        FALSE == *int_found_ptr &&
        TRUE == digi_pmon_ipi_int_retrieve(digi_handle, DIGI_PMON_IPI_TYPE_DDEG_ENH))
    {
        *int_found_ptr = TRUE; 
    }
    
    if ((PMC_SUCCESS == result) &&
        (FALSE == *int_found_ptr) &&
        (TRUE == digi_pmon_ipi_int_retrieve(digi_handle, DIGI_PMON_IPI_TYPE_DDEG_BURSTY)))
    {
        *int_found_ptr = TRUE; 
    }


    PMC_RETURN(result);
} /* digi_otn_odu_int_ddeg_enabled_check */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ddeg_chnl_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks for channelized ddeg interrupts.
*
* INPUTS:
*   digi_handle       - Pointer to digi handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   mon_seg           - Monitoring segment (stg1/stg2/stg3, or stg4)
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*
* OUTPUTS:
*   int_found_ptr     - Returns TRUE if an active interrupt is found
*  
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_ddeg_chnl_enabled_check(digi_handle_t             *digi_handle,
                                                          coreotn_int_chnl_info_t   *chnl_info,
                                                          coreotn_ddeg_mon_seg_t     mon_seg,  
                                                          coreotn_int_framer_chnl_t *int_en_table_ptr,
                                                          BOOL                      *int_found_ptr)
{
    PMC_ERROR               result = PMC_SUCCESS;
    BOOL                    update_enh, update_bursty, update_valid;
    digi_pmon_ddeg_stage_t *ddeg_ptr;
    UINT32                  chnl_id, pool_id;
    UINT32                  i;

    PMC_ENTRY();
    
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }
    
    /* If ddeg has not been triggered, just return */
    if (FALSE == digi_handle->var.int_info_ary->ddeg_cache_valid)
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Obtain the scope of ddeg */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_ddeg_scope_get(digi_handle,
                                                 mon_seg,
                                                 &update_enh,
                                                 &update_bursty,
                                                 &update_valid);
    }

    if (FALSE == update_valid)
    {
        /* Nothing to do */
        PMC_RETURN(result);
    }

    
    /* Get pointer to ddeg cache */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_ddeg_get(digi_handle,
                                           chnl_info->odu_level,
                                           &ddeg_ptr);
    }

    chnl_id = chnl_info->chnl_id;

    /* Check PMs */
    if ((PMC_SUCCESS == result) &&
        (FALSE == *int_found_ptr) &&
        (TRUE  == update_bursty) &&
        (TRUE  == pmc_bitarray_is_bit_set(ddeg_ptr[DIGI_PMON_DDEG_MODE_BURSTY].i_ptr, chnl_id)))
    {
        *int_found_ptr = TRUE; 
    }
    
    if ((PMC_SUCCESS == result) &&
        (FALSE == *int_found_ptr) &&
        (TRUE  == update_enh) &&
        (TRUE  == pmc_bitarray_is_bit_set(ddeg_ptr[DIGI_PMON_DDEG_MODE_ENH].i_ptr, chnl_id)))
    {
        *int_found_ptr = TRUE; 
    }

    /* Check TCMs */
    if (PMC_SUCCESS == result) 
    {
        for (i = 0; (i < COREOTN_PIDS_PER_CHNL) && (FALSE == *int_found_ptr); i++)
        {
            pool_id = chnl_info->rx_pool_id[i];

            if(DIGI_OTN_IS_TCM_PID_VALID(pool_id))
            {
                if ((TRUE == update_enh) &&
                    (TRUE == pmc_bitarray_is_bit_set(ddeg_ptr[DIGI_PMON_DDEG_MODE_ENH].tcm_i_ptr, pool_id)))
                {
                    *int_found_ptr = TRUE; 
                }

                if ((TRUE == update_bursty) &&
                    (TRUE == pmc_bitarray_is_bit_set(ddeg_ptr[DIGI_PMON_DDEG_MODE_BURSTY].tcm_i_ptr, pool_id)))
                {
                    *int_found_ptr = TRUE; 
                }
            }
        }
    }

    PMC_RETURN(result);
} /* digi_otn_odu_int_ddeg_chnl_enabled_check */

/*******************************************************************************
* FUNCTION: digi_otn_int_enabled_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves an aggregation interrupt table with enabled interrupt bits
*   over multiple channels.
*
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*
* OUTPUTS:
*   int_table_ptr  - pointer to aggregation interrupt table to store enabled interrupt
*                    information
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_int_enabled_get(digi_handle_t      *digi_handle,
                                          digi_otn_int_t     *int_table_ptr)
{
    PMC_ERROR                result = PMC_SUCCESS;
    digi_int_type_t          int_type = DIGI_INT_TYPE_OTN;
    UINT32                   i;
    UINT32                   num_odu;
    odu_struct_odu_level_t   odu_list[LAST_ODU_STRUCT_LEVEL];
 

    PMC_ATOMIC_ENTRY(digi_handle);

    result = digi_int_param_check(digi_handle, NULL, int_type, int_table_ptr); 
    
    /* Clear interrupt table memory */
    PMC_MEMSET(int_table_ptr, 0, sizeof(digi_otn_int_t));


    /* Retrieve all LINE/SYS OTN status */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_lineotn_int_enabled_get(digi_handle,
                                                  int_table_ptr);

    }

    if (PMC_SUCCESS == result)
    {
        result = digi_otn_server_int_enabled_get(digi_handle,
                                                 DIGI_INT_ALL_CHNLS,
                                                 DIGI_INT_CHNL_TYPE_OTN_SERVER,
                                                 int_table_ptr);

    }
    
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_server_int_enabled_get(digi_handle,
                                                 DIGI_INT_ALL_CHNLS,
                                                 DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS,
                                                 int_table_ptr);

    }

    if (PMC_SUCCESS == result)
    {
        result = digi_otn_coreotn_int_enabled_get(digi_handle,
                                                  int_table_ptr);

    }

    /* Get range of ODU levels (HO/MO/LO) to retrieve */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_odu_range_get(digi_handle,
                                                DIGI_INT_ALL_CHNLS,
                                                odu_list,
                                                &num_odu);
    }


    /* Retrieve all interrupts per odu level */
    for (i = 0; (PMC_SUCCESS == result) && (i < num_odu); i++)
    {
        result = digi_otn_odu_int_chnl_stage_enabled_get(digi_handle,
                                                         DIGI_INT_ALL_CHNLS,
                                                         odu_list[i],
                                                         int_table_ptr);

    } 




    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_int_enabled_get */


/*******************************************************************************
* FUNCTION: digi_otn_lineotn_int_enabled_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves an aggregation interrupt table with enabled interrupt bits.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*
* OUTPUTS:
*   int_table_ptr  - pointer to aggregation interrupt table to store enabled
*                    interrupt information
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_lineotn_int_enabled_get(digi_handle_t            *digi_handle,
                                                   digi_otn_int_t           *int_table_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;

    digi_otn_int_t              *int_en_table_ptr = NULL;
    lineotn_int_t               *lineotn_en_table_ptr = NULL;
    lineotn_int_t               *sysotn_en_table_ptr = NULL;

    PMC_ENTRY();
    
    /* Get internal enabled interrupt table to check */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);
    }

    if (PMC_SUCCESS == result && NULL != int_en_table_ptr)
    {
        lineotn_en_table_ptr = &int_en_table_ptr->lineotn;
        sysotn_en_table_ptr = &int_en_table_ptr->sysotn;
    }

    if (PMC_SUCCESS == result)
    {
        /* Copy enabled table */
        PMC_MEMCPY(&int_table_ptr->lineotn, lineotn_en_table_ptr, sizeof(lineotn_int_t));
        PMC_MEMCPY(&int_table_ptr->sysotn, sysotn_en_table_ptr, sizeof(lineotn_int_t));
    }

    PMC_RETURN(result);
} /* digi_otn_lineotn_int_enabled_get */


/*******************************************************************************
* FUNCTION: digi_otn_server_int_enabled_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves an aggregation interrupt table with enabled interrupt bits
*   over multiple channels.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to retrieve enabled interrupts
*   int_type        - Interrupt type (LINEOTN or SYSOTN)
*
* OUTPUTS:
*   int_table_ptr  - pointer to aggregation interrupt table to store enabled interrupt
*                    information
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_enabled_get(digi_handle_t            *digi_handle,
                                                  digi_otn_server_chnl_t   *chnl_handle,
                                                  digi_int_type_t           int_type,
                                                  digi_otn_int_t           *int_table_ptr)
{
    PMC_ERROR                        result = PMC_SUCCESS;

    UINT32                           start_link = 0;
    UINT32                           end_link = 0;
    UINT32                           i;
    digi_otn_int_t                  *int_en_table_ptr = NULL;
    digi_otn_server_chnl_def_t      *handle_pool_ptr = NULL;
    digi_otn_server_chnl_t          *chnl_ptr;
    digi_otn_server_chnl_t         **otn_handle_ptr = NULL;
    lineotn_int_chnl_t              *otn_table_ptr = NULL;
    lineotn_int_chnl_t              *otn_en_table_ptr = NULL;
    UINT32 size=0;

    PMC_ENTRY();
    result = digi_int_param_check(digi_handle, DIGI_INT_ALL_CHNLS, int_type, int_table_ptr); 
    
    /* Get internal enabled interrupt table to check */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);

    }

    if (PMC_SUCCESS == result && NULL != int_en_table_ptr)
    {
        switch (int_type)
        {
        case DIGI_INT_CHNL_TYPE_OTN_SERVER:
            handle_pool_ptr  = digi_handle->handle_pool.otn_server_chnl;
            otn_handle_ptr   = int_table_ptr->otn_server_handle;
            otn_table_ptr    = int_table_ptr->otn_server_chnl;
            otn_en_table_ptr = int_en_table_ptr->otn_server_chnl;
            size = DIGI_OTN_SERVER_CHNL_MAX;
            break;
            
        case DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS:
            handle_pool_ptr  = &digi_handle->handle_pool.sysotn_server_chnl;
            otn_handle_ptr   = int_table_ptr->sysotn_server_handle;
            otn_table_ptr    = int_table_ptr->sysotn_server_chnl;
            otn_en_table_ptr = int_en_table_ptr->sysotn_server_chnl;
            size = DIGI_OTN_SERVER_SYS_CHNL_MAX;
            break;
            
        default:
            PMC_ASSERT(NULL, DIGI_ERR_INVALID_ARG, 0, 0);
            break;
        } /* end switch */
    }


    /* Determine if are modfiying one channel or all channels */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_link_range_get(digi_handle,
                                         chnl_handle,
                                         int_type,
                                         &start_link,
                                         &end_link);
    }


    if (PMC_SUCCESS == result)
    {
        /* Copy enabled table */
        PMC_MEMCPY(otn_table_ptr, otn_en_table_ptr, size*sizeof(lineotn_int_chnl_t));
    }
   
    /* Fill in channel handles */
    for (i = start_link; (i < end_link) && (PMC_SUCCESS == result); i++)
    {
        otn_handle_ptr[i] = NULL;
        chnl_ptr = &handle_pool_ptr[i];

        if (util_global_is_chnl_prov(chnl_ptr))
        {
            otn_handle_ptr[i] = chnl_ptr; 
        }
    }

    PMC_RETURN(result);
} /* digi_otn_server_int_chnl_enabled_get */


/*******************************************************************************
* FUNCTION: digi_otn_coreotn_int_enabled_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves an aggregation interrupt table with enabled interrupt bits.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*
* OUTPUTS:
*   int_table_ptr  - pointer to aggregation interrupt table to store enabled
*                    interrupt information
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_coreotn_int_enabled_get(digi_handle_t            *digi_handle,
                                                   digi_otn_int_t           *int_table_ptr)
{
    PMC_ERROR                        result = PMC_SUCCESS;

    digi_otn_int_t                  *int_en_table_ptr = NULL;
    coreotn_int_t                   *otn_en_table_ptr = NULL;

    PMC_ENTRY();

    /* Get internal enabled interrupt table to check */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);

    }

    if (PMC_SUCCESS == result && NULL != int_en_table_ptr)
    {
        otn_en_table_ptr = &int_en_table_ptr->coreotn;
    }

    if (PMC_SUCCESS == result)
    {
        /* Copy enabled table */
        PMC_MEMCPY(&int_table_ptr->coreotn, otn_en_table_ptr, sizeof(coreotn_int_t));
    }

    PMC_RETURN(result);
} /* digi_otn_coreotn_int_enabled_get */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_chnl_stage_enabled_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieve interrupts in the specified HO/MO/LO stage.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - pointer to channel handle to retrieve enabled interrupts
*   odu_level       - Indicates whether to retrieve enabled interrupts on HO/MO/LO
*
* OUTPUTS:
*   int_table_ptr   - pointer to channel interrupt table to return status 
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_chnl_stage_enabled_get(digi_handle_t             *digi_handle,
                                                          digi_otn_odu_chnl_t       *chnl_handle,
                                                          odu_struct_odu_level_t     odu_level,
                                                          digi_otn_int_t            *int_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    digi_int_type_t             int_type = DIGI_INT_CHNL_TYPE_OTN_ODU;
    
    UINT32                      start_chnl = 0;
    UINT32                      end_chnl = 0;
    UINT32                      i;
    digi_otn_odu_chnl_t       **odu_handle_pptr;
    odu_struct_t               *handle_pool_ptr;
    odu_struct_t               *stg3b_handle_pool_ptr;
    digi_otn_odu_int_chnl_t    *odu_ptr;
    
    
    PMC_ENTRY();

    result = digi_int_param_check(digi_handle, chnl_handle, int_type, int_table_ptr); 


    if (PMC_SUCCESS == result)
    {
        /* Get range of channels to retrieve within ODU level */
        result = digi_otn_odu_int_link_range_get(digi_handle,
                                                 chnl_handle,
                                                 odu_level,
                                                 &start_chnl,
                                                 &end_chnl);
    }





    /* Get the pool pointer for ODU level */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_handle_pool_get(digi_handle, odu_level, &handle_pool_ptr);
    }
    
    /* Get the pool pointer for stg3b */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_handle_pool_get(digi_handle, ODU_STRUCT_LEVEL_3B_ODU, &stg3b_handle_pool_ptr);
    }
   



    /* Get the odu interrupt table for output */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_odu_get(digi_handle,
                                          odu_level,
                                          int_table_ptr,
                                          &odu_handle_pptr,
                                          &odu_ptr);
    }




    for (i = start_chnl; (i < end_chnl) && (PMC_SUCCESS == result); i++)
    {
        if (util_global_is_chnl_prov(&handle_pool_ptr[i]))
        {
            /* Store handle */
            odu_handle_pptr[i] = (digi_otn_odu_chnl_t *) &handle_pool_ptr[i];

            result = digi_otn_odu_int_chnl_stage_enabled_get_helper(digi_handle,
                                                                    odu_handle_pptr[i],
                                                                    odu_level,
                                                                    &odu_ptr[i].status);
            

            /* Retrieve Stg 3b if needed */
            if ((PMC_SUCCESS == result) &&
                (TRUE == digi_otn_is_stg3b_present(digi_handle, odu_handle_pptr[i])))
            {
                odu_ptr[i].stg3b_valid = TRUE;
            
                result = digi_otn_odu_int_chnl_stage_enabled_get_helper(digi_handle,
                                                                        &stg3b_handle_pool_ptr[i],
                                                                        ODU_STRUCT_LEVEL_3B_ODU,
                                                                        &odu_ptr[i].stg3b);

            }
        }
    }

    
    PMC_RETURN(result);
} /* digi_otn_odu_int_chnl_stage_enabled_get */




/*******************************************************************************
* FUNCTION: digi_otn_odu_int_chnl_stage_enabled_get_helper()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the Framer and TCM enabled interrupt bits. 
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to retrieve enabled interrupts
*   odu_level       - Indicates whether to retrieve enabled interrupts on HO/MO/LO
*
* OUTPUTS:
*   int_table_ptr   - pointer to channel interrupt table to return enabled interrupts 
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_chnl_stage_enabled_get_helper(digi_handle_t              *digi_handle,
                                                                digi_otn_odu_chnl_t        *chnl_handle,
                                                                odu_struct_odu_level_t      odu_level,
                                                                coreotn_int_chnl_t         *int_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    
    UINT32                      start_chnl = 0;
    UINT32                      end_chnl = 0;
    UINT32                      i;
    UINT32                      rx_pool_id[LAST_DIGI_OTN_TCM_NUM];
    UINT32                      tx_pool_id[LAST_DIGI_OTN_TCM_NUM];
    coreotn_int_framer_chnl_t  *framer_en_ptr;
    odu_rfrm_int_pid_chnl_t    *pid_en_ptr;
    UINT32                      prbs_chnl;
    coreotn_prbs_inst_t         prbs_inst;
    coreotn_int_prbs_chnl_t    *prbs_en_ptr;



    PMC_ENTRY();
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_handle != NULL, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(int_table_ptr != NULL, DIGI_ERR_INVALID_ARG, 0, 0);


    /* Get specific ODU level framer enabled interrupt table */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_en_framer_get(digi_handle,
                                                odu_level,
                                                &framer_en_ptr);
    }
    
    /* Get specific ODU level PID enabled interrupt table */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_en_pid_get(digi_handle,
                                             odu_level,
                                             &pid_en_ptr);
    }

    
    /* Get range of channels to retrieve within ODU level */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_link_range_get(digi_handle,
                                                 chnl_handle,
                                                 odu_level,
                                                 &start_chnl,
                                                 &end_chnl);
    }


    /* Gather Pool IDs */
    if (PMC_SUCCESS == result)
    {
        (void)digi_otn_pool_id_get(digi_handle, chnl_handle, rx_pool_id); 
    }

    /* get TFRM pool ids */
    if (PMC_SUCCESS == result)
    {
        (void)digi_otn_pool_id_get(digi_handle, chnl_handle, tx_pool_id); 
    }
   
    if (PMC_SUCCESS == result)
    {
        /* Copy enabled table */
        PMC_MEMCPY(&int_table_ptr->framer_chnl, &framer_en_ptr[start_chnl], sizeof(int_table_ptr->framer_chnl));

        /* Copy PIDs */
        for (i = 0; i < LAST_DIGI_OTN_TCM_NUM; i++)
        {
            int_table_ptr->pid.rx_tcm_pool_ids[i] = rx_pool_id[i];

            if (DIGI_OTN_IS_TCM_PID_VALID(rx_pool_id[i]))
            {
                PMC_MEMCPY(&int_table_ptr->pid.rx_tcm[i], &pid_en_ptr[rx_pool_id[i]], sizeof(odu_rfrm_int_pid_chnl_t));
            }
        }
    }

    if ((PMC_SUCCESS == result) &&
        (digi_otn_odu_int_prbs_is_prov(digi_handle,
                                       chnl_handle,
                                       &prbs_chnl,
                                       &prbs_inst,
                                       &prbs_en_ptr)))
    {
        int_table_ptr->prbs_valid = TRUE;
        PMC_MEMCPY(&int_table_ptr->prbs, prbs_en_ptr, sizeof(coreotn_int_prbs_chnl_t));
    }

    PMC_RETURN(result);
} /* digi_otn_odu_int_chnl_stage_enabled_get_helper */

/*******************************************************************************
* FUNCTION: digi_otn_int_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Searches enabled interrupt bits in all channels of the subsystem.
*
*   The callback associated with the aggregation interrupt type will be called
*   if an active interrupt is found in any channel.
*
*   The callback will be called a minimum of zero times if no active interrupts
*   are found, or a maximum of one time if there is an interrupt in at least
*   one channel.
*
*   A callback must be registered for the interrupt type before this API can be called.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*
*   
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_int_enabled_check(digi_handle_t   *digi_handle)
{
    PMC_ERROR            result = PMC_SUCCESS;
  
    PMC_ATOMIC_ENTRY(digi_handle);
  
    result = digi_otn_int_enabled_check_internal(digi_handle);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_int_enabled_check */


/*******************************************************************************
* FUNCTION: digi_otn_server_int_chnl_enabled_check_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Searches enabled interrupt bits in all channels of the subsystem.
*
*   The callback associated with the channel interrupt type will be called
*   for each channel that has an active interrupt.

*   The callback will be called a minimum of zero times if no active interrupts
*   are found, or a maximum of once per channel if there is an active interrupt
*   on every channel.
*
*   digi_otn_ddeg_int_start() needs to be called if checking for active dDEG ints.
*
*   A callback must be registered for the interrupt type before this API can be called.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_type        - Line or sysotn
*   int_en_table_ptr- Enabled interrupt table.
*   int_summary_ptr - If digi_otn_server_int_summary_get() was run prior to 
*                     calling this function, the pointer to the interrupt summary
*                     structure can be passed in to decrease the search
*                     time for active interrupts in this function.
*                     Set this parameter to NULL if the summary was not retrieved.
*
*   
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_chnl_enabled_check_internal(digi_handle_t                 *digi_handle,
                                                                 digi_int_type_t                int_type,
                                                                 digi_otn_int_t                *int_en_table_ptr,
                                                                 digi_otn_server_int_summary_t *int_summary_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;
    UINT32                       i;
    lineotn_handle_t            *lineotn_handle;
    digi_otn_server_chnl_def_t  *handle_pool_ptr;
    digi_otn_server_chnl_t      *chnl_handle;
    lineotn_int_chnl_t          *line_sys_en_table_ptr;
    BOOL                         int_summary_free_req = FALSE;         

    PMC_ENTRY();
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    if (PMC_SUCCESS == result)
    {
        switch (int_type)
        {
          case DIGI_INT_CHNL_TYPE_OTN_SERVER:
            lineotn_handle   = digi_handle->lineotn_handle;
            handle_pool_ptr  = digi_handle->handle_pool.otn_server_chnl;
            line_sys_en_table_ptr = int_en_table_ptr->otn_server_chnl;
            break;
            
          case DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS:
            lineotn_handle   = digi_handle->sysotn_handle;
            handle_pool_ptr  = &digi_handle->handle_pool.sysotn_server_chnl;
            line_sys_en_table_ptr = int_en_table_ptr->sysotn_server_chnl;
            break;
        
          default:
            PMC_ASSERT(NULL, DIGI_ERR_INVALID_ARG, 0, 0);
            break;
        } /* end switch */
    }

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == lineotn_start_state_test(lineotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    if(!digi_int_is_cb_registered(digi_handle, int_type))
    {
        result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
    }


    /* Find active channels */ 
    if ((PMC_SUCCESS == result) &&
        (NULL == int_summary_ptr))
    {
        int_summary_ptr = (digi_otn_server_int_summary_t *) PMC_MALLOC(sizeof(digi_otn_server_int_summary_t));
        PMC_MEMSET(int_summary_ptr, 0, sizeof(digi_otn_server_int_summary_t));
        int_summary_free_req = TRUE;
        
        result = digi_otn_server_int_summary_get_internal(digi_handle,
                                                          int_type,
                                                          0, /* unused */
                                                          int_summary_ptr);
    }

    /* Call user callback for all active channels */
    for (i = 0; (PMC_SUCCESS == result) && (i < int_summary_ptr->active_chnl_num); i++)
    {
        chnl_handle = int_summary_ptr->active_chnl[i];

        result = digi_int_callback_run(digi_handle, 
                                       chnl_handle,
                                       int_type);
    }
    
    if (TRUE == int_summary_free_req)
    {
        PMC_FREE(&int_summary_ptr);
    }

    PMC_RETURN(result);
} /* digi_otn_server_int_chnl_enabled_check_internal */

/*******************************************************************************
* FUNCTION: digi_otn_server_int_chnl_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Searches enabled interrupt bits in all channels of the subsystem.
*
*   The callback associated with the channel interrupt type will be called
*   for each channel that has an active interrupt.

*   The callback will be called a minimum of zero times if no active interrupts
*   are found, or a maximum of once per channel if there is an active interrupt
*   on every channel.
*
*   A callback must be registered for the interrupt type before this API can be called.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_summary_ptr - If digi_otn_server_int_summary_get() was run prior to 
*                     calling this function, the pointer to the interrupt summary
*                     structure can be passed in to decrease the search
*                     time for active interrupts in this function.
*                     Set this parameter to NULL if the summary was not retrieved.
*
*   
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_int_chnl_enabled_check(digi_handle_t                 *digi_handle,
                                                        digi_otn_server_int_summary_t *int_summary_ptr)
{
    PMC_ERROR            result = PMC_SUCCESS;
    digi_otn_int_t      *int_en_table_ptr;
  
    PMC_ATOMIC_ENTRY(digi_handle);
 
    /* Get internal enabled aggregate interrupt table to update */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);

    }


    if (PMC_SUCCESS == result)
    {
        result = digi_otn_server_int_chnl_enabled_check_internal(digi_handle,
                                                                 DIGI_INT_CHNL_TYPE_OTN_SERVER,
                                                                 int_en_table_ptr,
                                                                 int_summary_ptr);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_server_int_chnl_enabled_check */



/*******************************************************************************
* FUNCTION: digi_sysotn_server_int_chnl_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Searches enabled interrupt bits in all channels of the subsystem.
*
*   The callback associated with the channel interrupt type will be called
*   for each channel that has an active interrupt.

*   The callback will be called a minimum of zero times if no active interrupts
*   are found, or a maximum of once per channel if there is an active interrupt
*   on every channel.
*
*   A callback must be registered for the interrupt type before this API can be called.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_summary_ptr - If digi_otn_server_int_summary_get() was run prior to 
*                     calling this function, the pointer to the interrupt summary
*                     structure can be passed in to decrease the search
*                     time for active interrupts in this function.
*                     Set this parameter to NULL if the summary was not retrieved.
*
*   
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_sysotn_server_int_chnl_enabled_check(digi_handle_t                 *digi_handle,
                                                           digi_otn_server_int_summary_t *int_summary_ptr)
{
    PMC_ERROR            result = PMC_SUCCESS;
    digi_otn_int_t      *int_en_table_ptr;
  
    PMC_ATOMIC_ENTRY(digi_handle);
  
    /* Get internal enabled aggregate interrupt table to update */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);

    }

    if (PMC_SUCCESS == result)
    {
        result = digi_otn_server_int_chnl_enabled_check_internal(digi_handle,
                                                                 DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS,
                                                                 int_en_table_ptr,
                                                                 int_summary_ptr);
    }


    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_sysotn_server_int_chnl_enabled_check */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_chnl_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Searches enabled interrupt bits in all channels of the subsystem.
*
*   The callback associated with the channel interrupt type will be called
*   for each channel that has an active interrupt.

*   The callback will be called a minimum of zero times if no active interrupts
*   are found, or a maximum of once per channel if there is an active interrupt
*   on every channel.
*
*   digi_otn_odu_int_start(COREOTN_LATCH_DEFECT_ODUKP) or 
*   digi_otn_odu_int_start(COREOTN_LATCH_DEFECT_ALL) needs to be called if 
*   checking for active RFRM ints.
*
*   digi_otn_ddeg_int_start() needs to be called if checking for active dDEG ints.
*
*   A callback must be registered for the interrupt type before this API can be called.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   odu_level       - ODU level to check for active interrupts
*   int_summary_ptr - If digi_otn_odu_int_summary_get() was run prior to 
*                     calling this function, the pointer to the interrupt summary
*                     structure can be passed in to decrease the search
*                     time for active interrupts in this function.
*                     Set this parameter to NULL if the summary was not retrieved.
*
*   
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_chnl_enabled_check(digi_handle_t                  *digi_handle,
                                                     odu_struct_odu_level_t          odu_level,
                                                     digi_otn_odu_int_summary_t     *int_summary_ptr)
{
    PMC_ERROR               result = PMC_SUCCESS;
    BOOL                    int_summary_free_req = FALSE;         
    digi_otn_odu_chnl_t    *chnl_handle;
    UINT32                  i;
  
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
 
    if (odu_level >= LAST_ODU_STRUCT_LEVEL)
    {
        result = DIGI_ERR_ODU_LEVEL_NOT_VALID;
    }
    
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
    }

    if ((PMC_SUCCESS == result) &&
        (!digi_int_is_cb_registered(digi_handle, DIGI_INT_CHNL_TYPE_OTN_ODU)))
    {
        result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
    }


    /* Check ODU level of summary information */
    if (NULL != int_summary_ptr)
    {
        if (FALSE == (int_summary_ptr->mask & DIGI_OTN_ODU_INT_SUMMARY_MASK_ODU_LEVEL))
        {
            PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INT_SUMMARY_ODU_LEVEL_NOT_AVAIL);
        }

        if (odu_level != int_summary_ptr->odu_level)
        {
            PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INT_SUMMARY_ODU_LEVEL_MISMATCH);
        }
    }


    if (NULL == int_summary_ptr)
    {
        int_summary_ptr = (digi_otn_odu_int_summary_t *) PMC_MALLOC(sizeof(digi_otn_odu_int_summary_t));
        PMC_MEMSET(int_summary_ptr, 0, sizeof(digi_otn_odu_int_summary_t));
        int_summary_free_req = TRUE;
    }



    /* Get active channels for this odu level */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_active_chnl_get(digi_handle,
                                                  odu_level,
                                                  TRUE,
                                                  int_summary_ptr);
    }

    /* For active chnls in list, call user callback */
    for (i = 0; (PMC_SUCCESS == result) && (i < int_summary_ptr->active_chnl_num); i++)
    {
        chnl_handle = int_summary_ptr->active_chnl[i];

        result = digi_int_callback_run(digi_handle, 
                                       chnl_handle,
                                       DIGI_INT_CHNL_TYPE_OTN_ODU);
    } 


    if (TRUE == int_summary_free_req)
    {
        PMC_FREE(&int_summary_ptr);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_odu_int_chnl_enabled_check */



/*******************************************************************************
* FUNCTION: digi_otn_server_int_ddeg_chnl_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks for OTN server channelized ddeg interrupts.
*
* INPUTS:
*  digi_handle       - Pointer to digi handle
*  chnl_handle       - pointer to channel handle to check interrupts
*  int_en_table_ptr  - pointer to enabled channel interrupt table
*  is_line           - TRUE is LINEOTN FALSE is SYSOTN.
*
* OUTPUTS:
*   int_found_ptr     - Returns TRUE if an active interrupt is found
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_ddeg_chnl_enabled_check(digi_handle_t          *digi_handle,
                                                              digi_otn_server_chnl_t *chnl_handle,
                                                              lineotn_int_chnl_t     *int_en_table_ptr,
                                                              BOOL8 is_line,
                                                              BOOL *int_found_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;
    BOOL update_enh = FALSE;
    BOOL update_bursty = FALSE;
    BOOL update_valid = FALSE;
    UINT32                       dsi_stream;
    digi_pmon_ddeg_stage_t      *ddeg_ptr;
    digi_otn_server_chnl_def_t  *chnl_def_handle;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_handle    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_found_ptr  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* If ddeg has not been triggered, just return */
    if (FALSE == digi_handle->var.int_info_ary->ddeg_cache_valid)
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    result = digi_otn_odu_int_ddeg_scope_get(digi_handle,
                                             COREOTN_DDEG_MON_LINE,
                                             &update_enh,
                                             &update_bursty,
                                             &update_valid);


    if (PMC_SUCCESS == result)
    {
        if (FALSE == update_valid &&
            DIGI_OTN_ENHANCED_DDEG == digi_handle->var.linesys_ddeg_mode)
        {
            update_enh = TRUE;
            update_valid = TRUE;
        }
        else if (FALSE == update_valid &&
                 DIGI_OTN_ENH_BURSTY_DDEG == digi_handle->var.linesys_ddeg_mode)
        {
            update_bursty = TRUE;
            update_valid = TRUE;
        }
    }

    if (PMC_SUCCESS != result || FALSE == update_valid)
    {
        PMC_RETURN(result);
    }

    chnl_def_handle = (digi_otn_server_chnl_def_t*) chnl_handle;
    dsi_stream = chnl_def_handle->dsi_base_chnl;
    
    if (PMC_SUCCESS == result)
    {
        /* Get pointer to ddeg cache */
        digi_otn_server_int_ddeg_get(digi_handle,
                                     is_line,
                                     &ddeg_ptr);
    }

    if ((PMC_SUCCESS == result) &&
        (FALSE == *int_found_ptr) &&
        (TRUE  == update_bursty) &&
        (TRUE  == pmc_bitarray_is_bit_set(ddeg_ptr[DIGI_PMON_DDEG_MODE_BURSTY].i_ptr, dsi_stream)))
    {
        *int_found_ptr = TRUE; 
    }
    
    if ((PMC_SUCCESS == result) &&
        (FALSE == *int_found_ptr) &&
        (TRUE  == update_enh) &&
        (TRUE  == pmc_bitarray_is_bit_set(ddeg_ptr[DIGI_PMON_DDEG_MODE_ENH].i_ptr, dsi_stream)))
    {
        *int_found_ptr = TRUE; 
    }

    PMC_RETURN(result);
} /* digi_otn_server_int_ddeg_chnl_enabled_check */



/*******************************************************************************
* FUNCTION: digi_otn_server_int_chnl_enabled_check_helper()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Searches enabled interrupt bits in provided channel of the subsystem.
*   Returns if interrupt is found.
*
*
* INPUTS:
*  digi_handle       - pointer to DIGI handle instance.
*  chnl_handle       - pointer to channel handle to check interrupts
*  lineotn_handle    - pointer to line/sys otn handle 
*  int_en_table_ptr  - pointer to enabled channel interrupt table
*  int_type          - Whether this is LINEOTN or SYSOTN side
*
* OUTPUTS:
*   int_found_ptr     - Returns TRUE if an active interrupt is found
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_chnl_enabled_check_helper(digi_handle_t            *digi_handle,
                                                                digi_otn_server_chnl_t   *chnl_handle,
                                                                lineotn_handle_t         *lineotn_handle,
                                                                lineotn_int_chnl_t       *int_en_table_ptr,
                                                                digi_int_type_t           int_type,
                                                                BOOL                     *int_found_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;
    UINT32                       dsi_stream;
    digi_otn_server_chnl_def_t  *chnl_def_handle;

    PMC_ENTRY();
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != int_en_table_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != int_found_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    chnl_def_handle = (digi_otn_server_chnl_def_t*) chnl_handle;

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == lineotn_start_state_test(lineotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    
    if (!util_global_is_chnl_prov(chnl_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    if ((PMC_SUCCESS == result) &&
        (FALSE == *int_found_ptr))
    {
        dsi_stream = chnl_def_handle->dsi_base_chnl;

        /* Check enabled interrupts */
        result = lineotn_int_chnl_enabled_check(lineotn_handle, 
                                                dsi_stream,
                                                int_en_table_ptr,
                                                int_found_ptr);
    }
    
    if ((PMC_SUCCESS == result) &&
        (FALSE == *int_found_ptr))
    {
        /*
         * A value of TRUE for lineotn_mode indicates it is a lineotn, 
         * FALSE is SYSOTN. This value determines the ddeg pointer 
         * representing the cache written by FW for FW ddeg results.
         */
        BOOL8 is_line = TRUE;

        if (DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS == int_type)
        {
            is_line = FALSE;
        }
        result = digi_otn_server_int_ddeg_chnl_enabled_check(digi_handle,
                                                             chnl_handle,
                                                             int_en_table_ptr,
                                                             is_line,
                                                             int_found_ptr);    
    }

    

    PMC_RETURN(result);
} /* digi_otn_server_int_chnl_enabled_check_helper */



/*******************************************************************************
* FUNCTION: digi_otn_server_int_enabled_check_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Searches enabled interrupt bits in all channels of the subsystem.
*
*   The callback associated with the aggregation interrupt type will be called
*   if an active interrupt is found in any channel. The callback will be
*   called a minimum of zero times if no active interrupts are found, or
*   a maximum of one time if there is an interrupt in at least one channel.
*
*   A callback must be registered for the interrupt type before this API
*   can be called.
*
* INPUTS:
*   digi_handle       - pointer to DIGI handle instance.
*   int_type          - Line or sysotn
*   chnl_handle       - pointer to channel handle to check interrupts
*   int_en_table_ptr  - pointer to enabled channel interrupt table
*
* OUTPUTS:
*   int_found_ptr     - Returns TRUE if an active interrupt is found
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_int_enabled_check_internal(digi_handle_t            *digi_handle,
                                                             digi_int_type_t           int_type,
                                                             digi_otn_server_chnl_t   *chnl_handle,
                                                             digi_otn_int_t           *int_en_table_ptr,
                                                             BOOL                     *int_found_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;

    UINT32                       start_link = 0;
    UINT32                       end_link = 0;
    UINT32                       i;
    lineotn_handle_t            *lineotn_handle;
    digi_otn_server_chnl_def_t  *handle_pool_ptr;
    lineotn_int_chnl_t          *line_sys_en_table_ptr;
    BOOL                         is_all_chnls;
    
    PMC_ENTRY();
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
   
    is_all_chnls = IS_DIGI_INT_ALL_CHNLS(chnl_handle);

    if (PMC_SUCCESS == result)
    {
        switch (int_type)
        {
          case DIGI_INT_CHNL_TYPE_OTN_SERVER:
            lineotn_handle   = digi_handle->lineotn_handle;
            handle_pool_ptr  = digi_handle->handle_pool.otn_server_chnl;
            line_sys_en_table_ptr = int_en_table_ptr->otn_server_chnl;

            if (!is_all_chnls)
            {
                PMC_ASSERT(DIGI_OTN_SERVER_IS_LINE(chnl_handle), 0, 0, 0);
            }
            break;
            
          case DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS:
            lineotn_handle   = digi_handle->sysotn_handle;
            handle_pool_ptr  = &digi_handle->handle_pool.sysotn_server_chnl;
            line_sys_en_table_ptr = int_en_table_ptr->sysotn_server_chnl;
            
            if (!is_all_chnls)
            {
                PMC_ASSERT(DIGI_OTN_SERVER_IS_SYS(chnl_handle), 0, 0, 0);
            }
            break;
        
          default:
            PMC_ASSERT(NULL, DIGI_ERR_INVALID_ARG, 0, 0);
            break;
        } /* end switch */
    }

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == lineotn_start_state_test(lineotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }


    /* Determine if are accessing one channel or all channels */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_link_range_get(digi_handle,
                                         chnl_handle,
                                         int_type,
                                         &start_link,
                                         &end_link);
    }


    
    for (i = start_link; (i < end_link) && (PMC_SUCCESS == result) && (FALSE == *int_found_ptr); i++)
    {
        if (is_all_chnls)
        {
            chnl_handle = &handle_pool_ptr[i]; 
        }

        result = digi_otn_server_int_chnl_enabled_check_helper(digi_handle,
                                                               chnl_handle,
                                                               lineotn_handle,
                                                               &line_sys_en_table_ptr[i],
                                                               int_type,
                                                               int_found_ptr);
    }
    
    
    


    PMC_RETURN(result);
} /* digi_otn_server_int_enabled_check_internal */





/*******************************************************************************
* FUNCTION: digi_otn_odu_int_chnl_stage_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Searches for active interrupt bits based on the enabled interrupt table.
*
* INPUTS:
*   digi_handle       - pointer to DIGI handle instance.
*   chnl_handle       - pointer to channel handle to check interrupts
*   odu_level         - Indicates whether to check interrupts on HO/MO/LO
*   int_summary_ptr   - pointer to OTN ODU interrupt summary information
*
* OUTPUTS:
*   int_found_ptr     - Returns TRUE if an active interrupt is found
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_chnl_stage_enabled_check(digi_handle_t               *digi_handle,
                                                           digi_otn_odu_chnl_t         *chnl_handle,
                                                           odu_struct_odu_level_t       odu_level,
                                                           digi_otn_odu_int_summary_t  *int_summary_ptr,
                                                           BOOL                        *int_found_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    digi_int_type_t             int_type = DIGI_INT_CHNL_TYPE_OTN_ODU;

    digi_otn_odu_chnl_t        *chnl_ptr;
    UINT32                      chnl_id;
    coreotn_int_chnl_info_t     chnl_info;
    coreotn_handle_t           *coreotn_handle;
    UINT32                      start_chnl = 0;
    UINT32                      end_chnl = 0;
    UINT32                      i;
    odu_struct_t               *handle_pool_ptr;
    coreotn_int_framer_chnl_t  *framer_en_ptr;
    UINT32                      prbs_chnl;
    coreotn_prbs_inst_t         prbs_inst;
    coreotn_int_prbs_chnl_t    *prbs_en_ptr;
    odu_ohp_int_chnl_t         *ohp_en_table_pptr[COREOTN_NUM_ODU_OHP_INST];
    coreotn_ddeg_mon_seg_t      ddeg_mon; 
   
    PMC_ENTRY();

    PMC_ASSERT(int_summary_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    result = digi_int_param_check(digi_handle, NULL, int_type, int_found_ptr); 
    
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }


    if (PMC_SUCCESS == result)
    {
        /* Get range of channels to retrieve within ODU level */
        (void)digi_otn_odu_int_link_range_get(digi_handle,
                                              chnl_handle,
                                              odu_level,
                                              &start_chnl,
                                              &end_chnl);
    }

    if (PMC_SUCCESS == result)
    {
        /* Get the pool pointer for ODU level */
        result = digi_otn_odu_handle_pool_get(digi_handle, odu_level, &handle_pool_ptr);
    }

    /* Get specific ODU level framer enabled interrupt table */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_en_framer_get(digi_handle,
                                                odu_level,
                                                &framer_en_ptr);
    }

    if (PMC_SUCCESS != result)
    {
        /*
         * If there was an error up to here then return to ensure that
         * no more processing occurs in an error state.
         */
        PMC_RETURN(result);
    }
    /*
     * Clear the chnl_info table before updating.
     */
    PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));

    /* determine from odu struct line or source */
    if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    { 
        chnl_info.source = COREOTN_INT_SOURCE_SYS; 
    }
    else
    {
        chnl_info.source = COREOTN_INT_SOURCE_LINE; 
    }

    if (ODU_STRUCT_LEVEL_4_ODU == odu_level)
    {
        ddeg_mon = COREOTN_DDEG_MON_CLIENT;
    }
    else
    {
        ddeg_mon = COREOTN_DDEG_MON_LINE;
    }

    coreotn_handle              = digi_handle->coreotn_handle;
    chnl_info.odu_level         = odu_level;
    pmc_bitarray_or(chnl_info.rfrm_int_summary.active_chnl_bitmask, int_summary_ptr->active_chnl_bitmask, DIGI_ODU_CHNLS_MAX);
    pmc_bitarray_or(chnl_info.rfrm_int_summary.active_pid_bitmask,  int_summary_ptr->active_pid_bitmask,  DIGI_ODU_PIDS_MAX);
    pmc_bitarray_or(chnl_info.rfrm_int_summary.active_int_bitmask,  int_summary_ptr->active_int_bitmask,  LAST_ODU_RFRM_INT_DEFECT);

    /* Prepare ohp enable table pointer */
    ohp_en_table_pptr[(UINT32)ODU_OHP_1] = digi_handle->var.enabled_otn_int->ohp_1;
    ohp_en_table_pptr[(UINT32)ODU_OHP_2] = digi_handle->var.enabled_otn_int->ohp_2;
    ohp_en_table_pptr[(UINT32)ODU_OHP_3] = digi_handle->var.enabled_otn_int->ohp_3;

    for (i = start_chnl; (i < end_chnl) && (PMC_SUCCESS == result) && (FALSE == *int_found_ptr); i++)
    {
        if (IS_DIGI_INT_ALL_CHNLS(chnl_handle))
        {
            chnl_ptr = &handle_pool_ptr[i];
        }
        else
        {
            chnl_ptr = chnl_handle;
        }


        if (util_global_is_chnl_prov(chnl_ptr))
        {

            pmc_bitarray_or(chnl_info.rfrm_int_summary.active_chnl_bitmask, int_summary_ptr->active_chnl_bitmask, DIGI_ODU_CHNLS_MAX);
            pmc_bitarray_or(chnl_info.rfrm_int_summary.active_pid_bitmask,  int_summary_ptr->active_pid_bitmask,  DIGI_ODU_PIDS_MAX);
            pmc_bitarray_or(chnl_info.rfrm_int_summary.active_int_bitmask,  int_summary_ptr->active_int_bitmask,  LAST_ODU_RFRM_INT_DEFECT);

            chnl_id = digi_otn_odu_chnl_num_internal_get(digi_handle, chnl_ptr);

            chnl_info.chnl_id = chnl_id;
            (void)digi_otn_pool_id_get(digi_handle, chnl_ptr, chnl_info.rx_pool_id); 
            (void)digi_otn_pool_id_get(digi_handle, chnl_ptr, chnl_info.rfrm_int_summary.pool_id); 

            /* Retrieve PRBS enabled table (and ignore return) */
            digi_otn_odu_int_prbs_is_prov(digi_handle,
                                          chnl_ptr,
                                          &prbs_chnl,
                                          &prbs_inst,
                                          &prbs_en_ptr);
            
            /* find PID */
            result = coreotn_int_chnl_enabled_check(coreotn_handle, 
                                                    &chnl_info,
                                                    &framer_en_ptr[chnl_id],
                                                    NULL,
                                                    prbs_en_ptr,
                                                    ohp_en_table_pptr,
                                                    &digi_handle->var.enabled_otn_int->ri_rcp[chnl_id],
                                                    int_found_ptr);


            if ((PMC_SUCCESS == result) && (FALSE == *int_found_ptr))
            {
                result = digi_otn_odu_int_ddeg_chnl_enabled_check(digi_handle,
                                                                  &chnl_info,
                                                                  ddeg_mon,
                                                                  &framer_en_ptr[chnl_id],
                                                                  int_found_ptr);    
            }
        }
    }

    PMC_RETURN(result);
} /* digi_otn_odu_int_chnl_stage_enabled_check */



/*******************************************************************************
* FUNCTION: digi_otn_odu_int_chnl_stage_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears interrupts based on bits that are set in the channelized 
*   interrupt table.
*
* INPUTS:
*   digi_handle       - pointer to DIGI handle instance.
*   chnl_handle       - pointer to channel handle to check interrupts
*   odu_level         - Indicates whether to check interrupts on HO/MO/LO
*   int_table_ptr     - pointer to channel interrupt table with bits set to
*                       clear interrupts. DIGI_INT_ALL_INTS to clear all interrupts.
*   clear_rfrm_only   - Flag that if true results in ODU RFRM interrupts 
*                       being cleared.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_chnl_stage_clear(digi_handle_t             *digi_handle,
                                                   digi_otn_odu_chnl_t       *chnl_handle,
                                                   odu_struct_odu_level_t     odu_level,
                                                   digi_otn_odu_int_chnl_t   *int_table_ptr,
                                                   BOOL8 clear_rfrm_only)

{
    PMC_ERROR                   result = PMC_SUCCESS;

    coreotn_int_chnl_info_t     chnl_info;
    coreotn_handle_t           *coreotn_handle;
    UINT32                      start_chnl = 0;
    UINT32                      end_chnl = 0;
    UINT32                      i;
    odu_struct_t               *handle_pool_ptr;
    UINT32                      blk_filter, stg3b_blk_filter;
    
    
    PMC_ENTRY();
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));

    if (PMC_SUCCESS == result)
    {
        /* Get range of channels to retrieve within ODU level */
        result = digi_otn_odu_int_link_range_get(digi_handle,
                                                 chnl_handle,
                                                 odu_level,
                                                 &start_chnl,
                                                 &end_chnl);
    }

    /* Get the pool pointer for ODU level */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_handle_pool_get(digi_handle, odu_level, &handle_pool_ptr);
    }

    /* determine from odu struct line or source */
    if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    { 
        chnl_info.source = COREOTN_INT_SOURCE_SYS; 
    }
    else
    {
        chnl_info.source = COREOTN_INT_SOURCE_LINE; 
    }


    /* Mark desired blocks for clearing */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_blk_filter_set(digi_handle,
                                             UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, status),
                                             &blk_filter);
    }
    
    /* Mark desired blocks for clearing Stage 3b */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_blk_filter_set(digi_handle,
                                             UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, stg3b),
                                             &stg3b_blk_filter);
    }

    coreotn_handle = digi_handle->coreotn_handle;

    for (i = start_chnl; (i < end_chnl) && (PMC_SUCCESS == result); i++)
    {
        chnl_info.chnl_id    = i;
        chnl_info.odu_level  = odu_level;
        chnl_info.blk_filter = blk_filter;

        if (FALSE == clear_rfrm_only)
        {
            result = coreotn_int_chnl_clear(coreotn_handle, 
                                            &chnl_info,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, status));
        }
        else
        {
            result = coreotn_rfrm_chnl_clear(coreotn_handle, 
                                             &chnl_info);
        }

        /* clear Stg 3b if needed */
         if ((PMC_SUCCESS == result) &&
             (TRUE == digi_otn_is_stg3b_present(digi_handle, (digi_otn_odu_chnl_t  *) &handle_pool_ptr[i])))
         {
             chnl_info.odu_level = ODU_STRUCT_LEVEL_3B_ODU;
             chnl_info.blk_filter = stg3b_blk_filter;
             if (FALSE == clear_rfrm_only)
             {
                 result = coreotn_int_chnl_clear(coreotn_handle, 
                                                 &chnl_info,
                                                 UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, stg3b));
             }
             else
             {
                 result = coreotn_rfrm_chnl_clear(coreotn_handle, 
                                                  &chnl_info);

             }
         }
    }

   
    PMC_RETURN(result);
} /* digi_otn_odu_int_chnl_stage_clear */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_chnl_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears interrupts based on bits that are set in the channel
*   interrupt table.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to clear interrupts on, or
*                     DIGI_INT_ALL_CHNLS to clear interrupts on all channels
*                     of the subsystem
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     clear interrupts. DIGI_INT_ALL_INTS to clear all interrupts.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_int_chnl_clear(digi_handle_t              *digi_handle,
                                             digi_otn_odu_chnl_t        *chnl_handle,
                                             digi_otn_odu_int_chnl_t    *int_table_ptr)
{
    PMC_ERROR               result = PMC_SUCCESS;
    UINT32                  i;
    UINT32                  num_odu;
    odu_struct_odu_level_t  odu_list[LAST_ODU_STRUCT_LEVEL];

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Get range of odu levels (HO/MO/LO) to enable */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_odu_range_get(digi_handle,
                                                chnl_handle,
                                                odu_list,
                                                &num_odu);
    }

    for (i = 0; (PMC_SUCCESS == result) && (i < num_odu); i++)
    {
        result = digi_otn_odu_int_chnl_stage_clear(digi_handle,
                                                   chnl_handle,
                                                   odu_list[i],
                                                   int_table_ptr,
                                                   FALSE);
    } 
    

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_odu_int_chnl_clear */

/*******************************************************************************
* FUNCTION: digi_otn_odu_rfrm_chnl_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  ODU RFRM interrupts are typically read to clear. However AC_API_I 
*  interrupt requires a separate clear operation.  It is defined as a 
*  separate API as it may affect other interrupt settings and should be 
*  only used if this is specifically required.
*  Since there is only one interrupt there is no interrupt table required.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - pointer to channel handle to clear interrupts on, or
*                     DIGI_INT_ALL_CHNLS to clear interrupts on all channels
*                     of the subsystem
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_rfrm_chnl_clear(digi_handle_t              *digi_handle,
                                              digi_otn_odu_chnl_t        *chnl_handle)
{
    PMC_ERROR               result = PMC_SUCCESS;
    UINT32                  i;
    UINT32                  num_odu;
    odu_struct_odu_level_t  odu_list[LAST_ODU_STRUCT_LEVEL];

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Get range of odu levels (HO/MO/LO) to enable */
    result = digi_otn_odu_int_odu_range_get(digi_handle,
                                            chnl_handle,
                                            odu_list,
                                            &num_odu);

    for (i = 0; PMC_SUCCESS == result && i < num_odu; i++)
    {
        result = digi_otn_odu_int_chnl_stage_clear(digi_handle,
                                                   chnl_handle,
                                                   odu_list[i],
                                                   NULL,
                                                   TRUE);
    } 
    

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_odu_rfrm_chnl_clear */


/*******************************************************************************
* FUNCTION: digi_otn_int_enabled_check_internal
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Searches enabled interrupt bits in all channels of the subsystem.
*
*   The callback associated with the aggregation interrupt type will be called
*   if an active interrupt is found in any channel. The callback will be
*   called a minimum of zero times if no active interrupts are found, or
*   a maximum of one time if there is an interrupt in at least one channel.
*
*   A callback must be registered for the interrupt type before this API
*   can be called.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*
*   
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_int_enabled_check_internal(digi_handle_t   *digi_handle)
{
    PMC_ERROR                    result = PMC_SUCCESS;
    BOOL                         int_found = FALSE;
    digi_otn_int_t              *int_en_table_ptr;

    PMC_ENTRY();
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == lineotn_start_state_test(digi_handle->lineotn_handle) &&
                                 TRUE == lineotn_start_state_test(digi_handle->sysotn_handle) &&
                                 TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    if (PMC_SUCCESS == result)
    {
        if(!digi_int_is_cb_registered(digi_handle, DIGI_INT_TYPE_OTN))
        {
            result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
        }
    }
    
    
    /* Get internal enabled aggregate interrupt table to update */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       DIGI_INT_TYPE_OTN,
                                       (void**) &int_en_table_ptr);

    }


    /* Check for active interrupts */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_top_enabled_check(digi_handle, 
                                            DIGI_INT_TYPE_OTN,
                                            &int_found);
    }

    /* enable interrupt caching, clear cache */
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, TRUE, TRUE);

    /* Check enabled interrupts for SYSOTN (digi_int_top_enabled_check does not check for SYS)*/
    if (PMC_SUCCESS == result && FALSE == int_found)
    {
        result = digi_otn_server_int_enabled_check_internal(digi_handle,
                                                            DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS,
                                                            DIGI_INT_ALL_CHNLS,
                                                            int_en_table_ptr,
                                                            &int_found);
    }
    /* disable interrupt caching */
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle,
                                 FALSE, FALSE);

    /* Check enabled interrupts for enh dDeg */
    if (PMC_SUCCESS == result && FALSE == int_found)
    {
        result = digi_otn_odu_int_ddeg_enabled_check(digi_handle, 
                                                     COREOTN_DDEG_MON_LINE,
                                                     &int_found);
    }

#ifdef PMC_SW_SIMULATION
    /* Force found interrupt for simulation so that callback runs */
    int_found = TRUE;
#endif

    if (PMC_SUCCESS == result && TRUE == int_found)
    {
        result = digi_int_callback_run(digi_handle, NULL, 
                                       DIGI_INT_TYPE_OTN);
    }

    PMC_RETURN(result);
} /* digi_otn_int_enabled_check_internal */

/*******************************************************************************
* digi_otn_pmon_ddeg_hw_blk_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the ddeg hw block to access.
*
* INPUTS:
*   *digi_handle        - pointer to digi handle instance
*   odu_frm_id          - pointer to ODU_STRUCT to be operated on
*   pm_tcm_num          - enum to determine if dDEG is on PM or TCMi layer.
*                         See odu_struct_odu_frm_pm_tcm_id_t.
*
* OUTPUTS:
*   *ddeg_hw_blk        - dDeg HW block to access
*
* RETURNS:
*   The Framer tsga e
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_pmon_ddeg_hw_blk_get(digi_handle_t *digi_handle,
                                                odu_struct_frm_id_t odu_frm_id,
                                                odu_struct_odu_frm_pm_tcm_id_t pm_tcm_num,
                                                digi_pmon_ddeg_hw_block_t *ddeg_hw_blk)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();
        
    /* find the correct framer */
    switch (odu_frm_id)
    {
        case ODU_STRUCT_FRM_STG1:
            if (pm_tcm_num == ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM)
            {
                *ddeg_hw_blk = DIGI_PMON_DDEG_COREOTN_STG_1_PM;
            }
            else 
            {
                *ddeg_hw_blk = DIGI_PMON_DDEG_COREOTN_STG_1_TCM;
            }
            break;

       case ODU_STRUCT_FRM_STGN:
            if (pm_tcm_num == ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM)
            {
                *ddeg_hw_blk = DIGI_PMON_DDEG_COREOTN_STG_N_PM;
            }
            else 
            {
                *ddeg_hw_blk = DIGI_PMON_DDEG_COREOTN_STG_N_TCM;
            }
            break;

        case ODU_STRUCT_FRM_STG2:
            if (pm_tcm_num == ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM)
            {
                *ddeg_hw_blk = DIGI_PMON_DDEG_COREOTN_STG_2_PM;
            }
            else 
            {
                *ddeg_hw_blk = DIGI_PMON_DDEG_COREOTN_STG_2_TCM;
            }      
            break;
        case ODU_STRUCT_FRM_STG3A:
        case ODU_STRUCT_FRM_STG4:
            /* stage 3a and 4 */
            if (pm_tcm_num == ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM)
            {
                *ddeg_hw_blk = DIGI_PMON_DDEG_COREOTN_STG_3A_4_PM;
            }
            else 
            {
                *ddeg_hw_blk = DIGI_PMON_DDEG_COREOTN_STG_3A_4_TCM;
            }  
            break;
        case ODU_STRUCT_FRM_STG3B:
        default:
            *ddeg_hw_blk = DIGI_PMON_DDEG_HW_BLOCK_MAX_NUM;
            break;
    }
    
    PMC_RETURN(result);
} /* digi_otn_pmon_ddeg_hw_blk_get */

/*******************************************************************************
* FUNCTION: digi_otn_otu_handle_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   return the line or sys OTN handle based on the OTN server channel definition 
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   *otn_server_ptr - Pointer to a resource allocation
*                     context for the OTN server configured against the
*
* OUTPUTS:
*    hndl_pptr      - pointer to line or sys OTN handle
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.   
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_otu_handle_get(digi_handle_t               *digi_handle,
                                          digi_otn_server_chnl_def_t  *otn_server_ptr,
                                          lineotn_handle_t           **hndl_pptr)
{
    PMC_ERROR result;
    PMC_ENTRY();

    *hndl_pptr = NULL;

    /* check that (SYS)OTN server handle belongs to digi context */          
    if (NULL == otn_server_ptr)
    {
        /*
         * Return immediately from here to ensure that of otn_server_ptr
         * is NULL it is not processed later.
         */
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }
    result = digi_otn_server_chnl_handle_validate(digi_handle, otn_server_ptr);        
    if (PMC_SUCCESS != result)
    {
        result = digi_sysotn_server_chnl_handle_validate(digi_handle, otn_server_ptr);             
    }
    
    if (PMC_SUCCESS != result) 
    { 
        result = digi_sysotn_server_chnl_handle_validate(digi_handle, otn_server_ptr);
    }
    
    if (PMC_SUCCESS == result) 
    { 
        *hndl_pptr = otn_server_ptr->sys_line_src == FALSE?digi_handle->lineotn_handle:digi_handle->sysotn_handle;    
    }

    PMC_RETURN(result);
} /*digi_otn_otu_handle_get */

/*******************************************************************************
* FUNCTION: digi_otn_server_stream_is_10g()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Takes an OTN server chnl handle and returns TRUE if it is provisioned with
*   a 10G datapath.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - OTN server channel handle
*
* OUTPUTS:
*
* RETURNS:
*   TRUE     - TRUE 10G datapath
*   FALSE    - FALSE if not 10G datapath
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_stream_is_10g(digi_handle_t           *digi_handle,
                                               digi_otn_server_chnl_t  *chnl_handle)
{
    digi_otn_server_chnl_def_t  *chnl_def_handle;
    BOOL                        result = FALSE;



    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    chnl_def_handle = (digi_otn_server_chnl_def_t *) chnl_handle;

    switch (chnl_def_handle->oduk_type)
    {
      case UTIL_GLOBAL_ODU0:
      case UTIL_GLOBAL_ODU1:
      case UTIL_GLOBAL_ODU1E:
      case UTIL_GLOBAL_ODU1F:
      case UTIL_GLOBAL_ODU2:
      case UTIL_GLOBAL_ODU2E:
      case UTIL_GLOBAL_ODU2F:
      case UTIL_GLOBAL_ODUFLEX_CBR:
      case UTIL_GLOBAL_ODUFLEX_GFP:
      case UTIL_GLOBAL_ODU1E_ETRANS:
      case UTIL_GLOBAL_ODU2E_ETRANS:
        result = TRUE;
        break;


      default:
        result = FALSE;
        break;
    } /* end switch */
    


    PMC_RETURN(result);
} /* digi_otn_server_stream_is_10g */


/*******************************************************************************
* FUNCTION: digi_otn_server_stream_is_40g()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Takes an OTN server chnl handle and returns TRUE if it is provisioned with
*   a 40G datapath.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - OTN server channel handle
*
* OUTPUTS:
*
* RETURNS:
*   TRUE     - TRUE 40G datapath
*   FALSE    - FALSE if not 40G datapath
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_stream_is_40g(digi_handle_t           *digi_handle,
                                               digi_otn_server_chnl_t  *chnl_handle)
{
    digi_otn_server_chnl_def_t  *chnl_def_handle;
    BOOL                        result = FALSE;



    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    chnl_def_handle = (digi_otn_server_chnl_def_t *) chnl_handle;

    switch (chnl_def_handle->oduk_type)
    {
      case UTIL_GLOBAL_ODU3:
      case UTIL_GLOBAL_ODU3E1:
      case UTIL_GLOBAL_ODU3E2:
        result = TRUE;
        break;


      default:
        result = FALSE;
        break;
    } /* end switch */
    


    PMC_RETURN(result);
} /* digi_otn_server_stream_is_40g */



/*******************************************************************************
* FUNCTION: digi_otn_server_stream_is_100g()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Takes an OTN server chnl handle and returns TRUE if it is provisioned with
*   a 100G datapath.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - OTN server channel handle
*
* OUTPUTS:
*
* RETURNS:
*   TRUE     - TRUE 100G datapath
*   FALSE    - FALSE if not 100G datapath
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_stream_is_100g(digi_handle_t           *digi_handle,
                                                digi_otn_server_chnl_t  *chnl_handle)
{
    digi_otn_server_chnl_def_t  *chnl_def_handle;
    BOOL                        result = FALSE;



    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    chnl_def_handle = (digi_otn_server_chnl_def_t *) chnl_handle;

    switch (chnl_def_handle->oduk_type)
    {
      case UTIL_GLOBAL_ODU4:
        result = TRUE;
        break;
        

      default:
        result = FALSE;
        break;
    } /* end switch */
    


    PMC_RETURN(result);
} /* digi_otn_server_stream_is_100g */




/*******************************************************************************
* FUNCTION: digi_otn_remove_nominal_replacement
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This disables nominal replacement in the TX path (nominal replacement
*  is required for OCI, the nominal replacement needs to be removed
*  when the maintenance signal is removed.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_ptr         - OTN channel handle (HO or LO)
*
* OUTPUTS:
*
* RETURNS:
*  PMC_ERROR 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_remove_nominal_replacement(digi_handle_t *digi_handle,
                                                      odu_struct_t *odu_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT8 acb_inst = 0, ckctl_port_addr = 0, mpmo_proc_type = 0;
    digi_opsa_mpmo_target_t target = LAST_DIGI_OPSA_MPMO_TARGET;
    hostmsg_opsa_subsystem_cfg_t output_mpmo_ss = LAST_OPSA_HOSTMSG_SS; /* initialize to illegal value */
    digi_serdes_intf_t intf;

    digi_serdes_port_rate_prov_state_t serdes_prov_status;
    
    
    util_global_switch_data_def_t *pc_data_ptr = (util_global_switch_data_def_t *)odu_ptr;
    util_global_oduk_port_data_t *local_pc_ptr = &pc_data_ptr->oduk_data; 
    digi_otn_server_chnl_def_t *otn_server_ptr = NULL;

    BOOL facility_loopback_en;
    BOOL nominal_unchannelized_tx;
    BOOL remove_nominal;
    BOOL ho_unchannelized;
    BOOL oduksw_inactive;

    PMC_ENTRY();

    /*remove nominal replacement*/


    ho_unchannelized = DIGI_IS_ODU_CHNL_HO_UNCHANNELIZED(digi_handle, odu_ptr);
    
    /* If HO unchannelized it's nessecary to check OCI and facility loopback
    state before removing nominal replacment (if either is provisioned, then nominal
    replacement must stay provisioned*/
    if(ho_unchannelized)
    {
        switch(local_pc_ptr->port_type)
        {
        case UTIL_GLOBAL_ODUK_PORT_ILKN1:
            if(digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
            {
                /* ODUKSW port used by LINEOTN -> HO -> ODUKSW */
                /* LINEOTN channel handle is used by COREOTN_CTL */
                otn_server_ptr = &(digi_handle->handle_pool.otn_server_chnl[(local_pc_ptr->channel)]);
            } else 
            {
                /* that is an invalid case in non-sysotn mode */
                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
            }
            break;
        case UTIL_GLOBAL_ODUK_PORT_COREOTN:
            if(digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
            {
                /* ODUKSW port used by LINEOTN -> HO -> ODUKSW */
                otn_server_ptr = &(digi_handle->handle_pool.sysotn_server_chnl);             
            } else {
                PMC_ASSERT(local_pc_ptr->channel < DIGI_OTN_SERVER_CHNL_MAX, DIGI_ERR_CODE_ASSERT, 0, 0);
                /* LINEOTN channel handle is used by COREOTN_FO1 */
                otn_server_ptr = &(digi_handle->handle_pool.otn_server_chnl[(local_pc_ptr->channel)]);
            }
            break;
        default:
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        }

        /*get serdes prov state*/
        serdes_prov_status  = digi_serdes_port_prov_status_get(digi_handle,
                                                               otn_server_ptr->port_uid);
        
        if(serdes_prov_status == DIGI_SERDES_PORT_RATE_STATE_PROV_FACILITY_LPBK)
        {
            facility_loopback_en = TRUE;
        }
        else
        {
            facility_loopback_en = FALSE;
        }

        nominal_unchannelized_tx = digi_otn_nominal_tx_unchannelized_get(digi_handle,
                                                                         odu_ptr);
        
        oduksw_inactive = (odu_ptr->switch_data.oduk_data.op_state.active_state != UTIL_GLOBAL_CHNL_ACTIVE_STATE_ACTIVE);

        /*only remove nominal replacement on a HO UNCHANNELIZED channel if
        not OCI in being inserted in TX, and no facility loopback is being
        applied*/
        if(facility_loopback_en || nominal_unchannelized_tx || oduksw_inactive)
        {
            remove_nominal = FALSE;
        }
        else
        {
            remove_nominal = TRUE;
        }
    }
    else
    {
        oduksw_inactive = (odu_ptr->switch_data.oduk_data.op_state.active_state != UTIL_GLOBAL_CHNL_ACTIVE_STATE_ACTIVE);

        nominal_unchannelized_tx = digi_otn_nominal_tx_unchannelized_get(digi_handle,
                                                                         odu_ptr);

        if(oduksw_inactive || nominal_unchannelized_tx)
        {
            remove_nominal = FALSE;
        }
        else
        {
            remove_nominal = TRUE;
        }
    }

    if(remove_nominal)
    {
        if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_LO_ODU &&
           DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
        {
            output_mpmo_ss = OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_CTL;        
        }
        else
        {
            output_mpmo_ss = OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_FO1;     
        }


        /* use odu_level to determine the target */
        switch(odu_ptr->mem_ptr->odu_level)
        {
            case ODU_STRUCT_LEVEL_HO_ODU:
                /* collect Interface and ACB instance data for cases where ACB connected */
                digi_otn_acb_ckctl_get(digi_handle,
                                       odu_ptr,
                                       &intf,
                                       &acb_inst,
                                       &ckctl_port_addr);
                
                switch(intf)
                {
                case DIGI_SERDES_LINE_INTF:
                    target = DIGI_OPSA_MPMO_TARGET_ACB_LINE;
                    break;
                case DIGI_SERDES_SYSTEM_INTF:
                    target = DIGI_OPSA_MPMO_TARGET_ACB_SYS;
                    break;
                case DIGI_SERDES_SFI_51_INTF:
                    target = DIGI_OPSA_MPMO_TARGET_ACB_SFI51;
                    break;
                default:
                    PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                    break;
                }

                break;
            case ODU_STRUCT_LEVEL_MO_ODU:
                if(digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
                {
                    target = DIGI_OPSA_MPMO_TARGET_TS_STAGE_2;
                } else {
                    target = DIGI_OPSA_MPMO_TARGET_TS_STAGE_1;
                }
                break;
            case ODU_STRUCT_LEVEL_LO_ODU:
                if (digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD && 
                    output_mpmo_ss == OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_CTL)
                {
                    /* collect Interface and ACB instance data for cases where ACB connected */
                    digi_otn_acb_ckctl_get(digi_handle,
                                           odu_ptr,
                                           &intf,
                                           &acb_inst,
                                           &ckctl_port_addr);
                    
                    switch(intf)
                    {
                    case DIGI_SERDES_LINE_INTF:
                        target = DIGI_OPSA_MPMO_TARGET_ACB_LINE;
                        break;
                    case DIGI_SERDES_SYSTEM_INTF:
                        target = DIGI_OPSA_MPMO_TARGET_ACB_SYS;
                        break;
                    case DIGI_SERDES_SFI_51_INTF:
                        target = DIGI_OPSA_MPMO_TARGET_ACB_SFI51;
                        break;
                    default:
                        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                        break;
                    }
                    
                } else {
                    target = DIGI_OPSA_MPMO_TARGET_TS_STAGE_2;
                }
                break;
            case ODU_STRUCT_LEVEL_3B_ODU:
            case ODU_STRUCT_LEVEL_4_ODU:
            case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
            default:
                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                break;
        }

        mpmo_proc_type = FALSE;                    

        digi_opsa_cfg_mpmo_one_port_add(digi_handle,
                                        output_mpmo_ss,
                                        odu_ptr->switch_data.oduk_data.channel,
                                        target,
                                        acb_inst,
                                        ckctl_port_addr,
                                        mpmo_proc_type,
                                        FALSE,
                                        0,
                                        0,
                                        FALSE);

        /*
         * If removing nominal then set the FIFO_CLRB high.  After it is
         * moved from nominal it will set to low.
         */
        coreotn_mpmo_fifo_clear(digi_handle->coreotn_handle,
                                0,
                                odu_ptr);
    } /* if(remove_nominal) */



    PMC_RETURN(result);
} /* digi_otn_remove_nominal_replacement */


/*******************************************************************************
* FUNCTION: digi_cpb_update_nominal_replacement
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Updates the nominal settings for the input and output resources where
*  applicable.
*
* INPUTS:
*  digi_handle     - Pointer to digi handle
*  port_uid        - The serdes port for this channel handle.
*  switch_data_ptr - ENET LINE/SYS or CBRC channel handle
*  action          - OPSA operation being requested. Only  ACTIVATE (add)
*                    or DEACTIVATE(drop) are supported.
*  is_loopback     - Whether this is called from perspective of loopback
*                    removal (TRUE) or fault pattern removal (FALSE).
*
* OUTPUTS:
*
* RETURNS:
*  PMC_ERROR 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_update_nominal_replacement(digi_handle_t *digi_handle,
                                                     UINT32 port_uid,
                                                     util_global_switch_data_def_t *switch_data_ptr,
                                                     digi_opsa_cfg_action_t action,
                                                     BOOL8 is_loopback)
{
    UINT8 acb_inst = 0;
    UINT8 ckctl_port_addr = 0;
    UINT8 fo2_ckctl_port_addr = 0;
    BOOL8 is_bmp_mode = FALSE;
    digi_opsa_mpmo_target_t target = LAST_DIGI_OPSA_MPMO_TARGET;
    hostmsg_opsa_subsystem_cfg_t output_mpmo_ss = LAST_OPSA_HOSTMSG_SS;
    digi_serdes_intf_t intf;
    BOOL8 update_nominal = TRUE;
    BOOL8 cbrc_monitor = FALSE;
    hostmsg_opsa_subsystem_cfg_t input_fo2_ss = LAST_OPSA_HOSTMSG_SS;
    UINT32 input_fo2_chnl = 0;

    PMC_ENTRY();

    /*
     * Only valid actions are activate and deactivate. If that is not the
     * case then return and error.
     */
    if (!(DIGI_OPSA_CFG_ACTION_ACTIVATE == action ||
          DIGI_OPSA_CFG_ACTION_DEACTIVATE == action))
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    update_nominal = digi_cpb_retrieve_mpmo_data(digi_handle,
                                                 port_uid,
                                                 switch_data_ptr,
                                                 action,
                                                 is_loopback,
                                                 &output_mpmo_ss,
                                                 &cbrc_monitor,
                                                 &input_fo2_ss,
                                                 &input_fo2_chnl,
                                                 &is_bmp_mode);

    if (FALSE == update_nominal)
    {
        PMC_RETURN(PMC_SUCCESS);
    }
    /*
     * If here confirmation of the data path and whether or not add/drop
     * can be performed has been verified.  Need to retrieve ACB related
     * information which is done regardless of the operation being
     * performed.
     */
    digi_non_otn_acb_ckctl_get(digi_handle,
                               (util_global_switch_data_t *)switch_data_ptr,
                               &intf,
                               &acb_inst,
                               &ckctl_port_addr,
                               &fo2_ckctl_port_addr);
    
    switch(intf)
    {
      case DIGI_SERDES_LINE_INTF:
        target = DIGI_OPSA_MPMO_TARGET_ACB_LINE;
        break;
      case DIGI_SERDES_SYSTEM_INTF:
        target = DIGI_OPSA_MPMO_TARGET_ACB_SYS;
        break;
      case DIGI_SERDES_SFI_51_INTF:
        target = DIGI_OPSA_MPMO_TARGET_ACB_SFI51;
        break;
      default:
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        break;
    }

    if (DIGI_OPSA_CFG_ACTION_ACTIVATE == action)
    {
        /*
         * Add back in the OPSA FW for the client and include the Fo2 
         * related data.
         * Note: is_bmp_mode is set to TRUE in digi_otn_set_input_fo2 if 
         * MAPOTN uses a BMP mode otherwise should be FALSE.. 
         * If here then the output_mpmo_ss is  either CBRC, ENET LINE or 
         * ENET SYS
         */
        digi_opsa_cfg_mpmo_one_port_add(digi_handle,
                                        output_mpmo_ss,
                                        switch_data_ptr->cpb_data.channel,
                                        target,
                                        acb_inst,
                                        ckctl_port_addr,
                                        is_bmp_mode,
                                        cbrc_monitor,
                                        input_fo2_chnl,
                                        fo2_ckctl_port_addr,
                                        FALSE);
        
   
        if (LAST_OPSA_HOSTMSG_SS != input_fo2_ss)
        {
            /*
             * If the input has been set and MAPOTN MODE is not BMP then
             * add FW OPSA.
             */
            digi_opsa_cfg_mpmo_one_port_add(digi_handle,
                                            input_fo2_ss,
                                            input_fo2_chnl,
                                            target,
                                            acb_inst,
                                            fo2_ckctl_port_addr,
                                            FALSE,
                                            FALSE,
                                            0,
                                            0,
                                            FALSE);
        }
    }
    else
    {
        digi_opsa_cfg_mpmo_one_port_drop(digi_handle,
                                         output_mpmo_ss,
                                         switch_data_ptr->cpb_data.channel);

        if (LAST_OPSA_HOSTMSG_SS != input_fo2_ss)
        {
            digi_opsa_cfg_mpmo_one_port_drop(digi_handle,
                                             input_fo2_ss,
                                             input_fo2_chnl);
        }
    }
    PMC_RETURN(PMC_SUCCESS);
} /* digi_cpb_update_nominal_replacement */

/*******************************************************************************
* FUNCTION: digi_cpb_retrieve_mpmo_data
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Retrieves MPMO related data used by the caller to determine whether 
*  OPSA drop or add need be applied.  Centrix to CPB related connections.
*
* INPUTS:
*  digi_handle     - Pointer to digi handle
*  port_uid        - The serdes port for this channel handle.
*  switch_data_ptr - ENET LINE/SYS or CBRC channel handle
*  action          - OPSA operation being requested. Only  ACTIVATE (add)
*                    or DEACTIVATE(drop) are supported.
*  is_loopback     - Whether this is called from perspective of loopback
*                    removal (TRUE) or fault pattern removal (FALSE).
*
* OUTPUTS:
*  output_mpmo_ptr   - Reference to the output MPMO OPSA subsystem.
*  cbrc_monitor_ptr   - Reference set to TRUE if OUTPUT is CBRC and the
*                       mode is FC_1200 GFP. Otherwise FALSE.
*  input_fo2_ptr      - Set if the iput is F02 either MAPOTN directly or
*                       ENET as part of ETRANS.
*  input_fo2_chnl_ptr - Input F02 channel value.
*  is_bmp_ptr         - Whether FO2 is using a BMP mapping mode.
*
* RETURNS:
*  PMC_ERROR 
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 digi_cpb_retrieve_mpmo_data(digi_handle_t *digi_handle,
                                         UINT32 port_uid,
                                         util_global_switch_data_def_t *switch_data_ptr,
                                         digi_opsa_cfg_action_t action,
                                         BOOL8 is_loopback,
                                         hostmsg_opsa_subsystem_cfg_t *output_mpmo_ptr,
                                         BOOL8 *cbrc_monitor_ptr,
                                         hostmsg_opsa_subsystem_cfg_t *input_fo2_ptr,
                                         UINT32 *input_fo2_chnl_ptr,
                                         BOOL8 *is_bmp_ptr)
{
    BOOL8 update_nominal = TRUE;
    util_global_switch_data_t *input_ptr = NULL;
    BOOL8 mpmo_cfg = FALSE;
    digi_mapping_mode_t mode = LAST_DIGI_MAP;

    PMC_ENTRY();

    /*
     * If doing a nomrinal replacement, add operation, then it is not valid
     * if there is a facility looopback in place.
     */
    if (DIGI_OPSA_CFG_ACTION_ACTIVATE == action)
    {
        digi_serdes_port_rate_prov_state_t serdes_prov_status = 
          digi_serdes_port_prov_status_get(digi_handle, port_uid);
        /*
         * Only remove nominal replacement if channel is active at the CPB
         * and not facility loopback is applied.
         */
        if(serdes_prov_status == DIGI_SERDES_PORT_RATE_STATE_PROV_FACILITY_LPBK ||
           UTIL_GLOBAL_CHNL_ACTIVE_STATE_ACTIVE != switch_data_ptr->cpb_data.op_state.active_state)
        {
            PMC_RETURN(FALSE);
        }
    }
    /*
     * Retrieve the input pointer which determines whether the drop/add 
     * operation will need to occur on this resource or not.
     */
    input_ptr = digi_cpb_input_port_get(digi_handle, 
                                        (util_global_switch_data_t *)switch_data_ptr);            

    if (NULL != input_ptr)
    {
        switch (((util_global_switch_data_def_t *)input_ptr)->cpb_data.port_type)
        {
          case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
            if (1 == ((util_global_switch_data_def_t *)input_ptr)->cpb_data.data_source)
            {
                digi_otn_set_input_fo2(digi_handle,
                                       input_ptr,
                                       &mode,
                                       input_fo2_ptr,
                                       input_fo2_chnl_ptr,
                                       is_bmp_ptr);
            }
            break;
            
          case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
          case UTIL_GLOBAL_CPB_PORT_CBRC:
            break;
            
          case UTIL_GLOBAL_CPB_PORT_MAPOTN:
            /*
             * Check map_mode and ensure it is not BMP. If it is then Fo2
             * was never dropped and is not added.
             */      
            digi_otn_set_input_fo2(digi_handle,
                                   input_ptr,
                                   &mode,
                                   input_fo2_ptr,
                                   input_fo2_chnl_ptr,
                                   is_bmp_ptr);
            break;
            
          default:
            break;
        }
    }

    switch (switch_data_ptr->cpb_data.port_type)
    {
      case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
        (void)enet_mpmo_cfg_get(digi_handle->enet_line_handle,
                                switch_data_ptr->cpb_data.channel,
                                &mpmo_cfg);

        if (FALSE == mpmo_cfg)
        {
            update_nominal = FALSE;
        }
        else
        {
            *output_mpmo_ptr = OPSA_HOSTMSG_CPB_SS_ENET_LINE;
        }
        break;

     case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
        (void)enet_mpmo_cfg_get(digi_handle->enet_sys_handle,
                                switch_data_ptr->cpb_data.channel,
                                &mpmo_cfg);

        if (FALSE == mpmo_cfg)
        {
            update_nominal = FALSE;
        }
        else
        {
            *output_mpmo_ptr = OPSA_HOSTMSG_CPB_SS_ENET_SYS;
        }
        break;
        
      case UTIL_GLOBAL_CPB_PORT_CBRC:
        /*
         * Check that the nominal fault has been set, namely FW OPSA
         * drop was applied to this channel. If FALSE there is nothing
         * to do.
         */
        (void)cbrc_mpmo_cfg_get(digi_handle->cbrc_handle,
                                switch_data_ptr->cpb_data.channel,
                                &mpmo_cfg);
        /*
         * If the CBRC mode is not such that MPMO should be dropped then 
         * thereis nothing to do.
         */
        if (FALSE == mpmo_cfg)
        {
            PMC_RETURN(FALSE);
        }
        /*
         * If this is an ADD operation, namely replacing nominal, then
         * need to confirm that the nominal setting was done.
         * If so need to check whether a CBR pattern is still active. If
         * so cannot remove nominal.
         */
        if (DIGI_OPSA_CFG_ACTION_ACTIVATE == action && 
            TRUE == digi_cbr_nominal_fault_get(digi_handle,
                                               switch_data_ptr->cpb_data.channel))
        {
            /*
             * The unsetting of the loopback mode occurs before the call
             * to replace nominal. Whereas the fault pattern is updated 
             * only after replacing nominal.  Thus if this is the loopback
             * update calling need to check the fault pattern before
             * determining whether it is safe to remove nominal. 
             */
            if (TRUE == is_loopback)
            {
                BOOL enable = FALSE;
                cbr_fsgm_user_fault_pattern_t pattern = LAST_CBR_FSGM_USER_FAULT_PATTERN;

                (void)digi_cbr_fsgm_user_fault_pattern_get(digi_handle,
                                                           (digi_cbr_client_chnl_t *)switch_data_ptr,
                                                           CBRC_PORT_DIR_TX,
                                                           &pattern);
                /*
                 * Confirm that there is a pattern that has been set and then
                 * retrieve whether or not it is active.
                 */
                if (CBR_FSGM_USER_FAULT_PATTERN_NONE != pattern)
                {
                    (void)digi_cbr_fsgm_fault_force_get(digi_handle,
                                                        (digi_cbr_client_chnl_t *)switch_data_ptr,
                                                        CBRC_PORT_DIR_TX,
                                                        &enable);
                    
                }
                /*
                 * For CBRC channel handle need to check whether a fault
                 * pattern has been configured and enabled. If so cannot
                 * remove nominal replacement.
                 */
                if (TRUE == enable)
                {
                    update_nominal = FALSE;
                }
            }

            if (TRUE == update_nominal)
            {
                *output_mpmo_ptr = OPSA_HOSTMSG_CPB_SS_CBRC;

                if (DIGI_MAP_ODU2EP_FC_1200_GFP == mode)
                {
                    *cbrc_monitor_ptr = TRUE;
                }
                digi_cbr_nominal_fault_set(digi_handle,
                                           switch_data_ptr->cpb_data.channel,
                                           FALSE);
            }
        }
        else if (DIGI_OPSA_CFG_ACTION_DEACTIVATE == action &&
                 FALSE == digi_cbr_nominal_fault_get(digi_handle,
                                                     switch_data_ptr->cpb_data.channel))
        {
            /*
             * In this case dropping OPSA signal and need to confirm that
             * it has not already been done.
             */
            *output_mpmo_ptr = OPSA_HOSTMSG_CPB_SS_CBRC;
            digi_cbr_nominal_fault_set(digi_handle,
                                       switch_data_ptr->cpb_data.channel,
                                       TRUE);
        }
        else
        {
            /*
             * If here things are not aligned. Set the update_nominal flag
             * to false resulting in the function execution terminating and
             * no OPSA updates.
             */
            update_nominal = FALSE;
        }
        break;

      case UTIL_GLOBAL_CPB_PORT_MAPOTN:
        /*
         * Not sure what is reuqired here for MAPOTN.  It is configured as
         * part of digi_opsa_oduksw_activate_cfg however this is adding
         * back which should have been removed. For now leaving out.
         */
        update_nominal = FALSE;
        break;


      default:
        update_nominal = FALSE;
        break;
    }

    PMC_RETURN(update_nominal);
} /* digi_cpb_retrieve_mpmo_data */

/*******************************************************************************
* FUNCTION: digi_cpb_retrieve_mpma_data
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Retrieves MPMA related data. If returns TUR then the data is valid and
*  MPMA add can be safely called.
*
* INPUTS:
*  digi_handle     - Pointer to digi handle
*  port_uid        - The serdes port for this channel handle.
*  switch_data_ptr - ENET LINE/SYS or CBRC channel handle
*  action          - OPSA operation being requested. Only  ACTIVATE (add)
*                    or DEACTIVATE(drop) are supported.
*
* OUTPUTS:
*  input_mpma_ptr     - Subsystem of the MPMA
*  input_chnl_ptr     - Subsystem channel for this MPMA
*  qs_ch_en_ptr       - QS Channel enable reference    
*
* RETURNS:
*  PMC_ERROR 
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 digi_cpb_retrieve_mpma_data(digi_handle_t *digi_handle,
                                         UINT32 port_uid,
                                         util_global_switch_data_def_t *switch_data_ptr,
                                         digi_opsa_cfg_action_t action,
                                         hostmsg_opsa_subsystem_cfg_t *input_mpma_ptr,
                                         UINT32 *input_chnl_ptr,
                                         UINT8 *qs_ch_en_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    util_global_switch_data_t *input_ptr = NULL;
    digi_mapping_mode_t mode = LAST_DIGI_MAP;
    digi_serdes_acb_mode_t acb_timing_mode = DIGI_SERDES_ACB_MODE_NOMINAL;
    digi_enet_mode_t enet_mode;
    BOOL8 slave_primary = FALSE;
    util_global_cpb_connect_t *cpb_connect_data_ptr = NULL;

    PMC_ENTRY();

    /*
     * If doing a nomrinal replacement, add operation, then it is not valid
     * if there is a facility looopback in place.
     */
    if (DIGI_OPSA_CFG_ACTION_ACTIVATE == action)
    {
        digi_serdes_port_rate_prov_state_t serdes_prov_status = 
          digi_serdes_port_prov_status_get(digi_handle, port_uid);
        /*
         * Only remove nominal replacement if channel is active at the CPB
         * and not facility loopback is applied.
         */
        if(serdes_prov_status == DIGI_SERDES_PORT_RATE_STATE_PROV_FACILITY_LPBK ||
           UTIL_GLOBAL_CHNL_ACTIVE_STATE_ACTIVE != switch_data_ptr->cpb_data.op_state.active_state)
        {
            PMC_RETURN(FALSE);
        }
    }
    /*
     * Retrieve the input pointer which determines whether the drop/add 
     * operation will need to occur on this resource or not.
     */
    input_ptr = digi_cpb_input_port_get(digi_handle, 
                                        (util_global_switch_data_t *)switch_data_ptr);  

    if (NULL == input_ptr)
    {
        PMC_RETURN(FALSE);
    }
    /*
     * If the output pointer is not the primary reader and this is an
     * activate then there is no MPMA to add in this case.
     */
    cpb_connect_data_state_get(digi_handle->dcpb_handle,
                               &cpb_connect_data_ptr);

    if (FALSE == cpb_connect_data_ptr->chnl[(UINT32)switch_data_ptr->cpb_data.port_type][(UINT32)switch_data_ptr->cpb_data.channel].mst.is_reader_primary &&
        DIGI_OPSA_CFG_ACTION_ACTIVATE == action)
    {
        PMC_RETURN(FALSE);
    }
    else if (FALSE == cpb_connect_data_ptr->chnl[(UINT32)switch_data_ptr->cpb_data.port_type][(UINT32)switch_data_ptr->cpb_data.channel].mst.is_reader_primary &&
             DIGI_OPSA_CFG_ACTION_DEACTIVATE == action &&
             TRUE == cpb_connect_data_ptr->chnl[(UINT32)switch_data_ptr->cpb_data.port_type][(UINT32)switch_data_ptr->cpb_data.channel].mst.is_slave_zone_primary)
    {
        /*
         * Set the slave zone primrary to true which handles this special
         * case. A mpma_add occurs even though this is a deactivate 
         * except the QS_CH_EN value is set differently.
         */
        slave_primary = TRUE;
    }
    /*
     * Initialize to a default value before starting
     */
    *input_mpma_ptr = LAST_OPSA_HOSTMSG_SS;

    switch (((util_global_switch_data_def_t *)input_ptr)->cpb_data.port_type)
    {
      case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
        if (1 == ((util_global_switch_data_def_t *)input_ptr)->cpb_data.data_source)
        {
            /*
             * If data source is 1 then this is actually a MAPOTN channel
             * with enet_line inline in the MAPOTN datapath.
             */
            mode = ((digi_mapper_chnl_def_t *)input_ptr)->mode;
            result = digi_mapotn_data_src_acb_mode_find(digi_handle, mode,
                                                        &acb_timing_mode);
            
            if (PMC_SUCCESS == result && 
                DIGI_SERDES_ACB_MODE_NOMINAL != acb_timing_mode)
            {
                *input_mpma_ptr = OPSA_HOSTMSG_CPB_SS_ENET_LINE;
            }
        }
        else
        {
            enet_mode = ((digi_enet_client_chnl_def_t *)input_ptr)->mode;
            result = digi_enet_data_src_acb_mode_find(digi_handle, 
                                                      enet_mode,
                                                      &acb_timing_mode);

            if(PMC_SUCCESS == result &&
               acb_timing_mode != DIGI_SERDES_ACB_MODE_NOMINAL &&
               enet_mode != DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT &&
               enet_mode != DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT_RX_PMON)
            {
                *input_mpma_ptr = OPSA_HOSTMSG_CPB_SS_ENET_LINE;
            }
        }

        break;
            
      case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
        enet_mode = ((digi_enet_client_chnl_def_t *)input_ptr)->mode;
        result = digi_enet_data_src_acb_mode_find(digi_handle, enet_mode,
                                                  &acb_timing_mode);

        if(PMC_SUCCESS == result &&
           acb_timing_mode != DIGI_SERDES_ACB_MODE_NOMINAL &&
           enet_mode != DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT &&
           enet_mode != DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT_RX_PMON)
        {
            *input_mpma_ptr = OPSA_HOSTMSG_CPB_SS_ENET_SYS;
        }
        break;
      case UTIL_GLOBAL_CPB_PORT_CBRC:
        /*
         * If CBRC is not connected to MAPOTN or if it is and the 
         * mapping mode is not FC_1200_GFP then set the input_mpma_ptr
         * to CBRC
         */
        if (UTIL_GLOBAL_CPB_PORT_MAPOTN != switch_data_ptr->cpb_data.port_type ||
            DIGI_MAP_ODU2EP_FC_1200_GFP != 
            ((digi_mapper_chnl_def_t *)input_ptr)->mode)
        {
            *input_mpma_ptr = OPSA_HOSTMSG_CPB_SS_CBRC;
        }
        break;
        
      case UTIL_GLOBAL_CPB_PORT_MAPOTN:
        mode = ((digi_mapper_chnl_def_t *)input_ptr)->mode;
        /*
         * If FC_1200_GFP is not the mode and the acb_timing is not
         * nominal then MPMA can be updated.
         */
        if (DIGI_MAP_ODU2EP_FC_1200_GFP != mode)
        {
            result = digi_mapotn_data_src_acb_mode_find(digi_handle, 
                                                        mode,
                                                        &acb_timing_mode);
            
            if (PMC_SUCCESS == result && 
                DIGI_SERDES_ACB_MODE_NOMINAL != acb_timing_mode)
            {
                *input_mpma_ptr = OPSA_HOSTMSG_CPB_SS_MAPOTN;
            }
        }
        break;
        
      default:
        break;
    }


    if (LAST_OPSA_HOSTMSG_SS != *input_mpma_ptr)
    {
        /*
         * The input_mpma is valid.  Set the input channel and then 
         * retrieve the QS channel enable value.
         */
        *input_chnl_ptr = ((util_global_switch_data_def_t *)input_ptr)->cpb_data.channel;

        cpb_slv_chnl_qs_ch_en_get(digi_handle->dcpb_handle,
                                  ((util_global_switch_data_def_t *)input_ptr)->cpb_data.port_type,
                                  *input_chnl_ptr,
                                  qs_ch_en_ptr);
        /*
         * If slave_primary is TRUE then this is not the primary reader.
         * Retrieve the QS_CH_EN value based on the input/output value. The
         * qs_ch_en_to_dis sets the bit to1 that corresponds to the egress
         * mux port.
         */
        if (TRUE == slave_primary)
        {
            UINT8 qs_ch_en_to_dis = 0;

            digi_cpb_chnl_qs_ch_en_get(digi_handle,
                                       input_ptr,
                                       (util_global_switch_data_t *)switch_data_ptr,
                                       &qs_ch_en_to_dis);
            *qs_ch_en_ptr = *qs_ch_en_ptr^qs_ch_en_to_dis;
        }
        PMC_RETURN(TRUE);
    }

    PMC_RETURN(FALSE);

} /* digi_cpb_retrieve_mpma_data */


/*******************************************************************************
*  digi_otn_rfrm_maint_sig_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*  Encapsulates the reqiurements for retrieving the coreotn rfrm 
*  maintenance signal values.
*
* INPUTS:
*  digi_handle    - pointer to DIGI handle instance
*  odu_ptr        - Reference to the odu struct
*  is_sysotn      - Whether SYSOTN should be TRUE or FALSE
*                          
* OUTPUTS:                 
*  odu_rx_maint_sig_ptr - Maintenance signal value based on the odu level 
*                         and product application
*
* RETURNS:
*   PMC_SUCCESS if operation successful otherwise a descriptive error
*   code is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_otn_rfrm_maint_sig_set(digi_handle_t *digi_handle,
                                        odu_struct_t *odu_ptr,
                                        BOOL8 is_sysotn,
                                        coreotn_maint_sig_type_t *odu_rx_maint_sig_ptr)
{
    PMC_ENTRY();

    if (NULL == odu_ptr)
    {
        PMC_RETURN();
    }

    if (odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_LO_ODU &&
        DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == is_sysotn )
    {
        coreotn_prev_rfrm_maint_sig_get(digi_handle->coreotn_handle,
                                        odu_ptr->switch_data.oduk_data.channel,
                                        FALSE,
                                        odu_rx_maint_sig_ptr);
    }
    else
    {
        coreotn_prev_rfrm_maint_sig_get(digi_handle->coreotn_handle,
                                        odu_ptr->switch_data.oduk_data.channel,
                                        TRUE,
                                        odu_rx_maint_sig_ptr);
    }

    PMC_RETURN();
}


/*******************************************************************************
* digi_otn_odu_deg_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Conpute Ddeg channel associated to odu struct and TCM layer.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *chnl_ptr       - pointer to ODU framer channel handle to be operated on                   
*   pm_tcm_num      - PM or TCMi layer. See odu_struct_odu_frm_pm_tcm_id_t.
*                          
* OUTPUTS:                 
*   *deg_chnl_ptr   - ddeg channel.
*
* RETURNS:
*   PMC_SUCCESS if operation successful otherwise a descriptive error
*   code is returned.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_deg_chnl_get(digi_handle_t                  *digi_handle,
                                            digi_otn_odu_chnl_t            *chnl_ptr,
                                            odu_struct_odu_frm_pm_tcm_id_t  pm_tcm_num,
                                            UINT32                         *deg_chnl_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT16 tcm_pool_id;

    PMC_ENTRY();          

    PMC_ASSERT(NULL != deg_chnl_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
            
    if (pm_tcm_num == ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM)
    {
        *deg_chnl_ptr = (((odu_struct_t *)chnl_ptr)->switch_data.oduk_data.channel);
    }    
    else
    {
        /* retrieve tcm pool identifier */
        result = odu_struct_tcm_pool_id_from_instance_get(digi_handle->coreotn_handle,
                                                          (odu_struct_t *)chnl_ptr, 
                                                          ODU_STRUCT_STREAM_RX,
                                                          pm_tcm_num, &tcm_pool_id); 
        if (PMC_SUCCESS == result)
        {
                    *deg_chnl_ptr = tcm_pool_id;
        }
    }                         
    
    PMC_RETURN(result);
}/*digi_otn_odu_deg_chnl_get*/

/*******************************************************************************
* FUNCTION: digi_otn_ohp_int_ptr_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns OHP instance interrupt table reference contained in given OTN
*   interrupt table.
*
* INPUTS:
*   ohp                 - Specifies which OHP block (see odu_ohp_inst_t)
*   otn_int_table_ptr   - point to OTN interrupt table.
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   odu_ohp_int_t - pointer to ohp instance interrupt table.
*
* NOTES:
*
*******************************************************************************/
PRIVATE odu_ohp_int_t *digi_otn_ohp_int_ptr_get(odu_ohp_inst_t     ohp,
                                                digi_otn_int_t    *otn_int_table_ptr)
{
    odu_ohp_int_t *ohp_int_table_ptr = NULL;

    PMC_ENTRY();

    switch(ohp)
    {
    case ODU_OHP_1:
    case ODU_OHP_2:
    case ODU_OHP_3:
        ohp_int_table_ptr = &otn_int_table_ptr->ohp[(UINT32)ohp]; 
        break;
    default:        
        break;
    }

    PMC_RETURN(ohp_int_table_ptr);
}/* digi_otn_ohp_int_ptr_get */

/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ohp_chnl_enable_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables OHP channelized interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.       
*   ohp             - Specifies which OHP block (see odu_ohp_inst_t)
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem and all ODU levels (HO/MO/LO)
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*   enable          - TRUE to enable, FALSE to disable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_ohp_chnl_enable_internal(digi_handle_t             *digi_handle,
                                                            odu_ohp_inst_t             ohp,
                                                            digi_otn_odu_chnl_t       *chnl_handle,
                                                            odu_ohp_int_chnl_t        *int_table_ptr,
                                                            BOOL                       enable)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    digi_int_type_t          int_type = DIGI_INT_CHNL_TYPE_OTN_ODU;
    UINT32                   i;
    UINT32                   num_odu;
    odu_struct_odu_level_t   odu_list[LAST_ODU_STRUCT_LEVEL];
    
    
    PMC_ENTRY();
    result = digi_int_param_check(digi_handle, chnl_handle, int_type, int_table_ptr); 

    if (ODU_OHP_LAST  <= ohp)
    {
        result = DIGI_ERR_INVALID_ARG;
    }

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Callback for interrupt table must be registered before enable ints */
    if (PMC_SUCCESS == result && TRUE == enable)
    {
        if(!digi_int_is_cb_registered(digi_handle, DIGI_INT_TYPE_OTN) && 
           !digi_int_is_cb_registered(digi_handle, DIGI_INT_CHNL_TYPE_OTN_ODU))
        {
            result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
        }
    }


    /* Get range of odu levels (HO/MO/LO) to enable */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_odu_range_get(digi_handle,
                                                chnl_handle,
                                                odu_list,
                                                &num_odu);
    }

    /* Enable interrupts per odu level */
    for (i = 0; (PMC_SUCCESS == result) && (i < num_odu); i++)
    {
        result = digi_otn_odu_int_ohp_one_chnl_enable(digi_handle,
                                                  ohp,
                                                  chnl_handle,
                                                  odu_list[i],
                                                  int_table_ptr,
                                                  enable);
    } 
    

    PMC_RETURN(result);
} /* digi_otn_odu_int_ohp_chnl_enable_internal */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ohp_one_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables OHP channelized interrupts associated to the specified HO/MO/LO 
*   stage based on bits that are set in the channel interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.                                 
*   ohp             - Specifies which OHP block (see odu_ohp_inst_t)
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem
*   odu_level       - Indicates whether to enable interrupts on HO/MO/LO
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*   enable          - TRUE to enable specified interrupts, FALSE to disable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_ohp_one_chnl_enable(digi_handle_t         *digi_handle,
                                                   odu_ohp_inst_t             ohp,
                                                   digi_otn_odu_chnl_t       *chnl_handle,
                                                   odu_struct_odu_level_t     odu_level,
                                                   odu_ohp_int_chnl_t        *int_table_ptr,
                                                   BOOL                       enable)
{
    PMC_ERROR           result = PMC_SUCCESS;

    coreotn_int_chnl_info_t     chnl_info;
    coreotn_handle_t           *coreotn_handle;
    UINT32                      start_chnl = 0;
    UINT32                      end_chnl   = 0;
    UINT32                      i;
    odu_ohp_int_chnl_t         *ohp_en_ptr = NULL;
    odu_struct_t               *handle_pool_ptr;
        
    PMC_ENTRY();

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Determine if we are modfiying one channel or all channels in odu level */
    if (PMC_SUCCESS == result)
    {
        /* Get range of channels to retrieve within ODU level */
        result = digi_otn_odu_int_link_range_get(digi_handle,
                                                 chnl_handle,
                                                 odu_level,
                                                 &start_chnl,
                                                 &end_chnl);
    }

    /* Get the pool pointer for ODU level */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_handle_pool_get(digi_handle, odu_level, &handle_pool_ptr);
    }


    /* Get specific ODU level framer enabled interrupt table */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_en_ohp_get(digi_handle,
                                             ohp,
                                             &ohp_en_ptr);
    }

    if (PMC_SUCCESS != result)
    {
        PMC_RETURN(result);
    }

    PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));
    /* Enable interrupts */
    coreotn_handle      = digi_handle->coreotn_handle;
    chnl_info.odu_level = odu_level;

    if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    { 
        chnl_info.source = COREOTN_INT_SOURCE_SYS; 
    }
    else
    {
        chnl_info.source = COREOTN_INT_SOURCE_LINE; 
    }


    for (i = start_chnl; (i < end_chnl) && (PMC_SUCCESS == result); i++)
    {
        if (util_global_is_chnl_prov(&handle_pool_ptr[i]))
        {
            chnl_info.chnl_id = i;
            result = coreotn_int_ohp_chnl_enable(coreotn_handle, 
                                                 ohp,
                                                 &chnl_info,
                                                 int_table_ptr,
                                                 &ohp_en_ptr[i], 
                                                 enable);

        }
    }
                
    PMC_RETURN(result);
} /* digi_otn_odu_int_ohp_one_chnl_enable */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ri_rcp_chnl_enable_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables RI_RCP channelized interrupts based on bits that are set in the channel
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.       
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem and all ODU levels (HO/MO/LO)
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*   enable          - TRUE to enable, FALSE to disable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_ri_rcp_chnl_enable_internal(digi_handle_t          *digi_handle,
                                                               digi_otn_odu_chnl_t       *chnl_handle,
                                                               odu_ri_rcp_int_chnl_t     *int_table_ptr,
                                                               BOOL                       enable)
{      
    PMC_ERROR                result = PMC_SUCCESS;
    digi_int_type_t          int_type = DIGI_INT_CHNL_TYPE_OTN_ODU;
    UINT32                   i;
    UINT32                   num_odu;
    odu_struct_odu_level_t   odu_list[LAST_ODU_STRUCT_LEVEL];
    
    
    PMC_ENTRY();
    result = digi_int_param_check(digi_handle, chnl_handle, int_type, int_table_ptr); 

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Callback for interrupt table must be registered before enable ints */
    if (PMC_SUCCESS == result && TRUE == enable)
    {
        if(!digi_int_is_cb_registered(digi_handle, DIGI_INT_TYPE_OTN) && 
           !digi_int_is_cb_registered(digi_handle, DIGI_INT_CHNL_TYPE_OTN_ODU))
        {
            result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
        }
    }


    /* Get range of odu levels (HO/MO/LO) to enable */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_odu_range_get(digi_handle,
                                                chnl_handle,
                                                odu_list,
                                                &num_odu);
    }

    /* Enable interrupts per odu level */
    for (i = 0; (PMC_SUCCESS == result) && (i < num_odu); i++)
    {
        result = digi_otn_odu_int_ri_rcp_one_chnl_enable(digi_handle,
                                                         chnl_handle,
                                                         odu_list[i],
                                                         int_table_ptr,
                                                         enable);
    } 
    

    PMC_RETURN(result);
} /* digi_otn_odu_int_ri_rcp_chnl_enable_internal */


/*******************************************************************************
* FUNCTION: digi_otn_odu_int_ri_rcp_one_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables RI_RCP channelized interrupts associated to the specified HO/MO/LO 
*   stage based on bits that are set in the channel interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.                                 
*   chnl_handle     - pointer to channel handle to enable interrupts on, or
*                     DIGI_INT_ALL_CHNLS to enable interrupts on all channels
*                     of the subsystem
*   odu_level       - Indicates whether to enable interrupts on HO/MO/LO
*   int_table_ptr   - pointer to channel interrupt table with bits set to
*                     enable interrupts
*   enable          - TRUE to enable specified interrupts, FALSE to disable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_int_ri_rcp_one_chnl_enable(digi_handle_t      *digi_handle,
                                                   digi_otn_odu_chnl_t       *chnl_handle,
                                                   odu_struct_odu_level_t     odu_level,
                                                   odu_ri_rcp_int_chnl_t     *int_table_ptr,
                                                   BOOL                       enable)
{
    PMC_ERROR           result = PMC_SUCCESS;

    coreotn_int_chnl_info_t     chnl_info;
    coreotn_handle_t           *coreotn_handle;
    UINT32                      start_chnl = 0;
    UINT32                      end_chnl   = 0;
    UINT32                      i;
    odu_ri_rcp_int_chnl_t         *ri_rcp_en_ptr;
    odu_struct_t               *handle_pool_ptr;
        
    PMC_ENTRY();

    /* Skip interrupt retrieve if subsystem is not powered up */
    if (PMC_SUCCESS == result && TRUE == coreotn_start_state_test(digi_handle->coreotn_handle))
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Determine if we are modfiying one channel or all channels in odu level */
    if (PMC_SUCCESS == result)
    {
        /* Get range of channels to retrieve within ODU level */
        result = digi_otn_odu_int_link_range_get(digi_handle,
                                                 chnl_handle,
                                                 odu_level,
                                                 &start_chnl,
                                                 &end_chnl);
    }

    /* Get the pool pointer for ODU level */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_handle_pool_get(digi_handle, odu_level, &handle_pool_ptr);
    }


    /* Get specific ri_rcp channel enabled interrupt table */
    if (PMC_SUCCESS == result)
    {
        ri_rcp_en_ptr = digi_handle->var.enabled_otn_int->ri_rcp;
    }
    /*
     * If an error occurred upto this point then return the error.
     */
    if (PMC_SUCCESS != result)
    {
        PMC_RETURN(result);
    }
    
    PMC_MEMSET((void*) &chnl_info, 0, sizeof(chnl_info));
    /* Enable interrupts */
    coreotn_handle      = digi_handle->coreotn_handle;
    chnl_info.odu_level = odu_level;

    if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    { 
        chnl_info.source = COREOTN_INT_SOURCE_SYS; 
    }
    else
    {
        chnl_info.source = COREOTN_INT_SOURCE_LINE; 
    }

    for (i = start_chnl; (i < end_chnl) && (PMC_SUCCESS == result); i++)
    {
        if (util_global_is_chnl_prov(&handle_pool_ptr[i]))
        {
            chnl_info.chnl_id = i;
            result = coreotn_int_ri_rcp_chnl_enable(coreotn_handle, 
                                                 &chnl_info,
                                                 int_table_ptr,
                                                 &ri_rcp_en_ptr[i], 
                                                 enable);
        }
    }
                
    PMC_RETURN(result);
} /* digi_otn_odu_int_ri_rcp_one_chnl_enable */

/*******************************************************************************
* digi_otn_odu_maint_sig_set_internal
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Used to force a maintenance signal on a particular channel.
*   
*   For Sink (RX):
*      Maintenance signal is forced before any TCM processing. All layers (TCM/PM)
*      will see the maintenance signal.
*
*   For Source (TX):
*      Maintenance signal is forced at ODUkP/ODU[i][j] Mux adaptation layer 
*      (on top of all TCM/PM layers) if odukp_pck == FALSE
*
*      If odukp_pck == TRUE Maintenance is forced at the ODUkP source packet adaptation
*      (on top of the PM layer, but before ODUkT adaptation).  Use this mode
*      if you want all TCMs to remain operational on top of the maintenance signal.
*     
*
*   To remove the maintenance signal, call this function with force_alarm_sig = 0
*
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   *chnl_ptr           - pointer to ODU framer channel handle to be operated on                           
*   direction           - direction of the signal insertion \n
*                         0 -- Sink \n
*                         1 -- Source
*   force_alarm_sig     - enum,requested maintenance signal:
*                         CORE_OTN_NO_MAINT_SIG 
*                         CORE_OTN_ODUK_AIS 
*                         CORE_OTN_ODUK_LCK 
*                         CORE_OTN_ODUK_OCI 
*   odukp_pck            -  TRUE : Maintenance signal is forced at 
*                                  ODUkP/ODU[i][j]
*                           FALSE : Maintenance is forced at the ODUkP 
*                                   source packet adaptation
* 
* OUTPUTS:
*
* RETURNS:
*   PMC_ERR_FAIL - Internally generated error code
*              0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_odu_maint_sig_set_internal(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *chnl_ptr,
                                                      UINT8 direction,
                                                      coreotn_maint_sig_type_t force_alarm_sig,
                                                      BOOL odukp_pck)
{
    PMC_ERROR result = PMC_SUCCESS;
    odu_struct_t *odu_ptr = NULL;
    BOOL ho_unchannelized = FALSE;
    BOOL mo_lo_unchannelized = FALSE;
    odu_struct_t *rfrm_odu_ptr;
    UINT32 rfrm_chnl;
    BOOL line_facing_rfrm;
    BOOL8 old_sig_is_nominal = FALSE;
    BOOL8 new_sig_is_nominal = FALSE;
    BOOL8 nominal_tx_unchannelized;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle!=NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    /* check that user switch handle belongs to digi context */           
    DIGI_OTN_ODU_CHNL_HANDLE_CHECK(digi_handle, chnl_ptr, result);

    if (CORE_OTN_ODUK_AIS_NOMINAL == force_alarm_sig)
    {
        force_alarm_sig = CORE_OTN_ODUK_AIS;
        new_sig_is_nominal = TRUE;
    }
    else if (CORE_OTN_ODUK_LCK_NOMINAL == force_alarm_sig)
    {
        force_alarm_sig = CORE_OTN_ODUK_LCK;
        new_sig_is_nominal = TRUE;
    }
    else if (CORE_OTN_ODUK_OCI == force_alarm_sig)
    {
        new_sig_is_nominal = TRUE;
    }
    else
    {
        new_sig_is_nominal = FALSE;
    }
    
    
    if (PMC_SUCCESS == result)
    {

        if(odukp_pck == FALSE)
        {
            result = odu_struct_chnl_maint_sig_set(digi_handle->coreotn_handle,
                                                   (odu_struct_t *)chnl_ptr,
                                                   (odu_struct_stream_dir_t)direction,
                                                   force_alarm_sig,
                                                   ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
        }
        else
        {
            result = odu_struct_odukp_pck_maint_sig_set(digi_handle->coreotn_handle,
                                                        (odu_struct_t *)chnl_ptr,
                                                        force_alarm_sig,
                                                        ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE);
        }
    }   
    
    if (PMC_SUCCESS == result)
    {
        /* if signal alarms are sent in TX direction */
        if (1 == direction)
        {
            odu_ptr = (odu_struct_t *)chnl_ptr;


            /*Rate adaptation require for no MUXING
            non-sysotn : FMF1->TFRM12 
            sysotn     : FMF1->TFRM12, FMF2->TFRM12*/
            
            ho_unchannelized = DIGI_IS_ODU_CHNL_HO_UNCHANNELIZED(digi_handle, odu_ptr);


            /*Rate adaptation require for MUXING
            non-sysotn: 1x muxing, FMF1 TXJC needs to be in reset
                        2x muxing, FMF2 TXJC needs to be in reset
            sysotn    : 1x muxing, FMF2 TXJC needs to be in reset */
               
            mo_lo_unchannelized =  DIGI_IS_ODU_CHNL_MO_LO_UNCHANNELIZED(digi_handle, odu_ptr);



            /*Set context that indicates there's an active maintenance signal on this path*/
            if (odu_ptr->switch_data.oduk_data.lineotn_src)
            {
                if(odu_ptr->mem_ptr->odu_level ==  ODU_STRUCT_LEVEL_HO_ODU)
                {
                    old_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_HO_LINE, odu_ptr->switch_data.oduk_data.channel);
                    digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_HO_LINE, odu_ptr->switch_data.oduk_data.channel, new_sig_is_nominal);
                }
                else if(odu_ptr->mem_ptr->odu_level ==  ODU_STRUCT_LEVEL_MO_ODU)
                {
                    old_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_MO_LINE, odu_ptr->switch_data.oduk_data.channel);
                    digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_MO_LINE, odu_ptr->switch_data.oduk_data.channel, new_sig_is_nominal);
                }
                else if(odu_ptr->mem_ptr->odu_level ==  ODU_STRUCT_LEVEL_LO_ODU)
                {
                    old_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_LO_LINE, odu_ptr->switch_data.oduk_data.channel);
                    digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_LO_LINE, odu_ptr->switch_data.oduk_data.channel, new_sig_is_nominal);
                }
            }
            else
            {
                if(odu_ptr->mem_ptr->odu_level ==  ODU_STRUCT_LEVEL_HO_ODU)
                {
                    old_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_HO_SYS, odu_ptr->switch_data.oduk_data.channel);
                    digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_HO_SYS, odu_ptr->switch_data.oduk_data.channel, new_sig_is_nominal);
                }
                else if(odu_ptr->mem_ptr->odu_level ==  ODU_STRUCT_LEVEL_MO_ODU)
                {
                    old_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_MO_SYS, odu_ptr->switch_data.oduk_data.channel);
                    digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_MO_SYS, odu_ptr->switch_data.oduk_data.channel, new_sig_is_nominal);
                }
            }



            /* OPSA considerations only need to be made on UNCHHANELIZED signals */
            if(ho_unchannelized || mo_lo_unchannelized)
            {
                /*if forcing with nominal maintenance signal, the replacement signal must always be done using 
                the local reference clock (disable the OPSA workaround)*/
                if(result == PMC_SUCCESS &&
                   new_sig_is_nominal &&
                   !old_sig_is_nominal)
                {

                    if(result == PMC_SUCCESS)
                    {
                        result = odu_struct_tx_maint_sig_dummy_rfrm_cfg(digi_handle->coreotn_handle,
                                                                        odu_ptr->mem_ptr->odu_level,
                                                                        odu_ptr->mem_ptr->chnl_id,
                                                                        TRUE);            
                    }

                    if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_LO_ODU &&
                       DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
                    {
                        digi_opsa_cfg_mpmo_one_port_drop(digi_handle,
                                                         OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_CTL,
                                                         odu_ptr->switch_data.oduk_data.channel);  

                    }
                    else
                    {
                        digi_opsa_cfg_mpmo_one_port_drop(digi_handle,
                                                             OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_FO1,
                                                             odu_ptr->switch_data.oduk_data.channel);
                            
                    }
                    
                    /*
                    * Set the FIFO_CLRB to 0 to empty the ODUkSW 
                    * while nominal is being forced towords the line 
                    * or system side SerDes, when nominal replacement
                    * is removed, FIFO_CLRB is set back to 1 after 
                    * the digi_opsa_cfg_mpmo_one_port_add call to 
                    * complete the operation 
                    */
                    coreotn_mpmo_fifo_clear(digi_handle->coreotn_handle,
                                             1,
                                            odu_ptr);

                }
                else if(result == PMC_SUCCESS &&
                        old_sig_is_nominal &&
                        !new_sig_is_nominal)
                {
                    /* this case is to handle transitioning to from a nominal maintenance signal, to a non-nominal
                    maintenance signal, or no maintenance signal */

                    nominal_tx_unchannelized = digi_otn_nominal_tx_unchannelized_get(digi_handle, odu_ptr);
           
                    if(nominal_tx_unchannelized == FALSE &&
                       result ==  PMC_SUCCESS)
                    {
                        result = digi_otn_remove_nominal_replacement(digi_handle,
                                                                     odu_ptr);
                    }

                    if(result == PMC_SUCCESS &&
                       digi_otn_remove_dummy_maintenance_signal_get(digi_handle, odu_ptr))
                    {
                        result = odu_struct_tx_maint_sig_dummy_rfrm_cfg(digi_handle->coreotn_handle,
                                                                        odu_ptr->mem_ptr->odu_level,
                                                                        odu_ptr->mem_ptr->chnl_id,
                                                                        FALSE);
                    }

                } /*result == PMC_SUCCESS && old_sig_is_nominal && !new_sig_is_nominal)*/

            } /*if(ho_unchannelized || mo_lo_unchannelized)*/

        }
        else /* RX */
        {
              rfrm_odu_ptr = (odu_struct_t *)chnl_ptr;
              rfrm_chnl = rfrm_odu_ptr->switch_data.oduk_data.channel;

              /* check if this is bein applied to a LINE facing RFRM at the egress of
              the ODUKSW */
              if(rfrm_odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_3B_ODU)
              {
                  line_facing_rfrm = TRUE;

                  if(DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
                  {
                        if(digi_handle->handle_pool.mo_odu_struct[rfrm_chnl].switch_data.header.prov_state ==
                           UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED)
                        {
                            odu_ptr = &(digi_handle->handle_pool.mo_odu_struct[rfrm_chnl]);
                        }
                        else if(digi_handle->handle_pool.ho_odu_struct[rfrm_chnl].switch_data.header.prov_state ==
                                UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED)
                        {
                            odu_ptr = &(digi_handle->handle_pool.ho_odu_struct[rfrm_chnl]);
                        }
                        else
                        {
                            result = DIGI_ERR_INVALID_PTR;
                            PMC_ATOMIC_RETURN(digi_handle, result);
                        }
                  }
                  else
                  {
                        if(digi_handle->handle_pool.lo_odu_struct[rfrm_chnl].switch_data.header.prov_state ==
                           UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED)
                        {
                            odu_ptr = &(digi_handle->handle_pool.lo_odu_struct[rfrm_chnl]);
                        }
                        else if(digi_handle->handle_pool.mo_odu_struct[rfrm_chnl].switch_data.header.prov_state ==
                                UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED)
                        {
                            odu_ptr = &(digi_handle->handle_pool.mo_odu_struct[rfrm_chnl]);
                        }
                        else if(digi_handle->handle_pool.ho_odu_struct[rfrm_chnl].switch_data.header.prov_state ==
                                UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED)
                        {
                            odu_ptr = &(digi_handle->handle_pool.ho_odu_struct[rfrm_chnl]);
                        }
                        else
                        {
                            result = DIGI_ERR_INVALID_PTR;
                            PMC_ATOMIC_RETURN(digi_handle, result);
                        }
                  }
              }
              else if(rfrm_odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC)
              {
                  line_facing_rfrm = TRUE;
                  
                  if(digi_handle->handle_pool.lo_odu_struct[rfrm_chnl].switch_data.header.prov_state ==
                     UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED)
                  {
                        odu_ptr = &(digi_handle->handle_pool.lo_odu_struct[rfrm_chnl]);
                  }
                  else
                  {
                        result = DIGI_ERR_INVALID_PTR;
                        PMC_ATOMIC_RETURN(digi_handle, result);
                  }
              }
              else if(rfrm_odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_4_ODU)
              {
                  line_facing_rfrm = FALSE;

                  if(digi_handle->handle_pool.s4_odu_struct[rfrm_chnl].switch_data.header.prov_state ==
                     UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED)
                  {
                        odu_ptr = (odu_struct_t*)(&(digi_handle->handle_pool.mapper_chnl[rfrm_chnl]));
                  }
                  else
                  {
                        result = DIGI_ERR_INVALID_PTR;
                        PMC_ATOMIC_RETURN(digi_handle, result);
                  }
              }
              else
              {
                  line_facing_rfrm = FALSE;
              }

              if(rfrm_odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_3B_ODU ||
                 rfrm_odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC ||
                 rfrm_odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_4_ODU)
              {
                  if( odu_ptr->switch_data.oduk_data.op_state.active_state != UTIL_GLOBAL_CHNL_ACTIVE_STATE_ACTIVE)
                  {
                      PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_OTN_ODU_RX_MAINT_SIG);
                  }
              }
                       
              if(result == PMC_SUCCESS &&
                 line_facing_rfrm)
              {
                  ho_unchannelized = ((odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_HO_ODU &&
                                     odu_ptr->mem_ptr->payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED) ||
                                     (odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_LO_ODU &&
                                     DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle)));
              }



              
              if(line_facing_rfrm)
              {
                  if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_LO_ODU &&
                     DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
                  {
                      old_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_RX_LINE, odu_ptr->switch_data.oduk_data.channel);
                      digi_otn_channel_nominal_set(digi_handle, COREOTN_RX_LINE, odu_ptr->switch_data.oduk_data.channel, new_sig_is_nominal);
                  }
                  else
                  {
                      if(DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
                      {
                          old_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_RX_SYS, odu_ptr->switch_data.oduk_data.channel);
                          digi_otn_channel_nominal_set(digi_handle, COREOTN_RX_SYS, odu_ptr->switch_data.oduk_data.channel, new_sig_is_nominal);
                      }
                      else
                      {
                          old_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_RX_LINE, odu_ptr->switch_data.oduk_data.channel);
                          digi_otn_channel_nominal_set(digi_handle, COREOTN_RX_LINE, odu_ptr->switch_data.oduk_data.channel, new_sig_is_nominal);
                      }
                  }
              }



                /*if forcing with a nominal maintenance signal */
                if(result == PMC_SUCCESS &&
                   new_sig_is_nominal && 
                   !old_sig_is_nominal && 
                   line_facing_rfrm)
                {

                    /*if forcing with a nominal maintenance signal, the replacement signal must always 
                    be done using the local reference clock (disable the OPSA workaround)*/
                    if(result == PMC_SUCCESS)
                    {
                      
                        if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_LO_ODU &&
                           DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
                        {
                            digi_opsa_cfg_mpmo_one_port_drop(digi_handle,
                                                             OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_CTL,
                                                             odu_ptr->switch_data.oduk_data.channel);

                        }
                        else
                        {
                            digi_opsa_cfg_mpmo_one_port_drop(digi_handle,
                                                             OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_FO1,
                                                             odu_ptr->switch_data.oduk_data.channel);  

                        }
                        /*
                         * Set the FIFO_CLRB to 0 to empty the ODUkSW 
                         * while nominal is being forced towords the line 
                         * or system side SerDes, when nominal replacement
                         * is removed, FIFO_CLRB is set back to 1 after 
                         * the digi_opsa_cfg_mpmo_one_port_add call to 
                         * complete the operation 
                         */
                        coreotn_mpmo_fifo_clear(digi_handle->coreotn_handle,
                                                1,
                                                odu_ptr);
                    }
                
                }
                else if(result == PMC_SUCCESS &&
                        old_sig_is_nominal &&
                        !new_sig_is_nominal &&
                        line_facing_rfrm)
                {
                        /*this is to look after case from transitioning from nominal maintenance to
                        no maintenance signal*/

                          nominal_tx_unchannelized = digi_otn_nominal_tx_unchannelized_get(digi_handle, odu_ptr);

                          if(result == PMC_SUCCESS &&
                             nominal_tx_unchannelized == FALSE)
                          {
                              result = digi_otn_remove_nominal_replacement(digi_handle, 
                                                                           odu_ptr);

                          }

                } /*  else if(result == PMC_SUCCESS && old_sig_is_nominal && !new_sig_is_nominal && line_facing_rfrm) */
        }        
    }

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_odu_maint_sig_set_internal */

/*******************************************************************************
* FUNCTION: digi_otn_int_clear_internal
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears interrupts based on bits that are set in the aggregated 
*   interrupt table.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   int_table_ptr   - pointer to aggregated interrupt table with bits set to
*                     clear interrupts. DIGI_INT_ALL_INTS to clear all interrupts.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_int_clear_internal(digi_handle_t       *digi_handle,
                                             digi_otn_int_t      *int_table_ptr)
{
    odu_ohp_inst_t          ohp;
    PMC_ERROR               result = PMC_SUCCESS;

    PMC_ENTRY();

    if (PMC_SUCCESS == result)
    {
        result = digi_otn_server_int_clear(digi_handle,
                                           int_table_ptr);
    }
   
    /* Clear COREOTN TOP interrupts */
    if (PMC_SUCCESS == result)
    {
        if (NULL != int_table_ptr)
        {
            result = digi_otn_int_coreotn_clear(digi_handle,
                                                &int_table_ptr->coreotn);
        }
        else
        {
            result = digi_otn_int_coreotn_clear(digi_handle, NULL);
        }
    }

    /* Clear rest of framer interrupts per ODU to match RFRM behaviour */
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_odu_int_chnl_clear(digi_handle,
                                             DIGI_INT_ALL_CHNLS,
                                             DIGI_INT_ALL_INTS);
    }

    if (PMC_SUCCESS == result)
    {
        PMC_ATOMIC_YIELD(digi_handle, 0);
    }

    /* clear OHPs unchannelized interrupts */
    if (PMC_SUCCESS == result)
    {
        for (ohp = ODU_OHP_1; ODU_OHP_LAST > ohp; ohp = (odu_ohp_inst_t)((UINT32) ohp + 1))
        {
            digi_otn_odu_int_ohp_clear(digi_handle, 
                                       ohp,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, ohp[(UINT32)ohp]));
        }
    }

    if (PMC_SUCCESS == result)
    {
        PMC_ATOMIC_YIELD(digi_handle, 0);
    }

    /* clear DI RCP unchannelized interrupts */
    if (PMC_SUCCESS == result)
    {
        digi_otn_odu_int_rcp_clear(digi_handle, 
                                   ODU_RCP_DI_INST,
                                   UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, di_rcp));
    }

    if (PMC_SUCCESS == result)
    {
        PMC_ATOMIC_YIELD(digi_handle, 0);
    }
    
    /* clear RI RCP unchannelized interrupts */
    if (PMC_SUCCESS == result)
    {
        digi_otn_odu_int_rcp_clear(digi_handle, 
                                   ODU_RCP_RI_INST,
                                   UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, ri_rcp));
    }

    PMC_RETURN(result);
} /* digi_otn_int_clear_internal */


/*******************************************************************************
* FUNCTION: digi_otn_set_input_fo2
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Sets the passed in susystem and channel to the COREOTN_FO2 and the 
*  input_ptr channel if the settings are valid.
*   
*
* INPUTS:
*  digi_handle     - Pointer to digi handle
*  input_ptr       - Reference to the MAPOTN data handle.
*
* OUTPUTS:
*  mode_ptr       - Reference to the apping mode.
*  subsystem_ptr  - Assigned COREOTN FO2 subsystem if valid.
*  chnl_ptr       - Assigned the input channel value if valid.
*  bmp_mode_ptr   - Whether BMP is the mapotn mode.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_otn_set_input_fo2(digi_handle_t *digi_handle,
                                    util_global_switch_data_t *input_ptr,
                                    digi_mapping_mode_t *mode_ptr,
                                    hostmsg_opsa_subsystem_cfg_t *subsystem_ptr,
                                    UINT32 *chnl_ptr,
                                    BOOL8 *bmp_mode_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    util_global_map_adapt_func_t map_mode = UTIL_GLOBAL_MAP_NO_RATE;
    util_global_map_adapt_func_t dummy_mode = UTIL_GLOBAL_MAP_NO_RATE;
    util_global_mapping_mode_t mapotn_mode = UTIL_GLOBAL_NO_MAP;

    PMC_ENTRY();

    *mode_ptr = ((digi_mapper_chnl_def_t*)input_ptr)->mode;
    digi_mapotn_mode_params_convert(*mode_ptr,
                                    &map_mode,
                                    &dummy_mode);
    result = mapotn_mapping_mode_get(digi_handle->mapotn_handle, 
                                     map_mode,
                                     &mapotn_mode);
    PMC_ASSERT(result==PMC_SUCCESS, DIGI_ERR_CODE_ASSERT, 0, 0);
    /*
     * The input_fo2 channel needs to get set regardless of the result.
     * The subsystem_ptr determines whether or not opsa add/drop is 
     * performed on the F02 resources. Namely if set it is used. However
     * the FO2 channel is used regardless.
     */
    *chnl_ptr = ((digi_mapper_chnl_def_t*)input_ptr)->mapotn_chnl;

    if (UTIL_GLOBAL_BMP != mapotn_mode)
    {
        digi_serdes_acb_mode_t acb_timing_mode = DIGI_SERDES_ACB_MODE_NOMINAL;
        result = digi_mapotn_data_src_acb_mode_find(digi_handle, 
                                                    *mode_ptr, 
                                                    &acb_timing_mode);
        PMC_ASSERT(result==PMC_SUCCESS, DIGI_ERR_CODE_ASSERT, 0, 0);

        if(acb_timing_mode != DIGI_SERDES_ACB_MODE_NOMINAL)
        {
            *subsystem_ptr = OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_FO2;
        }
        *bmp_mode_ptr = FALSE;
    }
    else
    {
        *bmp_mode_ptr = TRUE;
    }

    PMC_RETURN();
} /* digi_otn_set_input_fo2 */



/*******************************************************************************
* FUNCTION: digi_otn_remove_dummy_maintenance_signal_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns indication whether or dummay maintenance signal can be removed.
*   Dummy maintenance signals are removed using 
*   odu_struct_tx_maint_sig_dummy_rfrm_cfg() when the ODUKSW is activated,
*   or when a nominal maitenance signal at the TFRM or OTUFRM
*   is removed.
*
*  Correct operation for removing dummy maint signal:
*     1) digi_otn_remove_dummy_maintenance_signal_get
*     2) if digi_otn_remove_dummy_maintenance_signal_get returns TRUE,
*        call odu_struct_tx_maint_sig_dummy_rfrm_cfg() with enable == FALSE
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   odu_ptr         - Point to odu_struct
*
* OUTPUTS:
*
* RETURNS:
*   TRUE     - It's OK to remove dummy maintenance signal
*   FALSE    - It's not OK to remove dummy maintenance signal
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL digi_otn_remove_dummy_maintenance_signal_get(digi_handle_t       *digi_handle,
                                                         odu_struct_t      *odu_ptr)
{
    BOOL tx_sig_is_nominal = FALSE;
    BOOL linesys_otn_is_nominal;
    BOOL ho_unchannelized;
    BOOL nominal_tx_unchannelized_tfrm_otufrm_only;

    PMC_ENTRY();

    ho_unchannelized = DIGI_IS_ODU_CHNL_HO_UNCHANNELIZED(digi_handle, odu_ptr);

    if (odu_ptr->switch_data.oduk_data.lineotn_src)
    {
        if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_HO_ODU)
        {
            tx_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_HO_LINE, odu_ptr->switch_data.oduk_data.channel);
        }
        else if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_MO_ODU)
        {
            tx_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_MO_LINE, odu_ptr->switch_data.oduk_data.channel);
        }
        else if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_LO_ODU)
        {
            tx_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_LO_LINE, odu_ptr->switch_data.oduk_data.channel);
        }
        
        if(ho_unchannelized)
        {
            linesys_otn_is_nominal = digi_otn_channel_nominal_get(digi_handle, LINEOTN_TX, odu_ptr->switch_data.oduk_data.channel);
        }
    }
    else
    {
        if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_HO_ODU)
        {
            tx_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_HO_SYS, odu_ptr->switch_data.oduk_data.channel);
        }
        else if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_MO_ODU)
        {
            tx_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_MO_SYS, odu_ptr->switch_data.oduk_data.channel);
        }

        if(ho_unchannelized)
        {
            linesys_otn_is_nominal = digi_otn_channel_nominal_get(digi_handle, SYSOTN_TX, odu_ptr->switch_data.oduk_data.channel);
        }
    }


    if(ho_unchannelized)
    {
        nominal_tx_unchannelized_tfrm_otufrm_only = linesys_otn_is_nominal | tx_sig_is_nominal;
    }
    else /* if(ho_unchannelized) */
    {
        nominal_tx_unchannelized_tfrm_otufrm_only = tx_sig_is_nominal;
    }

    
    if(nominal_tx_unchannelized_tfrm_otufrm_only == FALSE &&
       odu_ptr->switch_data.oduk_data.op_state.active_state == UTIL_GLOBAL_CHNL_ACTIVE_STATE_ACTIVE)
    {
        PMC_RETURN(TRUE);       
    }

    PMC_RETURN(FALSE);
}

/*******************************************************************************
* FUNCTION: digi_otn_nominal_tx_unchannelized_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Function to return whether or not:
*      - This channel is UNCHANNELIZED
*      - There is a nominal maintenance signal provisioned on this channel
*
* INPUTS:

*   digi_handle     - Pointer to digi handle
*   odu_ptr         - Point to odu_struct
*
* OUTPUTS:
*
* RETURNS:
*   TRUE     - There is a nominal unchannelized maintenance signal in the TX path
*   FALSE    - There is not a nominal unchannelized maintenance signal in 
*              the TX path
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL digi_otn_nominal_tx_unchannelized_get(digi_handle_t       *digi_handle,
                                                  odu_struct_t      *odu_ptr)
{
    BOOL tx_sig_is_nominal = FALSE;
    BOOL linesys_otn_is_nominal = FALSE;
    BOOL ho_unchannelized;
    BOOL mo_lo_unchannelized;
    BOOL rx_sig_is_nominal;
    BOOL nominal_tx_unchannelized;

    PMC_ENTRY();

    ho_unchannelized = DIGI_IS_ODU_CHNL_HO_UNCHANNELIZED(digi_handle, odu_ptr);

    if (odu_ptr->switch_data.oduk_data.lineotn_src)
    {
        if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_HO_ODU)
        {
            tx_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_HO_LINE, odu_ptr->switch_data.oduk_data.channel);
        }
        else if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_MO_ODU)
        {
            tx_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_MO_LINE, odu_ptr->switch_data.oduk_data.channel);
        }
        else if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_LO_ODU)
        {
            tx_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_LO_LINE, odu_ptr->switch_data.oduk_data.channel);
        }

        rx_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_RX_LINE, odu_ptr->switch_data.oduk_data.channel);

        if(ho_unchannelized)
        {
            linesys_otn_is_nominal = digi_otn_channel_nominal_get(digi_handle, LINEOTN_TX, odu_ptr->switch_data.oduk_data.channel); 
        }
    }
    else
    {

        if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_HO_ODU)
        {
            tx_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_HO_SYS, odu_ptr->switch_data.oduk_data.channel);
        }
        else if(odu_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_MO_ODU)
        {
            tx_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_TX_MO_SYS, odu_ptr->switch_data.oduk_data.channel);
        }

        rx_sig_is_nominal = digi_otn_channel_nominal_get(digi_handle, COREOTN_RX_SYS, odu_ptr->switch_data.oduk_data.channel);
    
        if(ho_unchannelized)
        {
            linesys_otn_is_nominal = digi_otn_channel_nominal_get(digi_handle, SYSOTN_TX, odu_ptr->switch_data.oduk_data.channel);
        }
    }

    

    mo_lo_unchannelized =  DIGI_IS_ODU_CHNL_MO_LO_UNCHANNELIZED(digi_handle, odu_ptr);
    

    if(ho_unchannelized)
    {
        nominal_tx_unchannelized = linesys_otn_is_nominal | tx_sig_is_nominal | rx_sig_is_nominal;
    }
    else if(mo_lo_unchannelized)
    {
        nominal_tx_unchannelized = tx_sig_is_nominal | rx_sig_is_nominal;
    }
    else
    {
        nominal_tx_unchannelized = FALSE;
    }

    
    PMC_RETURN(nominal_tx_unchannelized);
}


/*******************************************************************************
* FUNCTION: digi_otn_channel_nominal_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Function to return whether or not a nominal maintenance signal is active in
*   the TX path.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   ins_point       - The insertion point of the maintenance signal
*                     (see otn_maint_ins_point_t)
*   channel         - channel ID (for LINEOTN,SYSOTN and COREOTN provide 
*                     DCI channel)
*   nominal         - TRUE : rate is nominal
*                     FALSE : rate is not nominal
*
* OUTPUTS:

*
* RETURNS:
*   TRUE     - There is a nominal maintenance signal in the TX path
*   FALSE    - There is not a nominal maintenance signal in the TX path
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_otn_channel_nominal_set(digi_handle_t          *digi_handle,
                                         otn_maint_ins_point_t  ins_point,
                                         UINT32                 channel,
                                         BOOL                   nominal)
{
    UINT8 *coreotn_tx_ho_line_sig_nominal;
    UINT8 *coreotn_tx_mo_line_sig_nominal;
    UINT8 *coreotn_tx_lo_line_sig_nominal;
    UINT8 *coreotn_tx_ho_sys_sig_nominal;
    UINT8 *coreotn_tx_mo_sys_sig_nominal;
    UINT8 *coreotn_rx_sys_sig_nominal;
    UINT8 *coreotn_rx_line_sig_nominal;
    UINT8 *sysotn_tx_sig_nominal;
    UINT8 *lineotn_tx_sig_nominal;
     


    coreotn_tx_ho_line_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[0]));
    coreotn_tx_mo_line_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[2]));
    coreotn_tx_lo_line_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[14]));
    coreotn_tx_ho_sys_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[26]));
    coreotn_tx_mo_sys_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[28]));
    coreotn_rx_sys_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[40]));
    coreotn_rx_line_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[52]));
    sysotn_tx_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[64]));
    lineotn_tx_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[66]));

    PMC_ENTRY();


    if(ins_point == SYSOTN_TX || ins_point == LINEOTN_TX || ins_point == COREOTN_TX_HO_LINE
       || ins_point == COREOTN_TX_HO_SYS)
    {
        if(channel >= DIGI_NUM_HO_ODU_CHNL_MAX)
        {
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);    
        }
    }   
    else
    {
        if(channel >= DIGI_NUM_LO_ODU_CHNL_MAX)
        {
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0); 
        }
    }

    if(ins_point == SYSOTN_TX)
    {
        if(nominal)
        {
            sysotn_tx_sig_nominal[channel/8] = sysotn_tx_sig_nominal[channel/8] | (1<<(channel%8));
        }
        else
        {
            sysotn_tx_sig_nominal[channel/8] = sysotn_tx_sig_nominal[channel/8] & ~(1<<(channel%8));
        }
    }
    else if(ins_point == LINEOTN_TX)
    {
        if(nominal)
        {
            lineotn_tx_sig_nominal[channel/8] = lineotn_tx_sig_nominal[channel/8] | (1<<(channel%8));
        }
        else
        {
            lineotn_tx_sig_nominal[channel/8] = lineotn_tx_sig_nominal[channel/8] & ~(1<<(channel%8));
        }
    }
    else if(ins_point == COREOTN_TX_HO_LINE)
    {
        if(nominal)
        {
            coreotn_tx_ho_line_sig_nominal[channel/8] = coreotn_tx_ho_line_sig_nominal[channel/8] | (1<<(channel%8));
        }
        else
        {
            coreotn_tx_ho_line_sig_nominal[channel/8] = coreotn_tx_ho_line_sig_nominal[channel/8] & ~(1<<(channel%8));
        }
    }
    else if(ins_point == COREOTN_TX_MO_LINE)
    {
        if(nominal)
        {
            coreotn_tx_mo_line_sig_nominal[channel/8] = coreotn_tx_mo_line_sig_nominal[channel/8] | (1<<(channel%8));
        }
        else
        {
            coreotn_tx_mo_line_sig_nominal[channel/8] = coreotn_tx_mo_line_sig_nominal[channel/8] & ~(1<<(channel%8));
        }
    }
    else if(ins_point == COREOTN_TX_LO_LINE)
    {
        if(nominal)
        {
            coreotn_tx_lo_line_sig_nominal[channel/8] = coreotn_tx_lo_line_sig_nominal[channel/8] | (1<<(channel%8));
        }
        else
        {
            coreotn_tx_lo_line_sig_nominal[channel/8] = coreotn_tx_lo_line_sig_nominal[channel/8] & ~(1<<(channel%8));
        }
    }
    else if(ins_point == COREOTN_TX_HO_SYS)
    {
        if(nominal)
        {
            coreotn_tx_ho_sys_sig_nominal[channel/8] = coreotn_tx_ho_sys_sig_nominal[channel/8] | (1<<(channel%8));
        }
        else
        {
            coreotn_tx_ho_sys_sig_nominal[channel/8] = coreotn_tx_ho_sys_sig_nominal[channel/8] & ~(1<<(channel%8));
        }
    }
    else if(ins_point == COREOTN_TX_MO_SYS)
    {
        if(nominal)
        {
            coreotn_tx_mo_sys_sig_nominal[channel/8] = coreotn_tx_mo_sys_sig_nominal[channel/8] | (1<<(channel%8));
        }
        else
        {
            coreotn_tx_mo_sys_sig_nominal[channel/8] = coreotn_tx_mo_sys_sig_nominal[channel/8] & ~(1<<(channel%8));
        }
    }
    else if(ins_point == COREOTN_RX_LINE)
    {
        if(nominal)
        {
            coreotn_rx_line_sig_nominal[channel/8] = coreotn_rx_line_sig_nominal[channel/8] | (1<<(channel%8));
        }
        else
        {
            coreotn_rx_line_sig_nominal[channel/8] = coreotn_rx_line_sig_nominal[channel/8] & ~(1<<(channel%8));
        }
    }
    else if(ins_point == COREOTN_RX_SYS)
    {
        if(nominal)
        {
            coreotn_rx_sys_sig_nominal[channel/8] = coreotn_rx_sys_sig_nominal[channel/8] | (1<<(channel%8));
        }
        else
        {
            coreotn_rx_sys_sig_nominal[channel/8] = coreotn_rx_sys_sig_nominal[channel/8] & ~(1<<(channel%8));
        }
    }


    
    PMC_RETURN();
}



/*******************************************************************************
* FUNCTION: digi_otn_channel_nominal_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Function to return whether or not a nominal maintenance signal is active in
*   the TX path.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   ins_point       - The insertion point of the maintenance signal
*                     (see otn_maint_ins_point_t)
*   channel         - channel ID (for LINEOTN,SYSOTN and COREOTN provide 
*                     DCI channel)
*
* OUTPUTS:
*
* RETURNS:
*   TRUE     - There is a nominal maintenance signal in the TX path
*   FALSE    - There is not a nominal maintenance signal in the TX path
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL digi_otn_channel_nominal_get(digi_handle_t          *digi_handle,
                                         otn_maint_ins_point_t  ins_point,
                                         UINT32                 channel)
{
    UINT8 *coreotn_tx_ho_line_sig_nominal;
    UINT8 *coreotn_tx_mo_line_sig_nominal;
    UINT8 *coreotn_tx_lo_line_sig_nominal;
    UINT8 *coreotn_tx_ho_sys_sig_nominal;
    UINT8 *coreotn_tx_mo_sys_sig_nominal;
    UINT8 *coreotn_rx_sys_sig_nominal;
    UINT8 *coreotn_rx_line_sig_nominal;
    UINT8 *sysotn_tx_sig_nominal;
    UINT8 *lineotn_tx_sig_nominal;
    BOOL nominal = FALSE;
     
    PMC_ENTRY();

    if(ins_point == SYSOTN_TX || ins_point == LINEOTN_TX || ins_point == COREOTN_TX_HO_LINE
       || ins_point == COREOTN_TX_HO_SYS)
    {
        if(channel >= DIGI_NUM_HO_ODU_CHNL_MAX)
        {
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);    
        }
    }   
    else
    {
        if(channel >= DIGI_NUM_LO_ODU_CHNL_MAX)
        {
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0); 
        }
    }

    coreotn_tx_ho_line_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[0]));
    coreotn_tx_mo_line_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[2]));
    coreotn_tx_lo_line_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[14]));
    coreotn_tx_ho_sys_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[26]));
    coreotn_tx_mo_sys_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[28]));
    coreotn_rx_sys_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[40]));
    coreotn_rx_line_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[52]));
    sysotn_tx_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[64]));
    lineotn_tx_sig_nominal = (UINT8 *)(&(digi_handle->var.nominal_chnl_ctxt[66]));


    if(ins_point == SYSOTN_TX)
    {
        nominal = (sysotn_tx_sig_nominal[channel/8] >> channel%8) & 0x1;
    }
    else if(ins_point == LINEOTN_TX)
    {
        nominal = (lineotn_tx_sig_nominal[channel/8] >> channel%8) & 0x1;
    }
    else if(ins_point == COREOTN_TX_HO_LINE)
    {
        nominal = (coreotn_tx_ho_line_sig_nominal[channel/8] >> channel%8) & 0x1;
    }
    else if(ins_point == COREOTN_TX_MO_LINE)
    {
        nominal = (coreotn_tx_mo_line_sig_nominal[channel/8] >> channel%8) & 0x1;
    }
    else if(ins_point == COREOTN_TX_LO_LINE)
    {
        nominal = (coreotn_tx_lo_line_sig_nominal[channel/8] >> channel%8) & 0x1;
    }
    else if(ins_point == COREOTN_TX_HO_SYS)
    {
        nominal = (coreotn_tx_ho_sys_sig_nominal[channel/8] >> channel%8) & 0x1;
    }
    else if(ins_point == COREOTN_TX_MO_SYS)
    {
        nominal = (coreotn_tx_mo_sys_sig_nominal[channel/8] >> channel%8) & 0x1;
    }
    else if(ins_point == COREOTN_RX_LINE)
    {
        nominal = (coreotn_rx_line_sig_nominal[channel/8] >> channel%8) & 0x1;
    }
    else if(ins_point == COREOTN_RX_SYS)
    {
        nominal = (coreotn_rx_sys_sig_nominal[channel/8] >> channel%8) & 0x1;
    }

    PMC_RETURN(nominal);
}

/*******************************************************************************
* digi_cbr_nominal_fault_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Intialize leverages extra context space to used to store nominal fault
*  settings that apply to CBR fault patterns and loopback. Ensures the 
*  setting of these values are set to 0 before use.
*
* INPUTS:
*  digi_handle  - pointer to COREOTN handle instance to be operated on
*
* OUTPUTS:
*  None.
*
* RETURNS:
*  None
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_cbr_nominal_fault_init(digi_handle_t *digi_handle)
{
    PMC_ENTRY();

    PMC_MEMSET(&digi_handle->var.cbr_nominal_fault, 0, DIGI_NUM_HO_ODU_CHNL_MAX);

    PMC_RETURN();
}

/*******************************************************************************
* digi_cbr_nominal_fault_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Function that leverages extra context space to store nominal fault
*  settings that apply to CBR fault patterns and loopback. Ensures OPSA
*  ADD/REMOVES are not called multiple times if loopback and multiple CBR
*  fault patterns are used.
*
* INPUTS:
*  digi_handle  - pointer to DIGI handle reference.
*  chnl_id      - Index into the memory for this boolean value.
*  value        - Sets the content to TRUE or FALSE
*
* OUTPUTS:
*  None.
*
* RETURNS:
*  None
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_cbr_nominal_fault_set(digi_handle_t *digi_handle,
                                          UINT32 chnl_id,
                                          BOOL8 value)
{
    PMC_ENTRY();

    if (TRUE == value)
    {
        digi_handle->var.cbr_nominal_fault[chnl_id/8] = digi_handle->var.cbr_nominal_fault[chnl_id/8] | (1 << (chnl_id%8));
    }
    else
    {
        digi_handle->var.cbr_nominal_fault[chnl_id/8] = digi_handle->var.cbr_nominal_fault[chnl_id/8] & ~(1 << (chnl_id%8));
    }

    PMC_RETURN();
}

/*******************************************************************************
* digi_cbr_nominal_fault_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Returns the value of the cbr nominal fault setting for the specified 
*  channel.
*
* INPUTS:
*  digi_handle  - pointer to COREOTN handle instance to be operated on
*  chnl_id         - Index into the memory for this boolean value.
*
* OUTPUTS:
*  None.
*
* RETURNS:
*  None
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 digi_cbr_nominal_fault_get(digi_handle_t *digi_handle,
                                           UINT32 chnl_id)
{
    UINT8 value = 0;
    BOOL8 result = FALSE; 
    PMC_ENTRY();


    value = (digi_handle->var.cbr_nominal_fault[chnl_id/8] >> chnl_id%8) & 0x1;

    if (value > 0)
    {
        result = TRUE;
    }

    PMC_RETURN(result);
}


#endif /* DOXYGEN_PUBLIC_ONLY */

/*
** End of file
*/
