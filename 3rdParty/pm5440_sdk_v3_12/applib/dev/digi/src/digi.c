/*******************************************************************************
*   COPYRIGHT (C) 2011 PMC-SIERRA, INC. ALL RIGHTS RESERVED.
* --------------------------------------------------------------------------
*  This software embodies materials and concepts which are proprietary and
*  confidential to PMC-Sierra, Inc.
*  PMC-Sierra distributes this software to its customers pursuant to the
*  terms and conditions of the Software License Agreement
*  contained in the text file software.lic that is distributed along with
*  the software. This software can only be utilized if all
*  terms and conditions of the Software License Agreement are
*  accepted. If there are any questions, concerns, or if the
*  Software License Agreement text file, software.lic, is missing please
*  contact PMC-Sierra for assistance.
* --------------------------------------------------------------------------
*   DESCRIPTION : This file contains C functions for the creation and
*   destruction of DIGI devices and data paths.  Functions for usage in
*   higher level systems have prototypes defined in digi_api.h.  Other functions
*   should be considered private and for the internal use of the SW driver.
*
*   NOTES:
*
*******************************************************************************/
/*
** Include Files
*/
#include "digi_loc.h"
#include "digi_util_loc.h"
#include "digi_resource_loc.h"
#include "hostmsg_loc.h"
#include "pmc_ctxt_mgmt.h"
#include "util_gen_db.h"

/*
** Local Enumerated Types
*/

/*
** Local Constants
*/

/* digi possible 10/40G configuratons 3-18 (0,1,2 are 100G configurations not included in this table)                       */
/* first 4 numbers represent the number of instances of dsi lanes of eachinterface(otu2,otl,sfis,sfi5.1)                    */
/*                                                                                                                          */
/* cfg_signature_bm is a configuration descriptive bit map to specify how each lane is allocated according to the           */
/* following map:                                                                                                           */
/* bits 0-11 - each bit is a 10G lane. bit lane number is the bit position in the 0-11 bit range.                           */
/* bit  12   - when 1-> lanes 0-3 are 40G, when 0->  lanes 0-3 are 4x10G                                                    */
/* bit  13   - when 1-> lanes 4-7 are 40G, when 0->  lanes 4-7 are 4x10G                                                    */
/* bit  14   - when 1-> lanes 8-11 are 40G,when 0->  lanes 8-11 are 4x10G                                                   */
/* bits 16,15- 00-> lanes 0-3 interface is OTL,01-> lanes 0-3 interface is SFIS, 10-> lanes 0-3 interface is SFI5.1 bus A,  */
/*             11-> lanes 0-3 interface is SFI5.1 bus B                                                                     */
/* bits 18,17- 00-> lanes 4-7 interface is OTL,01-> lanes 4-7 interface is SFIS, 10-> lanes 4-7 interface is SFI5.1 bus A,  */
/*             11-> lanes 4-7 interface is SFI5.1 bus B                                                                     */
/* bits 20,19- 00-> lanes 8-11 interface is OTL,01-> lanes 8-11 interface is SFIS,10-> lanes 8-11 interface is SFI5.1 bus A,*/
/*             11-> lanes 8-11 interface is SFI5.1 bus B                                                                    */
/* bits 21-31- not used                                                                                                     */
#define DIGI_CFG_TABLE  {                                               \
        /* otu2 10G,otl 40g,    sfis 40G,   sfi51 40G,      signature   config num                                                           */ \
        {  12,      0,          0,          0,              0x00000fff, 3},  /* 3 - 12x10G OTU2                                  */ \
        {   8,      1,          0,          0,              0x00001fff, 4},  /* 4 - 1x40G OTL3.4 + 8x10G OTU2                    */ \
        {   8,      1,          0,          0,              0x00002fff, 4},  /* 4 - 1x40G OTL3.4 + 8x10G OTU2                    */ \
        {   8,      1,          0,          0,              0x00004fff, 4},  /* 4 - 1x40G OTL3.4 + 8x10G OTU2                    */ \
        {   7,      0,          1,          0,              0x00009fef, 5},  /* 5 - 1x40G SFIS   + 7x10G OTU2                    */ \
        {   3,      1,          1,          0,              0x0000dfef, 6},  /* 6 - 1x40G OTL3.4 + 1x40G SFIS   + 3x10G OTU2     */ \
        {   8,      0,          0,          1,              0x00011fff, 7},  /* 7 - 1x40G SFI5.1 + 8x10G OTU2                    */ \
        {   4,      1,          0,          1,              0x00013fff, 8},  /* 8 - 1x40G OTL3.4 + 1x40G SFI5.1 + 4x10G OTU2     */ \
        {   4,      0,          1,          1,              0x0006bfff, 9},  /* 9 - 1x40G SFIS   + 1x40G SFI5.1 + 4x10G OTU2     */ \
        {   0,      1,          1,          1,              0x0006ffff,10},  /* 10- 1x40G OTL3.4 + 1x40G SFIS   + 1x40G SFI5.1   */ \
        {   4,      2,          0,          0,              0x00003fff,11},  /* 11- 2x40G OTL3.4 + 4x10G OTU2                    */ \
        {   4,      2,          0,          0,              0x00006fff,11},  /* 11- 2x40G OTL3.4 + 4x10G OTU2                    */ \
        {   4,      2,          0,          0,              0x00005fff,11},  /* 11- 2x40G OTL3.4 + 4x10G OTU2                    */ \
        {   0,      2,          0,          1,              0x00017fff,12},  /* 12- 2x40G OTL3.4 + 1x40G SFI5.1                  */ \
        {   2,      0,          2,          0,              0x0002bcff,13},  /* 13- 2x40G SFIS   + 2xOTU2                        */ \
        {   0,      0,          2,          1,              0x0012ffff,14},  /* 14- 2x40G SFIS   + 1x40G SFI5.1                  */ \
        {   4,      0,          0,          2,              0x00073fff,15},  /* 15- 2x40G SFI5.1 + 4x10G OTU2                    */ \
        {   0,      1,          0,          2,              0x00077fff,16},  /* 16- 2x40G SFI5.1 + 1x40G OTL3.4                  */ \
        {   0,      0,          1,          2,              0x0016ffff,17},  /* 17- 2x40G SFI5.1 + 1x40G SFIS                    */ \
        {   0,      3,          0,          0,              0x00007fff,18},  /* 18- 3x40G OTL3.4                                 */ \
            };

#define DUMMY_ITEM {   0,      0,          0,          0,              0x00000000, 0}

#define DIGI60_LINE_CARD_CFG_TABLE  {                                   \
        /* otu2 10G,otl 40g,    sfis 40G,   sfi51 40G,      signature   config num */ \
        /* line card */                                                 \
        {   1,      0,          0,          0,              0x00000010, 3}, \
        {   2,      0,          0,          0,              0x00000030, 3}, \
        {   3,      0,          0,          0,              0x00000070, 3}, \
        {   4,      0,          0,          0,              0x000000f0, 3}, \
        {   5,      0,          0,          0,              0x000001f0, 3}, \
        {   6,      0,          0,          0,              0x000003f0, 3}, \
        {   0,      1,          0,          0,              0x000020f0, 4}, \
        {   2,      1,          0,          0,              0x000023f0, 4}, \
        {   1,      0,          1,          0,              0x000222f0, 5}, \
        {   2,      0,          0,          1,              0x000623f0, 15}, /* SFII5.1 bus B */ \
        {   2,      0,          0,          1,              0x0001930f, 15}, /* SFII5.1 bus B */ \
            DUMMY_ITEM,                                                 \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                };

#define DIGI60_TRANSMUXPONDER_CARD_CFG_TABLE  {                         \
        /* otu2 10G,otl 40g,    sfis 40G,   sfi51 40G,      signature   config num */ \
        {  12,      0,          0,          0,              0x00000fff, 3}, \
        {   3,      1,          1,          0,              0x00023eff, 6}, \
        {   4,      1,          0,          1,              0x00013fff, 8},  /* 8 - 1x40G OTL3.4 + 1x40G SFI5.1 + 4x10G OTU2     */ \
        {   4,      0,          1,          1,              0x0006bfff, 9},  /* 9 - 1x40G SFIS   + 1x40G SFI5.1 + 4x10G OTU2     */ \
        {   0,      2,          0,          0,              0x000030ff,11},  /* 11- 2x40G OTL3.4 */ \
        {   4,      2,          0,          0,              0x00003fff,11},  /* 11- 2x40G OTL3.4 + 4x10G OTU2                    */ \
        {   2,      0,          2,          0,              0x0002bcff,13},  /* 13- 2x40G SFIS   + 2xOTU2                        */ \
        {   4,      0,          0,          2,              0x00073fff,15},  /* 15- 2x40G SFI5.1 + 4x10G OTU2                    */ \
            DUMMY_ITEM,                                                 \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                DUMMY_ITEM,                                             \
                };

/*
** Local Macro Definitions
*/

/* Defines whether CBR LINE, SYSTEM, or BOTH serdes are valid for the product application */
#define DIGI_CBR_SERDES_PROD_APP_TABLE {                                \
        /* Line, System */                                              \
        { TRUE,  FALSE }, /* DIGI_PROD_APP_LINE_CARD */                 \
        { FALSE, TRUE  }, /* DIGI_PROD_APP_TRANSMUXPONDER_CARD */       \
        { FALSE, FALSE }, /* DIGI_PROD_APP_PORTLESS_CARD */             \
        { TRUE,  FALSE }, /* DIGI_PROD_APP_SYSOTN_CARD */               \
        { TRUE,  TRUE },  /* DIGI_PROD_APP_100G_3_X_40G_CFP_CARD */     \
        { TRUE,  FALSE },                                               \
        { TRUE,  FALSE },                                               \
            }

/*
** Global Variables
*/
/* PMC_EMULATION_CPB_051 */
/* Used when !PMC_EMULATION_CPB_051 */
PRIVATE const char* DCPB_HANDLE_NAME = "DCPB";  /*!< Handle name for debug output */
PRIVATE const char* MCPB_HANDLE_NAME = "MCPB";  /*!< Handle name for debug output */
PRIVATE const char* ENET_SYS_HANDLE_NAME = "ENET_SYS";  /*!< Handle name for debug output */
PRIVATE const char* ENET_LINE_HANDLE_NAME = "ENET_LINE";  /*!< Handle name for debug output */
PRIVATE const char* SIFD_HANDLE_NAME = "SIFD";  /*!< Handle name for debug output */
PRIVATE const char* LIFD_HANDLE_NAME = "LIFD";  /*!< Handle name for debug output */
PRIVATE const char* CBRC_HANDLE_NAME = "CBRC";  /*!< Handle name for debug output */
PRIVATE const char* MAPOTN_HANDLE_NAME = "MAPOTN";  /*!< Handle name for debug output */
PRIVATE const char* COREOTN_HANDLE_NAME = "COREOTN";  /*!< Handle name for debug output */
PRIVATE const char* LINEOTN_HANDLE_NAME = "LINEOTN";  /*!< Handle name for debug output */
PRIVATE const char* HOSTMSG_HANDLE_NAME = "HOSTMSG";  /*!< Handle name for debug output */
PRIVATE const char* S16_SYS_HANDLE_NAME = "S16_SYS";  /*!< Handle name for debug output */
PRIVATE const char* S16_LINE_HANDLE_NAME = "S16_LINE";  /*!< Handle name for debug output */
PRIVATE const char* SFI51_D8_RX_18X_HANDLE_NAME = "SFI51_D8_RX_18X";  /*!< Handle name for debug output */
PRIVATE const char* SFI51_D8_TX_18X_HANDLE_NAME = "SFI51_D8_TX_18X";  /*!< Handle name for debug output */
PRIVATE const char* BP_LR_T8_HANDLE_NAME = "BP_LR_T8";  /*!< Handle name for debug output */
PRIVATE const char* BP_SR_C8_HANDLE_NAME = "BP_SR_C8";  /*!< Handle name for debug output */
PRIVATE const char* GE_TX_HANDLE_NAME[] = {"GE_TX_0", "GE_TX_1", "GE_TX_2"};  /*!< Handle name for debug output */
PRIVATE const char* GE_RX_HANDLE_NAME[] = {"GE_RX_0", "GE_RX_1", "GE_RX_2"};  /*!< Handle name for debug output */
PRIVATE const char* MGMT_FEGE_HANDLE_NAME = "MGMT_FEGE";  /*!< Handle name for debug output */

/* pattern monitor bus width default value */
#define  GE_SERDES_D8_RX_18X_GEN_MON_BUS_WIDTH_VAL 10

/* block reset default value */
#define DIGI_TL_IC_RESET_VALUE                      0x1

/* Wait for DIGI SS to shut down (e.g. power consumption issue). */
#define DIGI_SS_SHUTDOWN_WAIT(handle) PMC_Q_USLEEP(handle,70)

/*
** Local Structures and Unions
*/

/*
** Local Variables
*/
#ifndef DISABLE_LLDP_WORKAROUND 
PRIVATE BOOL8 g_pkt_cache_init = FALSE; /*!< pkt_cache_init */
#endif

BOOL8 digi_handle_init_uses_fw_q_flag = TRUE; /*!< Control flag for use of firmware acceleration during digi_handle_init */

/* Only include the strings if logging with text*/
#ifdef PMC_LOG_STRINGS

/*
* The following creates the LOG/ERR strings from above by pulling out the text
* portion of the LOG_ERR_TABLE above
*/
#define PMC_LOG_ERR_PAIR_ENTRY_CREATE( enum, str ) str,
const char DIGI_LOG_ERR_STRINGS[][PMC_LOG_STRING_SIZEOF] =
{
    "Start of log string list",
    DIGI_LOG_ERR_TABLE
};
#undef PMC_LOG_ERR_PAIR_ENTRY_CREATE

#else  /* no strings */

const char DIGI_LOG_ERR_STRINGS[1][1] = {};

#endif /* PMC_SW_SIMULATION */

/*
 * Retrieve the declaration of the logging variables. Updated or reset in
 * crash/warm restart so that logging DIGI handles are correctly displayed
 */
extern pmc_log_data_t digi120_pmc_log_data;


/*
** Private Functions
*/
#ifndef DOXYGEN_PUBLIC_ONLY
PRIVATE BOOL8 digi_cpb_mapping_check(digi_handle_t *digi_handle,
                                     util_global_switch_data_t *input_pc_ptr,
                                     util_global_switch_data_t *output_pc_ptr);
PRIVATE BOOL8 digi_mapotn_enet_etrans_mode_convert(digi_handle_t *digi_handle,
                                                   util_global_switch_data_t *input_pc_ptr,
                                                   digi_enet_mode_t *out_enet_mode);
PRIVATE BOOL8 digi_enet_mapotn_mapping_check(digi_handle_t *digi_handle,
                                             digi_enet_mode_t enet_mode,
                                             digi_mapping_mode_t mapping_mode);
PRIVATE BOOL8 digi_enet_mapping_check(digi_handle_t *digi_handle,
                                      digi_enet_mode_t in_enet_mode,
                                      digi_enet_mode_t out_enet_mode);
PRIVATE BOOL8 digi_cbr_mapping_check(digi_handle_t *digi_handle,
                                     digi_cbr_client_mode_t in_cbr_client_mode,
                                     digi_cbr_client_mode_t out_cbr_client_mode);
PRIVATE BOOL8 digi_mapotn_mapping_check(digi_handle_t *digi_handle,
                                        digi_mapping_mode_t in_mapping_mode,
                                        digi_mapping_mode_t out_mapping_mode);
PRIVATE BOOL8 digi_cbr_mapotn_mapping_check(digi_handle_t *digi_handle,
                                            digi_cbr_client_mode_t cbr_client_mode,
                                            digi_mapping_mode_t mapping_mode);
PRIVATE PMC_ERROR digi_cpb_test_rate_compatibility(digi_handle_t *digi_handle,
                                                   util_global_switch_data_t *input_pc_ptr,
                                                   util_global_switch_data_t *output_pc_ptr,
                                                   digi_cpb_stream_t rate_data,
                                                   UINT32 client_num_odu0,
                                                   UINT32 halt_buffer);
PRIVATE PMC_ERROR digi_oduksw_test_rate_compatibility(digi_handle_t *digi_handle,
                                                      util_global_switch_data_t *input_pc_ptr,
                                                      util_global_switch_data_t *output_pc_ptr,
                                                      digi_oduksw_stream_t rate_data,
                                                      UINT32 client_num_odu0,
                                                      DOUBLE client_bitrate);
PRIVATE PMC_ERROR digi_oduksw_switch_data_rate_get(digi_handle_t *digi_handle,
                                                   util_global_switch_data_def_t *switch_data_ptr,
                                                   util_global_odukp_type_t *odu_type, 
                                                   UINT32 *num_slot);
PRIVATE void digi_dynamic_ctxt_alloc(digi_handle_t *digi_handle,
                                     BOOL8 alloc);
PRIVATE PMC_ERROR digi_subsystem_restart_init(digi_handle_t *digi_handle,
                                              BOOL8 is_warm_restart,
                                              util_global_restart_init_phase_t restart_init_phase,
                                              digi_resource_handle_summary_t *digi_resource_handle_ptr);
PRIVATE void digi_restart_tx_ilkn_bcw_dpi_map_init(digi_handle_t *digi_handle);
PRIVATE void digi_m1_pmm_ptp_cfg(digi_handle_t *digi_handle, BOOL8 enable);
PRIVATE PMC_ERROR digi_ilkn_chnl_cfg_lock_internal(digi_handle_t *digi_handle);
PRIVATE PMC_ERROR digi_device_init_params_validate(digi_handle_t *digi_handle,
                                                   digi_sifd_ilkn_1_cfg_t *sifd_1_cfg_ptr,
                                                   digi_sifd_ilkn_2_cfg_t *sifd_2_cfg_ptr,
                                                   digi_prod_app_t prod_app,
                                                   digi_otn_mux_stages_t mux_stages,
                                                   digi_ilkn_link_t **ilkn_1_ctxt_pptr,
                                                   digi_ilkn_link_t **ilkn_2_ctxt_pptr);

/* 
   internal functions that are used by CPB from the datapath layer
*/
PRIVATE PMC_ERROR digi_cpb_output_port_init(digi_handle_t *h,
                                            UINT32 cpb_emul_type,
                                            util_global_cpb_port_t output_port,
                                            UINT32 cpb_xfer_mode,
                                            cpb_dcs_instance_mode_t mode);

PRIVATE cpb_xfer_mode_t digi_cpb_ilkn_xfer_data_get(digi_sifd_xfer_mode_t xfer, digi_sifd_burst_t burst);

PRIVATE PMC_ERROR digi_cbr_lane_validate(digi_handle_t          *digi_handle,
                                         UINT32                  port_uid,
                                         cbrc_serdes_type_t      mode,
                                         digi_serdes_intf_t      intf_type);

PRIVATE PMC_ERROR digi_handle_init_children(digi_handle_t *digi_handle);
PRIVATE void digi_handle_init_alloc(digi_handle_t *digi_handle);

PRIVATE PMC_ERROR digi_cpb_mpmo_prov(digi_handle_t *digi_handle, 
                                     util_global_cpb_port_t input_port, 
                                     UINT32 input_channel, 
                                     util_global_cpb_port_t output_port, 
                                     UINT32 output_channel);

PRIVATE PMC_ERROR digi_cpb_mpmo_deprov(digi_handle_t *digi_handle, 
                                       util_global_cpb_port_t output_port, 
                                       UINT32 output_channel);

PRIVATE PMC_ERROR digi_by_mld_index_num_odus_get(digi_handle_t *digi_handle,
                                                 UINT8 post_mld_index,
                                                 UINT32 *num_odus);

PRIVATE PMC_ERROR digi_by_mld_index_num_odus_set(digi_handle_t *digi_handle,
                                                 UINT8 post_mld_index,
                                                 UINT32 num_odus);

PRIVATE PMC_ERROR digi_mapotn_prov_new_mapper_state_get(digi_mapper_alloc_t in_map_type,
                                                        BOOL enet_pmon,
                                                        mapotn_src_dest_t mapotn_dest,
                                                        digi_mapper_alloc_t *out_map_type);

PRIVATE PMC_ERROR digi_mapotn_deprov_new_mapper_state_get(digi_mapper_alloc_t in_map_type,
                                                          util_global_cpb_port_t port_type,
                                                          digi_mapper_alloc_t *out_map_type);

PRIVATE PMC_ERROR digi_enet_mapotn_mpmo_prov(digi_handle_t *digi_handle,
                                             UINT32 chnl,
                                             digi_mapping_mode_t mode);

PRIVATE PMC_ERROR digi_enet_mapotn_mpmo_deprov(digi_handle_t *digi_handle,
                                               UINT32 chnl,
                                               digi_mapping_mode_t mode);

PRIVATE void digi_num_odus_and_map_type_prov_set(digi_handle_t *digi_handle,
                                                 UINT16 post_mld_index, 
                                                 UINT32 num_cal_entries,
                                                 BOOL enet_pmon,
                                                 mapotn_src_dest_t mapotn_dest);

PRIVATE UINT32 digi_by_port_uid_num_line_xfi_lanes_get(digi_handle_t *digi_handle,
                                                       UINT32 port_uid);
PRIVATE UINT32 digi_by_port_uid_num_sfi51_lanes_get(digi_handle_t *digi_handle,
                                                    UINT32 port_uid);
PRIVATE UINT32 digi_by_port_uid_num_sys_xfi_lanes_get(digi_handle_t *digi_handle,
                                                      UINT32 port_uid);

PRIVATE UINT32 digi_by_port_uid_num_port_get(digi_handle_t *digi_handle,
                                             UINT32 port_uid);

PRIVATE PMC_ERROR digi_determine_resource_available(digi_handle_t *digi_handle, 
                                                    digi_mapper_primary_group_t p_group,
                                                    digi_mapper_secondary_group_t s_group, 
                                                    UINT16 post_mld_index, 
                                                    UINT32 num_cal_entries);

PRIVATE PMC_ERROR digi_num_post_mld_lanes_required(UINT32 num_entries,
                                                   UINT16 *num_lanes);

PRIVATE void digi_post_mld_dsi_lane_status_count(UINT32 chnl[MAPOTN_NUM_CHANL],
                                                 UINT16 lane,
                                                 UINT32 match_chnl,
                                                 UINT32 *num_entries);

PRIVATE void digi_mapotn_enet_params_convert(digi_mapping_mode_t map_mode,
                                             enet_datapath_t* e_mode);    
                                                                                       
PRIVATE void digi_mapotn_digi_enet_params_convert(digi_mapping_mode_t map_mode,
                                                  digi_enet_mode_t* digi_e_mode);

PRIVATE void digi_mapper_post_mld_index_get(digi_mapper_primary_group_t p_group,
                                            digi_mapper_secondary_group_t s_group, 
                                            digi_group_size_t group_size,
                                            UINT32 *link);

PRIVATE void digi_mapper_post_mld_dsi_get(digi_handle_t *digi_handle, 
                                          digi_mapper_primary_group_t p_group, 
                                          digi_mapper_secondary_group_t s_group, 
                                          digi_group_size_t group_size,
                                          UINT16 *dsi_mask_ptr);  

PRIVATE BOOL digi_mapper_db_test_update(digi_handle_t *digi_handle, 
                                        UINT32 schd_addr,
                                        util_global_cpb_port_t cpb_port_type,
                                        BOOL8 enet_line_as_pmon,
                                        UINT32 mapper_chnl,
                                        UINT32 enet_link);

PRIVATE BOOL digi_mapper_enet_line_db_test_update(digi_handle_t *digi_handle, 
                                                  UINT32 schd_addr,
                                                  util_global_cpb_port_t cpb_port_type,
                                                  BOOL8 enet_line_as_pmon,
                                                  UINT32 mapper_chnl,
                                                  UINT32 enet_link);
PRIVATE BOOL digi_mapper_mapotn_db_test_update(digi_handle_t *digi_handle, 
                                               UINT32 schd_addr,
                                               util_global_cpb_port_t cpb_port_type,
                                               BOOL8 enet_line_as_pmon,
                                               UINT32 mapper_chnl,
                                               UINT32 enet_link);


PRIVATE PMC_ERROR digi_mapper_db_clear(digi_handle_t *digi_handle, 
                                       util_global_cpb_port_t cpb_port_type,
                                       UINT32 mapper_chnl,
                                       UINT32 enet_link,
                                       BOOL8 is_umbilical_case);

PRIVATE PMC_ERROR digi_mapper_db_prov_cfg(digi_handle_t *digi_handle, 
                                          digi_mapper_primary_group_t p_group, 
                                          digi_mapper_secondary_group_t s_group, 
                                          digi_group_size_t group_size,
                                          util_global_cpb_port_t cpb_port_type,
                                          BOOL8 enet_line_as_pmon,
                                          UINT32 mapper_chnl,
                                          UINT32 enet_link, 
                                          UINT32 num_cal_entry_req);

PRIVATE BOOL digi_cbrc_db_test_update(digi_handle_t *digi_handle,
                                      UINT32 schd_addr,
                                      UINT32 cbrc_port, 
                                      UINT32 cbrc_dcs_inst,
                                      BOOL8  no_cpb_cfg);
                                      
PRIVATE PMC_ERROR digi_cbrc_db_clear(digi_handle_t *digi_handle,
                                     UINT32 cbrc_port, 
                                     UINT32 cbrc_dcs_inst);                                          

PRIVATE PMC_ERROR digi_coreotn_ho_db_clear(digi_handle_t *digi_handle,
                                           UINT32 ho_chnl_id);

PRIVATE PMC_ERROR digi_oduksw_sifd_db_prov_cfg(digi_handle_t *digi_handle,
                                               digi_sifd_ilkn_inst_t sifd_ilkn_inst,
                                               UINT32 chnl,
                                               UINT8 num_cal_entry_req,
                                               BOOL8 sifd_db); 
                                               
PRIVATE BOOL digi_oduksw_sifd_db_test_update(digi_handle_t *digi_handle,
                                             digi_sifd_ilkn_inst_t sifd_ilkn_inst,
                                             UINT32 schd_addr,
                                             UINT32 chnl,
                                             BOOL8 sifd_db);


/* Internal functions that are used for COREOTN datapath */
PRIVATE PMC_ERROR digi_otn_server_lo_ch_id_and_trib_port_get(digi_handle_t *digi_handle,
                                                             odu_struct_t * ho_odu_struct_ptr,   
                                                             UINT32 tx_trib_slot_mask[3],
                                                             UINT32 rx_trib_slot_mask[3],
                                                             UINT32 ho_cal_entry_ptr[DIGI_SCHD_96_ENTRY],
                                                             digi_odu_line_payload_t lo_payload_mode,
                                                             UINT32 *chnl_id,
                                                             UINT32 *tx_trib_port,
                                                             UINT32 *rx_trib_port,
                                                             BOOL *prov_rx,
                                                             BOOL *prov_tx);

PRIVATE PMC_ERROR digi_otn_server_lo_prov_internal( digi_handle_t *digi_handle,
                                                    digi_otn_odu_chnl_t *in_chnl_ctxt_ptr,
                                                    digi_otn_cfg_mode_t cfg_mode,
                                                    digi_oduk_t oduk_type,
                                                    DOUBLE client_bitrate,
                                                    digi_otn_mapping_type_t mapping_mode,
                                                    UINT32 tx_trib_slot_mask[3],
                                                    UINT32 rx_trib_slot_mask[3],
                                                    digi_odu_line_payload_t payload_mode,
                                                    digi_otn_odu_chnl_t **out_chnl_ctxt_pptr,
                                                    BOOL prov_ho_cfg);                                                             
                                                             
PRIVATE PMC_ERROR digi_otn_server_tx_lo_prov(digi_handle_t *digi_handle,
                                             odu_chnl_t *local_ho_odu_chnl_ptr,
                                             UINT32 lo_chnl_id,
                                             digi_otn_mux_stages_t mux_stage,
                                             util_global_odukp_type_t odu_container,
                                             UINT32 num_client_odu0,
                                             DOUBLE client_bitrate,
                                             util_global_mapping_mode_t mapping_type,
                                             UINT32 tx_trib_slot_mask[3],
                                             UINT32 trib_port,
                                             digi_odu_line_payload_t payload_mode,
                                             BOOL prov_ho_cfg);
                                             
PRIVATE PMC_ERROR digi_otn_server_rx_lo_prov(digi_handle_t *digi_handle,
                                             odu_chnl_t *local_ho_odu_chnl_ptr,
                                             UINT32 lo_chnl_id,
                                             digi_otn_mux_stages_t mux_stage,
                                             util_global_odukp_type_t odu_container,
                                             UINT32 num_client_odu0,
                                             DOUBLE client_bitrate,
                                             util_global_mapping_mode_t mapping_type,
                                             UINT32 rx_trib_slot_mask[3],
                                             UINT32 trib_port,
                                             digi_odu_line_payload_t payload_mode,
                                             BOOL prov_ho_cfg);
                                             
PRIVATE PMC_ERROR digi_oduksw_rate_get(digi_oduksw_stream_t rate_data,
                                       util_global_odukp_type_t *odu_type);

PRIVATE void digi_mcpb_halt_buffer_size_set (cpb_mcpb_egr_output_port_type_t egr_port,
                                             cpb_mcpb_ingr_input_port_type_t ingr_port,
                                             UINT32                          rate,
                                             UINT32                          *halt_buffer_size);

PUBLIC PMC_ERROR digi_oduk_rate_param_convert( digi_oduk_t oduk_type,
                                               util_global_odukp_type_t *odu_type );

PUBLIC PMC_ERROR digi_odu_rate_param_convert( util_global_odukp_type_t odu_type,
                                              digi_oduk_t *oduk_type);

PUBLIC PMC_ERROR digi_oduk_rate_num_cal_slot_get( util_global_odukp_type_t client_oduk_type,
                                                  util_global_odukp_type_t server_oduk_type,
                                                  UINT32 *num_cal_slots );

PRIVATE PMC_ERROR digi_coreotn_mapping_mode_convert( digi_otn_mapping_type_t mapping_type,
                                                     util_global_mapping_mode_t *mapping_mode );  
                                                     
PRIVATE PMC_ERROR digi_coreotn_mapping_mode_convert_reverse(util_global_mapping_mode_t mapping_mode,
                                                            digi_otn_mapping_type_t *mapping_type);

PRIVATE PMC_ERROR digi_coreotn_ho_chnl_bypass_cfg(digi_handle_t *digi_handle,
                                                  util_global_odukp_type_t odu_container,
                                                  digi_odu_line_payload_t payload_mode);                                                     

PRIVATE digi_cbr_client_chnl_def_t* digi_cbr_client_chnl_get(digi_handle_t* digi_handle, 
                                                             digi_serdes_port_mode_t serdes_mode,
                                                             UINT32 cbrc_link, 
                                                             UINT32 mux_link,
                                                             UINT32 port_uid,
                                                             digi_cbr_client_mode_t mode);
PRIVATE digi_mapper_chnl_def_t* digi_mapper_client_chnl_get(digi_handle_t* digi_handle, 
                                                            UINT32 oduk_chnl, 
                                                            UINT32 cpb_chnl,
                                                            util_global_cpb_port_t cpb_port_type);

PRIVATE digi_otn_server_chnl_def_t* digi_otn_server_line_client_chnl_get(digi_handle_t* digi_handle, 
                                                                         UINT32 dci_chnl);

PRIVATE digi_otn_server_chnl_def_t* digi_sysotn_server_line_client_chnl_get(digi_handle_t* digi_handle);


PRIVATE odu_struct_t* digi_ho_odu_struct_chnl_get(digi_handle_t* digi_handle, 
                                                  UINT32 chnl_id);

PRIVATE odu_struct_t* digi_mo_odu_struct_chnl_get(digi_handle_t* digi_handle, 
                                                  UINT32 chnl_id);

PRIVATE odu_struct_t* digi_lo_odu_struct_chnl_get(digi_handle_t* digi_handle, 
                                                  UINT32 chnl_id);
PRIVATE odu_struct_t* digi_s3b_odu_struct_chnl_get(digi_handle_t* digi_handle, 
                                                   UINT32 chnl_id);                                                  
PRIVATE odu_struct_t* digi_sysapp_line_odu_struct_chnl_get(digi_handle_t* digi_handle, 
                                                           UINT32 chnl_id);

PRIVATE void digi_ilkn_chnl_state_reset(digi_handle_t *digi_handle, 
                                        UINT32 channel,
                                        BOOL8 ILKN1);

                                                
PRIVATE PMC_ERROR digi_sifd_config(digi_handle_t *digi_handle,
                                   digi_sifd_ilkn_1_cfg_t *digi_sifd_ilkn_1_cfg_ptr,
                                   digi_sifd_ilkn_2_cfg_t *digi_sifd_ilkn_2_cfg_ptr,
                                   digi_ilkn_link_t **ilkn_1_ctxt_pptr,
                                   digi_ilkn_link_t **ilkn_2_ctxt_pptr);
 
                                                   
PRIVATE PMC_ERROR digi_non_otn_acb_ckctl_routing(digi_handle_t *digi_handle,
                                                 util_global_switch_data_t *input_pc_ptr, 
                                                 util_global_switch_data_t *output_pc_ptr,
                                                 digi_serdes_acb_mode_t acb_timing_mode,
                                                 digi_serdes_intf_t intf,
                                                 UINT32 ckctl_port,
                                                 BOOL8 use_digi_m1); 

PRIVATE PMC_ERROR digi_non_otn_acb_ckctl_line_cfg(digi_handle_t *digi_handle,
                                                  util_global_switch_data_t *input_pc_ptr,
                                                  util_global_switch_data_t *output_pc_ptr,
                                                  digi_serdes_cfg_action_t serdes_cfg_action,
                                                  digi_serdes_acb_mode_t acb_timing_mode,
                                                  UINT32 num_port,
                                                  UINT32 port_uid,
                                                  UINT32 master_lane,
                                                  digi_enet_tx_timing_mode_t force_enet_timing_mode);

PRIVATE PMC_ERROR digi_non_otn_acb_ckctl_xfi51_cfg(digi_handle_t *digi_handle,
                                                   util_global_switch_data_t *input_pc_ptr,
                                                   util_global_switch_data_t *output_pc_ptr,
                                                   digi_serdes_cfg_action_t serdes_cfg_action,
                                                   digi_serdes_acb_mode_t acb_timing_mode,
                                                   UINT32 num_port,
                                                   UINT32 port_uid,
                                                   UINT32 master_lane);

PRIVATE PMC_ERROR digi_non_otn_acb_ckctl_sys_cfg(digi_handle_t *digi_handle,
                                                 util_global_switch_data_t *input_pc_ptr,
                                                 util_global_switch_data_t *output_pc_ptr,
                                                 digi_serdes_cfg_action_t serdes_cfg_action,
                                                 digi_serdes_acb_mode_t acb_timing_mode,
                                                 UINT32 num_port,
                                                 UINT32 port_uid,
                                                 UINT32 master_lane,
                                                 digi_enet_tx_timing_mode_t force_enet_timing_mode);
                                                 
PRIVATE PMC_ERROR digi_otn_server_prov_all_lo_prov_end(digi_handle_t *digi_handle,
                                                       digi_otn_odu_chnl_t *in_chnl_ctxt_ptr);

PRIVATE PMC_ERROR digi_otn_server_prov_all_lo_deprov_end(digi_handle_t *digi_handle,
                                                         digi_otn_odu_chnl_t **ho_odu_chnl_ctxt_pptr);

PRIVATE PMC_ERROR digi_otn_acb_ckctl_line_cfg(digi_handle_t *digi_handle,
                                              digi_otn_server_chnl_def_t *otn_server_ptr,
                                              digi_serdes_cfg_action_t serdes_cfg_action,
                                              UINT32 num_10g_data_lane,
                                              acb_ft_prov_cfg_t* acb_ft_prov_cfg,
                                              UINT32 master_lane);

PRIVATE PMC_ERROR digi_otn_acb_ckctl_xfi51_cfg(digi_handle_t *digi_handle,
                                               digi_otn_server_chnl_def_t *otn_server_ptr,
                                               digi_serdes_cfg_action_t serdes_cfg_action,
                                               UINT32 num_10g_data_lane,
                                               acb_ft_prov_cfg_t* acb_ft_prov_cfg,
                                               UINT32 master_lane);

PRIVATE PMC_ERROR digi_otn_acb_ckctl_sys_cfg(digi_handle_t *digi_handle,
                                             digi_otn_server_chnl_def_t *otn_server_ptr,
                                             digi_serdes_cfg_action_t serdes_cfg_action,
                                             UINT32 num_10g_data_lane,
                                             acb_ft_prov_cfg_t* acb_ft_prov_cfg,
                                             UINT32 master_lane);
PRIVATE PMC_ERROR digi_otn_acb_ckctl_routing(digi_handle_t *digi_handle,
                                             digi_serdes_intf_t intf,
                                             UINT32 ckctl_port, 
                                             UINT32 chnl,
                                             coreotn_mpmo_inst_t *coreotn_mpmo_inst);

PRIVATE PMC_ERROR digi_read_write_status(digi_handle_t *digi_handle);

PRIVATE void digi_toc_cfg(digi_handle_t* digi_handle, BOOL enable);

PRIVATE PMC_ERROR digi_fec_init(digi_handle_t *digi_handle);

PRIVATE PMC_ERROR digi_otn_mapping_mode_validate( digi_handle_t *digi_handle,
                                                  digi_otn_odu_chnl_t *in_chnl_ctxt_ptr,
                                                  digi_oduk_t oduk_type,
                                                  digi_otn_mapping_type_t mapping_mode );

PRIVATE PMC_ERROR digi_serdes_line_port_init(digi_handle_t *digi_handle,
                                             UINT32 port_uid,
                                             UINT32 module_lane_tx[DIGI_SERDES_XFI_LANES_MAX],
                                             UINT32 module_lane_rx[DIGI_SERDES_XFI_LANES_MAX],
                                             UINT8 los_pin,
                                             BOOL los_inv,
                                             digi_s16_clk_cfg_t *s16_clk_cfg_ptr,
                                             digi_serdes_port_t **port_ctxt_ptr);

PRIVATE PMC_ERROR digi_serdes_line_port_uninit(digi_handle_t *digi_handle,
                                               digi_serdes_port_def_t *port_def_ptr);

PRIVATE PMC_ERROR digi_serdes_sys_port_uninit(digi_handle_t *digi_handle,
                                              digi_serdes_port_def_t *port_def_ptr);

PRIVATE PMC_ERROR digi_serdes_sfi51_port_init(digi_handle_t *digi_handle,
                                              UINT32 port_uid,
                                              UINT32 module_lane_tx[DIGI_NUM_SFI51_PORTS_MAX],
                                              UINT32 module_lane_rx[DIGI_NUM_SFI51_PORTS_MAX],
                                              BOOL los_inv,
                                              digi_serdes_port_t **port_ctxt_pptr);

PRIVATE PMC_ERROR digi_serdes_sys_port_init(digi_handle_t *digi_handle,
                                            UINT32 port_uid,
                                            UINT32 module_lane_tx[DIGI_SERDES_SYS_LANES_MAX],
                                            UINT32 module_lane_rx[DIGI_SERDES_SYS_LANES_MAX],
                                            UINT8 los_pin,
                                            BOOL los_inv,
                                            digi_s16_clk_cfg_t *s16_clk_cfg_ptr,
                                            digi_serdes_port_t **port_ctxt_pptr);

PRIVATE BOOL digi_is_port_uid_unique(digi_handle_t *h,
                                     UINT32 port_uid);


PRIVATE PMC_ERROR digi_line_lane_validate_and_count(digi_handle_t *h,
                                                    UINT32 module_lane_tx[DIGI_SERDES_XFI_LANES_MAX],
                                                    UINT32 module_lane_rx[DIGI_SERDES_XFI_LANES_MAX],
                                                    UINT8 los_pin,
                                                    digi_s16_clk_cfg_t *s16_clk_cfg_ptr,
                                                    UINT8 *gb_count,
                                                    UINT8 *cage_pin_count);

PRIVATE PMC_ERROR digi_line_lane_clear_and_bw_get(digi_handle_t* digi_handle,
                                                  digi_serdes_port_def_t* port_def_ptr,
                                                  UINT8* bw_alloc);

PRIVATE PMC_ERROR digi_sys_lane_clear_and_bw_get(digi_handle_t* digi_handle,
                                                 digi_serdes_port_def_t* port_def_ptr,
                                                 UINT8* bw_alloc);

PRIVATE PMC_ERROR digi_sfi51_bus_validate(digi_handle_t *h,
                                          UINT32 module_lane_tx[DIGI_NUM_SFI51_PORTS_MAX],
                                          UINT32 module_lane_rx[DIGI_NUM_SFI51_PORTS_MAX]);
PRIVATE PMC_ERROR digi_sys_lane_validate_and_count(digi_handle_t *h,
                                                   UINT32 module_lane_tx[DIGI_SERDES_XFI_LANES_MAX],
                                                   UINT32 module_lane_rx[DIGI_SERDES_XFI_LANES_MAX],
                                                   UINT8 los_pin,
                                                   digi_s16_clk_cfg_t *s16_clk_cfg_ptr,
                                                   UINT8 *gb_count,
                                                   UINT8 *cage_pin_count);

PRIVATE UINT8 digi_get_max_bandwidth(digi_prod_app_t prod_app,
                                     BOOL is_cfp);

PRIVATE BOOL digi_is_enhanced_enet_pmon_path(util_global_switch_data_t *input_pc_ptr,
                                             util_global_switch_data_t *output_pc_ptr);

PRIVATE PMC_ERROR digi_conditionaly_provision_enet_line_and_chnl_set(digi_handle_t* digi_handle, 
                                                                     mapotn_src_dest_t mapotn_dest,
                                                                     digi_enet_pmon_type_t enet_pmon_type,
                                                                     UINT32 post_mld_index, 
                                                                     digi_mapping_mode_t mode,
                                                                     UINT32 mapotn_chnl, 
                                                                     UINT32* chnl);

PRIVATE PMC_ERROR digi_otn_server_prov_all_lo_prov_end(digi_handle_t *digi_handle,
                                                       digi_otn_odu_chnl_t *in_chnl_ctxt_ptr);

PRIVATE PMC_ERROR digi_otn_server_prov_all_lo_deprov_end(digi_handle_t *digi_handle,
                                                         digi_otn_odu_chnl_t **ho_odu_chnl_ctxt_pptr);

PRIVATE void digi_mapper_all_params_convert_and_get(digi_handle_t* digi_handle,
                                                    digi_oduk_t odu_data,
                                                    digi_mapping_mode_t mode, 
                                                    BOOL enet_pmon,
                                                    UINT32* odu_flex_data_ptr, 
                                                    util_global_odukp_type_t* oduk_data_ptr,
                                                    digi_group_size_t* group_size_ptr,
                                                    util_global_map_adapt_func_t* map_mode_ptr,
                                                    util_global_map_adapt_func_t* demap_mode_ptr,
                                                    mapotn_src_dest_t* mapotn_src_ptr,
                                                    mapotn_src_dest_t* mapotn_dest_ptr,
                                                    UINT32* oduflex_cbr_rate_ptr);

PRIVATE UINT32 digi_reg_read_internal(digi_handle_t *digi_handle, UINT32 vaddr);

PRIVATE PMC_ERROR digi_line_port_info_internal_get(digi_handle_t *digi_handle,
                                                   digi_port_usage_grp_struct_t* port_grp_usage);
PRIVATE PMC_ERROR digi_cfp_pins_allocate(digi_handle_t* digi_handle);

PRIVATE void  digi_serdes_ctxt_init(digi_handle_t *digi_handle,
                                    BOOL8          serds_cfg_only);

PRIVATE void digi_int_event_callback(void  *handle);
PRIVATE PMC_ERROR digi_int_enabled_check_internal(digi_handle_t *digi_handle);
PRIVATE PMC_ERROR digi_device_int_enabled_check_internal(digi_handle_t   *digi_handle);

PRIVATE void digi_event_init(digi_handle_t *digi_handle, digi_event_cfg_t *event_cfg_ptr);
PRIVATE void digi_event_monitor(digi_handle_t *digi_handle, digi_event_cfg_t *event_cfg_ptr);
PRIVATE void digi_event_destroy(digi_handle_t *digi_handle);
PRIVATE void digi_device_reset(digi_handle_t   *digi_handle);

PRIVATE PMC_ERROR digi_otn_server_ho_internal_prov(digi_handle_t *digi_handle,
                                                   digi_otn_server_chnl_def_t* otn_server_def_ptr,
                                                   digi_otn_cfg_mode_t cfg_mode,
                                                   digi_odu_line_payload_t payload_mode,
                                                   BOOL8 is_src_sysotn_server,
                                                   digi_otn_odu_chnl_t **out_chnl_ctxt_pptr,
                                                   BOOL prov_ho_cfg,
                                                   BOOL prov_dummy_schd);

PRIVATE PMC_ERROR digi_otn_server_prov_all_lo_prov_end(digi_handle_t *digi_handle,
                                                       digi_otn_odu_chnl_t *in_chnl_ctxt_ptr);

PRIVATE PMC_ERROR digi_otn_server_prov_all_lo_deprov_end(digi_handle_t *digi_handle,
                                                         digi_otn_odu_chnl_t **ho_odu_chnl_ctxt_pptr);

PRIVATE PMC_ERROR digi_otn_server_ho_sysapp_internal_prov(digi_handle_t *digi_handle,
                                                          digi_otn_server_chnl_def_t* otn_server_def_ptr,
                                                          digi_otn_odu_chnl_t **out_chnl_ctxt_pptr);

PRIVATE PMC_ERROR digi_otn_server_ho_internal_deprov(digi_handle_t *digi_handle,
                                                     digi_otn_odu_chnl_t** out_chnl_ctxt_pptr,
                                                     digi_otn_server_chnl_def_t* otn_server_ptr,
                                                     BOOL8 is_src_sysotn_server,
                                                     BOOL8 deprov_ho_cfg,
                                                     BOOL8 deprov_dummy_schd);

PRIVATE PMC_ERROR digi_otn_server_ho_sysapp_internal_deprov(digi_handle_t *digi_handle,
                                                            digi_otn_odu_chnl_t** out_chnl_ctxt_pptr,
                                                            digi_otn_server_chnl_def_t* otn_server_ptr);

PRIVATE PMC_ERROR digi_coreotn_dci_mux_xoff_cfg(digi_handle_t *digi_handle,
                                                util_global_odukp_type_t odu_container,
                                                digi_odu_line_payload_t payload_mode);

PRIVATE BOOL8 digi_serdes_is_otn_dp_get(digi_handle_t                *digi_handle,
                                        UINT32                        input_port_type,
                                        util_global_cpb_port_data_t  *output_chnl_ptr);

PRIVATE BOOL digi_serdes_is_valid_100G_3_X_40G_card_config(digi_handle_t* digi_handle);

PRIVATE void digi_software_status_init(digi_handle_t *digi_handle);

PRIVATE PMC_ERROR digi_cpb_prov_and_map_state_check(digi_handle_t *digi_handle,
                                                    util_global_switch_data_def_t *input_pc_ptr,
                                                    util_global_switch_data_def_t *output_pc_ptr);

PRIVATE PMC_ERROR digi_cpb_test_unsupported_mappings(digi_handle_t *digi_handle,
                                                     util_global_cpb_port_data_t *local_input_pc_ptr,
                                                     util_global_cpb_port_data_t *local_output_pc_ptr);

PRIVATE BOOL digi_enet_channel_is_GSUP43_7_3_TRANSPARENT_mode(digi_enet_client_chnl_def_t* enet_chnl_ptr);

PRIVATE PMC_ERROR digi_otn_server_lo_deprov_internal(digi_handle_t *digi_handle,
                                                     digi_otn_odu_chnl_t **lo_odu_chnl_ctxt_pptr,
                                                     digi_otn_odu_chnl_t **ho_odu_chnl_ctxt_pptr,
                                                     digi_otn_asym_deprov_t deprov_flavour,
                                                     BOOL deprov_ho_cfg);

PRIVATE PMC_ERROR digi_otn_acb_reprov_pkt_size_configs(digi_handle_t *digi_handle,
                                                       digi_otn_server_chnl_def_t *otn_server_ptr);
                                                       
PRIVATE PMC_ERROR digi_non_otn_acb_reprov_pkt_size_configs(digi_handle_t *digi_handle,
                                                           util_global_switch_data_t *input_pc_ptr, 
                                                           util_global_switch_data_t *output_pc_ptr,
                                                           digi_enet_tx_timing_mode_t force_enet_timing_mode);
                                                          
PRIVATE PMC_ERROR digi_oduksw_chnl_map_internal(digi_handle_t *digi_handle,
                                                util_global_switch_data_t *input_pc_ptr,
                                                util_global_switch_data_t *output_pc_ptr,
                                                digi_oduksw_stream_t rate_data, UINT32 client_num_odu0,
                                                DOUBLE client_bitrate, UINT32 pkt_size, UINT32 pkt_per_int,
                                                UINT32 pkt_per_n, UINT32 pkt_per_d, BOOL   hys_buffer_en,
                                                UINT32 hys_buffer, UINT32 halt_buffer, UINT32 latency_s);
                                                
PRIVATE void digi_mpma_csi_type_params_convert(digi_opsa_csi_type_t opsa_csi_type,
                                               mpma_csi_type_t* csi_type);

PRIVATE PMC_ERROR digi_otn_server_prov_all_lo_prov_end(digi_handle_t *digi_handle,
                                                       digi_otn_odu_chnl_t *in_chnl_ctxt_ptr);

PRIVATE PMC_ERROR digi_otn_server_prov_all_lo_deprov_end(digi_handle_t *digi_handle,
                                                         digi_otn_odu_chnl_t **ho_odu_chnl_ctxt_pptr);

PRIVATE BOOL8 digi_coreotn_oduksw_is_ilkn_port(digi_handle_t *digi_handle,
                                               util_global_oduk_port_t oduksw_port_num);

PRIVATE PMC_ERROR digi_coreotn_null_sig_recover(digi_handle_t *digi_handle);

PRIVATE void digi_oduksw_bulk_prov_opsa_activate(digi_handle_t* digi_handle,
                                                 util_global_switch_data_t* input_dcs_chnls_per_port[],
                                                 util_global_switch_data_t* output_dcs_chnls_per_port[]);
#endif /* DOXYGEN_PUBLIC_ONLY */

/*
** Public Functions
*/

/*******************************************************************************
* digi_ctxt_create
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Creates and initializes a handle for a DIGI device.
*
*
* INPUTS:
*   *parent               - pointer to parent handle.  If no parent pass in
*                           NULL
*   base_address          - base address of the DIGI device relative to
*                           the device memory space
*   *sys_handle           - pointer to user system handle
*   *tsb_name             - Unique string defining the DIGI device instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   digi_handle_t - pointer to created handle
*
* NOTES:
*
*******************************************************************************/
PUBLIC digi_handle_t *digi_ctxt_create(pmc_handle_t *parent,
                                       UINT32 base_address,
                                       pmc_sys_handle_t *sys_handle,
                                       const char *tsb_name)
{
    UINT32 i;
#ifdef USE_PMC_CTXT_CALLOC
    void *c = NULL;
#endif /* USE_PMC_CTXT_CALLOC */
    digi_handle_t *digi_handle = NULL;
    UINT32 rev_code;
    hostmsg_handle_t *cpup34k_handle = NULL;

    PMC_ENTRY();

#ifdef USE_PMC_CTXT_CALLOC
    c = pmc_ctxt_mem_create(sys_handle, FALSE);
    pmc_ctxt_mem_init(c);
    digi_handle = (digi_handle_t*)(((pmc_ctxt_mgmt_ctxt_t*)c)->header.digi_hdl);

    digi_handle->base.ctxt = c;
#endif /* USE_PMC_CTXT_CALLOC */

    /* Note that it doesn't really matter if we use digi_handle here for the
     * pointer to pmc_handle required by PMC_CTXT_CALLOC.  If we're using the
     * contiguous context, digi_handle is already set and PMC_CTXT_CALLOC will
     * return the same value.  If we're not using the contiguous context, this
     * ends up ignoring the second argument and calling PMC_CALLOC. */
    digi_handle = (digi_handle_t*)PMC_CTXT_CALLOC(sizeof(digi_handle_t), digi_handle);

    pmc_handle_init(parent, digi_handle, sys_handle, PMC_MID_DIGI, tsb_name, base_address);

    gen_db_init_metadata(&digi_handle->base);

    /* initialize mutex */
    digi_handle->base.mutex_ctxt.keep_lock = FALSE;
    digi_handle->base.mutex_ctxt.recursive_level = 0;
    digi_handle->base.mutex_ctxt.user_ctxt = pmc_atomic_create();
    digi_handle->base.mutex_ctxt.suspended_thread_id = PMC_SYS_THREAD_ID_UNSET;

    /* Register log strings */
    pmc_log_block_strings_register(DIGI_LOG_ERR_STRINGS[0], DIGI_LOG_ERR_TABLE_BASE, DIGI_LOG_ERR_COUNT);
    /* Initialize hostmsg handle. */
    hostmsg_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_CPUP34K_APB_AXI_MTSB, sys_handle, HOSTMSG_HANDLE_NAME);

    digi_handle->dcpb_handle = cpb_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_DCPB_MTSB, sys_handle, DCPB_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->dcpb_handle, digi_handle);
    digi_handle->mcpb_handle = cpb_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_MCPB_MTSB, sys_handle, MCPB_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->mcpb_handle, digi_handle);
    digi_handle->enet_sys_handle = enet_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_ENET120_SYS_MTSB, sys_handle, ENET_SYS_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->enet_sys_handle, digi_handle);
    digi_handle->enet_line_handle = enet_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_ENET120_LINE_MTSB, sys_handle, ENET_LINE_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->enet_line_handle, digi_handle);
    digi_handle->sifd_handle = sifd_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_SIFD_MTSB, sys_handle, SIFD_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->sifd_handle, digi_handle);
    digi_handle->lifd_handle = lifd_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_LIFD_MTSB , sys_handle, LIFD_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->lifd_handle, digi_handle);
    digi_handle->cbrc_handle = cbrc_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_CBRC_MTSB, sys_handle, CBRC_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->cbrc_handle, digi_handle);
    digi_handle->mapotn_handle = mapotn_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_MAPOTN_MTSB, sys_handle, MAPOTN_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->mapotn_handle, digi_handle);
    digi_handle->coreotn_handle = coreotn_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_COREOTN_MTSB, sys_handle, COREOTN_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->coreotn_handle, digi_handle);
    digi_handle->lineotn_handle = lineotn_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_LINEOTN_MTSB, sys_handle, LINEOTN_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->lineotn_handle, digi_handle);
    digi_handle->sysotn_handle = lineotn_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_SYSOTN_MTSB, sys_handle, LINEOTN_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->sysotn_handle, digi_handle);
 

    digi_handle->s16_sys_handle = s16_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_S16_SYS_PM55_82_50_BRIDGE_MTSB(0), sys_handle, S16_SYS_HANDLE_NAME, S16_SYSTEM);
    PMC_CTXT_REGISTER_PTR(&digi_handle->s16_sys_handle, digi_handle);
    digi_handle->s16_line_handle = s16_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_S16_LINE_PM55_82_50_BRIDGE_MTSB(0), sys_handle, S16_LINE_HANDLE_NAME, S16_LINE);
    PMC_CTXT_REGISTER_PTR(&digi_handle->s16_line_handle, digi_handle);

    /* there are 2xSFI51_TX_18X and 2xSFI51_RX_18X blocks in DIGI */
    /* Create context associated to SFI51 interface */
    digi_handle->sfi51_d8_tx_18x_handle = (sfi51_d8_tx_18x_handle_t **)PMC_CTXT_CALLOC(sizeof(sfi51_d8_tx_18x_handle_t *) *DIGI_SERDES_MAX_SFI51_D8_TXRX_18X, digi_handle);
    PMC_CTXT_REGISTER_PTR(&digi_handle->sfi51_d8_tx_18x_handle, digi_handle);
    digi_handle->sfi51_d8_rx_18x_handle = (sfi51_d8_rx_18x_handle_t **)PMC_CTXT_CALLOC(sizeof(sfi51_d8_rx_18x_handle_t *) *DIGI_SERDES_MAX_SFI51_D8_TXRX_18X, digi_handle);
    PMC_CTXT_REGISTER_PTR(&digi_handle->sfi51_d8_rx_18x_handle, digi_handle);

    digi_handle->sfi51_d8_tx_18x_handle[0] = sfi51_d8_tx_18x_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_SFI51_TX_0_DIGI120_SFI51_TX_18X_GLUE_MTSB, sys_handle, SFI51_D8_TX_18X_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->sfi51_d8_tx_18x_handle[0], digi_handle);
    digi_handle->sfi51_d8_rx_18x_handle[0] = sfi51_d8_rx_18x_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_SFI51_RX_0_DIGI120_SFI51_RX_18X_GLUE_MTSB, sys_handle, SFI51_D8_RX_18X_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->sfi51_d8_rx_18x_handle[0], digi_handle);
    digi_handle->sfi51_d8_tx_18x_handle[1] = sfi51_d8_tx_18x_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_SFI51_TX_1_DIGI120_SFI51_TX_18X_GLUE_MTSB, sys_handle, SFI51_D8_TX_18X_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->sfi51_d8_tx_18x_handle[1], digi_handle);
    digi_handle->sfi51_d8_rx_18x_handle[1] = sfi51_d8_rx_18x_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_SFI51_RX_1_DIGI120_SFI51_RX_18X_GLUE_MTSB, sys_handle, SFI51_D8_RX_18X_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->sfi51_d8_rx_18x_handle[1], digi_handle);


    /* create context context associated LR backplane interface */
    /* create context context associated LR backplane interface */
    digi_handle->bp_lr_t8_handle = (t8_handle_t **)PMC_CTXT_CALLOC(sizeof(t8_handle_t *) * DIGI_SERDES_MAX_T8_2X, digi_handle);
    PMC_CTXT_REGISTER_PTR(&digi_handle->bp_lr_t8_handle, digi_handle);
    for (i = 0; i < DIGI_SERDES_MAX_T8_2X; i++)
    {
        digi_handle->bp_lr_t8_handle[i] = t8_ctxt_create((pmc_handle_t *)digi_handle, 
                                                         base_address+BASE_ADDR_DIGI120_TITAN_SERDES_PM20_82_24_MTSB(i), 
                                                         sys_handle, BP_LR_T8_HANDLE_NAME);
        PMC_CTXT_REGISTER_PTR(&digi_handle->bp_lr_t8_handle[i], digi_handle);
    }

    /* create context context associated SR backplane interface */
    digi_handle->bp_sr_c8_handle = c8_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_C8_SERDES_CNI_UNI_TXRX_MTSB(0), sys_handle, BP_SR_C8_HANDLE_NAME);
    PMC_CTXT_REGISTER_PTR(&digi_handle->bp_sr_c8_handle, digi_handle);
    
    /* create context associated to GE interface */
    digi_handle->ge_intf_handle = (digi_ge_serdes_handle_t *)PMC_CTXT_CALLOC(sizeof(digi_ge_serdes_handle_t), digi_handle);
    PMC_CTXT_REGISTER_PTR(&digi_handle->ge_intf_handle, digi_handle);

    for (i = 0; i <  DIGI_GE_SERDES_D8_2X_MAX; i++)
    {
        digi_handle->ge_intf_handle->d8_tx_2x_handle[i] = d8_tx_2x_ctxt_create(
            (pmc_handle_t *)digi_handle,
            base_address+BASE_ADDR_DIGI120_OH_RCP_ENET_MGMT_D8_TX_SFI51_TX_2X_SLICE(i), 
            sys_handle, GE_TX_HANDLE_NAME[i],
            GE_SERDES_D8_RX_18X_GEN_MON_BUS_WIDTH_VAL
            );
        PMC_CTXT_REGISTER_PTR(&digi_handle->ge_intf_handle->d8_tx_2x_handle[i], digi_handle);
        digi_handle->ge_intf_handle->d8_rx_2x_handle[i] = d8_rx_2x_ctxt_create(
            (pmc_handle_t *)digi_handle,
            base_address+BASE_ADDR_DIGI120_OH_RCP_ENET_MGMT_D8_RX_SFI5_1_RX_2X_SERDES_SLICE_MTSB(i), 
            sys_handle, GE_RX_HANDLE_NAME[i],
            GE_SERDES_D8_RX_18X_GEN_MON_BUS_WIDTH_VAL);
        PMC_CTXT_REGISTER_PTR(&digi_handle->ge_intf_handle->d8_rx_2x_handle[i], digi_handle);
    }
    
    /* create MGMT_FEGE handle */
    digi_handle->mgmt_fege_handle = mgmt_fege_ctxt_create((pmc_handle_t *)digi_handle, base_address+BASE_ADDR_DIGI120_DIGI_M1_MGMT_FEGE_MGMT_FEGE_TOP, sys_handle, MGMT_FEGE_HANDLE_NAME, base_address+BASE_ADDR_DIGI120_DIGI_M1_ENET_FEGE_MTSB );
    PMC_CTXT_REGISTER_PTR(&digi_handle->mgmt_fege_handle, digi_handle);

    /* register ENET pointer associated to a mapper handle*/
    for (i = 0; i <  DIGI_MAPOTN_CHNL_MAX; i++)
    {
        PMC_CTXT_REGISTER_PTR(&digi_handle->handle_pool.mapper_chnl[i].enet_pmon_data,
                              digi_handle);
    }

    /*
     * Moved the retrieval of the revision code to ctxt_create from 
     * digi_handle_init
     */
    digi_handle->digi_sw_status.device_revision_code = DIGI_REVISION_CODE_REV_A;
    cpup34k_handle = (hostmsg_handle_t *)(digi_handle->base.common_info->hostmsg_handle);
    PMC_ASSERT((NULL != cpup34k_handle),HOSTMSG_ERR_INVALID_PARAMETERS,0,0);

    /* get the revision code value from the register */
    rev_code = cpup34k_field_REVISION_CODE_get(NULL,(pmc_handle_t *)cpup34k_handle);
    rev_code = DIGI_REVISION_CODE_REV_B;    // change by xxu1
    
#ifdef PMC_SW_SIMULATION
    rev_code = DIGI_REVISION_CODE_REV_B;
#endif
    if (DIGI_REVISION_CODE_REV_A == rev_code ||
        DIGI_REVISION_CODE_REV_B == rev_code)
    {
        digi_handle->digi_sw_status.device_revision_code = (UINT8) rev_code;
    }
    else
    {
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_REVISION, 0, 0);
    }
    digi_handle->base.common_info->device_revision_code = digi_handle->digi_sw_status.device_revision_code;
    /* enable the log buffer */
    digi_handle->base.common_info->log_buffer = (void *)pmc_circbuf_init((void *)digi_handle);

    /* dynamic context allocation */
    digi_dynamic_ctxt_alloc(digi_handle,TRUE);

    PMC_RETURN(digi_handle);
} /* digi_ctxt_create */

/*******************************************************************************
* digi_ctxt_restart_create
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Recreates the digi context by calling pmc_ctxt_mem_create() again which will
*   end up calling the pmc_mem_ctxt_restore() porting function to restore the
*   context.  The mutex is re-created and all the pointers in the context are
*   updated in case the context has a new base address.
*
* INPUTS:
*   data_ptr      - no longer used.
*   sys_handle    - System handle copied into the digi_handle
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   digi_handle_t - pointer to created handle
*
* NOTES:
*
*******************************************************************************/
PUBLIC digi_handle_t *digi_ctxt_restart_create(void *data_ptr,
                                               pmc_sys_handle_t *sys_handle)
{
    digi_handle_t *digi_handle = NULL;
    void *restored_ctxt;

    PMC_ENTRY();

#ifdef PMC_SW_SIMULATION
    /* data_ptr is used in SW_SIMULATION for some testcases to simulate a warm
     * restart */
    restored_ctxt = data_ptr;
#else
    restored_ctxt = pmc_ctxt_mem_create(sys_handle, TRUE);
#endif

    if (NULL == restored_ctxt ||
        NULL == ((pmc_ctxt_mgmt_ctxt_t*)restored_ctxt)->header.digi_hdl)
    {
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
    }
    pmc_ctxt_update_pointers(restored_ctxt);
    digi_handle = (digi_handle_t*)((pmc_ctxt_mgmt_ctxt_t*)restored_ctxt)->header.digi_hdl;

    /* 
       initialize mutex              
       keep_lock and recursive_level are kept in the context
       they could be used to identify incoherency
    */
    digi_handle->base.mutex_ctxt.user_ctxt = pmc_atomic_create();
    digi_handle->base.mutex_ctxt.suspended_thread_id = PMC_SYS_THREAD_ID_UNSET;
    digi_handle->base.mutex_ctxt.suspended_recursive_level = 0;
    digi_handle->base.mutex_ctxt.current_thread_id = 0;

    /* dynamic context allocation */
    digi_dynamic_ctxt_alloc(digi_handle,TRUE);
    
    /* Initialize serdes adaptation parameters context*/    
    digi_serdes_ctxt_init(digi_handle, TRUE);
    
    /*
     * Updated the sys_handle pointer which in a restart should have
     * changed. Then call the pmc_handle function to update all the under
     * lying sys handles as well.
     */
    PMC_LOG_TRACE("DigiHandle Systemhandle=%p. New Handle=%p\n",
                  ((pmc_handle_t *)digi_handle)->sys_handle, sys_handle);
    ((pmc_handle_t *)digi_handle)->sys_handle = sys_handle;
    pmc_handle_fix_sys_handle_ptrs((pmc_handle_t *)digi_handle);

    PMC_LOG_TRACE("BaseAddress=%d and DeviceName=%s\n", 
                  ((pmc_handle_t*)digi_handle)->base_address,
                  ((pmc_handle_t*)digi_handle)->tsb_name);
    /*
     * FW file should not be needed for a restart and reset it to NULL to
     * ensure it is not FREED.
     */
    digi_handle->var.fw_filename = NULL;
    digi_handle->var.fw_pathname = NULL;
    digi_handle->base.mutex_ctxt.recursive_level |= (1 << 31);

    PMC_RETURN(digi_handle);
} /* digi_ctxt_restart_create */

/*******************************************************************************
* digi_ctxt_destroy
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Destroys a handle for a DIGI device.
*
*
* INPUTS:
*   **digi_handle         - pointer to DIGI handle instance
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_ctxt_destroy(digi_handle_t **digi_handle)
{
    UINT32 i;

    PMC_ENTRY();

    if (digi_handle != NULL) {

        digi_handle_t *digi_h_ptr = *digi_handle;

#ifdef DIGI_FW_STATS
        digi_fw_show_firmware_errors(digi_h_ptr);
#endif

        /* dynamic context allocation */
        digi_dynamic_ctxt_alloc(digi_h_ptr,FALSE);

        /* Check for unregistered pointers in the context */
        pmc_ctxt_log_unregistered_pointers(digi_h_ptr->base.ctxt);
        pmc_handle_mid_verify(digi_h_ptr, PMC_MID_DIGI);
        digi_h_ptr->base.tsb_mid = PMC_MID_INVALID;
        
        /* destroy the circbuf */
        pmc_circbuf_destroy( (void *)digi_h_ptr, (pmc_circbuf_t *)digi_h_ptr->base.common_info->log_buffer);
    
        /* delete mutex */
        pmc_atomic_internal_delete(&digi_h_ptr->base.mutex_ctxt);

        digi_ghao_ctxt_destroy(digi_h_ptr);

        sifd_ctxt_destroy(digi_h_ptr->sifd_handle);
        lifd_ctxt_destroy(digi_h_ptr->lifd_handle);
        lineotn_ctxt_destroy(digi_h_ptr->lineotn_handle);
        lineotn_ctxt_destroy(digi_h_ptr->sysotn_handle);
        cpb_ctxt_destroy(digi_h_ptr->dcpb_handle);
        cpb_ctxt_destroy(digi_h_ptr->mcpb_handle);
        cbrc_ctxt_destroy(digi_h_ptr->cbrc_handle);
        enet_ctxt_destroy(digi_h_ptr->enet_sys_handle);
        enet_ctxt_destroy(digi_h_ptr->enet_line_handle);
        mapotn_ctxt_destroy(digi_h_ptr->mapotn_handle);
        coreotn_ctxt_destroy(digi_h_ptr->coreotn_handle);
        
        hostmsg_ctxt_destroy((pmc_handle_t *)digi_h_ptr);
        s16_ctxt_destroy(digi_h_ptr->s16_sys_handle);
        s16_ctxt_destroy(digi_h_ptr->s16_line_handle);

        for (i = 0; i < DIGI_SERDES_MAX_SFI51_D8_TXRX_18X; i++)
        {
            sfi51_d8_tx_18x_ctxt_destroy(digi_h_ptr->sfi51_d8_tx_18x_handle[i]);
            sfi51_d8_rx_18x_ctxt_destroy(digi_h_ptr->sfi51_d8_rx_18x_handle[i]);
        }
        
        PMC_CTXT_FREE(&digi_h_ptr->sfi51_d8_tx_18x_handle, digi_h_ptr);
        PMC_CTXT_FREE(&digi_h_ptr->sfi51_d8_rx_18x_handle, digi_h_ptr);


        for (i = 0; i < DIGI_SERDES_MAX_T8_2X; i++)
        {
            t8_ctxt_destroy(digi_h_ptr->bp_lr_t8_handle[i]);
        }
        
        PMC_CTXT_FREE(&digi_h_ptr->bp_lr_t8_handle, digi_h_ptr);


        c8_ctxt_destroy(digi_h_ptr->bp_sr_c8_handle);
        
        for (i = 0; i <  DIGI_GE_SERDES_D8_2X_MAX; i++)
        {           
            d8_tx_2x_ctxt_destroy(digi_h_ptr->ge_intf_handle->d8_tx_2x_handle[i]);
            d8_rx_2x_ctxt_destroy(digi_h_ptr->ge_intf_handle->d8_rx_2x_handle[i]);
        }

        PMC_CTXT_FREE(&digi_h_ptr->ge_intf_handle, digi_h_ptr);

        mgmt_fege_ctxt_destroy(digi_h_ptr->mgmt_fege_handle);

        /*destroy databases*/    
        gen_all_db_destroy(&digi_h_ptr->base);

        /* Free the space used for the event table */
        digi_event_destroy(digi_h_ptr);

        /* Free the space used to store the firmware filename */
        if (NULL != digi_h_ptr->var.fw_filename) {
            PMC_FREE(&(digi_h_ptr->var.fw_filename));
        }

        if(digi_h_ptr->var.fw_pathname != NULL) {
            PMC_FREE(&(digi_h_ptr->var.fw_pathname));
        }

        PMC_CTXT_FREE(digi_handle, digi_h_ptr);
#ifdef USE_PMC_CTXT_CALLOC
        pmc_ctxt_mem_destroy(digi_h_ptr->base.ctxt);
#endif /* USE_PMC_CTXT_CALLOC */

    }

    PMC_RETURN();
} /* digi_ctxt_destroy */


/*******************************************************************************
* digi_ctxt_status_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns the prior saved context fields.
*
* INPUTS:
*   ctxt_ptr   - pointer to a DIGI context 
*
* OUTPUTS:
*   *ctxt_data_ptr  - Pointer to stuctire that contain the returned context fields.
*
* RETURNS:
*   PMC_SUCCESS - on success, DIGI_ERR_NULL_HANDLE otherwise.
*
* NOTES:
*       The ctxt_ptr could be retreived from digi_warm_restart_context_get 
*       or when creating the context in pmc_customers.h
*       digi_ctxt_create-> pmc_ctxt_mem_create -> pmc_mem_pool_create(..,PMC_MEM_POOL_TYPE_CONTEXT,...)) 
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ctxt_status_get(void * ctxt_ptr,
                              digi_ctxt_build_t *ctxt_data_ptr)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    pmc_ctxt_mgmt_header_t   *ctxt;
    

    PMC_ENTRY();

    ctxt = (pmc_ctxt_mgmt_header_t*)ctxt_ptr;

    PMC_LOG_TRACE(" ctxt_ptr sw_version %p \n", &ctxt->sw_version );

    if (ctxt == NULL) {
      rc = DIGI_ERR_NULL_HANDLE;
    }
    else {          
      ctxt_data_ptr->build_version = ctxt->sw_version;
      ctxt_data_ptr->ctxt_size = ctxt->total_size;
      rc = PMC_SUCCESS;
    }
      
    
    
    PMC_RETURN(rc);
} /* digi_ctxt_status_get */




/* LCOV_EXCL_START */


/*******************************************************************************
* digi_ctxt_v3_xx_to_v3_yy_migrate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Migrates a digi_ctxt from version 3.xx to version 3.yy with just MEMCPY.
*
*
* INPUTS:
*   *final_ptr              - pointer to the migrated 3.yy context.  If this
*                               is NULL, the context is to be migrated in place.
*   *original_ptr           - pointer to the previous 3.xx context.
*   *temp_ptr               - pointer to a temporary area.
*                               temp_ptr must point to memory at least as large
*                               as the maximum of the sizes of the xx and yy 
*                               contexts.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - if the migration succeeded.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ctxt_v3_xx_to_v3_yy_migrate(void *final_ptr, 
                                                  void *original_ptr, 
                                                  void *temp_ptr)
{
    PMC_ERROR rc = PMC_SUCCESS;
    UINT32 final_size;
    UINT32 original_size;

    PMC_ENTRY();

    original_size = digi_ctxt_v3_xx_size_get();
    final_size = digi_ctxt_v3_yy_size_get();

    if (NULL == final_ptr) 
    {
        /* This doesn't really do anything useful here, but assuming we would
         * need something done with temp_ptr ... */
        PMC_MEMCPY(temp_ptr, original_ptr, final_size);
    }
    else
    {
        PMC_MEMCPY(final_ptr, original_ptr, original_size);
    }

    PMC_RETURN(rc);
} /* digi_ctxt_v3_xx_to_v3_yy_migrate */

/*******************************************************************************
* digi_ctxt_v3_xx_size_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the size of the 3_xx (current) context.
*
* INPUTS:
*   None.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32 - The size of the 3_xx context.
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_ctxt_v3_xx_size_get()
{
    UINT32 rc = 0;

    PMC_ENTRY();
    
    rc = sizeof(pmc_ctxt_mgmt_ctxt_t);

    PMC_RETURN(rc);
} /* digi_ctxt_v3_xx_size_get */

/*******************************************************************************
* digi_ctxt_v3_05_to_v3_06_migrate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Migrates a digi_ctxt from version 3.05 to version 3.06.  Note there were
*   no changes in the digi_ctxt between these two releases so this function
*   is a MEMCPY operation with no changes.  It is included if an automatic
*   set of migrations is being implemented.
*
* INPUTS:
*   *final_ptr              - pointer to the migrated 3.06 context.  If this
*                               is NULL, the context is to be migrated in place.
*   *original_ptr           - pointer to the previous 3.05 context.
*   *temp_ptr               - pointer to a temporary area.
*                               temp_ptr must point to memory at least as large
*                               as the maximum of the sizes of the two 
*                               contexts.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - always returned as a MEMCPY.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ctxt_v3_05_to_v3_06_migrate(void *final_ptr, 
                                                  void *original_ptr, 
                                                  void *temp_ptr)
{
    PMC_ERROR rc = PMC_SUCCESS;
    UINT32 final_size;
    UINT32 original_size;

    PMC_ENTRY();

    original_size = digi_ctxt_v3_05_size_get();
    final_size = digi_ctxt_v3_06_size_get();

    if (NULL == final_ptr) 
    {
        /* This doesn't really do anything useful here, but assuming we would
         * need something done with temp_ptr ... */
        PMC_MEMCPY(temp_ptr, original_ptr, final_size);
    }
    else
    {
        PMC_MEMCPY(final_ptr, original_ptr, original_size);
    }

    PMC_RETURN(rc);
} /* digi_ctxt_v3_05_to_v3_06_migrate */

/*******************************************************************************
* digi_ctxt_v3_06_to_v3_07_migrate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Migrates a digi_ctxt from version 3.06 to version 3.07.  Note there were
*   no changes in the digi_ctxt between these two releases so this function
*   is a MEMCPY operation with no changes.  It is included if an automatic
*   set of migrations is being implemented.
*
* INPUTS:
*   *final_ptr              - pointer to the migrated 3.07 context.  If this
*                               is NULL, the context is to be migrated in place.
*   *original_ptr           - pointer to the previous 3.06 context.
*   *temp_ptr               - pointer to a temporary area.
*                               temp_ptr must point to memory at least as large
*                               as the maximum of the sizes of the two 
*                               contexts.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - always returned as a MEMCPY.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ctxt_v3_06_to_v3_07_migrate(void *final_ptr, 
                                                  void *original_ptr, 
                                                  void *temp_ptr)
{
    PMC_ERROR rc = PMC_SUCCESS;
    UINT32 final_size;
    UINT32 original_size;

    PMC_ENTRY();

    original_size = digi_ctxt_v3_06_size_get();
    final_size = digi_ctxt_v3_07_size_get();

    if (NULL == final_ptr) 
    {
        /* This doesn't really do anything useful here, but assuming we would
         * need something done with temp_ptr ... */
        PMC_MEMCPY(temp_ptr, original_ptr, final_size);
    }
    else
    {
        PMC_MEMCPY(final_ptr, original_ptr, original_size);
    }

    PMC_RETURN(rc);
} /* digi_ctxt_v3_06_to_v3_07_migrate */

/*******************************************************************************
* digi_ctxt_v3_07_to_v3_08_migrate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Migrates a digi_ctxt from version 3.07 to version 3.08.  Note there were
*   no changes in the digi_ctxt between these two releases so this function
*   is a MEMCPY operation with no changes.  It is included if an automatic
*   set of migrations is being implemented.
*
* INPUTS:
*   *final_ptr              - pointer to the migrated 3.07 context.  If this
*                               is NULL, the context is to be migrated in place.
*   *original_ptr           - pointer to the previous 3.06 context.
*   *temp_ptr               - pointer to a temporary area.
*                               temp_ptr must point to memory at least as large
*                               as the maximum of the sizes of the two 
*                               contexts.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - always returned as a MEMCPY.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ctxt_v3_07_to_v3_08_migrate(void *final_ptr, 
                                                  void *original_ptr, 
                                                  void *temp_ptr)
{
    PMC_ERROR rc = PMC_SUCCESS;
    UINT32 final_size;
    UINT32 original_size;

    PMC_ENTRY();

    original_size = digi_ctxt_v3_07_size_get();
    final_size = digi_ctxt_v3_08_size_get();

    if (NULL == final_ptr) 
    {
        /* This doesn't really do anything useful here, but assuming we would
         * need something done with temp_ptr ... */
        PMC_MEMCPY(temp_ptr, original_ptr, final_size);
    }
    else
    {
        PMC_MEMCPY(final_ptr, original_ptr, original_size);
    }

    PMC_RETURN(rc);
} /* digi_ctxt_v3_07_to_v3_08_migrate */

/*******************************************************************************
* digi_ctxt_v3_08_to_v3_09_migrate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Migrates a digi_ctxt from version 3.08 to version 3.09.  Note there were
*   no changes in the digi_ctxt between these two releases so this function
*   is a MEMCPY operation with no changes.  It is included if an automatic
*   set of migrations is being implemented.
*
* INPUTS:
*   *final_ptr              - pointer to the migrated 3.09 context. If this
*                             is NULL, the context is to be migrated in place.
*   *original_ptr           - pointer to the previous 3.08 context.
*   *temp_ptr               - pointer to a temporary area.
*                             temp_ptr must point to memory at least as 
*                             large as the maximum of the sizes of the two 
*                             contexts.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - always returned as a MEMCPY.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ctxt_v3_08_to_v3_09_migrate(void *final_ptr, 
                                                  void *original_ptr, 
                                                  void *temp_ptr)
{
    PMC_ERROR rc = PMC_SUCCESS;
    UINT32 final_size;
    UINT32 original_size;

    PMC_ENTRY();

    original_size = digi_ctxt_v3_08_size_get();
    final_size = digi_ctxt_v3_09_size_get();

    if (NULL == final_ptr) 
    {
        /* This doesn't really do anything useful here, but assuming we would
         * need something done with temp_ptr ... */
        PMC_MEMCPY(temp_ptr, original_ptr, final_size);
    }
    else
    {
        PMC_MEMCPY(final_ptr, original_ptr, original_size);
    }

    PMC_RETURN(rc);
} /* digi_ctxt_v3_08_to_v3_09_migrate */


/*******************************************************************************
* digi_ctxt_v3_09_to_v3_10_migrate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Migrates a digi_ctxt from version 3.09 to version 3.10. Note there were
*   no changes in the digi_ctxt between these two releases so this function
*   is a MEMCPY operation with no changes.  It is included if an automatic
*   set of migrations is being implemented.
*
* INPUTS:
*   *final_ptr              - pointer to the migrated 3.09 context. If this
*                             is NULL, the context is to be migrated in place.
*   *original_ptr           - pointer to the previous 3.08 context.
*   *temp_ptr               - pointer to a temporary area.
*                             temp_ptr must point to memory at least as 
*                             large as the maximum of the sizes of the two 
*                             contexts.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - always returned as a MEMCPY.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ctxt_v3_09_to_v3_10_migrate(void *final_ptr, 
                                                  void *original_ptr, 
                                                  void *temp_ptr)
{
    PMC_ERROR rc = PMC_SUCCESS;
    UINT32 final_size;
    UINT32 original_size;

    PMC_ENTRY();

    original_size = digi_ctxt_v3_09_size_get();
    final_size = digi_ctxt_v3_10_size_get();

    if (NULL == final_ptr) 
    {
        /* This doesn't really do anything useful here, but assuming we would
         * need something done with temp_ptr ... */
        PMC_MEMCPY(temp_ptr, original_ptr, final_size);
    }
    else
    {
        PMC_MEMCPY(final_ptr, original_ptr, original_size);
    }

    PMC_RETURN(rc);
} /* digi_ctxt_v3_09_to_v3_10_migrate */

/*******************************************************************************
* digi_ctxt_v3_10_to_v3_11_migrate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Migrates a digi_ctxt from version 3.10 to version 3.11. Note there were
*   no changes in the digi_ctxt between these two releases so this function
*   is a MEMCPY operation with no changes.  It is included if an automatic
*   set of migrations is being implemented.
*
* INPUTS:
*   *final_ptr              - pointer to the migrated 3.11 context. If this
*                             is NULL, the context is to be migrated in place.
*   *original_ptr           - pointer to the previous 3.10 context.
*   *temp_ptr               - pointer to a temporary area.
*                             temp_ptr must point to memory at least as 
*                             large as the maximum of the sizes of the two 
*                             contexts.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - always returned as a MEMCPY.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ctxt_v3_10_to_v3_11_migrate(void *final_ptr, 
                                                  void *original_ptr, 
                                                  void *temp_ptr)
{
    PMC_ERROR rc = PMC_SUCCESS;
    UINT32 final_size;
    UINT32 original_size;

    PMC_ENTRY();

    original_size = digi_ctxt_v3_10_size_get();
    final_size = digi_ctxt_v3_11_size_get();

    if (NULL == final_ptr) 
    {
        /* This doesn't really do anything useful here, but assuming we would
         * need something done with temp_ptr ... */
        PMC_MEMCPY(temp_ptr, original_ptr, final_size);
    }
    else
    {
        PMC_MEMCPY(final_ptr, original_ptr, original_size);
    }

    PMC_RETURN(rc);
} /* digi_ctxt_v3_10_to_v3_11_migrate */

/*******************************************************************************
* digi_ctxt_v3_11_to_v3_12_migrate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Migrates context.
*   Note there were no changes in the digi_ctxt between these two releases so 
*   this function is a MEMCPY operation with no changes. It is included if an 
*   automatic set of migrations is being implemented.
*
* INPUTS:
*   *final_ptr              - pointer to the traget migrated context. If this
*                             is NULL, the context is to be migrated in place.
*   *original_ptr           - pointer to the previous context.
*   *temp_ptr               - pointer to a temporary area.
*                             temp_ptr must point to memory at least as 
*                             large as the maximum of the sizes of the two 
*                             contexts.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - always returned as a MEMCPY.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ctxt_v3_11_to_v3_12_migrate(void *final_ptr, 
                                                  void *original_ptr, 
                                                  void *temp_ptr)
{
    PMC_ERROR rc = PMC_SUCCESS;
    UINT32 final_size;
    UINT32 original_size;

    PMC_ENTRY();

    original_size = digi_ctxt_v3_11_size_get();
    final_size = digi_ctxt_v3_12_size_get();

    if (NULL == final_ptr) 
    {
        /* This doesn't really do anything useful here, but assuming we would
         * need something done with temp_ptr ... */
        PMC_MEMCPY(temp_ptr, original_ptr, final_size);
    }
    else
    {
        PMC_MEMCPY(final_ptr, original_ptr, original_size);
    }

    PMC_RETURN(rc);
} /* digi_ctxt_v3_11_to_v3_12_migrate */

/*******************************************************************************
* digi_ctxt_v3_yy_size_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the size of the 3_yy context.
*
*
* INPUTS:
*   None.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32 - The size of the 3_yy context.
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_ctxt_v3_yy_size_get()
{
    UINT32 rc = 0;

    PMC_ENTRY();
    
    rc = sizeof(pmc_ctxt_mgmt_ctxt_t); /* This returns the current software size */

    PMC_RETURN(rc);
} /* digi_ctxt_v3_yy_size_get */

/*******************************************************************************
* digi_ctxt_v3_05_size_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the size of the 3.05 context. Note it is recommended to use the API
*   digi_ctxt_status_get() which returns the size directly from the context
*   image.
*
* INPUTS:
*   None.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32 - The size of the context.
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_ctxt_v3_05_size_get()
{
    UINT32 rc = 0;

    PMC_ENTRY();
    
    rc = sizeof(pmc_ctxt_mgmt_ctxt_305_t); /* Value that was coded into release */

    PMC_RETURN(rc);
} /* digi_ctxt_v3_05_size_get */

/*******************************************************************************
* digi_ctxt_v3_06_size_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the size of the 3.06 context. Note it is recommended to use the API
*   digi_ctxt_status_get() which returns the size directly from the context
*   image.
*
*
* INPUTS:
*   None.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32 - The size of the context.
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_ctxt_v3_06_size_get()
{
    UINT32 rc = 0;

    PMC_ENTRY();
    
    rc = sizeof(pmc_ctxt_mgmt_ctxt_306_t); /* Value that was coded into release */

    PMC_RETURN(rc);
} /* digi_ctxt_v3_06_size_get */

/*******************************************************************************
* digi_ctxt_v3_07_size_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the size of the 3.07 context. Note it is recommended to use the API
*   digi_ctxt_status_get() which returns the size directly from the context
*   image.
*
* INPUTS:
*   None.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32 - The size of the context.
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_ctxt_v3_07_size_get()
{
    UINT32 rc = 0;

    PMC_ENTRY();
    
    rc = sizeof(pmc_ctxt_mgmt_ctxt_307_t); /* Value that was coded into release */

    PMC_RETURN(rc);
} /* digi_ctxt_v3_07_size_get */

/*******************************************************************************
* digi_ctxt_v3_08_size_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the size of the 3.08 context. Note it is recommended to use the API
*   digi_ctxt_status_get() which returns the size directly from the context
*   image.
*
* INPUTS:
*   None.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32 - The size of the context.
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_ctxt_v3_08_size_get()
{
    UINT32 rc = 0;

    PMC_ENTRY();
    
    rc = sizeof(pmc_ctxt_mgmt_ctxt_308_t); /* Value that was coded into release */

    PMC_RETURN(rc);
} /* digi_ctxt_v3_08_size_get */

/*******************************************************************************
* digi_ctxt_v3_09_size_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the size of the 3.09 context. Note it is recommended to use the API
*   digi_ctxt_status_get() which returns the size directly from the context
*   image.
*
* INPUTS:
*   None.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32 - The size of the context.
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_ctxt_v3_09_size_get()
{
    UINT32 rc = 0;

    PMC_ENTRY();
    /* Value that was coded into release */
    rc = sizeof(pmc_ctxt_mgmt_ctxt_309_t); 

    PMC_RETURN(rc);
} /* digi_ctxt_v3_09_size_get */

/*******************************************************************************
* digi_ctxt_v3_10_size_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the size of the 3.10 context. Note it is recommended to use the API
*   digi_ctxt_status_get() which returns the size directly from the context
*   image.
*
* INPUTS:
*   None.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32 - The size of the context.
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_ctxt_v3_10_size_get()
{
    UINT32 rc = 0;

    PMC_ENTRY();
    /* Value that was coded into release */
    rc = sizeof(pmc_ctxt_mgmt_ctxt_310_t); 

    PMC_RETURN(rc);
} /* digi_ctxt_v3_10_size_get */

/*******************************************************************************
* digi_ctxt_v3_11_size_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the size of the 3.11 context. Note it is recommended to use the API
*   digi_ctxt_status_get() which returns the size directly from the context
*   image.
*
* INPUTS:
*   None.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32 - The size of the context.
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_ctxt_v3_11_size_get()
{
    UINT32 rc = 0;

    PMC_ENTRY();
    /* Value that was coded into release */
    rc = sizeof(pmc_ctxt_mgmt_ctxt_311_t); 

    PMC_RETURN(rc);
} /* digi_ctxt_v3_11_size_get */

/*******************************************************************************
* digi_ctxt_v3_12_size_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the size of the 3.12 context. Note it is recommended to use the API
*   digi_ctxt_status_get() which returns the size directly from the context
*   image.
*
* INPUTS:
*   None.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32 - The size of the context.
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_ctxt_v3_12_size_get()
{
    UINT32 rc = 0;

    PMC_ENTRY();
    /* Value that was coded into release */
    rc = sizeof(pmc_ctxt_mgmt_ctxt_312_t); 

    PMC_RETURN(rc);
} /* digi_ctxt_v3_12_size_get */

/* LCOV_EXCL_STOP */

/*******************************************************************************
* digi_handle_init_uses_fw_q
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures the behaviour of digi_handle_init() to initialize the firmware queue.
*
* INPUTS:
*   initialize_fw_q - TRUE -- digi_handle_init also initializes the firmware queue\n
*                     FALSE -- digi_handle_inti will not initialize the firmware queue.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None 
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_handle_init_uses_fw_q(BOOL8 initialize_fw_q )
{
    PMC_ENTRY();
    digi_handle_init_uses_fw_q_flag = initialize_fw_q;
    PMC_RETURN();
}

/*******************************************************************************
* digi_handle_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Initializes a DIGI device handle instance. This function can also be passed
*   the context information from a previous digi_warm_restart_context_get() call.
*   See the Programmers Manual for details on warm restart.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *warm_restart_ctxt     - This parameter has been deprecated and is
*                            ignored in this function. For initialization
*                            required after a warm or crash restart the
*                            function digi_handle_restart_init should be 
*                            called.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERROR - If there is a failure accessing the PCIe interface required
*               by FW.
*   PMC_ASSERT() if any other initialization or firmware startup failurews
*   PMC_SUCCESS - Otherwise
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_handle_init(digi_handle_t *digi_handle,
                                  void *warm_restart_ctxt)
{
    PMC_ERROR rc = PMC_SUCCESS;
    BOOL bypass_download = FALSE;
    BOOL need_to_wait_fw = FALSE;
    hostmsg_handle_t *cpup34k_handle = NULL;
    UINT32 boot_info = 0;
    digi_cfg_tbl_t temp_digi_cfg_tbl[] = DIGI_CFG_TABLE;
    UINT32 i,j; /* counters */    
    pmc_handle_t *pmc_handle = &digi_handle->base;
#ifdef PMC_TESTS 
    PMC_ATOMIC_ENTRY_VOID(digi_handle);
#else 
    PMC_ATOMIC_ENTRY(digi_handle);
#endif
    /* The initialization has been split into three stages
       1) Validation of parameters.
       2) Initialization of children.
       3) Allocation of structures for future use.
    */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->dcpb_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->mcpb_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->sifd_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->cbrc_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->enet_sys_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->enet_line_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->mapotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* dsi lane algorithm init */
    PMC_MEMCPY(&digi_handle->cfg.digi_cfg_tbl[0], &temp_digi_cfg_tbl[0],sizeof(digi_handle->cfg.digi_cfg_tbl));
    digi_handle->var.lineotn_cfg_num = DSI_ALLOC_NO_CFG_SET;
    digi_handle->var.sysotn_cfg_num = DSI_ALLOC_NO_CFG_SET;
    digi_handle->var.sifd_dcpb_in_use = DIGI_SIFD_NOT_IN_USE;

    /* digi_m1_ctxt */
    PMC_MEMSET(&digi_handle->var.digi_m1_ctxt, 0,sizeof(digi_m1_ctxt_t));
    digi_handle->var.digi_m1_ctxt.is_pmm_lite_configured = FALSE;

    /* initialize ENET handle */
    for (i = 0;i < DIGI_ENET_LINE_CHNL_MAX && PMC_SUCCESS == rc; i++)
    {
        digi_handle->handle_pool.enet_line_chnl[i].timing_mode = LAST_DIGI_ENET_TX_TIMING_MODE;
    }
    for (i = 0;i < DIGI_ENET_SYS_CHNL_MAX && PMC_SUCCESS == rc; i++)
    {
        digi_handle->handle_pool.enet_sys_chnl[i].timing_mode =LAST_DIGI_ENET_TX_TIMING_MODE;
    }

    /* initialize memory to track DCSU initialization state */
    digi_handle->var.dcsu_init_state[DIGI_DCSU_INST_OTN1] = FALSE; 
    digi_handle->var.dcsu_init_state[DIGI_DCSU_INST_OTN2] = FALSE;
    digi_handle->var.sifd_1_major_mode = DIGI_SIFD_PATH_NOT_IN_USE;
    digi_handle->var.sifd_2_major_mode = DIGI_SIFD_PATH_NOT_IN_USE;
    digi_handle->var.dcsu_init_state[DIGI_DCSU_INST_ENET3] = FALSE;
    digi_handle->var.dcsu_init_state[DIGI_DCSU_INST_PTP] = FALSE;

    digi_handle->var.dcsu_init_state[DIGI_DCSU_INST_ENET1] = FALSE; 
    digi_handle->var.dcsu_init_state[DIGI_DCSU_INST_ENET2] = FALSE; 
    
    digi_handle->var.prod_app = LAST_DIGI_PROD_APP;
    
    /* Initialize context used for OTN processing */
    digi_handle->var.mux_stages = LAST_DIGI_OTN_MUX_STAGES;

    for (i = 0; i < DIGI_NUM_ODU_CHNL_TOT; i++)
    {
        digi_handle->var.odu_chnl_payload[i] = LAST_DIGI_ODU_PAYLOAD_FORMAT;
    }  
    
    for (i = 0; i < DIGI_NUM_MO_ODU_CHNL_MAX; i++)
    {
        digi_handle->var.mo_prov_state_rx[i] = FALSE;
        digi_handle->var.mo_prov_state_tx[i] = FALSE;
    }   
          
        
    /*
     * Initialize the bcw channel ids to 0. When assigned the various
     * channels are represened by the various bits which are set to 1 to
     * indicate they are assigned and 0 if unassigned.
     */
    for(i=0; i < DIGI_BCW_CTXT_WORDS; i++)
    {    
        digi_handle->var.rx_bcw_chnl_id_assigned[0][i] = 0;
        digi_handle->var.rx_bcw_chnl_id_assigned[1][i] = 0;
    }

    for(i=0; i<DIGI_DCPB_NUM_DPI_PORTS;i++)
    {
        for(j=0;j<DIGI_CPB_PMON_COUNTERS_PER_PORT;j++)
        {
            digi_handle->var.cpb_port_pmon[i].pmon_counter[j].pmon_mode = CPB_PMON_MODE_DISABLE;
            digi_handle->var.cpb_port_pmon[i].pmon_counter[j].count_drop_packets = FALSE;
            digi_handle->var.cpb_port_pmon[i].pmon_counter[j].count_err_packets = FALSE;
            digi_handle->var.cpb_port_pmon[i].pmon_counter[j].count_oversize_packets = FALSE;
            digi_handle->var.cpb_port_pmon[i].pmon_counter[j].count_good_packets = FALSE;
        }
    }
    for(i=0; i<DIGI_OCPB_NUM_DPI_PORTS;i++)
    {
        for(j=0;j<DIGI_CPB_PMON_COUNTERS_PER_PORT;j++)
        {
            digi_handle->var.oduksw_port_pmon[i].pmon_counter[j].pmon_mode = CPB_PMON_MODE_DISABLE;
            digi_handle->var.oduksw_port_pmon[i].pmon_counter[j].count_drop_packets = FALSE;
            digi_handle->var.oduksw_port_pmon[i].pmon_counter[j].count_err_packets = FALSE;
            digi_handle->var.oduksw_port_pmon[i].pmon_counter[j].count_oversize_packets = FALSE;
            digi_handle->var.oduksw_port_pmon[i].pmon_counter[j].count_good_packets = FALSE;
        }
    }

    digi_handle->var.etrans_dcpb_use_model = FALSE;

    /* ensure MIPS and FW in reset */
    if (PMC_SUCCESS == rc)
    {
        if (digi_fw_is_running(digi_handle))
        {
            /*
             * hostmsg_handle_init will fail if there is an issue 
             * accessing the PCIe interface required by host message 
             * initializations. Assert on the result as a cold restart at
             * this point is requied.
             */
            rc = hostmsg_handle_init((pmc_handle_t*)digi_handle);

            if (PMC_SUCCESS != rc)
            {
                PMC_LOG(PMC_LOG_SEV_HIGHEST, 0, 0, 0,
                        "HOSTMSG Error. PCIe interface failure. Please reset\n");
                PMC_ATOMIC_RETURN(digi_handle, rc);
            }

#ifdef DIGI_FW_STATS
            /* show firmware assertions */
            digi_fw_show_firmware_errors(digi_handle);
#endif

            rc = digi_fw_shutdown_and_put_mips_in_reset(digi_handle);
            if (rc != PMC_SUCCESS) { 
                /* Note that even though FW failed to shutdown, we need to proceed with the next 
                   call because we put MIPS in reset even when FW failed to shutdown. 
                   The assumption is that FW gets stuck in a bad state and must be reset */ 
                PMC_LOG(PMC_LOG_SEV_HIGHEST, DIGI_ERR_FW_FAILED_TO_SHUTDOWN, 0, 0); 
                rc = PMC_SUCCESS;
            } 
        }
    }
    /* reset device execpt MIPS and FW (there are already reset) */
    if (PMC_SUCCESS == rc)
    {
        digi_device_reset(digi_handle);
        pgmrclk_energy_state_reg_toggle(digi_handle);
    }

    digi_software_status_init(digi_handle);

    digi_handle->digi_fw_status.fw_version               = 0;
    digi_handle->digi_fw_status.fw_build                 = 0;
    digi_handle->digi_fw_status.fw_is_alive              = FALSE;
    digi_handle->digi_fw_status.fw_version_not_supported = TRUE;
    digi_handle->digi_fw_status.gen_excp_detected        = FALSE;
    digi_handle->digi_fw_status.sw_rst_detected          = FALSE;
    digi_handle->digi_fw_status.wdog_rst_detected        = FALSE;
    digi_handle->digi_fw_status.fw_is_ready              = FALSE;
    digi_handle->digi_fw_status.bootloader_version       = 0;
    digi_handle->digi_fw_status.bootloader_build         = 0;
  
    /*initialize G.HAO context */
    digi_ghao_ctxt_init(digi_handle);

    /* use a hostmsg handle to access cpup34k block  */        
    cpup34k_handle = (hostmsg_handle_t *)(digi_handle->base.common_info->hostmsg_handle);
    PMC_ASSERT((NULL != cpup34k_handle), HOSTMSG_ERR_INVALID_PARAMETERS, 0, 0);

    /* If this is a cold start, check firmware filename is ?NULL? or not */
    /* If the filename is ?NULL?,download will be skipped */
    /* set last reset reason first regardless of downloading or not */
    digi_handle->digi_sw_status.last_reset_reason = COLD_RESTART;

    /* filename is the DIGI_FW_DOWNLOAD_NULL */
    if (PMC_STRLEN(digi_handle->var.fw_filename) == PMC_STRLEN(DIGI_FW_DOWNLOAD_NULL)) 
    {
        
        if (0==PMC_MEMCMP(digi_handle->var.fw_filename, DIGI_FW_DOWNLOAD_NULL, (PMC_STRLEN(DIGI_FW_DOWNLOAD_NULL)))) 
        {
            bypass_download = TRUE;
        }
        
    }

    if (bypass_download == FALSE)
    {
        /* get status of cpup34k core, then determine how to download firmware */
        boot_info = cpup34k_field_BOOT_INFO_get(NULL, (pmc_handle_t *)cpup34k_handle);
        PMC_LOG_TRACE("Get boot_info throught cpup34k_handle,  boot_info -> 0x%x \n",boot_info);
        
        if (boot_info == DIGI_FW_POLL_BOOT_ENABLE) 
        { /*device hard reset*/

            PMC_LOG_TRACE("calling digi_fw_download_from_hard_reset \n");
            rc = digi_fw_download_from_hard_reset(digi_handle);
            need_to_wait_fw = TRUE;
        } 
        else if ( digi_fw_is_in_reset(digi_handle) ) 
        { 
            PMC_LOG_TRACE("calling digi_fw_download_and_out_of_reset \n");
            /* mips core is already in reset state*/
            rc = digi_fw_download_and_out_of_reset(digi_handle, TRUE);
            need_to_wait_fw = TRUE;
        } 
        else 
        {
            rc = DIGI_ERR_UNKNOWN;                    
            PMC_LOG(PMC_LOG_SEV_HIGH, DIGI_ERR_FW_DOWNLOAD_FAIL, 0, 0,
                    "Digi device is in unknown status and firmware download failed, please hard reset device. \n");                
        }
    }

    if (rc == PMC_SUCCESS) 
    {
        rc = digi_handle_init_children(digi_handle);

        if (PMC_SUCCESS == rc)
        {
            digi_handle_init_alloc(digi_handle);
        }
    }

    if (rc == PMC_SUCCESS) 
    {
        if (TRUE == need_to_wait_fw)
        {
            /* Clear outbound doorbell after FW completes initialization */
            hostmsg_clear_outbound_doorbell(pmc_handle);

            /* Wait for FW start-up to complete */
            rc = digi_fw_poll_for_alive(digi_handle);  
        }
    }

    /* initialize MCPB context */
    if (rc == PMC_SUCCESS) 
    {
        for (i = 0; i < DIGI_MCPB_DCS_MAX; i++)
        {
            digi_handle->var.mcpb_ctxt.mcpb_dcs_num_registered_chnl[i] = 0;
        }
        
        digi_handle->var.mcpb_ctxt.mcpb_mux_mode_init = FALSE;
        digi_handle->var.mcpb_ctxt.mcpb_mgmt_fege_port_cfg = FALSE;
        digi_handle->var.mcpb_ctxt.mcpb_cpu_port_cfg = FALSE;
    }
      
    /* Initialize serdes adaptation parameters context*/
    if (rc == PMC_SUCCESS)   
    {
        digi_serdes_ctxt_init(digi_handle, FALSE);
    }   

    /* Initialize ddeg modes */
    digi_handle->var.linesys_ddeg_mode = DIGI_OTN_HARDWARE_DDEG;
    

    if (rc == PMC_SUCCESS)
    {
        /* initialize firmware stats and logging */
        rc = digi_fw_stats_init(digi_handle);
    }

    /* initialize firmware queue for reading and writing registers */
#ifndef DONT_USE_FW_Q
    if (rc == PMC_SUCCESS) 
    {
        if (digi_handle_init_uses_fw_q_flag)
        {
            rc = digi_fw_performance_queue_init(digi_handle, TRUE);
        }
    }
#endif

    /* Function must pass to continue operations so assert if above operations did
       not complete successfully */
    PMC_ASSERT(PMC_SUCCESS == rc, rc, 0, 0);

    /*new firmware is alive and digi init is done */
    digi_handle->var.digi_state = DIGI_STATE_HANDLE_INIT;
#ifndef PMC_SW_SIMULATION
    /* update firmware status */
    if (PMC_SUCCESS == rc)
    {
        digi_fw_status_t fw_status;
        rc = digi_firmware_status_get(digi_handle,&fw_status);

        PMC_ASSERT(!(digi_handle->digi_fw_status.fw_version_not_supported),  DIGI_SW_FW_DEPENDANCY, 0 , 0);
    }
#endif


    for(i=0;i<DIGI_NUM_LO_ODU_CHNL_MAX;i++)
    {
        digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_MO_SYS, i, FALSE);
        digi_otn_channel_nominal_set(digi_handle, COREOTN_RX_SYS, i, FALSE);
        digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_MO_LINE, i, FALSE);
        digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_LO_LINE, i, FALSE);
        digi_otn_channel_nominal_set(digi_handle, COREOTN_RX_LINE, i, FALSE);
    }
    for(i=0;i<DIGI_NUM_HO_ODU_CHNL_MAX;i++)
    {
        digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_HO_SYS, i, FALSE);
        digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_HO_LINE, i, FALSE);
        digi_otn_channel_nominal_set(digi_handle, SYSOTN_TX, i, FALSE);
        digi_otn_channel_nominal_set(digi_handle, LINEOTN_TX, i, FALSE);
    }

    for(i=0;i<LAST_INTR_IPI_WORKAROUND_RUNNING;i++)
    {
        digi_handle->var.fw_intr_mon_running[i] = FALSE;
    }
    digi_cbr_nominal_fault_init(digi_handle);

    PMC_ATOMIC_RETURN(digi_handle, PMC_SUCCESS);

} /* digi_handle_init */


/*******************************************************************************
* digi_handle_restart_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   Functionality described in this API is subject to change.\n\n
*
*   Handles the initialization of the digi_handle in the case of a crash or
*   warm restart. Ensures that the DIGI Applib SW and underlying HW device
*   are conherent. In the case of WARM restart an error is returned 
*   immediately in the case of any incoherency. In the case of crash 
*   restart the incoherency is resoleed.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   is_warm_restart        - TRUE call is made for a warm restart.
*                            FALSE implies a crash restart.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - Initialization was successful from the perspective of
*                 the restart type
*   PMC_ERROR   - For crash restart there is not at least one 
*                 undirectional path across the device before or after 
*                 all incoherency issues are resolved.
*                 The definition of an operational path is a unidirectional
*                 path between any of: 
*                  Rx Serdes 
*                  Rx Tributary Slots 
*                  Rx BCW channel ID 
*                 And any of 
*                  Tx Serdes 
*                  Tx Tributary Slots 
*                  Tx BCW channel ID 
*                 For warm restart at least one DIGI Applib and HW 
*                 incoherency was found.
*   PMC_ASSERT  - One or more pointers in the digi_handle are NULL.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_handle_restart_init(digi_handle_t *digi_handle,
                                          BOOL8 is_warm_restart)
{    
    PMC_ERROR result = PMC_SUCCESS;
    digi_resource_handle_summary_t *digi_resource_handle_ptr = NULL;
    BOOL8 operational_path_exists = FALSE;

    PMC_ENTRY();

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->dcpb_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->mcpb_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->sifd_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->cbrc_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->enet_sys_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->enet_line_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->mapotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->lineotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->sysotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    if (NULL == digi_handle->base.common_info ||
        0 == PMC_STRLEN(digi_handle->base.tsb_name))
    {
        PMC_LOG(PMC_LOG_SEV_HIGH, 0, 0, 0,
                "DigiHandle=%p does not have basic data. Possible issue with context restore?\n", digi_handle);
        PMC_RETURN(DIGI_ERR_EMPTY_CONTEXT);
    }

    /* 
       check MUTEX state 
       
       for warm restart:
       recursive_level != 0 is an indication that a crash happened in applib
       keep_lock == TRUE means that users has at least not cleanly saved its context        
       for crash restart:
       these values need to be re-initialized           
       in all case, the user mutex is reallocated in restart_create_ctxt
       
    */
    if (TRUE == is_warm_restart)
    {
        digi_handle->base.mutex_ctxt.recursive_level &= ~(1 << 31);

        if (TRUE == digi_handle->base.mutex_ctxt.keep_lock ||
            0 != digi_handle->base.mutex_ctxt.recursive_level)
        {
            PMC_LOG_TRACE("WARM RESTART and KeepLock=%d or RecursiveLevel=%d not set correctly\n", digi_handle->base.mutex_ctxt.keep_lock,
                          digi_handle->base.mutex_ctxt.recursive_level); 
            result = PMC_SHARED_ERR_CTXT_INCOHERENT;
        }       
    }
    else
    {
        digi_handle->base.mutex_ctxt.keep_lock = FALSE;
        digi_handle->base.mutex_ctxt.recursive_level = 0;
        digi_handle->base.mutex_ctxt.recursive_level |= (1 << 31);
    }
    if (result != PMC_SUCCESS )
    {
        PMC_RETURN(result);            
    }
    pmc_log_block_strings_register(DIGI_LOG_ERR_STRINGS[0], DIGI_LOG_ERR_TABLE_BASE, DIGI_LOG_ERR_COUNT);
    /*
     * Set the active_handle here so that it can be used for logging 
     * during a crash/warm restart. It must be reset after any call that
     * uses atomic entry/return as the active_handle gets reset
     */
    digi120_pmc_log_data.active_handle = digi_handle;

#if defined(PMC_SW_SIMULATION) | defined(PMC_VERIFICATION)
    PMC_RETURN(result);
#endif

    /* Reinitialize the databases */
    gen_db_reinit(&digi_handle->base);

    digi_software_status_init(digi_handle);
    digi120_pmc_log_data.active_handle = digi_handle;

    /* update firmware status */
    if (PMC_SUCCESS == result)
    {
        digi_fw_status_t fw_status;
        result = digi_firmware_status_get(digi_handle, &fw_status);
    }
    digi120_pmc_log_data.active_handle = digi_handle;
    /*
     * Initialize the underlying modules so there is no mischief later with
     * some nodes having non-context memory allocated and some not. The
     * calls allocate all underlying memory used by the various subsystems
     */
    cpb_alloc_init(digi_handle->dcpb_handle);
    cpb_alloc_init(digi_handle->mcpb_handle);
    sifd_alloc_init(digi_handle->sifd_handle);
    cbrc_alloc_init(digi_handle->cbrc_handle);

    /*
     * TRUE/FALSE flags indicate lineotn vs sysotn handles. Not sure if 
     * required in this case.
     */
    lineotn_alloc_init(digi_handle->lineotn_handle);
    lineotn_alloc_init(digi_handle->sysotn_handle);
    enet_alloc_init(digi_handle->enet_sys_handle);
    enet_alloc_init(digi_handle->enet_line_handle);
    mapotn_alloc_init(digi_handle->mapotn_handle);
    coreotn_alloc_init(digi_handle->coreotn_handle);
    digi_otn_ddeg_init(digi_handle);

    /* FIRST SUBSYSTEM reconcilation phase */
    result = digi_subsystem_restart_init(digi_handle,is_warm_restart,UTIL_GLOBAL_RESTART_INIT_PHASE_FIRST, digi_resource_handle_ptr);

    if (PMC_SUCCESS == result)
    {
        digi_enet_update_dsi_base_lane(digi_handle);
    }

    /*
     * If this is a warm restart and/or the result is not success then this
     * operation is done. WarmRestart does not reconcile any resources and
     * is simply an audit process or if there were errors related to crash
     * restart then there is nothing else to be done.
     */
    if (TRUE == is_warm_restart || result != PMC_SUCCESS)
    {
        
        if (PMC_SUCCESS == result)
        {
            digi_restart_tx_ilkn_bcw_dpi_map_init(digi_handle);
        }

        if (TRUE == is_warm_restart && result == PMC_SUCCESS)
        {
            digi_handle->digi_sw_status.last_reset_reason = WARM_RESTART;
            /* 
               unconditionnaly clear PMON/interrupt configuration 
            */            
            digi_resource_clean_int_pmon(digi_handle);
        }

        PMC_LOG_TRACE("WarmRestart=%d and Result=%d\n", 
                      is_warm_restart, result);

        if (NULL != digi_resource_handle_ptr)
        {
            PMC_FREE(&digi_resource_handle_ptr);
        }

        /* update FW enet client source internal value */
        if (result == PMC_SUCCESS)
        {
            BOOL8 is_enet_line;        
            (void)digi_fw_enet_client_source_get(digi_handle,
                                                 &is_enet_line);
#ifndef DONT_USE_FW_Q
            if (TRUE == digi_handle_init_uses_fw_q_flag)
            {
                result = digi_fw_performance_queue_init(digi_handle, TRUE);
            }
#endif
        }
        digi120_pmc_log_data.active_handle = NULL;
        PMC_RETURN(result);
    }
    /*
     * Initial coherency pass is complete and was successful. This is also
     * a crash restart scenario. From here need to ensure that:
     * 1. The digi layer is aligned with the sub systems.
     * 2. The data base is updated to align with the digi layer
     * 3. Either the subsystem is update as a second pass or the DIGI
     *    layer using existing APIs releases resources that do not complete
     *    a full data path.
     * Iterate serdes ports and determine what is connected.
     * For each port_ctxt_ptr that is valid determine if the path is 
     * full operational. This is done by checking the resources table 
     * connections, the underlying connections and the database where
     * applicable.   If there is any mismatch then the path is set to 
     * not operational and all the resources released.
     * Once this is complete the database is checked to determine if there
     * are entries that do not match any resources allocated.
     */
    if (NULL == digi_resource_handle_ptr)
    {
        digi_resource_handle_ptr = (digi_resource_handle_summary_t *)PMC_MALLOC(sizeof(digi_resource_handle_summary_t));
    }
    PMC_ASSERT(NULL != digi_resource_handle_ptr, DIGI_ERR_NULL_HANDLE, 0,
               0);
    result = digi_resource_state_get(digi_handle, digi_resource_handle_ptr);

    digi120_pmc_log_data.active_handle = digi_handle;
    operational_path_exists = FALSE;
    /*
     * When checking the data paths want to go from the widests to the 
     * narrowest. Namely from OTN muxing to indvidual endpoints. For
     * SYSOTN only the system side can use muxing so start with SYS SERDES.
     * Otherwise start with the line side.
     */
    if (DIGI_PROD_APP_SYSOTN_CARD == digi_handle->var.prod_app)
    {
        operational_path_exists =  digi_resource_is_path_operational(digi_handle,
                                                                     digi_resource_handle_ptr,
                                                                     DIGI_SERDES_SYSTEM_INTF);
    }
    else
    {
        operational_path_exists =  digi_resource_is_path_operational(digi_handle,
                                                                     digi_resource_handle_ptr,
                                                                     DIGI_SERDES_LINE_INTF);
    }

    /*
     * A second pass related to digi_handle_restart_init is needed to reset
     * the device if there is at least one operational path and at least
     * one path is not operational and will need cleaning.  Note that no
     * valid operational paths is a failure case and no data path clean
     * up is required.
     */
    digi120_pmc_log_data.active_handle = digi_handle;

    if (PMC_SUCCESS == result)
    {
        result = digi_subsystem_restart_init(digi_handle,
                                             is_warm_restart,
                                             UTIL_GLOBAL_RESTART_INIT_PHASE_SECOND,
                                             digi_resource_handle_ptr);
    }

    if (PMC_SUCCESS == result)
    {
        /*
         * Now iterate over the data base cleaning anything that is not
         * consistent with software.
         */
        digi_resource_clean(digi_handle);
    }

    if (PMC_SUCCESS == result)
    {
        digi_restart_tx_ilkn_bcw_dpi_map_init(digi_handle);
    }

    if (PMC_SUCCESS == result)
    {
        digi_handle->digi_sw_status.last_reset_reason = CRASH_RESTART;
        /* 
           unconditionnaly clear PMON/interrupt configuration 
        */            
        digi_resource_clean_int_pmon(digi_handle);
    }

    PMC_FREE(&digi_resource_handle_ptr);

    /* update FW enet client source internal value */
    if (result == PMC_SUCCESS)
    {
        BOOL8 is_enet_line;        
        (void)digi_fw_enet_client_source_get(digi_handle,
                                             &is_enet_line);
    }

#ifndef DONT_USE_FW_Q
    if (PMC_SUCCESS == result && TRUE == digi_handle_init_uses_fw_q_flag)
    {
        result = digi_fw_performance_queue_init(digi_handle, TRUE);
    }
#endif
    /*
     * This function fails if there are no operational paths.
     */
    if (FALSE == operational_path_exists && PMC_SUCCESS == result)
    {
        result = DIGI_ERR_NO_OPERATIONAL_DATAPATH;
    }
    digi120_pmc_log_data.active_handle = NULL;
    digi_handle->base.mutex_ctxt.recursive_level = 0;
    PMC_RETURN(result);
} /* digi_handle_restart_init */



/*******************************************************************************
* digi_software_status_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the status of the software.
*
* INPUTS:
*   *digi_handle   - pointer to DIGI handle instance
*
* OUTPUTS:
*   *status_ptr    - pointer to a status structure containing version and
*                    and status information for the software
*
* RETURNS:
*   PMC_SUCCESS or error codes from sub-functions
*
* NOTES:
*   Most of the values in the digi_sw_status_t are setup at startup by the
*   fucntion digi_software_status_init()
*******************************************************************************/
PUBLIC PMC_ERROR digi_software_status_get(digi_handle_t *digi_handle,
                                          digi_sw_status_t *status_ptr)
{
    PMC_ERROR rc = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check for legal parameters */
    PMC_ASSERT(NULL != digi_handle,DIGI_ERR_NULL_HANDLE,0,0);
    PMC_ASSERT(NULL != status_ptr, DIGI_ERR_INVALID_ARG,0,0);

    /* call method to that performs the read/write test*/
    rc = digi_read_write_status(digi_handle);
    if (PMC_SUCCESS == rc)
    {
        digi_handle->digi_sw_status.read_write_status |= (1 << 0);
    }

#ifdef PMC_SW_SIMULATION
    /* digi_read_write_status() always returns an ERROR in SW_SIMULATION */
    rc = PMC_SUCCESS;
#endif

    /* pass back pointer to digi sw status */
    *status_ptr = digi_handle->digi_sw_status;

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_software_status_get */

/*******************************************************************************
* digi_firmware_status_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the status of the firmware.
*
* INPUTS:
*   *digi_handle   - pointer to DIGI handle instance
*
* OUTPUTS:
*   *status_ptr    - pointer to a status structure containing version and
*                    and status information for the firmware.
*
* RETURNS:
*   PMC_SUCCESS or error codes from sub-functions
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_firmware_status_get(digi_handle_t *digi_handle,
                                          digi_fw_status_t *status_ptr)
{
    PMC_ERROR rc     = PMC_SUCCESS;
    hostmsg_info_req_ver_t info_req   = HOSTMSG_INFO_REQ_VER_GET_REV_AND_BUILD_NUM;
    UINT32 fw_ver    = 0;
    UINT32 fw_build  = 0;
    UINT32 bootloader_ver = 0;
    UINT32 bootloader_build = 0;
    UINT32 app_user1 = 0;
    const UINT32 APP_USER1_MSK = 0x00000001;
    const UINT32 FW_NOT_SUPPORTED_OFF = 0x9;
    const UINT32 GEN_EXCP_OFF  = 0x8;
    const UINT32 SW_RST_OFF    = 0x7;
    const UINT32 WDOG_RST_OFF  = 0x5;
    const UINT32 FW_READY_OFF  = 0x0;

    hostmsg_handle_t *cpup34k_handle = NULL;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* use a hostmsg handle to access cpup34k block  */        
    cpup34k_handle = (hostmsg_handle_t *)(digi_handle->base.common_info->hostmsg_handle);
    PMC_ASSERT((NULL != cpup34k_handle), HOSTMSG_ERR_INVALID_PARAMETERS, 0, 0);

    rc = digi_fw_poll_for_alive(digi_handle);
    if (PMC_SUCCESS == rc)
    {
        digi_handle->digi_fw_status.fw_is_alive = TRUE;
    }
        
    /* read APP_USER1 and copy fields into fw status struct */
    app_user1 = cpup34k_field_APP_USER1_get(NULL,(pmc_handle_t *)cpup34k_handle);

    digi_handle->digi_fw_status.fw_version_not_supported
        = (BOOL) (app_user1 >> FW_NOT_SUPPORTED_OFF & APP_USER1_MSK);
    digi_handle->digi_fw_status.gen_excp_detected
        = (BOOL) (app_user1 >> GEN_EXCP_OFF & APP_USER1_MSK);
    digi_handle->digi_fw_status.sw_rst_detected
        = (BOOL) (app_user1 >> SW_RST_OFF & APP_USER1_MSK);
    digi_handle->digi_fw_status.wdog_rst_detected
        = (BOOL) (app_user1 >> WDOG_RST_OFF & APP_USER1_MSK);
    digi_handle->digi_fw_status.fw_is_ready
        = (BOOL) (app_user1 >> FW_READY_OFF & APP_USER1_MSK);

    /* get application FW revision and build values
     * if the 'fw_is_alive' is True, then the FW can
     * receive host messages and the version get method call will work*/
    if (PMC_SUCCESS == rc && digi_handle->digi_fw_status.fw_is_alive == TRUE)
    {
        rc = digi_fw_version_get(digi_handle,info_req,&fw_ver,&fw_build,&bootloader_ver,&bootloader_build);
    }
    /* update status with new FW verions. if digi_fw_version_get not successful
     * than don't change revision/build, they are initalized to 0.*/
    if (PMC_SUCCESS == rc)
    {
        digi_handle->digi_fw_status.fw_version = fw_ver;
        digi_handle->digi_fw_status.fw_build   = fw_build;
        digi_handle->digi_fw_status.bootloader_version = bootloader_ver;
        digi_handle->digi_fw_status.bootloader_build = bootloader_build;
    }

    if (PMC_SUCCESS == rc)
    {
        if (fw_build < SW_FW_RECENT_DEPENDANCY_SVN_REVISION || fw_build == 0x01234567)
        {
            /* Set the FW version not supported flag to TRUE */
            digi_handle->digi_fw_status.fw_version_not_supported = TRUE;

            PMC_LOG(PMC_LOG_SEV_HIGHEST, DIGI_SW_FW_DEPENDANCY, 
                    fw_build, SW_FW_RECENT_DEPENDANCY_SVN_REVISION);
        }
    }
    /* pass back pointer to digi fw status */
    *status_ptr = digi_handle->digi_fw_status;

    PMC_ATOMIC_RETURN(digi_handle, rc);
} /* digi_firmware_status_get */


/*******************************************************************************
* digi_set_revision_code
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   Function sets the internal revision code to a value set by the caller.
*   Function must be called after digi_ctxt_create otherwise the revision
*   value will be updated when the actual value is retrieved from HW.
*   To coordinate the revision code setting with the retrieval of the
*   associated FW revision file this function should be called before 
*   digi_handle_init.
*   
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   revision_code       - Value to be set to the base revision field. Must
*                         be either REV A or REV B.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS         - revision_code is an acceptable value
*   PMC_ERR_INVALID_ARG - Otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_set_revision_code(digi_handle_t *digi_handle,
                                        UINT32 revision_code)
{
    PMC_ERROR result = DIGI_ERR_INVALID_ARG;

    PMC_ATOMIC_ENTRY(digi_handle);

    if (DIGI_REVISION_CODE_REV_A == revision_code ||
        DIGI_REVISION_CODE_REV_B == revision_code)
    {
        digi_handle->digi_sw_status.device_revision_code = (UINT8) revision_code;
        digi_handle->base.common_info->device_revision_code = digi_handle->digi_sw_status.device_revision_code;
        result = PMC_SUCCESS;
    }

    PMC_ATOMIC_RETURN(digi_handle, result);
}  /* digi_set_revision_code */

/*******************************************************************************
*  digi_atomic_keep_lock
*  ___________________________________________________________________________
*
*  DESCRIPTION:   
*   This function can be used for operations that requires an atomic region \n
*   spanning User Application and AppLib. 
*   This function has only an impact when atomic operators are implemented:
*     - pmc_atomic_create \n
*     - pmc_atomic_delete \n
*     - pmc_atomic_start \n
*     - pmc_atomic_end \n
*   This function shall be called before a thread-safe function (says \n
*   digi_any_api). Then, digi_any_api will not release the mutex and user code\n
*   can perform its  operations. User code shall explicitly call pmc_atomic_end to release \n
*   the applib mutex. A call to another thread-safe function \n
*   without releasing the mutex will create a fatal error. 
*
*  INPUTS:
*   *digi_handle   - pointer to DIGI handle instance
*
*  OUTPUTS:
*    None.
*
*  RETURNS:        
*   PMC_SHARED_ATOMIC_KEEP_LOCK_MODE_ALREADY_SET when this function has been
*   already called 
* 
*  NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_atomic_keep_lock(digi_handle_t *digi_handle)
{
    pmc_handle_t *pmc_handle_ptr;
    PMC_ATOMIC_ENTRY(digi_handle);

    pmc_handle_ptr = (pmc_handle_t *) digi_handle;

    if (TRUE == pmc_handle_ptr->mutex_ctxt.keep_lock) 
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_ATOMIC_KEEP_LOCK_MODE_ALREADY_SET);
    }
    pmc_handle_ptr->mutex_ctxt.keep_lock = TRUE;

    PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);
} /* digi_atomic_keep_lock */

/*******************************************************************************
*  digi_atomic_end
*  ___________________________________________________________________________
*
*  DESCRIPTION:   
*   This function can be used for operations that requires an atomic region \n
*   spanning User Application and AppLib. 
*   digi_atomic_end shall be explicitly called whenever an atomic has been \n
*   initiated using digi_atomic_keep_lock API.
*
*  INPUTS:
*   *digi_handle   - pointer to DIGI handle instance
*
*  OUTPUTS:
*    None.
*
*  RETURNS:     
*    None
* 
*  NOTES:
*
*******************************************************************************/
PUBLIC void digi_atomic_end(digi_handle_t *digi_handle)
{
    pmc_handle_t *pmc_handle_ptr;
    PMC_ENTRY();

    pmc_handle_ptr = (pmc_handle_t *) digi_handle;
    
    pmc_handle_ptr->mutex_ctxt.keep_lock = FALSE;
    pmc_handle_ptr->mutex_ctxt.recursive_level = 0;
    pmc_atomic_end(pmc_handle_ptr->mutex_ctxt.user_ctxt); 

    PMC_RETURN();
} /* digi_atomic_end */

/*******************************************************************************
* digi_device_shutdown
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Shutdown the device by resetting all the subsystems without resetting the PCIe
*   interface. Since these are register read/write operations there are no
*   error returns for this function.
*
* INPUTS:
*   *digi_handle   - pointer to DIGI handle instance
*
* OUTPUTS:
*   None
*
* RETURNS:
*   None
*
* NOTES:
*   Firmware must be shutdown before resetting the subsystems
*
*******************************************************************************/
PUBLIC void digi_device_shutdown(digi_handle_t *digi_handle)
{
#ifdef PMC_TESTS 
    PMC_ATOMIC_ENTRY_VOID(digi_handle);
#else 
    PMC_ATOMIC_ENTRY(digi_handle);
#endif

    /* check input */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    if (digi_device_init_status_get(digi_handle) == FALSE) {

        /* Nothing to be done, digi_handle_init was never called.
         * There is nothing to restart yet! */

    } else {
        PMC_ERROR result = DIGI_ERR_UNKNOWN;

#ifdef DIGI_FW_STATS
        /* check for firmware errors */
        digi_fw_show_firmware_errors(digi_handle);
#endif

#ifdef USE_FW_LOG
        if (digi_fw_firmware_logging_enabled) {
            /* for debugging,... also show firmware stats during shutdown */
            digi_fw_show_firmware_stats(digi_handle);
        }
#endif

#ifndef DONT_USE_FW_Q
        /* shutdown firmware queue */
        digi_fw_performance_queue_init(digi_handle , FALSE );
#endif

        /* This function does not return a value */
        digi_pgmrclk_div_all_disable(digi_handle);

        result = digi_fw_shutdown_and_put_mips_in_reset(digi_handle);

        if (PMC_SUCCESS != result)
        {
            /* Note that even though FW failed to shutdown, we need to proceed with the next
               call because we put MIPS in reset even when FW failed to shutdown.
               The assumption is that FW gets stuck in a bad state and must be reset */
            PMC_LOG(PMC_LOG_SEV_HIGHEST, DIGI_ERR_FW_FAILED_TO_SHUTDOWN, 0,
                    0, "Error Returned = %d\n", result); 
        }

        /* Uninitialize all DCSUs unconditionally */
        dcsu_uninit(digi_handle, DIGI_DCSU_INST_OTN1);
        dcsu_uninit(digi_handle, DIGI_DCSU_INST_OTN2);
        dcsu_uninit(digi_handle, DIGI_DCSU_INST_ENET3);
        dcsu_uninit(digi_handle, DIGI_DCSU_INST_ENET1);
        dcsu_uninit(digi_handle, DIGI_DCSU_INST_ENET2);

        if (TRUE != pmc_is_digi_rev_a_revision(&digi_handle->base))
        {   
            dcsu_uninit(digi_handle, DIGI_DCSU_INST_SYS2);
        }

        /* Configure the TOC to be disabled.
           This does not return a return code */
        digi_toc_cfg(digi_handle, FALSE);
        

        /* Final step is to toggle the PGMRCLK_RESET register bit.  This ensures all the registers within DIGI_M1 (including PGRMCLK) subsystem
           are going to be reset and put back to good known state. 
           We cannot leave PGMRCLK_RESET as '1' here, but need to toggle it (write 1 then 0) because we want to ensure 
           the PLL_STAT_OUT pin to continue to output the signal.
           This PLL_STAT_OUT signal is an indication that PCIe link is still up while we put the subsystems within the device in reset.*/
        pgmrclk_energy_state_reg_toggle(digi_handle);

        digi_device_reset(digi_handle);

        digi_handle->var.digi_state = DIGI_STATE_HANDLE_INIT;
    }
        
    PMC_ATOMIC_RETURN(digi_handle);
} /* digi_device_shutdown */

/*******************************************************************************
* digi_mapotn_etrans_scheduling_mode_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function must be called prior to digi_device_init() and cannot be 
*   modified once set.\n\n
*
*   This function provides the ability to change the default scheduling mode
*   used by the SW driver.  By default schd_mode == FALSE is used.\n\n
*
*   In all cases, the provisioning of resources with
*   digi_otn_mapper_prov requires primary and secondary group to be used to
*   identify which ENET_LINE resources will be used for applications that
*   require the ETRANS path.\n\n
*
*   The API digi_mapper_group_usage_get() provides a view of which serdes
*   ports are forfeited from provisioning against ENET_LINE or CBRC subsystems 
*   for the specified primary and secondary group.  When schd_mode is FALSE
*   only ENET_LINE is forfeited from usage against the serdes port, when 
*   schd_mode is true both ENET_LINE and CBRC is forteited from usage against
*   the serdes port.
*
*   
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   schd_mode           - MAPOTN Scheduling Mode
*                         FALSE: MAPOTN and ENET_LINE ETRANS applications use
*                                common DCPB queue system and pop port
*                         TRUE:  MAPOTN and ENET_LINE ETRANS applications do 
*                                not use common DCPB queue system and pop port
*                            
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_mapotn_etrans_scheduling_mode_set(digi_handle_t *digi_handle,
                                                   BOOL8 schd_mode)
{
#ifdef PMC_TESTS 
    PMC_ATOMIC_ENTRY_VOID(digi_handle);
#else 
    PMC_ATOMIC_ENTRY(digi_handle);
#endif
    
    digi_handle->var.etrans_dcpb_use_model = schd_mode;                                                             
    
    PMC_ATOMIC_RETURN(digi_handle);
} /* digi_mapotn_etrans_scheduling_mode_set */


/*******************************************************************************
* digi_device_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs device wide bring up of the DIGI device.  It takes in
*   arguments to define the state of resources that exist for the life of the
*   card.
*
*   If SERDES are required to be part of a backplane configuration, they are to 
*   be set up here as a part of the SIFD configuration.
*
*   For each SIFD configuration the corresponding enable mask will required to
*   be enabled where the BP is to be used for each of:
*
*   blk_to_E1_enable_mask, blk_to_N1_enable_mask, and blk_to_N2_enable_mask in
*   the lane portion of the digi_sifd_ilkn_1_cfg_t and the 
*   digi_sifd_ilkn_2_cfg_t variable respectively.
*
*   The E1 mask corresponds to the T8 SERDES, the N1 corresponds to the S16
*   system side SERDES, and the N2 corresponds to the C8 SERDES.
*
*   In addition, the digi_sifd_ilkn_cfg_t ilkn portion of the 
*   digi_sifd_ilkn_1_cfg_t and digi_sifd_ilkn_2_cfg_t require to be configured.
*   Please see the definiation of digi_sifd_ilkn_1_cfg_t and 
*   digi_sifd_ilkn_2_cfg_t for more information.
*
*   For product application prod_app == DIGI_PROD_APP_TRANSMUXPONDER_CARD,
*   or DIGI_PROD_APP_100G_3_X_40G_CFP_CARD, at least one line side SERDES 
*   must be defined.
*
*   For product application prod_app == DIGI_PROD_APP_SYSOTN_CARD, 
*   the mux_stages are limited to One or No stages.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *sifd_1_cfg_ptr          - pointer to configuration structure detailing
*                            ILKN1 configuration.  If ILKN1 unused, set to NULL
*   *sifd_2_cfg_ptr          - pointer to configuration structure detailing
*                            ILKN2 configuration.  If ILKN2 unused, set to NULL
*   prod_app               - Enum, defining the major product application that
*                            device is being configured to support
*   mux_stages             - Defines the maximum number of stages of OTN mapping
*                            the CORE_OTN subsystem will support.\n
*                            2: Two stages of multiplexing\n
*                            1: One stage of multiplexing\n
*                            0: No stages of multiplexing
*
*
* OUTPUTS:
*   **ilkn_1_ctxt_pptr     - A pointer to a pointer to a data structure defining
*                            how the first ilkn blk was configured based on the
*                            input parameters.
*   **ilkn_2_ctxt_pptr     - A pointer to a pointer to a data structure defining
*                            how the second ilkn blk was configured based on
*                            the input parameters.
*
* RETURNS:
*   PMC_SUCCESS, DIGI_ERR_HANDLE_NOT_INIT, or error codes from sub-functions
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_device_init(digi_handle_t *digi_handle,
                                  digi_sifd_ilkn_1_cfg_t *sifd_1_cfg_ptr,
                                  digi_sifd_ilkn_2_cfg_t *sifd_2_cfg_ptr,
                                  digi_prod_app_t prod_app,
                                  digi_otn_mux_stages_t mux_stages,
                                  digi_ilkn_link_t **ilkn_1_ctxt_pptr,
                                  digi_ilkn_link_t **ilkn_2_ctxt_pptr)
{
    PMC_ERROR rc = PMC_SUCCESS;
    coreotn_init_operation_t coreotn_init_state = COREOTN_SS_OPERATIONAL_MODE;
    UINT8 digi_max_bw;
    cpb_handle_t *ocpb_handle;
    digi_fw_opsa_mpmo_fifo_trigger_enables_t opsa_mpmo_fifo_trigger_enables;


    /*PMC_RETURN(rc);*/

    PMC_ATOMIC_ENTRY(digi_handle);


    /* Check that digi handle is initialized */
    if (FALSE == digi_handle_init_status_get(digi_handle))
    {
        rc = DIGI_ERR_HANDLE_NOT_INIT;
    }

    if (rc == PMC_SUCCESS)
    {
        rc = digi_device_init_params_validate(digi_handle, sifd_1_cfg_ptr,
                                              sifd_2_cfg_ptr, prod_app,
                                              mux_stages, ilkn_1_ctxt_pptr,
                                              ilkn_2_ctxt_pptr);
    }

    if (IS_DIGI60(digi_handle) && (prod_app != DIGI60_PROD_APP_LINE_CARD) && (prod_app != DIGI60_PROD_APP_TRANSMUXPONDER_CARD) && (prod_app != DIGI60_PROD_APP_TRANSMUXPONDER_SYS_CLIENT_CARD))
    {
        rc = DIGI_ERR_INVALID_ARG;
    }

    if (rc == PMC_SUCCESS)
    {
        digi_handle->var.prod_app = prod_app;
        /*
         * Reset the top level mask to 0 if this is not a SYSOTN 
         * application. It may or may not be the case that digi_int_init 
         * has already been called.
         */
        if (DIGI_PROD_APP_SYSOTN_CARD != digi_handle->var.prod_app)
        {
            lineotn_interrupt_type_save(digi_handle->sysotn_handle,
                                        SYSOTN_INTR_TYPE_SYSOTN_DISABLED);
        }

        switch(prod_app)
        {
        case DIGI_PROD_APP_LINE_CARD:
        case DIGI_PROD_APP_PORTLESS_CARD:
        case DIGI_PROD_APP_100G_3_X_40G_CFP_CARD:
            digi_handle->var.cbrc_intf = CBRC_SERDES_INTF_LINE;
            break;
        case DIGI_PROD_APP_SYSOTN_CARD:
            digi_handle->var.cbrc_intf = CBRC_SERDES_INTF_LINE;
            break;
        case DIGI_PROD_APP_TRANSMUXPONDER_CARD:
            digi_handle->var.cbrc_intf = CBRC_SERDES_INTF_SYS;
            break;
        case DIGI60_PROD_APP_LINE_CARD:
            digi_handle->var.cbrc_intf = CBRC_SERDES_INTF_LINE;
            /* set DIGI60_LINE */
            {
                UINT32 value;
                UINT32 vaddr = 0x248;
                value = digi_reg_read_internal(digi_handle, vaddr);
                pmc_sys_reg_write(digi_handle->base.sys_handle, vaddr, (value | 0x1));
            }
            {
                digi_cfg_tbl_t temp_digi60_cfg_tbl[] = DIGI60_LINE_CARD_CFG_TABLE;
                PMC_MEMCPY(&digi_handle->cfg.digi_cfg_tbl[0], &temp_digi60_cfg_tbl[0],sizeof(digi_handle->cfg.digi_cfg_tbl));
            }
            break;
        case DIGI60_PROD_APP_TRANSMUXPONDER_CARD:
        case DIGI60_PROD_APP_TRANSMUXPONDER_SYS_CLIENT_CARD:
            digi_handle->var.cbrc_intf = CBRC_SERDES_INTF_LINE;
            /* clear DIGI60_LINE and DIGI60_SFI51 */
            {
                UINT32 value;
                UINT32 vaddr = 0x248;
                value = digi_reg_read_internal(digi_handle, vaddr);
                pmc_sys_reg_write(digi_handle->base.sys_handle, vaddr, (value & ~0x3));
            }
            {
                digi_cfg_tbl_t temp_digi60_cfg_tbl[] = DIGI60_TRANSMUXPONDER_CARD_CFG_TABLE;
                PMC_MEMCPY(&digi_handle->cfg.digi_cfg_tbl[0], &temp_digi60_cfg_tbl[0],sizeof(digi_handle->cfg.digi_cfg_tbl));
            }
            break;
        default:
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
            break;
        }   
               
        digi_handle->var.mux_stages = mux_stages;
        /* coreotn initialization power saving */
        if (digi_handle->var.mux_stages == DIGI_OTN_MUX_STAGES_ONE)
        {
            if (DIGI_PROD_APP_SYSOTN_CARD == prod_app)
            {
                coreotn_init_state = COREOTN_SS_SYSOTN_MODE;
            } else 
            {
                coreotn_init_state = COREOTN_SS_ONE_STAGE_MUXING_MODE;
            }
        }
        else if (digi_handle->var.mux_stages == DIGI_OTN_MUX_STAGES_NONE)
        {
            if (DIGI_PROD_APP_SYSOTN_CARD == prod_app)
            {
                coreotn_init_state = COREOTN_SS_SYSOTN_BYPASS_MODE;
            } else 
            {
                /* coreotn is in full bypass mode */
                coreotn_init_state = COREOTN_SS_BYPASS_MODE;
            }
        }
        else 
        {
            /* passthru or two stage muxing */
            coreotn_init_state = COREOTN_SS_OPERATIONAL_MODE;
        }           
    }

    /*
     * Configure COREOTN operational mode
     */
    coreotn_operation_init_set(digi_handle->coreotn_handle, coreotn_init_state);

    /* in the SYSOTN product application, SYSOTN will populate COREOTN's HO
       database and LINEOTN will populate a different database.  It's
       required to set this context*/
    if(digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
    {
        lineotn_set_ho_db_populate_ctxt(digi_handle->lineotn_handle,
                                        FALSE);

        if (TRUE == pmc_is_digi_rev_a_revision(&digi_handle->base))
        {
            if(rc == PMC_SUCCESS)
            {
                rc = coreotn_adjust_dci_clock(digi_handle->coreotn_handle,
                                              680,
                                              681);
            }
            
            if(rc == PMC_SUCCESS)
            {
                rc = mapotn_adjust_dci_clock(digi_handle->mapotn_handle,
                                             680,
                                             681);
            }
            
            if(rc == PMC_SUCCESS)
            {
                rc = lineotn_adjust_dci_clock(digi_handle->lineotn_handle,
                                              680,
                                              681);
            }
            
            if(rc == PMC_SUCCESS)
            {
                rc = lineotn_adjust_dci_clock(digi_handle->sysotn_handle,
                                              680,
                                              681);
            }
            
        }
    }
    else
    {
        lineotn_set_ho_db_populate_ctxt(digi_handle->lineotn_handle,
                                        TRUE);
    }


    /* Retrieve the maximum bandwidth which is based on the product application. 
     * Check to make sure the bandwidth isn't oversubscribed on both the line and
     * system side. */
    if (rc == PMC_SUCCESS)
    {    
        digi_max_bw = digi_get_max_bandwidth(DIGI_PROD_APP_GET(digi_handle),
                                             digi_handle->var.line_port_bw.is_port_cfp);
        
        if (digi_handle->var.line_port_bw.total_port_bw_cfgd > digi_max_bw)
            rc = DIGI_ERR_MAX_BWTH_PROV;
    }

    if (rc == PMC_SUCCESS)
    { 
        digi_max_bw = digi_get_max_bandwidth(DIGI_PROD_APP_GET(digi_handle),
                                             digi_handle->var.sys_port_bw.is_port_cfp);

        if (digi_handle->var.sys_port_bw.total_port_bw_cfgd > digi_max_bw)
            rc = DIGI_ERR_MAX_BWTH_PROV;
    }


    if (TRUE != pmc_is_digi_rev_a_revision(&digi_handle->base))
    {   
        dcsu_init(digi_handle, DIGI_DCSU_INST_SYS2);
    }

    digi_handle->var.mux_stages = mux_stages;   

    if (rc == PMC_SUCCESS) {

        rc = digi_dsi_lane_allocation(digi_handle, FALSE);
    }

    if (PMC_SUCCESS == rc)
    {
        dcsu_init(digi_handle, DIGI_DCSU_INST_OTN1);
        dcsu_init(digi_handle, DIGI_DCSU_INST_ENET1);
        dcsu_init(digi_handle, DIGI_DCSU_INST_ENET2);
        dcsu_init(digi_handle, DIGI_DCSU_INST_ENET3);
        dcsu_init(digi_handle, DIGI_DCSU_INST_PTP);
        digi_dcsu_conditional_uninit(digi_handle, DIGI_DCSU_INST_ENET1);
        digi_dcsu_conditional_uninit(digi_handle, DIGI_DCSU_INST_ENET2);
        digi_dcsu_conditional_uninit(digi_handle, DIGI_DCSU_INST_PTP);
    }  

    if (rc == PMC_SUCCESS) 
    {
        dcsu_init(digi_handle, DIGI_DCSU_INST_OTN2);
        fec_gfec_lowpwr_set(digi_handle->lineotn_handle, FALSE);
        fec_all_swizzle_fec_lowpwr_set(digi_handle->lineotn_handle, FALSE); 
        fec_gfec_lowpwr_set(digi_handle->sysotn_handle, FALSE);
        PMC_Q_USLEEP(digi_handle->sysotn_handle,1);
        fec_gfec_lowpwr_set(digi_handle->lineotn_handle, TRUE);    
        fec_all_swizzle_fec_lowpwr_set(digi_handle->lineotn_handle, TRUE);      
        fec_gfec_lowpwr_set(digi_handle->sysotn_handle, TRUE);
        digi_dcsu_conditional_uninit(digi_handle, DIGI_DCSU_INST_OTN2);
    }

    if (TRUE == pmc_is_digi_rev_a_revision(&digi_handle->base))
    {
        if(prod_app == DIGI_PROD_APP_SYSOTN_CARD)
        {
            digi_dcsu_adjust_otu1_for_sysotn(digi_handle);
        }
    }

    if (TRUE == pmc_is_digi_rev_a_revision(&digi_handle->base))
    {
        digi_dcsu_conditional_uninit(digi_handle, DIGI_DCSU_INST_ENET3);
    }


    /* Take LIFD subsystems out of reset if required */
    if ((PMC_SUCCESS == rc) && 
        (TRUE == digi_lifd_system_required_test(digi_handle)))
    {
        digi_lifd_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RUNNING);
    }    

    if (PMC_SUCCESS == rc)
    {
        rc = digi_bp_intf_serdes_cfg(digi_handle, sifd_1_cfg_ptr, sifd_2_cfg_ptr,DIGI_BP_INTF_SERDES_CFG,FALSE);
    }           

    if (rc == PMC_SUCCESS) {

        /* Set up the sifd. This is set for the life of the device. */
        rc = digi_sifd_config(digi_handle,
                              sifd_1_cfg_ptr,
                              sifd_2_cfg_ptr,
                              ilkn_1_ctxt_pptr,
                              ilkn_2_ctxt_pptr);
    }


    /* enable the synchronization of the FPI Reshaping Block to an incoming FPI reference pulse. */
    if (PMC_SUCCESS == rc)
    {
        digi_pgmrclk_field_SYNC_DISABLE_8_set(NULL,digi_handle,FALSE);
    }

    /* initialize all GE serdes ports: OTN OH, RCP, ENET MGMT */    
    if(PMC_SUCCESS == rc)
    {
        /* Configure the TOC to be disabled.
           This does not return a return code */
        digi_toc_cfg(digi_handle, TRUE);

        rc = digi_serdes_ge_all_ports_init(digi_handle);
    }
    
    /* FEC must be initialized by firmware. It must be done after DIGI_MI is out of reset */
    if (PMC_SUCCESS == rc)
    {
        rc = digi_fec_init(digi_handle);
    } 
    
#ifdef PMC_INTERNAL_COREOTN_POWER
    /* RUNNING/OPTIMAL request shall be done in datapath prov/deprov functions.
       Requests on COREOTN_ODUKP power zone are not yet debugged */
#else 
    digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_RUNNING,COREOTN_ODUKP);
#endif

  
  
    /* We need to indicate to the ODUkSW which SS is connected to
     * port 0 */
    ocpb_handle = coreotn_oduksw_handle_get(digi_handle->coreotn_handle);

    if(digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
    {
        cpb_oduksw_port0_set(ocpb_handle, CPB_ODUKSW_PORT0_COREOTN_CTRL); 
    }
    else 
    {
        cpb_oduksw_port0_set(ocpb_handle, CPB_ODUKSW_PORT0_ILKN);
    }


    if (PMC_SUCCESS == rc)
    {
        rc = digi_otn_ddeg_init(digi_handle);
    }

    if (PMC_SUCCESS == rc)
    {
        digi_handle->var.digi_state = DIGI_STATE_DEVICE_INIT;
    }

#ifdef DIGI_FW_STATS    
    if (FALSE == pmc_is_digi_rev_a_revision(&digi_handle->base))
    {
        /* reset firmware statistics since we don't care about missed deadlines during initialization */
        if (PMC_SUCCESS == rc)
        {
            rc = digi_fw_stats_reset(digi_handle);
            if (rc != PMC_SUCCESS) {
              rc = PMC_SUCCESS; /* ignore return code from digi_fw_stats_reset to be compatible with older firmware versions */
            }
        }
    }
#endif








    if(PMC_SUCCESS == rc && (FALSE == pmc_is_digi_rev_a_revision(&digi_handle->base)))
    {
        memset(&opsa_mpmo_fifo_trigger_enables,0xff,sizeof(digi_fw_opsa_mpmo_fifo_trigger_enables_t));

        opsa_mpmo_fifo_trigger_enables.proc1_fifo_trigger_enabled = 0;

        rc = digi_fw_opsa_cfg_mpmo_fifo_trigger_enables(digi_handle, &opsa_mpmo_fifo_trigger_enables);
    }

#ifndef DISABLE_LLDP_WORKAROUND 
    if(g_pkt_cache_init == FALSE) {
        digi_enet_client_chnl_def_t* chnl_ctxt_ptr;
        digi_enet_eclass_filter_config_t eclass_cfg;
        
        digi_enet_line_energy_state_set(digi_handle, 0, ENET_SERDES_10GE_MAC, PMC_ENERGY_STATE_REQUEST_RUNNING);
        
        chnl_ctxt_ptr = &(digi_handle->handle_pool.enet_line_chnl[0]);

        /* Configure ENET datapath*/                                     
        rc  = enet_datapath_cfg(digi_handle->enet_line_handle,
                                0, 
                                ENET_SERDES_10GE_MAC, 
                                ENET_MAPOTN_CHANNEL_NONE, 
                                FALSE, 
                                FALSE); 


        if (PMC_SUCCESS == rc)
        {
            rc = digi_enet_fw_enet_client_source_conditional_update(digi_handle, (util_global_switch_data_t  *)chnl_ctxt_ptr);
        }
        
        if (PMC_SUCCESS == rc)
        {
            chnl_ctxt_ptr->switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_ENET_LINE;
            chnl_ctxt_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED;

            /* activate ENET TX */
            rc = enet_tx_activate(digi_handle->enet_line_handle,
                                  0, 
                                  ENET_SERDES_10GE_MAC);


            if (PMC_SUCCESS == rc) {
                rc = digi_enet_cpu_extract_pkt_cfg(digi_handle,
                                                   ENET_EGRESS,
                                                   (util_global_switch_data_t *)chnl_ctxt_ptr,
                                                   TRUE,
                                                   FALSE);
            }

            /* configure eclass */
            if (PMC_SUCCESS == rc) {
                eclass_cfg.encap = DIGI_ENET_ECLASS_ENCAP_ETH;
                eclass_cfg.direction = DIGI_ENET_ECLASS_DIR_EGRESS;
                eclass_cfg.param_1 = 0x88CC;
                eclass_cfg.param_2 = DIGI_ENET_ECLASS_LLDP_CBR_NONE;
                eclass_cfg.enable = TRUE;
                eclass_cfg.vlan_tag_cfg = ENET_VLAN_NO_TAG;
                eclass_cfg.vlan_tag_inner = 0x8100;
                eclass_cfg.vlan_tag_outer = 0x8100;
                eclass_cfg.mode = DIGI_ENET_ECLASS_MODE_LLDP_ET;
                eclass_cfg.target = DIGI_ENET_ECLASS_TARGET_CPUH;
                
                rc = digi_enet_eclass_filter_config(digi_handle, (util_global_switch_data_t *)chnl_ctxt_ptr, eclass_cfg);
            }

            /* send LLDP packet */
            if (PMC_SUCCESS == rc)
            {
                digi_enet_test_packet_t test_pkt;

                test_pkt.packet_size = 88;
                test_pkt.interval = 360;
                test_pkt.dest_addr_hi = 0x0180;
                test_pkt.dest_addr_lo = 0xC200000E;
                test_pkt.src_addr_hi = 0x1122;
                test_pkt.src_addr_lo = 0x33445566;
                test_pkt.ether_type = 1;
                test_pkt.outer_vlan = 0x88cc0000;
                test_pkt.inner_vlan = 0x0;
                test_pkt.payload = 0x11;
                rc = digi_enet_send_packets_set(digi_handle, 
                                           (util_global_switch_data_t *)chnl_ctxt_ptr, 
                                           TRUE, 
                                           &test_pkt);

                digi_enet_send_packets_set(digi_handle, 
                                           (util_global_switch_data_t *)chnl_ctxt_ptr, 
                                           FALSE, 
                                           &test_pkt);
            }
            
            /* disable all configurations */
            
            digi_enet_cpu_extract_pkt_cfg(digi_handle,
                                           ENET_EGRESS,
                                           (util_global_switch_data_t *)chnl_ctxt_ptr,
                                           FALSE,
                                           FALSE);

            eclass_cfg.encap = DIGI_ENET_ECLASS_ENCAP_NONE;
            eclass_cfg.direction = DIGI_ENET_ECLASS_DIR_EGRESS;
            eclass_cfg.mode = DIGI_ENET_ECLASS_MODE_LLDP_ET;
            eclass_cfg.target = DIGI_ENET_ECLASS_TARGET_CPUH;
            digi_enet_eclass_filter_config(digi_handle, (util_global_switch_data_t *)chnl_ctxt_ptr, eclass_cfg);
            digi_enet_lpd_release(digi_handle, (util_global_switch_data_t *)chnl_ctxt_ptr, DIGI_ENET_ECLASS_DIR_EGRESS);

            enet_tx_deactivate(digi_handle->enet_line_handle, 0, ENET_SERDES_10GE_MAC);
            enet_datapath_uncfg(digi_handle->enet_line_handle, 0);

            /* reset state */
            digi_enet_line_energy_state_set(digi_handle, 0, ENET_SERDES_10GE_MAC, PMC_ENERGY_STATE_REQUEST_RESET);
            chnl_ctxt_ptr->switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
            chnl_ctxt_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;

            g_pkt_cache_init = TRUE;
        }
    }
#endif

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_device_init */


/*******************************************************************************
* digi_mpmo_csi_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This API impacts the generation of the per MPMO channel CSI_CHG_I event 
*   indication.\n
*
*   This API enables or disables masking of the lower two bits of the ingress 5 
*   bit CSI value. When mask in enabled, only the upper 3 bits will be considered 
*   in signalling an interrupt for a change in CSI value via the CSI_CHG_I 
*   interrupt. When mask is disabled, all 5 bits will be considered in signalling
*   an interrupt for a change is CSI value via the CSI_CHG_I interrupt.
*
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance.
*   opsa_inst       - the MPMO instance to configure see digi_opsa_inst_t    
*   csi_squelch_en  - enables/disables masking of the lower two bits of the 
*                     ingress 5 bit CSI value: \n
*                     TRUE:  CSI bits 5:2 are used for comparison \n
*                     FALSE: CSI bits 5:0 are used for comparison \n
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_mpmo_csi_cfg(digi_handle_t *digi_handle,
                                   digi_opsa_inst_t opsa_inst,
                                   BOOL csi_squelch_en)
{
    PMC_ERROR rc = PMC_SUCCESS;
    coreotn_mpmo_inst_t mpmo_inst;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* Check arguments */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    switch (opsa_inst)
    {
    case DIGI_OPSA_COREOTN_FO1:
        mpmo_inst = COREOTN_MPMO_TO_COREOTN;
        break;           
    case DIGI_OPSA_COREOTN_FO2:
        mpmo_inst = COREOTN_MPMO_TO_MAPOTN;
        break;
    case DIGI_OPSA_COREOTN_CTL:
        mpmo_inst = COREOTN_MPMO_CORECTL;
        break;
    default:
        rc = DIGI_ERR_INVALID_ARG;
        break;
    }
    
    if (PMC_SUCCESS == rc)
    {
        rc = coreotn_mpmo_csi_cfg(digi_handle->coreotn_handle, mpmo_inst, csi_squelch_en);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_mpmo_csi_cfg */

/*******************************************************************************
* digi_mpma_csi_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This API configures the configurable client status indication in the CSI 
*   field of each outgoing packet header.  Three DCI signal failures 
*   (SSF, SD, SF), and two manual force registers (FORCE_TO and FORCE_AWAY) are
*   associated with configurable CSI values. In the event that there are multiple 
*   signal failures/forces, only the highest priority will be signalled via the 
*   CSI field according to the following priority:\n
*   1. Force Away (User Force, default 5'b11100)\n
*   2. SSF (DCI Signal failure, default 5'b10000)\n
*   3. SF (DCI Signal failure, default 5'b01100)\n
*   4. SD (DCI Signal failure, default 5'b01000)\n
*   5. Normal (DCI Signal failure, default 5'b00100)\n
*   6. Force to (User Force, default 5'b00000)\n
*
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance.
*   opsa_inst       - the MPMA instance to configure see digi_opsa_inst_t        
*   cfg_csi_type    - the cofigurable CSI values see digi_opsa_csi_type_t
*   csi_val         - CSI value to use
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*  For compliance with the OFP implementation agreement the configurable
*  client status indication should be set to their default values.
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_mpma_csi_cfg(digi_handle_t *digi_handle,
                                   digi_opsa_inst_t opsa_inst,
                                   digi_opsa_csi_type_t cfg_csi_type,
                                   UINT32 csi_val)
{
    
    PMC_ERROR rc = PMC_SUCCESS;
    coreotn_mpma_inst_t mpma_inst;
    mpma_csi_type_t mpma_csi_type = MPMA_CSI_NORMAL;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* Check arguments */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    switch (opsa_inst)
    {
    case DIGI_OPSA_COREOTN_FO1:
        mpma_inst = COREOTN_MPMA_TO_COREOTN;
        break;           
    case DIGI_OPSA_COREOTN_FO2:
        mpma_inst = COREOTN_MPMA_FROM_MAPOTN;
        break;
    case DIGI_OPSA_COREOTN_CTL:
        mpma_inst = COREOTN_MPMA_CORECTL;
        break;
    default:
        rc = DIGI_ERR_INVALID_ARG;
        break;
    }
    
    if (PMC_SUCCESS == rc)
    {
        digi_mpma_csi_type_params_convert(cfg_csi_type, &mpma_csi_type);
    
        rc = coreotn_mpma_csi_cfg(digi_handle->coreotn_handle, mpma_inst, mpma_csi_type, csi_val);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_mpma_csi_cfg */

/*******************************************************************************
* digi_otn_server_line_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies basic bidirectional mode configuration for an OTUk
*   signal passing between Line Serdes and COREOTN High Order framer.\n\n
*
*   OTUk signal types are defined in the digi_otn_server_mode_t enum type.\n\n
*
*   The FEC and payload format are intially set by this API.  These configurations 
*   may be dynamically reprovisioned after this API has been called.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_ctxt_ptr         - pointer to serdes port data for the serdes port to
*                            be configured.
*   otuk_mode              - Enum,  OTUk modes when connected to Line
*                            Serdes.
*   fec_mode               - Enum, FEC processing mode of OTN signal.  Valid for
*                            frame_mode DIGI_OTN_SERVER_FRAME_OTUK
*   deskew_type            - Enum,required deskew type.  See enum 
*                            digi_sfis_deskew_type_t.
*
* OUTPUTS:
*   **otn_server_pptr      - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
* RETURNS:
*   PMC_SUCCESS, DIGI_ERR_DEVICE_NOT_INIT, DIGI_ERR_INVALID_ARG,
*   DIGI_ERR_SERDES_PORT_ALREADY_PROV, DIGI_ERR_NO_DSI_ALLOC_PROV,
*   or error codes from sub-functions
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_line_prov(digi_handle_t *digi_handle,
                                           digi_serdes_port_t *port_ctxt_ptr,
                                           digi_otn_server_otuk_t otuk_mode,
                                           digi_otn_server_fec_t fec_mode,
                                           digi_sfis_deskew_type_t deskew_type,
                                           digi_otn_server_chnl_t **otn_server_pptr)
{
    PMC_ERROR rc = PMC_SUCCESS;

    UINT8     i  = 0;
    UINT32                base_dsi_stream = 0;
    lineotn_dsi_type_t    dsi_type   = (lineotn_dsi_type_t)0;
    UINT8                 port_lane_num = 0;   /* this counts how many of the current port_uid we have */
    lineotn_frame_rate_t  frame_rate = LAST_LINE_OTN_FRAME_RATE;
    UINT32                dci_channel = 0;
    BOOL                  dsi_state_configured = FALSE;
    digi_post_mld_dsi_ctxt_t *p_post_mld_lanes = NULL;
    util_global_odukp_type_t oduk_type = UTIL_GLOBAL_LAST_ODUK;
    digi_serdes_port_def_t  *p_port_ctxt = NULL;
    digi_serdes_port_mode_t serdes_mode = DIGI_SERDES_PORT_MODE_ANY_LOWPWR;
    digi_serdes_prov_state_t prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;
    rc = digi_otn_fec_type_validate(digi_handle, fec_mode);
    PMC_ASSERT(PMC_SUCCESS == rc, rc, 0, 0);

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != port_ctxt_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(deskew_type < LAST_DIGI_OTN_SERVER_DESKEW_TYPE, DIGI_ERR_INVALID_ARG, deskew_type, 0);
    PMC_ASSERT(NULL != otn_server_pptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    /* check serdes port context context */
    DIGI_SERDES_PORT_CTXT_HANDLE_CHECK(digi_handle, port_ctxt_ptr, rc);

    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_DEVICE_NOT_INIT);
    }
        
    /* dereference void pointer */
    p_port_ctxt=(digi_serdes_port_def_t*)port_ctxt_ptr;

    if ((DIGI_SERDES_SYSTEM_INTF == p_port_ctxt->intf)&&(digi_handle->var.prod_app != DIGI_PROD_APP_100G_3_X_40G_CFP_CARD))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }

    /* this function should be invoked AFTER !!! dsi lane algorithm              */
    /* zero step - check the post mld lanes to verify that this port can be provisioned to lineotn SS */
    p_post_mld_lanes=digi_first_post_mld_dsi_find(digi_handle,p_port_ctxt->port_uid);
    
    if( p_post_mld_lanes != NULL )
    {
        if( DIGI_SERDES_PROV_STATE_UNASSIGNED == p_post_mld_lanes->prov_state )  /* port found - check that it is configured and not assigned */
        {
            rc = digi_post_mld_prov_state_set(digi_handle,p_port_ctxt->port_uid,DIGI_SERDES_PROV_STATE_LINEOTN); /* if this is unassigned port - unassign it to lineotn  */
            prov_state = DIGI_SERDES_PROV_STATE_LINEOTN;
            if(PMC_SUCCESS == rc)
                dsi_state_configured = TRUE;
            else
                rc = DIGI_ERR_INVALID_ARG; 
        }
        else
            rc = DIGI_ERR_SERDES_PORT_ALREADY_PROV;
    }
    else
        rc = DIGI_ERR_NO_DSI_ALLOC_PROV;
    
    if (FALSE == dsi_state_configured) 
    {
        /* we did not find the specified port number */        
        PMC_ATOMIC_RETURN(digi_handle, rc);  /* if we got to this line - this a bug, exit and report */
    }

    /* first step - find the dsi lane and type based on dsi algorithm structures */
    /* before going any further - check that a lineotn configuration was set by the dsi alloc algo */
    if( digi_handle->var.lineotn_cfg_num < DSI_ALLOC_MAX_CFG_NUM )
    {
        /* Activate OTU2 DCSU for the first provisioned channel*/
        if(PMC_SUCCESS == rc)
        {
            digi_dcsu_conditional_init(digi_handle, DIGI_DCSU_INST_OTN2);
        }
        
        /* is it an sfi-5.1 port ? */
        if( digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[0].port_uid == p_port_ctxt->port_uid )
        {
            if( DIGI_POST_MUX_BUS_0==digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[0].post_mux_2G5_bus_allocation)
            {
                dsi_type = LINE_OTN_DSI_TYPE_SFI_51_A;
                base_dsi_stream = 0;
            }
            else if( DIGI_POST_MUX_BUS_1==digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[0].post_mux_2G5_bus_allocation)
            {
                dsi_type = LINE_OTN_DSI_TYPE_SFI_51_B;
                base_dsi_stream = 17;
            }
        }
        else if( digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[1].port_uid == p_port_ctxt->port_uid )
        {
            if( DIGI_POST_MUX_BUS_0==digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[1].post_mux_2G5_bus_allocation)
            {
                dsi_type = LINE_OTN_DSI_TYPE_SFI_51_A;
                base_dsi_stream = 0;
            }
            else if( DIGI_POST_MUX_BUS_1==digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[1].post_mux_2G5_bus_allocation)
            {
                dsi_type = LINE_OTN_DSI_TYPE_SFI_51_B;
                base_dsi_stream = 17;
            }
        }
        else /* count number of lanes in order to decide */
        {
            port_lane_num = 0;          /* this counts how many of the current port_uid we have */
            base_dsi_stream = DIGI_SERDES_DSI_LANES_MAX; /* put to maximum value on purpose */

            /* count only XFI side and find the lowest lane id - this will be the base dsi stream lane */
            for(i=0;i<DIGI_SERDES_XFI_LANES_MAX;i++)
            {
                if(digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid == p_port_ctxt->port_uid)
                {
                    /* keep the lowest post mux lane number */
                    if( digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].post_mux_dsi_lane < base_dsi_stream )
                        base_dsi_stream = digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].post_mux_dsi_lane;

                }
                /* If it'a a CFP application the port might be on the system side */
                if(DIGI_PROD_APP_GET(digi_handle) == DIGI_PROD_APP_100G_3_X_40G_CFP_CARD &&
                   digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid == p_port_ctxt->port_uid)
                {
                    /* keep the lowest post mux lane number */
                    if( digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].post_mux_dsi_lane < base_dsi_stream )
                        base_dsi_stream = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].post_mux_dsi_lane;

                }
            }

            port_lane_num = digi_by_port_uid_num_line_xfi_lanes_get(digi_handle, p_port_ctxt->port_uid);

            /* If it'a a CFP application the port might be on the system side */
            if(DIGI_PROD_APP_GET(digi_handle) == DIGI_PROD_APP_100G_3_X_40G_CFP_CARD &&
               port_lane_num == 0)
                port_lane_num = digi_by_port_uid_num_sys_xfi_lanes_get(digi_handle, p_port_ctxt->port_uid);

            switch(port_lane_num)
            {
            case 1: /* this is a 10G dsi type */
                dsi_type = LINE_OTN_DSI_TYPE_OTUK;
                break;

            case 4: /* this is a 40G OTL dsi type */
            case 10: /* this 100G cage OTL 4.10*/
                dsi_type = LINE_OTN_DSI_TYPE_OTL;
                break;

            case 5:  /* this is a 40G SFI-S dsi type */
            case 11:
            case 12:
                dsi_type = LINE_OTN_DSI_TYPE_SFIS;
                break;

            default:
                rc = DIGI_ERR_INVALID_ARG;
                break;
            }

        }

        if ( PMC_SUCCESS == rc ) /* second step - convert otuk_mode to line otn rate */
        {
            switch (otuk_mode)
            {
            case DIGI_OTN_SERVER_OTU2:
                frame_rate = LINE_OTN_RATE_OTU2;
                oduk_type = UTIL_GLOBAL_ODU2;
                break;
            case DIGI_OTN_SERVER_OTU1E:
                frame_rate = LINE_OTN_RATE_OTU1E;
                oduk_type = UTIL_GLOBAL_ODU1E;
                break;
            case DIGI_OTN_SERVER_OTU2E:
                frame_rate = LINE_OTN_RATE_OTU2E;
                oduk_type = UTIL_GLOBAL_ODU2E;
                break;
            case DIGI_OTN_SERVER_OTU1F:
                frame_rate = LINE_OTN_RATE_OTU1F;
                oduk_type = UTIL_GLOBAL_ODU1F;
                break;
            case DIGI_OTN_SERVER_OTU2F:
                frame_rate = LINE_OTN_RATE_OTU2F;
                oduk_type = UTIL_GLOBAL_ODU2F;
                break;
            case DIGI_OTN_SERVER_OTU3:
                frame_rate = LINE_OTN_RATE_OTU3;
                oduk_type = UTIL_GLOBAL_ODU3;
                break;
            case DIGI_OTN_SERVER_OTU3E1:
                frame_rate = LINE_OTN_RATE_OTU3E1;
                oduk_type = UTIL_GLOBAL_ODU3E1;
                break;
            case DIGI_OTN_SERVER_OTU3E2:
                frame_rate = LINE_OTN_RATE_OTU3E2;
                oduk_type = UTIL_GLOBAL_ODU3E2;
                break;
            case DIGI_OTN_SERVER_OTU4:
                frame_rate = LINE_OTN_RATE_OTU4;
                oduk_type = UTIL_GLOBAL_ODU4;
                break;
            default:
                rc = DIGI_ERR_INVALID_ARG;
                break;
            }

        }

        if ( PMC_SUCCESS == rc ) /* third step - power up line otn */
        {

            /* if this is the first time Lineotn is provisioned - change energy state */
            digi_lineotn_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RUNNING);
        }
        PMC_ATOMIC_YIELD(digi_handle,0);
        if ( PMC_SUCCESS == rc ) /* fourth step - set up the lifd/sifd mux */
        {
            rc = digi_serdes_port_lifd_sifd_mux_cfg(digi_handle,
                                                    p_port_ctxt,
                                                    XIFD_DSIS_OTN);
        }

        PMC_ATOMIC_YIELD(digi_handle,0);
        if ( PMC_SUCCESS == rc ) /* fifth step - configure the SERDES */
        {
            /* First get the serdes_mode, prior to configuring the SERDES */
            digi_otn_serdes_mode_get(otuk_mode, p_port_ctxt->intf, &serdes_mode);

            rc = digi_serdes_port_prov(digi_handle, p_port_ctxt, 
                                       serdes_mode);
            /* update serdes rate state */
            if (PMC_SUCCESS == rc)
            {
                rc = digi_serdes_port_rate_state_set(digi_handle, port_ctxt_ptr, serdes_mode, DIGI_SERDES_PROV_STATE_LINEOTN, DIGI_SERDES_PORT_RATE_STATE_PROV);
            }
            PMC_ATOMIC_YIELD(digi_handle,0);
            if ( PMC_SUCCESS == rc ) /* sixth step - provision line otn */
            {
                rc = lineotn_stream_prov(digi_handle->lineotn_handle,
                                         (lineotn_cfg_type_t)digi_handle->var.lineotn_cfg_num,
                                         base_dsi_stream,
                                         dsi_type,
                                         (lineotn_deskew_type_t)deskew_type,
                                         frame_rate,
                                         &dci_channel);
            }

            PMC_ATOMIC_YIELD(digi_handle,0);
            if ( PMC_SUCCESS == rc ) /* seventh step - set fec type */
            {
                rc = lineotn_fec_cfg( digi_handle->lineotn_handle,
                                      base_dsi_stream,
                                      dsi_type,
                                      (lineotn_fec_t)fec_mode );
            }


            PMC_ATOMIC_YIELD(digi_handle,0);
            /* Configure PMON related items for FEC */
            if ( PMC_SUCCESS == rc )
            {
                rc = digi_pmon_fw_fec_cfg(digi_handle);
            }

            PMC_ATOMIC_YIELD(digi_handle,0);

            /* Configure LOF monitoring in FW */
            if ( PMC_SUCCESS == rc && 
                 TRUE == pmc_lof_monitoring_in_fw(&digi_handle->base))
            {
                rc = lineotn_lof_mon_fw_cfg(digi_handle->lineotn_handle,
                                            base_dsi_stream,
                                            dsi_type,
                                            TRUE);

           
            }
            
            PMC_ATOMIC_YIELD(digi_handle,0); 
            if ( PMC_SUCCESS == rc ) /* eighth step - update output structure */
            {
                digi_otn_server_chnl_def_t *otn_server_ptr = digi_otn_server_line_client_chnl_get(digi_handle, dci_channel);
                otn_server_ptr->dci_chnl = dci_channel;
                otn_server_ptr->dsi_base_chnl = base_dsi_stream;
                otn_server_ptr->dsi_serdes_type =(UINT8)dsi_type;
                otn_server_ptr->port_uid = p_port_ctxt->port_uid;
                otn_server_ptr->oduk_type =(UINT8)oduk_type;
                otn_server_ptr->loopback_enabled = FALSE;
                
                (*otn_server_pptr) = (digi_otn_server_chnl_t*)otn_server_ptr;
                otn_server_ptr->serdes_mode = serdes_mode;

            }
        }
    }
    else
    {
        rc = DIGI_ERR_INVALID_ARG;
    }

    if (PMC_SUCCESS == rc)
    {
        rc = digi_serdes_port_rate_state_set(digi_handle, p_port_ctxt,serdes_mode, prov_state, DIGI_SERDES_PORT_RATE_STATE_PROV);
    }
    if (PMC_SUCCESS == rc)
    {
        ( (digi_otn_server_chnl_def_t*) *otn_server_pptr)->header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED;
    }
    
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_server_line_prov */

/*******************************************************************************
* digi_otn_server_sys_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies basic bidirectional mode configuration for an OTUk
*   signal passing between System Serdes and COREOTN High Order framer using the
*   SYSOTN subsystem.\n\n
*
*   This API may only be called in hardware systems where the product application
*   has been defined as: DIGI_PROD_APP_SYSOTN_CARD.\n\n
*
*   SYSOTN subsystem supports 100G OTU4 variants only.\n\n
*
*   OTUk signal types are defined in the digi_otn_server_mode_t enum type.\n\n
*
*   The FEC and payload format are intially set by this API.  These configurations 
*   may be dynamically reprovisioned after this API has been called.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_ctxt_ptr         - pointer to serdes port data for the serdes port to
*                            be configured.
*   fec_mode               - Enum, FEC processing mode of OTN signal.  Valid for
*                            frame_mode DIGI_OTN_SERVER_FRAME_OTUK
*   deskew_type            - Only valid if the serdes was provisioned
*                            for SFIS mode.  For system interface only
*                            DIGI_OTN_SERVER_OIF_SFIS_DESKEW is supported
*
* OUTPUTS:
*   **chnl_ctxt_pptr       - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
* RETURNS:
*   PMC_SUCCESS, DIGI_ERR_SYSOTN_UNSUPPORTED, DIGI_ERR_DEVICE_NOT_INIT,
*   DIGI_ERR_INVALID_ARG, DIGI_ERR_SERDES_PORT_ALREADY_PROV,
*   DIGI_ERR_NO_DSI_ALLOC_PROV or error codes from sub-functions
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_sys_prov(digi_handle_t *digi_handle,
                                          digi_serdes_port_t *port_ctxt_ptr,
                                          digi_otn_server_fec_t fec_mode,
                                          digi_sfis_deskew_type_t deskew_type,
                                          digi_otn_server_chnl_t **chnl_ctxt_pptr)
{
    PMC_ERROR rc = PMC_SUCCESS;


    UINT32                base_dsi_stream = 0;
    lineotn_dsi_type_t    dsi_type   = (lineotn_dsi_type_t)0;

    BOOL                  dsi_state_configured = FALSE;
    digi_post_mld_dsi_ctxt_t *p_post_mld_lanes = NULL;
    digi_serdes_port_def_t  *p_port_ctxt = NULL;
    digi_serdes_port_mode_t serdes_mode = DIGI_SERDES_PORT_MODE_ANY_LOWPWR;
    digi_serdes_prov_state_t prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;

    UINT32 dci_channel;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != port_ctxt_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_ctxt_pptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    rc = digi_otn_fec_type_validate(digi_handle, fec_mode);

    if (PMC_SUCCESS != rc)
    {
        PMC_ATOMIC_RETURN(digi_handle, rc);
    }

    if (FALSE == DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
    {
        /*
         * The product APP is npt SYSOTN. This is not a valid scenario tp
         * provision a sysotn port.
         */
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_SYSOTN_UNSUPPORTED);
    }

    /* check serdes port context context */
    DIGI_SERDES_PORT_CTXT_HANDLE_CHECK(digi_handle, port_ctxt_ptr, rc);

    /* dereference void pointer */
    p_port_ctxt=(digi_serdes_port_def_t*)port_ctxt_ptr;

    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_DEVICE_NOT_INIT);
    }

    /* this function should be invoked AFTER !!! dsi lane algorithm              */
    /* zero step - check the post mld lanes to verify that this port can be provisioned to lineotn SS */
    p_post_mld_lanes=digi_first_post_mld_dsi_find(digi_handle,p_port_ctxt->port_uid);
    
    if( p_post_mld_lanes != NULL )
    {
        if( DIGI_SERDES_PROV_STATE_UNASSIGNED == p_post_mld_lanes->prov_state )  /* port found - check that it is configured and not assigned */
        {
            rc = digi_post_mld_prov_state_set(digi_handle,p_port_ctxt->port_uid,DIGI_SERDES_PROV_STATE_SYSOTN); /* if this is unassigned port - unassign it to lineotn  */
            prov_state = DIGI_SERDES_PROV_STATE_SYSOTN;
            if(PMC_SUCCESS == rc)
                dsi_state_configured = TRUE;
            else
                rc = DIGI_ERR_INVALID_ARG; 
        }
        else
            rc = DIGI_ERR_SERDES_PORT_ALREADY_PROV;
    }
    else
    {
        rc = DIGI_ERR_NO_DSI_ALLOC_PROV;
    }
    
    if(!dsi_state_configured) /* we did not find the specified port number */        
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ARG);  /* if we got to this line - this a bug, exit and report */
    }
        
    if ( PMC_SUCCESS == rc ) /* third step - power up sysotn */
    {
        /* if this is the first time SYSOTN is provisioned - change energy state */
        digi_sysotn_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RUNNING);
    }
    PMC_ATOMIC_YIELD(digi_handle,0);
    if ( PMC_SUCCESS == rc ) /* fourth step - set up the lifd/sifd mux */
    {
        rc = digi_serdes_port_lifd_sifd_mux_cfg(digi_handle,
                                                p_port_ctxt,
                                                XIFD_DSIS_OTN);
    }
    PMC_ATOMIC_YIELD(digi_handle,0);
    if ( PMC_SUCCESS == rc ) /* fifth step - configure the SERDES */
    {
        /* First get the serdes_mode, prior to configuring the SERDES */
        digi_otn_serdes_mode_get(DIGI_OTN_SERVER_OTU4, p_port_ctxt->intf, &serdes_mode);

        rc = digi_serdes_port_prov(digi_handle, p_port_ctxt, 
                                   serdes_mode);

        /* update serdes rate state */
        if (PMC_SUCCESS == rc)
        {
            rc = digi_serdes_port_rate_state_set(digi_handle, port_ctxt_ptr, serdes_mode, DIGI_SERDES_PROV_STATE_SYSOTN, DIGI_SERDES_PORT_RATE_STATE_PROV);
        }
        PMC_ATOMIC_YIELD(digi_handle,0);
        if ( PMC_SUCCESS == rc ) /* sixth step - provision sysotn */
        {

            if(digi_handle->var.sysotn_cfg_num == 0)
            {
                /*OTL4 */
                rc = lineotn_stream_prov(digi_handle->sysotn_handle,
                                         (lineotn_cfg_type_t)digi_handle->var.sysotn_cfg_num,
                                         base_dsi_stream,
                                         LINE_OTN_DSI_TYPE_OTL,
                                         (lineotn_deskew_type_t)deskew_type,
                                         LINE_OTN_RATE_OTU4,
                                         &dci_channel);

                dsi_type = LINE_OTN_DSI_TYPE_OTL;
            }
            else
            {
                /* SFIS */
                rc = lineotn_stream_prov(digi_handle->sysotn_handle,
                                         (lineotn_cfg_type_t)digi_handle->var.sysotn_cfg_num,
                                         base_dsi_stream,
                                         LINE_OTN_DSI_TYPE_SFIS,
                                         (lineotn_deskew_type_t)deskew_type,
                                         LINE_OTN_RATE_OTU4,
                                         &dci_channel);

                dsi_type = LINE_OTN_DSI_TYPE_SFIS;

            }
        }
        PMC_ATOMIC_YIELD(digi_handle,0);
        if ( PMC_SUCCESS == rc ) /* seventh step - set fec type */
        {
            rc = lineotn_fec_cfg( digi_handle->sysotn_handle,
                                  base_dsi_stream,
                                  dsi_type,
                                  (lineotn_fec_t)fec_mode );
        }
        PMC_ATOMIC_YIELD(digi_handle,0);
        /* Configure LOF monitoring in FW */
        if ( PMC_SUCCESS == rc &&
             TRUE == pmc_lof_monitoring_in_fw(&digi_handle->base))
        {
            rc = lineotn_lof_mon_fw_cfg(digi_handle->sysotn_handle,
                                        base_dsi_stream,
                                        dsi_type,
                                        TRUE);
        }
        PMC_ATOMIC_YIELD(digi_handle,0);
        if ( PMC_SUCCESS == rc ) /* eighth step - update output structure */
        {
            digi_otn_server_chnl_def_t *otn_server_ptr = digi_sysotn_server_line_client_chnl_get(digi_handle);

            otn_server_ptr->dci_chnl = dci_channel;
            otn_server_ptr->dsi_base_chnl = base_dsi_stream;
            otn_server_ptr->dsi_serdes_type =(UINT8)dsi_type;
            otn_server_ptr->port_uid = p_port_ctxt->port_uid;
            otn_server_ptr->oduk_type =(UINT8)UTIL_GLOBAL_ODU4;
            otn_server_ptr->loopback_enabled = FALSE;
            /* Set SYSOTN context in the server channel pointer*/
            otn_server_ptr->sys_line_src = TRUE;
            (*chnl_ctxt_pptr) = (digi_otn_server_chnl_t*)otn_server_ptr;
            
            otn_server_ptr->serdes_mode = serdes_mode;

        }
    }
    
    if (PMC_SUCCESS == rc)
    {
        rc = digi_serdes_port_rate_state_set(digi_handle, p_port_ctxt,serdes_mode, prov_state, DIGI_SERDES_PORT_RATE_STATE_PROV);
    }

    if (PMC_SUCCESS == rc)
    {
        ( (digi_otn_server_chnl_def_t*) *chnl_ctxt_pptr)->header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED;
    }
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_server_sys_prov */

/*******************************************************************************
* digi_otn_odu_chnl_prov_mode_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function sets the COREOTN LO ODU channel provisioning mode. 
*   This function is used to determine if LO ODU channel will be provisioned 
*   one at a time or all LO ODU channels will be provisioned into the HO
*   container at once. 
*   
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance.
*   prov_mode       - Enum for LO ODU channel provisioning mode. 
*                     See digi_otn_odu_chnl_prov_mode_t. \n
*                            
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS or error codes from sub-functions
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_chnl_prov_mode_set(digi_handle_t *digi_handle,
                                                 digi_otn_odu_chnl_prov_mode_t prov_mode)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* replace with proper sub call after the review. Do we want to expand this 
    ** to include deprov mode if we decide to allow asymmetric prov-deprov mode?
    */
    /*result = coreotn_msi_cfg_mode_set(digi_handle->coreotn_handle,
      (util_global_otn_msi_cfg_mode_t) msi_cfg_mode);*/

    if (FALSE == pmc_prov_all_prov_mode_available(&digi_handle->base)
        && prov_mode ==  DIGI_OTN_ODU_CHNL_PROV_ALL)
    {
        PMC_LOG(PMC_LOG_SEV_MEDIUM, DIGI_ERR_PROV_ALL_NOT_AVAILABLE, 0, 0);
        result = PMC_SUCCESS;
    }
    else
    {
        result = coreotn_odu_chnl_prov_mode_set(digi_handle->coreotn_handle,
                                                (coreotn_odu_chnl_prov_mode_t)prov_mode);
    }

                                                
    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_odu_chnl_prov_mode_set */

/*******************************************************************************
* digi_otn_odu_chnl_prov_mode_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function gets the COREOTN LO ODU channel provisioning mode. 
*   
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance.
*                            
*
* OUTPUTS:
*   prov_mode       - Enum for LO ODU channel provisioning mode. 
*                     See digi_otn_odu_chnl_prov_mode_t. \n
*
* RETURNS:
*   PMC_SUCCESS or error codes from sub-functions
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_chnl_prov_mode_get(digi_handle_t *digi_handle,
                                                digi_otn_odu_chnl_prov_mode_t *prov_mode)
{
    PMC_ERROR rc = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    rc = coreotn_odu_chnl_prov_mode_get(digi_handle->coreotn_handle, 
                                        (coreotn_odu_chnl_prov_mode_t *)prov_mode);

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_odu_chnl_prov_mode_get */

/*******************************************************************************
* digi_otn_server_ho_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies detailed bidirectional configuration for high order
*   ODUk processing blocks.\n\n
*
*   SW driver internally describes ODU framer configuration using an ODU struct
*   for high order container.\n\n
*
*   In Direct Device Configuration mode - This function internally generates a
*   TRQ containing the requested configuration data and calls the FW Host
*   Message for processing the HO ODU struct.\n\n
*
*   In Pending Configuration mode - This function updates HO ODU struct
*   with the desired configuration data to be applied in the future.\n\n
*
*   When operating in pending mode, the OUTPUT parameter out_chnl_ctxt_pptr is
*   an input.  It is the caller's responsibility to allocate the ODU struct
*   pool resource and communicate it to this API using the out_chnl_ctxt_pptr
*   parameter.\n\n
*
*   The SW driver will initially specify the payload type of the signal for
*   payload mode of 1G25 or 2G5 Tributary slots for Payload Type 20 or 21 as
*   defined in ITU G.709.\n\n
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *otn_server_ptr        - pointer to OTU framer to configure ODU HO container
*                            against
*   cfg_mode               - function operation mode:\n
*                            0: Direct Device Configuration\n
*                            1: Pending Configuration
*   payload_mode           - System Side Payload Format\n
*                            0: Unchannelized\n
*                            1: Channelized 1G25 rate tributary slots\n
*                            2: Channelized 2G5 rate tributary slots
*
* OUTPUTS:
*   **out_chnl_ctxt_pptr   - pointer to a pointer to a context for the HO
*                            framer channel
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_ho_prov(digi_handle_t *digi_handle,
                                         digi_otn_server_chnl_t *otn_server_ptr,
                                         digi_otn_cfg_mode_t cfg_mode,
                                         digi_odu_line_payload_t payload_mode,
                                         digi_otn_odu_chnl_t **out_chnl_ctxt_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;

    digi_otn_server_chnl_def_t *temp_otn_server_ptr = (digi_otn_server_chnl_def_t *)otn_server_ptr;
    BOOL8 is_src_sysotn_server = FALSE;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != temp_otn_server_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(temp_otn_server_ptr->dci_chnl < DIGI_SERDES_XFI_LANES_MAX, DIGI_ERR_INVALID_ARG, temp_otn_server_ptr->dci_chnl, 0);
    PMC_ASSERT(temp_otn_server_ptr->dsi_base_chnl < DIGI_SERDES_XFI_LANES_MAX || 17==temp_otn_server_ptr->dsi_base_chnl , DIGI_ERR_INVALID_ARG, temp_otn_server_ptr->dsi_base_chnl, 0);
    PMC_ASSERT(temp_otn_server_ptr->dsi_serdes_type <  (UINT8)LAST_LINE_OTN_DSI_TYPE , DIGI_ERR_INVALID_ARG, temp_otn_server_ptr->dsi_base_chnl, 0);

    if (PMC_SUCCESS != digi_otn_server_chnl_handle_validate(digi_handle, otn_server_ptr) && PMC_SUCCESS != digi_sysotn_server_chnl_handle_validate(digi_handle, otn_server_ptr))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }

    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_DEVICE_NOT_INIT);
    }
                                             
    /* first look up to see if the server is sourced from LINEOTN or SYSOTN */
    is_src_sysotn_server = temp_otn_server_ptr->sys_line_src;

    /* LINEOTN */
    if (is_src_sysotn_server == FALSE) {

        if (PMC_SUCCESS == result) {

            /* is this a SYSOTN application ? */
            if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE) { 

                /* For SYSOTN applications were server is source from LINEOTN.
                   This should provision the ODUKSW <-> LINEOTN segment */

                result = digi_otn_server_ho_sysapp_internal_prov(digi_handle,
                                                                 temp_otn_server_ptr,
                                                                 out_chnl_ctxt_pptr);
 
            } else { /* (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == FALSE) */

                result = digi_otn_server_ho_internal_prov(digi_handle,
                                                          temp_otn_server_ptr,
                                                          cfg_mode,
                                                          payload_mode,
                                                          is_src_sysotn_server,
                                                          out_chnl_ctxt_pptr,
                                                          TRUE,
                                                          TRUE);
 
            }
        }

        /* SYSOTN */
    } else { /* (is_src_sysotn_server == TRUE) */
       
        /* provision the COREOTN HO segment (SYSOTN -> COREOTN HO in FMF2) */

        if (PMC_SUCCESS == result) {

            result = digi_otn_server_ho_internal_prov(digi_handle,
                                                      temp_otn_server_ptr,
                                                      cfg_mode,
                                                      payload_mode,
                                                      is_src_sysotn_server,
                                                      out_chnl_ctxt_pptr,
                                                      TRUE,
                                                      TRUE);

        }       
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_server_ho_prov */

/*******************************************************************************
* digi_otn_server_lo_prov_num_chnl_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   
*   This function is used to set the total number of LO channels that will be
*   added to the HO ODU channel. This function must be called for each HO ODU
*   channel that is channelized. \n\n
*
*   This function must be called after digi_otn_server_ho_prov() 
*   if digi_otn_odu_chnl_prov_mode_set() is called with 'DIGI_OTN_ODU_CHNL_RPOV_ALL'. \n\n
*
*   In 1 stage muxing, 'num_mo_chnls' should be set to the total number of
*   LO channels that will be provisioned in the HO. \n\n
*
*   In 2 stage muxing, 'num_mo_chnls' should be set to the total number of 
*   MO channels being provisioned into the HO channel and 'num_lo_chnls' should 
*   be set to the total number of LO channels that will be provisioned in one MO channel.\n\n
*
*   For example: 
*   1) In one stage muxing datapath such as 1xOTU4 <-> 80xODU0, 
*      this function needs to be called only once with 'num_mo_chnls' set to 80 
*      and 'num_lo_chnls' set to 0. \n\n
*   
*   2) In one stage muxing datapath such as 10xOTU2 <-> 40xODU1,
*      this function should be called once per HO OTU2. 
*      In each call, 'num_mo_chnls' should be set to 4.\n\n
*
*   3) In two stage muxing datapath such as 1xOTU4 <-> 40xODU1 <-> 80xODU0,
*      this function should be called only once with 'num_mo_chnls' set to 40
*      and 'num_lo_chnls' set to 2. \n\n
*    
*   
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   *in_chnl_ctxt_ptr   - pointer to higher order channel containing the
*                         low order framer to be provisioned.
*   num_mo_chnls        - total number of MO ODU channels that will be added to
*                         the HO ODU channel.
*   num_lo_chnls        - total number of LO ODU channels that will be added to
*                         the HO ODU channel.
*                            
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_lo_prov_num_chnl_set(digi_handle_t *digi_handle,
                                                      digi_otn_odu_chnl_t *in_chnl_ctxt_ptr,
                                                      UINT8 num_mo_chnls,
                                                      UINT8 num_lo_chnls)
{
    PMC_ERROR result = PMC_SUCCESS;
    odu_struct_t *ho_odu_struct_ptr;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != in_chnl_ctxt_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    /* get the HO framer channel context */
    ho_odu_struct_ptr = (odu_struct_t *)in_chnl_ctxt_ptr;
    PMC_ASSERT(NULL != ho_odu_struct_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    /* check if this is the absolute HO channel pointer and not MO */
    if ((UINT32)ho_odu_struct_ptr->mem_ptr->odu_level != (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
    {
        result = DIGI_ERR_INVALID_ODU_CHNL_CTXT;
    }
    else 
    {
        PMC_ASSERT(ho_odu_struct_ptr->mem_ptr->chnl_id < DIGI_NUM_HO_ODU_CHNL_MAX, DIGI_ERR_INVALID_ARG, ho_odu_struct_ptr->mem_ptr->chnl_id, 0);
    } 
    
    if (PMC_SUCCESS == result)
    {
        if (num_mo_chnls > DIGI_OTN_SERVER_MAX_TRIBSLOT 
            || num_lo_chnls > DIGI_OTN_SERVER_MAX_TRIBSLOT)
        {
            result = DIGI_ERR_INVALID_ARG;
        }
    }
    
    if (PMC_SUCCESS == result)
    {
        result = coreotn_super_prov_lo_prov_num_chnl_set(digi_handle->coreotn_handle,
                                                         ho_odu_struct_ptr->mem_ptr->chnl_id,
                                                         num_mo_chnls,
                                                         num_lo_chnls);                                                   
    }
    
    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_odu_chnl_prov_mode_set */

/*******************************************************************************
* digi_otn_server_lo_prov_asym
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies detailed configuration for low order ODUk processing
*   blocks. This function takes in two separate arguments for tributary slot
*   definition for each traffic diretion. \n\n
*
*   For Rev A devices, tx_trib_slot_mask[3] and rx_trib_slot_mask[3] must be
*   the same. Otherwise, an error will be returned from this function.

*   When this function is used to perform 1 stage multiplexing:
*   This function is used to provision a LO ODUk framer channel into a HO ODUk
*   framer channel.  
*
*   When this function is used to perform 2 stage multiplexing:
*   This function is used to provision a LO ODUk framer channel into a MO ODUk
*   framer channel as well as to provision a MO ODUk framer channel into a
*   HO ODUk framer channel.  
*
*   SW driver internally describes ODU framer configuration using an ODU struct
*   for low order container.\n\n
*
*   This function updates the tributary slot assignment and tributary port data
*   of the HO ODU struct that the LO ODU struct is associated with.\n\n
*
*   In Direct Device Configuration mode - This function internally generates a
*   TRQ containing the requested configuration data and calls the FW Host
*   Message for processing the HO/LO ODU struct.\n\n
*
*   In Pending mode - This function updates LO ODU struct and the parent HO ODU
*   struct with the desired configuration data to be applied in the future.\n\n
*
*   When operating in pending mode, the OUTPUT parameter out_chnl_ctxt_pptr is
*   an input.  It is the caller's responsibility to allocate the ODU struct
*   pool resource and communicate it to this API using the out_chnl_ctxt_pptr
*   parameter.\n\n
*
*   The SW driver will initially specify the payload type of the signal for
*   payload mode of 1G25 or 2G5 Tributary slots for Payload Type 20 or 21 as
*   defined in ITU G.709.\n\n
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   *in_chnl_ctxt_ptr   - pointer to higher order channel containing the
*                         low order framer to be provisioned.
*   cfg_mode            - function operation mode:\n
*                         0: Direct Device Configuration\n
*                         1: Pending Configuration
*   oduk_type           - Enum, ODUk container type. See digi_oduk_t.
*   client_bitrate      - For DIGI_ODUKSW_STREAM_CBR_ODUFLEX, specify the client
*                         bit rate in bps.  This is the ODU client rate.
*                         (ODU rate = unmapped client rate * (239/238))
*                         For all the other LO ODU types, set to 0.  
*   mapping_mode        - payload mapping mode. See digi_otn_mapping_type_t.
*   tx_trib_slot_mask   - tributary slots low order container will use 
*                         in higher order payload in transmit direction.
*                         For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, the number of
*                         bits set in this mask should match the number of 
*                         tributary slots in the ODUFlex container. Also the 
*                         number of bits set in this mask must equal the number
*                         of bits set in rx_trib_slot_mask input argument.                       
*   rx_trib_slot_mask   - tributary slots low order container will use 
*                         in higher order payload in receive direction.
*                         For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, the number of
*                         bits set in this mask should match the number of 
*                         tributary slots in the ODUFlex container. If
*                         you wish to perform RX provisioning independently
*                         of TX provisioning, see note below.
*   payload_mode        - System Side Payload Format\n
*                         0: Unchannelized\n
*                         1: Channelized 1G25 rate tributary slots\n
*                         2: Channelized 2G5 rate tributary slots
*
*   *** To perform TX provisioning independently of RX provisioning ***
*        if provisioning RX before TX:
*             - Provision LO segment in RX path only by providing 
*               valid rx_trib_slot_mask, and tx_trib_slot_mask = {0,0,0}
*             - Provision LO segment in TX (without interrupting traffic
*                in RX) by providing valid tx_trib_slot_mask and the
*                rx_trib_slot_mask provided in the first step
*        if provisioning TX before RX:
*             - Provision LO segment in TX path only by providing 
*               valid tx_trib_slot_mask, and rx_trib_slot_mask = {0,0,0}
*             - Provision LO segment in RX (without interrupting traffic
*                in TX) by providing valid rx_trib_slot_mask and the
*                tx_trib_slot_mask provided in the first step
*
* OUTPUTS:
*   **out_chnl_ctxt_pptr    - pointer to a pointer to a context for the LO
*                             framer channel
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_lo_prov_asym( digi_handle_t *digi_handle,
                                               digi_otn_odu_chnl_t *in_chnl_ctxt_ptr,
                                               digi_otn_cfg_mode_t cfg_mode,
                                               digi_oduk_t oduk_type,
                                               DOUBLE client_bitrate,
                                               digi_otn_mapping_type_t mapping_mode,
                                               UINT32 tx_trib_slot_mask[3],
                                               UINT32 rx_trib_slot_mask[3],
                                               digi_odu_line_payload_t payload_mode,
                                               digi_otn_odu_chnl_t **out_chnl_ctxt_pptr)                                       
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 i, j;
    
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_DEVICE_NOT_INIT);
    }
         
    if (TRUE == pmc_asymmetric_msi_revision(&digi_handle->base))
    {
        for (i = 0; i < DIGI_SCHD_96_ENTRY; i++)
        {
            /* the first tribslot in TX */
            if ((tx_trib_slot_mask[i/32] >> (i%32)) & 1)
            {
                /* confirm that RX has the same bit set */
                if ((rx_trib_slot_mask[i/32] >> (i%32)) & 1)    
                {
                    /* confirm that this is the first bit in RX since 
                    ** it is possible that there might be other bits set 
                    ** prior to this location
                    */
                    for (j = 0; j < i; j++)
                    {
                        if ((rx_trib_slot_mask[j/32] >> (j%32)) & 1)  
                        {
                            result = DIGI_ERR_TRIB_SLOT_ASYMMETRIC;
                            break;
                        }
                    } 
                    break;
                }
                else {
                    result = DIGI_ERR_TRIB_SLOT_ASYMMETRIC;
                }
                
                /* we successfully verified that both directions have the same 
                ** tribslot selected as its first ts
                */
                break;
            }
        }                    
    }
    
    if (PMC_SUCCESS == result)
    {
        result = digi_otn_server_lo_prov_internal(digi_handle,
                                                  in_chnl_ctxt_ptr,
                                                  cfg_mode,
                                                  oduk_type,
                                                  client_bitrate,
                                                  mapping_mode,
                                                  tx_trib_slot_mask,
                                                  rx_trib_slot_mask,
                                                  payload_mode,
                                                  out_chnl_ctxt_pptr,
                                                  TRUE); /*prov_ho_cfg == TRUE*/
    }                                         

    PMC_ATOMIC_RETURN(digi_handle,result);
    
} /* digi_otn_server_lo_prov_asym */


/*******************************************************************************
* digi_otn_server_lo_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies detailed bidirectional configuration for low order
*   ODUk processing blocks.\n\n
*
*   When this function is used to perform 1 stage multiplexing:
*   This function is used to provision a LO ODUk framer channel into a HO ODUk
*   framer channel.  
*
*   When this function is used to perform 2 stage multiplexing:
*   This function is used to provision a LO ODUk framer channel into a MO ODUk
*   framer channel as well as to provision a MO ODUk framer channel into a
*   HO ODUk framer channel.  
*
*   SW driver internally describes ODU framer configuration using an ODU struct
*   for low order container.\n\n
*
*   This function updates the tributary slot assignment and tributary port data
*   of the HO ODU struct that the LO ODU struct is associated with.\n\n
*
*   In Direct Device Configuration mode - This function internally generates a
*   TRQ containing the requested configuration data and calls the FW Host
*   Message for processing the HO/LO ODU struct.\n\n
*
*   In Pending mode - This function updates LO ODU struct and the parent HO ODU
*   struct with the desired configuration data to be applied in the future.\n\n
*
*   When operating in pending mode, the OUTPUT parameter out_chnl_ctxt_pptr is
*   an input.  It is the caller's responsibility to allocate the ODU struct
*   pool resource and communicate it to this API using the out_chnl_ctxt_pptr
*   parameter.\n\n
*
*   The SW driver will initially specify the payload type of the signal for
*   payload mode of 1G25 or 2G5 Tributary slots for Payload Type 20 or 21 as
*   defined in ITU G.709.\n\n
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   *in_chnl_ctxt_ptr   - pointer to higher order channel containing the
*                         low order framer to be provisioned.
*   cfg_mode            - function operation mode:\n
*                         0: Direct Device Configuration\n
*                         1: Pending Configuration
*   oduk_type           - Enum, ODUk container type. See digi_oduk_t.
*   client_bitrate      - For DIGI_ODUKSW_STREAM_CBR_ODUFLEX, specify the client
*                         bit rate in bps.  This is the ODU client rate.
*                         (ODU rate = unmapped client rate * (239/238))
*                         For all the other LO ODU types, set to 0.  
*   mapping_mode        - payload mapping mode. See digi_otn_mapping_type_t.
*   trib_slot_mask      - tributary slots low order container will use in
*                         higher order payload.
*                         For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, the number of
*                         bits set in this mask should match the number of 
*                         tributary slots in the ODUFlex container.
*   payload_mode        - System Side Payload Format\n
*                         0: Unchannelized\n
*                         1: Channelized 1G25 rate tributary slots\n
*                         2: Channelized 2G5 rate tributary slots
*
* OUTPUTS:
*   **out_chnl_ctxt_pptr    - pointer to a pointer to a context for the LO
*                             framer channel
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_lo_prov( digi_handle_t *digi_handle,
                                          digi_otn_odu_chnl_t *in_chnl_ctxt_ptr,
                                          digi_otn_cfg_mode_t cfg_mode,
                                          digi_oduk_t oduk_type,
                                          DOUBLE client_bitrate,
                                          digi_otn_mapping_type_t mapping_mode,
                                          UINT32 trib_slot_mask[3],
                                          digi_odu_line_payload_t payload_mode,
                                          digi_otn_odu_chnl_t **out_chnl_ctxt_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY(); /* Atomic entry/return is in digi_otn_server_lo_prov_asym */

    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        PMC_RETURN(DIGI_ERR_DEVICE_NOT_INIT);
    }

    result = digi_otn_server_lo_prov_asym( digi_handle,
                                           in_chnl_ctxt_ptr,
                                           cfg_mode,
                                           oduk_type,
                                           client_bitrate,
                                           mapping_mode,
                                           trib_slot_mask,
                                           trib_slot_mask,
                                           payload_mode,
                                           out_chnl_ctxt_pptr); 


    PMC_RETURN(result); /* Atomic entry/return is in digi_otn_server_lo_prov_asym */

} /* digi_otn_server_lo_prov */

/*******************************************************************************
* digi_otn_server_lo_prov_end
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs bulk provision for the two available modes:
*   COREOTN_ODU_CHNL_PROV_ALL or COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   *in_chnl_ctxt_ptr   - pointer to higher order channel containing the
*                         low order framer to be deprovisioned.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_lo_prov_end(digi_handle_t *digi_handle,
                                             digi_otn_odu_chnl_t *in_chnl_ctxt_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    coreotn_odu_chnl_prov_mode_t prov_mode = LAST_COREOTN_CHNL_PROV_MODE;


    PMC_ATOMIC_ENTRY(digi_handle);

    /* get ODU channel provisioning mode */
    coreotn_odu_chnl_prov_mode_get(digi_handle->coreotn_handle,
                                   &prov_mode);

    PMC_ASSERT(COREOTN_ODU_CHNL_PROV_ALL == prov_mode || COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK == prov_mode, DIGI_ERR_CODE_ASSERT, 0, 0);

    if (COREOTN_ODU_CHNL_PROV_ALL == prov_mode)
    {
        result = digi_otn_server_prov_all_lo_prov_end(digi_handle,
                                                      in_chnl_ctxt_ptr);
    }
    else
    {
        /* Provision mode is COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK */
        digi_otn_server_oduksw_prov_deprov_end(digi_handle, TRUE);
    }

    digi_otn_fc_calendar_bulk_update(digi_handle);

    coreotn_oduksw_port_bulk_update_req_init(digi_handle->coreotn_handle);

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_server_lo_prov_end */

/*******************************************************************************
* digi_otn_server_prov_all_lo_prov_end
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies the pending LO ODU channel configurations to the 
*   offline page and activates all the LO channels.\n\n
*
*   This function should be used only when 'digi_otn_odu_chnl_prov_mode_set() is 
*   called with DIGI_OTN_ODU_CHNL_PROV_ALL. This function must be called once
*   per each muxing stage.
* 
*   1) In one stage muxing datapath, this function needs to be called
*   once after the very last LO channel has been provisioned with digi_otn_server_lo_prov().
*       - '*in_chnl_ctxt_ptr' should be the pointer to the HO ODU channel.\n\n
*   2) In two stage muxing datapath, this function needs to be called twice.
*   Once after the very last MO channel has been provisioned.
*       - '*in_chnl_ctxt_ptr' should be the pointer to the HO ODU channel.\n\n
*   Once after the very last LO channel has been provisioned.
*       - '*in_chnl_ctxt_ptr' should be the pointer to the MO ODU channel.\n\n
*   
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   *in_chnl_ctxt_ptr   - pointer to higher order channel containing the
*                         low order framer to be provisioned.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_prov_all_lo_prov_end( digi_handle_t *digi_handle,
                                                        digi_otn_odu_chnl_t *in_chnl_ctxt_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    odu_struct_t *ho_odu_struct_ptr;
    digi_otn_mux_stages_t mux_stage = LAST_DIGI_OTN_MUX_STAGES;
    
    UINT32 num_lo_chnls_tx, num_lo_chnls_rx;
    
    UINT32 i;
    UINT32 j;
    BOOL8 ilkn_1_activate = FALSE;
    BOOL8 ilkn_2_activate = FALSE;
    BOOL8 mapotn_activate = FALSE;
    UINT32 cnt = 0;
    BOOL8 found = FALSE;
    
    util_global_switch_data_t* coreotn_input_pc_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_switch_data_t* coreotn_output_pc_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    
    util_global_switch_data_def_t *coreotn_local_output_sw_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_switch_data_def_t *coreotn_local_input_sw_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    
    util_global_switch_data_t* input_pc_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_switch_data_t* output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_NOT_USED][UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    
    util_global_oduk_port_data_t *coreotn_output_pc_data_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];    
    util_global_oduk_port_data_t *coreotn_input_pc_data_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    
    util_global_oduk_port_data_t *input_pc_data_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_oduk_port_data_t *output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_NOT_USED][UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    
    util_global_switch_data_def_t *local_input_sw_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_switch_data_def_t *local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_NOT_USED][UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    
    util_global_switch_data_t* input_to_mapotn_pc_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_switch_data_t* input_to_ilkn_1_pc_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_switch_data_t* input_to_ilkn_2_pc_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];

    util_global_oduk_port_data_t *input_to_mapotn_pc_data_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_oduk_port_data_t *input_to_ilkn_1_pc_data_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_oduk_port_data_t *input_to_ilkn_2_pc_data_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];

    BOOL is_coreotn_reader_primary[UTIL_GLOBAL_ODUK_PORT_NOT_USED][UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    BOOL is_coreotn_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_NOT_USED][UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    BOOL is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_NOT_USED][UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    BOOL is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_NOT_USED][UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    BOOL is_broadcast, is_multicast;
    UINT32 chnl_id = DIGI_DCI_CHANNEL_UNASSIGNED;
    util_global_odu_line_payload_t payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
    coreotn_chnl_state_t chnl_state;
    coreotn_odu_chnl_prov_mode_t prov_mode = LAST_COREOTN_CHNL_PROV_MODE;
    UINT8 ilkn_1_chnl_cnt = 0;
    UINT8 ilkn_2_chnl_cnt = 0;
    UINT8 mapotn_chnl_cnt = 0;
    UINT8 unchan_cnt = 0;
    BOOL8 unchan_mo = FALSE;
    digi_otn_server_chnl_def_t *otn_server_ptr;
    lineotn_handle_t* otn_handle;
    
    PMC_ENTRY();

    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        PMC_RETURN(DIGI_ERR_DEVICE_NOT_INIT);
    }
    
    /* If bulk (de)prov isn't available, issue a log message and return
     * PMC_SUCCESS
     */
    if (FALSE == pmc_prov_all_prov_mode_available(&digi_handle->base))
    {
        PMC_LOG(PMC_LOG_SEV_MEDIUM, DIGI_ERR_PROV_ALL_NOT_AVAILABLE, 0, 0);
        PMC_RETURN(PMC_SUCCESS);
    }

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != in_chnl_ctxt_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    /* get ODU channel provisioning mode */
    result = coreotn_odu_chnl_prov_mode_get(digi_handle->coreotn_handle, &prov_mode);
                                               
    if (PMC_SUCCESS == result && COREOTN_ODU_CHNL_PROV_ALL != prov_mode && COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK != prov_mode)
    {
        result = DIGI_ERR_INCORRECT_ODU_PROV_MODE;
    }

    if (PMC_SUCCESS == result)
    {
        /* check otn odu struct input handle */
        result = digi_ho_odu_struct_handle_validate(digi_handle, in_chnl_ctxt_ptr);
    }

    if (PMC_SUCCESS != result)
    {
        result = digi_mo_odu_struct_handle_validate(digi_handle, in_chnl_ctxt_ptr);        
    }
    
    if (PMC_SUCCESS == result)
    {
        /* initialize pointer lists */
        for (i = 0; i < UTIL_GLOBAL_MAX_NUM_ODU_CHNL; i++)
        {
            coreotn_input_pc_ptr_list[i] = NULL;
            coreotn_output_pc_ptr_list[i] = NULL;
            coreotn_local_input_sw_ptr_list[i] = NULL;
            coreotn_local_output_sw_ptr_list[i] = NULL;
            coreotn_input_pc_data_ptr_list[i] = NULL;
            coreotn_output_pc_data_ptr_list[i] = NULL;
            input_pc_ptr_list[i] = NULL;
            local_input_sw_ptr_list[i] = NULL;
            input_pc_data_ptr_list[i] = NULL;
            input_to_mapotn_pc_data_ptr_list[i] = NULL;
            input_to_ilkn_1_pc_data_ptr_list[i] = NULL;
            input_to_ilkn_2_pc_data_ptr_list[i] = NULL;
            input_to_mapotn_pc_ptr_list[i] = NULL;
            input_to_ilkn_1_pc_ptr_list[i] = NULL;
            input_to_ilkn_2_pc_ptr_list[i] = NULL;

        }    

        for (i = 0; i < UTIL_GLOBAL_ODUK_PORT_NOT_USED; i++)
        {
            for (j = 0; j < UTIL_GLOBAL_MAX_NUM_ODU_CHNL; j++)
            {
                output_pc_ptr_list[i][j] = NULL;
                local_output_sw_ptr_list[i][j] = NULL;
                output_pc_data_ptr_list[i][j] = NULL;
                is_other_reader_primary[i][j] = FALSE;
                is_other_slave_zone_primary[i][j] = FALSE;
                is_coreotn_reader_primary[i][j] = FALSE;
                is_coreotn_slave_zone_primary[i][j] = FALSE;

            }
        }
    }

    if (PMC_SUCCESS == result)
    {

        /* get the HO framer channel context */
        ho_odu_struct_ptr = (odu_struct_t *)in_chnl_ctxt_ptr;
        PMC_ASSERT(NULL != ho_odu_struct_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);

        odu_chnl_t *local_ho_odu_chnl_ptr = ho_odu_struct_ptr->mem_ptr;
        
        if (local_ho_odu_chnl_ptr->payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
        {
            PMC_RETURN(DIGI_ERR_INVALID_HO_PAYLOAD_FORMAT);
        }
        
        num_lo_chnls_tx = local_ho_odu_chnl_ptr->trib_slot_ctxt.num_sub_container_tx;
        num_lo_chnls_rx = local_ho_odu_chnl_ptr->trib_slot_ctxt.num_sub_container_rx;
        
        UINT8 lo_chnl_ids_tx[num_lo_chnls_tx];
        UINT8 lo_chnl_ids_rx[num_lo_chnls_rx];
        UINT8 lo_chnl_ids_tx_unchannelized[num_lo_chnls_tx];
        
        /* Initialize to 0 so it is set before used. */
        PMC_MEMSET(& lo_chnl_ids_tx[0],0x7F,sizeof(UINT8)* num_lo_chnls_tx);
        PMC_MEMSET(& lo_chnl_ids_rx[0],0x7F,sizeof(UINT8)* num_lo_chnls_rx);
        PMC_MEMSET(& lo_chnl_ids_tx_unchannelized[0],0x7F,sizeof(UINT8)* num_lo_chnls_tx);

        /* if HO payload is channelized, this is 1 stage muxing 
        ** add LO channel into the active HO channel
        */
        if ((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
        { 
            mux_stage = DIGI_OTN_MUX_STAGES_ONE;
        }
        else if ((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU)
        { 
            if (digi_handle->var.mux_stages != DIGI_OTN_MUX_STAGES_TWO)
            {
                PMC_ASSERT(FALSE, DIGI_ERR_INCORRECT_MAX_MUXING_LEVEL, 0, 0);
            }
            
            mux_stage = DIGI_OTN_MUX_STAGES_TWO;
        }
           
        /* retreive the LO channel IDs */
        for (i = 0; i < UTIL_GLOBAL_MAX_NUM_TS; i++)
        {
            if (local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_tx[i] != DIGI_DCI_CHANNEL_UNASSIGNED)
            {
                lo_chnl_ids_tx[cnt] = local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_tx[i];
                cnt++;
            } 
            
            if (cnt == num_lo_chnls_tx)
            {
                break;
            }                  
        }
        
        if (cnt != num_lo_chnls_tx)
        {
            result = DIGI_ERR_OTN_ODU_SUB_CHNL_CNT_MISMATCH;
        }
        
        cnt = 0;
        /* find channel IDs that map to COREOTN as its output port of ODUKSW */
        for (i = 0; i < UTIL_GLOBAL_MAX_NUM_TS; i++)
        {
            if (local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_rx[i] != DIGI_DCI_CHANNEL_UNASSIGNED)
            {
                lo_chnl_ids_rx[cnt] = local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_rx[i];
                cnt++;
            } 
            
            if (cnt == num_lo_chnls_rx)
            {
                break;
            }                    
        }
        
        if (cnt != num_lo_chnls_rx)
        {
            result = DIGI_ERR_OTN_ODU_SUB_CHNL_CNT_MISMATCH;
        } 
        /* set the channel config state to END */
        

        if (PMC_SUCCESS == result)
        {
            if ((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
            {
                found = FALSE;
                for (i = 0; i < cnt && PMC_SUCCESS == result && found == FALSE; i++)
                { 
                    result = coreotn_mo_chnl_state_get(digi_handle->coreotn_handle,
                                                       lo_chnl_ids_tx[i],
                                                       0, 
                                                       &chnl_state);
                    
                    /* New LO channels being added will be in EQUIPPED state at this point */                       
                    if ((chnl_state == COREOTN_CHNL_EQUIPPED || 
                        (prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK&& chnl_state == COREOTN_CHNL_OPERATIONAL)) 
                        && PMC_SUCCESS == result)
                    {                                           
                        coreotn_payload_format_get(digi_handle->coreotn_handle,
                                                   UTIL_GLOBAL_LEVEL_MO_ODU,
                                                   0,
                                                   lo_chnl_ids_tx[i],
                                                   &payload_format);

                        if (payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
                        {
                            lo_chnl_ids_tx_unchannelized[unchan_cnt] = lo_chnl_ids_tx[i];
                            unchan_cnt++;
                            unchan_mo = TRUE;  
                            
                            /* override the total number of lo channels to be used */
                                                    
                        }                                                                             
                    }
                }

                /* override the total number of lo channels to be used */
                if (unchan_mo)
                {
                    cnt = unchan_cnt; 
                }
            }
            else {
                /* if this is LO, then configure FO1 and ODUKSW:DCS calendars */
                payload_format = UTIL_GLOBAL_ODU_UNCHANNELIZED;
            }
        }                                                
        
        if (prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK) {
            if (((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU 
                 && payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED) || unchan_mo == TRUE)
            {                
                if (PMC_SUCCESS == result)
                {
                    result = coreotn_mpmo_scbs3_all_chnls_activate(digi_handle->coreotn_handle, COREOTN_MPMO_TO_COREOTN);
                }
                
                if (PMC_SUCCESS == result)
                {
                    result = coreotn_mpma_scbs3_all_chnls_activate(digi_handle->coreotn_handle, COREOTN_MPMA_TO_COREOTN);
                } 
            }
        }

        if (prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK) {
            /* configure MUX after FO1:MPMO has been provisioned and activated to
            ** provide valid IDs 
            */ 
            if (PMC_SUCCESS == result)
            {    
                result = coreotn_tx_lo_chnl_offline_activate_all(digi_handle->coreotn_handle,
                                                                 local_ho_odu_chnl_ptr->chnl_id,
                                                                 (coreotn_mux_stage_t)mux_stage);
            }    
        }

        if (PMC_SUCCESS == result && ((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU))
        {
            if (digi_handle->var.prod_app != DIGI_PROD_APP_SYSOTN_CARD)
            {
                otn_server_ptr = digi_otn_server_chnl_get(digi_handle, local_ho_odu_chnl_ptr->chnl_id);
                otn_handle = digi_handle->lineotn_handle;
            }
            else {
                otn_server_ptr = digi_sysotn_server_chnl_get(digi_handle);
                otn_handle = digi_handle->sysotn_handle;
            }

            result = lineotn_fec_act(otn_handle,
                                     otn_server_ptr->dsi_base_chnl,
                                     (lineotn_dsi_type_t)otn_server_ptr->dsi_serdes_type);
        }                                                         

        if (prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK) {
            if (PMC_SUCCESS == result)
            {
                result = coreotn_rx_lo_chnl_offline_activate_all(digi_handle->coreotn_handle,
                                                                 local_ho_odu_chnl_ptr->chnl_id,
                                                                 (coreotn_mux_stage_t)mux_stage);
            }   
        }
             
        /* check if the LO channels in this HO have been provisioned in 
        ** other DCS schedulers 
        */
        if (PMC_SUCCESS == result 
            && (((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU 
                 && payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED) || unchan_mo == TRUE))
        {
            /* swaps pages in COREOTN:ODUKSW. Port 2 of ODUKSW will always be used
            ** as an output port when COREOTN-ODUKSW connection is made. 
            */
            if (PMC_SUCCESS == result)
            {
                result = coreotn_oduksw_dcs_swap_and_update_all(digi_handle->coreotn_handle, UTIL_GLOBAL_ODUK_PORT_COREOTN, NULL, NULL);
            
                /* this is for unchannelized MO only */
                if (unchan_mo)
                {
                    for (i = 0; i < unchan_cnt; i++)
                    {
                        /* gather MO channel pointers coming into COREOTN */                        
                        coreotn_input_pc_ptr_list[i] = (util_global_switch_data_t *)&digi_handle->handle_pool.mo_odu_struct[lo_chnl_ids_tx_unchannelized[i]];
                        coreotn_local_input_sw_ptr_list[i] = (util_global_switch_data_def_t *)coreotn_input_pc_ptr_list[i];
                        coreotn_input_pc_data_ptr_list[i] = &(coreotn_local_input_sw_ptr_list[i]->oduk_data);
                        
                        coreotn_output_pc_ptr_list[i] = (util_global_switch_data_t *)&digi_handle->handle_pool.mo_odu_struct[lo_chnl_ids_tx_unchannelized[i]];                        
                        coreotn_local_output_sw_ptr_list[i] = (util_global_switch_data_def_t *)coreotn_output_pc_ptr_list[i];
                        coreotn_output_pc_data_ptr_list[i] = &(coreotn_local_output_sw_ptr_list[i]->oduk_data);
                        
                        /* find the input channel pointer given the COREOTN output channel pointer */
                        digi_opsa_src_chnl_hndl_for_dest_get(digi_handle,
                                                             coreotn_output_pc_ptr_list[i],
                                                             TRUE,
                                                             &input_pc_ptr_list[i]);
                        if (input_pc_ptr_list[i] != NULL)
                        {                                    
                            local_input_sw_ptr_list[i] = (util_global_switch_data_def_t *)input_pc_ptr_list[i];
                            input_pc_data_ptr_list[i] = &( local_input_sw_ptr_list[i]->oduk_data);                                                              
                        }                            
                    } 
                }
                else if (local_ho_odu_chnl_ptr->odu_level == ODU_STRUCT_LEVEL_MO_ODU
                         && local_ho_odu_chnl_ptr->payload_format != UTIL_GLOBAL_ODU_UNCHANNELIZED)
                {
                    
                    for (i = 0; i < cnt; i++)
                    {
                        /* gather MO channel pointers coming into COREOTN */
                        coreotn_input_pc_ptr_list[i] = (util_global_switch_data_t *)&digi_handle->handle_pool.lo_odu_struct[lo_chnl_ids_rx[i]];
                        coreotn_local_input_sw_ptr_list[i] = (util_global_switch_data_def_t *)coreotn_input_pc_ptr_list[i];
                        coreotn_input_pc_data_ptr_list[i] = &(coreotn_local_input_sw_ptr_list[i]->oduk_data);
                        
                        coreotn_output_pc_ptr_list[i] = (util_global_switch_data_t *)&digi_handle->handle_pool.lo_odu_struct[lo_chnl_ids_tx[i]];                        
                        coreotn_local_output_sw_ptr_list[i] = (util_global_switch_data_def_t *)coreotn_output_pc_ptr_list[i];
                        coreotn_output_pc_data_ptr_list[i] = &(coreotn_local_output_sw_ptr_list[i]->oduk_data);
                        
                        /* find the input channel pointer given the COREOTN output channel pointer */
                        digi_opsa_src_chnl_hndl_for_dest_get(digi_handle,
                                                             coreotn_output_pc_ptr_list[i],
                                                             TRUE,
                                                             &input_pc_ptr_list[i]);
                        
                        if (input_pc_ptr_list[i] != NULL)
                        {                                     
                            local_input_sw_ptr_list[i] = (util_global_switch_data_def_t *)input_pc_ptr_list[i];
                            input_pc_data_ptr_list[i] = &( local_input_sw_ptr_list[i]->oduk_data);            
                        }                                                   
                    } 
                }  
            } 
            
            if (PMC_SUCCESS == result)
            {          
                /* check if ILKN1 port is used */           
                if (digi_handle->var.prod_app != DIGI_PROD_APP_SYSOTN_CARD)
                {          
                    for (i = 0; i < cnt; i++)
                    {   
                        if (NULL != input_pc_data_ptr_list[i] &&
                            input_pc_data_ptr_list[i]->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1)
                        {
                            if (input_pc_data_ptr_list[i]->channel < DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX)
                            {                                                                             
                                chnl_id = input_pc_data_ptr_list[i]->channel+DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX;
                            }
                        
                            if (digi_handle->handle_pool.ilkn_1_chnl[chnl_id].switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1)
                            {
                                output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt] = (util_global_switch_data_t *)&digi_handle->handle_pool.ilkn_1_chnl[chnl_id];
                                local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt] = (util_global_switch_data_def_t *)output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt];
                                output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt] = &(local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt]->oduk_data);

                                /* store the coreotn input channel pointers that map to these output channels */
                                input_to_ilkn_1_pc_ptr_list[ilkn_1_chnl_cnt] = coreotn_input_pc_ptr_list[i];
                                input_to_ilkn_1_pc_data_ptr_list[ilkn_1_chnl_cnt] = coreotn_input_pc_data_ptr_list[i];
                                ilkn_1_chnl_cnt++;

                                if (ilkn_1_activate == FALSE)
                                {
                                    /* swap the page in DCS port 0 and update the offline page */
                                    result = coreotn_oduksw_dcs_swap_and_update_all(digi_handle->coreotn_handle, UTIL_GLOBAL_ODUK_PORT_ILKN1, NULL, NULL);
                                    ilkn_1_activate = TRUE;
                                }
                            }
                        }
                    }
                }
                else {
                    for (i = 0; i < cnt; i++)
                    {              
                        if (NULL != input_pc_data_ptr_list[i] &&
                            (input_pc_data_ptr_list[i]->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1)
                            && (digi_handle->handle_pool.lo_odu_struct[input_pc_data_ptr_list[i]->channel].switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1))
                        {
                            output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt] = (util_global_switch_data_t *)&digi_handle->handle_pool.lo_odu_struct[input_pc_data_ptr_list[i]->channel];
                            local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt] = (util_global_switch_data_def_t *)output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt];
                            output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt] = &(local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt]->oduk_data);

                            /* store the coreotn input channel pointers that map to these output channels */
                            input_to_ilkn_1_pc_ptr_list[ilkn_1_chnl_cnt] = coreotn_input_pc_ptr_list[i];
                            input_to_ilkn_1_pc_data_ptr_list[ilkn_1_chnl_cnt] = coreotn_input_pc_data_ptr_list[i];                          
                            ilkn_1_chnl_cnt++;

                            if (ilkn_1_activate == FALSE)
                            {
                                /* swap the page in DCS port 0 and update the offline page */
                                result = coreotn_oduksw_dcs_swap_and_update_all(digi_handle->coreotn_handle, UTIL_GLOBAL_ODUK_PORT_ILKN1, NULL, NULL);
                                ilkn_1_activate = TRUE;                 
                            } 
                        }
                    }
                } 
            }               
 
            /* check if ILKN2 port is used */    
            if (PMC_SUCCESS == result)
            {
                for (i = 0; i < cnt; i++)
                {   
                    if (NULL != input_pc_data_ptr_list[i] &&
                        input_pc_data_ptr_list[i]->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN2)
                    {  
                        if (input_pc_data_ptr_list[i]->channel < DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX)
                        {                                                                             
                            chnl_id = input_pc_data_ptr_list[i]->channel+DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX;
                        }
                            
                        if (digi_handle->handle_pool.ilkn_2_chnl[chnl_id].switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_ILKN2)
                        {
                            output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][ilkn_2_chnl_cnt] = (util_global_switch_data_t *)&digi_handle->handle_pool.ilkn_2_chnl[chnl_id];
                            local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][ilkn_2_chnl_cnt] = (util_global_switch_data_def_t *)output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][ilkn_2_chnl_cnt];
                            output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][ilkn_2_chnl_cnt] = &(local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][ilkn_2_chnl_cnt]->oduk_data);

                            /* store the coreotn input channel pointers that map to these output channels */
                            input_to_ilkn_2_pc_ptr_list[ilkn_2_chnl_cnt] = coreotn_input_pc_ptr_list[i];
                            input_to_ilkn_2_pc_data_ptr_list[ilkn_2_chnl_cnt] = coreotn_input_pc_data_ptr_list[i]; 
                            ilkn_2_chnl_cnt++;
                        
                            if (ilkn_2_activate == FALSE)
                            {
                                /* swap the page in DCS port 1 and update the offline page */
                                result = coreotn_oduksw_dcs_swap_and_update_all(digi_handle->coreotn_handle, UTIL_GLOBAL_ODUK_PORT_ILKN2, NULL, NULL);
                                ilkn_2_activate = TRUE;
                            } 
                        }
                    }
                }
            } 
           
            /* check if MAPOTN port is used */
            if (PMC_SUCCESS == result)
            {
                for (i = 0; i < cnt; i++)
                { 
                    if (NULL != input_pc_data_ptr_list[i] &&
                        (input_pc_data_ptr_list[i]->port_type == UTIL_GLOBAL_ODUK_PORT_MAPOTN)
                        && (digi_handle->handle_pool.mapper_chnl[input_pc_data_ptr_list[i]->channel].switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_MAPOTN))
                    { 
                        output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][mapotn_chnl_cnt] = (util_global_switch_data_t *)&digi_handle->handle_pool.mapper_chnl[input_pc_data_ptr_list[i]->channel];
                        local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][mapotn_chnl_cnt] = (util_global_switch_data_def_t *)output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][mapotn_chnl_cnt];
                        output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][mapotn_chnl_cnt] = &(local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][mapotn_chnl_cnt]->oduk_data);

                        /* store the coreotn input channel pointers that map to these output channels */
                        input_to_mapotn_pc_ptr_list[mapotn_chnl_cnt] = coreotn_input_pc_ptr_list[i];
                        input_to_mapotn_pc_data_ptr_list[mapotn_chnl_cnt] = coreotn_input_pc_data_ptr_list[i]; 
                        mapotn_chnl_cnt++;

                        if (mapotn_activate == FALSE)
                        {
                            /* swap the page in DCS port 3 and update the offline page */
                            result = coreotn_oduksw_dcs_swap_and_update_all(digi_handle->coreotn_handle, UTIL_GLOBAL_ODUK_PORT_MAPOTN, NULL, NULL);
                            mapotn_activate = TRUE;
                        } 
                    }
                }
            }                                                                               
           
            /* Opposite direction where COREOTN is used as an input port */  
            /* DCS SLV PORT 0 */
            if (ilkn_1_activate == TRUE)
            { 
                for (i = 0; i < ilkn_1_chnl_cnt; i++)
                {
                    if (PMC_SUCCESS == result && output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][i] != NULL)                                                              
                    {                                                                               
                        result = coreotn_oduksw_chnl_type_get(digi_handle->coreotn_handle,                       
                                                              UTIL_GLOBAL_ODUK_PORT_ILKN1,       
                                                              output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][i]->channel,         
                                                              &is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1][i],                   
                                                              &is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1][i],               
                                                              &is_broadcast,                        
                                                              &is_multicast); 
                    }                                                                        
                }

                /* COREOTN TO ILKN1 */
                if (PMC_SUCCESS == result)
                {
                    digi_opsa_oduksw_activate_cfg_all(digi_handle,
                                                      input_to_ilkn_1_pc_ptr_list,
                                                      output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1],
                                                      is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1],
                                                      is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1],
                                                      DIGI_OPSA_CFG_ACTION_ACTIVATE);
                } 


                /* DCS SLV PORT 0 will always be an output port at least once */
                for (i = 0; i < ilkn_1_chnl_cnt; i++)
                {
                    /* input_to_ilkn_1_pc_ptr_list[i] is an array of COREOTN output channels
                    ** that are connected to ILKN1
                    */
                    if (PMC_SUCCESS == result && input_to_ilkn_1_pc_data_ptr_list[i] != NULL)                                                              
                    {                                                                               
                        result = coreotn_oduksw_chnl_type_get(digi_handle->coreotn_handle,                       
                                                              UTIL_GLOBAL_ODUK_PORT_COREOTN,       
                                                              input_to_ilkn_1_pc_data_ptr_list[i]->channel,         
                                                              &is_coreotn_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1][i],                   
                                                              &is_coreotn_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1][i],               
                                                              &is_broadcast,                        
                                                              &is_multicast); 
                    }                                                                        
                }

                /* ILKN1 to COREOTN */
                if (PMC_SUCCESS == result)
                {
                    digi_opsa_oduksw_activate_cfg_all(digi_handle,
                                                      output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1],
                                                      input_to_ilkn_1_pc_ptr_list,
                                                      is_coreotn_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1],
                                                      is_coreotn_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1],
                                                      DIGI_OPSA_CFG_ACTION_ACTIVATE);
                } 

            }

            /* DCS SLV PORT 1 */
            if (ilkn_2_activate == TRUE)
            { 
                for (i = 0; i < ilkn_2_chnl_cnt; i++)
                {
                    if (PMC_SUCCESS == result && output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][i] != NULL)                                                              
                    {                                                                               
                        result = coreotn_oduksw_chnl_type_get(digi_handle->coreotn_handle,                       
                                                              UTIL_GLOBAL_ODUK_PORT_ILKN2,       
                                                              output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][i]->channel,         
                                                              &is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2][i],                   
                                                              &is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2][i],               
                                                              &is_broadcast,                        
                                                              &is_multicast); 
                    }                                                                        
                }   
                

                /* COREOTN TO ILKN2 */
                if (PMC_SUCCESS == result)
                {
                    digi_opsa_oduksw_activate_cfg_all(digi_handle,
                                                      input_to_ilkn_2_pc_ptr_list,
                                                      output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2],
                                                      is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2],
                                                      is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2],
                                                      DIGI_OPSA_CFG_ACTION_ACTIVATE);
                } 


                /* DCS SLV PORT 1 */
                for (i = 0; i < ilkn_2_chnl_cnt; i++)
                {
                    /* input_to_ilkn_2_pc_ptr_list[i] is an array of COREOTN output channels
                    ** that are connected to ILKN2
                    */
                    if (PMC_SUCCESS == result && input_to_ilkn_2_pc_data_ptr_list[i] != NULL)                                                              
                    {                                                                               
                        result = coreotn_oduksw_chnl_type_get(digi_handle->coreotn_handle,                       
                                                              UTIL_GLOBAL_ODUK_PORT_COREOTN,       
                                                              input_to_ilkn_2_pc_data_ptr_list[i]->channel,         
                                                              &is_coreotn_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2][i],                   
                                                              &is_coreotn_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2][i],               
                                                              &is_broadcast,                        
                                                              &is_multicast); 
                    }                                                                        
                }

                /* ILKN2 to COREOTN */
                if (PMC_SUCCESS == result)
                {
                    digi_opsa_oduksw_activate_cfg_all(digi_handle,
                                                      output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2],
                                                      input_to_ilkn_2_pc_ptr_list,
                                                      is_coreotn_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2],
                                                      is_coreotn_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2],
                                                      DIGI_OPSA_CFG_ACTION_ACTIVATE);
                } 
            }

            /* DCS SLV PORT 3 */
            if (mapotn_activate == TRUE)
            { 
                for (i = 0; i < mapotn_chnl_cnt; i++)
                {
                    if (PMC_SUCCESS == result && output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][i] != NULL)                                                              
                    {                                                                               
                        result = coreotn_oduksw_chnl_type_get(digi_handle->coreotn_handle,                       
                                                              UTIL_GLOBAL_ODUK_PORT_MAPOTN,       
                                                              output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][i]->channel,         
                                                              &is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN][i],                   
                                                              &is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN][i],               
                                                              &is_broadcast,                        
                                                              &is_multicast); 
                    }                                                                        
                } 
                 
                /* COREOTN to MAPOTN */  
                if (PMC_SUCCESS == result)
                {
                    digi_opsa_oduksw_activate_cfg_all(digi_handle,
                                                      input_to_mapotn_pc_ptr_list,
                                                      output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN],
                                                      is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN],
                                                      is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN],
                                                      DIGI_OPSA_CFG_ACTION_ACTIVATE);
                } 

                /* DCS SLV PORT 1 */
                for (i = 0; i < mapotn_chnl_cnt; i++)
                {
                    /* input_to_mapotn_pc_data_ptr_list[i] is an array of COREOTN output channels
                    ** that are connected to MAPOTN
                    */
                    if (PMC_SUCCESS == result && input_to_mapotn_pc_data_ptr_list[i] != NULL)                                                              
                    {                                                                               
                        result = coreotn_oduksw_chnl_type_get(digi_handle->coreotn_handle,                       
                                                              UTIL_GLOBAL_ODUK_PORT_COREOTN,       
                                                              input_to_mapotn_pc_data_ptr_list[i]->channel,         
                                                              &is_coreotn_reader_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN][i],                   
                                                              &is_coreotn_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN][i],               
                                                              &is_broadcast,                        
                                                              &is_multicast); 
                    }                                                                        
                }

                /* MAPOTN to COREOTN */
                if (PMC_SUCCESS == result)
                {
                    digi_opsa_oduksw_activate_cfg_all(digi_handle,
                                                      output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN],
                                                      input_to_mapotn_pc_ptr_list,
                                                      is_coreotn_reader_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN],
                                                      is_coreotn_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN],
                                                      DIGI_OPSA_CFG_ACTION_ACTIVATE);
                }  
            }   
            
            /* ODUKSW loopback */ 
            if (ilkn_1_activate == FALSE && ilkn_2_activate == FALSE && mapotn_activate == FALSE)
            {
                for (i = 0; i < cnt && PMC_SUCCESS == result; i++)
                {
                    result = coreotn_oduksw_chnl_type_get(digi_handle->coreotn_handle,                       
                                                          UTIL_GLOBAL_ODUK_PORT_COREOTN,       
                                                          coreotn_output_pc_data_ptr_list[i]->channel,         
                                                          &is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_COREOTN][i],                   
                                                          &is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_COREOTN][i],               
                                                          &is_broadcast,                        
                                                          &is_multicast);                                                                       
                } 

                if (PMC_SUCCESS == result)
                {
                    digi_opsa_oduksw_activate_cfg_all(digi_handle,
                                                      coreotn_input_pc_ptr_list,
                                                      coreotn_output_pc_ptr_list,
                                                      is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_COREOTN],
                                                      is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_COREOTN],
                                                      DIGI_OPSA_CFG_ACTION_ACTIVATE);
                } 
            }
        }
    }                                              

    PMC_RETURN(result);

} /* digi_otn_server_prov_all_lo_prov_end */

/*******************************************************************************
* digi_otn_server_lo_deprov_end
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs bulk de-provision for the two available modes:
*   COREOTN_ODU_CHNL_PROV_ALL or COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK.
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance.
*   *ho_odu_chnl_ctxt_pptr  - pointer to higher order channel containing the
*                             low order framer to be deprovisioned.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_lo_deprov_end(digi_handle_t *digi_handle,
                                               digi_otn_odu_chnl_t **ho_odu_chnl_ctxt_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    coreotn_odu_chnl_prov_mode_t prov_mode = LAST_COREOTN_CHNL_PROV_MODE;


    PMC_ATOMIC_ENTRY(digi_handle);

    /* get ODU channel provisioning mode */
    coreotn_odu_chnl_prov_mode_get(digi_handle->coreotn_handle,
                                   &prov_mode);

    PMC_ASSERT(COREOTN_ODU_CHNL_PROV_ALL == prov_mode || COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK == prov_mode,
               DIGI_ERR_CODE_ASSERT, 0, 0);

    if (COREOTN_ODU_CHNL_PROV_ALL == prov_mode)
    {
        result = digi_otn_server_prov_all_lo_deprov_end(digi_handle,
                                                        ho_odu_chnl_ctxt_pptr);
    }
    else
    {
        /* Provision mode is COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK */
        digi_otn_server_oduksw_prov_deprov_end(digi_handle, FALSE);
    }

    digi_otn_fc_calendar_bulk_update(digi_handle);

    coreotn_oduksw_port_bulk_update_req_init(digi_handle->coreotn_handle);

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_otn_server_lo_deprov_end */

/*******************************************************************************
* digi_otn_server_prov_all_lo_deprov_end
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions the pending LO ODU channel configurations to the 
*   offline page to keep both configuration pages in sync after LO ODU channels
*   have been removed in bulk.\n\n
*
*   This function should be used only when 'digi_otn_odu_chnl_prov_mode_set() is 
*   called with DIGI_OTN_ODU_CHNL_PROV_ALL. This function must be called once
*   per each muxing stage.
* 
*   1) In one stage muxing datapath, this function needs to be called
*      once after the very last LO channel has been deprovisioned 
*      with digi_otn_server_lo_deprov().
*       - '*ho_odu_chnl_ctxt_pptr' should be the pointer to the HO ODU channel.\n\n
*   2) In two stage muxing datapath, this function needs to be called twice.
*      Once after the very last MO channel has been deprovisioned.
*       - '*ho_odu_chnl_ctxt_pptr' should be the pointer to the HO ODU channel.\n\n
*      Once after the very last LO channel has been deprovisioned.
*       - '*ho_odu_chnl_ctxt_pptr' should be the pointer to the MO ODU channel.\n\n
*   
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   *ho_odu_chnl_ctxt_pptr  - pointer to higher order channel containing the
*                             low order framer to be deprovisioned.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_prov_all_lo_deprov_end( digi_handle_t *digi_handle,
                                                digi_otn_odu_chnl_t **ho_odu_chnl_ctxt_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    odu_struct_t *ho_odu_struct_ptr;
    digi_otn_mux_stages_t mux_stage = LAST_DIGI_OTN_MUX_STAGES;
    
    UINT32 num_lo_chnls_tx, num_lo_chnls_rx;
    
    UINT32 i, j;
    BOOL8 ilkn_1_activate = FALSE;
    BOOL8 ilkn_2_activate = FALSE;
    BOOL8 mapotn_activate = FALSE;
    BOOL8 oduksw_loopback = FALSE;
    UINT32 lo_rx_cnt = 0;
    UINT32 lo_tx_cnt = 0;
     
    util_global_switch_data_t* coreotn_input_pc_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_switch_data_t* coreotn_output_pc_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    
    util_global_switch_data_def_t *coreotn_local_output_sw_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_switch_data_def_t *coreotn_local_input_sw_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    
    util_global_switch_data_t* input_pc_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_switch_data_t* output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_NOT_USED][UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    
    util_global_oduk_port_data_t *coreotn_output_pc_data_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];    
    util_global_oduk_port_data_t *coreotn_input_pc_data_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    
    util_global_oduk_port_data_t *input_pc_data_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_oduk_port_data_t *output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_NOT_USED][UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    
    util_global_switch_data_def_t *local_input_sw_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_switch_data_def_t *local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_NOT_USED][UTIL_GLOBAL_MAX_NUM_ODU_CHNL];

    util_global_switch_data_t* input_to_mapotn_pc_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_switch_data_t* input_to_ilkn_1_pc_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_switch_data_t* input_to_ilkn_2_pc_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];

    util_global_oduk_port_data_t *input_to_mapotn_pc_data_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_oduk_port_data_t *input_to_ilkn_1_pc_data_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    util_global_oduk_port_data_t *input_to_ilkn_2_pc_data_ptr_list[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
        
    BOOL is_coreotn_reader_primary[UTIL_GLOBAL_ODUK_PORT_NOT_USED][UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    BOOL is_coreotn_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_NOT_USED][UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    BOOL is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_NOT_USED][UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    BOOL is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_NOT_USED][UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    BOOL is_broadcast, is_multicast;
    UINT32 chnl_id = DIGI_DCI_CHANNEL_UNASSIGNED;   
    UINT32 local_tx_cnt = 0;
    UINT32 local_rx_cnt = 0;
      
    UINT8 *lo_chnl_ids_tx = NULL; 
    UINT8 *lo_chnl_ids_rx = NULL;
    UINT8 *lo_chnl_ids_tx_unchannelized = NULL;
    UINT8 mapotn_broadcast_chnls[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    
    coreotn_chnl_state_t chnl_state;
    util_global_odu_line_payload_t payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
    coreotn_odu_chnl_prov_mode_t prov_mode = LAST_COREOTN_CHNL_PROV_MODE;
    UINT8 ilkn_1_chnl_cnt = 0;
    UINT8 ilkn_2_chnl_cnt = 0;
    UINT8 mapotn_chnl_cnt = 0;
    UINT8 unchan_cnt = 0;
    UINT32 cnt = 0;
    BOOL8 unchan_mo = FALSE;
    util_global_cpb_connect_t *oduk_connect_state_ptr = NULL;
    BOOL8 mapotn_broadcast = FALSE;
    UINT32 mapotn_broadcast_chnl_cnt = 0;
    UINT32 last_dest_mst_port;
    UINT32 last_dest_mst_chnl;
    BOOL8 is_output_mapped = TRUE;
    UINT8 mapped_chnl_cnt = 0;

    PMC_ENTRY(); /* Atomic entry/return is in digi_otn_server_lo_prov_asym */

    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        PMC_RETURN(DIGI_ERR_DEVICE_NOT_INIT);
    }

    /* If bulk (de)prov isn't available, issue a log message and return
     * PMC_SUCCESS
     */
    if (FALSE == pmc_prov_all_prov_mode_available(&digi_handle->base))
    {
        PMC_LOG(PMC_LOG_SEV_MEDIUM, DIGI_ERR_PROV_ALL_NOT_AVAILABLE, 0, 0);
        PMC_RETURN(PMC_SUCCESS);
    }

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != ho_odu_chnl_ctxt_pptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    /* get ODU channel provisioning mode */
    result = coreotn_odu_chnl_prov_mode_get(digi_handle->coreotn_handle, &prov_mode);
                                               
    if (PMC_SUCCESS == result && COREOTN_ODU_CHNL_PROV_ALL != prov_mode && COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK != prov_mode)
    {
        result = DIGI_ERR_INCORRECT_ODU_PROV_MODE;
    }

    if (PMC_SUCCESS == result)
    {
        /* check otn odu struct input handle */
        result = digi_ho_odu_struct_handle_validate(digi_handle, *ho_odu_chnl_ctxt_pptr);
    }

    if (PMC_SUCCESS != result)
    {
        result = digi_mo_odu_struct_handle_validate(digi_handle, *ho_odu_chnl_ctxt_pptr);        
    }

    if (PMC_SUCCESS == result)
    {
        /* initialize pointer lists */
        for (i = 0; i < UTIL_GLOBAL_MAX_NUM_ODU_CHNL; i++)
        {
            coreotn_input_pc_ptr_list[i] = NULL;
            coreotn_output_pc_ptr_list[i] = NULL;
            coreotn_local_input_sw_ptr_list[i] = NULL;
            coreotn_local_output_sw_ptr_list[i] = NULL;
            coreotn_input_pc_data_ptr_list[i] = NULL;
            coreotn_output_pc_data_ptr_list[i] = NULL;
            input_pc_ptr_list[i] = NULL;
            local_input_sw_ptr_list[i] = NULL; 
            input_pc_data_ptr_list[i] = NULL; 
            input_to_mapotn_pc_data_ptr_list[i] = NULL;
            input_to_ilkn_1_pc_data_ptr_list[i] = NULL;
            input_to_ilkn_2_pc_data_ptr_list[i] = NULL;
            input_to_mapotn_pc_ptr_list[i] = NULL;
            input_to_ilkn_1_pc_ptr_list[i] = NULL;
            input_to_ilkn_2_pc_ptr_list[i] = NULL;     
        } 

        for (i = 0; i < UTIL_GLOBAL_ODUK_PORT_NOT_USED; i++)
        {
            for (j = 0; j < UTIL_GLOBAL_MAX_NUM_ODU_CHNL; j++)
            {
                output_pc_ptr_list[i][j] = NULL;
                local_output_sw_ptr_list[i][j] = NULL;
                output_pc_data_ptr_list[i][j] = NULL;
                is_other_reader_primary[i][j] = FALSE;
                is_other_slave_zone_primary[i][j] = FALSE;
                is_coreotn_reader_primary[i][j] = FALSE;
                is_coreotn_slave_zone_primary[i][j] = FALSE;    
            }
        }
    }

    if (PMC_SUCCESS == result)
    {
        /* get the HO framer channel context */
        ho_odu_struct_ptr = (odu_struct_t *)(*ho_odu_chnl_ctxt_pptr);
        PMC_ASSERT(NULL != ho_odu_struct_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);

        odu_chnl_t *local_ho_odu_chnl_ptr = ho_odu_struct_ptr->mem_ptr;
    
        num_lo_chnls_tx = local_ho_odu_chnl_ptr->trib_slot_ctxt.num_sub_container_tx;
        num_lo_chnls_rx = local_ho_odu_chnl_ptr->trib_slot_ctxt.num_sub_container_rx;
        
        lo_chnl_ids_tx = (UINT8*)PMC_CALLOC(sizeof(UINT8)*num_lo_chnls_tx); 
        lo_chnl_ids_rx = (UINT8*)PMC_CALLOC(sizeof(UINT8)*num_lo_chnls_rx);  
        lo_chnl_ids_tx_unchannelized = (UINT8*)PMC_CALLOC(sizeof(UINT8)*num_lo_chnls_rx);    

        
        /* if HO payload is channelized, this is 1 stage muxing 
        ** add LO channel into the active HO channel
        */
        if ((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
        { 
            mux_stage = DIGI_OTN_MUX_STAGES_ONE;
        }
        else if ((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU)
        { 
            if (digi_handle->var.mux_stages != DIGI_OTN_MUX_STAGES_TWO)
            {
                PMC_ASSERT(FALSE, DIGI_ERR_INCORRECT_MAX_MUXING_LEVEL, 0, 0);
            }

            mux_stage = DIGI_OTN_MUX_STAGES_TWO;
        }

        /* check if the LO channels in this HO have been provisioned in 
        ** other DCS schedulers 
        */
        if (PMC_SUCCESS == result)
        {
            /* retreive the LO channel IDs */
            for (i = 0; i < UTIL_GLOBAL_MAX_NUM_TS; i++)
            {
                /* check for all LO channels with COREOTN_CHNL_DEPROV_PENDING state */
                if (local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_tx[i] != DIGI_DCI_CHANNEL_UNASSIGNED)
                {
                    if (mux_stage == DIGI_OTN_MUX_STAGES_ONE)
                    {
                        result = coreotn_mo_chnl_state_get(digi_handle->coreotn_handle,
                                                           local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_tx[i],
                                                           0, 
                                                           &chnl_state);
                    }
                    else {
                        result = coreotn_lo_chnl_state_get(digi_handle->coreotn_handle,
                                                           local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_tx[i],
                                                           0, 
                                                           &chnl_state);
                    }
                                                                                   
                    if (chnl_state == COREOTN_CHNL_DEPROV_PENDING || 
                        (prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK && chnl_state == COREOTN_CHNL_OPERATIONAL))
                    {                     
                        lo_chnl_ids_tx[lo_tx_cnt] = local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_tx[i];
                        lo_tx_cnt++;
                    }                        
                }                    
            }
            
            
            /* find channel IDs that map to COREOTN as its output port of ODUKSW */
            for (i = 0; i < UTIL_GLOBAL_MAX_NUM_TS; i++)
            {
                if (local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_rx[i] != DIGI_DCI_CHANNEL_UNASSIGNED)
                {
                    if (mux_stage == DIGI_OTN_MUX_STAGES_ONE)
                    {
                        result = coreotn_mo_chnl_state_get(digi_handle->coreotn_handle,
                                                           local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_rx[i],
                                                           1, 
                                                           &chnl_state);
                    }
                    else {
                        result = coreotn_lo_chnl_state_get(digi_handle->coreotn_handle,
                                                           local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_rx[i],
                                                           1, 
                                                           &chnl_state);
                    }                                                           

                    if (chnl_state == COREOTN_CHNL_DEPROV_PENDING || 
                        (prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK && chnl_state == COREOTN_CHNL_OPERATIONAL))
                    {                                   
                        lo_chnl_ids_rx[lo_rx_cnt] = local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_rx[i];
                        lo_rx_cnt++;
                    }
                }                    
            }
        }


        if (PMC_SUCCESS == result)
        {
            if ((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
            {
                for (i = 0; i < lo_tx_cnt && PMC_SUCCESS == result; i++)
                { 
                    result = coreotn_mo_chnl_state_get(digi_handle->coreotn_handle,
                                                       lo_chnl_ids_tx[i],
                                                       0, 
                                                       &chnl_state);
                    
                    /* New LO channels being deprovisioned will be in EQUIPPED state at this point */                       
                    if ((chnl_state == COREOTN_CHNL_DEPROV_PENDING || 
                        (prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK && chnl_state == COREOTN_CHNL_OPERATIONAL)) 
                        && PMC_SUCCESS == result)
                    {                                           
                        coreotn_payload_format_get(digi_handle->coreotn_handle,
                                                   UTIL_GLOBAL_LEVEL_MO_ODU,
                                                   0,
                                                   lo_chnl_ids_tx[i],
                                                   &payload_format);

                        if (payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
                        {
                            lo_chnl_ids_tx_unchannelized[unchan_cnt] = lo_chnl_ids_tx[i];
                            unchan_cnt++;
                            unchan_mo = TRUE; 
                        }
                    }
                }

                if (unchan_mo)
                {
                    /* override the total number of lo channels to be used */
                    cnt = unchan_cnt;
                }
            }
            else {
                /* if this is LO, then configure FO1 and ODUKSW:DCS calendars */
                payload_format = UTIL_GLOBAL_ODU_UNCHANNELIZED;
                cnt = lo_tx_cnt;
            }
        }

        if (prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK) {
            if ( (((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU 
                   && payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED) || unchan_mo == TRUE))
            {
                if (PMC_SUCCESS == result)
                {
                    /* remove all channels from MPMO::SCBS3 offline page */
                    result = coreotn_mpmo_scbs3_all_chnls_deactivate(digi_handle->coreotn_handle, COREOTN_MPMO_TO_COREOTN);
                }
                
                if (PMC_SUCCESS == result)
                {
                    result = coreotn_mpma_scbs3_all_chnls_deactivate(digi_handle->coreotn_handle, COREOTN_MPMA_TO_COREOTN);
                }
            }
        }
        PMC_ATOMIC_YIELD(digi_handle,0); 

        if (prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK) {
            if (PMC_SUCCESS == result)
            {
                result = coreotn_tx_lo_chnl_offline_deactivate_all(digi_handle->coreotn_handle,
                                                                   local_ho_odu_chnl_ptr->chnl_id,
                                                                   (coreotn_mux_stage_t)mux_stage);
            }
            PMC_ATOMIC_YIELD(digi_handle,0);                                                
            if (PMC_SUCCESS == result)
            {
                result = coreotn_rx_lo_chnl_offline_deactivate_all(digi_handle->coreotn_handle,
                                                                   local_ho_odu_chnl_ptr->chnl_id,
                                                                   (coreotn_mux_stage_t)mux_stage);
            }
        }
                
        if (PMC_SUCCESS == result 
            && (((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU 
                 && payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED) || unchan_mo == TRUE))
        {
            /* swaps pages in COREOTN:ODUKSW. Port 2 of ODUKSW will always be used
            ** as an output port when COREOTN-ODUKSW connection is made. 
            */
            if (PMC_SUCCESS == result)
            {            
                if (unchan_mo)
                {
                    for (i = 0; i < unchan_cnt; i++)
                    {
                        /* gather MO channel pointers coming into COREOTN */                        
                        coreotn_input_pc_ptr_list[i] = (util_global_switch_data_t *)&digi_handle->handle_pool.mo_odu_struct[lo_chnl_ids_tx_unchannelized[i]];
                        coreotn_local_input_sw_ptr_list[i] = (util_global_switch_data_def_t *)coreotn_input_pc_ptr_list[i];
                        coreotn_input_pc_data_ptr_list[i] = &(coreotn_local_input_sw_ptr_list[i]->oduk_data);
                    }
                    
                    for (i = 0; i < unchan_cnt; i++)    
                    {
                        coreotn_output_pc_ptr_list[i] = (util_global_switch_data_t *)&digi_handle->handle_pool.mo_odu_struct[lo_chnl_ids_tx_unchannelized[i]];                        
                        coreotn_local_output_sw_ptr_list[i] = (util_global_switch_data_def_t *)coreotn_output_pc_ptr_list[i];
                        coreotn_output_pc_data_ptr_list[i] = &(coreotn_local_output_sw_ptr_list[i]->oduk_data);
                        
                        /* find the input channel pointer given the COREOTN output channel pointer */
                        digi_opsa_src_chnl_hndl_for_dest_get(digi_handle,
                                                             coreotn_output_pc_ptr_list[i],
                                                             TRUE,
                                                             &input_pc_ptr_list[i]);

                        if (input_pc_ptr_list[i] != NULL)
                        {                                    
                            local_input_sw_ptr_list[i] = (util_global_switch_data_def_t *)input_pc_ptr_list[i];
                            input_pc_data_ptr_list[i] = &(local_input_sw_ptr_list[i]->oduk_data); 
                            mapped_chnl_cnt++;                                                                                       
                        }   
                        coreotn_oduksw_connect_data_state_get(digi_handle->coreotn_handle,
                                                              &oduk_connect_state_ptr);


                        UINT32 dest_port = oduk_connect_state_ptr->chnl[UTIL_GLOBAL_ODUK_PORT_COREOTN][lo_chnl_ids_tx_unchannelized[i]].slv.dest_mst_port;
                        UINT32 dest_chnl = oduk_connect_state_ptr->chnl[UTIL_GLOBAL_ODUK_PORT_COREOTN][lo_chnl_ids_tx_unchannelized[i]].slv.dest_mst_chnl;

                        if (CPB_INDEX_LAST != dest_port && CPB_INDEX_LAST != dest_chnl)
                        {
                            /* is broadcast */
                            if (TRUE == oduk_connect_state_ptr->chnl[UTIL_GLOBAL_ODUK_PORT_COREOTN][lo_chnl_ids_tx_unchannelized[i]].slv.is_broadcast
                                || TRUE == oduk_connect_state_ptr->chnl[UTIL_GLOBAL_ODUK_PORT_COREOTN][lo_chnl_ids_tx_unchannelized[i]].slv.is_multicast)
                            {
                                UINT32 next_dest_mst_port = oduk_connect_state_ptr->chnl[dest_port][dest_chnl].mst.next_dest_mst_port;
                                UINT32 next_dest_mst_chnl = oduk_connect_state_ptr->chnl[dest_port][dest_chnl].mst.next_dest_mst_chnl;

                                while (next_dest_mst_port != CPB_INDEX_LAST)
                                {
                                    if (next_dest_mst_port == UTIL_GLOBAL_ODUK_PORT_MAPOTN)
                                    {
                                        mapotn_broadcast = TRUE;
                                        mapotn_broadcast_chnls[mapotn_broadcast_chnl_cnt] = next_dest_mst_chnl;
                                        mapotn_broadcast_chnl_cnt++;
                                    }
                                    
                                    last_dest_mst_port = next_dest_mst_port;
                                    last_dest_mst_chnl = next_dest_mst_chnl;

                                    next_dest_mst_port = oduk_connect_state_ptr->chnl[last_dest_mst_port][last_dest_mst_chnl].mst.next_dest_mst_port;
                                    next_dest_mst_chnl = oduk_connect_state_ptr->chnl[last_dest_mst_port][last_dest_mst_chnl].mst.next_dest_mst_chnl;
                                }                  
                            }
                        } 
                        else {
                            is_output_mapped = FALSE;                      
                        }
                    }
                    
                }
                else if (local_ho_odu_chnl_ptr->odu_level == ODU_STRUCT_LEVEL_MO_ODU
                         && local_ho_odu_chnl_ptr->payload_format != UTIL_GLOBAL_ODU_UNCHANNELIZED)
                {
                    
                    for (i = 0; i < lo_rx_cnt; i++)
                    {
                        /* gather MO channel pointers coming into COREOTN */
                        coreotn_input_pc_ptr_list[i] = (util_global_switch_data_t *)&digi_handle->handle_pool.lo_odu_struct[lo_chnl_ids_rx[i]];
                        coreotn_local_input_sw_ptr_list[i] = (util_global_switch_data_def_t *)coreotn_input_pc_ptr_list[i];
                        coreotn_input_pc_data_ptr_list[i] = &(coreotn_local_input_sw_ptr_list[i]->oduk_data);
                    }
                    
                    for (i = 0; i < lo_tx_cnt; i++)   
                    {
                        coreotn_output_pc_ptr_list[i] = (util_global_switch_data_t *)&digi_handle->handle_pool.lo_odu_struct[lo_chnl_ids_tx[i]];                        
                        coreotn_local_output_sw_ptr_list[i] = (util_global_switch_data_def_t *)coreotn_output_pc_ptr_list[i];
                        coreotn_output_pc_data_ptr_list[i] = &(coreotn_local_output_sw_ptr_list[i]->oduk_data);

                        /* find the input channel pointer given the COREOTN output channel pointer */
                        digi_opsa_src_chnl_hndl_for_dest_get(digi_handle,
                                                             coreotn_output_pc_ptr_list[i],
                                                             TRUE,
                                                             &input_pc_ptr_list[i]);
                        
                        if (input_pc_ptr_list[i] != NULL)
                        {                                     
                            local_input_sw_ptr_list[i] = (util_global_switch_data_def_t *)input_pc_ptr_list[i];
                            input_pc_data_ptr_list[i] = &( local_input_sw_ptr_list[i]->oduk_data); 
                            mapped_chnl_cnt++;  
                        }  
                        
                        coreotn_oduksw_connect_data_state_get(digi_handle->coreotn_handle,
                                                              &oduk_connect_state_ptr);



                        UINT32 dest_port = oduk_connect_state_ptr->chnl[UTIL_GLOBAL_ODUK_PORT_COREOTN][lo_chnl_ids_tx[i]].slv.dest_mst_port;
                        UINT32 dest_chnl = oduk_connect_state_ptr->chnl[UTIL_GLOBAL_ODUK_PORT_COREOTN][lo_chnl_ids_tx[i]].slv.dest_mst_chnl;

                        if (CPB_INDEX_LAST != dest_port && CPB_INDEX_LAST != dest_chnl)
                        {
                            /* is broadcast */
                            if (TRUE == oduk_connect_state_ptr->chnl[UTIL_GLOBAL_ODUK_PORT_COREOTN][lo_chnl_ids_tx[i]].slv.is_broadcast
                                || TRUE == oduk_connect_state_ptr->chnl[UTIL_GLOBAL_ODUK_PORT_COREOTN][lo_chnl_ids_tx[i]].slv.is_multicast)
                            {
                                UINT32 next_dest_mst_port = oduk_connect_state_ptr->chnl[dest_port][dest_chnl].mst.next_dest_mst_port;
                                UINT32 next_dest_mst_chnl = oduk_connect_state_ptr->chnl[dest_port][dest_chnl].mst.next_dest_mst_chnl;

                                while (next_dest_mst_port != CPB_INDEX_LAST)
                                {
                                    if (next_dest_mst_port == UTIL_GLOBAL_ODUK_PORT_MAPOTN)
                                    {
                                        mapotn_broadcast = TRUE;
                                        mapotn_broadcast_chnls[mapotn_broadcast_chnl_cnt] = next_dest_mst_chnl;
                                        mapotn_broadcast_chnl_cnt++;
                                    }

                                    last_dest_mst_port = next_dest_mst_port;
                                    last_dest_mst_chnl = next_dest_mst_chnl;
                                        
                                    next_dest_mst_port = oduk_connect_state_ptr->chnl[last_dest_mst_port][last_dest_mst_chnl].mst.next_dest_mst_port;
                                    next_dest_mst_chnl = oduk_connect_state_ptr->chnl[last_dest_mst_port][last_dest_mst_chnl].mst.next_dest_mst_chnl;
                                }                   
                            }
                        }
                        else {
                            is_output_mapped = FALSE;
                        }
                    } 
                }
                else {
                    /* ODUKSW loopback */
                    for (i = 0; i < lo_tx_cnt; i++)
                    {
                        /* gather MO channel pointers coming into COREOTN */                        
                        coreotn_input_pc_ptr_list[i] = (util_global_switch_data_t *)&digi_handle->handle_pool.mo_odu_struct[lo_chnl_ids_tx[i]];
                        coreotn_local_input_sw_ptr_list[i] = (util_global_switch_data_def_t *)coreotn_input_pc_ptr_list[i];
                        coreotn_input_pc_data_ptr_list[i] = &(coreotn_local_input_sw_ptr_list[i]->oduk_data);
                    }
                    
                    for (i = 0; i < lo_rx_cnt; i++)    
                    {
                        coreotn_output_pc_ptr_list[i] = (util_global_switch_data_t *)&digi_handle->handle_pool.mo_odu_struct[lo_chnl_ids_rx[i]];                        
                        coreotn_local_output_sw_ptr_list[i] = (util_global_switch_data_def_t *)coreotn_output_pc_ptr_list[i];
                        coreotn_output_pc_data_ptr_list[i] = &(coreotn_local_output_sw_ptr_list[i]->oduk_data);                        
                    }  

                    oduksw_loopback = TRUE;
                }

                result = coreotn_oduksw_dcs_swap_and_update_all(digi_handle->coreotn_handle, UTIL_GLOBAL_ODUK_PORT_COREOTN, NULL, NULL);
            } 
          
            /* perform the following deprovisioning operations at ODUKSW only if there are output channels mapped at ODUKSW */

            if (is_output_mapped == TRUE || mapped_chnl_cnt != 0)
            {
                /* ILKN port 1 */
                if (PMC_SUCCESS == result)
                {          
                    /* check if ILKN1 port is used */           
                    if (digi_handle->var.prod_app != DIGI_PROD_APP_SYSOTN_CARD)
                    {          
                        for (i = 0; i < cnt; i++)
                        {   
                            if (NULL != input_pc_data_ptr_list[i] &&
                                input_pc_data_ptr_list[i]->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1)
                            {                       
                                if (input_pc_data_ptr_list[i]->channel < DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX)
                                {                                                                             
                                    chnl_id = input_pc_data_ptr_list[i]->channel+DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX;
                                }
                                
                                if (digi_handle->handle_pool.ilkn_1_chnl[chnl_id].switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1)
                                {
                                    output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt] = (util_global_switch_data_t *)&digi_handle->handle_pool.ilkn_1_chnl[chnl_id];
                                    local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt] = (util_global_switch_data_def_t *)output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt];
                                    output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt] = &(local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt]->oduk_data);
                                    
                                    /* store the coreotn input channel pointers that map to these output channels */
                                    input_to_ilkn_1_pc_ptr_list[ilkn_1_chnl_cnt] = coreotn_input_pc_ptr_list[i];
                                    input_to_ilkn_1_pc_data_ptr_list[ilkn_1_chnl_cnt] = coreotn_input_pc_data_ptr_list[i];
                                    ilkn_1_chnl_cnt++;

                                    if (ilkn_1_activate == FALSE)
                                    {
                                        /* clean up DCS calendar on ILKN1 port */
                                        result = coreotn_oduksw_dcs_swap_and_update_all(digi_handle->coreotn_handle, UTIL_GLOBAL_ODUK_PORT_ILKN1, NULL, NULL);
                                        ilkn_1_activate = TRUE;
                                    } 
                                }
                            }
                        }
                    }
                    else {
                        for (i = 0; i < cnt; i++)
                        {              
                            if (NULL != input_pc_data_ptr_list[i] &&
                                input_pc_data_ptr_list[i]->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1)
                            { 
                                if (digi_handle->handle_pool.lo_odu_struct[input_pc_data_ptr_list[i]->channel].switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1)
                                {
                                    output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt] = (util_global_switch_data_t *)&digi_handle->handle_pool.lo_odu_struct[input_pc_data_ptr_list[i]->channel];
                                    local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt] = (util_global_switch_data_def_t *)output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt];
                                    output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt] = &(local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][ilkn_1_chnl_cnt]->oduk_data);
                                    
                                    /* store the coreotn input channel pointers that map to these output channels */
                                    input_to_ilkn_1_pc_ptr_list[ilkn_1_chnl_cnt] = coreotn_input_pc_ptr_list[i];
                                    input_to_ilkn_1_pc_data_ptr_list[ilkn_1_chnl_cnt] = coreotn_input_pc_data_ptr_list[i];
                                    ilkn_1_chnl_cnt++;

                                    if (ilkn_1_activate == FALSE)
                                    {
                                        /* clean up DCS calendar on ILKN1 port */
                                        result = coreotn_oduksw_dcs_swap_and_update_all(digi_handle->coreotn_handle, UTIL_GLOBAL_ODUK_PORT_ILKN1, NULL, NULL);
                                        ilkn_1_activate = TRUE;
                                    }  
                                }
                            }
                        }
                    } 
                }               
     
                /* check if ILKN2 port is used */    
                if (PMC_SUCCESS == result)
                {
                    for (i = 0; i < cnt; i++)
                    {    
                        if (NULL != input_pc_data_ptr_list[i] &&
                            input_pc_data_ptr_list[i]->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN2)
                        { 
                            if (input_pc_data_ptr_list[i]->channel < DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX)
                            {                                                                             
                                chnl_id = input_pc_data_ptr_list[i]->channel+DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX;
                            }
                                
                            if (digi_handle->handle_pool.ilkn_2_chnl[chnl_id].switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_ILKN2)
                            {
                                output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][ilkn_2_chnl_cnt] = (util_global_switch_data_t *)&digi_handle->handle_pool.ilkn_2_chnl[chnl_id];
                                local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][ilkn_2_chnl_cnt] = (util_global_switch_data_def_t *)output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][ilkn_2_chnl_cnt];
                                output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][ilkn_2_chnl_cnt] = &(local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][ilkn_2_chnl_cnt]->oduk_data);
                                
                                /* store the coreotn input channel pointers that map to these output channels */
                                input_to_ilkn_2_pc_ptr_list[ilkn_2_chnl_cnt] = coreotn_input_pc_ptr_list[i];
                                input_to_ilkn_2_pc_data_ptr_list[ilkn_2_chnl_cnt] = coreotn_input_pc_data_ptr_list[i]; 
                                ilkn_2_chnl_cnt++;  
                            
                                if (ilkn_2_activate == FALSE)
                                {
                                    /* clean up DCS calendar on ILKN2 port */
                                    result = coreotn_oduksw_dcs_swap_and_update_all(digi_handle->coreotn_handle, UTIL_GLOBAL_ODUK_PORT_ILKN2, NULL, NULL);
                                    ilkn_2_activate = TRUE;
                                } 
                            }
                        }
                    }
                } 
               
                /* check if MAPOTN port is used */
                if (PMC_SUCCESS == result)
                {
                    for (i = 0; i < cnt; i++)
                    { 
                        if (NULL != input_pc_data_ptr_list[i] &&
                            (input_pc_data_ptr_list[i]->port_type == UTIL_GLOBAL_ODUK_PORT_MAPOTN)
                            && (digi_handle->handle_pool.mapper_chnl[input_pc_data_ptr_list[i]->channel].switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_MAPOTN))
                        { 
                            output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][mapotn_chnl_cnt] = (util_global_switch_data_t *)&digi_handle->handle_pool.mapper_chnl[input_pc_data_ptr_list[i]->channel];
                            local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][mapotn_chnl_cnt] = (util_global_switch_data_def_t *)output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][mapotn_chnl_cnt];
                            output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][mapotn_chnl_cnt] = &(local_output_sw_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][mapotn_chnl_cnt]->oduk_data);
                          
                            /* store the coreotn input channel pointers that map to these output channels */
                            input_to_mapotn_pc_ptr_list[mapotn_chnl_cnt] = coreotn_input_pc_ptr_list[i];
                            input_to_mapotn_pc_data_ptr_list[mapotn_chnl_cnt] = coreotn_input_pc_data_ptr_list[i]; 
                            mapotn_chnl_cnt++;

                            if (mapotn_activate == FALSE)
                            {
                                /* clean up DCS calendar on MAPOTN port */
                                result = coreotn_oduksw_dcs_swap_and_update_all(digi_handle->coreotn_handle, UTIL_GLOBAL_ODUK_PORT_MAPOTN, NULL, NULL);
                                mapotn_activate = TRUE;
                            } 
                        }  
                    }       
                }  

                /* DCS SLV PORT 0 */
                if (ilkn_1_activate == TRUE)
                {         
                    /* Opposite direction where COREOTN is used as an input port */          
                    for (i = 0; i < ilkn_1_chnl_cnt && PMC_SUCCESS == result; i++)
                    {
                        result = coreotn_oduksw_chnl_type_get(digi_handle->coreotn_handle,                       
                                                              UTIL_GLOBAL_ODUK_PORT_ILKN1,       
                                                              output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][i]->channel,         
                                                              &is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1][i],                   
                                                              &is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1][i],               
                                                              &is_broadcast,                        
                                                              &is_multicast);                                                                       
                    }   

                    /* COREOTN to ILKN1 */
                    if (PMC_SUCCESS == result)
                    {
                        digi_opsa_oduksw_activate_cfg_all(digi_handle,
                                                          input_to_ilkn_1_pc_ptr_list,
                                                          output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1],
                                                          is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1],
                                                          is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1],
                                                          DIGI_OPSA_CFG_ACTION_DEACTIVATE);
                    }

                    for (i = 0; i < ilkn_1_chnl_cnt && PMC_SUCCESS == result; i++) 
                    {
                        if (NULL != input_to_ilkn_1_pc_data_ptr_list[i])
                        {
                            result = coreotn_oduksw_fifo_var_data_and_chnl_state_reset( digi_handle->coreotn_handle,
                                                                                        UTIL_GLOBAL_ODUK_PORT_COREOTN,
                                                                                        input_to_ilkn_1_pc_data_ptr_list[i]->channel,
                                                                                        UTIL_GLOBAL_ODUK_PORT_ILKN1,
                                                                                        output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][i]->channel );                                                                            
                        } 
                    }

                    /* DCS SLV PORT 2 will always be an output port at least once */
                    for (i = 0; i < ilkn_1_chnl_cnt && PMC_SUCCESS == result; i++)
                    {
                        result = coreotn_oduksw_chnl_type_get(digi_handle->coreotn_handle,                       
                                                              UTIL_GLOBAL_ODUK_PORT_COREOTN,       
                                                              input_to_ilkn_1_pc_data_ptr_list[i]->channel,         
                                                              &is_coreotn_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1][i],                   
                                                              &is_coreotn_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1][i],               
                                                              &is_broadcast,                        
                                                              &is_multicast); 
                                                                           
                    } 

                    /* ILKN1 to COREOTN */
                    /* perform OPSA procedure here for all channels on DCS SLV port 2  */       
                    if (PMC_SUCCESS == result)
                    {
                        digi_opsa_oduksw_activate_cfg_all(digi_handle,
                                                          output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1],
                                                          input_to_ilkn_1_pc_ptr_list,
                                                          is_coreotn_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1],
                                                          is_coreotn_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN1],
                                                          DIGI_OPSA_CFG_ACTION_DEACTIVATE);
                    } 

                    /* clean up SW context in CPB */
                    for (i = 0; i < ilkn_1_chnl_cnt && PMC_SUCCESS == result; i++)
                    {
                        result = coreotn_oduksw_fifo_var_data_and_chnl_state_reset( digi_handle->coreotn_handle,
                                                                                    UTIL_GLOBAL_ODUK_PORT_ILKN1,
                                                                                    output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][i]->channel,
                                                                                    UTIL_GLOBAL_ODUK_PORT_COREOTN,
                                                                                    input_to_ilkn_1_pc_data_ptr_list[i]->channel );


                        /* reset ILKN1 channel state and port */
                        if (PMC_SUCCESS == result)
                        {
                            digi_ilkn_chnl_state_reset(digi_handle, output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][i]->channel, TRUE);
                        }
                    }

                    if (digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
                    {
                        BOOL8 prov_state = FALSE;
                        for (i = 0; i < ilkn_1_chnl_cnt && PMC_SUCCESS == result; i++)
                        {
                            /* check if digi_otn_server_ho_deprov() has been called prior to deprov_end()
                            ** if digi_otn_server_ho_deprov() has already been called, then it is safe to
                            ** release the pointer for the lo_odu_struct on LINE side HO
                            */                           
                            prov_state = coreotn_sysapp_line_chnl_prov_get(digi_handle->coreotn_handle,
                                                                           output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][i]->channel,
                                                                           UTIL_GLOBAL_CHNL_START);
                            if (TRUE == prov_state)
                            {
                                digi_chnl_ptr_initialize((util_global_switch_data_def_t*)&digi_handle->handle_pool.lo_odu_struct[output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN1][i]->channel]);
                            }
                        }
                    }
                }

                /* DCS SLV PORT 1 */
                if (ilkn_2_activate == TRUE)
                {     
                    for (i = 0; i < ilkn_2_chnl_cnt && PMC_SUCCESS == result; i++)
                    {
                        result = coreotn_oduksw_chnl_type_get(digi_handle->coreotn_handle,                       
                                                              UTIL_GLOBAL_ODUK_PORT_ILKN2,       
                                                              output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][i]->channel,         
                                                              &is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2][i],                   
                                                              &is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2][i],               
                                                              &is_broadcast,                        
                                                              &is_multicast);
                    } 

                    /* COREOTN to ILKN2 */
                    if (PMC_SUCCESS == result)
                    {
                        digi_opsa_oduksw_activate_cfg_all(digi_handle,
                                                          input_to_ilkn_2_pc_ptr_list,
                                                          output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2],
                                                          is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2],
                                                          is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2],
                                                          DIGI_OPSA_CFG_ACTION_DEACTIVATE);
                    }

                    for (i = 0; i < ilkn_2_chnl_cnt && PMC_SUCCESS == result; i++) 
                    {
                        if (NULL != input_to_ilkn_2_pc_data_ptr_list[i])
                        {
                            result = coreotn_oduksw_fifo_var_data_and_chnl_state_reset( digi_handle->coreotn_handle,
                                                                                        UTIL_GLOBAL_ODUK_PORT_COREOTN,
                                                                                        input_to_ilkn_2_pc_data_ptr_list[i]->channel,
                                                                                        UTIL_GLOBAL_ODUK_PORT_ILKN2,
                                                                                        output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][i]->channel );
                        }
                    } 

                    /* ILKN2 to COREOTN */
                    for (i = 0; i < ilkn_2_chnl_cnt && PMC_SUCCESS == result; i++)
                    {
                        result = coreotn_oduksw_chnl_type_get(digi_handle->coreotn_handle,                       
                                                              UTIL_GLOBAL_ODUK_PORT_COREOTN,       
                                                              input_to_ilkn_2_pc_data_ptr_list[i]->channel,         
                                                              &is_coreotn_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2][i],                   
                                                              &is_coreotn_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2][i],               
                                                              &is_broadcast,                        
                                                              &is_multicast); 
                    } 

                    /* perform OPSA procedure here  */       
                    if (PMC_SUCCESS == result)
                    {
                        digi_opsa_oduksw_activate_cfg_all(digi_handle,
                                                          output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2],
                                                          input_to_ilkn_2_pc_ptr_list,
                                                          is_coreotn_reader_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2],
                                                          is_coreotn_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_ILKN2],
                                                          DIGI_OPSA_CFG_ACTION_DEACTIVATE);
                    } 

                    /* clean up SW context in CPB */
                    for (i = 0; i < ilkn_2_chnl_cnt && PMC_SUCCESS == result; i++)
                    {
                        result = coreotn_oduksw_fifo_var_data_and_chnl_state_reset( digi_handle->coreotn_handle,
                                                                                    UTIL_GLOBAL_ODUK_PORT_ILKN2,
                                                                                    output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][i]->channel,
                                                                                    UTIL_GLOBAL_ODUK_PORT_COREOTN,
                                                                                    input_to_ilkn_2_pc_data_ptr_list[i]->channel );

                        /* reset ILKN2 channel state and port */
                        if (PMC_SUCCESS == result)
                        {
                            digi_ilkn_chnl_state_reset(digi_handle, output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_ILKN2][i]->channel, FALSE);
                        }
                    }
                }

                /* DCS SLV PORT 3 */
                if (mapotn_activate == TRUE)
                {
                    for (i = 0; i < mapotn_chnl_cnt && PMC_SUCCESS == result; i++)
                    {
                        result = coreotn_oduksw_chnl_type_get(digi_handle->coreotn_handle,                       
                                                              UTIL_GLOBAL_ODUK_PORT_MAPOTN,       
                                                              output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][i]->channel,         
                                                              &is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN][i],                   
                                                              &is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN][i],               
                                                              &is_broadcast,                        
                                                              &is_multicast);                                                                       
                    }  

                    /* COREOTN to MAPOTN */
                    if (PMC_SUCCESS == result)
                    {
                        digi_opsa_oduksw_activate_cfg_all(digi_handle,
                                                          input_to_mapotn_pc_ptr_list,
                                                          output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN],
                                                          is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN],
                                                          is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN],
                                                          DIGI_OPSA_CFG_ACTION_DEACTIVATE);
                    }

                    for (i = 0; i < mapotn_chnl_cnt && PMC_SUCCESS == result; i++) 
                    {
                        if (NULL != input_to_mapotn_pc_data_ptr_list[i])
                        {
                            result = coreotn_oduksw_fifo_var_data_and_chnl_state_reset( digi_handle->coreotn_handle,
                                                                                        UTIL_GLOBAL_ODUK_PORT_COREOTN,
                                                                                        input_to_mapotn_pc_data_ptr_list[i]->channel,
                                                                                        UTIL_GLOBAL_ODUK_PORT_MAPOTN,
                                                                                        output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][i]->channel );
                        }
                    }

                    /* MAPOTN to COREOTN */
                    for (i = 0; i < mapotn_chnl_cnt && PMC_SUCCESS == result; i++)
                    {
                        result = coreotn_oduksw_chnl_type_get(digi_handle->coreotn_handle,                       
                                                              UTIL_GLOBAL_ODUK_PORT_COREOTN,       
                                                              input_to_mapotn_pc_data_ptr_list[i]->channel,         
                                                              &is_coreotn_reader_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN][i],                   
                                                              &is_coreotn_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN][i],               
                                                              &is_broadcast,                        
                                                              &is_multicast); 
                    } 

                    /* perform OPSA procedure here  */       
                    if (PMC_SUCCESS == result)
                    {
                        digi_opsa_oduksw_activate_cfg_all(digi_handle,
                                                          output_pc_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN],
                                                          input_to_mapotn_pc_ptr_list,
                                                          is_coreotn_reader_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN],
                                                          is_coreotn_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_MAPOTN],
                                                          DIGI_OPSA_CFG_ACTION_DEACTIVATE);
                    }

                    /* clean up SW context in CPB */
                    for (i = 0; i < mapotn_chnl_cnt && PMC_SUCCESS == result; i++)
                    {
                        result = coreotn_oduksw_fifo_var_data_and_chnl_state_reset( digi_handle->coreotn_handle,
                                                                                    UTIL_GLOBAL_ODUK_PORT_MAPOTN,
                                                                                    output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][i]->channel,
                                                                                    UTIL_GLOBAL_ODUK_PORT_COREOTN,
                                                                                    input_to_mapotn_pc_data_ptr_list[i]->channel );
                    }

                    /* check if MAPOTN channel handle pointer has already been released by digi_otn_mapper_deprov */
                    for (i = 0; i < mapotn_chnl_cnt && PMC_SUCCESS == result; i++) 
                    { 
                        if ((digi_handle->handle_pool.mapper_chnl[output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][i]->channel]).odu_data == LAST_DIGI_ODUK) 
                        {
                            digi_chnl_ptr_initialize((util_global_switch_data_def_t*)&digi_handle->handle_pool.mapper_chnl[output_pc_data_ptr_list[UTIL_GLOBAL_ODUK_PORT_MAPOTN][i]->channel]);
                        }
                    }
                }

                if (mapotn_broadcast == TRUE)
                {
                    /* clean up DCS calendar on MAPOTN port */
                    if (mapotn_activate == FALSE)
                    {
                        result = coreotn_oduksw_dcs_swap_and_update_all(digi_handle->coreotn_handle, UTIL_GLOBAL_ODUK_PORT_MAPOTN, NULL, NULL);
                    }

                    for (i = 0; i < mapotn_broadcast_chnl_cnt; i++)
                    {
                        if (digi_handle->handle_pool.mapper_chnl[mapotn_broadcast_chnls[i]].odu_data == LAST_DIGI_ODUK) 
                        {
                            digi_chnl_ptr_initialize((util_global_switch_data_def_t*)&digi_handle->handle_pool.mapper_chnl[mapotn_broadcast_chnls[i]]);
                        }
                    }

                }

                /* ODUKSW loopback */
                if (ilkn_1_activate == FALSE && ilkn_2_activate == FALSE && mapotn_activate == FALSE)
                {
                    for (i = 0; i < lo_tx_cnt && PMC_SUCCESS == result; i++)
                    {
                        result = coreotn_oduksw_chnl_type_get(digi_handle->coreotn_handle,                       
                                                              UTIL_GLOBAL_ODUK_PORT_COREOTN,       
                                                              coreotn_output_pc_data_ptr_list[i]->channel,         
                                                              &is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_COREOTN][i],                   
                                                              &is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_COREOTN][i],               
                                                              &is_broadcast,                        
                                                              &is_multicast);                                                                       
                    } 

                    /* COREOTN to MAPOTN */
                    if (PMC_SUCCESS == result)
                    {
                        digi_opsa_oduksw_activate_cfg_all(digi_handle,
                                                          coreotn_input_pc_ptr_list,
                                                          coreotn_output_pc_ptr_list,
                                                          is_other_reader_primary[UTIL_GLOBAL_ODUK_PORT_COREOTN],
                                                          is_other_slave_zone_primary[UTIL_GLOBAL_ODUK_PORT_COREOTN],
                                                          DIGI_OPSA_CFG_ACTION_DEACTIVATE);
                    }

                    for (i = 0; i < lo_tx_cnt && PMC_SUCCESS == result; i++) 
                    {
                        if (NULL != coreotn_output_pc_data_ptr_list[i])
                        {
                            result = coreotn_oduksw_fifo_var_data_and_chnl_state_reset( digi_handle->coreotn_handle,
                                                                                        UTIL_GLOBAL_ODUK_PORT_COREOTN,
                                                                                        coreotn_input_pc_data_ptr_list[i]->channel,
                                                                                        UTIL_GLOBAL_ODUK_PORT_COREOTN,
                                                                                        coreotn_output_pc_data_ptr_list[i]->channel );
                        }
                    } 
                }
            }
        }

        /* clean COREOTN channel state */
        if (mux_stage == DIGI_OTN_MUX_STAGES_ONE)
        {
            /* For SNCP, just skip this part to leave the channels state unchanged */
            if (prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK) {
                for (i = 0; i < lo_tx_cnt && PMC_SUCCESS == result; i++)
                {
                    coreotn_mo_chnl_state_set(digi_handle->coreotn_handle,
                                              lo_chnl_ids_tx[i], 0,
                                              COREOTN_CHNL_START);
                }
                
                for (i = 0; i < lo_rx_cnt && PMC_SUCCESS == result; i++)
                {                                       
                    coreotn_mo_chnl_state_set(digi_handle->coreotn_handle,
                                              lo_chnl_ids_rx[i], 1,
                                              COREOTN_CHNL_START);                                                            
                }  
                
                /* initialize the LO channel state for unchannelized MO in 2 stage muxing */
                for (i = 0; i < unchan_cnt && PMC_SUCCESS == result; i++)
                {              
                    coreotn_lo_chnl_state_set(digi_handle->coreotn_handle,
                                              lo_chnl_ids_tx_unchannelized[i], 0,
                                              COREOTN_CHNL_START);
                }
                
                for (i = 0; i < unchan_cnt && PMC_SUCCESS == result; i++)
                {                              
                    coreotn_lo_chnl_state_set(digi_handle->coreotn_handle,
                                              lo_chnl_ids_tx_unchannelized[i], 1,
                                              COREOTN_CHNL_START);                                          
                }
            }
        }
        else {
            for (i = 0; i < lo_tx_cnt && PMC_SUCCESS == result; i++)
            {               
                coreotn_lo_chnl_state_set(digi_handle->coreotn_handle,
                                          lo_chnl_ids_tx[i], 0,
                                          COREOTN_CHNL_START);
            }
            
            for (i = 0; i < lo_rx_cnt && PMC_SUCCESS == result; i++)
            {                              
                coreotn_lo_chnl_state_set(digi_handle->coreotn_handle,
                                          lo_chnl_ids_rx[i], 1,
                                          COREOTN_CHNL_START);                                          
            } 
        }                                                                   
    

        /* clean up the channel ID context in the ODU_struct */    
        if (PMC_SUCCESS == result)
        {
            /* For SNCP, just skip this part to leave the channels state unchanged */ 
            if (prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK) {
                /* free the channel id */
                for (i = 0; i < lo_tx_cnt; i++)
                {
                    for (j = 0; j < UTIL_GLOBAL_MAX_NUM_TS; j++)
                    {
                        if (local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_tx[j] == lo_chnl_ids_tx[i])
                        {
                            local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_tx[j] = DIGI_DCI_CHANNEL_UNASSIGNED;
                            local_ho_odu_chnl_ptr->trib_slot_ctxt.tx_trib_port[j] = DIGI_TRIBPORT_UNUSED;
                            local_tx_cnt++;

                            if (lo_tx_cnt == local_tx_cnt)
                            {
                                break;
                            }
                        }
                    }
                }       
                
                for (i = 0; i < lo_rx_cnt; i++)
                {
                    for (j = 0; j < UTIL_GLOBAL_MAX_NUM_TS; j++)
                    {        
                        if (local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_rx[j] == lo_chnl_ids_rx[i])
                        {
                            local_ho_odu_chnl_ptr->trib_slot_ctxt.sub_chnl_ids_rx[j] = DIGI_DCI_CHANNEL_UNASSIGNED;
                            local_ho_odu_chnl_ptr->trib_slot_ctxt.rx_trib_port[j] = DIGI_TRIBPORT_UNUSED;
                            local_rx_cnt++;

                            if (lo_rx_cnt == local_rx_cnt)
                            {
                                break;
                            }
                        }
                    }
                }  
                 
                local_ho_odu_chnl_ptr->trib_slot_ctxt.num_sub_container_rx -= lo_rx_cnt;
                local_ho_odu_chnl_ptr->trib_slot_ctxt.num_sub_container_tx -= lo_tx_cnt;  
            }

            /* Only clean up channel pointer context if this RX and TX segment have been provision (last_segment==TRUE) */
              
            /* deactivate the odu struct */
            if (mux_stage == DIGI_OTN_MUX_STAGES_TWO)
            {
                for (i = 0; i < lo_rx_cnt; i++)
                {
                    digi_handle->handle_pool.lo_odu_struct[lo_chnl_ids_rx[i]].active = FALSE;
                }
            }
            else {
                for (i = 0; i < lo_rx_cnt; i++)
                {
                    digi_handle->handle_pool.mo_odu_struct[lo_chnl_ids_rx[i]].active = FALSE;
                }                
            }

            if (digi_handle->var.otn_cfg_mode == DIGI_OTN_DIRECT_DEVICE_CONFIG)
            {
                /* For SNCP, just skip this part to leave the channels state unchanged */
                if (prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK) {
                    if (mux_stage == DIGI_OTN_MUX_STAGES_TWO
                        || (mux_stage == DIGI_OTN_MUX_STAGES_ONE && local_ho_odu_chnl_ptr->odu_level == ODU_STRUCT_LEVEL_HO_ODU))
                    
                    {
                        for (i = 0; i < lo_rx_cnt; i++)
                        {
                            /* deactivate the 3b odu_struct */
                            digi_chnl_ptr_initialize((util_global_switch_data_def_t*)&(digi_handle->handle_pool.s3b_odu_struct[lo_chnl_ids_rx[i]]));
                        }                    
                    }
                    
                    if (mux_stage == DIGI_OTN_MUX_STAGES_ONE)
                    {
                        for (i = 0; i < lo_rx_cnt; i++)
                        {
                            digi_chnl_ptr_initialize((util_global_switch_data_def_t*)&digi_handle->handle_pool.mo_odu_struct[lo_chnl_ids_rx[i]]);
                        }
                    }
                    else {
                        for (i = 0; i < lo_rx_cnt; i++)
                        {
                            digi_chnl_ptr_initialize((util_global_switch_data_def_t*)&digi_handle->handle_pool.lo_odu_struct[lo_chnl_ids_rx[i]]);
                        }
                    }
                }
            } else {
                result = DIGI_ERR_NO_SW_CONTENT;
            }         
        } 

        PMC_FREE(&lo_chnl_ids_rx);
        PMC_FREE(&lo_chnl_ids_tx);
        PMC_FREE(&lo_chnl_ids_tx_unchannelized);
    }

    PMC_RETURN(result);

} /* digi_otn_server_prov_all_lo_deprov_end */


#ifndef DOXYGEN_PUBLIC_ONLY

/*******************************************************************************
* digi_dynamic_ctxt_alloc
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Dynamically alloc or FREE unstored part of the digi_var_t context 
*
* INPUTS:
*   *digi_handle          - pointer to digi handle
*   alloc                 - TRUE means allocation, FALSE free memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_dynamic_ctxt_alloc(digi_handle_t *digi_handle,
                                     BOOL8 alloc)
{
    PMC_ENTRY();


    if (TRUE == alloc)
    {
        digi_handle->var.enabled_int                  = (digi_int_t*) PMC_CALLOC(sizeof(digi_int_t));
        digi_handle->var.enabled_otn_int              = (digi_int_otn_t *) PMC_CALLOC(sizeof(digi_int_otn_t));
        digi_handle->var.int_info_ary                 = (digi_int_info_ary_t *) PMC_CALLOC(sizeof(digi_int_info_ary_t));
        digi_handle->var.digi_pmon_mode_profile       = (digi_pmon_mode_profile_t *) PMC_CALLOC(sizeof(digi_pmon_mode_profile_t));
        digi_handle->var.digi_pmon_mode_profile->digi_fw_stats.firmware_stats_buffer = NULL;
        digi_handle->var.serdes_ctxt.serdes_cfg       = (digi_serdes_cfg_t *)PMC_CALLOC(sizeof(digi_serdes_cfg_t));
        digi_handle->var.event_cfg                    = (digi_event_cfg_t *) PMC_CALLOC(sizeof(digi_event_cfg_t));


        PMC_MEMSET(digi_handle->var.int_info_ary, 0, sizeof(digi_int_info_ary_t));
    }
    else 
    {
        PMC_FREE(&digi_handle->var.enabled_int);
        PMC_FREE(&digi_handle->var.enabled_otn_int);
        PMC_FREE(&digi_handle->var.int_info_ary);
        if (digi_handle->var.digi_pmon_mode_profile->digi_fw_stats.firmware_stats_buffer != NULL) {
            PMC_FREE(&digi_handle->var.digi_pmon_mode_profile->digi_fw_stats.firmware_stats_buffer);
        }
        PMC_FREE(&digi_handle->var.digi_pmon_mode_profile);
        PMC_FREE(&digi_handle->var.event_cfg);
        PMC_FREE(&digi_handle->var.serdes_ctxt.serdes_cfg);
    }

    PMC_RETURN();
} /*digi_dynamic_ctxt_alloc */

/*******************************************************************************
* digi_subsystem_restart_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   Handles the re-initialization DIGI subsystem in the case of a crash or
*   warm restart. 
*
* INPUTS:
*   *digi_handle             - pointer to DIGI handle instance
*   is_warm_restart          - TRUE call is made for a warm restart.
*                              FALSE implies a crash restart.
*   restart_init_phase       - restart phase
*   digi_resource_handle_ptr - Reference to the digi resource table.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - Initialization was successful from the perspective of
*                 the restart type
*   PMC_ERROR   - For crash restart there is not at least one 
*                 bi-directional path across the device before or after 
*                 all incoherency issues are resolved.
*                 For warm restart at least one DIGI Applib and HW 
*                 incoherency was found.
*   PMC_ASSERT  - One or more pointers in the digi_handle are NULL.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_subsystem_restart_init(digi_handle_t *digi_handle,
                                              BOOL8 is_warm_restart,
                                              util_global_restart_init_phase_t restart_init_phase,
                                              digi_resource_handle_summary_t *digi_resource_handle_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_energy_state_t energy_state;
    util_global_restart_init_cfg_t restart_init_cfg;
    UINT32 itr  = 0;
    UINT8  otu_maint_sig[DIGI_OTN_SERVER_CHNL_MAX + DIGI_OTN_SERVER_SYS_CHNL_MAX];
    UINT8  map2enet_chnl[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    PMC_ENTRY();
      
    restart_init_cfg.is_warm_restart = is_warm_restart;
    restart_init_cfg.phase           = restart_init_phase;
    restart_init_cfg.opaque          = NULL;
    PMC_MEMSET(& map2enet_chnl[0],0,sizeof(UINT8)* UTIL_GLOBAL_MAX_NUM_ODU_CHNL);
    
    /* Reload Energy states from reg space (some subsystem may have been put in low power state)*/
    digi_energy_state_reg_get(digi_handle, &energy_state);

    hostmsg_handle_restart_init((pmc_handle_t*)digi_handle, &restart_init_cfg, PMC_ENERGY_STATE_RUNNING);

    if (UTIL_GLOBAL_RESTART_INIT_PHASE_FIRST  == restart_init_cfg.phase)
    {
        /* Serdes  */
        result = digi_serdes_restart_init(digi_handle,
                                          &restart_init_cfg);
                    
        /*
          PGMRCLK
        */
        if (PMC_SUCCESS == result)
        {
            digi_pgmrclk_restart_init(digi_handle,
                                      &restart_init_cfg);
        }
       
        /*
          DCPB
        */
        if (PMC_SUCCESS == result)
        {
            if(energy_state.dcpb == PMC_ENERGY_STATE_INCOHERENT)
            {
                if(is_warm_restart==FALSE)
                {
                    /* Crash - force the module to reset state */
                    digi_dcpb_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RESET);
                } 
                else 
                {
                    /* Warm - report incoherency error - audit failed */
                    PMC_LOG_TRACE("Overall coherency state is INCOHERENT\n");
                    result = DIGI_ERR_CONTEXT_INCOHERENT;
                }
            }    

            if(result == PMC_SUCCESS)
            {
                result = cpb_handle_restart_init(digi_handle->dcpb_handle,&restart_init_cfg, energy_state.dcpb);
                if (is_warm_restart==FALSE && PMC_SUCCESS == result )
                {
                    digi_dcpb_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
                }
            }
        }

        /* 
           MCPB 
        */
        if (PMC_SUCCESS == result)
        {
            if(energy_state.mcpb == PMC_ENERGY_STATE_INCOHERENT)
            {
                if(is_warm_restart==FALSE)
                {
                    /* Crash - force the module to reset state */
                    digi_mcpb_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RESET);
                } 
                else 
                {
                    /* Warm - report incoherency error - audit failed */
                    PMC_LOG_TRACE("Overall coherency state is INCOHERENT\n");
                    result = DIGI_ERR_CONTEXT_INCOHERENT;
                }
            }    

            if (PMC_SUCCESS == result)
            {
                result = cpb_handle_restart_init(digi_handle->mcpb_handle,&restart_init_cfg, energy_state.mcpb); 

                if (is_warm_restart==FALSE && PMC_SUCCESS == result )
                {
                    digi_mcpb_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
                }

                /* test DIGI context mcpb_mux_mode_init and reset it if the MCPB contains no 
                   ENET_LINE/ENET_SYS related paths */
                if(digi_handle->var.mcpb_ctxt.mcpb_mux_mode_init == TRUE && FALSE == cpb_mcpb_enet_connect_start_state_test(digi_handle->mcpb_handle))
                {
                    digi_handle->var.mcpb_ctxt.mcpb_mux_mode_init = FALSE;
                }

                /* test DIGI context mcpb_mux_mode_init to ensure if set, the MCPB register settings
                   are consistent for either ENET_LINE or ENET_SYS port selection */
                if(digi_handle->var.mcpb_ctxt.mcpb_mux_mode_init == TRUE && LAST_CPB_MCPB_MUX_MODE == cpb_mcpb_mux_mode_init_get(digi_handle->mcpb_handle))
                {
                    result = DIGI_ERR_CONTEXT_INCOHERENT;
                }

                if (PMC_SUCCESS != result)
                {
                    PMC_LOG_TRACE("MCBP restart failed\n");
                }
            }
        }

        /* 
           MAPOTN 
        */
        if (PMC_SUCCESS == result)
        {
            if(energy_state.mapotn == PMC_ENERGY_STATE_INCOHERENT && is_warm_restart== FALSE)
            {
                /* in crash restart, we reset the subsystem, we are done */
                digi_mapotn_energy_state_set(digi_handle, LAST_DIGI_MAP,PMC_ENERGY_STATE_REQUEST_RESET);
            } else if (energy_state.mapotn == PMC_ENERGY_STATE_INCOHERENT && is_warm_restart== TRUE)
            {
                result = DIGI_ERR_CONTEXT_INCOHERENT;
            }

            if (PMC_SUCCESS == result)
            {
                /* context RECOVER/AUDIT/CLEANUP*/
                result = mapotn_handle_restart_init(digi_handle->mapotn_handle,
                                                    &restart_init_cfg,
                                                    energy_state.mapotn);  
                if (is_warm_restart == FALSE)
                {
                    if (PMC_SUCCESS != result)
                    {
                        /* recovery has failed, we reset the subsystem */
                        digi_mapotn_energy_state_set(digi_handle,LAST_DIGI_MAP, PMC_ENERGY_STATE_REQUEST_RESET);
                    } else 
                    {
                        /* recovery has failed, we reset the subsystem */
                        digi_mapotn_energy_state_set(digi_handle,LAST_DIGI_MAP, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
                    }
                }
            }
        } 

        if (PMC_SUCCESS == result)
        {
            /*
             * SIFD
             */
            result = sifd_handle_restart_init(digi_handle->sifd_handle,
                                              &restart_init_cfg,
                                              PMC_ENERGY_STATE_RUNNING);
        
        }

        if (PMC_SUCCESS == result)
        {
            /*
             * LIFD
             */
            result = lifd_handle_restart_init(digi_handle->lifd_handle,
                                              &restart_init_cfg,
                                              PMC_ENERGY_STATE_RUNNING);
        
        }
        /*
          LINEOTN
        */
        if (PMC_SUCCESS == result)
        {
            if(energy_state.lineotn == PMC_ENERGY_STATE_INCOHERENT && is_warm_restart== FALSE)
            {
                /* Crash - force the module to reset state */
                digi_lineotn_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RESET);
            }
            else if (energy_state.lineotn == PMC_ENERGY_STATE_INCOHERENT && is_warm_restart== TRUE)
            {
                result = DIGI_ERR_CONTEXT_INCOHERENT;
            }
            else
            {
                result = lineotn_handle_restart_init(digi_handle->lineotn_handle, TRUE,&restart_init_cfg, energy_state.lineotn);
            
                if (is_warm_restart == FALSE)
                {
                    if (PMC_SUCCESS != result)
                    {
                
                        /* recovery has failed, we reset the subsystem */
                        digi_lineotn_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RESET);
                    } else 
                    {
                        digi_lineotn_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
                    }
                }
            }
        }

        /*
          SYSOTN
        */
        if (PMC_SUCCESS == result)
        {
            if(energy_state.sysotn == PMC_ENERGY_STATE_INCOHERENT && is_warm_restart== FALSE)
            {
                /* Crash - force the module to reset state */
                digi_sysotn_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RESET);
            }
            else if (energy_state.sysotn == PMC_ENERGY_STATE_INCOHERENT && is_warm_restart== TRUE)
            {
                result = DIGI_ERR_CONTEXT_INCOHERENT;
            }
            else
            {
                result = lineotn_handle_restart_init(digi_handle->sysotn_handle, FALSE,&restart_init_cfg, energy_state.sysotn);

                if (is_warm_restart == FALSE)
                {
                    if (PMC_SUCCESS != result)
                    {
                        /* recovery has failed, we reset the subsystem */
                        digi_sysotn_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RESET);
                    } else 
                    {
                        digi_sysotn_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
                    }
                } 

            }
        }

        /* 
           COREOTN
        */
        if (PMC_SUCCESS == result)
        {
            if(energy_state.coreotn == PMC_ENERGY_STATE_INCOHERENT && is_warm_restart== FALSE)
            {
                /* in crash restart, we reset the subsystem, we are done */
                digi_coreotn_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RESET, LAST_COREOTN_POWER);
            } else if (energy_state.coreotn == PMC_ENERGY_STATE_INCOHERENT && is_warm_restart== TRUE)
            {
                result = DIGI_ERR_CONTEXT_INCOHERENT;
            } else 
            {
                /* context RECOVER/AUDIT/CLEANUP*/
                result = coreotn_handle_restart_init(digi_handle->coreotn_handle,
                                                     &restart_init_cfg,
                                                     energy_state.coreotn);  
                if (is_warm_restart == FALSE)
                {
                    if (PMC_SUCCESS != result)
                    {
                        /* recovery has failed, we reset the subsystem */
                        digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_RESET,LAST_COREOTN_POWER);
                        PMC_LOG(PMC_LOG_SEV_HIGH, 0, 0, 0,
                                "coreotn_handle_restart_init FAILED!! Result=%d\n", result);
                    } else
                    {
                        digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_OPTIMAL,COREOTN_STG4);
                    }
                }
            }

            if (PMC_SUCCESS == result)
            {
                digi_coreotn_null_sig_recover(digi_handle);
            }
        }

        /* 
           ENET_LINE 
        */
        if (PMC_SUCCESS == result)
        {
            if(energy_state.enet_line == PMC_ENERGY_STATE_INCOHERENT && is_warm_restart== FALSE)
            {
                for(itr = 0; itr < ENET_NUM_LINK_MAX; itr++)
                {
                    /* in crash restart, we reset the subsystem, we are done */
                    digi_enet_line_energy_state_set(digi_handle, 
                                                    itr, 
                                                    LAST_ENET_DATAPATH, 
                                                    PMC_ENERGY_STATE_REQUEST_RESET);
                }
            } 
            else if (energy_state.enet_line == PMC_ENERGY_STATE_INCOHERENT && is_warm_restart== TRUE)
            {
                result = DIGI_ERR_CONTEXT_INCOHERENT;
            } 
            else 
            {
                /* context RECOVER/AUDIT/CLEANUP*/
                result = enet_handle_restart_init(digi_handle->enet_line_handle,
                                                  &restart_init_cfg,
                                                  energy_state.enet_line,
                                                  ENET_LINE);  
                if (is_warm_restart == FALSE)
                {                
                    for(itr = 0; itr < ENET_NUM_LINK_MAX; itr++)
                    {
                        /* recovery has failed, we reset the subsystem */
                        digi_enet_line_energy_state_set(digi_handle, 
                                                        itr, 
                                                        LAST_ENET_DATAPATH, 
                                                        PMC_SUCCESS != result?PMC_ENERGY_STATE_REQUEST_RESET:PMC_ENERGY_STATE_REQUEST_OPTIMAL);
                    }
                }
            }
        }
        /* 
           ENET_SYS 
        */
        if (PMC_SUCCESS == result)
        {
            if(energy_state.enet_sys == PMC_ENERGY_STATE_INCOHERENT && is_warm_restart== FALSE)
            {
                for(itr = 0; itr < ENET_NUM_LINK_MAX; itr++)
                {
                    /* in crash restart, we reset the subsystem, we are done */
                    digi_enet_sys_energy_state_set(digi_handle, 
                                                   itr, 
                                                   LAST_ENET_DATAPATH,
                                                   PMC_ENERGY_STATE_REQUEST_RESET);
                }
            } 
            else if (energy_state.enet_sys == PMC_ENERGY_STATE_INCOHERENT && is_warm_restart== TRUE)
            {
                result = DIGI_ERR_CONTEXT_INCOHERENT;
            } 
            else 
            {
                /* context RECOVER/AUDIT/CLEANUP*/
                result = enet_handle_restart_init(digi_handle->enet_sys_handle,
                                                  &restart_init_cfg,
                                                  energy_state.enet_sys,
                                                  ENET_SYS);  
                if (is_warm_restart == FALSE)
                {
                
                    for(itr = 0; itr < ENET_NUM_LINK_MAX; itr++)
                    {
                        /* recovery has failed, we reset the subsystem */
                        digi_enet_sys_energy_state_set(digi_handle, 
                                                       itr, 
                                                       LAST_ENET_DATAPATH,
                                                       PMC_SUCCESS != result?PMC_ENERGY_STATE_REQUEST_RESET:PMC_ENERGY_STATE_REQUEST_OPTIMAL);
                    }
                }
            }
        }

        /* CBRC */
        if (PMC_SUCCESS == result)
        {
            if(energy_state.cbrc == PMC_ENERGY_STATE_INCOHERENT && is_warm_restart== FALSE)
            {
                digi_cbrc_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RESET);
            }
            else if (energy_state.cbrc == PMC_ENERGY_STATE_INCOHERENT && is_warm_restart== TRUE)
            {
                result = DIGI_ERR_CONTEXT_INCOHERENT;
            } 
            else 
            {
                result = cbrc_handle_restart_init(digi_handle->cbrc_handle,&restart_init_cfg, energy_state.cbrc);

                if (is_warm_restart == FALSE)
                {
                    digi_cbrc_energy_state_set(digi_handle,PMC_SUCCESS != result? PMC_ENERGY_STATE_REQUEST_RESET:PMC_ENERGY_STATE_REQUEST_OPTIMAL);
                }
            }
        }  

        /* DCSUs */
        if (PMC_SUCCESS == result)
        {
            result = digi_dcsu_restart_init(digi_handle, &restart_init_cfg);
        }
                               
    } 
    else if (UTIL_GLOBAL_RESTART_INIT_PHASE_SECOND == restart_init_cfg.phase)
    {        
        restart_init_cfg.alloc_mem       = FALSE;
        restart_init_cfg.dcpb_connect    = NULL;
        restart_init_cfg.ocpb_connect    = NULL;
        
        /*
         * Clean any dangling resources at the switch.  To ensure the
         * data is accurate retrieve the resource table again which will
         * have changed after being cleaned.
         * Cancel OPSA FW processes and identify SERDES that may requires restoration on their context
         */
        if (PMC_SUCCESS == result)
        {
            (void) digi_resource_state_get(digi_handle, 
                                           digi_resource_handle_ptr); 
            digi120_pmc_log_data.active_handle = digi_handle;
            digi_resource_clean_switch(digi_handle, 
                                       digi_resource_handle_ptr);
            digi_resource_clean_enet_enh_pmon(digi_handle);
        }

        /* Serdes  */
        if (PMC_SUCCESS == result)
        {
            result = digi_serdes_restart_init(digi_handle,
                                              &restart_init_cfg);
        }

        /* 
           RESTART DCPB first 
        */        
        result = cpb_handle_restart_init(digi_handle->dcpb_handle,&restart_init_cfg, energy_state.dcpb);
        if (result == PMC_SUCCESS)
        {
            digi_dcpb_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
        }
        if (PMC_SUCCESS == result)
        {
            result = cpb_handle_restart_init(digi_handle->mcpb_handle,&restart_init_cfg, energy_state.mcpb);
            if (PMC_SUCCESS == result )
            {
                digi_mcpb_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
            }            
            /* test DIGI context mcpb_mux_mode_init and reset it if the MCPB contains no 
               ENET_LINE/ENET_SYS related paths */
            if(digi_handle->var.mcpb_ctxt.mcpb_mux_mode_init == TRUE && FALSE == cpb_mcpb_enet_connect_start_state_test(digi_handle->mcpb_handle))
            {
                digi_handle->var.mcpb_ctxt.mcpb_mux_mode_init = FALSE;
            }

        }
            
        if (PMC_SUCCESS == result)
        {
            /* context RECOVER/AUDIT/CLEANUP*/
            result = lineotn_handle_restart_init(digi_handle->lineotn_handle,
                                                 TRUE, 
                                                 &restart_init_cfg,
                                                 energy_state.lineotn);  
            if (PMC_SUCCESS != result)
            {
                /* recovery has failed, we reset the subsystem */
                digi_lineotn_energy_state_set(digi_handle,
                                              PMC_ENERGY_STATE_REQUEST_RESET);
            } else 
            {
                digi_lineotn_energy_state_set(digi_handle,
                                              PMC_ENERGY_STATE_REQUEST_OPTIMAL);
            } 
        }
        if (PMC_SUCCESS == result)
        {
            /* context RECOVER/AUDIT/CLEANUP*/
            result = lineotn_handle_restart_init(digi_handle->sysotn_handle,
                                                 FALSE, 
                                                 &restart_init_cfg,
                                                 energy_state.sysotn);  
            if (PMC_SUCCESS != result)
            {
                /* recovery has failed, we reset the subsystem */
                digi_sysotn_energy_state_set(digi_handle,
                                             PMC_ENERGY_STATE_REQUEST_RESET);
            } else 
            {
                digi_sysotn_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
            }
        }
       
        /* load OTU-level mainteance signals */
        {
            lineotn_maint_sig_type_t maint_sig;
            for (itr = 0; itr <DIGI_OTN_SERVER_CHNL_MAX; itr++)
            {
                if ( energy_state.lineotn == PMC_ENERGY_STATE_RUNNING &&                     
                     digi_handle->handle_pool.otn_server_chnl[itr].header.prov_state != UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG)
                {
                    (void) digi_otn_maintenance_sig_state_get(digi_handle,
                                                              (digi_otn_server_chnl_t *) &digi_handle->handle_pool.otn_server_chnl[itr],
                                                              LINE_OTN_TX_DIR,
                                                              &maint_sig);
                    otu_maint_sig[itr]  = (UINT8) maint_sig;                                                      
                } else 
                {
                    otu_maint_sig[itr]  = 0;
                }
            }
            if ( energy_state.sysotn == PMC_ENERGY_STATE_RUNNING &&                     
                 digi_handle->handle_pool.sysotn_server_chnl.header.prov_state != UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG)
            {
                (void) digi_otn_maintenance_sig_state_get(digi_handle,
                                                          (digi_otn_server_chnl_t *) &digi_handle->handle_pool.sysotn_server_chnl,
                                                          LINE_OTN_TX_DIR,
                                                          &maint_sig);
                otu_maint_sig[DIGI_OTN_SERVER_CHNL_MAX]  = (UINT8) maint_sig;                                                      
            } else 
            {
                otu_maint_sig[DIGI_OTN_SERVER_CHNL_MAX]  = 0;
            }  

            restart_init_cfg.opaque  = (void*) &otu_maint_sig[0];
        }


        if (PMC_SUCCESS == result)
        {
            /* context RECOVER/AUDIT/CLEANUP*/
            result = coreotn_handle_restart_init(digi_handle->coreotn_handle,
                                                 &restart_init_cfg,
                                                 energy_state.coreotn);  
            if (PMC_SUCCESS != result)
            {
                /* recovery has failed, we reset the subsystem */
                digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_RESET,LAST_COREOTN_POWER);
            } else 
            {
                digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_OPTIMAL,COREOTN_STG4);
            }
        }
                
        /* 
           reload DCPB & ODUKSW connection struct
        */
        {
            UINT32 itr;
            coreotn_oduksw_connect_data_state_get(digi_handle->coreotn_handle,
                                                  &restart_init_cfg.ocpb_connect);
            cpb_connect_data_state_get(digi_handle->dcpb_handle,
                                       & restart_init_cfg.dcpb_connect);              

            /* provide MAP to ENET DCPB channle mapping to mapotn restart */
            for ( itr = 0; itr < UTIL_GLOBAL_MAX_NUM_ODU_CHNL; itr ++)
            {
                if (digi_handle->handle_pool.mapper_chnl[itr].switch_data.cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE && 
                    TRUE == util_global_rx_or_tx_chnl_prov_status_get(digi_handle->handle_pool.mapper_chnl[itr].switch_data.header.prov_state))
                {
                    map2enet_chnl[itr] = digi_handle->handle_pool.mapper_chnl[itr].switch_data.cpb_data.channel;
                } else 
                {
                    map2enet_chnl[itr] = 0xFF;
                }
            }
            restart_init_cfg.opaque  = (void*) &map2enet_chnl[0];                     
        }

        if (PMC_SUCCESS == result)
        {
            /* context RECOVER/AUDIT/CLEANUP*/
            result = mapotn_handle_restart_init(digi_handle->mapotn_handle,
                                                &restart_init_cfg,
                                                energy_state.mapotn);  
            PMC_LOG_TRACE("mapotn_handle_restart_init 2nd Result=%d\n",
                          result);

            if (PMC_SUCCESS != result)
            {
                /* recovery has failed, we reset the subsystem */
                digi_mapotn_energy_state_set(digi_handle,LAST_DIGI_MAP, PMC_ENERGY_STATE_REQUEST_RESET);
            } else 
            {
                digi_mapotn_energy_state_set(digi_handle,LAST_DIGI_MAP, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
            }
        } 
                                

        if(result == PMC_SUCCESS)
        {
            result = sifd_handle_restart_init(digi_handle->sifd_handle,
                                              &restart_init_cfg,
                                              PMC_ENERGY_STATE_RUNNING);
        }

        if (PMC_SUCCESS == result)
        {            
            /* context RECOVER/AUDIT/CLEANUP*/
            result = enet_handle_restart_init(digi_handle->enet_line_handle,
                                              &restart_init_cfg,
                                              energy_state.enet_line,
                                              ENET_LINE);  

            for(itr = 0; itr < ENET_NUM_LINK_MAX; itr++)
            {
                /* recovery has failed, we reset the subsystem */
                digi_enet_line_energy_state_set(digi_handle, 
                                                itr, 
                                                LAST_ENET_DATAPATH,
                                                PMC_SUCCESS != result?PMC_ENERGY_STATE_REQUEST_RESET:PMC_ENERGY_STATE_REQUEST_OPTIMAL);            }
        }
        
        if (PMC_SUCCESS == result)
        {
            
            /* context RECOVER/AUDIT/CLEANUP*/
            result = enet_handle_restart_init(digi_handle->enet_sys_handle,
                                              &restart_init_cfg,
                                              energy_state.enet_sys,
                                              ENET_SYS); 

            for(itr = 0; itr < ENET_NUM_LINK_MAX; itr++)
            {
                /* recovery has failed, we reset the subsystem */
                digi_enet_sys_energy_state_set(digi_handle, 
                                               itr, 
                                               LAST_ENET_DATAPATH,
                                               PMC_SUCCESS != result?PMC_ENERGY_STATE_REQUEST_RESET:PMC_ENERGY_STATE_REQUEST_OPTIMAL);        
            }
        }
       
        /* CBRC */
        if (PMC_SUCCESS == result)
        {
            result = cbrc_handle_restart_init(digi_handle->cbrc_handle,&restart_init_cfg, energy_state.cbrc);
            
            digi_cbrc_energy_state_set(digi_handle,PMC_SUCCESS != result? PMC_ENERGY_STATE_REQUEST_RESET:PMC_ENERGY_STATE_REQUEST_OPTIMAL);
        }

        /* DCSUs */
        if (PMC_SUCCESS == result)
        {
            result = digi_dcsu_restart_init(digi_handle, &restart_init_cfg);
        }

    }
    
    PMC_RETURN(result);
} /* digi_subsystem_restart_init */



/******************************************************************************
* FUNCTION : digi_restart_tx_ilkn_bcw_dpi_map_init
* _____________________________________________________________________________
*
* DESCRIPTION:
*   This function is meant to regenerate the Tx ILKN BCW/DPI channel map. On
*   restart, the maps will be cleared (every entry set back to NULL). Then
*   loop through all the channel handles to retrieve the BCW channel ID and
*   DPI channel ID then correctly save to the map.
*
* INPUTS:
*   digi_handle - pointer to the digi_handle
*
* OUTPUTS;
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
******************************************************************************/
PRIVATE void digi_restart_tx_ilkn_bcw_dpi_map_init(digi_handle_t *digi_handle)
{
    UINT32 i = 0;
    UINT8 bcw_chnl_id = 0;
    UINT8 dpi_chnl_id = 0;
    digi_ilkn_chnl_target_t target = LAST_DIGI_ILKN_CHNL_TARGET;
    util_global_chnl_provisioned_state_t prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNUSED;

    PMC_ENTRY();

    for (i = 0; i < DIGI_SIFD_ILKN_ARB_DPI_CHANS_MAX; i++) {
        digi_handle->var.tx_ilkn_1_bcw_dpi_map[i] = DIGI_SIFD_ILKN_NULL_CAL_ENTRY;
        digi_handle->var.tx_ilkn_2_bcw_dpi_map[i] = DIGI_SIFD_ILKN_NULL_CAL_ENTRY;
    }

    for (i = 0; i < DIGI_SIFD_ILKN_ARB_DPI_CHANS_MAX; i++) {
        prov_state  = digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.header.prov_state;
        target      = digi_handle->handle_pool.ilkn_1_chnl[i].target;
        bcw_chnl_id = digi_handle->handle_pool.ilkn_1_chnl[i].tx_ilkn_info.ilkn_bcw_chnl;
        if (DIGI_ILKN_CHNL_TARGET_ODUK == target)
        {
            dpi_chnl_id = digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.oduk_data.channel + DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX;
        }
        if (DIGI_ILKN_CHNL_TARGET_CPB == target)
        {
            dpi_chnl_id = digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.cpb_data.channel;
        }

        if (UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG != prov_state) 
        {
            if (DIGI_SIFD_BCW_CHANNEL_NULL == digi_handle->var.tx_ilkn_1_bcw_dpi_map[bcw_chnl_id])
            {
                digi_handle->var.tx_ilkn_1_bcw_dpi_map[bcw_chnl_id] = dpi_chnl_id;
            }
            else
            {
                digi_handle->var.tx_ilkn_1_bcw_dpi_map[bcw_chnl_id] = DIGI_SIFD_BCW_CHANNEL_LINK;
            }
        }
    }

    for (i = 0; i < DIGI_SIFD_ILKN_ARB_DPI_CHANS_MAX; i++) {
        prov_state  = digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.header.prov_state;
        target      = digi_handle->handle_pool.ilkn_2_chnl[i].target;
        bcw_chnl_id = digi_handle->handle_pool.ilkn_2_chnl[i].tx_ilkn_info.ilkn_bcw_chnl;
        if (DIGI_ILKN_CHNL_TARGET_ODUK == target)
        {
            dpi_chnl_id = digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.oduk_data.channel + DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX;
        }
        if (DIGI_ILKN_CHNL_TARGET_CPB == target)
        {
            dpi_chnl_id = digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.cpb_data.channel;
        }

        if (UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG != prov_state) 
        {
            if (DIGI_SIFD_BCW_CHANNEL_NULL == digi_handle->var.tx_ilkn_2_bcw_dpi_map[bcw_chnl_id])
            {
                digi_handle->var.tx_ilkn_2_bcw_dpi_map[bcw_chnl_id] = dpi_chnl_id;
            }
            else
            {
                digi_handle->var.tx_ilkn_2_bcw_dpi_map[bcw_chnl_id] = DIGI_SIFD_BCW_CHANNEL_LINK;
            }
        }
    }

    PMC_RETURN();
}



/*******************************************************************************
* digi_otn_server_lo_prov_internal
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies detailed bidirectional configuration for low order
*   ODUk processing blocks.\n\n
*
*   When this function is used to perform 1 stage multiplexing:
*   This function is used to provision a LO ODUk framer channel into a HO ODUk
*   framer channel.  
*
*   When this function is used to perform 2 stage multiplexing:
*   This function is used to provision a LO ODUk framer channel into a MO ODUk
*   framer channel as well as to provision a MO ODUk framer channel into a
*   HO ODUk framer channel.  
*
*   SW driver internally describes ODU framer configuration using an ODU struct
*   for low order container.\n\n
*
*   This function updates the tributary slot assignment and tributary port data
*   of the HO ODU struct that the LO ODU struct is associated with.\n\n
*
*   In Direct Device Configuration mode - This function internally generates a
*   TRQ containing the requested configuration data and calls the FW Host
*   Message for processing the HO/LO ODU struct.\n\n
*
*   In Pending mode - This function updates LO ODU struct and the parent HO ODU
*   struct with the desired configuration data to be applied in the future.\n\n
*
*   When operating in pending mode, the OUTPUT parameter out_chnl_ctxt_pptr is
*   an input.  It is the caller's responsibility to allocate the ODU struct
*   pool resource and communicate it to this API using the out_chnl_ctxt_pptr
*   parameter.\n\n
*
*   The SW driver will initially specify the payload type of the signal for
*   payload mode of 1G25 or 2G5 Tributary slots for Payload Type 20 or 21 as
*   defined in ITU G.709.\n\n
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   *in_chnl_ctxt_ptr   - pointer to higher order channel containing the
*                         low order framer to be provisioned.
*   cfg_mode            - function operation mode:\n
*                         0: Direct Device Configuration\n
*                         1: Pending Configuration
*   oduk_type           - Enum, ODUk container type. See digi_oduk_t.
*   client_bitrate      - For DIGI_ODUKSW_STREAM_CBR_ODUFLEX, specify the client
*                         bit rate in bps.  This is the ODU client rate.  This 
*                         function will assert if client_bitrate is less than 
*                         1000bps.
*                         (ODU rate = unmapped client rate * (239/238))
*                         For all the other LO ODU types, set to 0.  
*   mapping_mode        - payload mapping mode. See digi_otn_mapping_type_t.
*   tx_trib_slot_mask   - transmit path tributary slots low order container will use in
*                         higher order payload.
*                         For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, the number of
*                         bits set in this mask should match the number of 
*                         tributary slots in the ODUFlex container.
*   rx_trib_slot_mask   - receive path tributary slots low order container will use in
*                         higher order payload.
*                         For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, the number of
*                         bits set in this mask should match the number of 
*                         tributary slots in the ODUFlex container.
*   payload_mode        - System Side Payload Format\n
*                         0: Unchannelized\n
*                         1: Channelized 1G25 rate tributary slots\n
*                         2: Channelized 2G5 rate tributary slots
*   prov_ho_cfg         - TRUE : provision  RFRM/TFRM
*                         FALSE : preserve current RFRM/TFRM configuration
*
* OUTPUTS:
*   **out_chnl_ctxt_pptr    - pointer to a pointer to a context for the LO
*                             framer channel
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_lo_prov_internal( digi_handle_t *digi_handle,
                                                    digi_otn_odu_chnl_t *in_chnl_ctxt_ptr,
                                                    digi_otn_cfg_mode_t cfg_mode,
                                                    digi_oduk_t oduk_type,
                                                    DOUBLE client_bitrate,
                                                    digi_otn_mapping_type_t mapping_mode,
                                                    UINT32 tx_trib_slot_mask[3],
                                                    UINT32 rx_trib_slot_mask[3],
                                                    digi_odu_line_payload_t payload_mode,
                                                    digi_otn_odu_chnl_t **out_chnl_ctxt_pptr,
                                                    BOOL prov_ho_cfg)                                     
{
    PMC_ERROR result = PMC_SUCCESS;

    UINT32 i;
    UINT32 num_cal_entries;
    util_global_odukp_type_t odu_container = UTIL_GLOBAL_LAST_ODUK;
    util_global_mapping_mode_t mapping_type;
    odu_struct_t *lo_odu_struct_ptr = NULL;
    odu_struct_t *ho_odu_struct_ptr = NULL;
    UINT32 ho_cal_entry_ptr[DIGI_SCHD_96_ENTRY];
    
    UINT32 chnl_id = DIGI_DCI_CHANNEL_UNASSIGNED;
    digi_otn_mux_stages_t mux_stage = LAST_DIGI_OTN_MUX_STAGES;
    UINT32 num_client_odu0 = 0;
    UINT32 lo_num_cal_entries = 0xffffffff; /* Out of range init value. */
    UINT32 lo_cal_entry_ptr_rx[DIGI_SCHD_96_ENTRY] = { 0 };
    UINT32 lo_cal_entry_ptr_tx[DIGI_SCHD_96_ENTRY] = { 0 };


    UINT32 tx_trib_port = DIGI_TRIBPORT_UNUSED;
    UINT32 rx_trib_port = DIGI_TRIBPORT_UNUSED;
    
    coreotn_odu_chnl_prov_mode_t coreotn_prov_mode = LAST_COREOTN_CHNL_PROV_MODE; 
    UINT8 target_lo_chnl_num = 0;
    UINT8 num_mo_chnls = 0;
    UINT8 num_lo_chnls = 0;
    util_global_odu_level_t odu_level = LAST_UTIL_GLOBAL_LEVEL;

    BOOL prov_activate_tx = FALSE;
    BOOL prov_activate_rx = FALSE;
    odu_chnl_t *local_ho_odu_chnl_ptr = NULL;

    BOOL new_chnl;
    UINT32 tx_cnt = 0;
    UINT32 rx_cnt = 0;
    BOOL compare_result;
    odu_struct_t* s3b_odu_struct_ptr = NULL;
    PMC_ENTRY();

/* trib_slot_mask will identify locations to write lo_msi_data and will be
   used to determine the number of tributary slots required for lower level
   API */

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != in_chnl_ctxt_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    /* check otn odu struct input handle */
    result = digi_ho_odu_struct_handle_validate(digi_handle, in_chnl_ctxt_ptr);

    if (PMC_SUCCESS != result)
    {
        result = digi_mo_odu_struct_handle_validate(digi_handle, in_chnl_ctxt_ptr);        
    }

    if (PMC_SUCCESS == result)
    {

        /* get the HO framer channel context */
        ho_odu_struct_ptr = (odu_struct_t *)in_chnl_ctxt_ptr;
        PMC_ASSERT(NULL != ho_odu_struct_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
        
        if (ho_odu_struct_ptr->mem_ptr->payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
        {
            PMC_ASSERT(FALSE, DIGI_ERR_INVALID_HO_ODU_PAYLOAD_FORMAT, ho_odu_struct_ptr->mem_ptr->payload_format, 0);
        }
        
        /* debug */
        /* print out the tribslot mask */
        for (i = 0; i < 3; i++)
        {
            PMC_LOG_TRACE("tx_trib_slot_mask[%u] = 0x%x\n", i, tx_trib_slot_mask[i]);
        } 
    
        for (i = 0; i < 3; i++)
        {
            PMC_LOG_TRACE("rx_trib_slot_mask[%u] = 0x%x\n", i, rx_trib_slot_mask[i]);
        }    
    
        /*
         * Compare the channel number against the particular ODU level.
         * If neither HO or MO then assert as invalid.
         */
        if ((UINT32)ho_odu_struct_ptr->mem_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
        {
            PMC_ASSERT(ho_odu_struct_ptr->mem_ptr->chnl_id < DIGI_NUM_HO_ODU_CHNL_MAX, DIGI_ERR_INVALID_ARG, ho_odu_struct_ptr->mem_ptr->chnl_id, 0);
        }
        else if ((UINT32)ho_odu_struct_ptr->mem_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU)
        {
            PMC_ASSERT(ho_odu_struct_ptr->mem_ptr->chnl_id < DIGI_NUM_MO_ODU_CHNL_MAX, DIGI_ERR_INVALID_ARG, ho_odu_struct_ptr->mem_ptr->chnl_id, 0);
        }
        else
        {
            PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, ho_odu_struct_ptr->mem_ptr->chnl_id, 0);
        }
        PMC_ASSERT((UINT32)ho_odu_struct_ptr->mem_ptr->odu_level < (UINT32)LAST_DIGI_ODU_STRUCT_LEVEL, DIGI_ERR_INVALID_ARG, ho_odu_struct_ptr->mem_ptr->odu_level, 0);

        /* Initialize the calendar array to default */
        for (i = 0; i < UTIL_GLOBAL_MAX_NUM_CAL_ENTRY; i++)
        {
            ho_cal_entry_ptr[i] = DIGI_DCI_CHANNEL_UNASSIGNED;
            lo_cal_entry_ptr_rx[i] = DIGI_DCI_CHANNEL_UNASSIGNED;
            lo_cal_entry_ptr_tx[i] = DIGI_DCI_CHANNEL_UNASSIGNED;
        }
    
/* if it is one stage muxing, we will have a passthru channel in FMF2.
** If "payload_mode == unchannelized", we know it is one stage muxing.
** If "payload_mode != unchannelized", provide the full details of the signal
** so that we can prov lo channels.
**
**  if we are provisioning as a mo channel, we can ignore mapping_mode, trib_slot_mask[3], lo_msi_data
*/
        /* argument checking */
        result = digi_otn_mapping_mode_validate(digi_handle, in_chnl_ctxt_ptr,
                                                oduk_type, mapping_mode );
    
        if (PMC_SUCCESS == result)
        {                                             
            if (oduk_type != DIGI_ODUK_ODUFLEX)
            {
                /* convert oduk_type */
                result = digi_oduk_rate_param_convert(oduk_type, &odu_container);
                
                /* check if the LO ODU rate is less than the HO ODU rate */
                PMC_ASSERT(ho_odu_struct_ptr->mem_ptr->odu_type >= odu_container, DIGI_ERR_INVALID_LO_ODUK_TYPE, odu_container, 0);
                
            }
            else {
                /* if it is Flex container, always get the number of ODU0
                ** for lower level processing 
                */
 
                /* the size of the ODUflex container is the same in both direction. 
                ** Therefore, we can use on trib_slot_mask to count the number of
                ** ODU0s in the flex container 
                **
                ** In asymmetric provisioning, the size of both ODUk containers
                ** are the same.
                */
                if (tx_trib_slot_mask[0] != 0x0 
                    || tx_trib_slot_mask[1] != 0x0
                    || tx_trib_slot_mask[2] != 0x0)
                {
                    for (i = 0; i < UTIL_GLOBAL_MAX_NUM_TS; i++)
                    {
                        if ((tx_trib_slot_mask[i/32] >> (i%32)) & 1)
                        { 
                            num_client_odu0++;
                        }
                    }
                }
                else {
                    for (i = 0; i < UTIL_GLOBAL_MAX_NUM_TS; i++)
                    {
                        if ((rx_trib_slot_mask[i/32] >> (i%32)) & 1)
                        { 
                            num_client_odu0++;
                        }
                    }
                }
                        
                /* Compare the client bitrate to 0.0 to see if GFP or CBR. Since
                   client_bitrate is a DOUBLE compare against a small range of
                   -0.001 < client_bitrate < 0.001 to see if equal to 0.0*/
                if (!digi_use_float32_get())
                {
                    compare_result = PMC_COMPARE_DOUBLE(client_bitrate, 0.0, 0.001);
                }
                else
                {
                    compare_result = PMC_COMPARE_FLOAT((FLOAT)client_bitrate, 0.0F, 0.001F);
                }
                if (compare_result)
                {   /* client_bitrate is 0.0 so GFP */
                    odu_container = UTIL_GLOBAL_ODUFLEX_GFP;   
                }
                else 
                {   /* client_bitrate is *not* 0.0 so CBR */
                    odu_container = UTIL_GLOBAL_ODUFLEX_CBR;
                    
                    if (client_bitrate < 1000.0)
                    {
                        PMC_ASSERT(client_bitrate >= 1000.0, DIGI_ERR_INVALID_ODUFLEX_CBR_CLIENT_BITRATE, client_bitrate, 0);
                    }   
                }
                 
            }
        }
    }
    else
    {
        result = DIGI_ERR_NULL_HANDLE;
    }
    
    /* There are two flavours of provisioning:
       - TX/RX and prov/activated at the same time
       - TX is prov/activated first, then RX is prov/activated */
    if (PMC_SUCCESS == result)
    {
        local_ho_odu_chnl_ptr = ho_odu_struct_ptr->mem_ptr;

        if((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
        {
            /* get all calendar entries for the HO channel to find shadow LO DCI ID */
            result = coreotn_db_ho_cal_entry_all_get(digi_handle->coreotn_handle,
                                                     local_ho_odu_chnl_ptr->chnl_id,
                                                     ho_cal_entry_ptr, &num_cal_entries);
        }
        else if((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU)
        {
            /* get all calendar entries for the HO channel to find shadow LO DCI ID */
            result = coreotn_db_mo_cal_entry_all_get(digi_handle->coreotn_handle,
                                                     local_ho_odu_chnl_ptr->chnl_id,
                                                     0, /*TX DB*/
                                                     ho_cal_entry_ptr, &num_cal_entries);
        } 
    }
    

    if(prov_ho_cfg)
    {
    
        if (PMC_SUCCESS == result) 
        {
            /* look-up channel id, tx anhd rx trib ports associated with
               the tribslot masks */
            result = digi_otn_server_lo_ch_id_and_trib_port_get(digi_handle,
                                                                ho_odu_struct_ptr,
                                                                tx_trib_slot_mask,
                                                                rx_trib_slot_mask,
                                                                ho_cal_entry_ptr,
                                                                payload_mode,
                                                                &chnl_id,
                                                                &tx_trib_port,
                                                                &rx_trib_port,
                                                                &prov_activate_rx,
                                                                &prov_activate_tx);
        }
        
        if (PMC_SUCCESS == result)
        {
            /*Using returned channel ID from digi_otn_server_lo_ch_id_and_trib_port_get(), see
              if the TX path is already active.  If it is, set prov_activate_tx ==TRUE */
            if((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
            {
                if(digi_handle->handle_pool.mo_odu_struct[chnl_id].active == TRUE)
                {
                    new_chnl = FALSE;
                }
                else
                {
                    new_chnl = TRUE;
                }
            }
            else
            {
                if(digi_handle->handle_pool.lo_odu_struct[chnl_id].active == TRUE)
                {
                    new_chnl = FALSE;
                }
                else
                {
                    new_chnl = TRUE;
                }
            }
        }

    }
    else
    {
        new_chnl = TRUE;
        prov_activate_tx = TRUE;
        prov_activate_rx = TRUE;


        for (i = 0; i < 96; i++) 
        {
            if ((tx_trib_slot_mask[i/32] >> (i%32)) & 1) 
            {
                if (tx_cnt == 0) 
                {
                    tx_trib_port = i;
                }
                tx_cnt++;
                break;
            }   
        }
        
        for (i = 0; i < 96; i++) 
        {
            if ((rx_trib_slot_mask[i/32] >> (i%32)) & 1) 
            {
                if (rx_cnt == 0) 
                {
                    rx_trib_port = i;
                }
                rx_cnt++;
                break;
            }   
        }


    }


    /* convert mapping mode */
    if (PMC_SUCCESS == result)
    {
        result = digi_coreotn_mapping_mode_convert(mapping_mode, &mapping_type);
    }
                                                          
    if (PMC_SUCCESS == result)
    {
        if (cfg_mode == DIGI_OTN_DIRECT_DEVICE_CONFIG)
        {  
            /* if HO payload is channelized, this is 1 stage muxing 
            ** add LO channel into the active HO channel
            */
            if ((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
            {
                mux_stage = DIGI_OTN_MUX_STAGES_ONE;
    
                if(result == PMC_SUCCESS)
                {
                    if(new_chnl &&
                       prov_ho_cfg)
                    {
                        /* obtain odu_struct for MO channel */
                        lo_odu_struct_ptr = digi_mo_odu_struct_chnl_get(digi_handle, chnl_id);
                    }
                    else if(new_chnl == FALSE &&
                            prov_ho_cfg == TRUE)
                    {
                        lo_odu_struct_ptr = &(digi_handle->handle_pool.mo_odu_struct[chnl_id]);
                    }
                    else
                    {
                        lo_odu_struct_ptr = ( odu_struct_t *)*out_chnl_ctxt_pptr;
                        chnl_id = lo_odu_struct_ptr->mem_ptr->chnl_id;
                    }
                }
            
            
                if (NULL == lo_odu_struct_ptr)
                {
                    PMC_RETURN(DIGI_ERR_INVALID_PTR);
                }
            
                /* store the payload format of the channel */
                if (payload_mode ==DIGI_ODU_UNCHANNELIZED)
                {
                    /* if this is unchannelized, then copy HO's payload format to be used for
                    ** lower level processing
                    */
                    digi_handle->var.odu_chnl_payload[DIGI_NUM_HO_ODU_CHNL_MAX+chnl_id] = digi_handle->var.odu_chnl_payload[local_ho_odu_chnl_ptr->chnl_id];
                }
                else {
                    /* if this is a true MO with mixed ts sizes, then use its own ts 
                    ** that is different from HO
                    */
                    if (digi_handle->var.mux_stages != DIGI_OTN_MUX_STAGES_TWO)
                    {
                        PMC_ASSERT(FALSE, DIGI_ERR_INCORRECT_MAX_MUXING_LEVEL, 0, 0);
                    }
            
                    digi_handle->var.odu_chnl_payload[DIGI_NUM_HO_ODU_CHNL_MAX+chnl_id] = payload_mode;
                }
                
            }
            else if ((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU)
            { 
                mux_stage = DIGI_OTN_MUX_STAGES_TWO; 
            
                if(result == PMC_SUCCESS)
                {
                    if(new_chnl &&
                       prov_ho_cfg)
                    {
                        /* obtain odu_struct for MO channel */
                        lo_odu_struct_ptr = digi_lo_odu_struct_chnl_get(digi_handle, chnl_id);
                    }
                    else if(new_chnl == FALSE &&
                            prov_ho_cfg == TRUE)
                    {
                        lo_odu_struct_ptr = &(digi_handle->handle_pool.lo_odu_struct[chnl_id]);
                    }
                    else
                    {
                        lo_odu_struct_ptr = ( odu_struct_t *)*out_chnl_ctxt_pptr;
                        chnl_id = lo_odu_struct_ptr->mem_ptr->chnl_id;
                    }
                }
    
            
                if (NULL == lo_odu_struct_ptr)
                {
                    PMC_RETURN(DIGI_ERR_INVALID_PTR);
                }
            
                /* store the payload format of the channel */
                digi_handle->var.odu_chnl_payload[DIGI_NUM_HO_ODU_CHNL_MAX+DIGI_NUM_MO_ODU_CHNL_MAX+chnl_id] = digi_handle->var.odu_chnl_payload[DIGI_NUM_HO_ODU_CHNL_MAX+local_ho_odu_chnl_ptr->chnl_id];
            
              
            }
            else {
                PMC_RETURN(DIGI_ERR_INVALID_ARG);
            }
            
    
            
            /* if we are operating in super prov mode */
            if (PMC_SUCCESS == result)
            {            
                result = coreotn_odu_chnl_prov_mode_get(digi_handle->coreotn_handle,
                                                        &coreotn_prov_mode);
            }                                                        
            
            if (PMC_SUCCESS == result && (UINT32)coreotn_prov_mode != DIGI_OTN_ODU_CHNL_PROV_IN_INCREMENT)
            {
                /* get the target number of total LO channels */
                result = coreotn_super_prov_lo_prov_num_chnl_get(digi_handle->coreotn_handle,
                                                                 (util_global_odu_level_t)local_ho_odu_chnl_ptr->odu_level,
                                                                 local_ho_odu_chnl_ptr->chnl_id,
                                                                 &num_mo_chnls,
                                                                 &num_lo_chnls);
            
                if (PMC_SUCCESS == result)
                {
                    if (num_mo_chnls != 0xFF && num_lo_chnls != 0xFF)
                    {
                        if ((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU) 
                        {
                            target_lo_chnl_num = num_lo_chnls;
                            odu_level = UTIL_GLOBAL_LEVEL_LO_ODU;
                        }
                        else if ((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
                        {
                            target_lo_chnl_num = num_mo_chnls;
                            odu_level = UTIL_GLOBAL_LEVEL_MO_ODU;
                        }
                       
    
                        /* operate in super prov, set channel config state */
                        if (((prov_activate_rx && local_ho_odu_chnl_ptr->trib_slot_ctxt.num_sub_container_rx == 0) ||
                             (prov_activate_tx && local_ho_odu_chnl_ptr->trib_slot_ctxt.num_sub_container_tx == 0)) &&
                            target_lo_chnl_num != 1)
                        {
                            /* CFG_START */
                            result = coreotn_lo_odu_chnl_cfg_state_set(digi_handle->coreotn_handle,
                                                                       odu_level,
                                                                       chnl_id,
                                                                       COREOTN_LO_ODU_CHNL_CFG_START,
                                                                       prov_activate_rx,
                                                                       prov_activate_tx);
                        }
                        else if ((prov_activate_rx && local_ho_odu_chnl_ptr->trib_slot_ctxt.num_sub_container_rx == target_lo_chnl_num - 1) ||
                                 (prov_activate_tx && local_ho_odu_chnl_ptr->trib_slot_ctxt.num_sub_container_tx == target_lo_chnl_num - 1))
                        {
                            /* last channel -> CFG_END */
                            result = coreotn_lo_odu_chnl_cfg_state_set(digi_handle->coreotn_handle,
                                                                       odu_level,
                                                                       chnl_id,
                                                                       COREOTN_LO_ODU_CHNL_CFG_END,
                                                                       prov_activate_rx,
                                                                       prov_activate_tx);
                        }
                        else 
                        {
                            /* everything in the middle -> CFG_APPLY */
                            result = coreotn_lo_odu_chnl_cfg_state_set(digi_handle->coreotn_handle,
                                                                       odu_level,
                                                                       chnl_id,
                                                                       COREOTN_LO_ODU_CHNL_CFG_APPLY,
                                                                       prov_activate_rx,
                                                                       prov_activate_tx);
                        }  
                    }
                    else {
                        if ((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU) 
                        {
                            odu_level = UTIL_GLOBAL_LEVEL_LO_ODU;
                        }
                        else if ((UINT32)local_ho_odu_chnl_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
                        {
                            odu_level = UTIL_GLOBAL_LEVEL_MO_ODU;
                        }
                        
                        /* operate in super prov, set channel config state */
                        if ((prov_activate_rx == TRUE && local_ho_odu_chnl_ptr->trib_slot_ctxt.num_sub_container_rx == 0) ||
                            (prov_activate_tx == TRUE && local_ho_odu_chnl_ptr->trib_slot_ctxt.num_sub_container_tx == 0))
                        {
                            /* CFG_START */
                            result = coreotn_lo_odu_chnl_cfg_state_set(digi_handle->coreotn_handle,
                                                                       odu_level,
                                                                       chnl_id,
                                                                       COREOTN_LO_ODU_CHNL_CFG_START,
                                                                       prov_activate_rx,
                                                                       prov_activate_tx);
                        }
                        else {
                            /* everything in the middle -> CFG_APPLY */
                            result = coreotn_lo_odu_chnl_cfg_state_set(digi_handle->coreotn_handle,
                                                                       odu_level,
                                                                       chnl_id,
                                                                       COREOTN_LO_ODU_CHNL_CFG_APPLY,
                                                                       prov_activate_rx,
                                                                       prov_activate_tx);
                        }
                    }                                                                       
                }
            }  /* end of if if (PMC_SUCCESS == result && (UINT32)prov_mode == DIGI_OTN_ODU_CHNL_PROV_IN_INCREMENT) */
    
         
            if (mux_stage == DIGI_OTN_MUX_STAGES_ONE)
            {
                if (PMC_SUCCESS == result &&
                    prov_activate_tx == TRUE)  
                { 
                    result = digi_otn_server_tx_lo_prov(digi_handle,
                                                        local_ho_odu_chnl_ptr,
                                                        chnl_id,
                                                        mux_stage,
                                                        odu_container,
                                                        num_client_odu0,
                                                        client_bitrate,
                                                        mapping_type,
                                                        tx_trib_slot_mask,
                                                        tx_trib_port,
                                                        payload_mode,
                                                        prov_ho_cfg);
                }    
            
                /* Receive path */
                if (PMC_SUCCESS == result &&
                    prov_activate_rx == TRUE)
                {
                    result = digi_otn_server_rx_lo_prov(digi_handle,
                                                        local_ho_odu_chnl_ptr,
                                                        chnl_id,
                                                        mux_stage,
                                                        odu_container,
                                                        num_client_odu0,
                                                        client_bitrate,
                                                        mapping_type,
                                                        rx_trib_slot_mask,
                                                        rx_trib_port,
                                                        payload_mode,
                                                        prov_ho_cfg);
                } 
            
            
                if ((payload_mode == DIGI_ODU_TS_1G25 || payload_mode == DIGI_ODU_TS_2G5
                     || payload_mode == DIGI_ODU_NULL) && (UINT32)coreotn_prov_mode == DIGI_OTN_ODU_CHNL_PROV_IN_INCREMENT)
                {
                    /* this should happen only once for the MO channel
                    ** 
                    */
                    if(prov_activate_rx)
                    {
                        if (PMC_SUCCESS == result && digi_handle->var.mo_prov_state_rx[chnl_id] == FALSE)
                        {
                            
                        
#ifdef PMC_INTERNAL_COREOTN_POWER
                            /* not yet debugged */
                            digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_RUNNING,COREOTN_ODUKP);                
#endif
         
                            result = coreotn_rx_ho_chnl_deactivate(digi_handle->coreotn_handle,
                                                                   chnl_id, 
                                                                   (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO);
                                                                                                  
                            
                            if (PMC_SUCCESS == result)
                            {                              
                                /* use MO's payload format stored in the context */                              
                                result =  coreotn_rx_ho_chnl_prov(digi_handle->coreotn_handle,
                                                                  chnl_id,
                                                                  (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO,
                                                                  odu_container,
                                                                  (util_global_odu_line_payload_t)digi_handle->var.odu_chnl_payload[DIGI_NUM_HO_ODU_CHNL_MAX+chnl_id],
                                                                  TRUE);
                            }
                            if (PMC_SUCCESS == result)
                            {
                                result = coreotn_rx_ho_chnl_activate(digi_handle->coreotn_handle,
                                                                     chnl_id, 
                                                                     (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO);                                                  
                            } 
                            
                            digi_handle->var.mo_prov_state_rx[chnl_id] = TRUE;
                                                                   
                        }
    
                    }
    
    
                    if(prov_activate_tx)
                    {
                        if (PMC_SUCCESS == result && digi_handle->var.mo_prov_state_tx[chnl_id] == FALSE)
                        {
                        
                        
#ifdef PMC_INTERNAL_COREOTN_POWER
                            /* not yet debugged */
                            digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_RUNNING,COREOTN_ODUKP);                
#endif
                            result = coreotn_tx_ho_chnl_deactivate(digi_handle->coreotn_handle,
                                                                   chnl_id, 
                                                                   (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO);
                            
                            if (PMC_SUCCESS == result)
                            {                              
                                /* use MO's payload format stored in the context */                              
                                result =  coreotn_tx_ho_chnl_prov(digi_handle->coreotn_handle,
                                                                  chnl_id,
                                                                  (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO,
                                                                  odu_container,
                                                                  (util_global_odu_line_payload_t)digi_handle->var.odu_chnl_payload[DIGI_NUM_HO_ODU_CHNL_MAX+chnl_id],
                                                                  TRUE,
                                                                  TRUE);
                            }

                            if (PMC_SUCCESS == result )
                            {
                                result = coreotn_tx_ho_chnl_activate(digi_handle->coreotn_handle,
                                                                     chnl_id, 
                                                                     (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO);                                                  
                            } 
                            
                            digi_handle->var.mo_prov_state_tx[chnl_id] = TRUE;
                                                                   
                        }
    
                    }
                }   
                                  
    
                if (PMC_SUCCESS == result && 
                    (payload_mode == DIGI_ODU_TS_1G25 || payload_mode == DIGI_ODU_TS_2G5 ||
                     payload_mode == DIGI_ODU_NULL) &&
                    prov_activate_tx == TRUE)
                {
                    digi_opsa_cfg_one_fmf1_txjc_cfc_fifo_clrb(digi_handle,
                                                              chnl_id,
                                                              TRUE);
                } 
                
                                                                                                                      
            }
            else if (mux_stage == DIGI_OTN_MUX_STAGES_TWO)
            { 
                if (TRUE == pmc_coreotn_schd_extra_channel_revision(&digi_handle->base) &&
                    prov_activate_tx == TRUE)
                {
                    if (local_ho_odu_chnl_ptr->chnl_id != chnl_id)
                    {
                        if (PMC_SUCCESS == result)
                        {
                            result = coreotn_odtu_mux_lo_chnl_activate_only(digi_handle->coreotn_handle, local_ho_odu_chnl_ptr->chnl_id);
                        }
                    }
                }
                /* 
                ** this is for provisioning a LO channel in Stage 2 
                */
    
                /* provision MO when the first LO is being added in super-prov case */
                if ((UINT32)coreotn_prov_mode != DIGI_OTN_ODU_CHNL_PROV_IN_INCREMENT)
                {
                    /* this should happen only once for the MO channel
                    ** 
                    */
                    if(prov_activate_rx)
                    {
                        if (PMC_SUCCESS == result && digi_handle->var.mo_prov_state_rx[local_ho_odu_chnl_ptr->chnl_id] == FALSE)
                        {
                            
                        
#ifdef PMC_INTERNAL_COREOTN_POWER
                            /* not yet debugged */
                            digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_RUNNING,COREOTN_ODUKP);                
#endif
         
                            result = coreotn_rx_ho_chnl_deactivate(digi_handle->coreotn_handle,
                                                                   local_ho_odu_chnl_ptr->chnl_id, 
                                                                   (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO);
                                                                                                  
                            
                            if (PMC_SUCCESS == result)
                            {                              
                                /* use MO's payload format stored in the context */                              
                                result =  coreotn_rx_ho_chnl_prov(digi_handle->coreotn_handle,
                                                                  local_ho_odu_chnl_ptr->chnl_id,
                                                                  (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO,
                                                                  local_ho_odu_chnl_ptr->odu_type,
                                                                  (util_global_odu_line_payload_t)digi_handle->var.odu_chnl_payload[DIGI_NUM_HO_ODU_CHNL_MAX+local_ho_odu_chnl_ptr->chnl_id],
                                                                  TRUE);
                            }
                            if (PMC_SUCCESS == result)
                            {
                                result = coreotn_rx_ho_chnl_activate(digi_handle->coreotn_handle,
                                                                     local_ho_odu_chnl_ptr->chnl_id, 
                                                                     (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO);                                                  
                            } 
                            
                            digi_handle->var.mo_prov_state_rx[local_ho_odu_chnl_ptr->chnl_id] = TRUE;
                                                                   
                        }
    
                    }
    
    
                    if(prov_activate_tx)
                    {
                        if (PMC_SUCCESS == result && digi_handle->var.mo_prov_state_tx[local_ho_odu_chnl_ptr->chnl_id] == FALSE)
                        {
                        
                        
#ifdef PMC_INTERNAL_COREOTN_POWER
                            /* not yet debugged */
                            digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_RUNNING,COREOTN_ODUKP);                
#endif
                            result = coreotn_tx_ho_chnl_deactivate(digi_handle->coreotn_handle,
                                                                   local_ho_odu_chnl_ptr->chnl_id, 
                                                                   (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO);
                            
                            if (PMC_SUCCESS == result)
                            {                              
                                /* use MO's payload format stored in the context */                              
                                result =  coreotn_tx_ho_chnl_prov(digi_handle->coreotn_handle,
                                                                  local_ho_odu_chnl_ptr->chnl_id,
                                                                  (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO,
                                                                  local_ho_odu_chnl_ptr->odu_type,
                                                                  (util_global_odu_line_payload_t)digi_handle->var.odu_chnl_payload[DIGI_NUM_HO_ODU_CHNL_MAX+local_ho_odu_chnl_ptr->chnl_id],
                                                                  TRUE,
                                                                  TRUE);
                            }

                            if (PMC_SUCCESS == result)
                            {
                                result = coreotn_tx_ho_chnl_activate(digi_handle->coreotn_handle,
                                                                     local_ho_odu_chnl_ptr->chnl_id, 
                                                                     (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO);                                                  
                            } 
                            
                            digi_handle->var.mo_prov_state_tx[local_ho_odu_chnl_ptr->chnl_id] = TRUE;
                                                                   
                        }
    
                    }
                }




                /* Transmit path */
                if (PMC_SUCCESS == result &&
                    prov_activate_tx == TRUE)
                {
                    result = digi_otn_server_tx_lo_prov(digi_handle,
                                                        local_ho_odu_chnl_ptr,
                                                        chnl_id,
                                                        DIGI_OTN_MUX_STAGES_TWO,
                                                        odu_container,
                                                        num_client_odu0,
                                                        client_bitrate,
                                                        mapping_type,
                                                        tx_trib_slot_mask,
                                                        tx_trib_port,
                                                        payload_mode,
                                                        prov_ho_cfg);
                }   
                
                /* Receive path */
                if (PMC_SUCCESS == result &&
                    prov_activate_rx == TRUE)
                {
                    result = digi_otn_server_rx_lo_prov(digi_handle,
                                                        local_ho_odu_chnl_ptr,
                                                        chnl_id,
                                                        DIGI_OTN_MUX_STAGES_TWO,
                                                        odu_container,
                                                        num_client_odu0,
                                                        client_bitrate,
                                                        mapping_type,
                                                        rx_trib_slot_mask,
                                                        rx_trib_port,
                                                        payload_mode,
                                                        prov_ho_cfg);
                }                                                                                                           
            }                                    
        }
        else {
            PMC_RETURN(DIGI_ERR_NO_SW_CONTENT);
        }  
    }        
    
    if (PMC_SUCCESS == result)
    {
    
        *out_chnl_ctxt_pptr = (digi_otn_odu_chnl_t *)lo_odu_struct_ptr;
    
        /* update odu_struct */
        lo_odu_struct_ptr->mem_ptr->chnl_id = chnl_id;
        lo_odu_struct_ptr->mem_ptr->odu_type = odu_container;
        lo_odu_struct_ptr->mem_ptr->payload_format = (util_global_odu_line_payload_t)payload_mode; 
        lo_odu_struct_ptr->active = TRUE;
        lo_odu_struct_ptr->mem_ptr->mapping_mode = mapping_type;
        lo_odu_struct_ptr->mem_ptr->client_bitrate = client_bitrate;
        /*inherit lineotn_src context from ho channel*/
        lo_odu_struct_ptr->switch_data.oduk_data.lineotn_src = ho_odu_struct_ptr->switch_data.oduk_data.lineotn_src;
    
        if(prov_activate_rx)
        {
            for (i = 0; i < 3; i++)
            {
                lo_odu_struct_ptr->mem_ptr->rx_trib_loc_mask[i] = rx_trib_slot_mask[i];
            }
        }

        if(prov_activate_tx)
        {
            for (i = 0; i < 3; i++)
            {
                lo_odu_struct_ptr->mem_ptr->tx_trib_loc_mask[i] = tx_trib_slot_mask[i];
            }
        }


        if(new_chnl)
        {
            if ((UINT32)ho_odu_struct_ptr->mem_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU)
            {
                lo_odu_struct_ptr->mem_ptr->odu_level = ODU_STRUCT_LEVEL_LO_ODU;
                lo_odu_struct_ptr->mem_ptr->mux_stage = (odu_struct_otn_mux_stages_t)DIGI_OTN_MUX_STAGES_TWO;
               
                /* oduksw port channel data */
                lo_odu_struct_ptr->switch_data.oduk_data.channel = chnl_id;  
                
                /* This is the lowest ODU level. Stage 3B will have the same channel information.
                ** Initialize odu_struct for stg3B 
                */
                if(new_chnl)
                {
                    /* if s3b_odu_struct_ptr is not used, digi_s3b_odu_struct_chnl_get
                       could be safely casted to 'void' because it asserts on
                       error .*/
                    s3b_odu_struct_ptr = digi_s3b_odu_struct_chnl_get(digi_handle, chnl_id);
                    /* coreotn_stg3b_odu_level_set will assert if there are
                       any problems. So, we can safely use 'void' cast here if
                       we do not need any return here. */
                    ( void )coreotn_stg3b_odu_level_set(digi_handle->coreotn_handle, chnl_id, ODU_STRUCT_LEVEL_LO_ODU);
                }
                
                if(prov_activate_tx)
                {
                    /* get all calendar entries that are assigned to this LO channel */
                    result = coreotn_db_lo_cal_entry_all_get(digi_handle->coreotn_handle,
                                                             chnl_id,
                                                             0, /*TX DB*/
                                                             lo_cal_entry_ptr_tx,
                                                             &lo_num_cal_entries);
                }
                
                if(prov_activate_rx)
                {
                    /* get all calendar entries that are assigned to this LO channel */
                    result = coreotn_db_lo_cal_entry_all_get(digi_handle->coreotn_handle,
                                                             chnl_id,
                                                             1, /*RX DB*/
                                                             lo_cal_entry_ptr_rx,
                                                             &lo_num_cal_entries);               
                }
            } 
            else if ((UINT32)ho_odu_struct_ptr->mem_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
            { 
                lo_odu_struct_ptr->mem_ptr->odu_level = ODU_STRUCT_LEVEL_MO_ODU;
                lo_odu_struct_ptr->mem_ptr->mux_stage = (odu_struct_otn_mux_stages_t)DIGI_OTN_MUX_STAGES_ONE;
                
                /* If this is the last stage of muxing, set the odu_3b_ctxt */
                if (payload_mode == DIGI_ODU_UNCHANNELIZED)
                {
                    /* initialize odu_struct for stg3B */

                    /* digi_s3b_odu_struct_chnl_get will assert if there are
                       any problems. So, we can safely use 'void' cast here if
                       we do not need any return here. */
                    s3b_odu_struct_ptr = digi_s3b_odu_struct_chnl_get(digi_handle, chnl_id);
                    
                    /* coreotn_stg3b_odu_level_set will assert if there are
                       any problems. So, we can safely use 'void' cast here if
                       we do not need any return here. */
                    ( void )coreotn_stg3b_odu_level_set(digi_handle->coreotn_handle, chnl_id, ODU_STRUCT_LEVEL_MO_ODU);
                }
                else {
                
                    /* this struct will be a MO. Initialize its sub-container structure */
                    /* LO channel information */
                    if (prov_activate_rx)
                    {
                        lo_odu_struct_ptr->mem_ptr->trib_slot_ctxt.num_sub_container_rx = 0; 
                        
                        for (i = 0; i < DIGI_NUM_MAX_TS; i++)
                        {
                            lo_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_rx[i] = DIGI_DCI_CHANNEL_UNASSIGNED;
                            lo_odu_struct_ptr->mem_ptr->trib_slot_ctxt.rx_trib_port[i] = DIGI_TRIBPORT_UNUSED;                  
                        }
                    }
                    
                    if(prov_activate_tx)
                    {  
                        lo_odu_struct_ptr->mem_ptr->trib_slot_ctxt.num_sub_container_tx = 0; 
                    
                        for (i = 0; i < DIGI_NUM_MAX_TS; i++)
                        {
                            lo_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_tx[i] = DIGI_DCI_CHANNEL_UNASSIGNED;             
                            lo_odu_struct_ptr->mem_ptr->trib_slot_ctxt.tx_trib_port[i] = DIGI_TRIBPORT_UNUSED;                 
                        }
                    }
                }
                  
                /* oduksw port channel data */
                lo_odu_struct_ptr->switch_data.oduk_data.channel = chnl_id;                                   
            }
        } /* end of if(new_chnl) */

        if ((UINT32)ho_odu_struct_ptr->mem_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU)
        {
            if(prov_activate_tx)
            {
                /* get all calendar entries that are assigned to this LO channel */
                result = coreotn_db_lo_cal_entry_all_get(digi_handle->coreotn_handle,
                                                         chnl_id,
                                                         0, /*TX DB*/
                                                         lo_cal_entry_ptr_tx,
                                                         &lo_num_cal_entries);
            }
            
            if(prov_activate_rx)
            {
                /* get all calendar entries that are assigned to this LO channel */
                result = coreotn_db_lo_cal_entry_all_get(digi_handle->coreotn_handle,
                                                         chnl_id,
                                                         1, /*RX DB*/
                                                         lo_cal_entry_ptr_rx,
                                                         &lo_num_cal_entries);
            
            }
        }
        else if((UINT32)ho_odu_struct_ptr->mem_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
        {
            if(prov_activate_tx)
            {
                /* get all calendar entries that are assigned to this LO channel */
                result = coreotn_db_mo_cal_entry_all_get(digi_handle->coreotn_handle,
                                                         chnl_id,
                                                         0, /*TX DB*/
                                                         lo_cal_entry_ptr_tx,
                                                         &lo_num_cal_entries);
            }
        
            if(prov_activate_rx)
            {
                /* get all calendar entries that are assigned to this LO channel */
                result = coreotn_db_mo_cal_entry_all_get(digi_handle->coreotn_handle,
                                                         chnl_id,
                                                         1, /*RX DB*/
                                                         lo_cal_entry_ptr_rx,
                                                         &lo_num_cal_entries);
            }
        }

        /* Make sure that lo_num_cal_entries is actually properly initialized
           before it's used. */
        PMC_ASSERT(lo_num_cal_entries != 0xffffffff, DIGI_ERR_INVALID_ARG, 0, 0);
 
        /* assign calendar entry mask for the current channel */
        if (PMC_SUCCESS == result)
        {
            /* get number of tribslots in the LO channel */
            if (payload_mode == DIGI_ODU_TS_1G25)
            {
                lo_odu_struct_ptr->mem_ptr->num_tribslots = lo_num_cal_entries;
            }
            else if (payload_mode == DIGI_ODU_TS_2G5)
            {
                lo_odu_struct_ptr->mem_ptr->num_tribslots = lo_num_cal_entries/2;
            }    
        
            if(prov_activate_tx)
            {
                for (i = 0; i < lo_num_cal_entries; i++)
                {
                    lo_odu_struct_ptr->mem_ptr->calendar_entry_mask_tx[(lo_cal_entry_ptr_tx[i])/32] = lo_odu_struct_ptr->mem_ptr->calendar_entry_mask_tx[(lo_cal_entry_ptr_tx[i])/32] + (1 << (lo_cal_entry_ptr_tx[i]%32));
                 
                }
            }

            if(prov_activate_rx)
            {
                for (i = 0; i < lo_num_cal_entries; i++)
                {
                    lo_odu_struct_ptr->mem_ptr->calendar_entry_mask_rx[(lo_cal_entry_ptr_rx[i])/32] = lo_odu_struct_ptr->mem_ptr->calendar_entry_mask_rx[(lo_cal_entry_ptr_rx[i])/32] + (1 << (lo_cal_entry_ptr_rx[i]%32));
                 
                }
            }
        }
                                           
        if (PMC_SUCCESS == result)
        {
            ho_odu_struct_ptr->mem_ptr->msi_mode = 0;
        
            if(prov_activate_tx == TRUE)
            {
                /* increment as one LO has been added to the parent */
                ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.num_sub_container_tx++;
            }

            if(prov_activate_rx == TRUE)
            {
                ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.num_sub_container_rx++;
            }


            if(prov_activate_tx == TRUE)
            {
                if (ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_tx[tx_trib_port] == DIGI_DCI_CHANNEL_UNASSIGNED 
                    && ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.tx_trib_port[tx_trib_port] == DIGI_TRIBPORT_UNUSED)
                {
                    ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_tx[tx_trib_port] = chnl_id;
                    ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.tx_trib_port[tx_trib_port] = tx_trib_port;
                }
                else if (ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_tx[tx_trib_port] == DIGI_DCI_CHANNEL_UNASSIGNED 
                         && ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.tx_trib_port[tx_trib_port] != DIGI_TRIBPORT_UNUSED)
                {
                    /* tributary port data has been modified with MSI value */
                    ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_tx[tx_trib_port] = chnl_id;
                    
                    /* update coreotn context to reflect this */
                    result = coreotn_ts_port_ctxt_update(digi_handle->coreotn_handle,
                                                         chnl_id,
                                                         ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.tx_trib_port[tx_trib_port],
                                                         DIGI_TRIBPORT_UNUSED,
                                                         (coreotn_mux_stage_t)mux_stage); 
                    
                }                  
            }

            if(prov_activate_rx == TRUE && PMC_SUCCESS == result)
            {
                if (ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_rx[rx_trib_port] == DIGI_DCI_CHANNEL_UNASSIGNED 
                    && ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.rx_trib_port[rx_trib_port] == DIGI_TRIBPORT_UNUSED)
                {
                    ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_rx[rx_trib_port] = chnl_id;
                    ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.rx_trib_port[rx_trib_port] = rx_trib_port;
                }
                else if (ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_rx[rx_trib_port] == DIGI_DCI_CHANNEL_UNASSIGNED 
                         && ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.rx_trib_port[rx_trib_port] != DIGI_TRIBPORT_UNUSED)
                {
                    ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_rx[rx_trib_port] = chnl_id;
                    
                    /* update coreotn context to reflect this */
                    result = coreotn_ts_port_ctxt_update(digi_handle->coreotn_handle,
                                                         chnl_id,
                                                         DIGI_TRIBPORT_UNUSED,
                                                         ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.rx_trib_port[rx_trib_port],
                                                         (coreotn_mux_stage_t)mux_stage);
                }
            }
        }
    } 

    /* update handle state */
    if (PMC_SUCCESS == result)
    {
        lo_odu_struct_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED;
        if (s3b_odu_struct_ptr != NULL)
        {
            s3b_odu_struct_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED;
        }
    }
     
    PMC_RETURN(result);
} /* digi_otn_server_lo_prov_internal */




/*******************************************************************************
* digi_otn_server_tx_lo_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies detailed configuration for transmit low order
*   ODUk processing blocks.\n\n
*
*   When this function is used to perform 1 stage multiplexing:
*   This function is used to provision a LO ODUk framer channel into a HO ODUk
*   framer channel.  
*
*   When this function is used to perform 2 stage multiplexing:
*   This function is used to provision a LO ODUk framer channel into a MO ODUk
*   framer channel as well as to provision a MO ODUk framer channel into a
*   HO ODUk framer channel.  
*
*   SW driver internally describes ODU framer configuration using an ODU struct
*   for low order container.\n\n
*
*   This function updates the tributary slot assignment and tributary port data
*   of the HO ODU struct that the LO ODU struct is associated with.\n\n
*
*   In Direct Device Configuration mode - This function internally generates a
*   TRQ containing the requested configuration data and calls the FW Host
*   Message for processing the HO/LO ODU struct.\n\n
*
*   In Pending mode - This function updates LO ODU struct and the parent HO ODU
*   struct with the desired configuration data to be applied in the future.\n\n
*
*   When operating in pending mode, the OUTPUT parameter out_chnl_ctxt_pptr is
*   an input.  It is the caller's responsibility to allocate the ODU struct
*   pool resource and communicate it to this API using the out_chnl_ctxt_pptr
*   parameter.\n\n
*
*   The SW driver will initially specify the payload type of the signal for
*   payload mode of 1G25 or 2G5 Tributary slots for Payload Type 20 or 21 as
*   defined in ITU G.709.\n\n
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance.
*   *local_ho_odu_chnl_ptr  - pointer to higher order channel containing the
*                             low order framer to be provisioned.
*   lo_chnl_id              - LO channel ID.
*   mux_stage               - Enum for MUX stage. See digi_otn_mux_stages_t\n                               
*   odu_container           - Enum, ODUk container type. See digi_oduk_t.
*   num_client_odu0         - number of ODU0 in ODUFlex container. Only valid if 
*                             'odu_container' is set to DIGI_ODUK_FLEX.
*   client_bitrate          - For DIGI_ODUKSW_STREAM_CBR_ODUFLEX, specify the client
*                             bit rate in bps.  This is the ODU client rate.
*                             (ODU rate = unmapped client rate * (239/238))
*                             For all the other LO ODU types, set to 0.  
*   mapping_type            - payload mapping mode. See digi_otn_mapping_type_t.
*   tx_trib_slot_mask       - transmit tributary slots low order container will use 
*                             in higher order payload.
*                             For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, the number of
*                             bits set in this mask should match the number of 
*                             tributary slots in the ODUFlex container.
*   trib_port               - tributary port number that will carry the 
*                             tributary slot data.
*   payload_mode            - System Side Payload Format\n
*                             0: Unchannelized\n
*                             1: Channelized 1G25 rate tributary slots\n
*                             2: Channelized 2G5 rate tributary slots
*   prov_ho_cfg             - TRUE : provision MUX-LO, TFRM config
*                             FALSE : preserve current MUX-LO, TFRM config
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_tx_lo_prov(digi_handle_t *digi_handle,
                                             odu_chnl_t *local_ho_odu_chnl_ptr,
                                             UINT32 lo_chnl_id,
                                             digi_otn_mux_stages_t mux_stage,
                                             util_global_odukp_type_t odu_container,
                                             UINT32 num_client_odu0,
                                             DOUBLE client_bitrate,
                                             util_global_mapping_mode_t mapping_type,
                                             UINT32 tx_trib_slot_mask[3],
                                             UINT32 trib_port,
                                             digi_odu_line_payload_t payload_mode,
                                             BOOL prov_ho_cfg)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();
        
    /* first hold the channel in reset */
    if(PMC_SUCCESS == result)
    {
        result = coreotn_tx_lo_chnl_deactivate(digi_handle->coreotn_handle,
                                               lo_chnl_id, 
                                               local_ho_odu_chnl_ptr->chnl_id,
                                               (coreotn_mux_stage_t)mux_stage);
    }
                                         
    /* provision a LO channel */                                   
    if (PMC_SUCCESS == result)
    {
        result = coreotn_tx_lo_chnl_prov(digi_handle->coreotn_handle,
                                         lo_chnl_id,
                                         (coreotn_mux_stage_t)mux_stage,
                                         odu_container,
                                         num_client_odu0,
                                         (coreotn_mapping_type_t)mapping_type,
                                         tx_trib_slot_mask,
                                         trib_port,
                                         (util_global_odu_line_payload_t)payload_mode,
                                         local_ho_odu_chnl_ptr->odu_type,
                                         local_ho_odu_chnl_ptr->chnl_id,
                                         client_bitrate,
                                         prov_ho_cfg);
    }
    /* activate the channel */  
    if (PMC_SUCCESS == result)
    {
        result = coreotn_tx_lo_chnl_activate(digi_handle->coreotn_handle,
                                             lo_chnl_id,
                                             local_ho_odu_chnl_ptr->chnl_id,
                                             (coreotn_mux_stage_t)mux_stage);
    }      
    
    PMC_RETURN(result);
} /* digi_otn_server_tx_lo_prov */

/*******************************************************************************
* digi_otn_server_rx_lo_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies detailed configuration for transmit low order
*   ODUk processing blocks.\n\n
*
*   When this function is used to perform 1 stage multiplexing:
*   This function is used to provision a LO ODUk framer channel into a HO ODUk
*   framer channel.  
*
*   When this function is used to perform 2 stage multiplexing:
*   This function is used to provision a LO ODUk framer channel into a MO ODUk
*   framer channel as well as to provision a MO ODUk framer channel into a
*   HO ODUk framer channel.  
*
*   SW driver internally describes ODU framer configuration using an ODU struct
*   for low order container.\n\n
*
*   This function updates the tributary slot assignment and tributary port data
*   of the HO ODU struct that the LO ODU struct is associated with.\n\n
*
*   In Direct Device Configuration mode - This function internally generates a
*   TRQ containing the requested configuration data and calls the FW Host
*   Message for processing the HO/LO ODU struct.\n\n
*
*   In Pending mode - This function updates LO ODU struct and the parent HO ODU
*   struct with the desired configuration data to be applied in the future.\n\n
*
*   When operating in pending mode, the OUTPUT parameter out_chnl_ctxt_pptr is
*   an input.  It is the caller's responsibility to allocate the ODU struct
*   pool resource and communicate it to this API using the out_chnl_ctxt_pptr
*   parameter.\n\n
*
*   The SW driver will initially specify the payload type of the signal for
*   payload mode of 1G25 or 2G5 Tributary slots for Payload Type 20 or 21 as
*   defined in ITU G.709.\n\n
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance.
*   *local_ho_odu_chnl_ptr  - pointer to higher order channel containing the
*                             low order framer to be provisioned.
*   lo_chnl_id              - LO channel ID.
*   mux_stage               - Enum, MUX stage. See digi_otn_mux_stages_t\n                              
*   odu_container           - Enum, ODUk container type. See digi_oduk_t.
*   num_client_odu0         - number of ODU0 in ODUFlex container. Only valid if 
*                             'odu_container' is set to DIGI_ODUK_FLEX.
*   client_bitrate          - For DIGI_ODUKSW_STREAM_CBR_ODUFLEX, specify the client
*                             bit rate in bps.  This is the ODU client rate.
*                             (ODU rate = unmapped client rate * (239/238))
*                             For all the other LO ODU types, set to 0.  
*   mapping_type            - payload mapping mode. See digi_otn_mapping_type_t.
*   rx_trib_slot_mask       - receive tributary slots low order container will use 
*                             in higher order payload.
*                             For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, the number of
*                             bits set in this mask should match the number of 
*                             tributary slots in the ODUFlex container.
*   trib_port               - tributary port number that will carry the 
*                             tributary slot data.
*   payload_mode            - System Side Payload Format\n
*                             0: Unchannelized\n
*                             1: Channelized 1G25 rate tributary slots\n
*                             2: Channelized 2G5 rate tributary slots
*   prov_ho_cfg             - TRUE : provision DMX-LO, ODUJAT, ODUKSC, RFRM configs
*                             FALSE : preserve current DMX-LO, ODUJAT, ODUKSC configs
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_rx_lo_prov(digi_handle_t *digi_handle,
                                             odu_chnl_t *local_ho_odu_chnl_ptr,
                                             UINT32 lo_chnl_id,
                                             digi_otn_mux_stages_t mux_stage,
                                             util_global_odukp_type_t odu_container,
                                             UINT32 num_client_odu0,
                                             DOUBLE client_bitrate,
                                             util_global_mapping_mode_t mapping_type,
                                             UINT32 rx_trib_slot_mask[3],
                                             UINT32 trib_port,
                                             digi_odu_line_payload_t payload_mode,
                                             BOOL prov_ho_cfg)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();

    /* first hold the channel in reset */
    
    if(PMC_SUCCESS == result)
    {
        result = coreotn_rx_lo_chnl_deactivate(digi_handle->coreotn_handle,
                                               lo_chnl_id, 
                                               local_ho_odu_chnl_ptr->chnl_id,
                                               (coreotn_mux_stage_t)mux_stage);
    }
    PMC_ATOMIC_YIELD(digi_handle,0);
    
    if (PMC_SUCCESS == result)
    {
        result = coreotn_rx_lo_chnl_prov(digi_handle->coreotn_handle,
                                         lo_chnl_id,
                                         (coreotn_mux_stage_t)mux_stage,
                                         odu_container,
                                         num_client_odu0,
                                         client_bitrate,
                                         (coreotn_mapping_type_t)mapping_type,
                                         rx_trib_slot_mask,
                                         trib_port,
                                         (util_global_odu_line_payload_t)payload_mode,
                                         local_ho_odu_chnl_ptr->odu_type,
                                         local_ho_odu_chnl_ptr->chnl_id,
                                         prov_ho_cfg);
    }
    PMC_ATOMIC_YIELD(digi_handle,0);
    
    /* activate the channel */  
    if (PMC_SUCCESS == result)
    {
        result = coreotn_rx_lo_chnl_activate(digi_handle->coreotn_handle,
                                             lo_chnl_id, 
                                             local_ho_odu_chnl_ptr->chnl_id,
                                             (coreotn_mux_stage_t)mux_stage,
                                             prov_ho_cfg);
    }    
    
    PMC_RETURN(result);
      
} /* digi_otn_server_rx_lo_prov */

/*******************************************************************************
* digi_otn_server_lo_ch_id_and_trib_port_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to internally assign LO channel ID and trib port.
*   LO channel ID will be determined by 'tx_trib_slot_mask'. 
*   'trib_port' will be determined by *_trib_slot_mask in each direction. 
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   ho_odu_struct_ptr   - HO channel handle 
*   tx_trib_slot_mask   - tributary slots transmit low order container will use 
*                         in higher order payload.
*                         For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, the number of
*                         bits set in this mask should match the number of 
*                         tributary slots in the ODUFlex container.
*   rx_trib_slot_mask   - tributary slots receive low order container will use 
*                         in higher order payload.
*                         For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, the number of
*                         bits set in this mask should match the number of 
*                         tributary slots in the ODUFlex container.
*   ho_cal_entry_ptr    - an array of HO calendar entries
*   lo_payload_mode     - Enum, payload format of the LO ODU channel.
*                         This is used to determine if MO channel can be
*                         assigned a channel ID that has already been assigned
*                         to a LO channel.
*   
*
* OUTPUTS:
*   *chnl_id            - pointer to a LO channel ID
*   *tx_trib_port       - pointer to transmit trib port number
*   *rx_trib_port       - pointer to receive trib port number
*   prov_rx             - provision and activate the RX segment
*   prov_tx             - provision and activate the TX segment
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_lo_ch_id_and_trib_port_get(digi_handle_t *digi_handle,
                                                             odu_struct_t * ho_odu_struct_ptr,   
                                                             UINT32 tx_trib_slot_mask[3],
                                                             UINT32 rx_trib_slot_mask[3],
                                                             UINT32 ho_cal_entry_ptr[DIGI_SCHD_96_ENTRY],
                                                             digi_odu_line_payload_t lo_payload_mode,
                                                             UINT32 *chnl_id,
                                                             UINT32 *tx_trib_port,
                                                             UINT32 *rx_trib_port,
                                                             BOOL *prov_rx,
                                                             BOOL *prov_tx)
{
    PMC_ERROR result = PMC_SUCCESS;

    UINT32 i, j;
    BOOL8 valid_rx_mask;
    BOOL8 valid_tx_mask;
    UINT32 tx_cnt = 0;
    UINT32 rx_cnt = 0;

    UINT32 lo_chnl_id_rx = 0;
    UINT32 lo_chnl_id_tx = 0;
    BOOL8 new_channel;
    UINT32 first_ts = 0;

    UINT32 rx_num_cal_entries = 0xffffffff;
    UINT32 tx_num_cal_entries = 0xffffffff;
    UINT32 rx_cal_entry_ptr[UTIL_GLOBAL_MAX_NUM_CAL_ENTRY];
    UINT32 tx_cal_entry_ptr[UTIL_GLOBAL_MAX_NUM_CAL_ENTRY];

    UINT32 ho_cal_entries[UTIL_GLOBAL_MAX_NUM_CAL_ENTRY];
    UINT32 tx_mo_chnl_ids[UTIL_GLOBAL_MAX_NUM_CAL_ENTRY];
    UINT32 tx_lo_chnl_ids[UTIL_GLOBAL_MAX_NUM_CAL_ENTRY];
    UINT32 rx_mo_chnl_ids[UTIL_GLOBAL_MAX_NUM_CAL_ENTRY];
    UINT32 rx_lo_chnl_ids[UTIL_GLOBAL_MAX_NUM_CAL_ENTRY];
    UINT32 ho_chnl_ids[UTIL_GLOBAL_MAX_NUM_CAL_ENTRY];
        
    UINT32 num_ho_entries;
    BOOL mo_match;

    BOOL8 direction;
    UINT32 ultimate_ho_chnl_id;
    BOOL8 new_entry_found;
    UINT32 mo_ch;
    *chnl_id = DIGI_DCI_CHANNEL_UNASSIGNED;

    PMC_ENTRY();
  
    if (TRUE != pmc_is_digi_rev_a_revision(&digi_handle->base))
    {

        valid_rx_mask = FALSE;
        valid_tx_mask = FALSE;

        for(i=0;i<3;i++)
        {
            if(tx_trib_slot_mask[i] != 0)
            {
                valid_tx_mask = TRUE;
            }

            if(rx_trib_slot_mask[i] != 0)
            {
                valid_rx_mask = TRUE;
            }

        }
                
        /* First, perform a look-up with tx_trib_slot_mask and rx_trib_slot_mask to
           see if this channel has already been provisioned in RX or TX */
        if(valid_rx_mask)
        {
            for(i=0;i<3;i++)
            {
                for(j=0;j<32;j++)
                {
                    if(((rx_trib_slot_mask[i] >> j) & 1) == 1)
                    {
                        first_ts = (i*32)+ j;
                        break;
                    }                       
                }
            }
                             
            result = coreotn_db_ts_port_to_lo_id_get(digi_handle->coreotn_handle,
                                                     1, /*RX*/
                                                     ho_odu_struct_ptr->mem_ptr->odu_level,
                                                     ho_odu_struct_ptr->switch_data.oduk_data.channel,
                                                     first_ts,
                                                     rx_cal_entry_ptr,
                                                     &rx_num_cal_entries,
                                                     &lo_chnl_id_rx);

        }

        if(result == PMC_SUCCESS)
        {
            if(valid_tx_mask)
            {

                for(i=0;i<3;i++) 
                {
                    for(j=0;j<32;j++)
                    {
                        if(((tx_trib_slot_mask[i] >> j) & 1) == 1)
                        {
                            first_ts = (i*32)+ j;
                            break;
                        }
                        
                    }
                }

                result = coreotn_db_ts_port_to_lo_id_get(digi_handle->coreotn_handle,
                                                         0, /*TX*/
                                                         ho_odu_struct_ptr->mem_ptr->odu_level,
                                                         ho_odu_struct_ptr->switch_data.oduk_data.channel,
                                                         first_ts ,
                                                         tx_cal_entry_ptr,
                                                         &tx_num_cal_entries,
                                                         &lo_chnl_id_tx);
            }

            if (PMC_SUCCESS == result)
            {
                if( (valid_rx_mask && rx_num_cal_entries == 0 && !valid_tx_mask) ||
                    (valid_tx_mask && tx_num_cal_entries == 0 && !valid_rx_mask) ||
                    (valid_tx_mask && tx_num_cal_entries == 0 && valid_rx_mask && rx_num_cal_entries == 0))
                {
                    new_channel = TRUE;
                }
                else
                {
                    new_channel = FALSE;
                }
                
                if(valid_rx_mask && rx_num_cal_entries == 0)
                {
                    *prov_rx = TRUE;
                }
                else
                {
                    *prov_rx = FALSE;
                }
                
                if(valid_tx_mask && tx_num_cal_entries == 0)
                {
                    *prov_tx = TRUE;
                }
                else
                {
                    *prov_tx = FALSE;
                } 
            }

        }

        if (PMC_SUCCESS == result)
        {
            if(new_channel == FALSE)
            {
                /*if this is not a new channel, the channel ID can come from the 
                  RX/TX that was already provisioned */
            
                if(rx_num_cal_entries == 0)
                {
                    *chnl_id = lo_chnl_id_tx;
                }
                else if(tx_num_cal_entries == 0)
                {
                    *chnl_id = lo_chnl_id_rx;
                }
            
            }
            else
            {
                if(result == PMC_SUCCESS)
                {
                    if((UINT32)ho_odu_struct_ptr->mem_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
                    {
                        ultimate_ho_chnl_id = ho_odu_struct_ptr->switch_data.oduk_data.channel;
                                         
                    }
                    else
                    {
                        if(valid_tx_mask)
                        {
                            direction = 0;
                        }
                        else
                        {
                            direction = 1;
                        }
            
                        result = coreotn_db_ho_chnl_id_get(digi_handle->coreotn_handle,
                                                           direction,
                                                           (util_global_odu_level_t)ho_odu_struct_ptr->mem_ptr->odu_level,
                                                           ho_odu_struct_ptr->switch_data.oduk_data.channel,
                                                           &ultimate_ho_chnl_id); 
                         
                    }
                }
                        
                if(result == PMC_SUCCESS)
                {
                    result = coreotn_db_ho_cal_entries_mo_lo_chnl_get(digi_handle->coreotn_handle,
                                                                      ultimate_ho_chnl_id,
                                                                      0,
                                                                      ho_cal_entries,
                                                                      &num_ho_entries,
                                                                      ho_chnl_ids,
                                                                      tx_mo_chnl_ids,
                                                                      tx_lo_chnl_ids);        
                }          
            
            
                if(result == PMC_SUCCESS)
                {
                    result = coreotn_db_ho_cal_entries_mo_lo_chnl_get(digi_handle->coreotn_handle,
                                                                      ultimate_ho_chnl_id,
                                                                      1,
                                                                      ho_cal_entries,
                                                                      &num_ho_entries,
                                                                      ho_chnl_ids,
                                                                      rx_mo_chnl_ids,
                                                                      rx_lo_chnl_ids);        
                }      
            
                if (PMC_SUCCESS == result)
                {
                    /* look up a new channel id */
                    if ((UINT32)ho_odu_struct_ptr->mem_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
                    {
                        /* if MO must select a channel not occupied by LOs or MOs.  It's important to
                        not select LO channels, even for lo_payload_mode != UTIL_GLOBAL_ODU_UNCHANNELIZED 
                        in the event of a payload type transition */ 
                        i=0;
                        new_entry_found = FALSE;
                        while (new_entry_found == FALSE && i < num_ho_entries)
                        {
                            UINT32 ho_cal_entry;
                            ho_cal_entry = ho_cal_entries[i];
                            
                            new_entry_found = TRUE;
                            
                            for(j=0;j<num_ho_entries;j++)
                            {
                                if ((ho_cal_entry == tx_mo_chnl_ids[j]) 
                                    || (ho_cal_entry == rx_mo_chnl_ids[j])
                                    || (ho_cal_entry == tx_lo_chnl_ids[j])
                                    || (ho_cal_entry == rx_lo_chnl_ids[j]))
                                {
                                    new_entry_found = FALSE;
                                    break;
                                }
                            }
                            
                            if(new_entry_found == TRUE)
                            {
                                *chnl_id = ho_cal_entry;
                                break;
                            }
                            
                            i++;
                        }   
                    }
                    else if((UINT32)ho_odu_struct_ptr->mem_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU)
                    {
                        /*LO channels must always:
                           - chose it's parent MO channel if available
                           - then select from pool (must not pick occupied MO or LO channel)
                           - check for MO is regardless of channelization to support PT transition case */

                        /*test MO entry against other LO channels*/
                        mo_ch = ho_odu_struct_ptr->switch_data.oduk_data.channel;

                        mo_match = FALSE;
                        for(j=0;j<num_ho_entries;j++)
                        {
                            if(mo_ch == tx_lo_chnl_ids[j] ||
                               mo_ch == rx_lo_chnl_ids[j])
                            {
                                mo_match = TRUE;
                            }
                        }
                        
                        if(mo_match == FALSE)
                        {
                            *chnl_id = mo_ch;
                        }

                        i=0; 
                        new_entry_found = FALSE;
                        while (mo_match == TRUE && new_entry_found == FALSE && i < num_ho_entries)
                        {                   
                            new_entry_found = TRUE;
                    
                            for(j=0;j<num_ho_entries;j++)
                            {
                                if((ho_cal_entries[i] == tx_mo_chnl_ids[j]) ||
                                   (ho_cal_entries[i] == rx_mo_chnl_ids[j]) ||
                                   (ho_cal_entries[i] == tx_lo_chnl_ids[j]) ||
                                   (ho_cal_entries[i] == rx_lo_chnl_ids[j]))
                                {
                                    new_entry_found = FALSE;
                                }                                                                                          
                            }
                    
                            if(new_entry_found == TRUE)
                            {
                                *chnl_id = ho_cal_entries[i];
                            }
                    
                            i++;
                        }  
                    } 
                }
            }
        }

    }
    else
    {
        for (i = 0; i < DIGI_SCHD_96_ENTRY; i++) 
        {
            if ((tx_trib_slot_mask[i/32] >> (i%32)) & 1) 
            {
                *chnl_id = ho_cal_entry_ptr[i]; 
                break;
            }
        }
        
        /* set variables to prov and activate both tx and rx */
        *prov_rx = TRUE;
        *prov_tx = TRUE;


    }

    if (PMC_SUCCESS == result)
    {    
        if (*chnl_id == DIGI_DCI_CHANNEL_UNASSIGNED)
        {
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        }
        
        for (i = 0; i < DIGI_SCHD_96_ENTRY; i++) 
        {
            if ((tx_trib_slot_mask[i/32] >> (i%32)) & 1) 
            {
                if (tx_cnt == 0) 
                {
                    *tx_trib_port = i;
                }
                tx_cnt++;
                break;
            }   
        }
        
        for (i = 0; i < DIGI_SCHD_96_ENTRY; i++) 
        {
            if ((rx_trib_slot_mask[i/32] >> (i%32)) & 1) 
            {
                if (rx_cnt == 0) 
                {
                    *rx_trib_port = i;
        
                    if (*chnl_id == DIGI_DCI_CHANNEL_UNASSIGNED)
                    {
                        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                    }
                }
                rx_cnt++;
                break;
            }   
        }
    }
    
    PMC_RETURN(result);
} /* digi_otn_server_lo_ch_id_and_trib_port_get */
#endif /* DOXYGEN_PUBLIC_ONLY */

/*******************************************************************************
* digi_enet_line_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies basic bidirectional mode configuration for a 10GE/
*   40GE/100GE signal passing between an optical module and the CPB subsystem.\n\n
*
*   The function specifies the internal device resources to process this signal
*   using the dsi_chnl argument. The ENET_SYS resource for processing a
*   dsi_chnl has a 1:1 mapping with the dsi_chnl.\n\n
*
*   Ethernet modes are defined in the digi_enet_mode_t enum type.  Only modes
*   that contain "SERDES" may be used with this function. "MAPOTN" modes are
*   invalid with this API.\n\n
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_ctxt_ptr         - Port datapath handle defining the physcial SerDes
*                            to configure the ENET_LINE resource against.\n
*   mode                   - Enum, ENET modes when connected to Line
*                            Serdes.  Only modes containing "SERDES" may be used.
*
* OUTPUTS:
*   **chnl_ctxt_pptr       - a pointer to a pointer to a digi_enet_client_chnl_t
*                            structure consisting of a dsi_base_lane, link, and
*                            util_global_cpb_port_data_t that is returned to the
*                            user.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*  The default setting is eFCS stripping when this channel handle is 
*  connected to a mapper resource.. To enable eFCS forwarding the APIs
*  digi_enet_insert_crc_set or digi_enet_crc_forwarding_set can be 
*  used to accomplish that.
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_enet_line_prov(digi_handle_t *digi_handle,
                                     digi_serdes_port_t *port_ctxt_ptr,
                                     digi_enet_mode_t mode,
                                     digi_enet_client_chnl_t **chnl_ctxt_pptr)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* This first call prevents ENET LINE MAC modes from being used in
     * a TRANSMUXPONDER Application */
    rc = digi_enet_line_prov_params_additional_validate(digi_handle, mode);

    if (rc == PMC_SUCCESS) 
    {
        /* check serdes port context */        
        DIGI_SERDES_PORT_CTXT_HANDLE_CHECK(digi_handle, port_ctxt_ptr, rc);
    }

    if (PMC_SUCCESS == rc)
    {   
        rc = digi_enet_line_prov_internal(digi_handle,
                                          port_ctxt_ptr,
                                          mode,
                                          FALSE,
                                          chnl_ctxt_pptr);

    }
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_enet_line_prov */

/*******************************************************************************
* digi_enet_line_mirror_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function is used to configure an enet line mirror port (A port that 
*   will receive traffic that is a duplicate of traffic sent to another port). 
*
*   Only enet_modes DIGI_ENET_SERDES_10GE_MAC and DIGI_ENET_SERDES_40GE_MAC
*   are supported.
*
*   This function applies basic bidirectional mode configuration for a 10GE/
*   40GE signal passing between an optical module and the CPB subsystem.\n\n
*
*   The function specifies the internal device resources to process this signal
*   using the dsi_chnl argument. 
*
*   Ethernet modes are defined in the digi_enet_mode_t enum type.  Only modes
*   that contain "SERDES" may be used with this function. "MAPOTN" modes are
*   invalid with this API.\n\n
*
*   The ENET mirror port and the source ENET channel should have the same 
*   runtime configuration. For example, the IPG, MRU and IRIG settings should
*   be mirrored (see the ENET runtime functions digi_enet_ipg_set, 
*   digi_enet_ipg_set, digi_enet_mru_set and digi_enet_irig_configuration_set.\n\n
*

*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_ctxt_ptr         - Port datapath handle defining the physcial SerDes
*                            to configure the ENET_LINE resource against.\n
*   mode                   - Enum, ENET modes when connected to Line
*                            Serdes.  Only modes containing "SERDES" may be used.
*
* OUTPUTS:
*   **chnl_ctxt_pptr       - a pointer to a pointer to a digi_enet_client_chnl_t
*                            structure consisting of a dsi_base_lane, link, and
*                            util_global_cpb_port_data_t that is returned to the
*                            user.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_enet_line_mirror_prov(digi_handle_t *digi_handle,
                                            digi_serdes_port_t *port_ctxt_ptr,
                                            digi_enet_mode_t mode,
                                            digi_enet_client_chnl_t **chnl_ctxt_pptr)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* This first call prevents ENET LINE MAC modes from being used in
     * a TRANSMUXPONDER Application */
    rc = digi_enet_line_prov_params_additional_validate(digi_handle, mode);

    if (rc == PMC_SUCCESS)
    {
        /* check serdes port context */        
        DIGI_SERDES_PORT_CTXT_HANDLE_CHECK(digi_handle, port_ctxt_ptr, rc);
    }

    if (rc == PMC_SUCCESS && mode != DIGI_ENET_SERDES_40GE_MAC && mode != DIGI_ENET_SERDES_10GE_MAC)
    {
        rc = DIGI_ERR_ENET_INVALID_MIRROR_MODE;
    }

    if (PMC_SUCCESS == rc)
    {   
        rc = digi_enet_line_prov_internal(digi_handle,
                                          port_ctxt_ptr,
                                          mode,
                                          TRUE,     /* mirror mode */
                                          chnl_ctxt_pptr);

    }
    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_enet_line_mirror_prov */

#ifndef DOXYGEN_PUBLIC_ONLY

/*******************************************************************************
* digi_enet_line_prov_internal
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies basic bidirectional mode configuration for a 10GE/
*   40GE/100GE signal passing between an optical module and the CPB subsystem.\n\n
*
*   The function specifies the internal device resources to process this signal
*   using the dsi_chnl argument. The ENET_SYS resource for processing a
*   dsi_chnl has a 1:1 mapping with the dsi_chnl.\n\n
*
*   Ethernet modes are defined in the digi_enet_mode_t enum type.  Only modes
*   that contain "SERDES" may be used with this function. "MAPOTN" modes are
*   invalid with this API.\n\n
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_ctxt_ptr         - Port datapath handle defining the physcial SerDes
*                            to configure the ENET_LINE resource against.\n
*   mode                   - Enum, ENET modes when connected to Line
*                            Serdes.  Only modes containing "SERDES" may be used.
*
*   mirror_mode            - Indicates whether this port will be used to mirror another 
*                            enet line port. See digi_enet_line_mirror_prov for details.
* OUTPUTS:
*   **chnl_ctxt_pptr       - a pointer to a pointer to a digi_enet_client_chnl_t
*                            structure consisting of a dsi_base_lane, link, and
*                            util_global_cpb_port_data_t that is returned to the
*                            user.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_enet_line_prov_internal(digi_handle_t *digi_handle,
                                              digi_serdes_port_t *port_ctxt_ptr,
                                              digi_enet_mode_t mode,
                                              BOOL mirror_mode,
                                              digi_enet_client_chnl_t **chnl_ctxt_pptr)
{
    PMC_ERROR rc = PMC_SUCCESS;

    enet_datapath_t e_mode = LAST_ENET_DATAPATH;
    digi_group_size_t group_size = LAST_DIGI_GRP_SIZE;

    UINT32 link = DIGI_SERDES_XFI_LANES_MAX;
    digi_post_mld_dsi_ctxt_t *post_mld_dsi_ptr = NULL;
    
    digi_serdes_port_def_t *port_def_ptr = NULL;
    digi_serdes_port_mode_t serdes_mode = DIGI_SERDES_PORT_MODE_ANY_LOWPWR;
    digi_mapper_alloc_t map_type = DIGI_MAPPER_ALLOC_UNUSED;
    digi_mapper_alloc_t new_map_type = DIGI_MAPPER_ALLOC_UNUSED;
    
    PMC_ENTRY();


    rc = DIGI_ERR_UNKNOWN;

    port_def_ptr = (digi_serdes_port_def_t*)port_ctxt_ptr;

    /* This first checks to ensure the parameters fall within reasonable
       limits, but also ensures that the number of pins provisioned
       against the port will support the mode */
    rc = digi_enet_line_prov_params_validate(digi_handle,
                                             port_def_ptr,
                                             mode,
                                             chnl_ctxt_pptr);
    if (rc == PMC_SUCCESS) {

        post_mld_dsi_ptr = digi_first_post_mld_dsi_find(digi_handle,
                                                        port_def_ptr->port_uid);

        digi_enet_line_prov_params_convert(mode, &e_mode, &group_size);

        if (post_mld_dsi_ptr == NULL) {

            /* This just indicates that no post_mld_dsi lane has been allocated
               for this port */
            rc = DIGI_ERR_NO_DSI_ALLOC_PROV;

        } else if (post_mld_dsi_ptr->prov_state != DIGI_SERDES_PROV_STATE_UNASSIGNED) {

            rc = DIGI_ERR_SERDES_PORT_ALREADY_PROV;

        }

        if(PMC_SUCCESS == rc) {
            rc = digi_enet_is_link_in_use(digi_handle, 
                                          post_mld_dsi_ptr->lane_index,
                                          group_size,
                                          UTIL_GLOBAL_CPB_PORT_ENET_LINE);
            if ( rc != PMC_SUCCESS) 
                rc = DIGI_ERR_ENET_LINE_RESOURCE_NOT_AVAILABLE;

        } 

        if(PMC_SUCCESS == rc) {
            /* Initialize ENET1/2 DCSU if ENET is in start state */
            digi_dcsu_conditional_init(digi_handle, DIGI_DCSU_INST_ENET1);
            digi_dcsu_conditional_init(digi_handle, DIGI_DCSU_INST_ENET2);

            /* ENET link is 1:1 mapped with post_mld_dsi */
            link = post_mld_dsi_ptr->lane_index;

            rc = digi_enet_line_db_prov_cfg(digi_handle, group_size, link, mirror_mode);

            if(rc != PMC_SUCCESS)
            {
                PMC_RETURN(rc);
            }

            /* Initialize the subsystem */
            digi_enet_line_energy_state_set(digi_handle, link, e_mode, PMC_ENERGY_STATE_REQUEST_RUNNING);

            PMC_ATOMIC_YIELD(digi_handle,0);
            if (rc == PMC_SUCCESS) {
                rc = digi_post_mld_prov_state_set(digi_handle,
                                                  port_def_ptr->port_uid,
                                                  DIGI_SERDES_PROV_STATE_ENET_LINE);
                /* We should never get here as this means our state is corrupt */
                PMC_ASSERT(PMC_SUCCESS == rc, rc, 0, 0);

                if( PMC_SUCCESS == rc) {
                    rc = digi_by_mld_index_post_mld_map_type_get(digi_handle,
                                                                 link,
                                                                 &map_type);
                    /* We should never get here as this means our state is corrupt */
                    PMC_ASSERT(PMC_SUCCESS == rc, rc, 0, 0);

                }

                if (PMC_SUCCESS == rc) {
                    rc = digi_enet_prov_new_mapper_state_get(map_type,
                                                             &new_map_type);
                    if( rc != PMC_SUCCESS)
                        rc = DIGI_ERR_ENET_LINE_RESOURCE_NOT_AVAILABLE;

                }

                if (PMC_SUCCESS == rc) {

                    rc = digi_by_mld_index_post_mld_map_type_set(digi_handle,
                                                                 link,
                                                                 UTIL_GLOBAL_CPB_PORT_ENET_LINE,
                                                                 new_map_type);
                    /* We should never get here as this means our state is corrupt */
                    PMC_ASSERT(PMC_SUCCESS == rc, rc, 0, 0);

                }
            }

            if(rc == PMC_SUCCESS)
                rc = digi_serdes_port_lifd_sifd_mux_cfg(digi_handle,
                                                        port_def_ptr,
                                                        XIFD_DSIS_ENET);

            PMC_ATOMIC_YIELD(digi_handle,0);
            if(rc == PMC_SUCCESS)
            {
                digi_enet_serdes_mode_get(mode, &serdes_mode);
                
                /* Success path */
                *chnl_ctxt_pptr = digi_enet_client_chnl_get(digi_handle, 
                                                            serdes_mode, mode, link, 
                                                            UTIL_GLOBAL_CPB_PORT_ENET_LINE,
                                                            DIGI_ENET_RES_SERDES);

                /* Provision the SERDES */
                rc = digi_serdes_port_prov(digi_handle, 
                                           port_ctxt_ptr, serdes_mode);

            }
            if(rc == PMC_SUCCESS)
            {
                rc = enet_datapath_cfg(digi_handle->enet_line_handle,
                                       link, e_mode, 
                                       ENET_MAPOTN_CHANNEL_NONE, 
                                       FALSE, FALSE);
            }
            PMC_ATOMIC_YIELD(digi_handle,0);           
            if (rc == PMC_SUCCESS) {

                /* Configure ENET Line client source in firmware */
                /* Since we are passing in the client channel handle, there will be no conflict in the
                   TRANSMUXPONDER application. FW will just remember the handle of the last configured ENET
                   subsystem (LINE or SYS) */
                rc = digi_enet_fw_enet_client_source_conditional_update(digi_handle, (util_global_switch_data_t  *)*chnl_ctxt_pptr);
            }           
            if(rc == PMC_SUCCESS)
            {
                rc = enet_rx_activate(digi_handle->enet_line_handle, 
                                      link,
                                      e_mode);
            }
            PMC_ATOMIC_YIELD(digi_handle,0);
            if (PMC_SUCCESS == rc) {
                rc = enet_tx_activate(digi_handle->enet_line_handle, 
                                      link, 
                                      e_mode);
            }

            if(rc == PMC_SUCCESS)
                rc = digi_serdes_port_rate_state_set(digi_handle, port_def_ptr,serdes_mode, DIGI_SERDES_PROV_STATE_ENET_LINE, DIGI_SERDES_PORT_RATE_STATE_PROV);
                
               
        }
    }

    /* Save post mld dsi lane in enet handle */
    if (PMC_SUCCESS == rc)
    {
        ((digi_enet_client_chnl_def_t*)*chnl_ctxt_pptr)->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED;
        (*(digi_enet_client_chnl_def_t **)chnl_ctxt_pptr)->dsi_base_lane = post_mld_dsi_ptr->lane_index;
    }

    PMC_RETURN(rc);
} /* digi_enet_line_prov_internal */

#endif /* DOXYGEN_PUBLIC_ONLY */

/*******************************************************************************
* digi_enet_line_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions the processing resources associated with a system
*   ENET client.  These resources are subsequently available for usage with other
*   provisioning operations. \n\n
*
*   The ENET channel handle will be destroyed by this function.  The passed in
*   pointer will be modified and set to NULL. \n\n
*
*
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   **chnl_ctxt_pptr - pointer to a pointer of an ENET channel handle
*                      corresponding to the instance to be deprovisioned.
*
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_enet_line_deprov(digi_handle_t * digi_handle,
                                       digi_enet_client_chnl_t ** chnl_ctxt_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;

    /* Implementation notes: Channel handle must be tested to retrieve the ENET 
       link identifier.

       PUBLIC PMC_ERROR enet_datapath_uncfg(enet_handle_t *hndl, UINT32 link);

       In addition to the above API, any API required to be called to put the
       subsystem in lowpwr/reset if no links are provisioned needs to be
       provided.

    */
    digi_enet_client_chnl_def_t *enet_chnl_handle_ptr;
    digi_serdes_port_t *port_ctxt_ptr = NULL;
    UINT32 port_uid = DIGI_SERDES_UNASSIGNED;
    digi_serdes_prov_state_t prov_state = DIGI_SERDES_PROV_STATE_NO_SERDES;
    digi_mapper_alloc_t map_type = DIGI_MAPPER_ALLOC_UNUSED;
    digi_mapper_alloc_t new_map_type = DIGI_MAPPER_ALLOC_UNUSED;
    digi_serdes_port_rate_prov_state_t serdes_port_prov_state;
    UINT32 link;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Check arguments */    
    if ((chnl_ctxt_pptr == NULL) || (*chnl_ctxt_pptr == NULL))
    {
        result = DIGI_ERR_INVALID_ARG;
    }

    /* check enet_line channel handle to make sure it belongs to digi handle pool */
    if (PMC_SUCCESS == result)
    {
        result = digi_enet_line_chnl_handle_validate(digi_handle, *chnl_ctxt_pptr);
    }

    /* confirm MCPB resources not provisioned against ENET_LINE resource */
    if (PMC_SUCCESS == result)
    {
        result = digi_enet_channel_mcpb_clean_test(digi_handle, *chnl_ctxt_pptr);
        if(result == PMC_SUCCESS)
        {
            util_global_switch_data_t *enet_handle_ptr = NULL;
            /* Check if there is a companion ENET handle */
            enet_handle_ptr = digi_enet_lldp_companion_pmon_get(digi_handle, (util_global_switch_data_t*)(*chnl_ctxt_pptr), FALSE);
            if(enet_handle_ptr)
            {
                /* Delete MCPB resource which is provisioned against companion ENET_SYS for LLDP feature */
                digi_enet_cpu_extract_pkt_cfg(digi_handle, ENET_INGRESS, enet_handle_ptr, FALSE, FALSE);
            }
        }
        else if(result == DIGI_ERR_MCPB_PATH_STILL_CONNECTED)
        {
            /* Delete MCPB resource which is provisioned against ENET_LINE resource. */
            digi_enet_cpu_extract_pkt_cfg(digi_handle, ENET_EGRESS, *chnl_ctxt_pptr, FALSE, TRUE);
            digi_enet_cpu_extract_pkt_cfg(digi_handle, ENET_EGRESS, *chnl_ctxt_pptr, FALSE, FALSE);
            digi_enet_cpu_extract_pkt_cfg(digi_handle, ENET_INGRESS, *chnl_ctxt_pptr, FALSE, FALSE);
            digi_enet_cpu_insert_pkt_cfg(digi_handle, ENET_EGRESS, *chnl_ctxt_pptr, FALSE);
            digi_enet_cpu_insert_pkt_cfg(digi_handle, ENET_INGRESS, *chnl_ctxt_pptr, FALSE);
            result = PMC_SUCCESS;
        }
    }

    if (PMC_SUCCESS == result)
    {
        enet_chnl_handle_ptr = (digi_enet_client_chnl_def_t *) (*chnl_ctxt_pptr); 

        DIGI_CHNL_HANDLE_MAGIC_CHECK (enet_chnl_handle_ptr);

        PMC_ASSERT (enet_chnl_handle_ptr->switch_data.cpb_data.port_type ==
                    UTIL_GLOBAL_CPB_PORT_ENET_LINE
                    && enet_chnl_handle_ptr->switch_data.cpb_data.data_source ==
                    0, DIGI_ERR_INVALID_ARG, 0, 0);

        if ((enet_chnl_handle_ptr->switch_data.cpb_data.op_state.map_state.is_input_mapped == TRUE) || 
            (enet_chnl_handle_ptr->switch_data.cpb_data.op_state.map_state.is_output_mapped == TRUE)) {

            result = DIGI_ERR_CPB_STILL_MAPPED;

        }

        if (PMC_SUCCESS == result) {
            result = digi_port_uid_from_enet_link_get(digi_handle,
                                                      enet_chnl_handle_ptr->switch_data.cpb_data.channel,
                                                      TRUE,
                                                      &port_uid);
            if(result != PMC_SUCCESS)
                result = DIGI_ERR_SERDES_PORT_NOT_PROV;

        } 
        
        if (PMC_SUCCESS == result) {

            link = enet_chnl_handle_ptr->switch_data.cpb_data.channel;
            result = PMC_SUCCESS;

            /* check if we have an active loopback on this segment */
            serdes_port_prov_state = digi_serdes_port_prov_status_get (digi_handle, port_uid);

            if (DIGI_SERDES_PORT_RATE_STATE_PROV_FACILITY_LPBK == serdes_port_prov_state
                || DIGI_SERDES_PORT_RATE_STATE_PROV_DIAG_LPBK == serdes_port_prov_state)
            {
                result = DIGI_ERR_LOOPBACK_STILL_ACTIVE;
            }
            /* clear timing mode */
            enet_chnl_handle_ptr->timing_mode = LAST_DIGI_ENET_TX_TIMING_MODE;

            /*
             * If the LF force was enabled for enet resource and was not
             * disabled then check it and disable here if applicable.
             */
            if (PMC_SUCCESS == result)
            {
                result = digi_enet_lf_force_set(digi_handle,
                                                enet_chnl_handle_ptr,
                                                FALSE, FALSE);
            }

            /* PROV_STATE SHALL BE UPDATED IN THE FIRST ATOMIC SECTION */
            if (PMC_SUCCESS == result)
            {
                enet_chnl_handle_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
            }

            if (result == PMC_SUCCESS) 
            {
                result = enet_rx_deactivate(digi_handle->enet_line_handle, 
                                            link, 
                                            (digi_handle->enet_line_handle)->var.ch_datapath[link]);
            }

            if (result == PMC_SUCCESS) 
            {
                result = enet_tx_deactivate(digi_handle->enet_line_handle, link, digi_handle->enet_line_handle->var.ch_datapath[link]);
            }

            if (result == PMC_SUCCESS) {

                result = enet_datapath_uncfg (digi_handle->enet_line_handle,
                                              link);
            }

            if (result == PMC_SUCCESS) {
                BOOL enet_mirror_mode = digi_cpb_enet_mirror_chk(digi_handle,
                                                                 (util_global_switch_data_def_t *)enet_chnl_handle_ptr);

                result = digi_enet_line_db_deprov_cfg (digi_handle,
                                                       link,
                                                       enet_mirror_mode);
            }

            if (result == PMC_SUCCESS) {

                /* Uninitialize the subsystem if no channels provisioned
                   against it */
                digi_enet_line_energy_state_set (digi_handle, 0,
                                                 ENET_UNPROV_DATAPATH,
                                                 PMC_ENERGY_STATE_REQUEST_OPTIMAL);
            }
        }

        if (result == PMC_SUCCESS) {

            result = digi_by_mld_index_post_mld_map_type_get(digi_handle,
                                                             link,
                                                             &map_type);
        }
        new_map_type = DIGI_MAPPER_ALLOC_UNUSED;
        if(PMC_SUCCESS == result && DIGI_MAPPER_ALLOC_UNUSED != map_type) {
            result = digi_enet_deprov_new_mapper_state_get(map_type,
                                                           &new_map_type);
            if ( result != PMC_SUCCESS) {

                /* The resource may be using ENET in a PMON fashion, but not in
                   a SERDES fashion */
                result = DIGI_ERR_SERDES_PORT_NOT_PROV;

            }
        }
            
        if (PMC_SUCCESS == result) {
            result = digi_by_mld_index_post_mld_map_type_set(digi_handle,
                                                             link,
                                                             UTIL_GLOBAL_CPB_PORT_ENET_LINE,
                                                             new_map_type);
            /* We should never get here as this means our state is corrupt */
            PMC_ASSERT (PMC_SUCCESS == result, result, 0, 0);

        }

        if (PMC_SUCCESS == result) {
            result = digi_by_port_uid_post_mld_prov_state_get (digi_handle,
                                                               port_uid,
                                                               &prov_state);

        }

        if ((PMC_SUCCESS == result) && (prov_state == DIGI_SERDES_PROV_STATE_ENET_LINE)) {

            result = digi_port_ctxt_from_channel_number_get(digi_handle,
                                                            prov_state,
                                                            link,
                                                            &port_ctxt_ptr);
            if (PMC_SUCCESS == result) {
    
                /* deactivate SerDes Port and put in lowest energy state */
                result = digi_serdes_port_deprov(digi_handle, port_ctxt_ptr);
            }

            if(PMC_SUCCESS == result) {
                result = digi_serdes_port_lifd_sifd_subsytem_disable(digi_handle, port_uid);
                /* We should never get here as this means our state is
                   corrupt */
                PMC_ASSERT(PMC_SUCCESS == result, result, 0, 0);
            }

            if(PMC_SUCCESS == result) {
                result = digi_post_mld_prov_state_set(digi_handle, port_uid,
                                                      DIGI_SERDES_PROV_STATE_UNASSIGNED);
                /* We should never get here as this means our state is
                   corrupt */
                PMC_ASSERT(PMC_SUCCESS == result, result, 0, 0);
            }

            if(PMC_SUCCESS == result) {
                result = digi_serdes_port_rate_state_set (digi_handle,
                                                          port_ctxt_ptr,
                                                          LAST_DIGI_SERDES_PORT_MODE,
                                                          DIGI_SERDES_PROV_STATE_UNASSIGNED,
                                                          DIGI_SERDES_PORT_RATE_STATE_DEPROV);
            }
        }

        /* Shut off ENET1/2 DCSU if ENET is in start state */
        if (result == PMC_SUCCESS) {

            digi_dcsu_conditional_uninit (digi_handle,
                                          DIGI_DCSU_INST_ENET1);
            digi_dcsu_conditional_uninit (digi_handle,
                                          DIGI_DCSU_INST_ENET2);
        }

        digi_chnl_ptr_initialize ((util_global_switch_data_def_t *) *(chnl_ctxt_pptr));
        *chnl_ctxt_pptr = NULL;
    }


    PMC_ATOMIC_RETURN(digi_handle,result);
}/* digi_enet_line_deprov */

/*******************************************************************************
* digi_enet_sys_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The function specifies the internal device resources to process this signal
*   using the dsi_chnl argument. The ENET_SYS resource for processing a
*   dsi_chnl has a 1:1 mapping with the dsi_chnl.\n\n
*
*   Ethernet modes are defined in the digi_enet_mode_t enum type.  Only modes
*   that contain "SERDES" may be used with this function. "MAPOTN" modes are
*   invalid with this API.\n\n
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_ctxt_ptr         - Port datapath handle defining the physcial SerDes
*                            to configure the ENET_LINE resource against.\n
*   mode                   - Enum, ENET_SYS modes when connected to Line
*                            Serdes.  Only modes containing "SERDES" may be used.
*
* OUTPUTS:
*   **chnl_ctxt_pptr       - a pointer to a pointer to a digi_enet_client_chnl_t
*                            structure consisting of a dsi_base_lane, link, and
*                            util_global_cpb_port_data_t that is returned to
*                            the user.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_enet_sys_prov(digi_handle_t *digi_handle,
                                    digi_serdes_port_t *port_ctxt_ptr,
                                    digi_enet_mode_t mode,
                                    digi_enet_client_chnl_t **chnl_ctxt_pptr)
{
    PMC_ERROR rc = PMC_SUCCESS;

    enet_datapath_t e_mode = LAST_ENET_DATAPATH;
    digi_group_size_t group_size = LAST_DIGI_GRP_SIZE;
    UINT32 link = DIGI_SERDES_SYS_LANES_MAX;
    digi_post_mld_dsi_ctxt_t *post_mld_dsi_ptr = NULL;
    digi_serdes_port_mode_t serdes_mode = DIGI_SERDES_PORT_MODE_ANY_LOWPWR;
    digi_serdes_port_def_t *port_def_ptr = NULL;

    PMC_ATOMIC_ENTRY(digi_handle);


    rc = PMC_SUCCESS;

    /* The only valid product app is DIGI_PROD_APP_TRANSMUXPONDER_CARD */
    if(digi_handle->var.prod_app != DIGI_PROD_APP_TRANSMUXPONDER_CARD
        && (digi_handle->var.prod_app != DIGI60_PROD_APP_TRANSMUXPONDER_SYS_CLIENT_CARD))   
        rc = DIGI_ERR_PROD_APP_NOT_SUPPORTED_CALL;

    if (rc == PMC_SUCCESS) 
    {
        /* check serdes port context  */
        DIGI_SERDES_PORT_CTXT_HANDLE_CHECK(digi_handle, port_ctxt_ptr, rc);
    }

    /* This first checks to ensure the parameters fall within reasonable
       limits, but also ensures that the number of pins provisioned
       against the port will support the mode */
    if (rc == PMC_SUCCESS) 
    {
        port_def_ptr = (digi_serdes_port_def_t*)port_ctxt_ptr;
        
        rc = digi_enet_sys_prov_params_validate(digi_handle,
                                                port_def_ptr, 
                                                mode,
                                                chnl_ctxt_pptr);
    }

    if (PMC_SUCCESS == rc) 
    {

        post_mld_dsi_ptr = digi_first_sys_post_mld_dsi_find(digi_handle,
                                                            port_def_ptr->port_uid);

        digi_enet_sys_prov_params_convert(mode, &e_mode, &group_size);

        if (post_mld_dsi_ptr == NULL) {

            /* This just indicates that no post_mld_dsi lane has been allocated
               for this port */
            rc = DIGI_ERR_NO_DSI_ALLOC_PROV;

        } else if (post_mld_dsi_ptr->prov_state != DIGI_SERDES_PROV_STATE_UNASSIGNED) {

            rc = DIGI_ERR_SERDES_PORT_ALREADY_PROV;

        } 

        if (PMC_SUCCESS == rc) {
            rc = digi_enet_is_link_in_use(digi_handle, 
                                          post_mld_dsi_ptr->lane_index,
                                          group_size,
                                          UTIL_GLOBAL_CPB_PORT_ENET_SYS);
            if(rc != PMC_SUCCESS)
                rc = DIGI_ERR_ENET_SYS_RESOURCE_NOT_AVAILABLE;

        } 

        if (PMC_SUCCESS == rc) {

            /* Initialize ENET1/2 DCSU if ENET is in start state */
            digi_dcsu_conditional_init(digi_handle, DIGI_DCSU_INST_ENET1);
            digi_dcsu_conditional_init(digi_handle, DIGI_DCSU_INST_ENET2);

            /* ENET link is 1:1 mapped with post_mld_dsi */
            link = post_mld_dsi_ptr->lane_index;
            
            rc = digi_enet_sys_db_prov_cfg(digi_handle, group_size, link);

            if(rc != PMC_SUCCESS)
            {
                PMC_ATOMIC_RETURN(digi_handle,rc);
            }

            /* Initialize the subsystem */
            digi_enet_sys_energy_state_set(digi_handle, link, e_mode, PMC_ENERGY_STATE_REQUEST_RUNNING);
        }


        if (rc == PMC_SUCCESS) {
            rc = digi_post_mld_prov_state_set(digi_handle,
                                              port_def_ptr->port_uid,
                                              DIGI_SERDES_PROV_STATE_ENET_SYS);
            /* We should never get here as this means our state is corrupt */
            /* The pins should be configured as part of the port */
            PMC_ASSERT(PMC_SUCCESS == rc, rc, 0, 0);
        }
                    
        if (PMC_SUCCESS == rc) {
            rc = digi_serdes_port_lifd_sifd_mux_cfg(digi_handle,
                                                    port_def_ptr,
                                                    XIFD_DSIS_ENET);
            if( rc  != PMC_SUCCESS)
                rc = DIGI_ERR_INVALID_ARG;

        } 

        if(PMC_SUCCESS == rc) {

            digi_enet_serdes_mode_get(mode, &serdes_mode);
            
            /* Success path */
            *chnl_ctxt_pptr = digi_enet_client_chnl_get(digi_handle, 
                                                        serdes_mode, mode, link, 
                                                        UTIL_GLOBAL_CPB_PORT_ENET_SYS,
                                                        DIGI_ENET_RES_SERDES);
        }
                        
        /* Provision the SERDES */
        if (PMC_SUCCESS == rc) {
            rc = digi_serdes_port_prov(digi_handle, 
                                       port_ctxt_ptr, serdes_mode);
            if(rc != PMC_SUCCESS)
                rc = DIGI_ERR_SERDES_COULD_NOT_PROV;
        }
        
        if (PMC_SUCCESS == rc) {
            rc = enet_datapath_cfg(digi_handle->enet_sys_handle,
                                   link, e_mode, 
                                   ENET_MAPOTN_CHANNEL_NONE, 
                                   FALSE, FALSE);
            if (rc != PMC_SUCCESS) 
                rc = DIGI_ERR_ENET_COULD_NOT_PROV;

        } 
        if (rc == PMC_SUCCESS) {

            /* Configure ENET Line client source in firmware */
            /* Since we are passing in the client channel handle, there will be no conflict in the
               TRANSMUXPONDER application. FW will just remember the handle of the last configured ENET
               subsystem (LINE or SYS) */
            rc = digi_enet_fw_enet_client_source_conditional_update(digi_handle, (util_global_switch_data_t  *)*chnl_ctxt_pptr);
        }                      
        if (PMC_SUCCESS == rc) {
            rc = enet_rx_activate(digi_handle->enet_sys_handle, 
                                  link, 
                                  e_mode);
        }
        if (PMC_SUCCESS == rc) {
            rc = enet_tx_activate(digi_handle->enet_sys_handle, 
                                  link, 
                                  e_mode);
        }

        if (PMC_SUCCESS == rc)
        {
            rc = digi_serdes_port_rate_state_set(digi_handle, port_def_ptr, serdes_mode, DIGI_SERDES_PROV_STATE_ENET_SYS, DIGI_SERDES_PORT_RATE_STATE_PROV);
        }
    }

    /* Save post mld dsi lane in enet handle */
    if (PMC_SUCCESS == rc)
    {
        ((digi_enet_client_chnl_def_t*)*chnl_ctxt_pptr)->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED;
        (*(digi_enet_client_chnl_def_t **)chnl_ctxt_pptr)->dsi_base_lane = post_mld_dsi_ptr->lane_index;
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_enet_sys_prov */


/*******************************************************************************
* digi_enet_sys_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions the processing resources associated with a system
*   ENET client.  These resources are subsequently available for usage with other
*   provisioning operations.
*
*   The ENET channel handle will be destroyed by this function.  The passed in
*   pointer will be modified and set to NULL.
*
*
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance.
*   *chnl_ctxt_pptr - pointer to ENET channel handle of the instance to be
*                     deprovisioned.
*
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_enet_sys_deprov(digi_handle_t * digi_handle,
                                      digi_enet_client_chnl_t ** chnl_ctxt_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;

    /* Implementation notes: Channel handle must be tested to retrieve the ENET 
       link identifier.

       PUBLIC PMC_ERROR enet_datapath_uncfg(enet_handle_t *hndl, UINT32 link);

       In addition to the above API, any API required to be called to put the
       subsystem in lowpwr/reset if no links are provisioned needs to be
       provided.

    */
    digi_enet_client_chnl_def_t *enet_chnl_handle_ptr;
    digi_serdes_port_t *port_ctxt_ptr = NULL;
    UINT32 port_uid = DIGI_SERDES_UNASSIGNED;
    digi_serdes_port_rate_prov_state_t serdes_port_prov_state;
    UINT32 link;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    

    /* Check arguments */
    if ((chnl_ctxt_pptr == NULL) || (*chnl_ctxt_pptr == NULL))
    {

        result = DIGI_ERR_INVALID_ARG;

    }
    /* check enet_line channel handle to make sure it belongs to digi handle pool */
    if (PMC_SUCCESS == result)
    {
        result = digi_enet_sys_chnl_handle_validate(digi_handle, *chnl_ctxt_pptr);
    } 

    /* confirm MCPB resources not provisioned against ENET_SYS resource */
    if (PMC_SUCCESS == result)
    {
        result = digi_enet_channel_mcpb_clean_test(digi_handle, *chnl_ctxt_pptr);
        if(result == PMC_SUCCESS)
        {
            util_global_switch_data_t *enet_handle_ptr = NULL;
            /* Check if there is a companion ENET handle */
            enet_handle_ptr = digi_enet_lldp_companion_pmon_get(digi_handle, (util_global_switch_data_t*)(*chnl_ctxt_pptr), FALSE);
            if(enet_handle_ptr)
            {
                /* Delete MCPB resource which is provisioned against companion ENET_LINE for LLDP feature */
                digi_enet_cpu_extract_pkt_cfg(digi_handle, ENET_INGRESS, enet_handle_ptr, FALSE, FALSE);
            }
        }
        else if(result == DIGI_ERR_MCPB_PATH_STILL_CONNECTED)
        {
            /* Delete MCPB resource which is provisioned against ENET_SYS resource. */
            digi_enet_cpu_extract_pkt_cfg(digi_handle, ENET_EGRESS, *chnl_ctxt_pptr, FALSE, TRUE);
            digi_enet_cpu_extract_pkt_cfg(digi_handle, ENET_EGRESS, *chnl_ctxt_pptr, FALSE, FALSE);
            digi_enet_cpu_extract_pkt_cfg(digi_handle, ENET_INGRESS, *chnl_ctxt_pptr, FALSE, FALSE);
            digi_enet_cpu_insert_pkt_cfg(digi_handle, ENET_EGRESS, *chnl_ctxt_pptr, FALSE);
            digi_enet_cpu_insert_pkt_cfg(digi_handle, ENET_INGRESS, *chnl_ctxt_pptr, FALSE);
            result = PMC_SUCCESS;
        }
    }

    if (PMC_SUCCESS == result)
    {

        enet_chnl_handle_ptr = (digi_enet_client_chnl_def_t *) (*chnl_ctxt_pptr);
        link = enet_chnl_handle_ptr->switch_data.cpb_data.channel;

        DIGI_CHNL_HANDLE_MAGIC_CHECK (enet_chnl_handle_ptr);

        PMC_ASSERT (enet_chnl_handle_ptr->switch_data.cpb_data.port_type ==
                    UTIL_GLOBAL_CPB_PORT_ENET_SYS
                    && enet_chnl_handle_ptr->switch_data.cpb_data.data_source ==
                    0, DIGI_ERR_INVALID_ARG, 0, 0);

        if ((enet_chnl_handle_ptr->switch_data.cpb_data.op_state.map_state.is_input_mapped == TRUE) || 
            (enet_chnl_handle_ptr->switch_data.cpb_data.op_state.map_state.is_output_mapped == TRUE)) {

            result = DIGI_ERR_CPB_STILL_MAPPED;

        }

        if (PMC_SUCCESS == result)
        {
            result = digi_port_uid_from_enet_link_get(digi_handle,
                                                      link,
                                                      FALSE,
                                                      &port_uid);
            if(result != PMC_SUCCESS)
                result = DIGI_ERR_SERDES_PORT_NOT_PROV;

        }

        /*
         * If the LF force was enabled for enet resource and was not
         * disabled then check it and disable here if applicable.
         */
        if (PMC_SUCCESS == result)
        {
            result = digi_enet_lf_force_set(digi_handle,
                                            enet_chnl_handle_ptr,
                                            FALSE, FALSE);
        }
        
        if (PMC_SUCCESS == result)
        {
            /* check if we have an active loopback on this segment */
            serdes_port_prov_state =
                digi_serdes_port_prov_status_get (digi_handle, port_uid);
            if (DIGI_SERDES_PORT_RATE_STATE_PROV_FACILITY_LPBK ==
                serdes_port_prov_state
                || DIGI_SERDES_PORT_RATE_STATE_PROV_DIAG_LPBK ==
                serdes_port_prov_state)
            {
                result = DIGI_ERR_LOOPBACK_STILL_ACTIVE;
            }


            /* PROV_STATE SHALL BE UPDATED IN THE FIRST ATOMIC SECTION */
            if (PMC_SUCCESS == result)
            {
                enet_chnl_handle_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
            }

            /* clear timing mode */
            enet_chnl_handle_ptr->timing_mode = LAST_DIGI_ENET_TX_TIMING_MODE;

            if (PMC_SUCCESS == result)
            {
                result = enet_rx_deactivate(digi_handle->enet_sys_handle, 
                                            link, 
                                            (digi_handle->enet_sys_handle)->var.ch_datapath[link]);
            }

            if (result == PMC_SUCCESS)
            {
                result = enet_tx_deactivate(digi_handle->enet_sys_handle, link, digi_handle->enet_sys_handle->var.ch_datapath[link]);
            }
            
            if (PMC_SUCCESS == result)
            {
                result = enet_datapath_uncfg (digi_handle->enet_sys_handle,
                                              link);
            }
            
            if (result == PMC_SUCCESS)
            {
                result = digi_enet_sys_db_deprov_cfg (digi_handle,
                                                      link);
            }

            /* PMC_FREE(chnl_ctxt_pptr); */
            if (result == PMC_SUCCESS)
            {
                /* Uninitialize the subsystem if no channels provisioned
                   against it */
                digi_enet_sys_energy_state_set (digi_handle, 0,
                                                ENET_UNPROV_DATAPATH,
                                                PMC_ENERGY_STATE_REQUEST_OPTIMAL);
            }


        }

        if (PMC_SUCCESS == result)
        {

            result = digi_port_ctxt_from_channel_number_get(digi_handle,
                                                            DIGI_SERDES_PROV_STATE_ENET_SYS,
                                                            link,
                                                            &port_ctxt_ptr);
            if (PMC_SUCCESS == result)
            {

                /* deactivate SerDes Port and put in lowest energy state */
                result = digi_serdes_port_deprov(digi_handle, port_ctxt_ptr);

                if(PMC_SUCCESS == result)
                {
                    result = digi_serdes_port_lifd_sifd_subsytem_disable(digi_handle, port_uid);

                    /* We should never get here as this means our state is corrupt */
                    PMC_ASSERT(PMC_SUCCESS == result, result, 0, 0);

                    result = digi_post_mld_prov_state_set(digi_handle, port_uid,
                                                          DIGI_SERDES_PROV_STATE_UNASSIGNED);

                    /* We should never get here as this means our state is corrupt */
                    PMC_ASSERT(PMC_SUCCESS == result, result, 0, 0);

                    result = digi_serdes_port_rate_state_set (digi_handle,
                                                              port_ctxt_ptr,
                                                              LAST_DIGI_SERDES_PORT_MODE,
                                                              DIGI_SERDES_PROV_STATE_UNASSIGNED,
                                                              DIGI_SERDES_PORT_RATE_STATE_DEPROV);
                }
            }
        }

        /* Shut off ENET1/2 DCSU if ENET is in start state */
        if (result == PMC_SUCCESS)
        {
            digi_dcsu_conditional_uninit (digi_handle, DIGI_DCSU_INST_ENET1);
            digi_dcsu_conditional_uninit (digi_handle, DIGI_DCSU_INST_ENET2);
        }

        digi_chnl_ptr_initialize ((util_global_switch_data_def_t *) *(chnl_ctxt_pptr));
        *chnl_ctxt_pptr = NULL;

    }

    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_enet_sys_deprov */

/*******************************************************************************
* digi_mapper_group_usage_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns the set of Line Serdes resources that are available
*   to be associated with primary and secondary mapper groups for Line Serdes to
*   ENET_LINE to CPB data path usage.\n\n
*
*   This function can be used to retrieve the assignment of ENET_LINE processing
*   resources made by the SW driver to allow user to manage the usage of MAPOTN
*   and ENET_LINE resources between CPB to ODUKSW and CPB to LINE_SERDES data
*   paths.\n\n
*
*   By using the API the user is aware of what ENET_LINE processing resources
*   have potentially become unavailable for serdes port data processing.  They
*   have also identified the set of set of modules associated with a serdes
*   cage that must be used as a group to not preclude reconfiguration of the
*   group.\n\n
*
*   For example to not preclude an ENET_LINE resource being available for
*   later use, should a CPB to ODUKSW connection not require ENET_LINE
*   processing, it may occupy the same group as the that required by Line
*   Serdes, to maintain the availability of the resource.\n\n
*
*   The SW driver manages Post MUX DSI Lane Usage.  This is determined based on
*   the identification of the set of cages and Serdes modules provided by the
*   user with digi_serdes_cage_cfg() and digi_serdes_port_init() calls.\n\n
*
*   Based on the modules present, the driver allocates a set of ENET_LINE
*   processing resources that are available for usage by these pins.
*
*
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*
*
* OUTPUTS:
*   *port_grp_usage    - Pointer to a digi_port_usage_grp_struct_t.
*                      This structure contains 12 elements of 
*                      type digi_port_usage_struct_t. This contains the 
*                      pointer to the port context and the port states as
*                      well as the number of odu0s provisioned against
*                      this port context. These structures are filled in 
*                      by this function. 
*                      Array index is primary_group number*4 +
*                      secondary_group number. \n
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_mapper_group_usage_get(digi_handle_t *digi_handle,
                                             digi_port_usage_grp_struct_t* port_grp_usage)

{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;

    PMC_ATOMIC_ENTRY(digi_handle);

    rc = digi_line_port_info_internal_get(digi_handle, port_grp_usage);

    PMC_ATOMIC_RETURN(digi_handle,rc);

} /* digi_mapper_group_usage_get */


/*******************************************************************************
* digi_serdes_cage_cfg()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function specifies the set of Serdes pins of the Line Serdes or System
*   Serdes interfce associated with a common cage.\n\n
*
*   Cage specification is a device level consideration and must be stable for
*   the operational usage of the card.  This API must only be called once per 
*   Serdes interface to define cage usage of the card.\n\n
*
*   Following device initialization, the Serdes pin to cage relationship is
*   generated.\n\n
*
*   The cage represents a grouping that SW driver will maintain when selecting
*   internal device resources for processing signals within a cage.\n\n
*
*   This ensures that if there is a 4 pin cage that should it have the potential
*   to hold a 4 x 10G or 1 x 40G module that if the device initially configured
*   for 4 x 10G usage that the set of internal device resources used to process
*   this signal overlap with the resources required to process a 40G signal
*   should the module be swapped from a 4 x 10G module to a 1 x 40G module.\n\n
*
*   An example of the cage_id_per_pin[12] usage for 2 x 40G modules and 4 x 10G
*   modules for a hypothetical pinout would be:\n
*   cage_id_per_pin[0, 0, 0, 0, 1, 1, 1, 1, 2, 3, 4, 5]\n
*   Where:\n
*      - cage_id 0 is 40G module associated with serdes pins 3:0\n
*      - cage_id 1 is 40G module associated with serdes pins 7:4\n
*      - cage_id 2 is 10G module associated with serdes pin 8\n
*      - cage_id 3 is 10G module associated with serdes pin 9\n
*      - cage_id 4 is 10G module associated with serdes pin 10\n
*      - cage_id 5 is 10G module associated with serdes pin 11\n
*   If hw design required different set of pin allocation, the value could be:\n
*   cage_id_per_pin[0, 2, 0, 3, 1, 1, 1, 1, 0, 0, 4, 5]\n
*   Where:\n
*      - cage_id 0 is 40G module associated with serdes pins [9, 8, 2, 0]\n
*      - cage_id 1 is 40G module associated with serdes pins [7, 6, 5, 4]\n
*      - cage_id 2 is 10G module associated with serdes pin 1\n
*      - cage_id 3 is 10G module associated with serdes pin 3\n
*      - cage_id 4 is 10G module associated with serdes pin 10\n
*      - cage_id 5 is 10G module associated with serdes pin 11\n
*
*   For SFIS cages,the number of pins in a cage must be 5 for a 40G SFIS 
*   module, or 11 for the 100G SFIS module.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   intf                   - Interface cage configuration related to, valid
*                            values:\n
*                            DIGI_SERDES_LINE_INTF\n
*                            DIGI_SERDES_SYSTEM_INTF
*   cage_id_per_pin        - Array defining upto 12 unique
*                            cages connected to interface specified with intf.
*                            The array is indexed by serdes pin number.  Should
*                            a pin not be associated with a cage, the value
*                            DIGI_SERDES_PIN_NOT_USED (0xFF) may be used to
*                            define 'Not Connected'.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_serdes_cage_cfg(digi_handle_t *digi_handle,
                                      digi_serdes_intf_t intf,
                                      UINT8 cage_id_per_pin[DIGI_SERDES_XFI_LANES_MAX])
{
    PMC_ERROR rc = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    rc = DIGI_ERR_UNKNOWN;
    
    if (intf >= LAST_DIGI_SERDES_INTF) {

        rc = DIGI_ERR_INVALID_ARG;

    } else {

        switch (intf) {

        case DIGI_SERDES_LINE_INTF:
            rc = digi_serdes_line_cage_cfg(digi_handle, 
                                           cage_id_per_pin);
            break;
        case DIGI_SERDES_SYSTEM_INTF:
            rc = digi_serdes_sys_cage_cfg(digi_handle, 
                                          cage_id_per_pin);
            break;
        case DIGI_SERDES_SFI_51_INTF:
            rc = DIGI_ERR_SERDES_NO_SFI51_CAGE_PROV;
            break;
        default:
            break;
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);

} /* digi_serdes_cage_cfg */

/*******************************************************************************
* digi_serdes_port_init()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This function specifies the presence of Serdes modules connected to
*   device serdes interface.\n\n
*
*   The configuration of the pin relationship need only be configured once with
*   the exception of cages (as defined in digi_serdes_cage_cfg) which support
*   replacable modules such as a 4 x 10G Serdes pin cage that supports a 1 x 40G
*   or 4 x 10G module.\n\n
*
*   When such a module is hot swapped it is expected to call
*   digi_serdes_port_uninit() to free the resources and this API to define the
*   new pin usage.\n\n
*
*   The logical sequence of transmit and receive module lanes allow for 40G
*   and 100G LINE or SYSTEM SERDES connected modules to have alternate logical
*   lane sequences defined.  For 10G modules, the data to module_lane_tx and
*   module_lane_rx must be identical.
*
*   For SFIS ports,the number of pins in a port must be 5 for a 40G SFIS 
*   module, or 11 for the 100G SFIS module.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   identifier             - Unique user assigned value for identifying
*                            serdes port.  The value 0xFFFFFFFF
*                            DIGI_SERDES_UNASSIGNED is reserved as the
*                            default unassigned setting.
*   intf                   - enum, defining the serdes interface the port
*                            is associated with
*   module_lane_tx         - Applicable to Tx Serdes Lanes:\n\n
*                            For intf of DIGI_SERDES_LINE_INTF or 
*                            DIGI_SERDES_SYSTEM_INTF, array defining set of 
*                            interface pins and logical sequence of these pins 
*                            relative to the module pins for a serdes port.  
*                            Pins not associated with the serdes port must be 
*                            set to DIGI_SERDES_UNASSIGNED.\n\n
*                            For intf DIGI_SERDES_SFI_51_INTF, first 2 index
*                            of array are used.  Array index identifies the
*                            physical SFI51 interface A/B (index 0/1) and the
*                            data within the array defines the lane order
*                            definition of the pins within the interface.
*                            The legal definitions of the swizzling mode are:
*                            DIGI_SERDES_SFI51_SWAP_ON\n
*                            DIGI_SERDES_SFI51_SWAP_OFF\n
*                            Refer to enum, digi_serdes_sfi51_swap_t.\n
*                            The alternate SFI51 port must be set to 
*                            DIGI_POST_MUX_BUS_UNUSED.\n
*   module_lane_rx         - Applicable to Rx Serdes Lanes:\n\n
*                            See module_lane_tx description. module_lane_rx must
*                            be the same as module_lane_tx for 10G serdes ports.
*                            Otherwise the pin sequence may be uniquely defined
*                            if required.
*   los_pin                - The pin index on which the LOS is carried.
*                            Valid values are any pin within SYS_LOS[11:0] or 
*                            LINE_LOS[11:0] bus interfaces.
*                            For intf DIGI_SERDES_SFI_51_INTF, this value is
*                            ignored.
*                            Setting this to a value of DIGI_SERDES_PORT_DLOS_LOS_SOURCE
*                            will set this serdes lane to ignore the LOS pin
*                            and use its internal DLOS as a LOS source.  
*                            (Note: los_inv parameter is ignored and internally treated as TRUE when using internal DLOS)
*                            Setting this to a value of DIGI_SERDES_PORT_NO_LOS_SOURCE
*                            will disable the LOS feature.
*   los_inv                - Module LOS logical state definition:\n
*                            TRUE: In LOS state logic 0 (value ignored when los_pin is set to DIGI_SERDES_PORT_DLOS_LOS_SOURCE)
*                            FALSE: In LOS state logic 1
*   *s16_clk_cfg_ptr       - The configuration of the additional serdes as a clock
*                            at he nominal rate of the datapath with a specified 
*                            divider. The pin index of this serdes shall be not 
*                            used be any other serdes ports and shall not be included 
*                            in the cage definition.
*                            This input must be set to NULL when a clock is not 
*                            requested
*                            For intf DIGI_SERDES_SFI_51_INTF, this value is
*                            ignored.
*
* OUTPUTS:
*   **port_ctxt_pptr       - pointer to a pointer to a serdes port data used for
*                            identifying serdes context for usage by other API
*                            of the SW driver.
*
* RETURNS:
*   DIGI_ERR_INVALID_ARG, or
*   DIGI_ERR_NULL_HANDLE on failure.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_serdes_port_init(digi_handle_t *digi_handle,
                                       UINT32 identifier,
                                       digi_serdes_intf_t intf,
                                       UINT32 module_lane_tx[DIGI_SERDES_XFI_LANES_MAX],
                                       UINT32 module_lane_rx[DIGI_SERDES_XFI_LANES_MAX],
                                       UINT8 los_pin,
                                       BOOL los_inv,
                                       digi_s16_clk_cfg_t *s16_clk_cfg_ptr,
                                       digi_serdes_port_t **port_ctxt_pptr)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    if (port_ctxt_pptr == NULL)  {

        rc = DIGI_ERR_NULL_HANDLE;

    } else if (identifier == DIGI_SERDES_UNASSIGNED) {

        rc = DIGI_ERR_INVALID_ARG;

    } else if (intf >= LAST_DIGI_SERDES_INTF) {

        rc = DIGI_ERR_INVALID_ARG;

    } else if (digi_is_port_uid_unique(digi_handle, identifier) == FALSE) {
        rc = DIGI_ERR_SERDES_PORT_ALREADY_PROV;

    } else {
        if (DIGI_SERDES_PORT_DLOS_LOS_SOURCE == los_pin)
        {
            los_inv = TRUE;
        }
        
        switch (intf) {

        case DIGI_SERDES_LINE_INTF:
            rc = digi_serdes_line_port_init(digi_handle, identifier,
                                            module_lane_tx, module_lane_rx,
                                            los_pin, los_inv,
                                            s16_clk_cfg_ptr,
                                            port_ctxt_pptr);
            break;
        case DIGI_SERDES_SYSTEM_INTF:
            rc = digi_serdes_sys_port_init(digi_handle, identifier,
                                           module_lane_tx, module_lane_rx,
                                           los_pin, los_inv,
                                           s16_clk_cfg_ptr,
                                           port_ctxt_pptr);
            break;
        case DIGI_SERDES_SFI_51_INTF:
            rc = digi_serdes_sfi51_port_init(digi_handle, identifier,
                                             module_lane_tx, module_lane_rx,
                                             los_inv,
                                             port_ctxt_pptr);
            break;
        default:
            break;
        }
    }

    if (rc == PMC_SUCCESS) {
        if (digi_serdes_is_valid_100G_3_X_40G_card_config(digi_handle) == TRUE)
        {
            rc = digi_dsi_lane_allocation(digi_handle, FALSE);

            if (rc == PMC_SUCCESS)
            {
                rc = digi_cfp_pins_allocate(digi_handle);
            }
        }
        else
        {
            if(digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
            {
                if(intf == DIGI_SERDES_LINE_INTF &&
                   TRUE == digi_device_init_status_get(digi_handle))
                {
                  rc = digi_dsi_lane_allocation(digi_handle, TRUE);
                }
            }
            else
            {
                if(intf == DIGI_SERDES_LINE_INTF)
                {
                    /* check that DIGI device is initialized */
                    if(FALSE == digi_device_init_status_get(digi_handle))
                    {
                        PMC_ATOMIC_RETURN(digi_handle, PMC_SUCCESS);
                    }
                
                    rc = digi_otn_cfg_mode_set(digi_handle);
                }
            }
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_serdes_port_init */

/*******************************************************************************
* digi_serdes_port_uninit()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This function releases resources from usage against a user specified
*   Serdes Port.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   **port_ctxt_pptr       - pointer to a pointer to a serdes port data used
*                            for identifying serdes context for usage by other
*                            API of the SW driver.
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_serdes_port_uninit(digi_handle_t *digi_handle,
                                         digi_serdes_port_t **port_ctxt_pptr)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    PMC_ATOMIC_ENTRY(digi_handle);
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    if (port_ctxt_pptr == NULL) {

        rc = DIGI_ERR_NULL_HANDLE;

    } else if (*port_ctxt_pptr == NULL) {

        rc = DIGI_ERR_NULL_HANDLE;

    }     
    else if (PMC_SUCCESS != digi_serdes_port_ctxt_validate(digi_handle, *port_ctxt_pptr))
    {
       
        rc = DIGI_ERR_INVALID_ARG; 
    }
    else if (((digi_serdes_port_def_t*)*port_ctxt_pptr)->port_uid == DIGI_SERDES_UNASSIGNED) {

        rc = DIGI_ERR_INVALID_ARG;

    } else {

        switch(((digi_serdes_port_def_t*)*port_ctxt_pptr)->intf) { 
            
        case DIGI_SERDES_LINE_INTF:
            rc = digi_serdes_line_port_uninit(digi_handle, 
                                              (digi_serdes_port_def_t*)*port_ctxt_pptr);
            break;
        case DIGI_SERDES_SYSTEM_INTF:
            rc = digi_serdes_sys_port_uninit(digi_handle, 
                                             (digi_serdes_port_def_t*)*port_ctxt_pptr);
            break;
        case DIGI_SERDES_SFI_51_INTF:
            rc = DIGI_ERR_SERDES_CANNOT_UNINIT_SFI51;
            break;
        default:
            break;
        }

        if (rc == PMC_SUCCESS) {

            *port_ctxt_pptr = NULL;

        }
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_serdes_port_uninit */

/*******************************************************************************
* digi_port_is_initialized()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function is used as an accessor for digi_serdes_port_t. As the user 
*   may need to determine additional information about the digi_serdes_ports
*   from digi_mapper_group_usage_get(). It is used to determine if a particular 
*   port has already been initialized or not.\n\n
*
* INPUTS:
*   *port_ctxt_ptr   - pointer to the digi_serdes_port_t to access.
*
* OUTPUTS:
*   *is_init         - Pointer to a BOOL. This is set to TRUE if the port has
*                      been initialized. FALSE otherwise. This value is only 
*                      valid if PMC_SUCCESS was returned.
*
* RETURNS:
*   PMC_SUCCESS - on success, DIGI_ERR_NULL_HANDLE otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_port_is_initialized(digi_serdes_port_t *port_ctxt_ptr,
                                          BOOL* is_init)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    PMC_ENTRY();

    if (port_ctxt_ptr == NULL)  {

        rc = DIGI_ERR_NULL_HANDLE;

    } else {

        *is_init = ((digi_serdes_port_def_t*)port_ctxt_ptr)->init;
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
} /* digi_port_is_initialized */

/*******************************************************************************
* digi_port_uid_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function is used as an accessor for digi_serdes_port_t. As the user 
*   may need to determine additional information about the digi_serdes_ports
*   from digi_mapper_group_usage_get(). It is used to obtain the port_uid of 
*   the specified port.\n\n
*
* INPUTS:
*   *port_ctxt_ptr   - pointer to the digi_serdes_port_t to access.
*
* OUTPUTS:
*   *port_uid        - Pointer to a UINT32. This is set to port_uid of this
*                      port or DIGI_SERDES_UNASSIGNED if it is not in use.
*                      This value is only valid if PMC_SUCCESS was returned.
*
* RETURNS:
*   PMC_SUCCESS - on success, DIGI_ERR_NULL_HANDLE otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_port_uid_get(digi_serdes_port_t *port_ctxt_ptr,
                                   UINT32* port_uid)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    PMC_ENTRY();

    if (port_ctxt_ptr == NULL)  {

        rc = DIGI_ERR_NULL_HANDLE;

    } 
    else {

        *port_uid = ((digi_serdes_port_def_t*)port_ctxt_ptr)->port_uid;
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
} /* digi_port_uid_get */

/*******************************************************************************
* digi_port_interface_type_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function is used as an accessor for digi_serdes_port_t. As the user 
*   may need to determine additional information about the digi_serdes_ports
*   from digi_mapper_group_usage_get(). It is used to obtain the interface type 
*   of the specified port.\n\n
*
* INPUTS:
*   *port_ctxt_ptr   - pointer to the digi_serdes_port_t to access.
*
* OUTPUTS:
*   *interface_type  - Pointer to a digi_serdes_intf_t. This is set to the 
*                      interface type of this port.
*                      This value is only valid if PMC_SUCCESS was returned.
*
* RETURNS:
*   PMC_SUCCESS - on success, DIGI_ERR_NULL_HANDLE otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_port_interface_type_get(digi_serdes_port_t *port_ctxt_ptr,
                                              digi_serdes_intf_t* interface_type)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    PMC_ENTRY();

    if (port_ctxt_ptr == NULL)  {

        rc = DIGI_ERR_NULL_HANDLE;

    } 
    else {

        *interface_type = ((digi_serdes_port_def_t*)port_ctxt_ptr)->intf;
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
} /* digi_port_interface_type_get */

/*******************************************************************************
* digi_enhanced_pmon_link_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns primary group and secondary group to be used to retrieve TX PMON. 
*   
*   This function is only valid for DIGI60 device.
*
*   For DIGI60_PROD_APP_TRANSMUXPONDER_CARD:
*
*   There are two types of 10GE/40GE data paths for this XPONDER product 
*   application, one is OEO(ENET<>CPB<>ENET), the other is ENET<>CPB<>MAPPER<>OTN.
*   For the former, there is no TX ENET PMON available on DIGI60, while for the 
*   later we support directional ENET PMON.
*
*   To achieve bidirectional ENET PMON for ENET<>CPB<>MAPPER<>OTN path, 
*   some steps should be followed.
*     1, Before setting up the data path, customer should determine a couple of 
*        involved ports: port C (ENET port) and port S (OTN port).
*     2, During data path provision, before calling digi_otn_mapper_prov() 
*        with enet_pmon being true to enable PMON, customer should 
*        call digi_enhance_pmon_link_get(), passing in OTN port S. 
*        This API returns primary_group and secondary_group. 
*     3, And then call digi_otn_mapper_prov(), passing in primary_group 
*        and secondary_group gotten in above step.
*     4, When retrieving PMON, the Rx PMON (mapping direction) data should be 
*        taken from ENET channel handle associated with ENET port C,  
*        and the Tx PMON (de-mapping direction) data should be taken from MAPOTN 
*        channel handle. (Refer to digi_mapper_pmon_retrieve())
*
*   For DIGI60_PROD_APP_LINE_CARD:
*
*   To achieve bidirectional ENET PMON for ENET<>CPB<>MAPPER<>ODUKSW<>ILKN path, 
*   some steps should be followed.
*     1, During data path provision, before calling digi_otn_mapper_prov() 
*        with enet_pmon being true to enable PMON, customer should 
*        call digi_enhance_pmon_link_get(), passing in ENET port. 
*        This API returns primary_group and secondary_group. 
*     2, And then call digi_otn_mapper_prov(), passing in primary_group 
*        and secondary_group gotten in above step.
*     3, When retrieving PMON, the Rx PMON (mapping direction) data should be 
*        taken from ENET channel handle associated with ENET port C,  
*        and the Tx PMON (de-mapping direction) data should be taken from MAPOTN 
*        channel handle. (Refer to digi_mapper_pmon_retrieve())
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_ctxt_ptr         - pointer to serdes port data.
*                            For DIGI60_PROD_APP_TRANSMUXPONDER_CARD:
*                             - The SerDes port to configure the LINE_OTN 
*                               resource against.
*                            For DIGI60_PROD_APP_LINE_CARD:
*                             - The SerDes port to configure the ENET 
*                               resource against.
*
* OUTPUTS:
*   *primary_group_ptr     - Primary group setting.
*   *secondary_group_ptr   - Secondary group setting
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_enhanced_pmon_link_get(digi_handle_t *digi_handle, 
                                           digi_serdes_port_t *port_ctxt_ptr,
                                           digi_mapper_primary_group_t *primary_group_ptr,
                                           digi_mapper_secondary_group_t *secondary_group_ptr)
{
    PMC_ERROR rc = PMC_SUCCESS;
    UINT32 link = 0;
    digi_serdes_port_def_t *port_def_ptr = NULL;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != port_ctxt_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != primary_group_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != secondary_group_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);

    if(!DIGI60_PROD_APP_IS_TRANSMUXPONDER_CARD(digi_handle)
        && !DIGI60_PROD_APP_IS_LINE_CARD(digi_handle)
        && !DIGI60_PROD_APP_IS_TRANSMUXPONDER_SYS_CLIENT_CARD(digi_handle)) {
        rc = DIGI_ERR_PROD_APP_NOT_SUPPORTED_CALL;
    }
    else
    {
        port_def_ptr = (digi_serdes_port_def_t *)port_ctxt_ptr;
    }
    
    if(PMC_SUCCESS == rc && (DIGI60_PROD_APP_IS_TRANSMUXPONDER_CARD(digi_handle) || DIGI60_PROD_APP_IS_TRANSMUXPONDER_SYS_CLIENT_CARD(digi_handle))) {

        link = (UINT32)port_def_ptr->master_lane;

    }

    if(PMC_SUCCESS == rc && DIGI60_PROD_APP_IS_LINE_CARD(digi_handle)) {

        if (!((port_def_ptr->master_lane >= 4) && (port_def_ptr->master_lane <= 9) )) {
            rc = DIGI_ERR_INVALID_ARG;
        }

        if(PMC_SUCCESS == rc) {
            if (port_def_ptr->master_lane < 8) {
                link = (UINT32)(port_def_ptr->master_lane - 4);
            } else {
                link = (UINT32)(port_def_ptr->master_lane + 2);
            }
        }
    }

    if(PMC_SUCCESS == rc) {
        if(primary_group_ptr != NULL) {
            *primary_group_ptr = (digi_mapper_primary_group_t)(link / 4);
        }
        if(secondary_group_ptr != NULL) {
            *secondary_group_ptr = (digi_mapper_secondary_group_t)(link % 4);
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_enhanced_pmon_link_get */

/*******************************************************************************
* digi_otn_server_prov_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the Systen or Line side OTN server port handle based on the 
*   serdes port handle used to configure it. When configured the serdes 
*   port handle port uid was assigned to the OTN server channel. That value
*   is  used to find the associated line/system side OTN server channel
*   handle
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_ctxt_ptr         - pointer to serdes port data for the serdes port to
*                            be configured.
*
* OUTPUTS:
*   **otn_server_pptr      - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.
*
* RETURNS:
*   PMC_SUCCESS - OTN Server context was found
*   PMC_ERROR - Error type indicating the issue.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_prov_chnl_get(digi_handle_t *digi_handle,
                                               digi_serdes_port_t *port_ctxt_ptr,
                                               digi_otn_server_chnl_t **otn_server_pptr)
{
    PMC_ERROR rc = DIGI_ERR_NULL_HANDLE;

    UINT8     i  = 0;
    digi_serdes_intf_t intf;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(port_ctxt_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    intf = ((digi_serdes_port_def_t *)port_ctxt_ptr)->intf;

    if (otn_server_pptr == NULL)  {

        rc = DIGI_ERR_NULL_HANDLE;

    }  
    else if (PMC_SUCCESS != digi_serdes_port_ctxt_validate(digi_handle, port_ctxt_ptr))
    {       
        rc = DIGI_ERR_INVALID_ARG; 
    }
    else if (intf >= LAST_DIGI_SERDES_INTF) {

        rc = DIGI_ERR_INVALID_ARG;

    } else if (DIGI_SERDES_LINE_INTF == intf) {

        for (i=0; i < DIGI_OTN_SERVER_CHNL_MAX; i++)
        {
            if (digi_handle->handle_pool.otn_server_chnl[i].header.prov_state != 
                UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG &&
                digi_handle->handle_pool.otn_server_chnl[i].port_uid ==
                ((digi_serdes_port_def_t*)port_ctxt_ptr)->port_uid)
            {
                digi_otn_server_chnl_def_t *otn_server_ptr =
                    &(digi_handle->handle_pool.otn_server_chnl[i]);
                *otn_server_pptr = (digi_otn_server_chnl_t *)otn_server_ptr;
                rc = PMC_SUCCESS;
                break;
            }
        }
    } 
    else if (DIGI_SERDES_SYSTEM_INTF == intf) 
    {
        if (UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG == 
            digi_handle->handle_pool.sysotn_server_chnl.header.prov_state && 
            DIGI_PROD_APP_100G_3_X_40G_CFP_CARD == digi_handle->var.prod_app)
        {
            for (i=0; i < DIGI_OTN_SERVER_CHNL_MAX; i++)
            {
                if ((digi_handle->handle_pool.otn_server_chnl[i].header.prov_state !=  UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) &&
                    digi_handle->handle_pool.otn_server_chnl[i].port_uid ==
                    ((digi_serdes_port_def_t*)port_ctxt_ptr)->port_uid)
                {
                    digi_otn_server_chnl_def_t *otn_server_ptr =
                        &(digi_handle->handle_pool.otn_server_chnl[i]);
                    *otn_server_pptr = (digi_otn_server_chnl_t *)otn_server_ptr;
                    rc = PMC_SUCCESS;
                    break;
                }
            }
        }
        else if (digi_handle->handle_pool.sysotn_server_chnl.header.prov_state != 
                 UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG &&
                 digi_handle->handle_pool.sysotn_server_chnl.port_uid ==
                 ((digi_serdes_port_def_t*)port_ctxt_ptr)->port_uid)
        {
            digi_otn_server_chnl_def_t *otn_server_ptr =
                &(digi_handle->handle_pool.sysotn_server_chnl);
            *otn_server_pptr = (digi_otn_server_chnl_t *)otn_server_ptr;
            rc = PMC_SUCCESS;
        }
    }
    PMC_ATOMIC_RETURN(digi_handle, rc);
} /* digi_otn_server_prov_chnl_get */

/*******************************************************************************
* digi_otn_server_ho_prov_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the OTN High Order channel pointer based on the OTN server 
*   channel entity.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *otn_server_ptr        - pointer to OTU framer to configure ODU HO container
*                            against
*
* OUTPUTS:
*   **out_chnl_ctxt_pptr   - pointer to a pointer to a context for the HO
*                            framer channel
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_ho_prov_chnl_get(digi_handle_t *digi_handle,
                                                  digi_otn_server_chnl_t *otn_server_ptr,
                                                  digi_otn_odu_chnl_t **out_chnl_ctxt_pptr)
{
    PMC_ERROR result = DIGI_ERR_NULL_HANDLE;

    odu_struct_t *odu_struct_ptr = NULL;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    if (out_chnl_ctxt_pptr == NULL || otn_server_ptr == NULL)  {

        result = DIGI_ERR_NULL_HANDLE;

    } 
    else if (PMC_SUCCESS != digi_otn_server_chnl_handle_validate(digi_handle, otn_server_ptr))
    {       
        result = DIGI_ERR_INVALID_ARG; 
    }
    else 
    {
        BOOL8 is_sysotn = DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle);
        UINT32 chnl_id = ((digi_otn_server_chnl_def_t *)otn_server_ptr)->dci_chnl;
        /*
         * If this is sysotn and sys_line_src is false meaning this is a
         * line side call then the data is in the lo order struct.
         * Otherwise if this sysotn and sys_line_src is true or this is
         * a normal line side call then the data is in the high order
         * structure.
         */
        if (TRUE == is_sysotn && FALSE == ((digi_otn_server_chnl_def_t *)otn_server_ptr)->sys_line_src)
        {
            odu_struct_ptr = &(digi_handle->handle_pool.lo_odu_struct[chnl_id]);
        }
        else
        {
            odu_struct_ptr = &(digi_handle->handle_pool.ho_odu_struct[chnl_id]);
        }
    }

    if (NULL == odu_struct_ptr) 
    {
        result = DIGI_ERR_NULL_HANDLE;
    } 
    else if (UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG ==
             odu_struct_ptr->switch_data.header.prov_state)
    {
        result = DIGI_ERR_INCORRECT_ODU_PROV_MODE;
    } 
    else 
    {
        *out_chnl_ctxt_pptr = (digi_otn_odu_chnl_t *)odu_struct_ptr;
        result = PMC_SUCCESS;
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_server_ho_prov_chnl_get */

/*******************************************************************************
* digi_otn_server_lo_prov_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  This function retrieves the low order channel from the channel identifier
*  determined from the tributary mask. The channel ID is grabbed from RX database.
*  This function only applies for the scenario that the channel ID is the same  
*  for TX and RX.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   *in_chnl_ctxt_ptr   - pointer to higher order channel containing the
*                         low order framer to be provisioned. 
*   cfg_mode            - See digi_otn_cfg_mode_t for definition.
*   trib_slot_mask      - tributary slots low order container will use in
*                         higher order payload.
*                         For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, the number of
*                         bits set in this mask should match the number of 
*                         tributary slots in the ODUFlex container.
*
* OUTPUTS:
*   **out_chnl_ctxt_pptr    - pointer to a pointer to a context for the LO
*                             framer channel
*
* RETURNS:
*   PMC_SUCCESS: Everything went as expected
*   PMC_ERROR: An error occurred retrieving the lo order channel.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_lo_prov_chnl_get( digi_handle_t *digi_handle,
                                                   digi_otn_odu_chnl_t *in_chnl_ctxt_ptr,
                                                   digi_otn_cfg_mode_t cfg_mode,
                                                   UINT32 trib_slot_mask[3],
                                                   digi_otn_odu_chnl_t **out_chnl_ctxt_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;

    /* get the HO framer channel context */
    odu_struct_t *ho_odu_struct_ptr = (odu_struct_t *)in_chnl_ctxt_ptr;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    if (in_chnl_ctxt_ptr == NULL)  
    {
        result = DIGI_ERR_NULL_HANDLE;
    } 
    else if (PMC_SUCCESS != digi_ho_odu_struct_handle_validate(digi_handle, in_chnl_ctxt_ptr) &&             
             PMC_SUCCESS != digi_mo_odu_struct_handle_validate(digi_handle, in_chnl_ctxt_ptr))
    {       
        result = DIGI_ERR_INVALID_ARG; 
    }
    else if (NULL == out_chnl_ctxt_pptr) 
    {
        result = DIGI_ERR_NULL_HANDLE;
    } 
    else if (DIGI_OTN_DIRECT_DEVICE_CONFIG != cfg_mode) 
    {
        result = DIGI_ERR_NO_SW_CONTENT;
    } 
    else if((ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.num_sub_container_rx == 0) && 
            (ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.num_sub_container_tx == 0)) 
    {
        /* There is no provisioned LO ODU channels, return error */
        result = DIGI_ERR_NO_LO_ODU_PROVISIONED;
    } 
    else 
    {
        odu_struct_t *lo_odu_struct_ptr = NULL;
        UINT32 i;
        UINT32 chnl_id = DIGI_DCI_CHANNEL_UNASSIGNED;
        UINT32 ho_cal_entries[UTIL_GLOBAL_MAX_NUM_CAL_ENTRY];
        UINT32 rx_mo_chnl_ids[UTIL_GLOBAL_MAX_NUM_CAL_ENTRY];
        UINT32 rx_lo_chnl_ids[UTIL_GLOBAL_MAX_NUM_CAL_ENTRY];
        UINT32 ho_chnl_ids[UTIL_GLOBAL_MAX_NUM_CAL_ENTRY];
        UINT32 num_ho_entries = 0;
        
        /* first check if the trib_slot_mask is in use */
        for (i = 0; i < DIGI_NUM_MAX_TS; i++) 
        {
            /* check only the first tributary slot as the first tributary slot is used
            ** as the triburary port of the LO channel
            */
            if ((trib_slot_mask[i/32] >> (i%32)) & 1) 
            {
                if ((ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.rx_trib_port[i] == DIGI_TRIBPORT_UNUSED) &&
                    (ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.tx_trib_port[i] == DIGI_TRIBPORT_UNUSED))
                {
                     /* The provided 'trib_slot_mask' is not in use. There is no valid channel handle to retrieve
                     ** return error
                     */ 
                    result = DIGI_ERR_UNUSED_TRIBSLOT;
                }
                break;
            }   
        }
        
        if (PMC_SUCCESS == result)
        {
            /* if HO payload is channelized, this is 1 stage muxing 
            ** add LO channel into the active HO channel
            */
            if ((UINT32)ho_odu_struct_ptr->mem_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
            { 
                result = coreotn_db_ho_cal_entries_mo_lo_chnl_get(digi_handle->coreotn_handle,
                                                                  ho_odu_struct_ptr->mem_ptr->chnl_id,
                                                                  1,
                                                                  ho_cal_entries,
                                                                  &num_ho_entries,
                                                                  ho_chnl_ids,
                                                                  rx_mo_chnl_ids,
                                                                  rx_lo_chnl_ids); 
            
                if (PMC_SUCCESS == result) 
                {
                    for (i = 0; i < DIGI_SCHD_96_ENTRY; i++) 
                    {
                        if ((trib_slot_mask[i/32] >> (i%32)) & 1) 
                        {
                            chnl_id = rx_mo_chnl_ids[i];
                            break;
                        }   
                    }
            
                    if (DIGI_CHANNEL_UNASSIGNED_FOR_TRIBPORT == chnl_id)
                    {   
                        result = DIGI_ERR_CHANNEL_ID_UNASSIGNED; 
                        
                    } else {
                        /* obtain odu_struct for MO channel */
                        lo_odu_struct_ptr = &(digi_handle->handle_pool.mo_odu_struct[chnl_id]);
                    }
                }
            }
            else if ((UINT32)ho_odu_struct_ptr->mem_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU)
            { 
                result = coreotn_db_mo_cal_entries_lo_chnl_get(digi_handle->coreotn_handle,
                                                               ho_odu_struct_ptr->mem_ptr->chnl_id,
                                                               1,
                                                               ho_cal_entries,
                                                               &num_ho_entries,
                                                               rx_mo_chnl_ids,
                                                               rx_lo_chnl_ids);
            
                if (PMC_SUCCESS == result) 
                {
                    for (i = 0; i < DIGI_SCHD_96_ENTRY; i++) 
                    {
                        if ((trib_slot_mask[i/32] >> (i%32)) & 1) 
                        {
                            chnl_id = rx_lo_chnl_ids[i];
                            break;
                        }   
                    }
            
                    if (DIGI_CHANNEL_UNASSIGNED_FOR_TRIBPORT == chnl_id)
                    {
                        
                        result = DIGI_ERR_CHANNEL_ID_UNASSIGNED; 
                        
                    } else {
                        /* obtain odu_struct for LO channel */
                        lo_odu_struct_ptr = &(digi_handle->handle_pool.lo_odu_struct[chnl_id]);
                    }
                }
            } 
        }
        
        if (PMC_SUCCESS == result)
        { 
            if (NULL == lo_odu_struct_ptr || 
                (TRUE != util_global_rx_or_tx_chnl_prov_status_get(lo_odu_struct_ptr->switch_data.header.prov_state)) ||
                lo_odu_struct_ptr->mem_ptr->chnl_id != chnl_id)
            {
                
                result = DIGI_ERR_INVALID_ARG;
                
            } else {
              
                *out_chnl_ctxt_pptr = (digi_otn_odu_chnl_t *)lo_odu_struct_ptr;
            }
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_server_lo_prov_chnl_get */

/*******************************************************************************
* digi_enet_prov_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_ctxt_ptr         - Port datapath handle defining the physcial SerDes
*                            to configure the ENET_LINE resource against.\n
*
* OUTPUTS:
*   **chnl_ctxt_pptr       - a pointer to a pointer to a digi_enet_client_chnl_t
*                            structure consisting of a dsi_base_lane, link, and
*                            util_global_cpb_port_data_t that is returned to
*                            the user.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_enet_prov_chnl_get(digi_handle_t *digi_handle,
                                         digi_serdes_port_t *port_ctxt_ptr,
                                         digi_enet_client_chnl_t **chnl_ctxt_pptr)
{
    PMC_ERROR result = DIGI_ERR_NULL_HANDLE;

    digi_post_mld_dsi_ctxt_t *post_mld_dsi_ptr = NULL;
    util_global_cpb_port_t port_type;
    digi_serdes_intf_t intf;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    intf = ((digi_serdes_port_def_t *)port_ctxt_ptr)->intf;

    
    if (chnl_ctxt_pptr == NULL)
    {
        result = DIGI_ERR_NULL_HANDLE;
    }
    else if (PMC_SUCCESS != digi_serdes_port_ctxt_validate(digi_handle, port_ctxt_ptr))
    {
        result = DIGI_ERR_INVALID_ARG;
    } 
    else if (intf >= LAST_DIGI_SERDES_INTF) 
    {
        result = DIGI_ERR_INVALID_ARG;
    } 
    else if (DIGI_SERDES_SYSTEM_INTF == intf) 
    {
        if (DIGI_PROD_APP_100G_3_X_40G_CFP_CARD == digi_handle->var.prod_app)
        {
            port_type = UTIL_GLOBAL_CPB_PORT_ENET_LINE;
            post_mld_dsi_ptr = digi_first_post_mld_dsi_find(digi_handle, ((digi_serdes_port_def_t*)port_ctxt_ptr)->port_uid);
        }
        else
        {
            port_type = UTIL_GLOBAL_CPB_PORT_ENET_SYS;
            post_mld_dsi_ptr = digi_first_sys_post_mld_dsi_find(digi_handle, ((digi_serdes_port_def_t*)port_ctxt_ptr)->port_uid);
        }

    } 
    else if (DIGI_SERDES_LINE_INTF == intf) 
    {
        port_type = UTIL_GLOBAL_CPB_PORT_ENET_LINE;
        post_mld_dsi_ptr = digi_first_post_mld_dsi_find(digi_handle, ((digi_serdes_port_def_t*)port_ctxt_ptr)->port_uid);
    }

    if (NULL == post_mld_dsi_ptr)
    {
        result = DIGI_ERR_NULL_HANDLE;
    } 
    else 
    {
        UINT32  enet_link = post_mld_dsi_ptr->lane_index;
        digi_enet_client_chnl_def_t* chnl_ctxt_ptr = NULL;

        if (DIGI_SERDES_LINE_INTF == intf ||
            (DIGI_SERDES_SYSTEM_INTF == intf &&
             DIGI_PROD_APP_100G_3_X_40G_CFP_CARD == digi_handle->var.prod_app))
        {
            chnl_ctxt_ptr = &(digi_handle->handle_pool.enet_line_chnl[enet_link]);
        }
        else if (DIGI_SERDES_SYSTEM_INTF == intf)
        {
            chnl_ctxt_ptr = &(digi_handle->handle_pool.enet_sys_chnl[enet_link]);
        } 

        if (NULL == chnl_ctxt_ptr || 
            (TRUE != util_global_rx_or_tx_chnl_prov_status_get(chnl_ctxt_ptr->switch_data.header.prov_state)) ||
            chnl_ctxt_ptr->switch_data.cpb_data.port_type != port_type) 
        {
            result = DIGI_ERR_INVALID_ARG;
        } 
        else 
        {
            *chnl_ctxt_pptr = (digi_enet_client_chnl_t*)chnl_ctxt_ptr;
            result = PMC_SUCCESS;
        }
    }        
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_enet_prov_chnl_get */

/*******************************************************************************
* digi_cbr_client_prov_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_ctxt_ptr         - Port datapath handle used to configure the
*                            CBRC resource.
*
* OUTPUTS:
*   **chnl_ctxt_pptr       - a pointer to a pointer to a digi_enet_client_chnl_t
*                            structure consisting of a dsi_base_lane, link, and
*                            util_global_cpb_port_data_t that is returned to
*                            the user.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cbr_client_prov_chnl_get(digi_handle_t *digi_handle,
                                               digi_serdes_port_t *port_ctxt_ptr,
                                               digi_cbr_client_chnl_t **chnl_ctxt_pptr)
{
    PMC_ERROR result = DIGI_ERR_NULL_HANDLE;

    digi_cbr_client_chnl_def_t* chnl_ctxt_ptr = NULL;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    if (chnl_ctxt_pptr == NULL)
    {
        result = DIGI_ERR_NULL_HANDLE;
    }
    else if (PMC_SUCCESS != digi_serdes_port_ctxt_validate(digi_handle, port_ctxt_ptr))
    {
        result = DIGI_ERR_INVALID_ARG;
    } 
    else
    {
        UINT32 port_uid = ((digi_serdes_port_def_t *)port_ctxt_ptr)->port_uid;
        UINT32 i;

        for (i = 0; i < DIGI_CBRC_CHNL_MAX; i++)
        {
            if (digi_handle->handle_pool.cbr_chnl[i].port_uid == port_uid &&
                (TRUE == util_global_rx_or_tx_chnl_prov_status_get(digi_handle->handle_pool.cbr_chnl[i].switch_data.header.prov_state)))
            {
                chnl_ctxt_ptr = &(digi_handle->handle_pool.cbr_chnl[i]);
                break;
            }
        }
    }

    if (NULL != chnl_ctxt_ptr)
    {
        *chnl_ctxt_pptr = (digi_cbr_client_chnl_t*)chnl_ctxt_ptr;
        result = PMC_SUCCESS;
    }        

     PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_cbrc_prov_chnl_get */

#ifndef DOXYGEN_PUBLIC_ONLY
/*******************************************************************************
* digi_enet_is_link_in_use
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The is a helper function that determines if the requested enet link is in
*   use and if so, in what fashion.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   enet_link              - the ethernet_link
*   group_size             - the size of the link. See digi_group_size_t for 
*                            more info.
*   port_type              - the util_global_cbp_port_t. Should be
*                            ENET_LINE/ENET_SYS only
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_enet_is_link_in_use(digi_handle_t* digi_handle,
                                          UINT32 enet_link, 
                                          digi_group_size_t group_size,
                                          util_global_cpb_port_t port_type)
{
    UINT8 num_lanes_req = 0;
    UINT8 i = 0;
    digi_mapper_alloc_t map_type = LAST_DIGI_MAPPER_ALLOC;
    UINT16 digi_enet_mask = 1;

    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    if (port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE) {

        switch(group_size)
        {
        case DIGI_GRP_SIZE_10G:
            num_lanes_req = DIGI_SERDES_LINE_LANES_FOR_10G;
            break;
        case DIGI_GRP_SIZE_40G:
            num_lanes_req = DIGI_SERDES_LINE_LANES_FOR_40G;
            break;
        case DIGI_GRP_SIZE_100G:
            num_lanes_req = DIGI_SERDES_LINE_LANES_FOR_100G;
            break;
        default:
            PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
            break;
        }


        for (i = enet_link, digi_enet_mask = digi_enet_mask << enet_link;
             i < enet_link + num_lanes_req; 
             i++, 
                 digi_enet_mask = digi_enet_mask << DIGI_SERDES_LINE_LANES_FOR_10G) {

            map_type = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].map_type;

            if ((map_type == DIGI_MAPPER_ALLOC_ENET_LINE) || 
                (map_type == DIGI_MAPPER_ALLOC_MAPPER_WITH_ENET_LINE) || 
                (map_type == DIGI_MAPPER_ALLOC_MAPPER_AND_ENET_LINE)) {

                result = DIGI_ERR_ENET_LINE_RESOURCE_NOT_AVAILABLE;
                break;

            } else if ((digi_enet_mask & digi_handle->var.digi_enet_pmon_line_usage) != 0) {

                result = DIGI_ERR_ENET_LINE_RESOURCE_NOT_AVAILABLE;
                break;
            }
        }


    } else if (port_type == UTIL_GLOBAL_CPB_PORT_ENET_SYS) {

        switch(group_size)
        {
        case DIGI_GRP_SIZE_10G:
            num_lanes_req = DIGI_SERDES_SYS_LANES_FOR_10G;
            break;
        case DIGI_GRP_SIZE_40G:
            num_lanes_req = DIGI_SERDES_SYS_LANES_FOR_40G;
            break;
        case DIGI_GRP_SIZE_100G:
            num_lanes_req = DIGI_SERDES_SYS_LANES_FOR_100G;
            break;
        default:
            PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
            break;
        }

        for (i = enet_link, digi_enet_mask = digi_enet_mask << enet_link;
             i < enet_link + num_lanes_req; 
             i++, digi_enet_mask = digi_enet_mask << DIGI_SERDES_LINE_LANES_FOR_10G) {

            if ((digi_enet_mask & digi_handle->var.digi_enet_pmon_sys_usage) != 0) {

                result = DIGI_ERR_ENET_SYS_RESOURCE_NOT_AVAILABLE;
                break;
            }
        }

    } else {

        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    if (i == (enet_link + num_lanes_req)) { 

        result = PMC_SUCCESS;
    }

    PMC_RETURN(result);
    
} /* digi_enet_is_link_in_use */

/*******************************************************************************
* digi_enet_pmon_prov_params_convert
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the adaptaion function and group
*   size for enet sys when acting as PMON only mode.
*
* INPUTS:
*   mode             - the enet PMON mode
*
* OUTPUTS:
*   *group_size      - the number of post MLD DSI lanes required for this mode.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_enet_pmon_prov_params_convert(enet_datapath_t mode, 
                                               digi_group_size_t* group_size)
{
    PMC_ENTRY();

    switch(mode) {
    case ENET_SLAVE_100GE_TRANSPARENT_TX_PMON:
    case ENET_SLAVE_100GE_MAC_TX_PMON:
        *group_size = DIGI_GRP_SIZE_100G;
        break;
    case ENET_SLAVE_40GE_TRANSPARENT_TX_PMON:
    case ENET_SLAVE_40GE_MAC_TX_PMON:
        *group_size = DIGI_GRP_SIZE_40G;
        break;
    case ENET_SLAVE_10GE_TRANSPARENT_TX_PMON:
    case ENET_SLAVE_10GE_GSUP43_7_3_TRANSPARENT_TX_PMON:
    case ENET_SLAVE_10GE_MAC_TX_PMON:
        *group_size = DIGI_GRP_SIZE_10G;
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        break;
    }

    PMC_RETURN();
} /* digi_enet_pmon_prov_params_convert */

/*******************************************************************************
* digi_serdes_line_port_init()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This is a helper function digi_serdes_port_init() and handles the case for
*   the xfi port type.\n\n
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   port_uid               - Unique user assigned value for identifying
*                            serdes port.  The value 0xFFFFFFFF
*                            DIGI_SERDES_UNASSIGNED is reserved as the
*                            default unassigned setting.
*   module_lane_tx         - Applicable to Tx Serdes Lanes:\n\n
*                            For intf of DIGI_SERDES_LINE_INTF or 
*                            DIGI_SERDES_SYSTEM_INTF, array defining set of 
*                            interface pins and logical sequence of these pins 
*                            relative to the module pins for a serdes port.  
*                            Pins not associated with the serdes port must be 
*                            set to DIGI_SERDES_UNASSIGNED.\n\n
*                            For intf DIGI_SERDES_SFI_51_INTF, first 2 index
*   module_lane_rx         - Applicable to Rx Serdes Lanes:\n\n
*                            See module_lane_tx description. module_lane_rx must
*                            be the same as module_lane_tx for 10G serdes ports.
*                            Otherwise the pin sequence may be uniquely defined
*                            if required.
*   los_pin                - The device pin transferring the LOS input from 
*                            optical module.
*                            Setting this to a value of DIGI_SERDES_PORT_DLOS_LOS_SOURCE
*                            will set this serdes lane to ignore the LOS pin
*                            and use its internal DLOS as a LOS source.
*                            Setting this to a value of DIGI_SERDES_PORT_NO_LOS_SOURCE
*                            will disable the LOS feature.
*   los_inv                - Module LOS logical state definition:\n
*                            TRUE: In LOS state logic 0
*                            FALSE: In LOS state logic 1
*   *s16_clk_cfg_ptr       - The configuration of the additional serdes as a clock
*                            at he nominal rate of the datapath with a specified 
*                            divider. The pin index of this serdes shall be not 
*                            used be any other serdes ports.\n
*                            This input must be set to NULL when a clock is not 
*                            requested
*
* OUTPUTS:
*   **port_ctxt_pptr       - Pointer to serdes port data used for identifying
*                            serdes context for usage by other API of the SW
*                            driver.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_serdes_line_port_init(digi_handle_t *digi_handle,
                                             UINT32 port_uid,
                                             UINT32 module_lane_tx[DIGI_SERDES_XFI_LANES_MAX],
                                             UINT32 module_lane_rx[DIGI_SERDES_XFI_LANES_MAX],
                                             UINT8 los_pin,
                                             BOOL los_inv,
                                             digi_s16_clk_cfg_t *s16_clk_cfg_ptr,
                                             digi_serdes_port_t **port_ctxt_pptr)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    UINT32 i = 0;
    digi_serdes_port_def_t *port_def_ptr = NULL;
    digi_xfi_pin_ctxt_t *xfi_ctxt_ptr = NULL;
    UINT8 bw_alloc = 0;
    UINT32 master_lane = 0;
    BOOL  first_pin_set = FALSE; 
    UINT8 cage_pin_count;
    digi_xfi_pin_ctxt_t *xfi_pin_up_ptr[DIGI_SERDES_LINE_LANES_FOR_100G];
    UINT8 lane_order_count = 0;
    BOOL8 is_cfp;

    PMC_ENTRY();

    is_cfp = (DIGI_PROD_APP_100G_3_X_40G_CFP_CARD == digi_handle->var.prod_app) ? TRUE : FALSE;

    /* Find the first free port of the following type */
    port_def_ptr = digi_port_ctxt_find(digi_handle,
                                       DIGI_SERDES_UNASSIGNED,
                                       DIGI_SERDES_LINE_INTF);

    if (port_def_ptr == NULL) {

        rc = DIGI_ERR_SERDES_ALL_PORTS_PROV;

    } else {

        /* Check to see if the module_lane_tx & rx is sane before proceeding */
        /* Also obtain the amount of BW this will consume */
        rc = digi_line_lane_validate_and_count(digi_handle,
                                               module_lane_tx, 
                                               module_lane_rx, 
                                               los_pin,
                                               s16_clk_cfg_ptr,
                                               &bw_alloc,
                                               &cage_pin_count);
    }
    
    if (rc == PMC_SUCCESS) {
        
        /* If a CFP (1x100G in a 10 pin) (1x40G in 10 pin cage) has
           already been configured, we can not configure anything more
           against this interface */
        if (digi_handle->var.line_port_bw.is_port_cfp == TRUE) {
            
            rc = DIGI_ERR_MAX_BWTH_PROV;

        } else if ((digi_handle->var.line_port_bw.total_port_bw_cfgd + bw_alloc) > DIGI_PORT_BANDWIDTH_MAX) {

            rc = DIGI_ERR_MAX_BWTH_PROV;

        } else {
            /* If this is a 100G Port or a 40G Port and the cage
               has been configured for CFP, then mark the port as
               CFP so that nothing else can get provisioned against
               this interface */
            if ((bw_alloc == DIGI_PORT_BANDWIDTH_100G) &&
                (digi_handle->var.cage_cfg.is_line_cfp == TRUE)) {
                
                digi_handle->var.line_port_bw.is_port_cfp = TRUE;

                /* Same as above case */
            } else if ((bw_alloc == DIGI_PORT_BANDWIDTH_40G) &&
                       (digi_handle->var.cage_cfg.is_line_cfp == TRUE)) {

                digi_handle->var.line_port_bw.is_port_cfp = TRUE;

                /* Cannot provision 100G against non 100G cage. */
            } else if ((bw_alloc == DIGI_PORT_BANDWIDTH_100G) &&
                       (digi_handle->var.cage_cfg.is_line_cfp != TRUE)) {
                rc = DIGI_ERR_PORT_PROV_CAGE_FAIL;
                
                /* Cannot provision 10G against 100G cage. */
            } else if ((bw_alloc == DIGI_PORT_BANDWIDTH_10G) &&
                       (digi_handle->var.cage_cfg.is_line_cfp == TRUE)) {
                rc = DIGI_ERR_PORT_PROV_CAGE_FAIL;
            }
            /* check that 10G port is mapped to 1- or 4-pin cage */
            else if ((cage_pin_count != DIGI_SERDES_LINE_LANES_FOR_40G &&
                      cage_pin_count != DIGI_SERDES_LINE_LANES_FOR_10G) &&
                     bw_alloc == DIGI_PORT_BANDWIDTH_10G)
            {
                rc = DIGI_ERR_SERDES_10G_PORT_CAGE_INVALID;
            }
            
            if (rc == PMC_SUCCESS) 
            {
                /* All checks passed. Provision the port and pins */
                for (i = 0; i < DIGI_SERDES_XFI_LANES_MAX && PMC_SUCCESS == rc; i++) 
                {
                    if (module_lane_tx[i] != DIGI_SERDES_PIN_NOT_USED) 
                    {
                        xfi_ctxt_ptr = &(digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i]);
                        xfi_ctxt_ptr->port_uid = port_uid;
                        xfi_ctxt_ptr->los_pin = los_pin;

                        if(los_pin == DIGI_SERDES_PORT_DLOS_LOS_SOURCE)
                        {
                            rc = lifd_los_internal_context_set(digi_handle->lifd_handle, i, i, TRUE);

                        }
                        else if (los_pin == DIGI_SERDES_PORT_NO_LOS_SOURCE)
                        {
                            rc = lifd_los_internal_context_set(digi_handle->lifd_handle,i,los_pin, TRUE);
                        }

                        if (PMC_SUCCESS == rc)
                        {
                            xfi_ctxt_ptr->los_inv = los_inv;
                            xfi_ctxt_ptr->module_lane_tx_index = module_lane_tx[i];
                            xfi_ctxt_ptr->module_lane_rx_index = module_lane_rx[i];
                            
                            /* save 4-pin 40G serdes port xfi context pointer, there will be used
                               to operation dsi lane assignment */
                            if (FALSE == is_cfp &&
                                TRUE == digi_device_init_status_get(digi_handle) &&
                                (cage_pin_count == DIGI_SERDES_LINE_LANES_FOR_40G ||
                                (DIGI_PROD_APP_SYSOTN_CARD == digi_handle->var.prod_app && 
                                cage_pin_count == DIGI_SERDES_LINE_LANES_FOR_100G)))
                            {
                                xfi_pin_up_ptr[lane_order_count] = xfi_ctxt_ptr;
                                lane_order_count += 1;
                            }
                            if (first_pin_set == FALSE) 
                            {
                              
                              master_lane = i;
                              first_pin_set = TRUE;
                            }
                        }
                    }
                }

                if (PMC_SUCCESS == rc)
                {
                    port_def_ptr->master_lane = master_lane;
                    port_def_ptr->port_uid = port_uid;
                    port_def_ptr->intf = DIGI_SERDES_LINE_INTF;
                    port_def_ptr->los_pin = los_pin;
                    
                    if ((los_pin != DIGI_SERDES_PORT_DLOS_LOS_SOURCE) &&
                        (los_pin != DIGI_SERDES_PORT_NO_LOS_SOURCE)) { 
                      /* use LOS */
                      rc = lifd_los_internal_context_set(digi_handle->lifd_handle,los_pin,los_pin,TRUE);
                    }
                }
            }
            if (rc == PMC_SUCCESS) {            

                /* store s16 clk configuration */
                if (NULL == s16_clk_cfg_ptr) 
                {
                    port_def_ptr->s16_clk_cfg.pin_index = DIGI_SERDES_PIN_NOT_USED;
                } else 
                {
                    PMC_MEMCPY(&port_def_ptr->s16_clk_cfg, s16_clk_cfg_ptr, sizeof(digi_s16_clk_cfg_t));
                }
                *port_ctxt_pptr = (digi_serdes_port_t*)port_def_ptr; 

                /* Increment used bandwidth */
                digi_handle->var.line_port_bw.total_port_bw_cfgd += bw_alloc;
                rc = digi_serdes_port_rate_state_set(digi_handle, port_def_ptr, LAST_DIGI_SERDES_PORT_MODE, DIGI_SERDES_PROV_STATE_UNASSIGNED, DIGI_SERDES_PORT_RATE_STATE_DEPROV);
            }
        }
    }

    if (PMC_SUCCESS == rc)
    {
        /* consider port initialized only when post dsi lane is updated */
        if (FALSE == is_cfp &&
            TRUE == digi_device_init_status_get(digi_handle))
        {
            
            /* update dsi lane associated to serdes pin when device is already in initialized 
               dsi lane are reused after device init */
            UINT32 jtr;
            UINT32 ltr;
            /* order pin context per dsi lane */
            if(lane_order_count == DIGI_SERDES_LINE_LANES_FOR_40G)
            {
                digi_xfi_pin_ctxt_t *tmp;
                for (jtr = 0; jtr < DIGI_SERDES_LINE_LANES_FOR_40G; jtr+=1)
                {
                    for (ltr = jtr + 1; ltr < DIGI_SERDES_LINE_LANES_FOR_40G; ltr+=1)
                    {
                        if (xfi_pin_up_ptr[jtr]->module_lane_tx_index > xfi_pin_up_ptr[ltr]->module_lane_tx_index)
                        {
                            tmp = xfi_pin_up_ptr[ltr];
                            xfi_pin_up_ptr[ltr] = xfi_pin_up_ptr[jtr];
                            xfi_pin_up_ptr[jtr] = tmp;
                        }
                    }
                }
            }
            else if(DIGI_PROD_APP_SYSOTN_CARD == digi_handle->var.prod_app &&
                    lane_order_count == DIGI_SERDES_LINE_LANES_FOR_100G)
            {
                digi_xfi_pin_ctxt_t *tmp;
                for (jtr = 0; jtr < DIGI_SERDES_LINE_LANES_FOR_100G; jtr+=1)
                {
                    for (ltr = jtr + 1; ltr < DIGI_SERDES_LINE_LANES_FOR_100G; ltr+=1)
                    {
                        if (xfi_pin_up_ptr[jtr]->module_lane_tx_index > xfi_pin_up_ptr[ltr]->module_lane_tx_index)
                        {
                            tmp = xfi_pin_up_ptr[ltr];
                            xfi_pin_up_ptr[ltr] = xfi_pin_up_ptr[jtr];
                            xfi_pin_up_ptr[jtr] = tmp;
                        }
                    }
                }
            }

            ltr = 0;

            if(DIGI_PROD_APP_SYSOTN_CARD == digi_handle->var.prod_app &&
               (lane_order_count == DIGI_SERDES_LINE_LANES_FOR_100G))
            {
                for (jtr = 0; jtr < DIGI_SERDES_DSI_LANES_MAX && ltr < lane_order_count; jtr++) 
                {
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[jtr].port_uid = port_uid;   
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[jtr].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;   

                    xfi_pin_up_ptr[ltr]->post_mux_dsi_lane = jtr;
                    ltr += 1;
                }
            }
            else
            {
                /* reuse dsi lane already allocated during digi_device_init() */
                for (jtr = 0; jtr < DIGI_SERDES_DSI_LANES_MAX && ltr < lane_order_count; jtr++)
                {    
                    if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[jtr].cage_uid == xfi_pin_up_ptr[ltr]->cage_id && 
                        (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[jtr].prov_state == DIGI_SERDES_PROV_STATE_NO_SERDES) && 
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[jtr].port_uid == DIGI_SERDES_UNASSIGNED)
                    {
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[jtr].port_uid = port_uid;   
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[jtr].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;   

                        if (DIGI_SERDES_PIN_NOT_USED == xfi_pin_up_ptr[ltr]->post_mux_dsi_lane)
                        {
                            xfi_pin_up_ptr[ltr]->post_mux_dsi_lane = jtr;
                            ltr += 1;
                        }
                    }
                }
            }

            /* confirm initialization only if dsi lanes are assigned to all pins */
            if (ltr == lane_order_count)
            {
                port_def_ptr->init = TRUE;
            }
            else
            {
                rc = DIGI_ERR_NO_DSI_ALLOC_PROV; 
                /* cancel dsi assignement */
                ltr = 0;
                for (jtr = 0; jtr < DIGI_SERDES_DSI_LANES_MAX && ltr < lane_order_count; jtr++) 
                {
                    
                    if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[jtr].port_uid == port_uid)
                    {
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[jtr].port_uid = DIGI_SERDES_UNASSIGNED;   
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[jtr].prov_state = DIGI_SERDES_PROV_STATE_NO_SERDES;   
                        xfi_pin_up_ptr[ltr]->post_mux_dsi_lane = DIGI_SERDES_PIN_NOT_USED;
                    }
                }                
            }
        }
    }
    
    PMC_RETURN(rc);
} /* digi_serdes_line_port_init */

/*******************************************************************************
* digi_serdes_line_port_uninit()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This is a helper function digi_serdes_port_uninit() and handles the case for
*   the line xfi port type.\n\n
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_def_ptr          - Pointer to serdes port data used for identifying
*                            serdes context for usage by other API of the SW
*                            driver.
*
* OUTPUTS:
*    None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_serdes_line_port_uninit(digi_handle_t *digi_handle,
                                               digi_serdes_port_def_t *port_def_ptr)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;

    UINT8 bw_alloc = 0;

    PMC_ENTRY();

    if (port_def_ptr == NULL) {

        PMC_ASSERT(FALSE, DIGI_ERR_NULL_HANDLE, 0, 0);

    } else {

        /* Check to see if the post mld lanes are Provisioned against any SS */
        /* Also obtain the amount of BW this did consume */
        rc = digi_line_lane_clear_and_bw_get(digi_handle,
                                             port_def_ptr,
                                             &bw_alloc);
    

        if (rc == PMC_SUCCESS) {

            /* Decrement used bandwidth */
            digi_handle->var.line_port_bw.total_port_bw_cfgd -= bw_alloc;

            digi_handle->var.line_port_bw.is_port_cfp = FALSE;

            rc = digi_serdes_port_rate_state_set(digi_handle, port_def_ptr, LAST_DIGI_SERDES_PORT_MODE, DIGI_SERDES_PROV_STATE_NO_SERDES, DIGI_SERDES_PORT_RATE_STATE_DEPROV);
        }
    }

    PMC_RETURN(rc);
} /* digi_serdes_line_port_uninit */

/*******************************************************************************
* digi_serdes_sys_port_uninit()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This is a helper function digi_serdes_port_uninit() and handles the case for
*   the sys xfi port type.\n\n
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_def_ptr          - Pointer to serdes port data used for identifying
*                            serdes context for usage by other API of the SW
*                            driver.
*
* OUTPUTS:
*    None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_serdes_sys_port_uninit(digi_handle_t *digi_handle,
                                              digi_serdes_port_def_t *port_def_ptr)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    UINT8 bw_alloc = 0;

    PMC_ENTRY();

    if (port_def_ptr == NULL) {

        PMC_ASSERT(FALSE, DIGI_ERR_NULL_HANDLE, 0, 0);

    } else {

        /* Check to see if the post mld lanes are Provisioned against any SS */
        /* Also obtain the amount of BW this did consume */
        rc = digi_sys_lane_clear_and_bw_get(digi_handle,
                                            port_def_ptr,
                                            &bw_alloc);
    
        if (rc == PMC_SUCCESS) {

            /* Decrement used bandwidth */
            digi_handle->var.sys_port_bw.total_port_bw_cfgd -= bw_alloc;

            rc = digi_serdes_port_rate_state_set(digi_handle, port_def_ptr, LAST_DIGI_SERDES_PORT_MODE, DIGI_SERDES_PROV_STATE_NO_SERDES, DIGI_SERDES_PORT_RATE_STATE_DEPROV);
        }
    }

    PMC_RETURN(rc);
} /* digi_serdes_line_port_uninit */

/*******************************************************************************
* digi_serdes_sfi51_port_init()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This is a helper function digi_serdes_port_init() and handles the case for
*   the sfi port type.\n\n
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   port_uid               - Unique user assigned value for identifying
*                            serdes port.  The value 0xFFFFFFFF
*                            DIGI_SERDES_UNASSIGNED is reserved as the
*                            default unassigned setting.
*   module_lane_tx         - Applicable to Tx Serdes Lanes:\n\n
*                            For intf of DIGI_SERDES_LINE_INTF or 
*                            DIGI_SERDES_SYSTEM_INTF, array defining set of 
*                            interface pins and logical sequence of these pins 
*                            relative to the module pins for a serdes port.  
*                            Pins not associated with the serdes port must be 
*                            set to DIGI_SERDES_UNASSIGNED.\n\n
*                            For intf DIGI_SERDES_SFI_51_INTF, first 2 index
*   module_lane_rx         - Applicable to Rx Serdes Lanes:\n\n
*                            See module_lane_tx description. module_lane_rx must
*                            be the same as module_lane_tx for 10G serdes ports.
*                            Otherwise the pin sequence may be uniquely defined
*                            if required.
*   los_inv                - Module LOS logical state definition:\n
*                            TRUE: In LOS state logic 0
*                            FALSE: In LOS state logic 1
*
* OUTPUTS:
*   **port_ctxt_pptr       - Pointer to serdes port data used for identifying
*                            serdes context for usage by other API of the SW
*                            driver.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_serdes_sfi51_port_init(digi_handle_t *digi_handle,
                                              UINT32 port_uid,
                                              UINT32 module_lane_tx[DIGI_NUM_SFI51_PORTS_MAX],
                                              UINT32 module_lane_rx[DIGI_NUM_SFI51_PORTS_MAX],
                                              BOOL los_inv,
                                              digi_serdes_port_t **port_ctxt_pptr)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    UINT32 i = 0;
    digi_serdes_port_def_t *port_def_ptr = NULL;
    digi_sfi51_bus_ctxt_t *sfi_ctxt_ptr = NULL;
    UINT8 bw_alloc = DIGI_PORT_BANDWIDTH_40G;

    PMC_ENTRY();

    /* Find the first free port of the following type */
    port_def_ptr = digi_port_ctxt_find(digi_handle,
                                       DIGI_SERDES_UNASSIGNED,
                                       DIGI_SERDES_SFI_51_INTF);

    if (port_def_ptr == NULL) {

        rc = DIGI_ERR_SERDES_ALL_PORTS_PROV;

    } else {

        /* Check to see if the module_lane is sane before proceeding */
        rc = digi_sfi51_bus_validate(digi_handle, module_lane_tx, module_lane_rx);
    }

    if (rc == PMC_SUCCESS) {

        /* All checks passed. Provision the port and bus */
        for (i = 0; i < DIGI_NUM_SFI51_PORTS_MAX; i++) {

            if (module_lane_tx[i] != DIGI_POST_MUX_BUS_UNUSED) {

                sfi_ctxt_ptr = &(digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[i]);
                sfi_ctxt_ptr->port_uid = port_uid;
                sfi_ctxt_ptr->post_mux_2G5_bus_allocation = (digi_post_mux_sfi51_bus_t)module_lane_tx[i];
                sfi_ctxt_ptr->los_inv = los_inv;

                if (module_lane_tx[i] == i) {
                    sfi_ctxt_ptr->lane_swap_tx = DIGI_SERDES_SFI51_SWAP_OFF;
                } else {
                    sfi_ctxt_ptr->lane_swap_tx = DIGI_SERDES_SFI51_SWAP_ON;
                }

                if (module_lane_rx[i] == i) {
                    sfi_ctxt_ptr->lane_swap_rx = DIGI_SERDES_SFI51_SWAP_OFF;
                } else {
                    sfi_ctxt_ptr->lane_swap_rx = DIGI_SERDES_SFI51_SWAP_ON;
                }
            }
        }

        port_def_ptr->port_uid = port_uid;
        port_def_ptr->intf = DIGI_SERDES_SFI_51_INTF;
        port_def_ptr->s16_clk_cfg.pin_index = DIGI_SERDES_PIN_NOT_USED;
        *port_ctxt_pptr = port_def_ptr;

        /* We add 40G because this interface is alwys 40G */
        digi_handle->var.line_port_bw.total_port_bw_cfgd += bw_alloc;
        rc = digi_serdes_port_rate_state_set(digi_handle, port_def_ptr, LAST_DIGI_SERDES_PORT_MODE, DIGI_SERDES_PROV_STATE_NO_SERDES, DIGI_SERDES_PORT_RATE_STATE_DEPROV);
        
    }

    PMC_RETURN(rc);
} /* digi_serdes_sfi51_port_init */

/*******************************************************************************
* digi_serdes_sys_port_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function digi_serdes_port_init() and handles the case for
*   the sys port type.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   port_uid               - Unique user assigned value for identifying
*                            serdes port.  The value 0xFFFFFFFF
*                            DIGI_SERDES_UNASSIGNED is reserved as the
*                            default unassigned setting.
*   module_lane_tx         - Applicable to Tx Serdes Lanes:\n\n
*                            For intf of DIGI_SERDES_LINE_INTF or 
*                            DIGI_SERDES_SYSTEM_INTF, array defining set of 
*                            interface pins and logical sequence of these pins 
*                            relative to the module pins for a serdes port.  
*                            Pins not associated with the serdes port must be 
*                            set to DIGI_SERDES_UNASSIGNED.\n\n
*                            For intf DIGI_SERDES_SFI_51_INTF, first 2 index
*   module_lane_rx         - Applicable to Rx Serdes Lanes:\n\n
*                            See module_lane_tx description. module_lane_rx must
*                            be the same as module_lane_tx for 10G serdes ports.
*                            Otherwise the pin sequence may be uniquely defined
*                            if required.
*   los_pin                - The pin index on which the LOS is carried.
*                            Valid values are are values within the module lanes.
*                            Setting this to a value of DIGI_SERDES_PORT_DLOS_LOS_SOURCE
*                            will set this serdes lane to ignore the LOS pin
*                            and use its internal DLOS as a LOS source.
*                            Setting this to a value of DIGI_SERDES_PORT_NO_LOS_SOURCE
*                            will disable the LOS feature.
*   los_inv                - Module LOS logical state definition:\n
*                            TRUE: In LOS state logic 0
*                            FALSE: In LOS state logic 1
*   *s16_clk_cfg_ptr       - The configuration of the additional serdes as a clock
*                            at he nominal rate of the datapath with a specified 
*                            divider. The pin index of this serdes shall be not 
*                            used be any other serdes ports.\n
*                            This input must be set to NULL when a clock is not 
*                            requested
* 
* OUTPUTS:
*   **port_ctxt_pptr       - Pointer to serdes port data used for identifying
*                            serdes context for usage by other API of the SW
*                            driver.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_serdes_sys_port_init(digi_handle_t *digi_handle,
                                            UINT32 port_uid,
                                            UINT32 module_lane_tx[DIGI_SERDES_SYS_LANES_MAX],
                                            UINT32 module_lane_rx[DIGI_SERDES_SYS_LANES_MAX],
                                            UINT8 los_pin,
                                            BOOL los_inv,
                                            digi_s16_clk_cfg_t *s16_clk_cfg_ptr,
                                            digi_serdes_port_t **port_ctxt_pptr)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    UINT32 i = 0;
    digi_serdes_port_def_t *port_def_ptr = NULL;
    digi_xfi_pin_ctxt_t *sys_ctxt_ptr = NULL;
    UINT8 bw_alloc;
    UINT32 master_lane = 0;
    BOOL first_pin_set = FALSE; 
    UINT8 cage_pin_count;
    digi_xfi_pin_ctxt_t *sys_pin_up_ptr[DIGI_SERDES_SYS_LANES_FOR_40G];
    UINT8 lane_order_count = 0;
    BOOL8 is_cfp;

    PMC_ENTRY();

    is_cfp = (DIGI_PROD_APP_100G_3_X_40G_CFP_CARD == digi_handle->var.prod_app) ? TRUE : FALSE;

    /* Find the first free port of the following type */
    port_def_ptr = digi_port_ctxt_find(digi_handle,
                                       DIGI_SERDES_UNASSIGNED,
                                       DIGI_SERDES_SYSTEM_INTF);

    if (port_def_ptr == NULL) {

        rc = DIGI_ERR_SERDES_ALL_PORTS_PROV;

    } else {

        /* Check to see if the module_lane is sane before proceeding */
        /* Also obtain the amount of BW this will consume */
        rc = digi_sys_lane_validate_and_count(digi_handle,
                                              module_lane_tx, 
                                              module_lane_rx, 
                                              los_pin,
                                              s16_clk_cfg_ptr,
                                              &bw_alloc,
                                              &cage_pin_count);
    }
            
    if (rc == PMC_SUCCESS) {
        /* If a CFP (1x100G in a 10 pin) (1x40G in 10 pin cage) has
           already been configured, we can not configure anything more
           against this interface */
        if (digi_handle->var.sys_port_bw.is_port_cfp == TRUE) {

            rc = DIGI_ERR_MAX_BWTH_PROV;

            /* If an attempt is made to configure more ports than the maximum
               available bandwith on this interface, fail. */
        
        } else {

            /* If this is a 100G Port or a 40G Port and the cage
               has been configured for CFP, then mark the port as
               CFP so that nothing else can get provisioned against
               this interface */
            if ((bw_alloc == DIGI_PORT_BANDWIDTH_100G) &&
                (digi_handle->var.cage_cfg.is_sys_cfp == TRUE)) {

                digi_handle->var.sys_port_bw.is_port_cfp = TRUE;

                /* Same as above case, but for 40G */
            } else if ((bw_alloc == DIGI_PORT_BANDWIDTH_40G) &&
                       (digi_handle->var.cage_cfg.is_sys_cfp == TRUE)) {

                digi_handle->var.sys_port_bw.is_port_cfp = TRUE;

                /* Cannot provision 100G against non 100G cage. */
            } else if ((bw_alloc == DIGI_PORT_BANDWIDTH_100G) &&
                       (digi_handle->var.cage_cfg.is_sys_cfp != TRUE)) {
                rc = DIGI_ERR_PORT_PROV_CAGE_FAIL;

                /* Cannot provision 10G against 100G cage. */
            } else if ((bw_alloc == DIGI_PORT_BANDWIDTH_10G) &&
                       (digi_handle->var.cage_cfg.is_sys_cfp == TRUE)) {
                rc = DIGI_ERR_PORT_PROV_CAGE_FAIL;
            }
            /* check that 10G port is mapped to 1- or 4-pin cage */
            else if ((cage_pin_count != DIGI_SERDES_SYS_LANES_FOR_40G &&
                      cage_pin_count != DIGI_SERDES_SYS_LANES_FOR_10G) &&
                     bw_alloc == DIGI_PORT_BANDWIDTH_10G)
            {
                rc = DIGI_ERR_SERDES_10G_PORT_CAGE_INVALID;
            }

            if (rc == PMC_SUCCESS) 
            {
                /* All checks passed. Provision the port and pins */
                for (i = 0; i < DIGI_SERDES_SYS_LANES_MAX && PMC_SUCCESS == rc; i++) 
                {                    
                    if (module_lane_tx[i] != DIGI_SERDES_PIN_NOT_USED) 
                    {
                        sys_ctxt_ptr = &(digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i]);
                        sys_ctxt_ptr->port_uid = port_uid;
                        sys_ctxt_ptr->los_pin = los_pin;  

                        if (los_pin == DIGI_SERDES_PORT_NO_LOS_SOURCE) 
                        {
                            /* use DLOS */
                            rc = sifd_los_internal_context_set(digi_handle->sifd_handle, i, los_pin);
                        }
                        else if (los_pin == DIGI_SERDES_PORT_DLOS_LOS_SOURCE)

                        {
                            /* use DLOS */
                            rc = sifd_los_internal_context_set(digi_handle->sifd_handle, i, i);
                        
                        }

                        if (PMC_SUCCESS == rc)
                        {
                            sys_ctxt_ptr->los_inv = los_inv;
                            sys_ctxt_ptr->module_lane_tx_index = module_lane_tx[i];
                            sys_ctxt_ptr->module_lane_rx_index = module_lane_rx[i];
 
                            /* save 4-pin 40G serdes port xfi context pointer, there will be used
                               to operation dsi lane assignment */
                            if (FALSE == is_cfp &&
                                TRUE == digi_device_init_status_get(digi_handle) &&
                                cage_pin_count == DIGI_SERDES_SYS_LANES_FOR_40G)
                              {
                                sys_pin_up_ptr[lane_order_count] = sys_ctxt_ptr;
                                lane_order_count += 1;
                              }

                            if (first_pin_set == FALSE) {

                              master_lane = i;
                              first_pin_set = TRUE;
                            }
                        }
                    }
                }

                if (PMC_SUCCESS == rc)
                {
                    port_def_ptr->master_lane = master_lane;
                    port_def_ptr->port_uid = port_uid;
                    port_def_ptr->intf = DIGI_SERDES_SYSTEM_INTF;
                    port_def_ptr->los_pin = los_pin;
                    
                    /*
                     * As with the line side set the los pin if it is not one
                     * of the DLOS values to ensure it gets set.
                     */
                    if (!(los_pin == DIGI_SERDES_PORT_DLOS_LOS_SOURCE ||
                          los_pin == DIGI_SERDES_PORT_NO_LOS_SOURCE))
                      {
                        rc = sifd_los_internal_context_set(digi_handle->sifd_handle, los_pin, los_pin);
                      }
                }

                if (PMC_SUCCESS == rc)
                {
                    /* store s16 clk configuration */
                    if (NULL == s16_clk_cfg_ptr) 
                      {
                        port_def_ptr->s16_clk_cfg.pin_index = DIGI_SERDES_PIN_NOT_USED;
                      } 
                    else 
                      {
                        PMC_MEMCPY(&port_def_ptr->s16_clk_cfg, s16_clk_cfg_ptr, sizeof(digi_s16_clk_cfg_t));
                      }
                    *port_ctxt_pptr = port_def_ptr;                
                    /* Increment used bandwidth */
                    digi_handle->var.sys_port_bw.total_port_bw_cfgd += bw_alloc;
                    rc = digi_serdes_port_rate_state_set(digi_handle, port_def_ptr, LAST_DIGI_SERDES_PORT_MODE, DIGI_SERDES_PROV_STATE_UNASSIGNED, DIGI_SERDES_PORT_RATE_STATE_DEPROV);
                }
            }
        }
    }

    if (PMC_SUCCESS == rc)
    {
        /* consider port initialized only when post dsi lane is updated */
        if (FALSE == is_cfp &&
            TRUE == digi_device_init_status_get(digi_handle))
        {          
            port_def_ptr->init = TRUE;
                
            /* update dsi lane associated to serdes pin when device is already in initialized 
               dsi lane are reused after device init */
            UINT32 jtr;
            UINT32 ltr;
            /* order pin context per dsi lane */
            if(lane_order_count == DIGI_SERDES_SYS_LANES_FOR_40G)
            {
                digi_xfi_pin_ctxt_t *tmp;
                for (jtr = 0; jtr < DIGI_SERDES_SYS_LANES_FOR_40G; jtr+=1)
                {
                    for (ltr = jtr + 1; ltr < DIGI_SERDES_SYS_LANES_FOR_40G; ltr+=1)
                    {
                        if (sys_pin_up_ptr[jtr]->module_lane_tx_index > sys_pin_up_ptr[ltr]->module_lane_tx_index)
                        {
                            tmp = sys_pin_up_ptr[ltr];
                            sys_pin_up_ptr[ltr] = sys_pin_up_ptr[jtr];
                            sys_pin_up_ptr[jtr] = tmp;
                        }
                    }
                }
            }
            ltr = 0;
            /* reuse dsi lane already allocated during digi_device_init() */
            for (jtr = 0; jtr < DIGI_SERDES_DSI_LANES_MAX && ltr < lane_order_count; jtr++) {
                
                if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[jtr].cage_uid == sys_pin_up_ptr[ltr]->cage_id && 
                    (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[jtr].prov_state == DIGI_SERDES_PROV_STATE_NO_SERDES) && 
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[jtr].port_uid == DIGI_SERDES_UNASSIGNED)
                {
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[jtr].port_uid = port_uid;   
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[jtr].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;   
                    if (DIGI_SERDES_PIN_NOT_USED == sys_pin_up_ptr[ltr]->post_mux_dsi_lane)
                    {
                        sys_pin_up_ptr[ltr]->post_mux_dsi_lane = jtr;
                        ltr += 1;
                    }
                }
            }

            /* confirm initialization only if dsi lanes are assigned to all pins */ 
            if (ltr == lane_order_count)
            {
                port_def_ptr->init = TRUE;
            }
            else
            {
                rc = DIGI_ERR_NO_DSI_ALLOC_PROV;
                /* cancel dsi assignement */
                ltr = 0;
                for (jtr = 0; jtr < DIGI_SERDES_DSI_LANES_MAX && ltr < lane_order_count; jtr++) 
                {
                    
                    if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[jtr].port_uid == port_uid)
                    {
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[jtr].port_uid = DIGI_SERDES_UNASSIGNED;   
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[jtr].prov_state = DIGI_SERDES_PROV_STATE_NO_SERDES;   
                        sys_pin_up_ptr[ltr]->post_mux_dsi_lane = DIGI_SERDES_PIN_NOT_USED;
                    }
                }                
            }
        }
    }

    PMC_RETURN(rc);

} /* digi_serdes_sys_port_init */

/*******************************************************************************
* digi_line_lane_validate_and_count
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function for the the digi data path layer API.
*   This function validates the lane configuration and returns how much
*   bandwidth would be consumed if this port was activated.
*
* INPUTS:
*    *h                 - pointer to DIGI handle instance
*    module_lane_tx     - an array of the tx lanes used on this ports
*    module_lane_rx     - an array of the rx lanes used on this ports
*    los_pin            - The pin index on which the LOS is carried.
*                         Valid values are are values within the module lanes.
*                         As well as the two special values of 
*                         DIGI_SERDES_PORT_DLOS_LOS_SOURCE  (to use DLOS)                 
*                         or DIGI_SERDES_PORT_NO_LOS_SOURCE (to disable LOS)
*   *s16_clk_cfg_ptr    - The configuration of the additional serdes as a clock
*                         at he nominal rate of the datapath with a specified 
*                         divider. The pin index of this serdes shall be not 
*                         used be any other serdes ports.\n
*                         This input must be set to NULL when a clock is not 
*                         requested
*
* OUTPUTS:
*    *gb_count           - amount of GB that would be consumed if this port
*                          would be provisioned.
*    *cage_pin_count     - number of pins contained in cage associated to possible serdes port.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*   gb_count is only valid if PMC_SUCCESS is returned.
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_line_lane_validate_and_count(digi_handle_t *h,
                                                    UINT32 module_lane_tx[DIGI_SERDES_XFI_LANES_MAX],
                                                    UINT32 module_lane_rx[DIGI_SERDES_XFI_LANES_MAX],
                                                    UINT8 los_pin,
                                                    digi_s16_clk_cfg_t *s16_clk_cfg_ptr,
                                                    UINT8 *gb_count,
                                                    UINT8 *cage_pin_count)
{
    UINT8 i,j = 0;
    UINT8 pin_count = 0;
    UINT16 tx_pin_mask = 0;
    UINT16 rx_pin_mask = 0;
    UINT8 cage_id = DIGI_SERDES_PIN_NOT_USED;
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    digi_xfi_pin_ctxt_t *xfi_ctxt_ptr = NULL;

    PMC_ENTRY();

    if (NULL == cage_pin_count || NULL == gb_count)
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    *cage_pin_count = 0;

    /* s16 clock cfg checks  */
    if ( s16_clk_cfg_ptr != NULL)
    {        

        /* check it is not out of bounds */
        if (DIGI_SERDES_PIN_NOT_USED  == s16_clk_cfg_ptr->pin_index ||
            DIGI_SERDES_XFI_LANES_MAX <= s16_clk_cfg_ptr->pin_index) 
        {
            rc = DIGI_ERR_SERDES_INVALID_S16_CLK_CFG;
        }
        
        /* s16 clock pin shall not be provisionned and it is not part of any cage */
        if (rc == DIGI_ERR_UNKNOWN)
        {
            xfi_ctxt_ptr = &(h->var.pin_bus_ctxt.xfi_line_pin_ctxt[s16_clk_cfg_ptr->pin_index]);
            if (xfi_ctxt_ptr->port_uid != DIGI_SERDES_UNASSIGNED ||
                xfi_ctxt_ptr->cage_id != DIGI_SERDES_PIN_NOT_USED )
            {
                rc = DIGI_ERR_SERDES_INVALID_S16_CLK_CFG;           
            }
        }
    }

    if (rc == DIGI_ERR_UNKNOWN && gb_count != NULL) {

        *gb_count = 0;

        for (i = 0; i < DIGI_SERDES_XFI_LANES_MAX; i++) {

            /* The first check ensures that none of the pins specified
               are out of bounds */
            if ((module_lane_tx[i] >= DIGI_SERDES_XFI_LANES_MAX) &&
                (module_lane_tx[i] != DIGI_SERDES_PIN_NOT_USED)) {

                rc = DIGI_ERR_INVALID_ARG;
                break;

            } 
            
            if ((module_lane_rx[i] >= DIGI_SERDES_XFI_LANES_MAX) &&
                (module_lane_rx[i] != DIGI_SERDES_PIN_NOT_USED)) {

                rc = DIGI_ERR_INVALID_ARG;
                break;

            } 
            
            if ((h->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].los_pin == los_pin) &&
                (los_pin != DIGI_SERDES_PORT_DLOS_LOS_SOURCE) &&
                (los_pin != DIGI_SERDES_PORT_NO_LOS_SOURCE)) {

                rc = DIGI_ERR_SERDES_LOS_PIN_ALREADY_USED;
                break;

            } 
            
            if ((los_pin != DIGI_SERDES_PORT_DLOS_LOS_SOURCE) &&
                (los_pin != DIGI_SERDES_PORT_NO_LOS_SOURCE) &&
                (h->var.pin_bus_ctxt.xfi_line_pin_ctxt[los_pin].los_pin == DIGI_SERDES_PORT_DLOS_LOS_SOURCE)) {
                rc = DIGI_ERR_SERDES_LOS_PIN_ALREADY_USED;
                break;
                
            } 
            
            if (los_pin == DIGI_SERDES_PORT_DLOS_LOS_SOURCE &&
                module_lane_rx[i] != DIGI_SERDES_PIN_NOT_USED) {

                for (j = 0; j < DIGI_SERDES_XFI_LANES_MAX; j++) {
                
                    if(h->var.pin_bus_ctxt.xfi_line_pin_ctxt[j].los_pin == i) {
                        rc = DIGI_ERR_SERDES_LOS_PIN_ALREADY_USED;
                        break;
                    }

                }

                if(rc == DIGI_ERR_SERDES_LOS_PIN_ALREADY_USED)
                    break;
            }

            if (module_lane_tx[i] != DIGI_SERDES_PIN_NOT_USED) {

                /* check that the s16 clock config is not trying to use a data lane */
                if (s16_clk_cfg_ptr != NULL && i == s16_clk_cfg_ptr->pin_index) 
                {
                    rc = DIGI_ERR_SERDES_INVALID_S16_CLK_CFG;
                    break;
                }
                
                /* The user has specified at least one valid pin. */
                pin_count++;

                /* The second check ensures that the user does not attempt to
                   configure the pin twice on one port */
                if ((tx_pin_mask) & (1 << module_lane_tx[i])) {

                    rc = DIGI_ERR_INVALID_ARG;
                    break;
                } else if ((rx_pin_mask) & (1 << module_lane_rx[i])) {

                    rc = DIGI_ERR_INVALID_ARG;
                    break;
                }

                tx_pin_mask = tx_pin_mask | (1 << module_lane_tx[i]);
                rx_pin_mask = rx_pin_mask | (1 << module_lane_rx[i]);

                /* The third check ensures that the pin hasn't already been
                   provisioned on another port */
                xfi_ctxt_ptr = &(h->var.pin_bus_ctxt.xfi_line_pin_ctxt[i]);
                if (xfi_ctxt_ptr->port_uid != DIGI_SERDES_UNASSIGNED) {

                    rc = DIGI_ERR_SERDES_XFI_PIN_ALREADY_PROV;
                    break;

                    /* The fourth check ensures that the pin is already part of
                       a cage. */
                } else if (xfi_ctxt_ptr->cage_id == DIGI_SERDES_PIN_NOT_USED) {

                    rc = DIGI_ERR_SERDES_NO_CAGE_PROV;
                    break;

                } else if (pin_count == 1) {

                    /* Remember the cage associated with this port */
                    cage_id = xfi_ctxt_ptr->cage_id;

                } else if (cage_id != xfi_ctxt_ptr->cage_id) {

                    /* We're mixing cage and pin locations */
                    /* The port straddles more than one cage */
                    rc = DIGI_ERR_PORT_PROV_CAGE_FAIL;
                    break;
                }              
            }
        }

        if (rc != DIGI_ERR_UNKNOWN)  {

            /* We've triped another case above so drop through with that rc */

        } else {

            if (pin_count == 0) {
                /* At least one valid pin must be specified */
                rc = DIGI_ERR_INVALID_ARG;

            } else if (count_trailing_zeros(~tx_pin_mask) != pin_count) {

                /* One of the values between 0 and pin_count is missing!
                   IE: The user specifeid 4 pins, and has specified the order 
                   as being 3, 0, 4, 1 (should be 2, not 4) 
                   pin_mask would be:  0000 0000 0001 1101 
                   ~pin_mask would be: 1111 1111 1110 0010 
                   count_trailing_zeros(~pin_mask) counts the number of zeros starting
                   at the least significant bit position: 1
                   A proper 
                   pin_mask would be:  0000 0000 0000 1111 
                   ~pin_mask would be: 1111 1111 1111 0000 
                   count_trailing_zeros: 4 == pin_count!
                */
                rc = DIGI_ERR_INVALID_ARG;

            } else if (count_trailing_zeros(~rx_pin_mask) != pin_count) {

                /* Same error case as above, but for rx case */
                rc = DIGI_ERR_INVALID_ARG;

            } else if (rx_pin_mask != tx_pin_mask) {

                /* This should enforce rx and tx to use the same pin-set */
                rc = DIGI_ERR_INVALID_ARG;

            } else if ((los_pin >= DIGI_SERDES_XFI_LANES_MAX) &&
                       (los_pin != DIGI_SERDES_PORT_DLOS_LOS_SOURCE) &&
                       (los_pin != DIGI_SERDES_PORT_NO_LOS_SOURCE)) {

                /* LOS pin not in the pin set */
                rc = DIGI_ERR_INVALID_ARG;

            } else if (pin_count == DIGI_SERDES_LINE_LANES_FOR_10G) {
                *gb_count = DIGI_PORT_BANDWIDTH_10G;
                rc = PMC_SUCCESS;

            } else if (pin_count == DIGI_SERDES_LINE_LANES_FOR_40G) {
                *gb_count = DIGI_PORT_BANDWIDTH_40G;
                rc = PMC_SUCCESS;

            } else if (pin_count == DIGI_SERDES_LINE_LANES_FOR_40G_SFIS) {
                *gb_count = DIGI_PORT_BANDWIDTH_40G;
                rc = PMC_SUCCESS;

            } else if (pin_count == DIGI_SERDES_LINE_LANES_FOR_100G) {
                *gb_count = DIGI_PORT_BANDWIDTH_100G;
                rc = PMC_SUCCESS;
            
            } else if (pin_count == DIGI_SERDES_LINE_LANES_FOR_100G_SFIS) {
                *gb_count = DIGI_PORT_BANDWIDTH_100G;
                rc = PMC_SUCCESS;
            } else if (pin_count == DIGI_SERDES_LINE_LANES_FOR_100G_2X_SFIS_5) {
                *gb_count = DIGI_PORT_BANDWIDTH_100G;
                rc = PMC_SUCCESS;
            
            } else {

                rc = DIGI_ERR_SERDES_INVALID_NUM_PINS_PER_PORT_PROV;
            }
        }
    }
    
    /* count number of pin associated to serdes port's cage */
    if (PMC_SUCCESS == rc)
    {
        for (i = 0; i < DIGI_SERDES_XFI_LANES_MAX; i++) 
        {
            /* update cage pin count */
            if (DIGI_SERDES_PIN_NOT_USED != h->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].cage_id &&
                cage_id == h->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].cage_id)
            {
                *cage_pin_count += 1;
            }
        }
    }

    PMC_RETURN(rc);
} /* digi_line_lane_validate_and_count */

/*******************************************************************************
* digi_line_lane_clear_and_bw_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function for the the digi data path layer API.
*
*   This function clears the lane information and determines the amount of 
*   bandwidth that would be consumed by this port
*
* INPUTS:
*    *digi_handle       - pointer to DIGI handle instance
*    *port_def_ptr      - a pointer to the port context.
*
* OUTPUTS:
*    *bw_alloc          - amount of BW that would be returned if this port
*                         would be deprovisioned.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*   bw_alloc is only valid if PMC_SUCCESS is returned.
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_line_lane_clear_and_bw_get(digi_handle_t* digi_handle,
                                                  digi_serdes_port_def_t* port_def_ptr,
                                                  UINT8* bw_alloc)
{

    UINT8 i = 0;
    UINT8 pin_count = 0;
    UINT8 cage_pin_count = 0;
    UINT32 cage_id = 0;
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;

    digi_xfi_pin_ctxt_t *xfi_ctxt_ptr = NULL;
    digi_post_mld_dsi_ctxt_t *post_mld_ptr = NULL;

    PMC_ENTRY();

    *bw_alloc = 0;
    
    for (i = 0; i < DIGI_SERDES_DSI_LANES_MAX; i++) {
        
        if(digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].port_uid == port_def_ptr->port_uid) {
            
            if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].prov_state == DIGI_SERDES_PROV_STATE_UNASSIGNED) {

                pin_count++;
                cage_id = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].cage_uid;
                rc = PMC_SUCCESS;
            } else { 

                rc = DIGI_ERR_SERDES_STILL_IN_USE;

            }
        }
    }
    /* count number of pin in cage because serdes uninit is allowed only on 
       CFP card or 4-pin cage */
    for (i = 0; i < DIGI_SERDES_DSI_LANES_MAX && PMC_SUCCESS == rc; i++) {

        if(digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].cage_uid == cage_id) 
        {
            cage_pin_count += 1;
        }
    }

    if (PMC_SUCCESS == rc)
    {
        if (pin_count == DIGI_SERDES_LINE_LANES_FOR_40G && 
            (digi_handle->var.prod_app == DIGI_PROD_APP_100G_3_X_40G_CFP_CARD ||
             cage_pin_count == DIGI_SERDES_LINE_LANES_FOR_40G) )
        {            
            *bw_alloc = DIGI_PORT_BANDWIDTH_40G;
            
        } else if ((digi_handle->var.prod_app == DIGI_PROD_APP_100G_3_X_40G_CFP_CARD) && 
                   (pin_count == DIGI_SERDES_LINE_LANES_FOR_100G)) {
            
            *bw_alloc = DIGI_PORT_BANDWIDTH_100G;            
        }
        else if (1 == pin_count && 
                 cage_pin_count == DIGI_SERDES_LINE_LANES_FOR_40G)
        {
            *bw_alloc = DIGI_PORT_BANDWIDTH_10G;            
        }
        else if ((digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD) &&
                 (pin_count == DIGI_SERDES_LINE_LANES_FOR_100G))
        {
            *bw_alloc = DIGI_PORT_BANDWIDTH_100G;
        }
        else if ((digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD) &&
                 (pin_count == DIGI_SERDES_LINE_LANES_FOR_40G))
        {
            *bw_alloc = DIGI_PORT_BANDWIDTH_40G;
        }
        else
        {
            rc = DIGI_ERR_SERDES_CANNOT_UNINIT;
        }
    } 

    if (rc == PMC_SUCCESS) 
    {
        /* All checks passed. Deprovision the port and pins */
        for (i = 0; i < DIGI_SERDES_XFI_LANES_MAX; i++) {            
            xfi_ctxt_ptr = &(digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i]);
            
            if (xfi_ctxt_ptr->port_uid == port_def_ptr->port_uid) 
            {
                /*
                 * For each port that matches and if DLOS was used then
                 * ensure that it gets cleared.
                 */
                if(xfi_ctxt_ptr->los_pin == DIGI_SERDES_PORT_DLOS_LOS_SOURCE ||
                   xfi_ctxt_ptr->los_pin == DIGI_SERDES_PORT_NO_LOS_SOURCE)
                {
                    rc = lifd_los_internal_context_unset(digi_handle->lifd_handle,i,TRUE);
                }
                xfi_ctxt_ptr->port_uid = DIGI_SERDES_UNASSIGNED;
                xfi_ctxt_ptr->module_lane_tx_index = 0;
                xfi_ctxt_ptr->module_lane_rx_index = 0;
                xfi_ctxt_ptr->los_pin = DIGI_SERDES_PIN_NOT_USED;
                xfi_ctxt_ptr->los_inv = FALSE;
                xfi_ctxt_ptr->post_mux_dsi_lane = DIGI_SERDES_PIN_NOT_USED;
                /* rate state done further down */

            }
        }
        /* digi_cfg_tbl_t temp_digi_cfg_tbl[] = DIGI_CFG_TABLE; */
        for (i = 0; i < DIGI_SERDES_DSI_LANES_MAX; i++) {
                
            post_mld_ptr = &(digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i]);
                
            if (post_mld_ptr->port_uid == port_def_ptr->port_uid) {
                    
                post_mld_ptr->port_uid = DIGI_SERDES_UNASSIGNED;
                post_mld_ptr->prov_state = DIGI_SERDES_PROV_STATE_NO_SERDES;
                /* dsi lane are assigned once during digi_Device_init execution except for DFP board*/
                /* cage_uid should not be reset to avoid calling digi_dsi_allocation() */
                /*
                 * Check whether the LOS PIN is set.  If so pass in the
                 * actual los pin being set.
                 */
                if ((port_def_ptr->los_pin != DIGI_SERDES_PORT_DLOS_LOS_SOURCE) &&
                    (port_def_ptr->los_pin != DIGI_SERDES_PORT_NO_LOS_SOURCE)) 
                {
                    rc = lifd_los_internal_context_unset(digi_handle->lifd_handle, port_def_ptr->los_pin, TRUE);
                }
            }
        }        

        port_def_ptr->init = FALSE;
        port_def_ptr->port_uid = DIGI_SERDES_UNASSIGNED;
        port_def_ptr->intf = DIGI_SERDES_LINE_INTF;
        port_def_ptr->s16_clk_cfg.pin_index = DIGI_SERDES_PIN_NOT_USED;
        port_def_ptr->master_lane = 0;
        port_def_ptr->los_pin = 0;
    }
           
    /* reinit port status to catch issue after a crash restart */
    if (rc == PMC_SUCCESS) 
    {
        port_def_ptr->init = FALSE;
    }
 
    PMC_RETURN(rc);
} /* digi_line_lane_clear_and_bw_get */

/*******************************************************************************
* digi_sys_lane_clear_and_bw_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function for the the digi data path layer API.
*
*   This function clears the lane information and determines the amount of 
*   bandwidth that would be consumed by this port
*
* INPUTS:
*    *digi_handle       - pointer to DIGI handle instance
*    *port_def_ptr      - a pointer to the port context.
*
* OUTPUTS:
*    *bw_alloc          - amount of BW that would be returned if this port
*                         would be deprovisioned.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*   bw_alloc is only valid if PMC_SUCCESS is returned.
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_sys_lane_clear_and_bw_get(digi_handle_t* digi_handle,
                                                 digi_serdes_port_def_t* port_def_ptr,
                                                 UINT8* bw_alloc)
{

    UINT8 i = 0;
    UINT8 pin_count = 0;
    UINT8 cage_pin_count = 0;
    UINT32 cage_id = 0;
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;

    digi_xfi_pin_ctxt_t *xfi_ctxt_ptr = NULL;
    digi_post_mld_dsi_ctxt_t *post_mld_ptr = NULL;

    PMC_ENTRY();

    *bw_alloc = 0;
    for (i = 0; i < DIGI_SERDES_DSI_LANES_MAX; i++) {

        if(digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].port_uid == port_def_ptr->port_uid) {

            if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].prov_state == DIGI_SERDES_PROV_STATE_UNASSIGNED) {

                pin_count++;
                rc = PMC_SUCCESS;
                cage_id = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].cage_uid;

            } else { 

                rc = DIGI_ERR_SERDES_STILL_IN_USE;

            }
        }
    }

    /* count number of pin in cage because serdes uninit is allowed only on 
       CFP card or 4-pin cage */
    for (i = 0; i < DIGI_SERDES_DSI_LANES_MAX && PMC_SUCCESS == rc; i++) {

        if(digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].cage_uid == cage_id) 
        {
            cage_pin_count += 1;
        }
    }

    if (PMC_SUCCESS == rc)
    {
        if (pin_count == DIGI_SERDES_SYS_LANES_FOR_40G && 
            cage_pin_count == DIGI_SERDES_LINE_LANES_FOR_40G) {
            
            *bw_alloc = DIGI_PORT_BANDWIDTH_40G;
            rc = PMC_SUCCESS;
            
        } 
        else if (pin_count == DIGI_SERDES_SYS_LANES_FOR_10G && 
                 cage_pin_count == DIGI_SERDES_LINE_LANES_FOR_40G) {
            
            *bw_alloc = DIGI_PORT_BANDWIDTH_10G;
            rc = PMC_SUCCESS;
            
        }else {
            rc = DIGI_ERR_SERDES_CANNOT_UNINIT;
        }
    }

    if (rc == PMC_SUCCESS) {

        /* All checks passed. Deprovision the port and pins */
        for (i = 0; i < DIGI_SERDES_XFI_LANES_MAX; i++) {

            xfi_ctxt_ptr = &(digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i]);

            if (xfi_ctxt_ptr->port_uid == port_def_ptr->port_uid) 
            {
                /*
                 * Check whether the los pin is set. If so unset the 
                 * actual los pin.
                 */
                if(xfi_ctxt_ptr->los_pin == DIGI_SERDES_PORT_DLOS_LOS_SOURCE ||
                   xfi_ctxt_ptr->los_pin == DIGI_SERDES_PORT_NO_LOS_SOURCE)

                {
                    rc = sifd_los_internal_context_unset(digi_handle->sifd_handle, i);
                }

                xfi_ctxt_ptr->port_uid = DIGI_SERDES_UNASSIGNED;
                xfi_ctxt_ptr->module_lane_tx_index = 0;
                xfi_ctxt_ptr->module_lane_rx_index = 0;
                xfi_ctxt_ptr->los_pin = DIGI_SERDES_PIN_NOT_USED;
                xfi_ctxt_ptr->los_inv = FALSE;
                xfi_ctxt_ptr->post_mux_dsi_lane = DIGI_SERDES_PIN_NOT_USED;
                /* rate state done further down */

            }
        }

        for (i = 0; i < DIGI_SERDES_XFI_LANES_MAX; i++) {

            post_mld_ptr = &(digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i]);

            if (post_mld_ptr->port_uid == port_def_ptr->port_uid) {

                post_mld_ptr->port_uid = DIGI_SERDES_UNASSIGNED;
                /* dsi lane are assigned once during digi_Device_init execution except for DFP board*/
                /* cage_uid should not be reset to avoid calling digi_dsi_allocation() */
                /* post_mld_ptr->cage_uid = DIGI_SERDES_PIN_NOT_USED; */
                post_mld_ptr->prov_state = DIGI_SERDES_PROV_STATE_NO_SERDES;
                /*
                 * Check whether the los pin was set. If so unset the 
                 * actual los_pin.
                 */
                if(!(port_def_ptr->los_pin == DIGI_SERDES_PORT_DLOS_LOS_SOURCE ||
                     port_def_ptr->los_pin == DIGI_SERDES_PORT_NO_LOS_SOURCE))
                {
                    rc = sifd_los_internal_context_unset(digi_handle->sifd_handle, port_def_ptr->los_pin);
                }
            }
        }

        port_def_ptr->init = FALSE;
        port_def_ptr->port_uid = DIGI_SERDES_UNASSIGNED;
        port_def_ptr->intf = DIGI_SERDES_SYSTEM_INTF;
        port_def_ptr->s16_clk_cfg.pin_index = DIGI_SERDES_PIN_NOT_USED;
        port_def_ptr->master_lane = 0;
        port_def_ptr->los_pin = 0;

    }
            
    PMC_RETURN(rc);
} /* digi_sys_lane_clear_and_bw_get */

/*******************************************************************************
* digi_sys_lane_validate_and_count
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function for the the digi data path layer API.
*   This function validates the lane configuration and returns how much
*   bandwidth would be consumed if this port was activated.
*
* INPUTS:
*    *h                 - pointer to DIGI handle instance
*    module_lane_tx     - an array of the tx lanes used on this ports
*    module_lane_rx     - an array of the rx lanes used on this ports
*    los_pin            - The pin index on which the LOS is carried.
*                         Valid values are are values within the module lanes.
*                         As well as the two special values of 
*                         DIGI_SERDES_PORT_DLOS_LOS_SOURCE  (to use DLOS)                 
*                         or DIGI_SERDES_PORT_NO_LOS_SOURCE (to disable LOS)
*   *s16_clk_cfg_ptr    - The configuration of the additional serdes as a clock
*                         at he nominal rate of the datapath with a specified 
*                         divider. The pin index of this serdes shall be not 
*                         used be any other serdes ports.\n
*                         This input must be set to NULL when a clock is not 
*                         requested
*
* OUTPUTS:
*    *gb_count           - amount of GB that would be consumed if this port
*                          would be provisioned.
*    *cage_pin_count     - number of pins contained in cage associated to possible serdes port.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*   gb_count is only valid if PMC_SUCCESS is returned.
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_sys_lane_validate_and_count(digi_handle_t *h,
                                                   UINT32 module_lane_tx[DIGI_SERDES_XFI_LANES_MAX],
                                                   UINT32 module_lane_rx[DIGI_SERDES_XFI_LANES_MAX],
                                                   UINT8 los_pin,
                                                   digi_s16_clk_cfg_t *s16_clk_cfg_ptr,
                                                   UINT8 *gb_count,
                                                   UINT8 *cage_pin_count)
{
    UINT8 i,j = 0;
    UINT32 n1_ilkn1_pin_msk = 0, n1_ilkn2_pin_msk = 0, s16_clk_cfg_pin_msk = 0;
    UINT8 pin_count = 0;
    UINT16 tx_pin_mask = 0;
    UINT16 rx_pin_mask = 0;
    UINT8 cage_id = DIGI_SERDES_PIN_NOT_USED;
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    digi_xfi_pin_ctxt_t *sys_ctxt_ptr = NULL;

    PMC_ENTRY();
    
    if (NULL == cage_pin_count || NULL == gb_count)
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    *cage_pin_count = 0;

    /* s16 clock cfg checks  */
    if ( s16_clk_cfg_ptr != NULL)
    {        
        /* check it is not out of bounds */
        if (DIGI_SERDES_PIN_NOT_USED  == s16_clk_cfg_ptr->pin_index ||
            DIGI_SERDES_XFI_LANES_MAX <= s16_clk_cfg_ptr->pin_index) 
        {
            rc = DIGI_ERR_SERDES_INVALID_S16_CLK_CFG;
        }
        
        /* s16 clock pin shall not be part of any cage */
        if (rc == DIGI_ERR_UNKNOWN)
        {            
            sys_ctxt_ptr = &(h->var.pin_bus_ctxt.xfi_sys_pin_ctxt[s16_clk_cfg_ptr->pin_index]);
            if (sys_ctxt_ptr->port_uid != DIGI_SERDES_UNASSIGNED ||
                sys_ctxt_ptr->cage_id != DIGI_SERDES_PIN_NOT_USED )
            {
                rc = DIGI_ERR_SERDES_INVALID_S16_CLK_CFG;            
            }
        }

        /* check other S16 clk in other ports */
        for (i =0; i < DIGI_NUM_SYS_PORTS_MAX && rc == DIGI_ERR_UNKNOWN ; i++)
        {
            if (h->var.port_ctxt.sys_port_ctxt[i].init == TRUE && 
                h->var.port_ctxt.sys_port_ctxt[i].s16_clk_cfg.pin_index == s16_clk_cfg_ptr->pin_index)
            {
                rc = DIGI_ERR_SERDES_INVALID_S16_CLK_CFG;   
            }
        }
        /* check ilkn 1 & 2*/
        /* normalize ilkn1_blk_to_N1_enable_mask to N1 pins 15:0 */
        /* ILKN1[15:0] with mask 0xFFFF and offset 0 map to 
           N1[15:0] with offset 0 */
        n1_ilkn1_pin_msk = h->var.sifd_ilkn_1_cfg.lane.blk_to_N1_enable_mask & 0xFFFF;
        
        /* normalize ilkn2_blk_to_N1_enable_mask to N1 pins 15:0 */
        /* ILKN2[7:0] with mask 0xFF and offset 0 map to 
           N1[15:8] with offset 8 */
        n1_ilkn2_pin_msk = (h->var.sifd_ilkn_2_cfg.lane.blk_to_N1_enable_mask & 0xFF) << 8;
        s16_clk_cfg_pin_msk = 1 << s16_clk_cfg_ptr->pin_index;
        if (rc == DIGI_ERR_UNKNOWN && (n1_ilkn1_pin_msk & s16_clk_cfg_pin_msk) != 0)
        {
            rc = DIGI_ERR_SERDES_INVALID_S16_CLK_CFG;   
        }
        if (rc == DIGI_ERR_UNKNOWN && (n1_ilkn2_pin_msk & s16_clk_cfg_pin_msk) != 0)
        {
            rc = DIGI_ERR_SERDES_INVALID_S16_CLK_CFG;   
        }
    }

    if (gb_count != NULL) {

        *gb_count = 0;

        for (i = 0; i < DIGI_SERDES_SYS_LANES_MAX; i++) {

            /* The first check ensures that none of the pins specified
               are out of bounds */
            if ((module_lane_tx[i] >= DIGI_SERDES_XFI_LANES_MAX) &&
                (module_lane_tx[i] != DIGI_SERDES_PIN_NOT_USED)) {

                rc = DIGI_ERR_INVALID_ARG;
                break;

            } 
            
            if ((module_lane_rx[i] >= DIGI_SERDES_XFI_LANES_MAX) &&
                (module_lane_rx[i] != DIGI_SERDES_PIN_NOT_USED)) {

                rc = DIGI_ERR_INVALID_ARG;
                break;

            } 
            
            if ((h->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].los_pin == los_pin) &&
                (los_pin != DIGI_SERDES_PORT_DLOS_LOS_SOURCE) &&
                (los_pin != DIGI_SERDES_PORT_NO_LOS_SOURCE)) {

                rc = DIGI_ERR_SERDES_LOS_PIN_ALREADY_USED;
                break;

            }

            if ((los_pin != DIGI_SERDES_PORT_DLOS_LOS_SOURCE) &&
                (los_pin != DIGI_SERDES_PORT_NO_LOS_SOURCE) &&
                (h->var.pin_bus_ctxt.xfi_sys_pin_ctxt[los_pin].los_pin == DIGI_SERDES_PORT_DLOS_LOS_SOURCE)) 
            {
                rc = DIGI_ERR_SERDES_LOS_PIN_ALREADY_USED;
                break;
                
            } 
            
            if (los_pin == DIGI_SERDES_PORT_DLOS_LOS_SOURCE &&
                module_lane_rx[i] != DIGI_SERDES_PIN_NOT_USED) {

                for (j = 0; j < DIGI_SERDES_XFI_LANES_MAX; j++) {
                
                    if(h->var.pin_bus_ctxt.xfi_sys_pin_ctxt[j].los_pin == i) {
                        rc = DIGI_ERR_SERDES_LOS_PIN_ALREADY_USED;
                        break;
                    }

                }

                if(rc == DIGI_ERR_SERDES_LOS_PIN_ALREADY_USED)
                    break;
            }
            
            if (module_lane_tx[i] != DIGI_SERDES_PIN_NOT_USED) { 

                /* The user has specified at least one valid pin. */
                pin_count++;

                /* The second check ensures that the user does not attempt to
                   configure the pin twice on one port */
                if ((tx_pin_mask) & (1 << module_lane_tx[i])) {

                    rc = DIGI_ERR_INVALID_ARG;
                    break;
                } else if ((rx_pin_mask) & (1 << module_lane_rx[i])) {

                    rc = DIGI_ERR_INVALID_ARG;
                    break;
                }

                tx_pin_mask = tx_pin_mask | (1 << module_lane_tx[i]);
                rx_pin_mask = rx_pin_mask | (1 << module_lane_rx[i]);

                /* The third check ensures that the pin hasn't already been
                   provisioned on another port */
                sys_ctxt_ptr = &(h->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i]);
                if (sys_ctxt_ptr->port_uid != DIGI_SERDES_UNASSIGNED) {

                    rc = DIGI_ERR_SERDES_SYS_PIN_ALREADY_PROV;
                    break;

                    /* The fourth check ensures that the pin is already part of
                       a cage. */
                } else if (sys_ctxt_ptr->cage_id == DIGI_SERDES_PIN_NOT_USED) {

                    rc = DIGI_ERR_SERDES_NO_CAGE_PROV;
                    break;

                } else if (pin_count == 1) {

                    /* Remember the cage associated with this port */
                    cage_id = sys_ctxt_ptr->cage_id;

                } else if (cage_id != sys_ctxt_ptr->cage_id) {

                    /* We're mixing cage and pin locations */
                    /* The port straddles more than one cage */
                    rc = DIGI_ERR_PORT_PROV_CAGE_FAIL;
                    break;
                }
            }
        }

        if (rc != DIGI_ERR_UNKNOWN)  {

            /* We've triped another case above so drop through with that rc */

        } else {

            if (pin_count == 0) {
                /* At least one valid pin must be specified */
                rc = DIGI_ERR_INVALID_ARG;

            } 
            else if (count_trailing_zeros(~tx_pin_mask) != pin_count) {

                /* One of the values between 0 and pin_count is missing!
                   IE: The user specifeid 4 pins, and has specified the order 
                   as being 3, 0, 4, 1 (should be 2, not 4) 
                   pin_mask would be:  0000 0000 0001 1101 
                   ~pin_mask would be: 1111 1111 1110 0010 
                   count_trailing_zeros(~pin_mask) counts the number of zeros starting
                   at the least significant bit position: 1
                   A proper 
                   pin_mask would be:  0000 0000 0000 1111 
                   ~pin_mask would be: 1111 1111 1111 0000 
                   count_trailing_zeros: 4 == pin_count!
                */
                rc = DIGI_ERR_INVALID_ARG;

            } else if (count_trailing_zeros(~rx_pin_mask) != pin_count) {

                /* Same error case as above, but for rx case */
                rc = DIGI_ERR_INVALID_ARG;

            }
            else if (rx_pin_mask != tx_pin_mask) {

                /* This should enforce rx and tx to use the same pin-set */
                rc = DIGI_ERR_INVALID_ARG;

            } else if ((los_pin >= DIGI_SERDES_XFI_LANES_MAX) &&
                       (los_pin != DIGI_SERDES_PORT_DLOS_LOS_SOURCE) &&
                       (los_pin != DIGI_SERDES_PORT_NO_LOS_SOURCE)) {

                /* LOS pin not in the pin set */
                rc = DIGI_ERR_INVALID_ARG;

            } else if (pin_count == DIGI_SERDES_LINE_LANES_FOR_10G) {
                *gb_count = DIGI_PORT_BANDWIDTH_10G;
                rc = PMC_SUCCESS;

            } else if (pin_count == DIGI_SERDES_LINE_LANES_FOR_40G) {
                *gb_count = DIGI_PORT_BANDWIDTH_40G;
                rc = PMC_SUCCESS;

            } else if (pin_count == DIGI_SERDES_LINE_LANES_FOR_40G_SFIS) {
                *gb_count = DIGI_PORT_BANDWIDTH_40G;
                rc = PMC_SUCCESS;

            } else if (pin_count == DIGI_SERDES_LINE_LANES_FOR_100G) {
                *gb_count = DIGI_PORT_BANDWIDTH_100G;
                rc = PMC_SUCCESS;

            } else if (pin_count == DIGI_SERDES_LINE_LANES_FOR_100G_SFIS) { 
                *gb_count = DIGI_PORT_BANDWIDTH_100G;
                rc = PMC_SUCCESS;          
            } else {

                rc = DIGI_ERR_SERDES_INVALID_NUM_PINS_PER_PORT_PROV;
            }
        }
    }

    /* count number of pin associated to serdes port's cage */
    if (PMC_SUCCESS == rc)
    {
        for (i = 0; i < DIGI_SERDES_SYS_LANES_MAX; i++) 
        {
            /* update cage pin count */
            if (DIGI_SERDES_PIN_NOT_USED != h->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].cage_id &&
                cage_id == h->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].cage_id)
            {
                *cage_pin_count += 1;
            }
        }
    }
    
    PMC_RETURN(rc);
} /* digi_sys_lane_validate_and_count */

/*******************************************************************************
* digi_sfi51_bus_validate
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function for the the digi data path layer API.
*   This function validates the lane configuration
*
* INPUTS:
*    *h                 - pointer to DIGI handle instance
*    module_lane_tx     - an array of the tx busses used on this ports
*    module_lane_rx     - an array of the rx busses used on this ports
*
* OUTPUTS:
*    None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*   There is no need to determine the b/w used by this function as in the case
*   of the other interfaces as it is always 40GB as long as it validates
*   correctly.
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_sfi51_bus_validate(digi_handle_t *h,
                                          UINT32 module_lane_tx[DIGI_NUM_SFI51_PORTS_MAX],
                                          UINT32 module_lane_rx[DIGI_NUM_SFI51_PORTS_MAX])
{
    UINT8 i = 0;
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    BOOL found_err = FALSE;
    UINT8 bus_count = 0;
    digi_sfi51_bus_ctxt_t *p_sfi51_ctxt = NULL;

    PMC_ENTRY();

    for (i = 0; i < DIGI_NUM_SFI51_PORTS_MAX; i++) {

        /* The first check ensures that none of the buses specified
           are out of bounds */
        if ((module_lane_tx[i] >= DIGI_NUM_SFI51_PORTS_MAX) &&
            (module_lane_tx[i] != DIGI_POST_MUX_BUS_UNUSED)) {

            found_err = TRUE;
            break;

        } else if ((module_lane_rx[i] >= DIGI_NUM_SFI51_PORTS_MAX) &&
                   (module_lane_rx[i] != DIGI_POST_MUX_BUS_UNUSED)) {

            found_err = TRUE;
            break;

        } else if ((module_lane_tx[i] == DIGI_POST_MUX_BUS_UNUSED) &&
                   (module_lane_rx[i] == DIGI_POST_MUX_BUS_UNUSED)) {

            /* Pin (BUS) not used, go to the next one if there is one */

        } else {

            /* The user has specified at least one valid bus. */
            bus_count++;

            /* The second check ensures that the bus hasn't already been
               provisioned */
            p_sfi51_ctxt = &(h->var.pin_bus_ctxt.sfi51_bus_ctxt[i]);
            if (p_sfi51_ctxt->port_uid != DIGI_SERDES_UNASSIGNED) {

                rc = DIGI_ERR_SERDES_SFI51_BUS_ALREADY_PROV;
                break;
            }

            /* We don't need to check to see if we have provisioned a cage here
             * as SFI51 interfaces do not have the concept of cages. */
        }
    }

    if (rc != DIGI_ERR_UNKNOWN)  {

        /* We've triped another case above so drop through with that rc */

    } else if (bus_count != 1) {

        /* One and only one valid must be specified */
        rc = DIGI_ERR_INVALID_ARG;

    } else {

        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
}

/*******************************************************************************
* digi_is_port_uid_unique
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function for the the digi data path layer API.
*   This function determines if a port_uid is indeed unique.
*
* INPUTS:
*    *h                 - pointer to DIGI handle instance
*    port_uid           - the port_uid to check
*
* OUTPUTS:
*    None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL digi_is_port_uid_unique(digi_handle_t *h,
                                     UINT32 port_uid)
{
    BOOL rc = FALSE;

    PMC_ENTRY();

    /* Has this unique identifier been used before? */
    /* ...on ANY interface type? */
    if (digi_port_ctxt_find(h, port_uid, DIGI_SERDES_LINE_INTF) != NULL) {

    } else if (digi_port_ctxt_find(h, port_uid,
                                   DIGI_SERDES_SYSTEM_INTF) != NULL) {

    } else if (digi_port_ctxt_find(h, port_uid,
                                   DIGI_SERDES_SFI_51_INTF) != NULL) {
    } else {

        rc = TRUE;
    }

    PMC_RETURN(rc);
} /* digi_is_port_uid_unique */

/*******************************************************************************
* digi_get_max_bandwidth
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Based on the product application returns the maximum bandwidth for this side
*  of the device.
*
* INPUTS:
*   prod_app -      The enumerand representing the product application the device
*                   is being used int.
*   is_cfp -        If a CFP Application (is_cfp==TRUE) then limit the application
*                   is limited to 100G.
*
* OUTPUTS:
*
* RETURNS:
*   UINT8 - bandwidth returns a UINT8 representation of the bandwidth for the 
*                   particular product application.
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT8 digi_get_max_bandwidth(digi_prod_app_t prod_app,
                                     BOOL is_cfp)
{
    UINT8 max_bandwidth = DIGI_PORT_BANDWIDTH_MAX;

    PMC_ENTRY();

    switch (prod_app)
    {
    case DIGI_PROD_APP_LINE_CARD:
    case DIGI_PROD_APP_TRANSMUXPONDER_CARD:
    case DIGI_PROD_APP_PORTLESS_CARD:
    case DIGI_PROD_APP_SYSOTN_CARD:
        /*
          Regardless of the product type if the CFP flag is set then restrict the bandwidth to
          100G rather than 120 a side.
        */
        if ( TRUE == is_cfp )
        {
            max_bandwidth = DIGI_CFP_BANDWIDTH_MAX; 
        }
        break;

    case DIGI_PROD_APP_100G_3_X_40G_CFP_CARD:
        max_bandwidth = DIGI_CFP_BANDWIDTH_MAX;
        break;
    case DIGI60_PROD_APP_LINE_CARD:
    case DIGI60_PROD_APP_TRANSMUXPONDER_SYS_CLIENT_CARD:
        max_bandwidth = 60;
        break;
    case DIGI60_PROD_APP_TRANSMUXPONDER_CARD:
        max_bandwidth = 120;
        break;

    default:
        break;
    }

    PMC_RETURN(max_bandwidth);
} /* digi_get_max_bandwidth */

#endif /* DOXYGEN_PUBLIC_ONLY */

/*******************************************************************************
* digi_line_port_info_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns the set of Line Serdes resources that are available
*   to be associated with primary and secondary mapper groups for Line Serdes to
*   ENET_LINE to CPB data path usage.\n\n
*
*   This function can be used to retrieve the assignment of ENET_LINE processing
*   resources made by the SW driver to allow user to manage the usage of MAPOTN
*   and ENET_LINE resources between CPB to ODUKSW and CPB to LINE_SERDES data
*   paths.\n\n
*
*   By using the API the user is aware of what ENET_LINE processing resources
*   have potentially become unavailable for serdes port data processing.  They
*   have also identified the set of set of modules associated with a serdes
*   cage that must be used as a group to not preclude reconfiguration of the
*   group.\n\n
*
*   For example to not preclude an ENET_LINE resource being available for
*   later use, should a CPB to ODUKSW connection not require ENET_LINE
*   processing, it may occupy the same group as the that required by Line
*   Serdes, to maintain the availability of the resource.\n\n
*
*   The SW driver manages Post MUX DSI Lane Usage.  This is determined based on
*   the identification of the set of cages and Serdes modules provided by the
*   user with digi_serdes_cage_cfg() and digi_serdes_port_init() calls.\n\n
*
*   Based on the modules present, the driver allocates a set of ENET_LINE
*   processing resources that are available for usage by these pins.
*
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*
*
* OUTPUTS:
*   *port_grp_usage    - Pointer to a digi_port_usage_grp_struct_t.
*                      This structure contains 12 elements of 
*                      type digi_port_usage_struct_t. This contains the 
*                      pointer to the port context and the port states as
*                      well as the number of odu0s provisioned against
*                      this port context. These structures are filled in 
*                      by this function. 
*                      Array index is primary_group number*4 +
*                      secondary_group number. \n
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_line_port_info_get(digi_handle_t *digi_handle,
                                         digi_port_usage_grp_struct_t* port_grp_usage)

{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;

    PMC_ATOMIC_ENTRY(digi_handle);

    rc = digi_line_port_info_internal_get(digi_handle,port_grp_usage);

    PMC_ATOMIC_RETURN(digi_handle,rc);

} /* digi_line_port_info_get */

#ifndef DOXYGEN_PUBLIC_ONLY

/*******************************************************************************
* digi_line_port_info_internal_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   see digi_line_port_info__get description 
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*
*
* OUTPUTS:
*   *port_grp_usage    - Pointer to a digi_port_usage_grp_struct_t.
*                      This structure contains 12 elements of 
*                      type digi_port_usage_struct_t. This contains the 
*                      pointer to the port context and the port states as
*                      well as the number of odu0s provisioned against
*                      this port context. These structures are filled in 
*                      by this function. 
*                      Array index is primary_group number*4 +
*                      secondary_group number. \n
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_line_port_info_internal_get(digi_handle_t *digi_handle,
                                                   digi_port_usage_grp_struct_t* port_grp_usage)

{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;

    UINT8 i = 0; /* counter */
    UINT8 cage_uid = DIGI_SERDES_PIN_NOT_USED;
    UINT32 port_uid = DIGI_SERDES_UNASSIGNED;
    digi_serdes_port_t* port_ptr = NULL;
    digi_serdes_prov_state_t prov_state = DIGI_SERDES_PROV_STATE_NO_SERDES;
    digi_mapper_alloc_t map_type = DIGI_MAPPER_ALLOC_UNUSED;
    UINT8 num_odus = 0;

    PMC_ENTRY();
 
    /*
      This function will look at the used resources associated with the
      group.  If MAPOTN processing is present but not using ENET_LINE as
      part of the data path, the resource is still available for Line Serdes
      to ENET_LINE to CPB usage.

      The intention is that user calls this API prior to the provisioning
      of ENET_LINE resources or Mapper path resources.  These API will of
      course identify warning if the configuration is moving into violation
    */

    if (digi_handle == NULL)  {

        rc = DIGI_ERR_NULL_HANDLE;

    } else {

        for (i = 0; i < DIGI_MAPPER_NUM_SECONDARY_GROUPS; i++) {

            cage_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].cage_uid;
            port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].port_uid;

            port_ptr = NULL;
            prov_state = DIGI_SERDES_PROV_STATE_NO_SERDES;
            map_type = DIGI_MAPPER_ALLOC_UNUSED;
            num_odus = 0;

            if ((cage_uid != DIGI_SERDES_PIN_NOT_USED) &&
                (port_uid != DIGI_SERDES_UNASSIGNED)) {
                port_ptr = digi_port_ctxt_no_type_find(digi_handle, port_uid);
            }

            prov_state = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].prov_state;
            map_type = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].map_type;
            num_odus = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].num_odu0;



            port_grp_usage->port_usage[i].port_ctxt_ptr = port_ptr;
            port_grp_usage->port_usage[i].prov_state = prov_state;
            port_grp_usage->port_usage[i].grp_alloc = map_type;
            port_grp_usage->port_usage[i].num_odu0 = num_odus;

        }
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);

} /* digi_line_port_info_internal_get */

#endif /* DOXYGEN_PUBLIC_ONLY */

/*******************************************************************************
* digi_system_port_info_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns the set of System Serdes resources that are available
*   to be associated with primary and secondary mapper groups for System 
*   SERDES.\n\n
*
*   This function can be used to retrieve the assignment of ENET_SYS processing
*   resources made by the SW driver to allow user to manage the usage of 
*   and System SERDES resources between SIFD and other modules
*   paths.\n\n
*
*   The SW driver manages Post MUX DSI Lane Usage.  This is determined based on
*   the identification of the set of cages and Serdes modules provided by the
*   user with digi_serdes_cage_cfg() and digi_serdes_port_init() calls.\n\n
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*
*
* OUTPUTS:
*   *port_grp_usage    - Pointer to a digi_port_usage_grp_struct_t.
*                      This structure contains 12 elements of 
*                      type digi_port_usage_struct_t. This contains the 
*                      pointer to the port context and the port states as
*                      well as the number of odu0s provisioned against
*                      this port context. These structures are filled in 
*                      by this function. 
*                      Array index is primary_group number*4 +
*                      secondary_group number. \n
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_system_port_info_get(digi_handle_t *digi_handle,
                                           digi_port_usage_grp_struct_t* port_grp_usage)

{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;

    UINT8 i = 0; /* counter */
    UINT8 cage_uid = DIGI_SERDES_PIN_NOT_USED;
    UINT32 port_uid = DIGI_SERDES_UNASSIGNED;
    digi_serdes_port_t* port_ptr = NULL;
    digi_serdes_prov_state_t prov_state = DIGI_SERDES_PROV_STATE_NO_SERDES;
    digi_mapper_alloc_t map_type = DIGI_MAPPER_ALLOC_UNUSED;
    UINT8 num_odus = 0;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    for (i = 0; i < DIGI_MAPPER_NUM_SECONDARY_GROUPS; i++) {
        
        cage_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].cage_uid;
        port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].port_uid;
        
        port_ptr = NULL;
        prov_state = DIGI_SERDES_PROV_STATE_NO_SERDES;
        map_type = DIGI_MAPPER_ALLOC_UNUSED;
        num_odus = 0;
        
        if ((cage_uid != DIGI_SERDES_PIN_NOT_USED) &&
            (port_uid != DIGI_SERDES_UNASSIGNED)) {
            
            port_ptr = digi_port_ctxt_no_type_find(digi_handle, port_uid);
            
            if (port_ptr == NULL) {
                
                /* Assert here because if the port is provisioned, but
                   cannot be found, we have gotten into an inconsistent
                   state */
                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                
            } else {
                
                prov_state = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].prov_state;
                /* Note: The mapper state is not picked up as it should
                   always be DIGI_MAPPER_ALLOC_UNUSED */
                num_odus = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].num_odu0;
            }
            
        }
        
        port_grp_usage->port_usage[i].port_ctxt_ptr = port_ptr;
        port_grp_usage->port_usage[i].prov_state = prov_state;
        port_grp_usage->port_usage[i].grp_alloc = map_type;
        port_grp_usage->port_usage[i].num_odu0 = num_odus;
        
    }
    rc = PMC_SUCCESS;    

    PMC_ATOMIC_RETURN(digi_handle,rc);

} /* digi_system_port_info_get */

/*******************************************************************************
* digi_otn_mapper_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies basic bidirectional mode configuration for a signal
*   passing between ODUKSW and CPB.  This path provides for all OPU payload
*   mapping defined by the DIGI device.\n\n
*
*   The function specifies the internal device resources to process this signal
*   using the primary_group and secondary_group arguments.  Upto 8 ODU0 rate
*   channels may be provisioned against a secondary group.  Four secondary
*   groups are associated with each primary group.\n\n
*
*   In systems where ENET_LINE is not used or where MAPOTN and ENET_LINE are never
*   used in conjuction, primary and secondary group do not need to be considered
*   and can be specified with their respective DONT_CARE enum values.
*
*   Primary group and secondary group is important in systems where ENET_LINE and
*   MAPOTN subsystem are used in conjuction for processing a signal between ODUKSW
*   and CPB blocks.  It provides the ability for higher level systems to classify
*   the bandwidth assigned to MAPOTN in order to support reconfiguration scenarios
*   of ENET_LINE.
*
*   Mapping modes are defined in the digi_mapping_mode_t enum type.  Depending
*   on the mapping mode data may enter the CPB via the MAPOTN or ENET
*   subsystems.\n\n
*
*   ENET_LINE resources are required for the following applications:\n
*   DIGI_MAP_ODU4P_100_GE_GFP\n
*   DIGI_MAP_ODU4P_100_GE_GMP\n
*   DIGI_MAP_ODU3P_40_GE_GFP\n
*   DIGI_MAP_ODU3P_40_GE_GMP\n
*   DIGI_MAP_ODU2P_10_GE_7_3_GFP\n
*   DIGI_MAP_ODU2P_10_GE_6_2_GFP\n
*   DIGI_MAP_ODU3E2P_40_G_CBR_GMP\n
*   DIGI_MAP_ODU1EP_PKT_10G3_7_2_BMP\n
*   DIGI_MAP_ODU2EP_PKT_10G3_7_1_BMP\n
*   DIGI_MAP_ODU1EP_CBR_10G3_7_2_BMP (with enet_pmon == TRUE)\n
*   DIGI_MAP_ODU2EP_CBR_10G3_7_1_BMP (with enet_pmon == TRUE)\n\n
*
*   digi_mapper_group_usage_get() is provided to assist higher level systems to
*   determine which Serdes Port would be locked out from ENET_LINE serdes
*   processing if it were assigned to a mapper channel that required the ENET_LINE
*   resources for that channel.\n\n
*
*   The function may also be used to identify which mapotn channels need to be
*   deprovisioned should a set of 10G secondary groups need to be freed to
*   convert them to usage for ENET_LINE processing of a 40G resource.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   primary_group          - Enum, Primary group to configure mapper channel
*                            against.
*   secondary_group        - Enum, Secondary group to configure mapper channel
*                            against.
*   mode                   - Enum, OPU payload mapping modes.
*   enet_pmon              - 10GE/40GE/100GE passive monitoring of CBR Ethernet
*                            signals.\n
*                            TRUE: ENET_LINE used for PMON of signal transferred
*                                  transferredbetween MAPOTN and CPB\n
*                            FALSE: ENET_LINE not used\n
*                            Applicable to:\n
*                               DIGI_MAP_ODU1EP_CBR_10G3_7_2_BMP\n
*                               DIGI_MAP_ODU2EP_CBR_10G3_7_1_BMP\n
*   odu_data               - Enum, Additional mode context for arbitary ODU
*                            container size.  Applicable to:\n
*                                DIGI_MAP_ODUKP_PACKET_GFP\n
*   odu_flex_data          - Number of ODU0 tributary slots making up the
*                            ODUFlex container.  Applicable to:\n
*                                DIGI_MAP_ODUKP_PACKET_GFP with odu_data
*                                DIGI_ODUK_ODUFLEX
*
* OUTPUTS:
*   **chnl_ctxt_pptr       - Pointer to a pointer to a mapper channel context
*                            for identifying device resources associated with
*                            a mapper path channel.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_mapper_prov(digi_handle_t *digi_handle,
                                      digi_mapper_primary_group_t primary_group,
                                      digi_mapper_secondary_group_t secondary_group,
                                      digi_mapping_mode_t mode,
                                      BOOL enet_pmon,
                                      digi_oduk_t odu_data,
                                      UINT32 odu_flex_data,
                                      digi_mapper_chnl_t **chnl_ctxt_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);

    if(result == PMC_SUCCESS){

        result = digi_util_otn_mapper_prov(digi_handle, primary_group, secondary_group,
                                           mode, enet_pmon, odu_data, odu_flex_data,
                                           DIGI_MAPOTN_CHNL_MAX, chnl_ctxt_pptr);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
    
} /* digi_otn_mapper_prov */


#ifndef DOXYGEN_PUBLIC_ONLY

/*******************************************************************************
* digi_util_otn_mapper_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies basic bidirectional mode configuration for a signal
*   passing between ODUKSW and CPB.  This path provides for all OPU payload
*   mapping defined by the DIGI device.\n\n
*
*   The function specifies the internal device resources to process this signal
*   using the primary_group and secondary_group arguments.  Upto 8 ODU0 rate
*   channels may be provisioned against a secondary group.  Four secondary
*   groups are associated with each primary group.\n\n
*
*   In systems where ENET_LINE is not used or where MAPOTN and ENET_LINE are never
*   used in conjuction, primary and secondary group do not need to be considered
*   and can be specified with their respective DONT_CARE enum values.
*
*   Primary group and secondary group is important in systems where ENET_LINE and
*   MAPOTN subsystem are used in conjuction for processing a signal between ODUKSW
*   and CPB blocks.  It provides the ability for higher level systems to classify
*   the bandwidth assigned to MAPOTN in order to support reconfiguration scenarios
*   of ENET_LINE.
*
*   Mapping modes are defined in the digi_mapping_mode_t enum type.  Depending
*   on the mapping mode data may enter the CPB via the MAPOTN or ENET
*   subsystems.\n\n
*
*   ENET_LINE resources are required for the following applications:\n
*   DIGI_MAP_ODU4P_100_GE_GFP\n
*   DIGI_MAP_ODU4P_100_GE_GMP\n
*   DIGI_MAP_ODU3P_40_GE_GFP\n
*   DIGI_MAP_ODU3P_40_GE_GMP\n
*   DIGI_MAP_ODU2P_10_GE_7_3_GFP\n
*   DIGI_MAP_ODU2P_10_GE_6_2_GFP\n
*   DIGI_MAP_ODU3E2P_40_G_CBR_GMP\n
*   DIGI_MAP_ODU1EP_PKT_10G3_7_2_BMP\n
*   DIGI_MAP_ODU2EP_PKT_10G3_7_1_BMP\n
*   DIGI_MAP_ODU1EP_CBR_10G3_7_2_BMP (with enet_pmon == TRUE)\n
*   DIGI_MAP_ODU2EP_CBR_10G3_7_1_BMP (with enet_pmon == TRUE)\n\n
*
*   digi_mapper_group_usage_get() is provided to assist higher level systems to
*   determine which Serdes Port would be locked out from ENET_LINE serdes
*   processing if it were assigned to a mapper channel that required the ENET_LINE
*   resources for that channel.\n\n
*
*   The function may also be used to identify which mapotn channels need to be
*   deprovisioned should a set of 10G secondary groups need to be freed to
*   convert them to usage for ENET_LINE processing of a 40G resource.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   primary_group          - Enum, Primary group to configure mapper channel
*                            against.
*   secondary_group        - Enum, Secondary group to configure mapper channel
*                            against.
*   mode                   - Enum, OPU payload mapping modes.
*   enet_pmon              - 10GE/40GE/100GE passive monitoring of CBR Ethernet
*                            signals.\n
*                            TRUE: ENET_LINE used for PMON of signal transferred
*                                  transferredbetween MAPOTN and CPB\n
*                            FALSE: ENET_LINE not used\n
*                            Applicable to:\n
*                               DIGI_MAP_ODU1EP_CBR_10G3_7_2_BMP\n
*                               DIGI_MAP_ODU2EP_CBR_10G3_7_1_BMP\n
*   odu_data               - Enum, Additional mode context for arbitary ODU
*                            container size.  Applicable to:\n
*                                DIGI_MAP_ODUKP_PACKET_GFP\n
*   odu_flex_data          - Number of ODU0 tributary slots making up the
*                            ODUFlex container.  Applicable to:\n
*                                DIGI_MAP_ODUKP_PACKET_GFP with odu_data
*                                DIGI_ODUK_ODUFLEX
*   pv_dci_chnl_force      - Force DCI channel ID used for MAPOTN 
*
* OUTPUTS:
*   **chnl_ctxt_pptr       - Pointer to a pointer to a mapper channel context
*                            for identifying device resources associated with
*                            a mapper path channel.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_util_otn_mapper_prov(digi_handle_t *digi_handle,
                                           digi_mapper_primary_group_t primary_group,
                                           digi_mapper_secondary_group_t secondary_group,
                                           digi_mapping_mode_t mode,
                                           BOOL enet_pmon,
                                           digi_oduk_t odu_data,
                                           UINT32 odu_flex_data,
                                           UINT32 pv_dci_chnl_force,
                                           digi_mapper_chnl_t **chnl_ctxt_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    util_global_odukp_type_t oduk_data = UTIL_GLOBAL_LAST_ODUK;
    util_global_map_adapt_func_t map_mode = UTIL_GLOBAL_MAP_NO_RATE;
    util_global_map_adapt_func_t demap_mode = UTIL_GLOBAL_MAP_NO_RATE;
    mapotn_src_dest_t mapotn_dest = MAPOTN_DEST_CPB;
    mapotn_src_dest_t mapotn_src = MAPOTN_DEST_CPB;
    digi_enet_pmon_type_t enet_pmon_type = DIGI_NO_PMON;
    UINT32 mapotn_chnl = 0;
    UINT32 chnl = 0;
    UINT32 num_cal_entry_req = 0;
    UINT32 oduflex_cbr_rate = 0;
    BOOL8 enet_line_as_pmon = FALSE;
    BOOL8 is_dest_enet = FALSE;
    util_global_cpb_port_t cpb_port_type = LAST_UTIL_GLOBAL_CPB_PORT;
    digi_group_size_t group_size = LAST_DIGI_GRP_SIZE;

    digi_enet_res_type_t enet_res_type = DIGI_ENET_RES_UNUSED; 
    util_global_cpb_port_t port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;

    UINT32 post_mld_index = DIGI_SERDES_XFI_LANES_MAX;
    util_global_mapping_mode_t mapotn_mapping_mode = UTIL_GLOBAL_NO_MAP;
    enet_datapath_t e_mode = LAST_ENET_DATAPATH;

    coreotn_odu_chnl_prov_mode_t prov_mode = LAST_COREOTN_CHNL_PROV_MODE;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(primary_group < LAST_DIGI_MAPPER_PRIMARY_GROUP, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(secondary_group < LAST_DIGI_MAPPER_SECONDARY_GROUP, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(mode < LAST_DIGI_MAP, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(odu_data < LAST_DIGI_ODUK, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(chnl_ctxt_pptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        PMC_RETURN(DIGI_ERR_DEVICE_NOT_INIT);
    }


    digi_mapper_all_params_convert_and_get(digi_handle, 
                                           odu_data, 
                                           mode, 
                                           enet_pmon,
                                           &odu_flex_data, 
                                           &oduk_data, 
                                           &group_size, 
                                           &map_mode, 
                                           &demap_mode, 
                                           &mapotn_src, 
                                           &mapotn_dest,
                                           &oduflex_cbr_rate);

    /* PMON helper to set all variables */
    result = digi_enet_pmon_is_available_and_case_determine(digi_handle, 
                                                            mode,
                                                            enet_pmon,
                                                            mapotn_dest,
                                                            &enet_line_as_pmon,
                                                            &enet_pmon_type,
                                                            &cpb_port_type); 

    if(PMC_SUCCESS == result) {

        if (pv_dci_chnl_force >= DIGI_MAPOTN_CHNL_MAX) {

            /* get the first available channel to provision */
            result = mapotn_unused_chnl_get(digi_handle->mapotn_handle, &mapotn_chnl);    

        } else {

            /* check pool for availability of this channel and if available assign else return an error*/
            result = mapotn_chnl_avail_chk(digi_handle->mapotn_handle, pv_dci_chnl_force);

            if(PMC_SUCCESS == result) {

                mapotn_chnl = pv_dci_chnl_force;

            } else {

                result =  DIGI_ERR_MAPPER_CHNL_NOT_AVAIL;
            }
        }
    }
    
    if (mapotn_chnl >= DIGI_MAPOTN_CHNL_MAX)
    {
        result = DIGI_ERR_MAPPER_CHNL_NOT_AVAIL;
    }

    is_dest_enet = (mapotn_dest == MAPOTN_DEST_ENET || mapotn_dest == MAPOTN_DEST_CPB_ENET);
    
    /* Obtain the post_mld_index so we can check the state of the MLD
       provisioning */
    if(PMC_SUCCESS == result) {

        /*
         * If primary group = Don't Care and the datapath is 40G enet line then 
         *  determine which primary group is available.
         */
        if (primary_group == DIGI_MAPPER_PRIMARY_GROUP_DONT_CARE && is_dest_enet && group_size == DIGI_GRP_SIZE_40G) 
        {
            int pri_grp;
            for (pri_grp = DIGI_MAPPER_PRIMARY_GROUP_0; pri_grp < DIGI_MAPPER_PRIMARY_GROUP_DONT_CARE; pri_grp++)
            {
                primary_group = (digi_mapper_primary_group_t)pri_grp;
                digi_mapper_post_mld_index_get(primary_group, secondary_group,
                                               group_size, &post_mld_index);
                
                if (digi_enet_is_link_in_use(digi_handle, post_mld_index, group_size,
                                             UTIL_GLOBAL_CPB_PORT_ENET_LINE) == PMC_SUCCESS) 
                    break;
            }
            if (primary_group == DIGI_MAPPER_PRIMARY_GROUP_DONT_CARE)
            {

                result = DIGI_ERR_ENET_LINE_RESOURCE_NOT_AVAILABLE;
            }
        }
        else 
        {
            digi_mapper_post_mld_index_get(primary_group, secondary_group,
                                           group_size, &post_mld_index);

        }
                    

        /* If we are DIGI_ENET_LINE_PMON, we'll need to know if the resource is
           available right now at provisioning time.
           If we are DIGI_ENET_SYS_PMON, we won't know if the resource is available
           until time of mapping. In any other case, we don't need PMON, so continue.
        */
        if (result == PMC_SUCCESS && enet_pmon_type == DIGI_ENET_LINE_PMON) {
            result = digi_enet_is_link_in_use(digi_handle, 
                                              post_mld_index,
                                              group_size,
                                              UTIL_GLOBAL_CPB_PORT_ENET_LINE);
            if (result != PMC_SUCCESS) {

                result = DIGI_ERR_ENET_LINE_RESOURCE_NOT_AVAILABLE;

            } 
        }
    }

    PMC_LOG_TRACE("start testing\n");
    if(PMC_SUCCESS == result)
    {
        result = mapotn_num_cal_entry_req_get(digi_handle->mapotn_handle, oduk_data, oduflex_cbr_rate, odu_flex_data, &num_cal_entry_req);
    }

    if(PMC_SUCCESS == result) {

        result = digi_determine_resource_available(digi_handle, primary_group, secondary_group, post_mld_index, num_cal_entry_req);
    }

    if(PMC_SUCCESS == result)
    {
        result = digi_mapper_db_prov_cfg(digi_handle, 
                                         primary_group, secondary_group, 
                                         group_size, cpb_port_type, 
                                         enet_line_as_pmon, mapotn_chnl, 
                                         post_mld_index, num_cal_entry_req);
    }

    PMC_LOG_TRACE("end testing\n");

    /* Perform ENET1 DCSU Rate Configuration */
    if(FALSE == pmc_is_digi_rev_a_revision(&digi_handle->base))
    {
        if(result == PMC_SUCCESS && mode == DIGI_MAP_ODU4P_PKT_100_GE_GMP)
        {
            /* set DCSU for 517 MHz */
            digi_dcsu_adjust_enet1(digi_handle, TRUE);
        }
        else
        {
            /* set DCSU for 573.48 MHz default rate */
            digi_dcsu_adjust_enet1(digi_handle, FALSE);
        }
    }

    if(PMC_SUCCESS == result)
    {
        /* Initialize ENET1/2 DCSU if ENET is in stat state */
        if ((enet_pmon_type == DIGI_ENET_LINE_PMON) || (mapotn_dest == MAPOTN_DEST_ENET)) {

            digi_dcsu_conditional_init(digi_handle, DIGI_DCSU_INST_ENET1);
            digi_dcsu_conditional_init(digi_handle, DIGI_DCSU_INST_ENET2);
            digi_dcsu_conditional_init(digi_handle, DIGI_DCSU_INST_ENET3);
        }

        digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_RUNNING,COREOTN_STG4);
        digi_mapotn_energy_state_set(digi_handle, mode, PMC_ENERGY_STATE_REQUEST_RUNNING);
   

        result = mapotn_mapper_prov(digi_handle->mapotn_handle, mapotn_chnl, map_mode, oduk_data, oduflex_cbr_rate, odu_flex_data, 0, mapotn_src);

        PMC_LOG_TRACE("map mode is %d\n", map_mode);
        PMC_LOG_TRACE("map is %d\n", mode);
    }

    if(PMC_SUCCESS == result)
    {
        result  = digi_enet_mapotn_mpmo_prov(digi_handle, mapotn_chnl, mode);
    }

    if(PMC_SUCCESS == result)
    {
        result = mapotn_demapper_prov(digi_handle->mapotn_handle, mapotn_chnl, demap_mode, oduk_data, oduflex_cbr_rate, odu_flex_data, 0, mapotn_dest);
    }

    if(PMC_SUCCESS == result)
    {

        result = digi_conditionaly_provision_enet_line_and_chnl_set(digi_handle, mapotn_dest, enet_pmon_type, post_mld_index, mode, mapotn_chnl, &chnl);
    }

    /* Turn on the blocks in FO2 */
    /* call FO2 (coreotn 4th stage) provisioning */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_stg4_rx_chnl_prov(digi_handle->coreotn_handle,
                                           mapotn_chnl,
                                           1);
    }
    if (PMC_SUCCESS == result)
    {
        result = coreotn_stg4_tx_chnl_prov(digi_handle->coreotn_handle,
                                           mapotn_chnl,
                                           1);
    }                  
                                              
    if(PMC_SUCCESS == result)
    {
        digi_mapper_chnl_def_t *chnl_ctxt_ptr;
        digi_enet_client_chnl_t* enet_chnl_ctxt_ptr;

        if(digi_handle->var.etrans_dcpb_use_model == FALSE || enet_line_as_pmon == TRUE)
        {
            digi_num_odus_and_map_type_prov_set(digi_handle, post_mld_index, num_cal_entry_req, enet_line_as_pmon, mapotn_dest);
        }

        chnl_ctxt_ptr = digi_mapper_client_chnl_get(digi_handle, mapotn_chnl, chnl, cpb_port_type);
        chnl_ctxt_ptr->mode = mode;
        chnl_ctxt_ptr->enet_pmon = enet_pmon_type;
        chnl_ctxt_ptr->mapotn_chnl = mapotn_chnl;
        chnl_ctxt_ptr->odu_data = odu_data;
        chnl_ctxt_ptr->odu_flex_data = odu_flex_data;
        chnl_ctxt_ptr->primary_group = primary_group;
        chnl_ctxt_ptr->secondary_group = secondary_group;
        *chnl_ctxt_pptr = (digi_mapper_chnl_def_t*)chnl_ctxt_ptr;
        chnl_ctxt_ptr->post_mld_index = post_mld_index;
        
        if (enet_pmon_type == DIGI_ENET_LINE_PMON) {
        
            enet_res_type = DIGI_ENET_RES_PMON; 
            port_type = UTIL_GLOBAL_CPB_PORT_ENET_LINE;

        } else if (mapotn_dest == MAPOTN_DEST_ENET) {

            enet_res_type = DIGI_ENET_RES_UNUSED; 
            port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
        }

        if ((enet_pmon_type == DIGI_ENET_LINE_PMON) || (mapotn_dest == MAPOTN_DEST_ENET)) {

            digi_enet_mode_t digi_e_mode = LAST_DIGI_ENET;
            digi_mapotn_digi_enet_params_convert(mode, &digi_e_mode);

            PMC_ASSERT(post_mld_index < DIGI_ENET_CHNL_MAX, DIGI_ERR_CODE_ASSERT, 0, 0);
            enet_chnl_ctxt_ptr = digi_enet_client_chnl_get(digi_handle,  /* this function is used as an accessor based on the chnl and UTIL PORT TYPE. The other values are just stubbed in */
                                                           DIGI_SERDES_PORT_MODE_ANY_LOWPWR, 
                                                           digi_e_mode, 
                                                           post_mld_index, 
                                                           port_type,
                                                           enet_res_type);

            PMC_ASSERT(enet_chnl_ctxt_ptr != NULL, DIGI_ERR_CODE_ASSERT, 0, 0);

            chnl_ctxt_ptr->enet_pmon_data = (digi_enet_client_chnl_def_t*)enet_chnl_ctxt_ptr;

            /* Client source cfg for FW */
            result = digi_enet_fw_enet_client_source_conditional_update(digi_handle, (util_global_switch_data_t  *)enet_chnl_ctxt_ptr);
            
            /*
             * Register the MAPOTN enet_pmon value here when it is used
             * rather than registering all the enet_pmon_data handles 
             * associated with MAPOTN.
             */
            if (result == PMC_SUCCESS)
            {
                if (enet_pmon_type == DIGI_ENET_LINE_PMON)
                {
                    if (mode == DIGI_MAP_ODU2P_10_GE_6_2_GFP_ENET ||
                        mode == DIGI_MAP_ODU3P_40_GE_GFP_ENET ||
                        mode == DIGI_MAP_ODU4P_100_GE_GFP_ENET) 
                    {
                        if (result == PMC_SUCCESS) 
                        {
                            /* 
                             *  For MAPOTN -> ETRANS -> EMAC(line) (Rx PMON) path, 
                             *      disable fcs stripping & fcs insertion in mapotn.
                             */ 
                            result = mapotn_rgfpf_egress_pfcs_efcs_strip_cfg(digi_handle->mapotn_handle, mapotn_chnl, 0, 0);
                        }
                        
                        if (result == PMC_SUCCESS) 
                        {
                            /* Disable FCS insert in mapotn */
                            result = mapotn_tgfpf_chnl_payload_fcs_cfg(digi_handle->mapotn_handle,
                                                                       mapotn_chnl, MAPOTN_NO_FCS,     
                                                                       0,0,0,0,1,1);   
                        }
                    }
                } 
            }
        }
        
    
        if(result == PMC_SUCCESS)
        {
            result = mapotn_mapping_mode_get(digi_handle->mapotn_handle, 
                                             map_mode,
                                             &mapotn_mapping_mode);
            if(mapotn_dest == MAPOTN_DEST_ENET || mapotn_dest == MAPOTN_DEST_CPB_ENET)
                digi_mapotn_enet_params_convert(mode, &e_mode);
        }

        if(result == PMC_SUCCESS && mapotn_src == MAPOTN_DEST_ENET)
        {
            result = enet_tx_activate(digi_handle->enet_line_handle, chnl, e_mode);
        }


        if(result == PMC_SUCCESS && mapotn_dest == MAPOTN_DEST_CPB_ENET)
        {
            result = digi_enet_enhanced_pmon_line_local_activate(digi_handle,
                                                                 (util_global_switch_data_def_t*)chnl_ctxt_ptr);
        }
        
            if(result == PMC_SUCCESS && mapotn_dest == MAPOTN_DEST_ENET)
            {
                result = enet_rx_activate(digi_handle->enet_line_handle, chnl, e_mode);
            }

        if(result == PMC_SUCCESS && !(mapotn_mapping_mode == UTIL_GLOBAL_GFP && mapotn_src == MAPOTN_DEST_CPB))
        {
            result = mapotn_mapper_activate( digi_handle->mapotn_handle, mapotn_chnl);
        }

        if(result == PMC_SUCCESS && !(mapotn_mapping_mode == UTIL_GLOBAL_GFP))
        {
            result = mapotn_demapper_activate( digi_handle->mapotn_handle, mapotn_chnl);
        }

        if(result == PMC_SUCCESS && mapotn_src == MAPOTN_DEST_ENET && mapotn_mapping_mode != UTIL_GLOBAL_GFP)
        {
            digi_opsa_cfg_one_tgmp_txjc_cfc_fifo_clrb(digi_handle,
                                                      mapotn_chnl,
                                                      TRUE);    
        }

        if(result == PMC_SUCCESS && mapotn_mapping_mode != UTIL_GLOBAL_GFP && mapotn_src == MAPOTN_DEST_ENET)
        {
            /* activate MAPOTN MPMO for the case where it is internally used on the ETRANS path */
            result = mapotn_mpmo_ch_activate(digi_handle->mapotn_handle, mapotn_chnl);
        }

        if(result == PMC_SUCCESS && mapotn_src == MAPOTN_DEST_ENET)
        {
            result = coreotn_odu_chnl_prov_mode_get(digi_handle->coreotn_handle,
                                                    &prov_mode);

            if (PMC_SUCCESS == result)
            {
                if (prov_mode == COREOTN_ODU_CHNL_PROV_ALL)
                {
                    result = mapotn_mapper_tgmp_cfc_xoff_cfg_super_prov(digi_handle->mapotn_handle,
                                                                        mapotn_chnl);
                }
                else {  
                    result = mapotn_mapper_tgmp_cfc_xoff_cfg(digi_handle->mapotn_handle, mapotn_chnl);
                }
            }
        }


        PMC_LOG_TRACE("\ninput port: %u \
                \ninput chnl: %u        \
                \ndata_source: %u       \
                \noduk_chnl: %u \n",
                      chnl_ctxt_ptr->switch_data.cpb_data.port_type,
                      chnl_ctxt_ptr->switch_data.cpb_data.channel,
                      chnl_ctxt_ptr->switch_data.cpb_data.data_source,
                      ((util_global_switch_data_def_t *)chnl_ctxt_ptr)->oduk_data.channel);

    }




    /* Perform ENET2 DCSU Startup Procedure for 100GE GMP Mapped ENET ETRANS Applications */
    if(result == PMC_SUCCESS && mode == DIGI_MAP_ODU4P_PKT_100_GE_GMP && 
       FALSE == pmc_is_digi_rev_a_revision(&digi_handle->base))
      {
        const UINT32 CN_GENERATOR_ENABLE_ADDR = 0x8E6044;
        const UINT32 FIFO_CLRB_ADDR = 0x8C8000;
        /* turn off the Cn Generation logic of the MPMO_DSP in MAPOTN_TX */
        UINT32 write_mask = digi_reg_read(digi_handle, 
                                          CN_GENERATOR_ENABLE_ADDR);
        write_mask &= ~0x3;
        digi_reg_write(digi_handle, CN_GENERATOR_ENABLE_ADDR, write_mask);

        /* set the fill level of the TGMP96:TXJC channel FIFO to zero */
        digi_reg_write(digi_handle, FIFO_CLRB_ADDR, 0);

        /* turn off DCSU */
        digi_dcsu_act(digi_handle, DIGI_DCSU_INST_ENET2, FALSE);

        /* adjust DCSU rate */
        digi_dcsu_adjust_enet2(digi_handle, TRUE);

        /* confirm MAPOTN Tx Path drained */
        PMC_Q_USLEEP(digi_handle,5);

        /* first try the firmware procedure, then we execute it on the host if it fails.            
         */
        {
            HOSTMSG_DECLARE_CFG_MSG_STAT(stat);
            result = hostmsg_send_cfg_message((pmc_handle_t *)digi_handle,MODID_PTP,HOSTMSG_CMD_REQ_PTP_SET_PTP_HOSTMSG_DCSU_AJUST_ST,NULL,0,stat);
            if (PMC_SUCCESS == result)
            {
                digi_handle->var.dcsu_init_state[DIGI_DCSU_INST_ENET2] = TRUE;
            }
        }
        if (PMC_SUCCESS != result)
        {
            result = PMC_SUCCESS;
            
            /* turn on DCSU */
            digi_dcsu_act(digi_handle, DIGI_DCSU_INST_ENET2, TRUE);
            
            /* wait 1 msecond for data path to fill */
            PMC_Q_USLEEP(digi_handle,1000);
            
            /* adjust DCSU back to default rate */
            digi_dcsu_adjust_enet2(digi_handle, FALSE);
        }
    }

    /* update handle state */ 
    if (PMC_SUCCESS == result)
    {
        ((digi_mapper_chnl_def_t*)*chnl_ctxt_pptr)->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED;
        digi_handle->handle_pool.s4_odu_struct[mapotn_chnl].switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED;
    }

    PMC_RETURN(result);
} /* digi_util_otn_mapper_prov */

/*******************************************************************************
* FUNCTION: digi_cbr_info_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*    Determine serdes type, post mux lane number, and post mld lane number
*
* INPUTS:
*   digi_handle     - Pointer to DIGI handle
*   intf_type       - Line, Sys, or SFI5.1 interface
*   port_uid        - Port UID 
*
* OUTPUTS:
*   cbrc_serdes     - CBRC serdes
*   cbrc_link       - Post mld link (0..11)
*   mux_link        - Post mux link
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cbr_info_get(digi_handle_t          *digi_handle,
                                   digi_serdes_intf_t      intf_type,
                                   UINT32                  port_uid,
                                   cbrc_serdes_type_t     *cbrc_serdes,
                                   UINT32                 *cbrc_link,
                                   UINT32                 *mux_link)
{
    PMC_ERROR                       result = PMC_SUCCESS;
    BOOL                            port_uid_found = FALSE;
    UINT32                          pin_count;    
    UINT32                          i;

    UINT32                          sfi_port_uid;
    digi_post_mux_sfi51_bus_t       sfi_bus_alloc;
    digi_xfi_pin_ctxt_t       *xfi_line_pin_ctxt_ptr;
    digi_xfi_pin_ctxt_t        *xfi_sys_pin_ctxt_ptr;


    PMC_ENTRY();
    
    PMC_ASSERT(digi_handle != NULL,       DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(cbrc_link != NULL,         DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(cbrc_serdes != NULL,       DIGI_ERR_NULL_HANDLE, 0, 0);
   
    /* Interface can only be Line or Sys */
    switch (intf_type)
    {
    case DIGI_SERDES_LINE_INTF:
    case DIGI_SERDES_SYSTEM_INTF:
    case DIGI_SERDES_SFI_51_INTF:
        break;
        
    default:
        PMC_RETURN(DIGI_ERR_CBR_INCORRECT_SERDES);
        break;
    } /* end switch */
    


    /* Determine serdes type, post mux lane number, and post mld lane number */
    /* Check for SFI 5.1 for 40G */
    if (DIGI_SERDES_SFI_51_INTF == intf_type) 
    {
        for (i = 0; i < DIGI_NUM_SFI51_PORTS_MAX; i++)
        {
            sfi_port_uid  = digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[i].port_uid;
            sfi_bus_alloc = digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[i].post_mux_2G5_bus_allocation;

            if (sfi_port_uid == port_uid)
            {
                if (DIGI_POST_MUX_BUS_0 == sfi_bus_alloc)
                {
                    *cbrc_serdes     = CBRC_SERDES_TYPE_40G_SFI51;
                    *cbrc_link       = 0;
                    *mux_link        = 0;
                    port_uid_found   = TRUE;
                }
                else if (DIGI_POST_MUX_BUS_1 == sfi_bus_alloc)
                {
                    *cbrc_serdes     = CBRC_SERDES_TYPE_40G_SFI51;
                    *cbrc_link       = 4; 
                    *mux_link        = 17;
                    port_uid_found   = TRUE;
                } 
                break;
            }
        }
    }         
    
    /* XFI/SFI-S mode */
    else
    {
        if (DIGI_SERDES_LINE_INTF == intf_type) {
            xfi_line_pin_ctxt_ptr = digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt;
        
            /* Find post-mux line lane from port uid */
            for(i = 0; i < DIGI_SERDES_XFI_LANES_MAX; i++)
            {
                if(xfi_line_pin_ctxt_ptr[i].port_uid == port_uid )
                {
                    *mux_link = xfi_line_pin_ctxt_ptr[i].post_mux_dsi_lane;
                    port_uid_found = TRUE;
                    break;
                }
            }
        } else {
            xfi_sys_pin_ctxt_ptr = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt;
            
            /* Find post-mux sys lane from port uid */
            for(i = 0; i < DIGI_SERDES_XFI_LANES_MAX; i++)
            {
                if(xfi_sys_pin_ctxt_ptr[i].port_uid == port_uid )
                {
                    *mux_link = xfi_sys_pin_ctxt_ptr[i].post_mux_dsi_lane;
                    port_uid_found = TRUE;
                    break;
                }
            }
        }

        


        if (TRUE == port_uid_found)
        {
            /* Get number of pins used */
            if (DIGI_SERDES_LINE_INTF == intf_type) {
                pin_count = digi_num_xfi_pins_in_use(digi_handle, port_uid);
            } else {
                pin_count = digi_num_sys_pins_in_use(digi_handle, port_uid);
            }


            /* Set serdes type based on number of pins used and set post-mld lane */
            switch (pin_count)
            {
            case DIGI_NUM_DSI_LANES_IN_10G:
                *cbrc_serdes = CBRC_SERDES_TYPE_10G_XFI;
                *cbrc_link   = *mux_link;
                break;
                
            case DIGI_NUM_DSI_LANES_IN_40G:
                *cbrc_serdes = CBRC_SERDES_TYPE_40G_STL;
                *cbrc_link   = *mux_link;
                break;
                
            case DIGI_NUM_DSI_LANES_IN_40G_SFIS:
                *cbrc_serdes = CBRC_SERDES_TYPE_40G_SFIS;
                
                if (0 == *mux_link)
                { 
                    *cbrc_link = 0;
                }
                else if (5 == *mux_link)
                {
                    *cbrc_link = 4;
                }
                else
                {
                    PMC_ASSERT(FALSE, DIGI_ERR_SERDES_INVALID_NUM_PINS_PER_PORT_PROV, *mux_link, *cbrc_serdes);
                }
                break;
            
            default:
                PMC_ASSERT(FALSE, DIGI_ERR_SERDES_INVALID_NUM_PINS_PER_PORT_PROV, pin_count, 0);
                break;
            } /* end switch */
        }
    }

    if (FALSE == port_uid_found)
    {
        result = DIGI_ERR_SERDES_PORT_UID_NOT_FOUND;
    }


    PMC_RETURN(result);
} /* digi_cbr_info_get */

#endif /* DOXYGEN_PUBLIC_ONLY */

/*******************************************************************************
* digi_cbr_client_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies basic bidirectional mode configuration for a signal
*   terminated by the CBRC subsystem.\n\n
*
*   This function applies basic bidirectional mode configuration for a 10GE/
*   40GE/100GE signal passing between an optical module and the CPB subsystem.\n\n
*
*   The function specifies the internal device resources to process this signal
*   using the dsi_chnl argument.  The CBRC resource for processing a
*   dsi_chnl has a 1:1 mapping with the dsi_chnl.\n\n
*
*   CBR client modes are defined in the digi_cbr_client_mode_t enum type.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_ctxt_ptr           - Structure defining serdes pins forming the
*                            physical ports.
*   mode                   - Enum, cbr client modes when connected to Line
*                            Serdes.
*
* OUTPUTS:
*   **chnl_ctxt_pptr       - a pointer to a pointer to a digi_cbr_client_chnl_t
*                            structure consisting of a mux_dsi_chnl,
*                            and util_global_cpb_port_data_t
*                            inner structure that is returned to the user.
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cbr_client_prov(digi_handle_t *digi_handle,
                                      digi_serdes_port_t *port_ctxt_ptr,
                                      digi_cbr_client_mode_t mode,
                                      digi_cbr_client_chnl_t **chnl_ctxt_pptr)
{
    PMC_ERROR           result = PMC_SUCCESS;

    /* CBRC API inputs */
    cbrc_handle_t              *cbrc_handle_ptr;
    mld_prbs_rx_mux_t           mux_table[LAST_DIGI_SERDES_INTF] = { LAST_MLD_PRBS_RX_MUX };
    mld_prbs_rx_mux_t           mux_select;
    cbrc_port_mode_t            client_mode[LAST_DIGI_CBR_CLIENT];
    UINT32                      cbrc_link = 0; /* Post MLD link (0..11) */
    cbrc_serdes_type_t          cbrc_serdes = CBRC_SERDES_TYPE_NONE;

    /* DIGI datapath layer processing */
    digi_cbr_client_mode_t           digi_mode = mode;
    digi_serdes_intf_t               intf_type;
    digi_post_mld_dsi_ctxt_t        *post_mld_lanes_ptr = NULL;
    UINT32                           i;
    digi_serdes_port_mode_t          serdes_mode = DIGI_SERDES_PORT_MODE_ANY_LOWPWR;
    digi_group_size_t                group_size = LAST_DIGI_GRP_SIZE;
    digi_serdes_port_def_t          *port_def_ptr = NULL;
    UINT32                           mux_link = 0;  /* Post Mux link */
    UINT32                           port_uid;
    digi_serdes_prov_state_t prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_DEVICE_NOT_INIT);
    }

    /* Check arguments */
    PMC_ASSERT(digi_handle != NULL,              DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(digi_handle->cbrc_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ctxt_pptr != NULL,           DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(port_ctxt_ptr != NULL,            DIGI_ERR_NULL_HANDLE, 0, 0);

    /* check serdes port context  */
    DIGI_SERDES_PORT_CTXT_HANDLE_CHECK(digi_handle, port_ctxt_ptr, result);
  
    /* Get interface and port uid */
    if (PMC_SUCCESS == result)
    {
        /* Cast void pointer */
        port_def_ptr = (digi_serdes_port_def_t*) port_ctxt_ptr;
    
        intf_type = port_def_ptr->intf;
        port_uid  = port_def_ptr->port_uid;
    } /* end if */
   
    

    /* Get CBRC inputs based on port uid and intf type */
    if (PMC_SUCCESS == result)
    {
        result = digi_cbr_info_get(digi_handle, 
                                   intf_type,
                                   port_uid,
                                   &cbrc_serdes,
                                   &cbrc_link,
                                   &mux_link);
    }




    /* This first checks to ensure the parameters fall within reasonable
       limits, but also ensures that the number of pins provisioned
       against the port will support the mode */
    if (PMC_SUCCESS == result)
    {
        result = digi_cbr_lane_validate(digi_handle,
                                        port_uid,
                                        cbrc_serdes,
                                        intf_type);
        
    } /* end if */


    /* Configure database */ 
    if (PMC_SUCCESS == result)
    {
        digi_cbrc_prov_params_convert(mode, &group_size);
        result = digi_cbrc_db_prov_cfg(digi_handle, group_size, cbrc_link, FALSE);
    } /* end if */




    if (PMC_SUCCESS == result)
    {
        post_mld_lanes_ptr = digi_first_post_mld_dsi_find(digi_handle, port_uid);
        if (NULL != post_mld_lanes_ptr)
        {
            if (DIGI_SERDES_PROV_STATE_UNASSIGNED == post_mld_lanes_ptr->prov_state)  
            {
                /* port found - check that it is configured and not assigned */
                /* if this is unassigned port, assign it to cbrc*/
                result = digi_post_mld_prov_state_set(digi_handle,
                                                      port_uid,
                                                      DIGI_SERDES_PROV_STATE_CBRC); 
                prov_state = DIGI_SERDES_PROV_STATE_CBRC;

                if(PMC_SUCCESS != result)
                {
                    result = DIGI_ERR_INVALID_ARG; 
                }
            } else {
                result = DIGI_ERR_SERDES_PORT_ALREADY_PROV;
            }

        } else {
            result = DIGI_ERR_NO_DSI_ALLOC_PROV;
        }
    } /* end if */
   

    /* Setup cbrc channel context (output) */
    if (PMC_SUCCESS == result)
    {
        digi_cbrc_serdes_mode_get(digi_mode, intf_type, &serdes_mode);
        /* Success path */
        *chnl_ctxt_pptr = digi_cbr_client_chnl_get(digi_handle, serdes_mode, cbrc_link, mux_link, port_uid, digi_mode);

    } /* end if */

    /* Get CBRC handle */
    cbrc_handle_ptr = digi_handle->cbrc_handle;

    if (PMC_SUCCESS == result)
    {
        /* determine state of the CBRC SS and if in lowpwr/reset state transition to a configurable state */
        digi_cbrc_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RUNNING);
    }

    /* Map serdes_if input to cbrc input */
    if (PMC_SUCCESS == result)
    {
        if (DIGI_PROD_APP_IS_100G_3X40G_CFP_CARD(digi_handle))
        {
            mux_select = MLD_PRBS_RX_MUX_LINE;
        }
        else
        {
            mux_table[DIGI_SERDES_LINE_INTF]   = MLD_PRBS_RX_MUX_LINE;
            mux_table[DIGI_SERDES_SYSTEM_INTF] = MLD_PRBS_RX_MUX_SYSTEM;
            mux_table[DIGI_SERDES_SFI_51_INTF] = MLD_PRBS_RX_MUX_LINE;
            mux_select = mux_table[intf_type];
        }


        /* Set all line serdes MUXes to same source */
        for (i = 0; i < UTIL_GLOBAL_CBRC_MAX_SLOTS; i++)
        {
            if (PMC_SUCCESS == result)
            {
                result = cbrc_mld_prbs_rx_mux_cfg(cbrc_handle_ptr, i, mux_select);
            }
        }
    } /* end if */


    if (PMC_SUCCESS == result)
    {
        result = digi_serdes_port_lifd_sifd_mux_cfg(digi_handle,
                                                    port_def_ptr,
                                                    XIFD_DSIS_CBRC);
    }

    if (PMC_SUCCESS == result)
    {
        /* Provision the SERDES */        
        result = digi_serdes_port_prov(digi_handle, port_ctxt_ptr, 
                                       serdes_mode);
    }

    /* Provision post-mld lanes in CBRC */
    if (PMC_SUCCESS == result)
    {
        /* Map client mode and serdes to cbrc input */
        client_mode[DIGI_CBR_CLIENT_40G_STS768]       = CBRC_PORT_MODE_40G_STS768;
        client_mode[DIGI_CBR_CLIENT_40G_STM256]       = CBRC_PORT_MODE_40G_STM256;
        client_mode[DIGI_CBR_CLIENT_10G_STS192]       = CBRC_PORT_MODE_10G_STS192;
        client_mode[DIGI_CBR_CLIENT_10G_STM64]        = CBRC_PORT_MODE_10G_STM64;
        client_mode[DIGI_CBR_CLIENT_10G_FC1200_ODU1F] = CBRC_PORT_MODE_10G_FC1200_ODU1F;
        client_mode[DIGI_CBR_CLIENT_10G_FC1200_ODU2F] = CBRC_PORT_MODE_10G_FC1200_ODU2F;
        client_mode[DIGI_CBR_CLIENT_10G_FC1200_GFP_ODU2E] = CBRC_PORT_MODE_10G_FC1200_GFP_ODU2E;
        client_mode[DIGI_CBR_CLIENT_10G_FC800]        = CBRC_PORT_MODE_10G_FC800;
        client_mode[DIGI_CBR_CLIENT_10G_CPRI_5G]      = CBRC_PORT_MODE_10G_CPRI_5G;
        client_mode[DIGI_CBR_CLIENT_10G_CPRI_6G]      = CBRC_PORT_MODE_10G_CPRI_6G;
        client_mode[DIGI_CBR_CLIENT_10G_CPRI_10G]     = CBRC_PORT_MODE_10G_CPRI_10G;
        client_mode[DIGI_CBR_CLIENT_10G_GDPS_5G]      = CBRC_PORT_MODE_10G_GDPS_5G;
        client_mode[DIGI_CBR_CLIENT_10G_GDPS_10G]     = CBRC_PORT_MODE_10G_GDPS_10G;
        client_mode[DIGI_CBR_CLIENT_10G_STS192_PRBS]  = CBRC_PORT_MODE_10G_STS192_PRBS;
        client_mode[DIGI_CBR_CLIENT_10G_STM64_PRBS]   = CBRC_PORT_MODE_10G_STM64_PRBS;
        client_mode[DIGI_CBR_CLIENT_10G_8B_10B_IDLE]  = CBRC_PORT_MODE_10G_8B_10B_IDLE;
        client_mode[DIGI_CBR_CLIENT_10G_64B_66B_IDLE] = CBRC_PORT_MODE_10G_64B_66B_IDLE;
        client_mode[DIGI_CBR_CLIENT_10G_8B_10B_ARB] = CBRC_PORT_MODE_10G_8B_10B_ARB;

        result = cbrc_port_provision(cbrc_handle_ptr,
                                     cbrc_link,
                                     cbrc_serdes,
                                     client_mode[digi_mode]);
    }

    /* activate CBR RX slice */    
    if (PMC_SUCCESS == result)
    {
        PMC_LOG_TRACE("\nCPB testing: calling cbrc rx and tx channel activate ... \n");
        result = cbrc_port_activate(cbrc_handle_ptr,
                                    CBRC_PORT_DIR_RX,
                                    cbrc_link);
        if (PMC_SUCCESS == result)
        {
            result = cbrc_port_activate(digi_handle->cbrc_handle,CBRC_PORT_DIR_TX,cbrc_link);
        }
            
        if (PMC_SUCCESS == result)
        {
            result = cbrc_sdh_pmg_activate(digi_handle->cbrc_handle,CBRC_PORT_DIR_RX,cbrc_link);
        }
    }

    if (PMC_SUCCESS == result)
    {
        result = digi_serdes_port_rate_state_set(digi_handle, port_def_ptr, serdes_mode, prov_state, DIGI_SERDES_PORT_RATE_STATE_PROV);
    }
    if (PMC_SUCCESS == result)
    {
        ((digi_cbr_client_chnl_def_t*)*chnl_ctxt_pptr)->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED;
    }

#ifdef CBRC_SONET_LOS_V_WORKAROUND
    if (PMC_SUCCESS == result)
    {
        result = cbrc_sonet_los_v_workaround(cbrc_handle_ptr, cbrc_link);
    }
#endif

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_cbr_client_prov */

/*******************************************************************************
* digi_ilkn_cpb_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This function applies basic configuration for a signal terminated by the
*   SIFD subsystem to a backplane interface from the CPB subsystem.\n\n
*
*   The enet_pmon parameter allows the channel to be identified for ENET PMON
*   monitoring by the ENET_SYS subsystem.  This is only applicable to the 
*   following product applications excluding: \n
*   DIGI_PROD_APP_SYSOTN_CARD \n\n
*
*   The ENET PMON configuration is only realized if the data stream is mapped  
*   to ENET_LINE subsystem.  This is because the ENET_SYS resources for
*   PMON monitoring must use the same 'link' indexes as the ENET_LINE
*   resources in order for device implementation specific timing routing to
*   be properly configured. \n\n
*
*   This function takes in the Tx and Rx Flow control calendar data and 
*   applies and deltas to the current configuration to the device.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *chnl_ctxt_ptr         - a pointer to a digi_ilkn_chnl_t
*                            structure consisting of a channel data this is
*                            configured.
*   rate                   - channel rate.  specified as an integer fraction of
*                            96. Used to allocate scheduling for signal
*                            transferred towards backplane.  The following must
*                            be true\n
*                            rate/96 >= (signal_rate Gpbs)/(120 Gbps
*   enet_pmon              - Initialization for ENET PMON monitoring of data
*                            stream with channel. Available only in some 
*                            scenarios see description. \n
*                            Valid values are: \n
*                             1 -- ENET PMON with ENET_SYS. \n
*                             0 -- No ENET PMON 
*   tx_type_header         - Defines if the device appends the four byte TYPE
*                            field for data transfers across the ILKN interface.
*                            Valid values are: \n
*                             1 -- ILKN data tranfers have TYPE header \n
*                             0 -- ILKN data transfer have no TYPE header 
*   rx_type_header         - Specifies the presence of TYPE header on data sent
*                            from backplane to ILKN interface \n
*                            Valid values are: \n
*                             1 -- ILKN data tranfers have TYPE header \n
*                             0 -- ILKN data transfer have no TYPE header 
*   rx_fc_reach_extend     - Configure data source (MAPOTN/ENET) to directly
*                            use ILKN XOFF indication for channel to backpressure
*                            Fabric Egress transmitter.  Used in cases where large 
*                            downstream channel buffering is present as required 
*                            for reach extension applications. \n
*                            Valid values are: \n
*                            0 --  Reach Extension Flow Control disabled \n
*                            1 --  Reach Extension Flow Control enabled
*   *tx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            that a TX CPB channel will respond to for
*                            XON/XOFF states. If not used pass in NULL.
*                            Used for output_port ILKN1/ILKN2 only.
*   *rx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            that a RX CPB channel will use to generate
*                            XON/XOFF states for processing by upstream device.
*                            If not used pass in NULL.
*                            Used for input_port ILKN1/ILKN2 only.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS on success or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_cpb_chnl_prov(digi_handle_t *digi_handle,
                                         digi_ilkn_chnl_t *chnl_ctxt_ptr,
                                         UINT8 rate,
                                         BOOL enet_pmon,
                                         BOOL tx_type_header,
                                         BOOL rx_type_header,
                                         BOOL rx_fc_reach_extend,
                                         digi_sifd_ilkn_calendar32_t *tx_ilkn_fc_ptr,
                                         digi_sifd_ilkn_calendar32_t *rx_ilkn_fc_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_ilkn_chnl_def_t* chnl_data_ptr;
    digi_sifd_ilkn_inst_t sifd_ilkn_inst;

    PMC_ATOMIC_ENTRY(digi_handle);


    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ctxt_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(rate <= DIGI_SCHD_96_ENTRY,DIGI_ERR_INVALID_ARG, 0, 0);

    /* Check that given handles belong to digi handle */
    DIGI_ILKN_CHNL_HANDLE_CHECK(digi_handle, chnl_ctxt_ptr, result);

    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_DEVICE_NOT_INIT);
    }
    
    if(IS_DIGI60(digi_handle) && (enet_pmon == TRUE))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_ILKN_CPB_NOT_SUPPORT_ENET_PMON_DIGI60);
    }

    /* add entries to DCS for the SIFD interface */
    chnl_data_ptr = (digi_ilkn_chnl_def_t*)chnl_ctxt_ptr;
    
    DIGI_CHNL_HANDLE_MAGIC_CHECK(chnl_data_ptr);
                        
    if (chnl_data_ptr->switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) 
    {
        /* It should be impossible to obtain a handle that has not been
         * configured */
        PMC_ASSERT(FALSE, DIGI_ERR_ILKN_CHNL_UNCONFIG, 0, 0);
    } 
    /* check that channel is not already provisoned against ODUK */
    else if (chnl_data_ptr->target == DIGI_ILKN_CHNL_TARGET_ODUK)
    {            
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_ILKN_CHNL_PROV_INCOMPATIBLE_TARGET);
    }
    else if (TRUE == util_global_rx_or_tx_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state))
    {

        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_ILKN_CHNL_ALREADY_PROV);
    }

    /* Retrieve ILKN instance associated to channel */
    result =  digi_ilkn_inst_get(chnl_data_ptr, &sifd_ilkn_inst);
                     
                
    if (result==PMC_SUCCESS)
    {
        result = digi_sifd_db_prov_cfg(digi_handle,
                                       sifd_ilkn_inst,
                                       chnl_data_ptr->switch_data.cpb_data.channel,
                                       rate);
    }

    if(result==PMC_SUCCESS)
    {

        cpb_sifd_chnl_ctxt_set(digi_handle->dcpb_handle, 
                               chnl_data_ptr->switch_data.cpb_data.port_type, 
                               chnl_data_ptr->switch_data.cpb_data.channel, 
                               rx_fc_reach_extend);
    
        chnl_data_ptr->tx_type_header = tx_type_header;
        chnl_data_ptr->rx_type_header = rx_type_header;
        chnl_data_ptr->rate = rate;
        chnl_data_ptr->rx_fc_reach_extend = rx_fc_reach_extend;

        if(enet_pmon == FALSE)
        {
            chnl_data_ptr->enet_pmon = DIGI_NO_PMON;

        } else if (DIGI_PROD_APP_GET(digi_handle) == DIGI_PROD_APP_TRANSMUXPONDER_CARD) {

            /* In this case and only this case, the ENET_LINE is the companion
             * ENET PMON for ENET_SYS */
            chnl_data_ptr->enet_pmon = DIGI_ENET_LINE_PMON;

        } else {
            /* Action: Determine if SIFD port ENET data stream ever targets ENET_SYS
               - if so then we may need to set enet_pmon based on the mapping picking the destination.
               - there would be an adjustment of the ->enet_pmon value if the source was ILKN. 
               - if we check product app, we can determine if we need ENET_LINE or ENET_SYS as
               the monitor. In transmuxponder we do not support system serdes to SIFD, so
               it would be ENET_LINE as the PMON source, otherwise it would be ENET_SYS */
            chnl_data_ptr->enet_pmon = DIGI_ENET_SYS_PMON;
        }
    
        /* apply flow control calendar update */
        if(result == PMC_SUCCESS)
        {
            result = digi_sifd_fc_calendar_save(digi_handle, 
                                                (sifd_ilkn_inst_t)sifd_ilkn_inst,
                                                tx_ilkn_fc_ptr,
                                                rx_ilkn_fc_ptr);
        }

        if (result == PMC_SUCCESS) {

            chnl_data_ptr->switch_data.header.prov_state = digi_ilkn_chnl_prov_state_new_val_get(chnl_data_ptr->switch_data.header.prov_state, TRUE, TRUE, TRUE, TRUE);
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_ilkn_cpb_chnl_prov */

/*******************************************************************************
* digi_ilkn_cpb_rx_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This functionprovides configuration of ILKN channel connected to 
*   Fabric Egress (Backplane -> ILKN -> DCPB).
*
*   The enet_pmon parameter allows the channel to be identified for ENET PMON
*   monitoring by the ENET_SYS subsystem.  This is only applicable to the 
*   following product applications excluding: \n
*   DIGI_PROD_APP_SYSOTN_CARD \n\n
*
*   The ENET PMON configuration is only realized if the data stream is mapped  
*   to ENET_LINE subsystem.  This is because the ENET_SYS resources for
*   PMON monitoring must use the same 'link' indexes as the ENET_LINE
*   resources in order for device implementation specific timing routing to
*   be properly configured. \n\n
*
*   This function takes in the Rx Flow control calendar data and 
*   applies and deltas to the current configuration to the device.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *chnl_ctxt_ptr         - a pointer to a digi_ilkn_chnl_t
*                            structure consisting of a channel data this is
*                            configured.
*   enet_pmon              - Initialization for ENET PMON monitoring of data
*                            stream with channel. Available only in some 
*                            scenarios see description. \n
*                            Valid values are: \n
*                             1 -- ENET PMON with ENET_SYS. \n
*                             0 -- No ENET PMON 
*   rx_type_header         - Specifies the presence of TYPE header on data sent
*                            from backplane to ILKN interface \n
*                            Valid values are: \n
*                             1 -- ILKN data tranfers have TYPE header \n
*                             0 -- ILKN data transfer have no TYPE header 
*   *rx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            that a RX CPB channel will use to generate
*                            XON/XOFF states for processing by upstream device.
*                            If not used pass in NULL.
*                            Used for input_port ILKN1/ILKN2 only.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS on success or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_cpb_rx_chnl_prov(digi_handle_t            *digi_handle,
                                            digi_ilkn_chnl_t            *chnl_ctxt_ptr,
                                            BOOL                         enet_pmon,
                                            BOOL                         rx_type_header,
                                            digi_sifd_ilkn_calendar32_t *rx_ilkn_fc_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_ilkn_chnl_def_t* chnl_data_ptr;
    digi_sifd_ilkn_inst_t sifd_ilkn_inst;

    PMC_ATOMIC_ENTRY(digi_handle);


    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ctxt_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Check that given handles belong to digi handle */
    DIGI_ILKN_CHNL_HANDLE_CHECK(digi_handle, chnl_ctxt_ptr, result);

    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_DEVICE_NOT_INIT);
    }

    chnl_data_ptr = (digi_ilkn_chnl_def_t*)chnl_ctxt_ptr;
    
    DIGI_CHNL_HANDLE_MAGIC_CHECK(chnl_data_ptr);

    /* Check channel state */
    if (chnl_data_ptr->switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) 
    {

        /* It should be impossible to obtain a handle that has not been
         * configured */
        PMC_ASSERT(FALSE, DIGI_ERR_ILKN_CHNL_UNCONFIG, 0, 0);

    }
    else if (TRUE == util_global_rx_or_tx_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state)) 
    {                       
        if (PMC_SUCCESS == result)
        {
            if ((FALSE == util_global_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state, UTIL_GLOBAL_DIR_TX)))
            {
                result = DIGI_ERR_ILKN_CHNL_ALREADY_PROV;
            }
            else
            {
                /* check that rx channel is not provisoned against ODUKSW */
                if (chnl_data_ptr->target == DIGI_ILKN_CHNL_TARGET_ODUK)
                {            
                    result = DIGI_ERR_ILKN_CHNL_PROV_INCOMPATIBLE_TARGET;
                }
            }
        }
    }
    
    /* Retrieve ILKN instance associated to channel */
    if (PMC_SUCCESS == result)
    {
        result =  digi_ilkn_inst_get(chnl_data_ptr, &sifd_ilkn_inst);
    }
    
    /* Configure context */
    if (result==PMC_SUCCESS)
    {    
        chnl_data_ptr->rx_type_header = rx_type_header;

        if(enet_pmon == FALSE)
        {
            chnl_data_ptr->enet_pmon = DIGI_NO_PMON;

        } else if (DIGI_PROD_APP_GET(digi_handle) == DIGI_PROD_APP_TRANSMUXPONDER_CARD) {

            /* In this case and only this case, the ENET_LINE is the companion
             * ENET PMON for ENET_SYS */
            chnl_data_ptr->enet_pmon = DIGI_ENET_LINE_PMON;

        } else {
            /* Action: Determine if SIFD port ENET data stream ever targets ENET_SYS
               - if so then we may need to set enet_pmon based on the mapping picking the destination.
               - there would be an adjustment of the ->enet_pmon value if the source was ILKN. 
               - if we check product app, we can determine if we need ENET_LINE or ENET_SYS as
               the monitor. In transmuxponder we do not support system serdes to SIFD, so
               it would be ENET_LINE as the PMON source, otherwise it would be ENET_SYS */
            chnl_data_ptr->enet_pmon = DIGI_ENET_SYS_PMON;
        }
    }

    /* apply flow control RX calendar update */
    if(result == PMC_SUCCESS)
    {
        result = digi_sifd_fc_calendar_save(digi_handle, 
                                            (sifd_ilkn_inst_t)sifd_ilkn_inst,
                                            NULL,
                                            rx_ilkn_fc_ptr);
    }
    /* final config update */
    if (PMC_SUCCESS == result)
    { 
        chnl_data_ptr->switch_data.header.prov_state = digi_ilkn_chnl_prov_state_new_val_get(chnl_data_ptr->switch_data.header.prov_state, TRUE, TRUE, FALSE, FALSE);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_ilkn_cpb_rx_chnl_prov */

/*******************************************************************************
* digi_ilkn_cpb_tx_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This functionprovides configuration of ILKN channel connected to 
*   Fabric Ingress (DCPB -> ILKN -> Backplane).
*
*   This function takes in the Tx Flow control calendar data and 
*   applies and deltas to the current configuration to the device.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *chnl_ctxt_ptr         - a pointer to a digi_ilkn_chnl_t
*                            structure consisting of a channel data this is
*                            configured.
*   rate                   - channel rate.  specified as an integer fraction of
*                            96. Used to allocate scheduling for signal
*                            transferred towards backplane.  The following must
*                            be true\n
*                            rate/96 >= (signal_rate Gpbs)/(120 Gbps
*   tx_type_header         - Defines if the device appends the four byte TYPE
*                            field for data transfers across the ILKN interface.
*                            Valid values are: \n
*                             1 -- ILKN data tranfers have TYPE header \n
*                             0 -- ILKN data transfer have no TYPE header 
*   rx_fc_reach_extend     - Configure data source (MAPOTN/ENET) to directly
*                            use ILKN XOFF indication for channel to backpressure
*                            Fabric Egress transmitter.  Used in cases where large 
*                            downstream channel buffering is present as required 
*                            for reach extension applications. \n
*                            Valid values are: \n
*                            0 --  Reach Extension Flow Control disabled \n
*                            1 --  Reach Extension Flow Control enabled
*   *tx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            that a TX CPB channel will respond to for
*                            XON/XOFF states. If not used pass in NULL.
*                            Used for output_port ILKN1/ILKN2 only.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS on success or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_cpb_tx_chnl_prov(digi_handle_t               *digi_handle,
                                            digi_ilkn_chnl_t            *chnl_ctxt_ptr,
                                            UINT8                        rate,
                                            BOOL                         tx_type_header,
                                            BOOL                         rx_fc_reach_extend,
                                            digi_sifd_ilkn_calendar32_t *tx_ilkn_fc_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_ilkn_chnl_def_t* chnl_data_ptr;
    digi_sifd_ilkn_inst_t sifd_ilkn_inst;

    PMC_ATOMIC_ENTRY(digi_handle);


    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ctxt_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(rate <= DIGI_SCHD_96_ENTRY,DIGI_ERR_INVALID_ARG, 0, 0);

    /* Check that given handles belong to digi handle */
    DIGI_ILKN_CHNL_HANDLE_CHECK(digi_handle, chnl_ctxt_ptr, result);

    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_DEVICE_NOT_INIT);
    }
    
    /* add entries to DCS for the SIFD interface */
    chnl_data_ptr = (digi_ilkn_chnl_def_t*)chnl_ctxt_ptr;
    
    DIGI_CHNL_HANDLE_MAGIC_CHECK(chnl_data_ptr);
    
    if (chnl_data_ptr->switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) 
    {
        
        /* It should be impossible to obtain a handle that has not been
         * configured */
        
        PMC_ASSERT(FALSE, DIGI_ERR_ILKN_CHNL_UNCONFIG, 0, 0);
        
    } 
    else if (TRUE == util_global_rx_or_tx_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state))
    {      
        
        /* check that Tx direction is not already provisoned */
        if (result==PMC_SUCCESS)
        {              
            if ((FALSE == util_global_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state, UTIL_GLOBAL_DIR_RX)))
            {
                result = DIGI_ERR_ILKN_CHNL_ALREADY_PROV;
            }
            else
            {
                /* check that channel is not already provisoned against ODUKSW */
                if (chnl_data_ptr->target == DIGI_ILKN_CHNL_TARGET_ODUK)
                {            
                    result = DIGI_ERR_ILKN_CHNL_PROV_INCOMPATIBLE_TARGET;
                }
            }        
        }
    }

    /* Retrieve ILKN instance assocaited to channel */  
    if (result==PMC_SUCCESS)
    {
        result =  digi_ilkn_inst_get(chnl_data_ptr, &sifd_ilkn_inst);
    }
    
    /* Create DB entries only if channel is only in configuration mode */
    if (result == PMC_SUCCESS)
    {
        result = digi_sifd_db_prov_cfg(digi_handle,
                                       sifd_ilkn_inst,
                                       chnl_data_ptr->switch_data.cpb_data.channel,
                                       rate);
    }
    
    /* Configure context */
    if (result == PMC_SUCCESS)
    {         
        cpb_sifd_chnl_ctxt_set(digi_handle->dcpb_handle,
                               chnl_data_ptr->switch_data.cpb_data.port_type,
                               chnl_data_ptr->switch_data.cpb_data.channel,
                               rx_fc_reach_extend);
        chnl_data_ptr->rx_fc_reach_extend = rx_fc_reach_extend;               
        chnl_data_ptr->tx_type_header = tx_type_header;
        chnl_data_ptr->rate = rate;
    
        /* apply flow control calendar update */
        if (result == PMC_SUCCESS)
        {
            result = digi_sifd_fc_calendar_save(digi_handle, 
                                                (sifd_ilkn_inst_t)sifd_ilkn_inst,
                                                tx_ilkn_fc_ptr,
                                                NULL);
        }
    }

    /* final context update done if execution succeeds */
    if (PMC_SUCCESS == result)
    { 
        chnl_data_ptr->switch_data.header.prov_state = digi_ilkn_chnl_prov_state_new_val_get(chnl_data_ptr->switch_data.header.prov_state, FALSE, FALSE, TRUE, TRUE);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_ilkn_cpb_tx_chnl_prov */

/*******************************************************************************
* digi_ilkn_cpb_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This function removes basic configuration for a signal terminated by the
*   SIFD subsystem to a backplane interface from the CPB subsystem.\n\n
*
*   This function takes in the Tx and Rx Flow control calendar data and 
*   applies and deltas to the current configuration to the device.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *chnl_ctxt_ptr         - a pointer to a digi_ilkn_chnl_t
*                            structure consisting of a channel data this is
*                            configured.
*   *tx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            that a TX CPB channel will respond to for
*                            XON/XOFF states. 
*                            If not used pass in NULL.
*                            Used for output_port ILKN1/ILKN2 only.
*   *rx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            that a RX CPB channel will use to generate
*                            XON/XOFF states for processing by upstream device.
*                            If not used pass in NULL.
*                            Used for input_port ILKN1/ILKN2 only.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_cpb_chnl_deprov(digi_handle_t *digi_handle,
                                           digi_ilkn_chnl_t *chnl_ctxt_ptr,
                                           digi_sifd_ilkn_calendar32_t *tx_ilkn_fc_ptr,
                                           digi_sifd_ilkn_calendar32_t *rx_ilkn_fc_ptr)
{
    PMC_ERROR result = DIGI_ERR_UNKNOWN;
    digi_ilkn_chnl_def_t* chnl_data_ptr;
    digi_sifd_ilkn_inst_t sifd_ilkn_inst = LAST_DIGI_SIFD_ILKN;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ctxt_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);


    chnl_data_ptr = (digi_ilkn_chnl_def_t*)chnl_ctxt_ptr;

    DIGI_CHNL_HANDLE_MAGIC_CHECK(chnl_data_ptr);

    if (chnl_data_ptr->switch_data.cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_NOT_USED) {

        result = DIGI_ERR_ILKN_CHNL_NOT_PROV;

    } 
    /* check that channel is not already provisoned against ODUK */
    else if (chnl_data_ptr->target == DIGI_ILKN_CHNL_TARGET_ODUK)
    {            
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_ILKN_CHNL_PROV_INCOMPATIBLE_TARGET);
    }
    else if ((chnl_data_ptr->switch_data.cpb_data.op_state.map_state.is_input_mapped == TRUE) ||
             (chnl_data_ptr->switch_data.cpb_data.op_state.map_state.is_output_mapped == TRUE)) {

        result = DIGI_ERR_CPB_STILL_MAPPED;

    } else {

        /* Retrieve ILKN instance associated to channel */
        result =  digi_ilkn_inst_get(chnl_data_ptr, &sifd_ilkn_inst);
        
        /* clear DB only when TX direction is provisoned */
        if (TRUE == util_global_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state,
                                                     UTIL_GLOBAL_DIR_TX))
        {
            result = digi_sifd_db_clear(digi_handle,
                                        sifd_ilkn_inst,
                                        chnl_data_ptr->switch_data.cpb_data.channel);  
        }
            
        /* apply flow control calendar update */
        if (result == PMC_SUCCESS) {
            result = digi_sifd_fc_calendar_save(digi_handle, 
                                                (sifd_ilkn_inst_t)sifd_ilkn_inst,
                                                tx_ilkn_fc_ptr,
                                                rx_ilkn_fc_ptr);
        }
            
        if (result == PMC_SUCCESS) {
            /* Once an ILKN chnl has been configured, it will always be
             * configured. It is safe to re-configure, but we place it back
             * into the CONFIG state instead of the the _UNCONFIG state. */
            chnl_data_ptr->switch_data.header.prov_state = digi_ilkn_chnl_prov_state_new_val_get(chnl_data_ptr->switch_data.header.prov_state, TRUE, FALSE, TRUE, FALSE);
            chnl_data_ptr->rate = 0;
            chnl_data_ptr->rx_fc_reach_extend = FALSE;
            chnl_data_ptr->rx_fc_reach_extend = FALSE;
            chnl_data_ptr->enet_pmon = DIGI_NO_PMON; 
            PMC_ASSERT(UTIL_GLOBAL_CHNL_ACTIVE_STATE_INACTIVE == chnl_data_ptr->switch_data.cpb_data.op_state.active_state,
                       DIGI_ERR_INVALID_ARG, 0, 0);
        }
    }


    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_ilkn_cpb_chnl_deprov */

/*******************************************************************************
* digi_ilkn_cpb_rx_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function removes basic configuration of ILKN channel connected to 
*   Fabric Egress (Backplane -> ILKN -> DCPB).
*
*   This function takes in the Rx Flow control calendar data and 
*   applies and deltas to the current configuration to the device.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *chnl_ctxt_ptr         - a pointer to a digi_ilkn_chnl_t
*                            structure consisting of a channel data this is
*                            configured.
*   *rx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            that a RX CPB channel will use to generate
*                            XON/XOFF states for processing by upstream device.
*                            If not used pass in NULL.
*                            Used for input_port ILKN1/ILKN2 only.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_cpb_rx_chnl_deprov(digi_handle_t *digi_handle,
                                              digi_ilkn_chnl_t *chnl_ctxt_ptr,
                                              digi_sifd_ilkn_calendar32_t *rx_ilkn_fc_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_ilkn_chnl_def_t* chnl_data_ptr;
    digi_sifd_ilkn_inst_t sifd_ilkn_inst = LAST_DIGI_SIFD_ILKN;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ctxt_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);


    chnl_data_ptr = (digi_ilkn_chnl_def_t*)chnl_ctxt_ptr;

    DIGI_CHNL_HANDLE_MAGIC_CHECK(chnl_data_ptr);

    /* check channel state */
    if (chnl_data_ptr->switch_data.cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_NOT_USED)
    {
        result = DIGI_ERR_ILKN_CHNL_NOT_PROV;
    } 
    /* check that channel is not already provisoned against ODUK */
    else if (chnl_data_ptr->target == DIGI_ILKN_CHNL_TARGET_ODUK)
    {            
        result = DIGI_ERR_ILKN_CHNL_PROV_INCOMPATIBLE_TARGET;
    }    

    if (PMC_SUCCESS == result)
    {    
        if (TRUE != util_global_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state,
                                                     UTIL_GLOBAL_DIR_RX))
        {
            result = DIGI_ERR_ILKN_CHNL_NOT_PROV;
        }
        else if ((chnl_data_ptr->switch_data.cpb_data.op_state.map_state.is_input_mapped == TRUE))
        {
            result = DIGI_ERR_CPB_STILL_MAPPED;
        }
    }

    if (PMC_SUCCESS == result)
    {    
        /* Retrieve ILKN instance associated to channel */
        result =  digi_ilkn_inst_get(chnl_data_ptr, &sifd_ilkn_inst);

        /* apply RX flow control calendar update */
        if (result == PMC_SUCCESS) 
        {
            result = digi_sifd_fc_calendar_save(digi_handle, 
                                                (sifd_ilkn_inst_t)sifd_ilkn_inst,
                                                NULL,
                                                rx_ilkn_fc_ptr);
        }

        /* update context */
        if (result == PMC_SUCCESS) 
        {
            /* Once an ILKN chnl has been configured, it will always be
             * configured. It is safe to re-configure, but we place it back
             * into the CONFIG state instead of the the _UNCONFIG state. */
            /* update provisioning status only if TX direction is not provisioned 
               otherwise keep prov_state as is */
            chnl_data_ptr->switch_data.header.prov_state = digi_ilkn_chnl_prov_state_new_val_get(chnl_data_ptr->switch_data.header.prov_state, TRUE, FALSE, FALSE, FALSE);
            if (TRUE != util_global_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state,
                                                         UTIL_GLOBAL_DIR_TX))
            {
                chnl_data_ptr->enet_pmon = DIGI_NO_PMON; 
            }
            chnl_data_ptr->rx_fc_reach_extend = FALSE;
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_ilkn_cpb_rx_chnl_deprov */

/*******************************************************************************
* digi_ilkn_cpb_tx_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function removes basic configuration of ILKN channel connected to 
*   Fabric Ingress (DCPB -> ILKN -> Backplane).
*
*   This function takes in the Tx Flow control calendar data and 
*   applies and deltas to the current configuration to the device.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *chnl_ctxt_ptr         - a pointer to a digi_ilkn_chnl_t
*                            structure consisting of a channel data this is
*                            configured.
*   *tx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            that a TX CPB channel will respond to for
*                            XON/XOFF states. 
*                            If not used pass in NULL.
*                            Used for output_port ILKN1/ILKN2 only.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_cpb_tx_chnl_deprov(digi_handle_t *digi_handle,
                                              digi_ilkn_chnl_t *chnl_ctxt_ptr,
                                              digi_sifd_ilkn_calendar32_t *tx_ilkn_fc_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_ilkn_chnl_def_t* chnl_data_ptr;
    digi_sifd_ilkn_inst_t sifd_ilkn_inst = LAST_DIGI_SIFD_ILKN;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ctxt_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    chnl_data_ptr = (digi_ilkn_chnl_def_t*)chnl_ctxt_ptr;

    DIGI_CHNL_HANDLE_MAGIC_CHECK(chnl_data_ptr);

    /* check channel state */
    if (chnl_data_ptr->switch_data.cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_NOT_USED) 
    {
        result = DIGI_ERR_ILKN_CHNL_NOT_PROV;
    }  
    /* check that channel is not already provisoned against ODUK */
    else if (chnl_data_ptr->target == DIGI_ILKN_CHNL_TARGET_ODUK)
    {            
        result = DIGI_ERR_ILKN_CHNL_PROV_INCOMPATIBLE_TARGET;
    }    

    if (PMC_SUCCESS == result)
    {
        if ((TRUE != util_global_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state, UTIL_GLOBAL_DIR_TX)))
        {
            result = DIGI_ERR_ILKN_CHNL_NOT_PROV;
        }
        else if ((chnl_data_ptr->switch_data.cpb_data.op_state.map_state.is_output_mapped == TRUE)) 
        {
            result = DIGI_ERR_CPB_STILL_MAPPED;
        } 
    }
    
    if (PMC_SUCCESS == result)
    {        
        /* Retrieve ILKN instance associated to channel */
        result =  digi_ilkn_inst_get(chnl_data_ptr, &sifd_ilkn_inst);
        
        /* Clear SIFD database entries associated to channel */ 
        if (result == PMC_SUCCESS) 
        {
            result = digi_sifd_db_clear(digi_handle,
                                        sifd_ilkn_inst,
                                        chnl_data_ptr->switch_data.cpb_data.channel);  
        }
        
        /* apply flow control calendar update */
        if (result == PMC_SUCCESS) {
            result = digi_sifd_fc_calendar_save(digi_handle, 
                                                (sifd_ilkn_inst_t)sifd_ilkn_inst,
                                                tx_ilkn_fc_ptr,
                                                NULL);
        }
        
        if (result == PMC_SUCCESS) 
        {
            /* Once an ILKN chnl has been configured, it will always be
             * configured. It is safe to re-configure, but we place it back
             * into the CONFIG state instead of the the _UNCONFIG state. */
            chnl_data_ptr->switch_data.header.prov_state = digi_ilkn_chnl_prov_state_new_val_get(chnl_data_ptr->switch_data.header.prov_state, FALSE, FALSE, TRUE, FALSE);
            if (FALSE == util_global_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state, UTIL_GLOBAL_DIR_RX))
            {
                chnl_data_ptr->enet_pmon = DIGI_NO_PMON; 
            }
            chnl_data_ptr->rate = 0;
        }        
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_ilkn_cpb_tx_chnl_deprov */

/*******************************************************************************
* digi_ilkn_oduk_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This function applies basic configuration for a signal terminated by the
*   SIFD subsystem to a backplane interface from the COREOTN ODUKSW subsystem.\n\n
*
*   This function takes in the Tx and Rx Flow control calendar data and 
*   applies and deltas to the current configuration to the device.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *chnl_ctxt_ptr         - a pointer to a digi_ilkn_chnl_t
*                            structure consisting of a channel data this is
*                            configured.
*   rate                   - channel rate.  specified as an integer fraction of
*                            96. Used to allocate scheduling for signal
*                            transferred towards backplane.  The following must
*                            be true\n
*                            rate/96 >= (signal_rate Gpbs)/(120 Gbps)
*   *tx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            that a TX ODUK channel will respond to for
*                            XON/XOFF states. 
*                            If not used pass in NULL.
*                            Used for output_port ILKN1/ILKN2 only.
*   *rx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            that a RX ODUK channel will use to generate
*                            XON/XOFF states for processing by upstream device.
*                            If not used pass in NULL.
*                            Used for input_port ILKN1/ILKN2 only.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS on success or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_oduk_chnl_prov(digi_handle_t *digi_handle,
                                          digi_ilkn_chnl_t *chnl_ctxt_ptr,
                                          UINT8 rate,
                                          digi_sifd_ilkn_calendar32_t *tx_ilkn_fc_ptr,
                                          digi_sifd_ilkn_calendar32_t *rx_ilkn_fc_ptr)
{
    PMC_ERROR result = DIGI_ERR_UNKNOWN;

    digi_ilkn_chnl_def_t* chnl_data_ptr;
    digi_sifd_ilkn_inst_t sifd_ilkn_inst = LAST_DIGI_SIFD_ILKN;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ctxt_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Check that given handles belong to digi handle */
    DIGI_ILKN_CHNL_HANDLE_CHECK(digi_handle, chnl_ctxt_ptr, result);

    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_DEVICE_NOT_INIT);
    }
    
    chnl_data_ptr = (digi_ilkn_chnl_def_t*)chnl_ctxt_ptr;
    
    if (chnl_data_ptr->switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) {
        
        /* It should be impossible to obtain a handle that has not been
         * configured */
        
        PMC_ASSERT(FALSE, DIGI_ERR_ILKN_CHNL_UNCONFIG, 0, 0);
        
    }
    /* check that channel is not already provisoned against CPB */
    else if (chnl_data_ptr->target == DIGI_ILKN_CHNL_TARGET_CPB)
    {            
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_ILKN_CHNL_PROV_INCOMPATIBLE_TARGET);
    }
    else if (TRUE == util_global_rx_or_tx_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state)) 
    {        
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_ILKN_CHNL_ALREADY_PROV);
    }

    /* Retrieve ILKN instance associated to channel */
    result =  digi_ilkn_inst_get(chnl_data_ptr, &sifd_ilkn_inst);

    /* add DB entries only when TX direction is provisoned */
    if (PMC_SUCCESS == result)
    {
        result = digi_oduksw_sifd_db_prov_cfg(digi_handle,
                                              sifd_ilkn_inst,
                                              chnl_data_ptr->switch_data.oduk_data.channel,
                                              rate,
                                              TRUE);
    }
    
    /* write the DIGI layer SIFD flow control calendar */
    if (PMC_SUCCESS == result)
    {
        
        result = digi_sifd_fc_calendar_save(digi_handle, 
                                            (sifd_ilkn_inst_t)sifd_ilkn_inst,
                                            tx_ilkn_fc_ptr,
                                            rx_ilkn_fc_ptr);
    }
    
    if (result == PMC_SUCCESS) 
    {
        chnl_data_ptr->rate = rate;        
        chnl_data_ptr->switch_data.header.prov_state = digi_ilkn_chnl_prov_state_new_val_get(chnl_data_ptr->switch_data.header.prov_state, TRUE, TRUE, TRUE, TRUE);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_ilkn_oduk_chnl_prov */

/*******************************************************************************
* digi_ilkn_oduk_rx_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This functionprovides configuration of ILKN channel connected to 
*   Fabric Egress (Backplane -> ILKN -> ODUKSW).
*
*   This function takes in the Rx Flow control calendar data and 
*   applies and deltas to the current configuration to the device.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *chnl_ctxt_ptr         - a pointer to a digi_ilkn_chnl_t
*                            structure consisting of a channel data this is
*                            configured.
*   *rx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            that a RX ODUK channel will use to generate
*                            XON/XOFF states for processing by upstream device.
*                            If not used pass in NULL.
*                            Used for input_port ILKN1/ILKN2 only.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS on success or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_oduk_rx_chnl_prov(digi_handle_t                *digi_handle,
                                             digi_ilkn_chnl_t             *chnl_ctxt_ptr,
                                             digi_sifd_ilkn_calendar32_t  *rx_ilkn_fc_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;

    digi_ilkn_chnl_def_t* chnl_data_ptr;
    digi_sifd_ilkn_inst_t sifd_ilkn_inst = LAST_DIGI_SIFD_ILKN;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ctxt_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Check that given handles belong to digi handle */
    DIGI_ILKN_CHNL_HANDLE_CHECK(digi_handle, chnl_ctxt_ptr, result);

    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_DEVICE_NOT_INIT);
    }
    
    chnl_data_ptr = (digi_ilkn_chnl_def_t*)chnl_ctxt_ptr;
    
    /* check channel state */
    if (chnl_data_ptr->switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) {
        
        /* It should be impossible to obtain a handle that has not been
         * configured */
        
        PMC_ASSERT(FALSE, DIGI_ERR_ILKN_CHNL_UNCONFIG, 0, 0);
        
    } 

    if (PMC_SUCCESS == result)
    {
        if (util_global_rx_or_tx_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state))
        { 
            /* check that rx direction is not already provisioned */
            if (PMC_SUCCESS == result)
            {
                if (FALSE == util_global_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state, UTIL_GLOBAL_DIR_TX))
                {            
                    result = DIGI_ERR_ILKN_CHNL_ALREADY_PROV;
                } 
                else 
                {
                    /* check that channel is not already provisoned against CPB */
                    if (chnl_data_ptr->target == DIGI_ILKN_CHNL_TARGET_CPB)
                    {            
                        result = DIGI_ERR_ILKN_CHNL_PROV_INCOMPATIBLE_TARGET;
                    }
                }
            }
        }
    }

    if (PMC_SUCCESS == result)
    {
        /* Retrieve ILKN instance associated to channel */
        result =  digi_ilkn_inst_get(chnl_data_ptr, &sifd_ilkn_inst);
    } 
        
    /* write the DIGI layer SIFD RX flow control calendar */
    if (PMC_SUCCESS == result)
    {        
        result = digi_sifd_fc_calendar_save(digi_handle, 
                                            (sifd_ilkn_inst_t)sifd_ilkn_inst,
                                            NULL,
                                            rx_ilkn_fc_ptr);
    }
    
    /* update context */
    if (result == PMC_SUCCESS) 
    { 
        chnl_data_ptr->switch_data.header.prov_state = digi_ilkn_chnl_prov_state_new_val_get(chnl_data_ptr->switch_data.header.prov_state, TRUE, TRUE, FALSE, FALSE);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_ilkn_oduk_rx_chnl_prov */

/*******************************************************************************
* digi_ilkn_oduk_tx_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This functionprovides configuration of ILKN channel connected to 
*   Fabric Ingress (ODUKSW  -> ILKN -> Backplane).
*
*   This function takes in the Tx Flow control calendar data and 
*   applies and deltas to the current configuration to the device.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *chnl_ctxt_ptr         - a pointer to a digi_ilkn_chnl_t
*                            structure consisting of a channel data this is
*                            configured.
*   rate                   - channel rate.  specified as an integer fraction of
*                            96. Used to allocate scheduling for signal
*                            transferred towards backplane.  The following must
*                            be true\n
*                            rate/96 >= (signal_rate Gpbs)/(120 Gbps)
*   *tx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            that a TX ODUK channel will respond to for
*                            XON/XOFF states. 
*                            If not used pass in NULL.
*                            Used for output_port ILKN1/ILKN2 only.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS on success or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_oduk_tx_chnl_prov(digi_handle_t               *digi_handle,
                                             digi_ilkn_chnl_t            *chnl_ctxt_ptr,
                                             UINT8                        rate,
                                             digi_sifd_ilkn_calendar32_t *tx_ilkn_fc_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;

    digi_ilkn_chnl_def_t* chnl_data_ptr;
    digi_sifd_ilkn_inst_t sifd_ilkn_inst = LAST_DIGI_SIFD_ILKN;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ctxt_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Check that given handles belong to digi handle */
    DIGI_ILKN_CHNL_HANDLE_CHECK(digi_handle, chnl_ctxt_ptr, result);

    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_DEVICE_NOT_INIT);
    }
    
    chnl_data_ptr = (digi_ilkn_chnl_def_t*)chnl_ctxt_ptr;
    
    /* check channel state */
    if (chnl_data_ptr->switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) {
        
        /* It should be impossible to obtain a handle that has not been
         * configured */
        
        PMC_ASSERT(FALSE, DIGI_ERR_ILKN_CHNL_UNCONFIG, 0, 0);
        
    }

 
    if (result==PMC_SUCCESS)
    { 
        if (util_global_rx_or_tx_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state))
        {
            if (result==PMC_SUCCESS)
            {   
                /* check that tx direction is not already provisioned */ 
                if (FALSE == util_global_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state, UTIL_GLOBAL_DIR_RX))
                {            
                    result = DIGI_ERR_ILKN_CHNL_ALREADY_PROV;
                } 
                else 
                {
                    /* check that channel is not already provisoned against CPB */
                    if (chnl_data_ptr->target == DIGI_ILKN_CHNL_TARGET_CPB)
                    {            
                        result = DIGI_ERR_ILKN_CHNL_PROV_INCOMPATIBLE_TARGET;
                    }
                }
            }
        }
    }

    if (PMC_SUCCESS == result)
    {
        /* Retrieve ILKN instance associated to channel */
        result =  digi_ilkn_inst_get(chnl_data_ptr, &sifd_ilkn_inst);
    }

    if (PMC_SUCCESS == result)
    {
        /* Create DB entries only if channel is only in configuration mode */
        result = digi_oduksw_sifd_db_prov_cfg(digi_handle,
                                              sifd_ilkn_inst,
                                              chnl_data_ptr->switch_data.oduk_data.channel,
                                              rate,
                                              TRUE);        
    }
    /* update context */
    if (result == PMC_SUCCESS) 
    {    
        chnl_data_ptr->switch_data.header.prov_state = digi_ilkn_chnl_prov_state_new_val_get(chnl_data_ptr->switch_data.header.prov_state, FALSE, FALSE, TRUE, TRUE);
        chnl_data_ptr->rate = rate;
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_ilkn_oduk_tx_chnl_prov */

/*******************************************************************************
* digi_ilkn_oduk_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function removes basic configuration for a signal terminated by the
*   SIFD subsystem to a backplane interface from the ODUK subsystem.\n\n
*
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *chnl_ctxt_ptr         - a pointer to a digi_ilkn_chnl_t
*                            structure consisting of a channel data this is
*                            configured.
*   *tx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            that a TX ODUK channel will respond to for
*                            XON/XOFF states. 
*                            If not used pass in NULL.
*                            Used for output_port ILKN1/ILKN2 only.
*   *rx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            that an inbound ODUK channel will use to generate
*                            XON/XOFF states for processing by upstream device.
*                            If not used pass in NULL.
*                            Used for input_port ILKN1/ILKN2 only.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_oduk_chnl_deprov(digi_handle_t               *digi_handle,
                                            digi_ilkn_chnl_t            *chnl_ctxt_ptr,
                                            digi_sifd_ilkn_calendar32_t *tx_ilkn_fc_ptr,
                                            digi_sifd_ilkn_calendar32_t *rx_ilkn_fc_ptr)
{
    digi_ilkn_chnl_def_t* chnl_data_ptr;
    digi_sifd_ilkn_inst_t sifd_ilkn_inst = LAST_DIGI_SIFD_ILKN;

    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ctxt_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Check that given handles belong to digi handle */
    DIGI_ILKN_CHNL_HANDLE_CHECK(digi_handle, chnl_ctxt_ptr, result);

    chnl_data_ptr = (digi_ilkn_chnl_def_t*)chnl_ctxt_ptr;

    DIGI_CHNL_HANDLE_MAGIC_CHECK(chnl_data_ptr);

    if (chnl_data_ptr->switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_NOT_USED) {
        
        result = DIGI_ERR_ILKN_CHNL_NOT_PROV;
        
    } 
    /* check that channel is not already provisoned against CPB */
    else if (chnl_data_ptr->target == DIGI_ILKN_CHNL_TARGET_CPB)
    {            
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_ILKN_CHNL_PROV_INCOMPATIBLE_TARGET);
    }
    else if ((chnl_data_ptr->switch_data.oduk_data.op_state.map_state.is_input_mapped == TRUE) ||
             (chnl_data_ptr->switch_data.oduk_data.op_state.map_state.is_output_mapped == TRUE)) {
        result = DIGI_ERR_ODUKSW_STILL_MAPPED;
        
    } else {
        /*
         * Updated the match the prov case and ensure that we get the 
         * exact ILKN value and not skew as a result of different 
         * types being slightly different.
         */
        /* Retrieve ILKN instance associated to channel */
        result =  digi_ilkn_inst_get(chnl_data_ptr, &sifd_ilkn_inst);

        if (result == PMC_SUCCESS) {
            /* apply flow control calendar update */
            result = digi_sifd_fc_calendar_save(digi_handle, 
                                                (sifd_ilkn_inst_t)sifd_ilkn_inst,
                                                tx_ilkn_fc_ptr,
                                                rx_ilkn_fc_ptr);
        }
        if (PMC_SUCCESS == result &&
            TRUE ==  util_global_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state, UTIL_GLOBAL_DIR_TX))
        {
            result = digi_oduksw_sifd_db_clear(digi_handle,
                                               sifd_ilkn_inst,
                                               chnl_data_ptr->switch_data.oduk_data.channel,
                                               TRUE);
        }
        if (result == PMC_SUCCESS) 
        {
            /* Once an ILKN chnl has been configured, it will always be
             * configured. It is safe to re-configure, but we place it back
             * into the CONFIG state instead of the the _UNCONFIG state. */
            chnl_data_ptr->switch_data.header.prov_state = digi_ilkn_chnl_prov_state_new_val_get(chnl_data_ptr->switch_data.header.prov_state, TRUE, FALSE, TRUE, FALSE);
            /* Note: The above does not reset the special ENET_PMON field */
            chnl_data_ptr->enet_pmon = DIGI_NO_PMON;
            chnl_data_ptr->rate = 0;
            chnl_data_ptr->rx_fc_reach_extend = FALSE;
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_ilkn_oduk_chnl_deprov */

/*******************************************************************************
* digi_ilkn_oduk_rx_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function removes basic configuration of ILKN channel connected to 
*   Fabric Egress (Backplane -> ILKN -> ODUKSW).
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *chnl_ctxt_ptr         - a pointer to a digi_ilkn_chnl_t
*                            structure consisting of a channel data this is
*                            configured.
*   *rx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            that a RX ODUK channel will use to generate
*                            XON/XOFF states for processing by upstream device.
*                            If not used pass in NULL.
*                            Used for input_port ILKN1/ILKN2 only.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_oduk_rx_chnl_deprov(digi_handle_t               *digi_handle,
                                               digi_ilkn_chnl_t            *chnl_ctxt_ptr,
                                               digi_sifd_ilkn_calendar32_t *rx_ilkn_fc_ptr)
{
    digi_ilkn_chnl_def_t* chnl_data_ptr;
    digi_sifd_ilkn_inst_t sifd_ilkn_inst = LAST_DIGI_SIFD_ILKN;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ctxt_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Check that given handles belong to digi handle */
    DIGI_ILKN_CHNL_HANDLE_CHECK(digi_handle, chnl_ctxt_ptr, result);

    chnl_data_ptr = (digi_ilkn_chnl_def_t*)chnl_ctxt_ptr;

    DIGI_CHNL_HANDLE_MAGIC_CHECK(chnl_data_ptr);

    /* check channel state */
    if (chnl_data_ptr->switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_NOT_USED) 
    {        
        result = DIGI_ERR_ILKN_CHNL_NOT_PROV;        
    } 
    /* check that channel is not already provisoned against CPB */
    else if (chnl_data_ptr->target == DIGI_ILKN_CHNL_TARGET_CPB)
    {            
        result = DIGI_ERR_ILKN_CHNL_PROV_INCOMPATIBLE_TARGET;
    }
    
    if (result==PMC_SUCCESS)
    {   
        if (TRUE != util_global_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state, UTIL_GLOBAL_DIR_RX))
        {
            result = DIGI_ERR_ILKN_CHNL_NOT_PROV;
        }
        else if ((chnl_data_ptr->switch_data.oduk_data.op_state.map_state.is_input_mapped == TRUE)) 
        {
            result = DIGI_ERR_ODUKSW_STILL_MAPPED;
            
        } 
    }
   
    if (result==PMC_SUCCESS)
    {
        /*
         * Updated the match the prov case and ensure that we get the 
         * exact ILKN value and not skew as a result of different 
         * types being slightly different.
         */
        /* Retrieve ILKN instance associated to channel */
        result =  digi_ilkn_inst_get(chnl_data_ptr, &sifd_ilkn_inst);

        if (result == PMC_SUCCESS) 
        {
            /* apply RX flow control calendar update */
            result = digi_sifd_fc_calendar_save(digi_handle, 
                                                (sifd_ilkn_inst_t)sifd_ilkn_inst,
                                                NULL,
                                                rx_ilkn_fc_ptr);
        }
        
        /* update context */
        if (result == PMC_SUCCESS) 
        {
            /* Once an ILKN chnl has been configured, it will always be
             * configured. It is safe to re-configure, but we place it back
             * into the CONFIG state instead of the the _UNCONFIG state. */
            /* Note: The above does not reset the special ENET_PMON field */
            chnl_data_ptr->switch_data.header.prov_state = digi_ilkn_chnl_prov_state_new_val_get(chnl_data_ptr->switch_data.header.prov_state, TRUE, FALSE, FALSE, FALSE);
            if (FALSE == util_global_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state, UTIL_GLOBAL_DIR_TX))
            {
                chnl_data_ptr->enet_pmon = DIGI_NO_PMON; 
            }            
            chnl_data_ptr->rx_fc_reach_extend = FALSE;
        }    
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_ilkn_oduk_rx_chnl_deprov */

/*******************************************************************************
* digi_ilkn_oduk_tx_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function removes basic configuration of ILKN channel connected to 
*   Fabric Ingress (ODUKSW -> ILKN -> Backplane).
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *chnl_ctxt_ptr         - a pointer to a digi_ilkn_chnl_t
*                            structure consisting of a channel data this is
*                            configured.
*   *tx_ilkn_fc_ptr        - Defines the set of flow control calendar entries
*                            thata TX ODUK channel will respond to for
*                            XON/XOFF states. 
*                            If not used pass in NULL.
*                            Used for output_port ILKN1/ILKN2 only.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_oduk_tx_chnl_deprov(digi_handle_t               *digi_handle,
                                               digi_ilkn_chnl_t            *chnl_ctxt_ptr,
                                               digi_sifd_ilkn_calendar32_t *tx_ilkn_fc_ptr)
{
    digi_ilkn_chnl_def_t* chnl_data_ptr;
    digi_sifd_ilkn_inst_t sifd_ilkn_inst = LAST_DIGI_SIFD_ILKN;

    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ctxt_ptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Check that given handles belong to digi handle */
    DIGI_ILKN_CHNL_HANDLE_CHECK(digi_handle, chnl_ctxt_ptr, result);

    chnl_data_ptr = (digi_ilkn_chnl_def_t*)chnl_ctxt_ptr;

    DIGI_CHNL_HANDLE_MAGIC_CHECK(chnl_data_ptr);

    /* check channel state */
    if (chnl_data_ptr->switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_NOT_USED) 
    {        
        result = DIGI_ERR_ILKN_CHNL_NOT_PROV;        
    } 
    /* check that channel is not already provisoned against CPB */
    else if (chnl_data_ptr->target == DIGI_ILKN_CHNL_TARGET_CPB)
    {            
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_ILKN_CHNL_PROV_INCOMPATIBLE_TARGET);
    }
    
    if (result==PMC_SUCCESS)
    {   
        if (TRUE != util_global_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state,
                                                     UTIL_GLOBAL_DIR_TX))
        {
            result = DIGI_ERR_ILKN_CHNL_NOT_PROV;
        }
        else if ((chnl_data_ptr->switch_data.oduk_data.op_state.map_state.is_output_mapped == TRUE)) 
        {
            result = DIGI_ERR_ODUKSW_STILL_MAPPED;            
        } 
    }

      
    if (result == PMC_SUCCESS)
    {   
        /*
         * Updated the match the prov case and ensure that we get the 
         * exact ILKN value and not skew as a result of different 
         * types being slightly different.
         */
        /* Retrieve ILKN instance associated to channel */
        result =  digi_ilkn_inst_get(chnl_data_ptr, &sifd_ilkn_inst);
        
        if (result == PMC_SUCCESS) {
            /* apply flow control calendar update */
            result = digi_sifd_fc_calendar_save(digi_handle, 
                                                (sifd_ilkn_inst_t)sifd_ilkn_inst,
                                                tx_ilkn_fc_ptr,
                                                NULL);
        }
        /* Clear SFID database entries */
        if (PMC_SUCCESS == result)
        {
            result = digi_oduksw_sifd_db_clear(digi_handle,
                                               sifd_ilkn_inst,
                                               chnl_data_ptr->switch_data.oduk_data.channel,
                                               TRUE);            
        }
        /* update context */
        if (result == PMC_SUCCESS) 
        {
            /* Once an ILKN chnl has been configured, it will always be
             * configured. It is safe to re-configure, but we place it back
             * into the CONFIG state instead of the the _UNCONFIG state. */
            
            /* Note: The above does not reset the special ENET_PMON field */
            chnl_data_ptr->switch_data.header.prov_state = digi_ilkn_chnl_prov_state_new_val_get(chnl_data_ptr->switch_data.header.prov_state, FALSE, FALSE, TRUE, FALSE);  
            if (FALSE == util_global_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state, UTIL_GLOBAL_DIR_RX))
            {
                chnl_data_ptr->enet_pmon = DIGI_NO_PMON; 
            }
            chnl_data_ptr->rate = 0;        
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_ilkn_oduk_tx_chnl_deprov */

/*******************************************************************************
* digi_oduksw_chnl_map
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function creates a logical connection between two DPI channels connected
*   to the ODUKSW of the COREOTN subsystem.  In addition it provides Packet Maker
*   and Monitor setup based on the signal properties being transferred through the
*   switch.\n\n
*
*   A helper function is provided to generate the B, T and T fractional input
*   values required as inputs to this function.  Prior to calling this API,
*   call digi_oif_pkt_period_calc() function to generate the packet size and
*   packet period data to use as inputs to this function.
*
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance.
*   *input_pc_ptr   - util_global_switch_data_t pointer defining inbound port
*   *output_pc_ptr  - util_global_switch_data_t pointer defining outbound port
*   rate_data       - enum, client stream types of signal passing through ODUKSW.
*                     For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, client_num_odu0 must
*                     be provided
*   client_num_odu0 - For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, number of ODU0 container
*                     associated with ODUFLEX signal.
*   client_bitrate  - For DIGI_ODUKSW_STREAM_CBR_ODUFLEX, this argument specifies
*                     client bitrate in bps. Set to 0 for all other ODU rates.                     
*   pkt_size        - desired packet size to pass through ODUKSW.  The packet size
*                     and packet period information is used to configure
*                     packet maker and packet monitor blocks surrounding ODUKSW
*                     to monitor the client rate.
*   pkt_per_int     - integer portion of packet period
*   pkt_per_n       - numerator of the packet period
*   pkt_per_d       - denominator of the packet period
*   halt_buffer     - ODUKSW FIFO buffer room to capture in flight data in
*                     the event that ODUKSW FIFO generates an upstream flow
*                     control signal.  Used in cases where ENET utilizes
*                     pause flow control and where a channel is fed from
*                     SIFD and asserts XOFF flow control.  halt_buffer is
*                     specified in units of blocks. \n
*                     The block size in bytes per unit is: 768 bytes. \n
*                     Applicable to client_data containing "DIGI_ODUKSW_STREAM_PKT_"
*   latency_s       - Maximum system latency outside the DIGI device.  
*                     Specified in units of 3.125 ns ticks.  The maximum 
*                     supported value is 38880 representing a maximum system 
*                     latency of 125 useconds.  This parameter is used to 
*                     configure the MPMO hold off delay following MPMOs
*                     reception of the first packet. Otherwise, set to 0.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_oduksw_chnl_map(digi_handle_t *digi_handle,
                                      util_global_switch_data_t *input_pc_ptr,
                                      util_global_switch_data_t *output_pc_ptr,
                                      digi_oduksw_stream_t rate_data,
                                      UINT32 client_num_odu0,
                                      DOUBLE client_bitrate,
                                      UINT32 pkt_size,
                                      UINT32 pkt_per_int,
                                      UINT32 pkt_per_n,
                                      UINT32 pkt_per_d,
                                      UINT32 halt_buffer,
                                      UINT32 latency_s)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* Check arguments */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_ASSERT(NULL != input_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != output_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    
    
    
    result = digi_oduksw_chnl_map_internal(digi_handle, input_pc_ptr, output_pc_ptr, rate_data, 
                                           client_num_odu0, client_bitrate, pkt_size, pkt_per_int, pkt_per_n, 
                                           pkt_per_d, FALSE, 0 ,halt_buffer, latency_s);
    if (result != PMC_SUCCESS)
    {
        PMC_ATOMIC_RETURN(digi_handle, result);
    }  
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_oduksw_chnl_map */

/*******************************************************************************
* digi_oduksw_int_latency_chnl_map
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function creates a logical connection between two DPI channels connected
*   to the ODUKSW of the COREOTN subsystem.  In addition it provides Packet Maker
*   and Monitor setup based on the signal properties being transferred through the
*   switch.\n\n
*
*   This function allows to program the hysteresis buffer. The programmable 
*   hysteresis buffer MUST be greater than the latency of one packet and less than 
*   the default hysteresis buffer latency.\n\n
*
*   A helper function is provided to generate the B, T and T fractional input
*   values required as inputs to this function.  Prior to calling this API,
*   call digi_oif_pkt_period_calc() function to generate the packet size and
*   packet period data to use as inputs to this function.
*
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance.
*   *input_pc_ptr   - util_global_switch_data_t pointer defining inbound port
*   *output_pc_ptr  - util_global_switch_data_t pointer defining outbound port
*   rate_data       - enum, client stream types of signal passing through ODUKSW.
*                     For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, client_num_odu0 must
*                     be provided
*   client_num_odu0 - For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, number of ODU0 container
*                     associated with ODUFLEX signal.
*   client_bitrate  - For DIGI_ODUKSW_STREAM_CBR_ODUFLEX, this argument specifies
*                     client bitrate in bps. Set to 0 for all other ODU rates.                     
*   pkt_size        - desired packet size to pass through ODUKSW.  The packet size
*                     and packet period information is used to configure
*                     packet maker and packet monitor blocks surrounding ODUKSW
*                     to monitor the client rate.
*   pkt_per_int     - integer portion of packet period
*   pkt_per_n       - numerator of the packet period
*   pkt_per_d       - denominator of the packet period
*   hys_buffer      - hysteresis buffer size in refclk cycles
*   halt_buffer     - ODUKSW FIFO buffer room to capture in flight data in
*                     the event that ODUKSW FIFO generates an upstream flow
*                     control signal.  Used in cases where ENET utilizes
*                     pause flow control and where a channel is fed from
*                     SIFD and asserts XOFF flow control.  halt_buffer is
*                     specified in units of blocks. \n
*                     The block size in bytes per unit is: 768 bytes. \n
*                     Applicable to client_data containing "DIGI_ODUKSW_STREAM_PKT_"
*   latency_s       - Maximum system latency outside the DIGI device.  
*                     Specified in units of 3.125 ns ticks.  The maximum 
*                     supported value is 38880 representing a maximum system 
*                     latency of 125 useconds.  This parameter is used to 
*                     configure the MPMO hold off delay following MPMOs
*                     reception of the first packet. Otherwise, set to 0.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_oduksw_int_latency_chnl_map(digi_handle_t *digi_handle,
                                                  util_global_switch_data_t *input_pc_ptr,
                                                  util_global_switch_data_t *output_pc_ptr,
                                                  digi_oduksw_stream_t rate_data,
                                                  UINT32 client_num_odu0,
                                                  DOUBLE client_bitrate,
                                                  UINT32 pkt_size,
                                                  UINT32 pkt_per_int,
                                                  UINT32 pkt_per_n,
                                                  UINT32 pkt_per_d,
                                                  UINT32 hys_buffer,
                                                  UINT32 halt_buffer,
                                                  UINT32 latency_s)
{
    
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    /* Check arguments */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_ASSERT(NULL != input_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != output_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    
    if (PMC_SUCCESS == result)
    {
        result = digi_oduksw_chnl_map_internal(digi_handle, input_pc_ptr, output_pc_ptr, rate_data, 
                                               client_num_odu0, client_bitrate, pkt_size, pkt_per_int, pkt_per_n, 
                                               pkt_per_d, TRUE, hys_buffer ,halt_buffer, latency_s);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_oduksw_int_latency_chnl_map */

/*******************************************************************************
*  digi_default_hys_latency_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function gets the default hysteresis buffer size in refclk cycles. 
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance.
*   *output_pc_ptr  - util_global_switch_data_t pointer defining outbound port
*                     of the ODUKSW (ILKN->"X")
*
* OUTPUTS:
*   hys_latency_refclk - latency in reference clock cycles
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_default_hys_latency_get(digi_handle_t *digi_handle, 
                                              util_global_switch_data_t *output_pc_ptr,
                                              UINT32 *hys_latency_refclk)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 hys_latency;
    util_global_switch_data_def_t *local_output_sw_ptr = (util_global_switch_data_def_t *)output_pc_ptr;
    util_global_oduk_port_data_t *local_output_pc_ptr = &(local_output_sw_ptr->oduk_data);
    
    PMC_ATOMIC_ENTRY(digi_handle);

    result = coreotn_hys_latency_get(digi_handle->coreotn_handle,
                                     (coreotn_oduksw_output_port_type_t)local_output_pc_ptr->port_type,
                                     local_output_pc_ptr->channel,
                                     0,
                                     &hys_latency);

    PMC_LOG_TRACE("hys_latency: %u \n",hys_latency);
    
    if (PMC_SUCCESS != result)
    {
        PMC_ATOMIC_RETURN(digi_handle, result);
    }
    
    *hys_latency_refclk = hys_latency;
    
    PMC_ATOMIC_RETURN(digi_handle,result);
    
} /* digi_default_hys_latency_get */

#ifndef DOXYGEN_PUBLIC_ONLY

/*******************************************************************************
* digi_oduksw_chnl_map_internal
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function creates a logical connection between two DPI channels connected
*   to the ODUKSW of the COREOTN subsystem.  In addition it provides Packet Maker
*   and Monitor setup based on the signal properties being transferred through the
*   switch.\n\n
*
*   This function also allows to program the hysteresis buffer. The programmable 
*   hysteresis buffer MUST be greater than the latency of one packet and less than 
*   the default hysteresis buffer latency. \n\n
*
*   A helper function is provided to generate the B, T and T fractional input
*   values required as inputs to this function.  Prior to calling this API,
*   call digi_oif_pkt_period_calc() function to generate the packet size and
*   packet period data to use as inputs to this function.
*
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance.
*   *input_pc_ptr   - util_global_switch_data_t pointer defining inbound port
*   *output_pc_ptr  - util_global_switch_data_t pointer defining outbound port
*   rate_data       - enum, client stream types of signal passing through ODUKSW.
*                     For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, client_num_odu0 must
*                     be provided
*   client_num_odu0 - For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, number of ODU0 container
*                     associated with ODUFLEX signal.
*   client_bitrate  - For DIGI_ODUKSW_STREAM_CBR_ODUFLEX, this argument specifies
*                     client bitrate in bps. Set to 0 for all other ODU rates.                     
*   pkt_size        - desired packet size to pass through ODUKSW.  The packet size
*                     and packet period information is used to configure
*                     packet maker and packet monitor blocks surrounding ODUKSW
*                     to monitor the client rate.
*   pkt_per_int     - integer portion of packet period
*   pkt_per_n       - numerator of the packet period
*   pkt_per_d       - denominator of the packet period
*   hys_buffer_en   - custom hysteresis buffer size mode:\n
*                     TRUE : custom hysteresis buffer size mode is enable 
*                     FALSE : custom hysteresis buffer size mode is disabled
*   hys_buffer      - hysteresis buffer size in refclk cycles
*   halt_buffer     - ODUKSW FIFO buffer room to capture in flight data in
*                     the event that ODUKSW FIFO generates an upstream flow
*                     control signal.  Used in cases where ENET utilizes
*                     pause flow control and where a channel is fed from
*                     SIFD and asserts XOFF flow control.  halt_buffer is
*                     specified in units of blocks. \n
*                     The block size in bytes per unit is: 768 bytes. \n
*                     Applicable to client_data containing "DIGI_ODUKSW_STREAM_PKT_"
*   latency_s       - Maximum system latency outside the DIGI device.  
*                     Specified in units of 3.125 ns ticks.  The maximum 
*                     supported value is 38880 representing a maximum system 
*                     latency of 125 useconds.  This parameter is used to 
*                     configure the MPMO hold off delay following MPMOs
*                     reception of the first packet. Otherwise, set to 0.
* 
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_oduksw_chnl_map_internal(digi_handle_t *digi_handle,
                                                util_global_switch_data_t *input_pc_ptr,
                                                util_global_switch_data_t *output_pc_ptr,
                                                digi_oduksw_stream_t rate_data,
                                                UINT32 client_num_odu0,
                                                DOUBLE client_bitrate,
                                                UINT32 pkt_size,
                                                UINT32 pkt_per_int,
                                                UINT32 pkt_per_n,
                                                UINT32 pkt_per_d,
                                                BOOL   hys_buffer_en,
                                                UINT32 hys_buffer,
                                                UINT32 halt_buffer,
                                                UINT32 latency_s)
{
    PMC_ERROR result = PMC_SUCCESS;

    util_global_odukp_type_t odu_type = UTIL_GLOBAL_LAST_ODUK;

    util_global_switch_data_def_t *input_pc_data_ptr = NULL;
    util_global_switch_data_def_t *output_pc_data_ptr = NULL;

    util_global_oduk_port_data_t *local_input_pc_ptr = (util_global_oduk_port_data_t*)input_pc_ptr;
    util_global_oduk_port_data_t *local_output_pc_ptr = (util_global_oduk_port_data_t*)output_pc_ptr;
    digi_sifd_xfer_mode_t xfer_mode = (digi_sifd_xfer_mode_t)0;
    coreotn_oduksw_xfer_mode_t oduksw_xfer_mode = LAST_COREOTN_ODUKSW_BURST_XFER;

    UINT32 dcs_mode = 1;

    BOOL port_state = FALSE;
    UINT32 hdr_removal_size = 0;
    UINT32 hdr_hole_size = 0;
    UINT32 i, chnl;

    coreotn_handle_t *coreotn_handle;

    mapotn_src_dest_t mapotn_src = LAST_MAPOTN_DEST;
    mapotn_src_dest_t mapotn_dest = LAST_MAPOTN_DEST;
    util_global_mapping_mode_t mapotn_mapping_mode = UTIL_GLOBAL_NO_MAP;
    util_global_map_adapt_func_t adapt_mode = UTIL_GLOBAL_MAP_NO_RATE;
    util_global_map_adapt_func_t dummy_adapt_mode = UTIL_GLOBAL_MAP_NO_RATE;
    BOOL8 bmp_map = FALSE;
    BOOL8 valid_payload = FALSE;
    digi_ilkn_chnl_def_t* ilkn_chnl_data_ptr;

    PMC_ENTRY();

    /* Check arguments */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_ASSERT(NULL != input_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != output_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* Check that given handles belong to digi handle */
    result = digi_oduksw_chnl_validate(digi_handle, input_pc_ptr);

    if (result == PMC_SUCCESS)
    {
        result = digi_oduksw_chnl_validate(digi_handle, output_pc_ptr);
    }
    if (PMC_SUCCESS != result)
    {
        PMC_RETURN(result);
    }
    
    coreotn_handle = digi_handle->coreotn_handle;

    input_pc_data_ptr = (util_global_switch_data_def_t *)input_pc_ptr;
    output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;

    DIGI_CHNL_HANDLE_MAGIC_CHECK(input_pc_data_ptr);
    DIGI_CHNL_HANDLE_MAGIC_CHECK(output_pc_data_ptr);

    local_input_pc_ptr = &(input_pc_data_ptr->oduk_data);
    local_output_pc_ptr = &(output_pc_data_ptr->oduk_data);

    if (result == PMC_SUCCESS)
    {

        if(latency_s > DIGI_LATENCY_S_MAX_VALUE)
        {
            result = DIGI_ERR_LATENCY_S_EXCEEDED;
        }
    }

    if (result == PMC_SUCCESS)
    {

        if (TRUE != util_global_chnl_prov_status_get(input_pc_data_ptr->header.prov_state, UTIL_GLOBAL_DIR_RX)) {

            result = DIGI_ERR_ODUKSW_CHNL_NOT_PROV;

        } else if (TRUE != util_global_chnl_prov_status_get(output_pc_data_ptr->header.prov_state, UTIL_GLOBAL_DIR_TX)) {

            result = DIGI_ERR_ODUKSW_CHNL_NOT_PROV;

        } 
        else if (local_output_pc_ptr->op_state.map_state.is_output_mapped == TRUE) {

            result = DIGI_ERR_ODUKSW_ALREADY_MAPPED;
        }
    }
    if (PMC_SUCCESS == result)
    {
        PMC_ASSERT(local_input_pc_ptr->port_type < UTIL_GLOBAL_ODUK_PORT_NOT_USED, DIGI_ERR_INVALID_ARG, 0, 0);
        PMC_ASSERT(local_output_pc_ptr->port_type < UTIL_GLOBAL_ODUK_PORT_NOT_USED, DIGI_ERR_INVALID_ARG, 0, 0);
    }

    /* check the payload type of the output channel. If not unchannelized
    ** then return an error
    */
    if (PMC_SUCCESS == result && local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_COREOTN)
    {
        result = coreotn_oduksw_odu_payload_format_validate(digi_handle->coreotn_handle,
                                                            local_output_pc_ptr,
                                                            &valid_payload);
                                                            
        if (valid_payload == FALSE)
        {
            result = DIGI_ERR_INVALID_ODU_PAYLOAD_FORMAT;
        }                                                               
    }

    if (PMC_SUCCESS == result)
    {
        result  = digi_oduksw_test_rate_compatibility(digi_handle,
                                                      input_pc_ptr,
                                                      output_pc_ptr,
                                                      rate_data,
                                                      client_num_odu0,
                                                      client_bitrate);
    }
   
    /* powerup oduksw */
    digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_RUNNING,COREOTN_ODUKSW);                
    if (PMC_SUCCESS == result)
    {

        /*test if the CPB input port and output port has been initialized, if not initialized, initialized
          the port first */
        if(UTIL_GLOBAL_ODUK_PORT_ILKN1 == local_output_pc_ptr->port_type
           && digi_handle->var.prod_app != DIGI_PROD_APP_SYSOTN_CARD)
        {
            if (DIGI_SIFD_ODUKSW_ILKN_HEADER_2B_AND_4B == digi_handle->var.sifd_ilkn_1_cfg.ilkn.oduksw_header)
            {
                hdr_hole_size = 6;
            }
            else if (DIGI_SIFD_ODUKSW_ILKN_HEADER_4B == digi_handle->var.sifd_ilkn_1_cfg.ilkn.oduksw_header)
            {
                hdr_hole_size = 4;
            }
            else if (DIGI_SIFD_ODUKSW_ILKN_HEADER_2B == digi_handle->var.sifd_ilkn_1_cfg.ilkn.oduksw_header)
            {
                hdr_hole_size = 2;
            }
            dcs_mode = 2;
            xfer_mode = digi_handle->var.sifd_ilkn_1_cfg.ilkn.oduksw_tx_xfer_mode;
        }
        else if (UTIL_GLOBAL_ODUK_PORT_ILKN2 == local_output_pc_ptr->port_type)
        {
            xfer_mode = digi_handle->var.sifd_ilkn_2_cfg.ilkn.oduksw_tx_xfer_mode;
            dcs_mode = 2;
            
            if (DIGI_SIFD_ODUKSW_ILKN_HEADER_2B_AND_4B == digi_handle->var.sifd_ilkn_2_cfg.ilkn.oduksw_header)
            {
                hdr_hole_size = 6;
            }
            else if (DIGI_SIFD_ODUKSW_ILKN_HEADER_4B == digi_handle->var.sifd_ilkn_2_cfg.ilkn.oduksw_header)
            {
                hdr_hole_size = 4;
            }
            else if (DIGI_SIFD_ODUKSW_ILKN_HEADER_2B == digi_handle->var.sifd_ilkn_2_cfg.ilkn.oduksw_header)
            {
                hdr_hole_size = 2;
            }
        }
        
        /* set hdr_removal_size */
        if (UTIL_GLOBAL_ODUK_PORT_ILKN1 == local_input_pc_ptr->port_type
            && digi_handle->var.prod_app != DIGI_PROD_APP_SYSOTN_CARD)
        {
            if (DIGI_SIFD_ODUKSW_ILKN_HEADER_2B_AND_4B == digi_handle->var.sifd_ilkn_1_cfg.ilkn.oduksw_header)
            {
                hdr_removal_size = 6;
            }
            else if (DIGI_SIFD_ODUKSW_ILKN_HEADER_4B == digi_handle->var.sifd_ilkn_1_cfg.ilkn.oduksw_header)
            {
                hdr_removal_size = 4;
            }
            else if (DIGI_SIFD_ODUKSW_ILKN_HEADER_2B == digi_handle->var.sifd_ilkn_1_cfg.ilkn.oduksw_header)
            {
                hdr_removal_size = 2;
            }
        }
        else if (UTIL_GLOBAL_ODUK_PORT_ILKN2 == local_input_pc_ptr->port_type)
        {
            if (DIGI_SIFD_ODUKSW_ILKN_HEADER_2B_AND_4B == digi_handle->var.sifd_ilkn_2_cfg.ilkn.oduksw_header)
            {
                hdr_removal_size = 6;
            }
            else if (DIGI_SIFD_ODUKSW_ILKN_HEADER_4B == digi_handle->var.sifd_ilkn_2_cfg.ilkn.oduksw_header)
            {
                hdr_removal_size = 4;
            }
            else if (DIGI_SIFD_ODUKSW_ILKN_HEADER_2B == digi_handle->var.sifd_ilkn_2_cfg.ilkn.oduksw_header)
            {
                hdr_removal_size = 2;
            }    
        }
        else {
            hdr_removal_size = 0;
        }    
            
            
        /* test input port to see if it has already been initialized,
           if not initialized, initialize port first */
        port_state = coreotn_oduksw_port_init_state_get(coreotn_handle, COREOTN_ODUKSW_PORT_TYPE_DPI_SLAVE, local_input_pc_ptr->port_type);
        if (FALSE == port_state)
        {
            if (UTIL_GLOBAL_ODUK_PORT_ILKN1 == local_input_pc_ptr->port_type
                && digi_handle->var.prod_app != DIGI_PROD_APP_SYSOTN_CARD)
            {
                oduksw_xfer_mode = (coreotn_oduksw_xfer_mode_t)digi_cpb_ilkn_xfer_data_get(digi_handle->var.sifd_ilkn_1_cfg.ilkn.rx_xfer_mode,
                                                                                           digi_handle->var.sifd_ilkn_1_cfg.ilkn.burst);
                
                result = coreotn_oduksw_input_port_init(coreotn_handle, local_input_pc_ptr->port_type,
                                                        oduksw_xfer_mode, hdr_removal_size);                                                        
            }
            else if (UTIL_GLOBAL_ODUK_PORT_ILKN2 == local_input_pc_ptr->port_type)
            {
                oduksw_xfer_mode = (coreotn_oduksw_xfer_mode_t)digi_cpb_ilkn_xfer_data_get(digi_handle->var.sifd_ilkn_2_cfg.ilkn.rx_xfer_mode,
                                                                                           digi_handle->var.sifd_ilkn_2_cfg.ilkn.burst);
                
                result = coreotn_oduksw_input_port_init(coreotn_handle, local_input_pc_ptr->port_type,
                                                        oduksw_xfer_mode, hdr_removal_size);                                                      
            }
            else
            {
                oduksw_xfer_mode = (coreotn_oduksw_xfer_mode_t)0;
                hdr_removal_size = 0;
                result = coreotn_oduksw_input_port_init(coreotn_handle, local_input_pc_ptr->port_type,
                                                        oduksw_xfer_mode, hdr_removal_size);
            }                                                         
        }
    }
    

    if (PMC_SUCCESS == result)
    {
        /* test the output port and initialize if it is not already initialized */
        port_state = coreotn_oduksw_port_init_state_get(coreotn_handle, COREOTN_ODUKSW_PORT_TYPE_DPI_MASTER, local_output_pc_ptr->port_type);
        if(FALSE == port_state)
        {
            result = coreotn_oduksw_output_port_init(coreotn_handle, local_output_pc_ptr->port_type, xfer_mode, 1);
        }
    }

    if (PMC_SUCCESS == result)
    {
        /* test the output port and initialize if it is not already initialized */
        port_state = coreotn_oduksw_port_init_state_get(coreotn_handle, COREOTN_ODUKSW_PORT_TYPE_DCS, local_output_pc_ptr->port_type);
        if(FALSE == port_state)
        {
            result = coreotn_oduksw_egress_mux_input_init(coreotn_handle, local_output_pc_ptr->port_type, xfer_mode, dcs_mode);
            /*result = cpb_egress_mux_input_init(coreotn_handle->oduksw_handle,
              output_port, oduksw_xfer_mode, mode);*/
            
        }     
    }


    if( ((UTIL_GLOBAL_ODUK_PORT_COREOTN == local_output_pc_ptr->port_type && 
          digi_handle->var.prod_app != DIGI_PROD_APP_SYSOTN_CARD) ||
         (UTIL_GLOBAL_ODUK_PORT_COREOTN == local_output_pc_ptr->port_type &&
          digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD &&
          digi_handle->var.mux_stages == DIGI_OTN_MUX_STAGES_NONE ) ||
         (UTIL_GLOBAL_ODUK_PORT_ILKN1 == local_output_pc_ptr->port_type &&
          digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)))
    {
        BOOL8 pinch_set = (rate_data == DIGI_ODUKSW_STREAM_CBR_ODU4)?TRUE:FALSE;
        UINT32 xoff_thres = (rate_data == DIGI_ODUKSW_STREAM_CBR_ODU4)?30:0x85;
        
        
        /*set the FO1 MPMO and DCS to pinch the calendar */
        if(result == PMC_SUCCESS)
        {
            result = coreotn_odu4_calendar_pinch_set(digi_handle->coreotn_handle,
                                                     (coreotn_oduksw_output_port_type_t)local_output_pc_ptr->port_type,
                                                     pinch_set);
        }

        /*Set the OTU_FRM_DINTLV_XOFF_THRES to 30 */
        if(pinch_set == TRUE && result == PMC_SUCCESS)
        {

            if((UTIL_GLOBAL_ODUK_PORT_COREOTN == local_output_pc_ptr->port_type &&
                digi_handle->var.prod_app != DIGI_PROD_APP_SYSOTN_CARD) ||
               (UTIL_GLOBAL_ODUK_PORT_ILKN1 == local_output_pc_ptr->port_type &&
                digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD))
            {
                result = lineotn_otu_frm_dintlv_xoff_thres_set(digi_handle->lineotn_handle,
                                                               local_output_pc_ptr->channel,    
                                                               xoff_thres);                                               
            }
            else
            {
                result = lineotn_otu_frm_dintlv_xoff_thres_set(digi_handle->sysotn_handle,
                                                               local_output_pc_ptr->channel,    
                                                               xoff_thres);
            }
        }
    } 
    
    /* get client rate in bps */
    if (PMC_SUCCESS == result)
    {
        result = digi_oduksw_rate_get( rate_data, &odu_type );
    }

    PMC_LOG_TRACE("odu_type = %u\n", odu_type);
    
    /* retrieve the input channel ID */
    if (PMC_SUCCESS == result && local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_MAPOTN)
    {
        /* populate ODUKSW DCS calendar with MAPOTN DB contents */
        for (i = 0; i < DIGI_SCHD_96_ENTRY; i++)
        {
            result = mapotn_db_entry_get(digi_handle->mapotn_handle, i, &chnl);
            
            if (PMC_SUCCESS == result && local_output_pc_ptr->channel == chnl)
            {
                result = coreotn_oduksw_db_entry_set(digi_handle->coreotn_handle,
                                                     (coreotn_oduksw_output_port_type_t)local_output_pc_ptr->port_type,
                                                     i,
                                                     local_output_pc_ptr->channel);
                if(PMC_SUCCESS != result)
                {
                    PMC_RETURN(result);
                }                                      
            }                                        
        }
    }
  
    /* in the SYSOTN card aplication, the ODUKSW allocation for LINE <-> COREOTN
       needs to slave to the lineotn database */
    if (PMC_SUCCESS == result && local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1)
    {
        if (digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
        {
            for (i = 0; i < DIGI_SCHD_96_ENTRY; i++)
            {
                result = lineotn_sysotn_mode_db_entry_get(digi_handle->lineotn_handle, i, &chnl);
            
                if (PMC_SUCCESS == result && local_output_pc_ptr->channel == chnl)
                {
                    result = coreotn_oduksw_db_entry_set(digi_handle->coreotn_handle,
                                                         (coreotn_oduksw_output_port_type_t)local_output_pc_ptr->port_type,
                                                         i,
                                                         local_output_pc_ptr->channel);
                    if(PMC_SUCCESS != result)
                    {
                        PMC_RETURN(result);
                    }                                      
                }                                        
            }
        } 
        else 
        {
            /* ilkn channel pointer exists for ILKN1 port in non SYSOTN case! */
            ilkn_chnl_data_ptr =  (digi_ilkn_chnl_def_t*) output_pc_ptr;

            /* At this point, Tx channel should be provisioned with a valid rate */
            if (0 == ilkn_chnl_data_ptr->rate)
            {
                result = DIGI_ERR_SCHD_INSUFFICIENT_RESOURCES_AVAILABLE;
            }

            if (PMC_SUCCESS == result)
            {
                result = digi_oduksw_sifd_db_prov_cfg(digi_handle,
                                                     DIGI_SIFD_ILKN1,
                                                     local_output_pc_ptr->channel,
                                                     ilkn_chnl_data_ptr->rate,
                                                     FALSE);
            }
        }       
    } 
    else if (PMC_SUCCESS == result && local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN2)
    {        
        ilkn_chnl_data_ptr =  (digi_ilkn_chnl_def_t*) output_pc_ptr;
        if (0 != ilkn_chnl_data_ptr->rate)
        {
            result = digi_oduksw_sifd_db_prov_cfg(digi_handle,
                                                  DIGI_SIFD_ILKN2,
                                                  local_output_pc_ptr->channel,
                                                  ilkn_chnl_data_ptr->rate,
                                                  FALSE);
        }
        else
        {
            result = DIGI_ERR_SCHD_RESOURCE_NOT_AVAILABLE;
        }
    }




    if (PMC_SUCCESS == result)
    {
        PMC_LOG_TRACE("\ncoreotn_oduksw_chnl_prov called with:\n    Input Port/Channel: %u %u\n    Output Port/Channel: %u %u\n",
                      (UINT32)local_input_pc_ptr->port_type, local_input_pc_ptr->channel,
                      (UINT32)local_output_pc_ptr->port_type,local_output_pc_ptr->channel);

        if(UTIL_GLOBAL_ODUK_PORT_MAPOTN == local_input_pc_ptr->port_type)
        {
            /* determine if the FO2 is being used as part of a BMP mapping application with MAPOTN_TX data coming
               from CPB. Note: The BMP mode does not apply to ETRANS paths to MAPOTN_TX.  */
            digi_mapper_src_dest_get(digi_handle,
                                     digi_handle->handle_pool.mapper_chnl[local_input_pc_ptr->channel].mode,
                                     digi_handle->handle_pool.mapper_chnl[local_input_pc_ptr->channel].enet_pmon,
                                     &mapotn_src,
                                     &mapotn_dest);
            digi_mapotn_mode_params_convert(digi_handle->handle_pool.mapper_chnl[local_input_pc_ptr->channel].mode,
                                            &adapt_mode,
                                            &dummy_adapt_mode);
            result = mapotn_mapping_mode_get(digi_handle->mapotn_handle, 
                                             adapt_mode,
                                             &mapotn_mapping_mode);
            PMC_ASSERT(result==PMC_SUCCESS, DIGI_ERR_CODE_ASSERT, 0, 0);

            if(mapotn_src == MAPOTN_DEST_CPB && mapotn_mapping_mode == UTIL_GLOBAL_BMP) bmp_map = TRUE;
        }    


        result = coreotn_oduksw_chnl_prov(digi_handle->coreotn_handle,
                                          (coreotn_oduksw_input_port_type_t)local_input_pc_ptr->port_type,
                                          local_input_pc_ptr->channel,
                                          (coreotn_oduksw_output_port_type_t)local_output_pc_ptr->port_type,
                                          local_output_pc_ptr->channel,
                                          odu_type,
                                          client_num_odu0,
                                          client_bitrate,
                                          pkt_size,
                                          pkt_per_int,
                                          pkt_per_n,
                                          pkt_per_d,
                                          (coreotn_oduksw_xfer_mode_t)xfer_mode,
                                          hys_buffer_en, 
                                          hys_buffer,
                                          halt_buffer,
                                          hdr_removal_size,
                                          latency_s,
                                          bmp_map);
              
    }
    PMC_ATOMIC_YIELD(digi_handle,0);

    /* configure ODUKSW hole insertion */
    if ((local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1 && 
         digi_handle->var.prod_app != DIGI_PROD_APP_SYSOTN_CARD)
        || local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN2)
    {
        if (PMC_SUCCESS == result)
        {
            result = coreotn_oduksw_chnl_hole_inst_head_cfg(coreotn_handle,
                                                            local_output_pc_ptr->port_type,
                                                            local_output_pc_ptr->channel,
                                                            hdr_hole_size);                                                     
        } 
    }         


#ifndef PMC_SW_SIMULATION
    /* activate FW OPU_CSF monitor */
    if (result==PMC_SUCCESS &&
        local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_MAPOTN)
    {
        if (FALSE == ((digi_mapper_chnl_def_t *)output_pc_ptr)->switch_data.cpb_data.op_state.map_state.is_input_mapped)
        {
            result =  digi_map_opu_csf_int_cfg(digi_handle, (digi_mapper_chnl_def_t *)output_pc_ptr, local_input_pc_ptr->channel, TRUE);
        }
    }
#endif /*PMC_SW_SIMULATION*/

    if (result==PMC_SUCCESS) {

        local_input_pc_ptr->op_state.map_state.input_map_count++;
        local_input_pc_ptr->op_state.map_state.is_input_mapped = TRUE;
        local_output_pc_ptr->op_state.map_state.is_output_mapped = TRUE;
    }

    PMC_RETURN(result);
} /* digi_oduksw_chnl_map_internal */
#endif /* DOXYGEN_PUBLIC_ONLY */

/*******************************************************************************
*  digi_cpb_remap_clean
* ______________________________________________________________________________
*
* DESCRIPTION:
*   If there is a block leak in the CPB this function attempts to clean it. If 
*   there is no block leak or it was cleaned, a NULL value is returned. If a 
*   block leak still persists, the channel handle with the associated block leak 
*   is returned. If this function is unable to clean a block leak, the block 
*   leak can be cleaned by first calling digi_cpb_chnl_deactivate() which puts 
*   the FIFO pointers in reset, and then by calling this function again.
*
*   If there is a block leak, a clean up will automatically be attempted whenever
*   digi_cpb_chnl_map() is called. Consequently, this function may never need to
*   be called but it may be called at anytime after the CPB is out of reset to 
*   check for an outstanding block leak.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   util_global_switch_data_t - If there is still a block leak at the end of this function, it
*   returns a pointer to the channel which contains the FIFO with
*   the leaked block. Otherwise returns NULL.
*
* NOTES:
*
*******************************************************************************/
PUBLIC util_global_switch_data_t* digi_cpb_remap_clean(digi_handle_t * digi_handle)
{
    BOOL block_leak;
    UINT32 i;
    UINT32 cpb_master_port;
    UINT32 cpb_master_channel;
#ifdef PMC_TESTS 
    PMC_ATOMIC_ENTRY_VOID(digi_handle);
#else 
    PMC_ATOMIC_ENTRY(digi_handle);
#endif
        
    block_leak = cpb_remap_clean(digi_handle->dcpb_handle,
                                 &cpb_master_port,
                                 &cpb_master_channel);

    if(block_leak == FALSE)
        PMC_ATOMIC_RETURN(digi_handle, NULL);

    /* There is still a block leak, find the channel handle */
    switch (cpb_master_port)
    {
    case 0:
        for(i=0;i<DIGI_SIFD_ILKN_ARB_DPI_CHANS_MAX;i++)
        {
            if(digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.cpb_data.op_state.map_state.is_output_mapped == TRUE &&
               digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ILKN1 &&
               digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.cpb_data.channel == cpb_master_channel)
            {
                PMC_ATOMIC_RETURN(digi_handle, (util_global_switch_data_t *) &digi_handle->handle_pool.ilkn_1_chnl[i]); 

            }
        }

        break;

    case 1:
        for(i=0;i<DIGI_SIFD_ILKN_ARB_DPI_CHANS_MAX;i++)
        {
            if(digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.cpb_data.op_state.map_state.is_output_mapped == TRUE &&
               digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ILKN2 &&
               digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.cpb_data.channel == cpb_master_channel)
            {
                PMC_ATOMIC_RETURN(digi_handle, (util_global_switch_data_t *) &digi_handle->handle_pool.ilkn_2_chnl[i]); 

            }
        }

        break;
    case 2:
        for(i=0;i<DIGI_CBRC_CHNL_MAX;i++)
        {
            if(digi_handle->handle_pool.cbr_chnl[i].switch_data.cpb_data.op_state.map_state.is_output_mapped == TRUE &&
               digi_handle->handle_pool.cbr_chnl[i].switch_data.cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_CBRC &&
               digi_handle->handle_pool.cbr_chnl[i].switch_data.cpb_data.channel == cpb_master_channel)
            {
                PMC_ATOMIC_RETURN(digi_handle, (util_global_switch_data_t *) &digi_handle->handle_pool.cbr_chnl[i]); 

            }
        }

        break;
    case 3:
        for(i=0;i<DIGI_MAPOTN_CHNL_MAX;i++)
        {
            if(digi_handle->handle_pool.mapper_chnl[i].switch_data.cpb_data.op_state.map_state.is_output_mapped == TRUE &&
               digi_handle->handle_pool.mapper_chnl[i].switch_data.cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_MAPOTN &&
               digi_handle->handle_pool.mapper_chnl[i].switch_data.cpb_data.channel == cpb_master_channel)
            {
                PMC_ATOMIC_RETURN(digi_handle, (util_global_switch_data_t *) &digi_handle->handle_pool.mapper_chnl[i]); 

            }
        }

        break;
    case 4:
        for(i=0;i<DIGI_ENET_LINE_CHNL_MAX;i++)
        {
            if(digi_handle->handle_pool.enet_line_chnl[i].switch_data.cpb_data.op_state.map_state.is_output_mapped == TRUE &&
               digi_handle->handle_pool.enet_line_chnl[i].switch_data.cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE &&
               digi_handle->handle_pool.enet_line_chnl[i].switch_data.cpb_data.channel == cpb_master_channel)
            {
                PMC_ATOMIC_RETURN(digi_handle, (util_global_switch_data_t *) &digi_handle->handle_pool.enet_line_chnl[i]); 

            }
        }

        break;
    case 5:
        for(i=0;i<DIGI_ENET_SYS_CHNL_MAX;i++)
        {
            if(digi_handle->handle_pool.enet_sys_chnl[i].switch_data.cpb_data.op_state.map_state.is_output_mapped == TRUE &&
               digi_handle->handle_pool.enet_sys_chnl[i].switch_data.cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ENET_SYS &&
               digi_handle->handle_pool.enet_sys_chnl[i].switch_data.cpb_data.channel == cpb_master_channel)
            {
                PMC_ATOMIC_RETURN(digi_handle, (util_global_switch_data_t *) &digi_handle->handle_pool.enet_sys_chnl[i]); 

            }
        }

        break;

    default:
        break;

    }

    PMC_ATOMIC_RETURN(digi_handle, NULL);
}

/*******************************************************************************
*  digi_oduksw_remap_clean
* ______________________________________________________________________________
*
* DESCRIPTION:
*   If there is a block leak in the ODUkSW this function attempts to clean it. If 
*   there is no block leak or it was cleaned, a NULL value is returned. If a 
*   block leak still persists, the channel handle with the associated block leak 
*   is returned. If this function is unable to clean a block leak, the block 
*   leak can be cleaned by first calling digi_oduksw_chnl_deactivate() which puts 
*   the FIFO pointers in reset, and then by calling this function again.
*
*   If there is a block leak, a clean up will automatically be attempted whenever
*   digi_oduksw_chnl_map() is called. Consequently, this function may never need to
*   be called but it may be called at anytime after the ODUkSW is out of reset to 
*   check for an outstanding block leak.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   util_global_switch_data_t - If there is still a block leak at the end of this function, it
*   returns a pointer to the channel which contains the FIFO with
*   the leaked block. Otherwise returns NULL.
*
* NOTES:
*
*******************************************************************************/
PUBLIC util_global_switch_data_t* digi_oduksw_remap_clean(digi_handle_t * digi_handle)
{
    BOOL block_leak;
    UINT32 i;
    UINT32 cpb_master_port;
    UINT32 cpb_master_channel;
    cpb_handle_t * ocpb_handle;
#ifdef PMC_TESTS 
    PMC_ATOMIC_ENTRY_VOID(digi_handle);
#else 
    PMC_ATOMIC_ENTRY(digi_handle);
#endif

    ocpb_handle = coreotn_oduksw_handle_get(digi_handle->coreotn_handle);
    
    block_leak = cpb_remap_clean(ocpb_handle,
                                 &cpb_master_port,
                                 &cpb_master_channel);

    if(block_leak == FALSE)
        PMC_ATOMIC_RETURN(digi_handle, NULL);

    /* There is still a block leak, find the channel handle */
    switch (cpb_master_port)
    {
    case 0:
        for(i=0;i<DIGI_SIFD_ILKN_ARB_DPI_CHANS_MAX;i++)
        {
            if(digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.oduk_data.op_state.map_state.is_output_mapped == TRUE &&
               digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1 &&
               digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.oduk_data.channel == cpb_master_channel)
            {
                PMC_ATOMIC_RETURN(digi_handle, (util_global_switch_data_t *) &digi_handle->handle_pool.ilkn_1_chnl[i]); 

            }
        }

        break;

    case 1:
        for(i=0;i<DIGI_SIFD_ILKN_ARB_DPI_CHANS_MAX;i++)
        {
            if(digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.oduk_data.op_state.map_state.is_output_mapped == TRUE &&
               digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_ILKN2 &&
               digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.oduk_data.channel == cpb_master_channel)
            {
                PMC_ATOMIC_RETURN(digi_handle, (util_global_switch_data_t *) &digi_handle->handle_pool.ilkn_2_chnl[i]); 

            }
        }

        break;
    case 2:
        for(i=0;i<DIGI_OTN_SERVER_LO_CHNL_MAX;i++)
        {
            if(digi_handle->handle_pool.lo_odu_struct[i].switch_data.oduk_data.op_state.map_state.is_output_mapped == TRUE &&
               digi_handle->handle_pool.lo_odu_struct[i].switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_COREOTN &&
               digi_handle->handle_pool.lo_odu_struct[i].switch_data.oduk_data.channel == cpb_master_channel)
            {
                PMC_ATOMIC_RETURN(digi_handle, (util_global_switch_data_t *) &digi_handle->handle_pool.lo_odu_struct[i]); 

            }
        }

        break;
    case 3:
        for(i=0;i<DIGI_MAPOTN_CHNL_MAX;i++)
        {
            if(digi_handle->handle_pool.mapper_chnl[i].switch_data.oduk_data.op_state.map_state.is_output_mapped == TRUE &&
               digi_handle->handle_pool.mapper_chnl[i].switch_data.oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_MAPOTN &&
               digi_handle->handle_pool.mapper_chnl[i].switch_data.oduk_data.channel == cpb_master_channel)
            {
                PMC_ATOMIC_RETURN(digi_handle, (util_global_switch_data_t *) &digi_handle->handle_pool.mapper_chnl[i]); 

            }
        }

        break;
       
    default:
        break;

    }

    PMC_ATOMIC_RETURN(digi_handle, NULL);
}

/*******************************************************************************
*  digi_oif_pkt_period_calc
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to calculate the B, T, Tfrac values as per
*   OIF recommendations.\n\n
*
*   The OIF spreadsheet oif2011.115.02 does not used ITU defined ODU rates.
*   The Gbps values are rounded to 6 or 7 decimal places for ODU1, ODU2, ODU2E, 
*   ODU2F, ODU3, ODU3E1, ODU3E2 and ODU4 rates.  To use these rounded inputs 
*   compile code defining the flag DIGI_OIF_SPREADSHEET_INPUTS.\n\n

*
* INPUTS:
*   *digi_handle      - handle to the COREOTN instance to be operated on
*   rate_data         - ODU bit rate (in bps). See enum digi_oduksw_stream_t.
*   num_odu0          - number of ODU0's if 'rate_date' is set to 
*                       DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX.
*   client_bitrate    - client bitrate in bps if oduksw stream 'rate_data' is  
*                       set to DIGI_ODUKSW_STREAM_CBR_ODUFLEX.
*   pkt_size          - desired packet fabric class as defined in the 
*                       OIF OTN Over Packet Fabric Protocol (OFP) implementation
*                       Agreement (IA) recommendation.
*                       Valid values are:
*                       -- 128B
*                       -- 256B
*                       -- 512B
*   header_size       - size of header appended to the packet. This value is
*                       subtracted from the 'pkt_size' to get the payload bytes
*                       of Bnom +/- 1byte as per OIF IA.
*                       This includes 4 bytes of OFP (OTN over Packet Fabric) 
*                       header and the optional 0-6 bytes of "user overhead
*                       and fabric overhead" supported by the device.
*                       An example of user overhead and fabric overhead field is 
*                       the Interlaken header format as described in the 
*                       enumerated type 'digi_sifd_oduksw_ilkn_header_t'.
*                       As an example, when DIGI_SIFD_ODUKSW_ILKN_HEADER_2B is 
*                       used as the header format between the Interlaken 
*                       interface and the COREOTN ODUKSW, 
*                       'header_size' should be set to 6(2B + 4B OFP).                      
*                       Valid range: 4 - 16 bytes*
*                       
*                       Note, DIGI only supports insertion of up to 6 bytes.
*                       Fabrics external to DIGI may require additional header bytes.
*                       A maximum of 16 bytes is allowed as defined by OIF (4 bytes
*                       for OFP + 12 user defined bytes)
*
* OUTPUTS:
*   *pkt_size_ptr     - configured packet size
*   *pkt_per_int_ptr  - configured integer portion of packet period
*   *pkt_per_n_ptr    - configured numerator of packet period fraction
*   *pkt_per_d_ptr    - configured denominator of packet period fraction
*   *eps_ptr          - Epsilon
*
* RETURNS: 
*   PMC_SUCCESS - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_oif_pkt_period_calc(digi_handle_t *digi_handle,
                                          digi_oduksw_stream_t rate_data,
                                          UINT32 num_odu0,
                                          DOUBLE client_bitrate,
                                          UINT32 pkt_size,
                                          UINT32 header_size,
                                          UINT32 *pkt_size_ptr,
                                          UINT32 *pkt_per_int_ptr,
                                          UINT32 *pkt_per_n_ptr,
                                          UINT32 *pkt_per_d_ptr,
                                          DOUBLE *eps_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    util_global_odukp_type_t odu_type = UTIL_GLOBAL_LAST_ODUK;
    DOUBLE client_rate;
    DOUBLE ppm;
    BOOL8 use_float32_mode = digi_use_float32_get();

    PMC_ATOMIC_ENTRY(digi_handle);

    result = digi_oduksw_rate_get(rate_data, &odu_type);

    if (PMC_SUCCESS == result)
    {
        if (odu_type == UTIL_GLOBAL_ODUFLEX_GFP)
        {
            /*client_rate = num_odu0 * UTIL_GLOBAL_ODU0_RATE; */
            
            if (num_odu0 <= 8)
            {
                if (!use_float32_mode) {
                    client_rate = (num_odu0 * UTIL_GLOBAL_ODU2_TS_RATE);
                } else {
                    client_rate = (DOUBLE)(num_odu0 * (FLOAT)UTIL_GLOBAL_ODU2_TS_RATE);
                }
            } else if(num_odu0 <= 32) {
                if (!use_float32_mode) {
                    client_rate = (num_odu0 * UTIL_GLOBAL_ODU3_TS_RATE);
                } else {
                    client_rate = (DOUBLE)(num_odu0 * (FLOAT)UTIL_GLOBAL_ODU3_TS_RATE);
                }
            } else {
                if (!use_float32_mode) {
                    client_rate = (num_odu0 * UTIL_GLOBAL_ODU4_TS_RATE);
                } else {
                    client_rate = (DOUBLE)(num_odu0 * (FLOAT)UTIL_GLOBAL_ODU4_TS_RATE);
                }
            }
        }
        else if (odu_type == UTIL_GLOBAL_ODUFLEX_CBR)
        {
            client_rate = client_bitrate;
        }
        else 
        {
            result = util_global_client_rate_get((UINT32)odu_type,
                                                 &client_rate,
                                                 &ppm);
        }
    }


    if (PMC_SUCCESS == result)
    {
        result = coreotn_oif_pkt_period_calc(digi_handle->coreotn_handle,
                                             client_rate,
                                             pkt_size,
                                             header_size,
                                             pkt_size_ptr,
                                             pkt_per_int_ptr,
                                             pkt_per_n_ptr,
                                             pkt_per_d_ptr,
                                             eps_ptr);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_oif_pkt_period_calc */




/*******************************************************************************
* digi_min_eps_pkt_period_calc
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to calculate the B, T, Tfrac values.
*
* INPUTS:
*   *digi_handle      - handle to the COREOTN instance to be operated on
*   rate_data         - See enum digi_oduksw_stream_t.
*   num_odu0          - number of ODU0's if 'rate_date' is set to
*                       DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX.
*   client_bitrate    - client bitrate in bps if oduksw stream 'rate_data' is
*                       set to DIGI_ODUKSW_STREAM_CBR_ODUFLEX.
*
* OUTPUTS:
*   *pkt_size     - configured packet size
*   *pkt_per_int  - configured integer portion of packet period
*   *pkt_per_n    - configured numerator of packet period fraction
*   *pkt_per_d    - configured denominator of packet period fraction
*   *epsilon          - Epsilon
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_min_eps_pkt_period_calc(digi_handle_t *digi_handle,
                                              digi_oduksw_stream_t rate_data,
                                              UINT32 num_odu0,
                                              DOUBLE client_bitrate,
                                              UINT32 *pkt_size,
                                              UINT32 *pkt_per_int,
                                              UINT32 *pkt_per_n,
                                              UINT32 *pkt_per_d,
                                              DOUBLE *epsilon)
{
    PMC_ERROR result = PMC_SUCCESS;
    util_global_odukp_type_t odu_type = UTIL_GLOBAL_LAST_ODUK;
    DOUBLE client_rate;
    DOUBLE ppm;

    PMC_ATOMIC_ENTRY(digi_handle);

    result = digi_oduksw_rate_get(rate_data, &odu_type);

    if (PMC_SUCCESS == result)
    {
        if (odu_type == UTIL_GLOBAL_ODUFLEX_GFP)
        {

            if (num_odu0 <= 8)
            {
                client_rate = (num_odu0 * UTIL_GLOBAL_ODU2_TS_RATE); /* bps */
            } else if(num_odu0 <= 32) {
                client_rate = (num_odu0 * UTIL_GLOBAL_ODU3_TS_RATE); /* bps */
            } else {
                client_rate = (num_odu0 * UTIL_GLOBAL_ODU4_TS_RATE); /* bps */
            }
        }
        else if (odu_type == UTIL_GLOBAL_ODUFLEX_CBR)
        {
            client_rate = client_bitrate; /* bps */
        }
        else
        {
            result = util_global_client_rate_get((UINT32)odu_type,
                                                 &client_rate, /* kbps */
                                                 &ppm);
        }
    }


    if (PMC_SUCCESS == result)
    {
        result = coreotn_min_eps_pkt_period_calc(digi_handle->coreotn_handle,
                                                 client_rate,
                                                 pkt_per_int,
                                                 pkt_per_n,
                                                 pkt_per_d,
                                                 pkt_size,
                                                 epsilon);
    }

    PMC_ATOMIC_RETURN(digi_handle, result);

} /* digi_min_eps_pkt_period_calc */



/*******************************************************************************
*  digi_generic_mpma_pkt_period_calc
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to calculate packet period parameters such as 
*   B, T, Tfrac values.
*
*   Only UTIL_OPSA_INT_PKT_PER or UTIL_OPSA_EPS_MIN are suported as calculating 
*   method. To calculate packet period as per OIF recommendations, 
*   use API digi_oif_pkt_period_calc().
*
* INPUTS:
*   *digi_handle      - handle to the COREOTN instance to be operated on
*   rate_data         - ODU bit rate (in bps). See enum digi_oduksw_stream_t.
*   num_odu0          - number of ODU0's if 'rate_date' is set to 
*                       DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX.
*   client_bitrate    - client bitrate in bps if oduksw stream 'rate_data' is  
*                       set to DIGI_ODUKSW_STREAM_CBR_ODUFLEX.
*   min_pkt_size      - minimum packet size.
*   max_pkt_size      - maximum packet size.
*   pkt_period_calc   - method for calculating packet period and size:
*                       UTIL_OPSA_INT_PKT_PER or UTIL_OPSA_EPS_MIN.
*
* OUTPUTS:
*   *pkt_size_ptr     - configured packet size
*   *pkt_per_int_ptr  - configured integer portion of packet period
*   *pkt_per_n_ptr    - configured numerator of packet period fraction
*   *pkt_per_d_ptr    - configured denominator of packet period fraction
*   *eps_ptr          - Epsilon
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_generic_mpma_pkt_period_calc(digi_handle_t              *digi_handle,
                                                   digi_oduksw_stream_t        rate_data,
                                                   UINT32                      num_odu0,
                                                   DOUBLE                      client_bitrate,
                                                   UINT32                      min_pkt_size,
                                                   UINT32                      max_pkt_size,
                                                   util_opsa_pkt_period_calc_t pkt_period_calc,
                                                   UINT32                     *pkt_size_ptr,
                                                   UINT32                     *pkt_per_int_ptr,
                                                   UINT32                     *pkt_per_n_ptr,
                                                   UINT32                     *pkt_per_d_ptr,
                                                   DOUBLE                     *eps_ptr)
{


    PMC_ERROR result = PMC_SUCCESS;
    util_global_odukp_type_t odu_type = UTIL_GLOBAL_LAST_ODUK;
    DOUBLE client_rate;
    DOUBLE ppm;
    UINT32 pkt_size_range = 0;

    PMC_ATOMIC_ENTRY(digi_handle);

    switch (pkt_period_calc)
    {
        /* passthrough */
    case UTIL_OPSA_EPS_MIN:
    case UTIL_OPSA_INT_PKT_PER:
        /* passthrough */
        break;
    default:
        result = DIGI_ERR_INVALID_ARG;
        break;
    }


    if (PMC_SUCCESS == result)
    {
        result = digi_oduksw_rate_get(rate_data, &odu_type);
    }

    if (PMC_SUCCESS == result)
    {
        if (odu_type == UTIL_GLOBAL_ODUFLEX_GFP)
        {
            
            if (num_odu0 <= 8)
            {
                client_rate = (num_odu0 * UTIL_GLOBAL_ODU2_TS_RATE);
            } else if(num_odu0 <= 32) {
                client_rate = (num_odu0 * UTIL_GLOBAL_ODU3_TS_RATE);
            } else {
                client_rate = (num_odu0 * UTIL_GLOBAL_ODU4_TS_RATE);
            }
        }
        else if (odu_type == UTIL_GLOBAL_ODUFLEX_CBR)
        {
            client_rate = client_bitrate;
        }
        else 
        {
            result = util_global_client_rate_get((UINT32)odu_type,
                                                 &client_rate,
                                                 &ppm);
        }
    }

    pkt_size_range = max_pkt_size - min_pkt_size;

    if (PMC_SUCCESS == result)
    {
        result = mpma_pkt_period_calc((mpma_handle_t *)NULL, 
                                      client_rate, 
                                      min_pkt_size,
                                      pkt_size_range, 
                                      UTIL_OPSA_T_FRAME_UNUSED, /* cn_frame_period */
                                      pkt_period_calc, /* pkt_period_calc method to use */
                                      pkt_size_ptr,
                                      pkt_per_int_ptr,
                                      pkt_per_n_ptr, 
                                      pkt_per_d_ptr,
                                      eps_ptr);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);

}/*digi_generic_mpma_pkt_period_calc*/



/*******************************************************************************
* digi_cpb_chnl_map
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies configuration to CPB subsystem.  It performs channel
*   mapping and setup configuration, and it allocates resources required when
*   channel is later enabled.  Prior to any device modification it evaluates
*   configuration request to ensure that when channel later activated that
*   resources are allocated to the channel and the addition will not impact other
*   operational channels.  For SIFD interface related channels allocates flow
*   control calendar entries for the channel and provides BCW to CPB DPI channel
*   mapping.\n\n
*
*   CPB device level and interface level configurations are performed as
*   a function of the set of channels assigned to the device.  When no channels
*   are provisioned in the device, the CPB will be in low power standby state.\n\n
*
*   The decision for system SerDes CBRC and ENET_SYS clients to pass through
*   Ingress Mux Output Port 0 or 1 is performed by the SW driver.  If no SIFD
*   channel assigned, the client will be mapped to Output Port 0, if SIFD
*   channel assigned to Output Port 0, client will be assigned to Output Port
*   1.  If both SIFD1/2 channels provisioned, the client request will be
*   rejected.
*
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *input_pc_ptr    - util_global_switch_data_t pointer defining inbound port
*   *output_pc_ptr   - util_global_switch_data_t pointer defining outbound port
*   rate_data        - enum, client stream types of signal passing through CPB.
*                    For DIGI_CPB_STREAM_PKT_GFPF_ODUFLEX, client_num_odu0 must
*                    be provided
*   client_num_odu0  - For DIGI_CPB_STREAM_PKT_GFPF_ODUFLEX, number of ODU0 container
*                    associated with ODUFLEX signal.
*   halt_buffer      - CPB FIFO buffer room to capture in flight data in
*                    the event that CPB FIFO generates an upstream flow
*                    control signal.  Used in cases where ENET utilizes
*                    pause flow control and where a channel is fed from
*                    SIFD and asserts XOFF flow control.  halt_buffer is
*                    specified in units of blocks.  The block size in bytes per unit is:
*                    12288 bytes
*                    Applicable to client_data containing "DIGI_CPB_STREAM_PKT_"
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_chnl_map(digi_handle_t *digi_handle,
                                   util_global_switch_data_t *input_pc_ptr,
                                   util_global_switch_data_t *output_pc_ptr,
                                   digi_cpb_stream_t rate_data,
                                   UINT32 client_num_odu0,
                                   UINT32 halt_buffer)
{

    PMC_ERROR result = DIGI_ERR_UNKNOWN;
    digi_mapper_chnl_def_t* mapper_chnl_ptr = NULL;
    digi_ilkn_chnl_def_t* ilkn_chnl_ptr = NULL;
    digi_enet_client_chnl_def_t* enet_chnl_ptr = NULL;
    enet_datapath_t enet_mode = LAST_ENET_DATAPATH;
    digi_enet_mode_t digi_enet_mode = LAST_DIGI_ENET;
    digi_enet_enhanced_pmon_req_t pmon_req_type = DIGI_ENHANCED_ENET_PMON_REQ_AND_NOT_REALIZABLE;
    BOOL enet_mirror_mode = FALSE;
 
    PMC_ATOMIC_ENTRY(digi_handle);

    /* Check that given handles belong to digi handle */
    result = digi_cpb_chnl_validate(digi_handle, input_pc_ptr);

    if (result == PMC_SUCCESS)
    {
        result = digi_cpb_chnl_validate(digi_handle, output_pc_ptr);
    }
    if (PMC_SUCCESS != result)
    {
        PMC_ATOMIC_RETURN(digi_handle, result);
    }

    enet_mirror_mode = digi_cpb_enet_mirror_chk(digi_handle, output_pc_ptr);
    
    if (!enet_mirror_mode)
    {
        /* Note: Helper function below does parameter checking */
        result = digi_enet_is_enhanced_pmon_required(digi_handle,
                                                     input_pc_ptr, 
                                                     output_pc_ptr,
                                                     &mapper_chnl_ptr,
                                                     &ilkn_chnl_ptr,
                                                     &enet_chnl_ptr,
                                                     &enet_mode, 
                                                     &digi_enet_mode,
                                                     &pmon_req_type);
    }
    if (result == PMC_SUCCESS) {
 

        /* Do primary mapping first. */
        result = digi_cpb_internal_chnl_map(digi_handle,
                                            input_pc_ptr,
                                            output_pc_ptr,
                                            rate_data,
                                            client_num_odu0,
                                            halt_buffer);

        if ((result == PMC_SUCCESS) && 
            (pmon_req_type != DIGI_ENHANCED_PMON_NO_PMON_REQ) && !enet_mirror_mode) {

            /* Since we've done all our resource checking up front, this
               should never fail. If the above call was successful, but we don't
               need PMON, then there is nothing to be done. */
            result = digi_enet_enhanced_pmon_map(digi_handle, 
                                                 input_pc_ptr, 
                                                 output_pc_ptr,
                                                 rate_data,
                                                 client_num_odu0,
                                                 halt_buffer,
                                                 pmon_req_type,
                                                 mapper_chnl_ptr,
                                                 ilkn_chnl_ptr,
                                                 enet_chnl_ptr,
                                                 enet_mode, 
                                                 digi_enet_mode);
        }
    }
 
    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_cpb_chnl_map */

/*******************************************************************************
* digi_cpb_chnl_activate
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function provides graceful data path enabling of a client stream
*   passing through CPB subsystem in a single direction.  It performs data path
*   element reset and data flow enabling operations on all subsystems related to
*   the datapath.\n\n
*
*   The function takes in the output port and output channel to identify the
*   channel.  This allows for CPB broadcast and multicast implementations
*   to be supported with this interface.
*
*
*
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *output_pc_ptr   - a pointer to the destination DPI port / chanel pair
*                      for the channel to be activated.
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_chnl_activate(digi_handle_t *digi_handle,
                                        util_global_switch_data_t *output_pc_ptr)
{
    PMC_ERROR result = DIGI_ERR_UNKNOWN;
    BOOL enet_mirror_mode = FALSE;
    PMC_ATOMIC_ENTRY(digi_handle);

    /* Check that given handles belong to digi handle */
    result = digi_cpb_chnl_validate(digi_handle, output_pc_ptr);

    if (PMC_SUCCESS == result)
    {        
        result = digi_cpb_internal_chnl_activate(digi_handle, output_pc_ptr);
    }

    if (result == PMC_SUCCESS) 
    {
        /* 
         *  Check if the output is an enet line mirror port. If it is, don't try to 
         *  activate an enh pmon. The enh pmon (if needed) is activated when 
         *  dig_cpb_chn activate is called for the primary enet line channel. 
         */
        enet_mirror_mode = digi_cpb_enet_mirror_chk(digi_handle, output_pc_ptr);

        if (!enet_mirror_mode)
        {
            /* The following function does argument checking and 
             * always succeeeds even if PMON is not required.
             * This would only fail if for some reason PMON is required and 
             * the actual PMON datapath activation fails. */
            /* We need to look up the input_chnl based on this output chnl. */
            util_global_switch_data_t* input_pc_ptr;
            input_pc_ptr = digi_cpb_input_port_get(digi_handle, output_pc_ptr);
            PMC_ASSERT(NULL != input_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

            result = digi_enet_enhanced_pmon_activate(digi_handle, input_pc_ptr);
        }
    }
 
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_cpb_chnl_activate */

/*******************************************************************************
* digi_warm_restart_context_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function returns the backup_ram_pptr which points to a block of data
*   of length returned in size_ptr which can be used to restart the AppLib
*   and connect to a running device. This function also signals firmware to
*   suppress all further operations that signal the host software.
*
*   When this data has been connected it is required that no further
*   configuration operations to the device are performed or it may not be
*   possible to restart. See Programmers Manual for further details.
*
* INPUTS:
*   *digi_handle   - pointer to DIGI handle instance
*
* OUTPUTS:
*   *size_ptr - length of the **backup_ram_pptr buffer in bytes
*   **backup_ram_pptr - allocated memory containing the context information and
*                       check information to be used for warm restart of the
*                       device.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_warm_restart_context_get(digi_handle_t *digi_handle,
                                               UINT32 *size_ptr,
                                               void **backup_ram_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    /*
     * The context is saved in pmc_mem_ctxt_save. If using 
     * PMC_ATOTMIC_ENTRY then the recursive level will be saved with a 
     * value of 1. Want the level to be saved with a value of 0 assuming 
     * that this function is called correctly so that when it is restored
     * the recursive level can be use to verify that the system did not 
     * reset in the middle of an operation.  This effects WARM Restart 
     * test cases.
     */
    PMC_ENTRY();

    if (NULL == backup_ram_pptr || NULL == size_ptr)
    {
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
    }
    *size_ptr = sizeof(pmc_ctxt_mgmt_ctxt_t);
    *backup_ram_pptr = (void *)digi_handle->base.ctxt;
    result = pmc_mem_ctxt_save(*backup_ram_pptr, *size_ptr, 
                               ((pmc_handle_t *)digi_handle)->sys_handle);

    PMC_RETURN(result);
}


/*******************************************************************************
* digi_oduksw_chnl_activate
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function provides graceful data path enabling of a client stream
*   passing through ODUK Switch block, packet maker and packet monitor blocks.
*   It performs data path element reset and data flow enabling operations on all
*   subsystems related to the datapath.\n\n
*
*   The function takes in the output port to identify the channel.  This allows
*   for ODUK Switch broadcast and multicast implementations to be supported with
*   this interface.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   *output_pc_ptr      - Destination DPI port / channel pair for the channel
*                         mapping to be performed.
*                         Accepts the pointer to one of the following channel
*                         handle types: \n\n
*                           digi_odu_struct_t \n
*                           digi_ilkn_chnl_t \n
*                           digi_mapper_chnl_t \n
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_oduksw_chnl_activate(digi_handle_t *digi_handle,
                                           util_global_switch_data_t *output_pc_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    coreotn_handle_t *coreotn_handle = NULL;
    BOOL is_broadcast = FALSE;
    BOOL is_multicast = FALSE;

    BOOL is_reader_primary = FALSE;
    BOOL is_slave_zone_primary = FALSE;                           

    util_global_switch_data_def_t *local_output_sw_ptr = (util_global_switch_data_def_t *)output_pc_ptr;
    util_global_oduk_port_data_t *local_output_pc_ptr = &(local_output_sw_ptr->oduk_data);
    util_global_switch_data_def_t *local_input_sw_ptr = NULL;
    util_global_cpb_port_data_t *local_input_cpb_pc_ptr;
    util_global_oduk_port_data_t local_input_pc;
    util_global_switch_data_t *input_pc_ptr;
    util_global_switch_data_def_t *enet_input_pc_ptr;
    UINT32 mapotn_ingress_mux_input_port = LAST_UTIL_GLOBAL_CPB_PORT;
    UINT32 mapotn_ingress_mux_input_port_chnl;
    BOOL8 mapotn_is_multicast = FALSE;
    BOOL8 mapotn_is_broadcast = FALSE;
    BOOL8 mapotn_is_reader_primary = FALSE;
    BOOL8 mapotn_is_slave_zone_primary = FALSE; 
    
    BOOL8 is_output_ho_unchnl = FALSE;
    BOOL8 is_sysotn_card = FALSE;
    BOOL8 is_input_ilkn_1_and_sysotn_card = FALSE;
    BOOL8 is_output_ilkn_1 = FALSE;

    digi_otn_server_chnl_def_t *otn_server_ptr;
    lineotn_frame_rate_t dsi_rate;
    lineotn_handle_t* otn_handle;
    coreotn_odu_chnl_prov_mode_t prov_mode; 

    util_global_mapping_mode_t mapotn_mapping_mode = UTIL_GLOBAL_NO_MAP;
    mapotn_src_dest_t mapotn_src = LAST_MAPOTN_DEST;
    mapotn_src_dest_t mapotn_dest = LAST_MAPOTN_DEST;
    util_global_map_adapt_func_t adapt_mode = UTIL_GLOBAL_MAP_NO_RATE;
    util_global_map_adapt_func_t dummy_adapt_mode = UTIL_GLOBAL_MAP_NO_RATE;

    BOOL8 mpmo_cfg_req;
    sifd_ilkn_inst_t sifd_ilkn_inst;
    BOOL8 activate_mpmo = FALSE;
    BOOL8 is_chnl_otu4_odu4;
    digi_serdes_cfg_action_t serdes_cfg_action;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* Check arguments */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != output_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* Check that given handle belongs to digi handle */
    result = digi_oduksw_chnl_validate(digi_handle, output_pc_ptr);

    if (PMC_SUCCESS != result)
    {
        PMC_ATOMIC_RETURN(digi_handle, result);
    }

    if (local_output_pc_ptr->op_state.map_state.is_output_mapped == FALSE) {

        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_ODUKSW_NOT_MAPPED);

    } else if (local_output_pc_ptr->op_state.active_state == UTIL_GLOBAL_CHNL_ACTIVE_STATE_ACTIVE) {

        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_ODUKSW_ALREADY_ACTIVE);
    }
    

    /* retrieve coreotn handle */
    coreotn_handle = digi_handle->coreotn_handle;

    /* retrieve otn handle */
    if(local_output_pc_ptr->lineotn_src) {

        otn_handle = digi_handle->lineotn_handle;

    } else {

        otn_handle = digi_handle->sysotn_handle;
    }

    if (PMC_SUCCESS == result)
    {
        result = coreotn_oduksw_chnl_source_and_type_test(coreotn_handle,
                                                          local_output_pc_ptr->port_type,
                                                          local_output_pc_ptr->channel,
                                                          (UINT32*)&(local_input_pc.port_type),
                                                          &(local_input_pc.channel),
                                                          &is_broadcast,
                                                          &is_multicast);
                                                          
        if (PMC_SUCCESS == result)
        { 
            result = coreotn_oduksw_chnl_type_get(coreotn_handle,
                                                  local_output_pc_ptr->port_type,
                                                  local_output_pc_ptr->channel,         
                                                  &is_reader_primary,
                                                  &is_slave_zone_primary,
                                                  &is_broadcast,
                                                  &is_multicast);
        }                                                          

        /* Check if Datapath passes through ENET SS, and set serdes Maximum PPM in consequence */
        if (PMC_SUCCESS == result)
        {
            /* if it's a OTN -> ENET datapath, set ENET serdes maximum PPM such as =
               150% of (ENET MAX_ PPM + OTN MAX PPM) */
            if (UTIL_GLOBAL_ODUK_PORT_MAPOTN == local_output_pc_ptr->port_type)
            {
                /* retrieve MAPOTN channel pointer */                
                result = cpb_chnl_source_type_and_primary_test(digi_handle->dcpb_handle,
                                                               local_output_pc_ptr->port_type,
                                                               local_output_pc_ptr->channel,
                                                               &mapotn_ingress_mux_input_port,
                                                               &mapotn_ingress_mux_input_port_chnl,
                                                               &mapotn_is_broadcast,
                                                               &mapotn_is_multicast,
                                                               &mapotn_is_reader_primary,
                                                               &mapotn_is_slave_zone_primary);


    
                if( result == PMC_SUCCESS )
                {
                    PMC_ASSERT(local_output_pc_ptr->channel < DIGI_SCHD_96_ENTRY, COREOTN_ERR_INVALID_ARG, 0 ,0);
                    enet_input_pc_ptr = (util_global_switch_data_def_t*)digi_cpb_input_port_get(digi_handle, &digi_handle->handle_pool.mapper_chnl[local_output_pc_ptr->channel]);
                
                    if (NULL != enet_input_pc_ptr && 
                        (UTIL_GLOBAL_CPB_PORT_ENET_LINE == enet_input_pc_ptr->cpb_data.port_type ||
                         UTIL_GLOBAL_CPB_PORT_ENET_SYS == enet_input_pc_ptr->cpb_data.port_type))
                    {
                        /* setup ENET Serdes PPM in consequence */
                        result = digi_non_otn_acb_ckctl_cfg(digi_handle, &digi_handle->handle_pool.mapper_chnl[local_output_pc_ptr->channel], enet_input_pc_ptr, DIGI_SERDES_ENET_OTN_MAX_PPM_SET, LAST_DIGI_ENET_TX_TIMING_MODE);
                        PMC_LOG_TRACE("enet dp found\n");
                    }
                }
                else
                {
                    result = PMC_SUCCESS;
                }
            }
        }
    }

    if (PMC_SUCCESS == result)
    {
        /* retrieve the values for the rest of our local variables */
        is_output_ho_unchnl = (local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_COREOTN  
                               && local_output_pc_ptr->odu_level == UTIL_GLOBAL_LEVEL_HO_ODU  
                               && digi_handle->var.odu_chnl_payload[local_output_pc_ptr->channel] == DIGI_ODU_UNCHANNELIZED);

        is_sysotn_card = (digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD);

        is_output_ilkn_1 = (local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1);
        
        is_input_ilkn_1_and_sysotn_card = ((local_input_pc.port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1) && 
                                           (is_sysotn_card == TRUE));
    }

    /* activate lineotn tx if LINEOTN HO Framer is unchannelized    *OR*
     * if chnl of type ILKN and we are in DIGI_PROD_APP_SYSOTN_CARD      */
    if (PMC_SUCCESS == result &&
        ((is_output_ho_unchnl == TRUE) || 
         (is_output_ilkn_1 == TRUE && is_sysotn_card == TRUE)))
    {


        if (local_output_pc_ptr->lineotn_src) 
        {
            otn_server_ptr = digi_otn_server_chnl_get(digi_handle, local_output_pc_ptr->channel);

        } 
        else {

            otn_server_ptr = digi_sysotn_server_chnl_get(digi_handle);
        }
                   
        /* // determine that current channel is a OTU4/ODU4 */
        is_chnl_otu4_odu4 = FALSE;
        if (PMC_SUCCESS == result && NULL != otn_server_ptr)
        {
            result = lineotn_dsi_rate_get(digi_handle->lineotn_handle,
                                          local_output_pc_ptr->channel,
                                          &dsi_rate);
           if (PMC_SUCCESS == result &&
               (is_output_ho_unchnl == TRUE) &&
               dsi_rate == LINE_OTN_RATE_OTU4)
           {            
               is_chnl_otu4_odu4 = TRUE;
           }
        }

        /* activate ACB */
        if (PMC_SUCCESS == result)
        {
            if (TRUE == pmc_is_digi_rev_a_revision(&digi_handle->base))
            {
                /*never activate the SYSTEM side ACB for transponder.  Only activate the LINE side ACB for MUXPONDER */
                if( digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
                {
                    if(local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1)
                    {
                        result = lineotn_dsi_rate_get(digi_handle->lineotn_handle,
                                                      0,
                                                      &dsi_rate);
                        if(dsi_rate != LINE_OTN_RATE_OTU4)
                        {
                            /* provision ACB (that can be moved into digi_oduksw_chnl_map) */
                            if (PMC_SUCCESS == result) 
                            {
                                result = digi_otn_acb_ckctl_cfg(digi_handle, otn_server_ptr,DIGI_SERDES_PROV);  
                            }
                            result = digi_otn_acb_ckctl_cfg(digi_handle, otn_server_ptr,DIGI_SERDES_ACTIVATE);
                        }
                    }
                }
                else
                {
                    /* provision ACB (that can be moved into digi_oduksw_chnl_map) */
                    if (PMC_SUCCESS == result) 
                    {
                        serdes_cfg_action = DIGI_SERDES_PROV;
                        result = digi_otn_acb_ckctl_cfg(digi_handle, otn_server_ptr, serdes_cfg_action); 
                    }
                    result = digi_otn_acb_ckctl_cfg(digi_handle, otn_server_ptr,DIGI_SERDES_ACTIVATE);
                }
            }
            else
            {
                /* provision ACB (that can be moved into digi_oduksw_chnl_map) */
                if (PMC_SUCCESS == result)
                {
                    serdes_cfg_action = DIGI_SERDES_PROV;
                    result = digi_otn_acb_ckctl_cfg(digi_handle, otn_server_ptr, serdes_cfg_action); 
                }
                result = digi_otn_acb_ckctl_cfg(digi_handle, otn_server_ptr,DIGI_SERDES_ACTIVATE);
            }
        }
    }
    
  
    if (PMC_SUCCESS == result)
    {
        result = coreotn_oduksw_chnl_activate(digi_handle->coreotn_handle,
                                              (coreotn_oduksw_input_port_type_t)local_input_pc.port_type,
                                              local_input_pc.channel,
                                              (coreotn_oduksw_output_port_type_t)local_output_pc_ptr->port_type,
                                              local_output_pc_ptr->channel);
    }

    
  
    /* if activating ODUKSW connection from MAPOTN, then activate MAPOTN MPMO 
    ** after COREOTN FO1 MPMO and COREOTN FO2 MPMA have been activated
    ** Check to see if this is the first channel if we are in broadcast or
    ** multicast scenario.
    */
    if (PMC_SUCCESS == result &&
        ( (is_broadcast == FALSE && is_multicast == FALSE) 
          || (is_broadcast == TRUE && is_slave_zone_primary == TRUE) 
          || (is_multicast == TRUE && is_reader_primary == TRUE) ) )
    {
        if (local_input_pc.port_type == UTIL_GLOBAL_ODUK_PORT_MAPOTN)
        { 
            /* determine if ENET_LINE data source and if so activate Tx ENET path */
            if (result == PMC_SUCCESS)
            {
                input_pc_ptr = digi_oduksw_input_port_get(digi_handle, 
                                                          local_input_pc.port_type,
                                                          local_input_pc.channel, 
                                                          DIGI_ILKN_CHNL_TARGET_CPB);
        
                local_input_sw_ptr = (util_global_switch_data_def_t*)input_pc_ptr;
                local_input_cpb_pc_ptr = &(local_input_sw_ptr->cpb_data);
            }
            if(result == PMC_SUCCESS)
            {
                result = mapotn_mapper_mpmo_cfg_get(digi_handle->mapotn_handle, local_input_pc.channel, &mpmo_cfg_req);
            }
    
            /* check if MAPOTN is carrying non GFP traffic */
            if (PMC_SUCCESS == result)
            {
                /* If MAPOTN Associated with etrans path for AMP/GMP then TGMP FIFO_CLRB must be set via FW proxy */
                digi_mapper_src_dest_get(digi_handle,
                                         digi_handle->handle_pool.mapper_chnl[local_input_pc.channel].mode,
                                         digi_handle->handle_pool.mapper_chnl[local_input_pc.channel].enet_pmon,
                                         &mapotn_src,
                                         &mapotn_dest);
                digi_mapotn_mode_params_convert(digi_handle->handle_pool.mapper_chnl[local_input_pc.channel].mode,
                                                &adapt_mode,
                                                &dummy_adapt_mode);
                result = mapotn_mapping_mode_get(digi_handle->mapotn_handle, 
                                                 adapt_mode,
                                                 &mapotn_mapping_mode);


                if(result == PMC_SUCCESS && mapotn_src == MAPOTN_DEST_CPB && mapotn_mapping_mode == UTIL_GLOBAL_GFP)
                {
                    result = mapotn_mapper_activate( digi_handle->mapotn_handle, local_input_pc.channel);
                }


                if(result == PMC_SUCCESS && mpmo_cfg_req == TRUE && mapotn_src == MAPOTN_DEST_CPB)
                {
                    /* activate MAPOTN MPMO */
                    result = mapotn_mpmo_ch_activate(digi_handle->mapotn_handle, local_input_pc.channel);
                }

            }
        }                                                                                  
    }
    


    /* retrieve the input channel pointer */
    if (result == PMC_SUCCESS)
    {
        input_pc_ptr = digi_oduksw_input_port_get(digi_handle, 
                                                  local_input_pc.port_type,
                                                  local_input_pc.channel, 
                                                  DIGI_ILKN_CHNL_TARGET_ODUK);

        local_input_sw_ptr = (util_global_switch_data_def_t*)input_pc_ptr;

        if(NULL == local_input_sw_ptr)
        {
            result = PMC_ERR_FAIL;
        }
    }
    
    /* Call FW methods to add MPMA/MPMO configuration as required by datapath */
    if(result == PMC_SUCCESS)
    {
        /* retreive coreotn provision mode */   
        result = coreotn_odu_chnl_prov_mode_get(coreotn_handle, &prov_mode);
        
        if (PMC_SUCCESS == result && (prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT))
        {
            /*only activate opsa segment if OCI is not provisioned in TX path*/
            if((is_output_ilkn_1 == TRUE && is_sysotn_card == TRUE) ||
               local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_COREOTN)
            {
                /* if there is an active nominal maintenance signal, do not
                activate the MPMO.  Do not activate the MPMO for ODUKSW BULK operation */
                if(digi_otn_nominal_tx_unchannelized_get(digi_handle, (odu_struct_t *)output_pc_ptr))
                {
                    activate_mpmo = FALSE;
                }
                else
                {
                    activate_mpmo = TRUE;
                }
            }
            else
            {
                activate_mpmo = TRUE;
            }
            

            digi_opsa_oduksw_activate_cfg(digi_handle,
                                          input_pc_ptr, 
                                          output_pc_ptr,
                                          is_reader_primary,
                                          is_slave_zone_primary,
                                          DIGI_OPSA_CFG_ACTION_ACTIVATE,
                                          activate_mpmo,
                                          FALSE);


        }                                          
    }                                                                  
                                            

    if (TRUE == pmc_coreotn_mux_empty_ho_order_revision(&digi_handle->base))
    {
        if (PMC_SUCCESS == result 
            && local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_COREOTN
            && local_output_pc_ptr->odu_level != UTIL_GLOBAL_LEVEL_HO_ODU)
        {
            result = coreotn_odtu_mux_empty_ho_unlock(digi_handle->coreotn_handle,
                                                      local_output_pc_ptr->odu_level,
                                                      local_output_pc_ptr->channel);       
        }
    }
    
    if (result == PMC_SUCCESS)
    {
        local_output_pc_ptr->op_state.active_state = UTIL_GLOBAL_CHNL_ACTIVE_STATE_ACTIVE;
        local_input_sw_ptr->oduk_data.op_state.map_state.dest_active_count++;
    }
 
    if(PMC_SUCCESS == result &&
       prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK) 
    {
        /* Update SIFD flow control calendar if needed */
        /* TX data */
        if((local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1 && (is_sysotn_card == FALSE)) ||
           local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN2)
        {
            sifd_ilkn_inst = local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1 ? SIFD_COPI_ILKN1 : SIFD_COPI_ILKN2;
            
            if (result == PMC_SUCCESS)
                result = digi_sifd_fc_calendar_update(digi_handle,
                                                      sifd_ilkn_inst,
                                                      (UINT32)local_output_pc_ptr->port_type,
                                                      TRUE, /* TRUE means TX data direction */
                                                      TRUE,/* TRUE means it's for ODUk switch, not CPB */
                                                      SIFD_ILKN_NULL_CAL_ENTRY); 
        }
        /* RX data */
        if ( (local_input_pc.port_type == 0 && (is_sysotn_card == FALSE)) || 
             local_input_pc.port_type == 1)
        {
            sifd_ilkn_inst = local_input_pc.port_type == 0 ? SIFD_COPI_ILKN1 : SIFD_COPI_ILKN2;
        
            if (result == PMC_SUCCESS)
                result = digi_sifd_fc_calendar_update(digi_handle,
                                                      sifd_ilkn_inst,
                                                      (UINT32)local_input_pc.port_type,
                                                      FALSE, /* FALSE means RX data direction */
                                                      TRUE,
                                                      SIFD_ILKN_NULL_CAL_ENTRY);
        }
    }

    if (PMC_SUCCESS == result && prov_mode != COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        /* set an indication that the port requires an update during bulk prov */
        coreotn_oduksw_port_bulk_update_req_set(digi_handle->coreotn_handle,
                                                local_output_pc_ptr->port_type,
                                                UTIL_GLOBAL_DATAPATH_DIR_EGRESS,
                                                TRUE);
        coreotn_oduksw_port_bulk_update_req_set(digi_handle->coreotn_handle,
                                                local_input_pc.port_type,
                                                UTIL_GLOBAL_DATAPATH_DIR_INGRESS,
                                                TRUE);
    }
    if (PMC_SUCCESS == result && prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
    {
        if((is_output_ilkn_1 == TRUE && is_sysotn_card == TRUE) ||
           local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_COREOTN)
        {
            if(digi_otn_remove_dummy_maintenance_signal_get(digi_handle, (odu_struct_t *)output_pc_ptr))
            {
                result = odu_struct_tx_maint_sig_dummy_rfrm_cfg(digi_handle->coreotn_handle,
                                                                ((odu_struct_t *)output_pc_ptr)->mem_ptr->odu_level,
                                                                ((odu_struct_t *)output_pc_ptr)->mem_ptr->chnl_id,
                                                                FALSE);
            }
        
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_oduksw_chnl_activate */
    
/*******************************************************************************
* digi_cpb_chnl_deactivate
* ______________________________________________________________________________
*   
* DESCRIPTION:
*   
*   This function gracefully disables the elements of a data path flowing
*   through CPB for one direction.
*   
*   In the case of a broadcast or multicast channel in CPB subsystem, the
*   reader will be disabled, and the writer will remain enabled.  Except if the
*   reader is the primary reader and broadcast or multicast readers are still
*   active.  In this case an error will be returned.  This error is recoverable,
*   in order for this datapath to be deactivated, each non-primary reader port
*   needs to be deactivated prior to deactivating the primary reader for the
*   write port.
*   
*   
*   
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *output_pc_ptr   - Destination DPI port / channel pair for the channel to
*                      be activated.  Accepts the pointer to one of the
*                      following channel handle types: \n\n
*                      digi_enet_client_chnl_t \n
*                      digi_cbr_client_chnl_t \n
*                      digi_ilkn_chnl_t \n
*                      digi_mapper_chnl_t \n
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_chnl_deactivate(digi_handle_t *digi_handle,
                                          util_global_switch_data_t *output_pc_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ATOMIC_ENTRY(digi_handle);

    /* Check that given handles belong to digi handle */
    result = digi_cpb_chnl_validate(digi_handle, output_pc_ptr);

    if (result == PMC_SUCCESS) 
    {        
        /* 
         * If it's an enet mirror chnl -> don't try to deactivate the enh pmon. 
         * (It will be deactivated when the primary chnl is deactivated).
         */
        BOOL enet_mirror_mode = digi_cpb_enet_mirror_chk(digi_handle, output_pc_ptr);

        if (!enet_mirror_mode)
        {
            /* The following function does argument checking and 
             * always succeeeds even if PMON was not required.
             * This would only fail if for some reason PMON was required and 
             * the actual PMON datapath deactivation fails. */
            result = digi_enet_enhanced_pmon_deactivate(digi_handle, output_pc_ptr);
        }
    }

    if (result == PMC_SUCCESS) {

        result = digi_cpb_internal_chnl_deactivate(digi_handle, output_pc_ptr);
    }
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_cpb_chnl_deactivate */

/*******************************************************************************
* digi_oduksw_chnl_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function provides graceful data path disabling of a client stream
*   passing through ODUK Switch block.  It performs data path element reset and
*
*
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   *output_pc_ptr      - Destination DPI port / channel pair for the channel
*                         mapping to be performed.
*                         Accepts the pointer to one of the following channel
*                         handle types: \n\n
*                           digi_odu_struct_t \n
*                           digi_ilkn_chnl_t \n
*                           digi_mapper_chnl_t \n
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_oduksw_chnl_deactivate(digi_handle_t *digi_handle,
                                             util_global_switch_data_t *output_pc_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;

    /* variable definition */
    UINT32 ingress_mux_input_port = UTIL_GLOBAL_ODUK_PORT_NOT_USED;
    UINT32 ingress_mux_input_port_chnl;
    BOOL dummy;
    BOOL is_multicast = FALSE;
    BOOL is_broadcast = FALSE;
    BOOL is_reader_primary = FALSE;
    BOOL is_slave_zone_primary = FALSE;
    util_global_switch_data_def_t *output_pc_data_ptr = NULL;
    util_global_oduk_port_data_t *local_output_pc_ptr = (util_global_oduk_port_data_t*)output_pc_ptr;

    UINT32  dsi_stream = 0;
    util_global_switch_data_def_t *local_input_sw_ptr = NULL;
    util_global_switch_data_t *input_pc_ptr;
    coreotn_handle_t *coreotn_handle = NULL;

    digi_otn_server_chnl_def_t *otn_server_ptr;
    lineotn_frame_rate_t dsi_rate;
    
    BOOL is_output_ho_unchnl;
    BOOL is_sysotn_card = FALSE;
    BOOL is_input_ilkn_and_sysotn_card;
    BOOL is_output_ilkn = FALSE;

    util_global_cpb_port_data_t *local_input_cpb_pc_ptr;
    BOOL8 mpmo_cfg_req;

    sifd_ilkn_inst_t sifd_ilkn_inst;
    coreotn_odu_chnl_prov_mode_t prov_mode;
    util_global_mapping_mode_t mapotn_mapping_mode = UTIL_GLOBAL_NO_MAP;

    util_global_map_adapt_func_t map_mode;
    util_global_map_adapt_func_t demap_mode;

    mapotn_src_dest_t mapotn_src = LAST_MAPOTN_DEST;
    mapotn_src_dest_t mapotn_dest = LAST_MAPOTN_DEST;
    BOOL8 deactivate_mpmo = FALSE;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* Check arguments */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->coreotn_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != output_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;

    /* Check that given handle belongs to digi handle */
    result = digi_oduksw_chnl_validate(digi_handle, output_pc_ptr);
    if (PMC_SUCCESS != result)
    {
        PMC_ATOMIC_RETURN(digi_handle, result);
    }

    DIGI_CHNL_HANDLE_MAGIC_CHECK(output_pc_data_ptr);

    local_output_pc_ptr = &(output_pc_data_ptr->oduk_data);

    PMC_ASSERT(local_output_pc_ptr->port_type < UTIL_GLOBAL_ODUK_PORT_NOT_USED, DIGI_ERR_INVALID_ARG, 0, 0);

    if (local_output_pc_ptr->op_state.active_state != UTIL_GLOBAL_CHNL_ACTIVE_STATE_ACTIVE) {

        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_ODUKSW_NOT_ACTIVE);
    }


    /* retrieve required COREOTN handle */
    coreotn_handle = digi_handle->coreotn_handle;

    /* find the input channel pointer */
    if( result == PMC_SUCCESS )
    {
        result = coreotn_oduksw_chnl_source_and_type_test(coreotn_handle,
                                                          local_output_pc_ptr->port_type,
                                                          local_output_pc_ptr->channel,
                                                          &ingress_mux_input_port,
                                                          &ingress_mux_input_port_chnl,
                                                          &dummy,
                                                          &dummy);
    }

    if (PMC_SUCCESS == result)
    {
        input_pc_ptr = digi_oduksw_input_port_get(digi_handle, 
                                                  ingress_mux_input_port,
                                                  ingress_mux_input_port_chnl,
                                                  DIGI_ILKN_CHNL_TARGET_ODUK);
        
        local_input_sw_ptr = (util_global_switch_data_def_t*)input_pc_ptr;

        if (NULL == local_input_sw_ptr)
        {
            result = DIGI_ERR_ODUKSW_NOT_ACTIVE;
        }
        else
        {
            /* retrieve the values for the rest of our local variables */
            is_output_ho_unchnl = (local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_COREOTN && 
                                   local_output_pc_ptr->odu_level == UTIL_GLOBAL_LEVEL_HO_ODU && 
                                   digi_handle->var.odu_chnl_payload[local_output_pc_ptr->channel] == DIGI_ODU_UNCHANNELIZED);
            
            is_sysotn_card = (digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD);
            
            is_input_ilkn_and_sysotn_card = ((local_input_sw_ptr->oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1) && 
                                             (is_sysotn_card == TRUE));
            
            is_output_ilkn = (local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1);
        }
    }
    /* return the broadcast and multicast state of the channel and if the channel is a
       primary reader or otherwise */
    if( result == PMC_SUCCESS )
    {
        result = coreotn_oduksw_chnl_type_get(coreotn_handle,
                                              local_output_pc_ptr->port_type,
                                              local_output_pc_ptr->channel,         
                                              &is_reader_primary,
                                              &is_slave_zone_primary,
                                              &is_broadcast,
                                              &is_multicast);
    }

    if( (result == PMC_SUCCESS) && 
        (is_broadcast || is_multicast || is_reader_primary || is_slave_zone_primary))
    {
        result = coreotn_oduksw_chnl_switch(coreotn_handle,
                                            (coreotn_oduksw_output_port_type_t)local_output_pc_ptr->port_type,
                                            local_output_pc_ptr->channel);
        if( result == PMC_SUCCESS )
        {
            result = coreotn_oduksw_chnl_type_get(coreotn_handle,
                                                  local_output_pc_ptr->port_type,
                                                  local_output_pc_ptr->channel,         
                                                  &is_reader_primary,
                                                  &is_slave_zone_primary,
                                                  &is_broadcast,
                                                  &is_multicast);
        }
    }

    /* Call FW methods to drop MPMA/MPMO configuration as required by datapath */
    if(result == PMC_SUCCESS)
    {
        /* retreive coreotn provision mode */   
        result = coreotn_odu_chnl_prov_mode_get(coreotn_handle, &prov_mode);
        
        if (PMC_SUCCESS == result && (prov_mode != COREOTN_ODU_CHNL_PROV_ALL))
        {
            /*only activate opsa segment if OCI is not provisioned in TX path*/


            if((is_output_ilkn == TRUE && is_sysotn_card == TRUE) ||
               local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_COREOTN)
            {
                if(digi_otn_nominal_tx_unchannelized_get(digi_handle, (odu_struct_t *)output_pc_ptr) ||
                   prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK )
                {
                    deactivate_mpmo = FALSE;
                }
                else
                {
                    deactivate_mpmo = TRUE;
                }
            }
            else
            {
                deactivate_mpmo = TRUE;
            }


            digi_opsa_oduksw_activate_cfg(digi_handle,
                                          input_pc_ptr, 
                                          output_pc_ptr,
                                          is_reader_primary,
                                          is_slave_zone_primary,
                                          DIGI_OPSA_CFG_ACTION_DEACTIVATE,
                                          deactivate_mpmo,
                                          FALSE);
                    
        }
    }

    /* Disable data source if it is not used by other downstream data paths */
    if( result == PMC_SUCCESS && 
        ( (is_broadcast == FALSE && is_multicast == FALSE) ||
          (is_broadcast == TRUE && is_slave_zone_primary == TRUE) ||
          (is_multicast == TRUE && is_reader_primary == TRUE) ) )
    {

    }

   
    /* if deactivating ODUKSW connection from MAPOTN, then deactivate MAPOTN MPMO 
    ** first then COREOTN FO2 MPMA and COREOTN FO1 MPMO will be deactivated
    ** Check if this is the last channel if we are in broadcase or multicast 
    ** scenario.
    */
    if( PMC_SUCCESS == result && 
        ( (is_broadcast == FALSE && is_multicast == FALSE) ||
          (is_broadcast == TRUE && is_slave_zone_primary == TRUE) ||
          (is_multicast == TRUE && is_reader_primary == TRUE) ) )
    {
        if (ingress_mux_input_port == UTIL_GLOBAL_ODUK_PORT_MAPOTN)
        {                                      
            result = mapotn_mapper_mpmo_cfg_get(digi_handle->mapotn_handle, ingress_mux_input_port_chnl, &mpmo_cfg_req);
            
            /* check if MAPOTN is carrying non GFP traffic */
            if (PMC_SUCCESS == result && mpmo_cfg_req == TRUE)
            {
                /* deactivate MAPOTN MPMO */
                digi_mapper_src_dest_get(digi_handle,
                                         digi_handle->handle_pool.mapper_chnl[ingress_mux_input_port_chnl].mode,
                                         digi_handle->handle_pool.mapper_chnl[ingress_mux_input_port_chnl].enet_pmon,
                                         &mapotn_src,
                                         &mapotn_dest);
                if(mapotn_src == MAPOTN_DEST_CPB)
                {
                    result = mapotn_mpmo_ch_deactivate(digi_handle->mapotn_handle, ingress_mux_input_port_chnl);
                }
            }
            /* determine if ENET_LINE data source and if so deactivate Tx ENET path */
            if (result == PMC_SUCCESS)
            {
                input_pc_ptr = digi_oduksw_input_port_get(digi_handle, 
                                                          local_input_sw_ptr->oduk_data.port_type,
                                                          local_input_sw_ptr->oduk_data.channel, 
                                                          DIGI_ILKN_CHNL_TARGET_CPB);
       
                local_input_sw_ptr = (util_global_switch_data_def_t*)input_pc_ptr;
                local_input_cpb_pc_ptr = &(local_input_sw_ptr->cpb_data);
            }
            if(result == PMC_SUCCESS && local_input_cpb_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_MAPOTN)
            {
                digi_mapotn_mode_params_convert(((digi_mapper_chnl_def_t*)input_pc_ptr)->mode,
                                                &map_mode,
                                                &demap_mode);
                result = mapotn_mapping_mode_get(digi_handle->mapotn_handle, 
                                                 map_mode,
                                                 &mapotn_mapping_mode);
            }


            if (PMC_SUCCESS == result && local_input_cpb_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_MAPOTN && 
                mapotn_mapping_mode == UTIL_GLOBAL_GFP)
            {
                /* deactivate MAPOTN MPMO */
                result = mapotn_mapper_deactivate(digi_handle->mapotn_handle, ingress_mux_input_port_chnl);
            }

        }
    }                                                                                  

    if(result == PMC_SUCCESS)
    {
        result = coreotn_oduksw_chnl_deactivate(coreotn_handle,
                                                (coreotn_oduksw_input_port_type_t)ingress_mux_input_port,
                                                ingress_mux_input_port_chnl,
                                                (coreotn_oduksw_output_port_type_t)local_output_pc_ptr->port_type,
                                                local_output_pc_ptr->channel);
    }


    if (PMC_SUCCESS == result)
    {
        /* If it's a broadcast or multicast primary channel, then only deactivate 
         * if there are no secondary readers active */
        if(is_multicast == TRUE && is_reader_primary == TRUE && 
           local_input_sw_ptr->oduk_data.op_state.map_state.dest_active_count > 1) 
            result = DIGI_ERR_PRIMARY_UNABLE_TO_DEACTIVATE;
        if(is_broadcast == TRUE && is_slave_zone_primary == TRUE &&
           local_input_sw_ptr->oduk_data.op_state.map_state.dest_active_count > 1) 
            result = DIGI_ERR_PRIMARY_UNABLE_TO_DEACTIVATE;

        if(PMC_SUCCESS == result && (prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK))
        {

            /* Update SIFD flow control calendar if needed */
            /* TX data */
            if((local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1 && (is_sysotn_card == FALSE)) ||
               local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN2)
            {
                sifd_ilkn_inst = local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1 ? SIFD_COPI_ILKN1 : SIFD_COPI_ILKN2;
                
                if (result == PMC_SUCCESS && prov_mode != COREOTN_ODU_CHNL_PROV_ALL)
                {
                    /*this ensure that FC update won't occur even during PROV_ALL bulk prov.*/
                    result = digi_sifd_fc_calendar_update(digi_handle,
                                                          sifd_ilkn_inst,
                                                          (UINT32)local_output_pc_ptr->port_type,
                                                          TRUE, /* TRUE means TX data direction */
                                                          TRUE,/* TRUE means it's for ODUk switch, not CPB */
                                                          local_output_pc_ptr->channel); 
                }
            }
            /* RX data */
            if ((local_input_sw_ptr->oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1 && (is_sysotn_card == FALSE)) ||
                local_input_sw_ptr->oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_ILKN2)
            {
                sifd_ilkn_inst = (local_input_sw_ptr->oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1) ? SIFD_COPI_ILKN1 : SIFD_COPI_ILKN2;
                
                if (result == PMC_SUCCESS && prov_mode != COREOTN_ODU_CHNL_PROV_ALL)
                {
                    /*this ensure that FC update won't occur even during PROV_ALL bulk prov.*/
                    result = digi_sifd_fc_calendar_update(digi_handle,
                                                          sifd_ilkn_inst,
                                                          (UINT32)local_input_sw_ptr->oduk_data.port_type,
                                                          FALSE, /* FALSE means RX data direction */
                                                          TRUE,
                                                          local_input_sw_ptr->oduk_data.channel);
                }
            }
        }
    }

    if (PMC_SUCCESS == result && prov_mode != COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        /* set an indication that the port requires an update during bulk deprov */
        coreotn_oduksw_port_bulk_update_req_set(digi_handle->coreotn_handle,
                                                local_output_pc_ptr->port_type,
                                                UTIL_GLOBAL_DATAPATH_DIR_EGRESS,
                                                TRUE);
        coreotn_oduksw_port_bulk_update_req_set(digi_handle->coreotn_handle,
                                                local_input_sw_ptr->oduk_data.port_type,
                                                UTIL_GLOBAL_DATAPATH_DIR_INGRESS,
                                                TRUE);
    }

    if (PMC_SUCCESS == result && 
        ((is_output_ho_unchnl == TRUE) ||
         ((is_output_ilkn == TRUE) && (is_sysotn_card == TRUE)))) 
    {    
        /* deactivate ACB */
        if (PMC_SUCCESS == result)
        {         
            if(local_output_pc_ptr->lineotn_src) {

                otn_server_ptr = digi_otn_server_chnl_get(digi_handle, local_output_pc_ptr->channel);

            } else {

                otn_server_ptr = digi_sysotn_server_chnl_get(digi_handle);
            }

            if (TRUE == pmc_is_digi_rev_a_revision(&digi_handle->base))
            {
                /*never deactivate the SYSTEM side ACB for transponder.  Only deactivate the LINE side ACB for MUXPONDER */
                if (is_sysotn_card == TRUE) 
                { 
                    if (is_output_ilkn == TRUE) 
                    {
                        result = lineotn_dsi_rate_get(digi_handle->lineotn_handle,
                                                      dsi_stream,
                                                      &dsi_rate);

                        if (dsi_rate != LINE_OTN_RATE_OTU4) 
                        { 
                            result = digi_otn_acb_ckctl_cfg(digi_handle, otn_server_ptr, DIGI_SERDES_DEACTIVATE);

                            if (PMC_SUCCESS == result)
                            {        
                                result = digi_otn_acb_ckctl_cfg(digi_handle, otn_server_ptr,DIGI_SERDES_DEPROV);
                            }
                        }
                    }
                } 
                else 
                {
                    result = digi_otn_acb_ckctl_cfg(digi_handle, otn_server_ptr,DIGI_SERDES_DEACTIVATE);
                    if (PMC_SUCCESS == result)
                    {        
                        result = digi_otn_acb_ckctl_cfg(digi_handle, otn_server_ptr,DIGI_SERDES_DEPROV);
                    }
                }
            }
            else
            {
                result = digi_otn_acb_ckctl_cfg(digi_handle, otn_server_ptr,DIGI_SERDES_DEACTIVATE);
                if (PMC_SUCCESS == result)
                {        
                    result = digi_otn_acb_ckctl_cfg(digi_handle, otn_server_ptr,DIGI_SERDES_DEPROV);
                }
            }

        }
    } 

    if (result == PMC_SUCCESS) {

        local_output_pc_ptr->op_state.active_state = UTIL_GLOBAL_CHNL_ACTIVE_STATE_INACTIVE;
        local_input_sw_ptr->oduk_data.op_state.map_state.dest_active_count--;
    }


    if (PMC_SUCCESS == result && prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
    {
        if((is_output_ilkn == TRUE) && (is_sysotn_card == TRUE))
        {
            result = odu_struct_tx_maint_sig_dummy_rfrm_cfg(digi_handle->coreotn_handle,
                                                            ((odu_struct_t *)output_pc_ptr)->mem_ptr->odu_level,
                                                            ((odu_struct_t *)output_pc_ptr)->mem_ptr->chnl_id,
                                                            TRUE);        
        }
        else if(local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_COREOTN)
        {

            result = odu_struct_tx_maint_sig_dummy_rfrm_cfg(digi_handle->coreotn_handle,
                                                            ((odu_struct_t *)output_pc_ptr)->mem_ptr->odu_level,
                                                            ((odu_struct_t *)output_pc_ptr)->mem_ptr->chnl_id,
                                                            TRUE);
        }
    }


    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_oduksw_chnl_deactivate */

/*******************************************************************************
* digi_cpb_chnl_demap
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function provides CPB demapping functionality.  It will demap and
*   deprovision resources used by a CPB output port and channel.
*
*   The function will also operate at the CPB interface level and disable
*   interfaces if no channels are provisioned against them. It will further
*   put the subsystem in lowpwr/reset state so if no channels are provisioned
*   against the subsystem.
*
*
*
*
* INPUTS:
*   *digi_handle   - pointer to DIGI handle instance.
*   *output_pc_ptr   - Destination DPI port / channel pair for the channel
*                      mapping to be performed.  Accepts the pointer to one of
*                      the following channel handle types: \n\n
*                      digi_enet_client_chnl_t \n
*                      digi_cbr_client_chnl_t \n
*                      digi_ilkn_chnl_t \n
*                      digi_mapper_chnl_t \n
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_chnl_demap( digi_handle_t *digi_handle,
                                      util_global_switch_data_t *output_pc_ptr )
{
    PMC_ERROR result = PMC_SUCCESS;


    /* variable definition */
    util_global_switch_data_def_t *output_pc_data_ptr = NULL;
    util_global_switch_data_t* input_pc_ptr;
    util_global_cpb_port_data_t *local_output_pc_ptr = (util_global_cpb_port_data_t*)output_pc_ptr;
    cpb_handle_t *cpb_handle = NULL;
    UINT32 cpb_output_port;
    UINT32 i;
    BOOL enet_mirror_mode = FALSE;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* Check arguments */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != output_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    /* Check that given handles belong to digi handle */
    result = digi_cpb_chnl_validate(digi_handle, output_pc_ptr);

    if (result != PMC_SUCCESS) 
    {    
        PMC_ATOMIC_RETURN(digi_handle, result);
    }

    output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;

    DIGI_CHNL_HANDLE_MAGIC_CHECK(output_pc_data_ptr);

    local_output_pc_ptr = &(output_pc_data_ptr->cpb_data);

    PMC_ASSERT(local_output_pc_ptr->port_type < UTIL_GLOBAL_CPB_PORT_NOT_USED, DIGI_ERR_INVALID_ARG, 0, 0);

    if ((local_output_pc_ptr->op_state.map_state.is_input_mapped == FALSE) &&
        (local_output_pc_ptr->op_state.map_state.is_output_mapped == FALSE)) {

        /* Already un-mapped */ 
        /* Return SUCCUESS */
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);

    } else if (local_output_pc_ptr->op_state.active_state == UTIL_GLOBAL_CHNL_ACTIVE_STATE_ACTIVE) {

        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_CPB_STILL_ACTIVE);

    }



    enet_mirror_mode = digi_cpb_enet_mirror_chk(digi_handle, output_pc_ptr);

    /* retrieve required CPB handle */
    cpb_handle = digi_handle->dcpb_handle;
    cpb_output_port = local_output_pc_ptr->port_type;

    /* We need to look up the input_chnl based on this output chnl. */
    input_pc_ptr = digi_cpb_input_port_get(digi_handle, output_pc_ptr);

    PMC_ASSERT(NULL != input_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    if (!enet_mirror_mode)
    {
        digi_enet_client_chnl_def_t *enet_chnl_ptr = NULL;
        /* Check if there is an enhanced PMON ENET handle */
        enet_chnl_ptr = digi_enet_enhanced_pmon_ptr_get(((util_global_switch_data_def_t*)input_pc_ptr));
        if(enet_chnl_ptr)
        {
            /* Delete MCPB resource which is provisioned against enhanced ENET for LLDP feature */
            digi_enet_cpu_extract_pkt_cfg(digi_handle,
                                          ENET_INGRESS,
                                          (util_global_switch_data_t*)enet_chnl_ptr,
                                          FALSE, 
                                          FALSE);
        }

        result = digi_enet_enhanced_pmon_demap(digi_handle, input_pc_ptr);
    }

    if (result == PMC_SUCCESS) {
    
        result = digi_cpb_internal_chnl_demap(digi_handle,
                                              cpb_handle,
                                              cpb_output_port,
                                              input_pc_ptr,
                                              output_pc_ptr);
    }

    if (result == PMC_SUCCESS) {
    
        /* When a channel is deprovisioned, also remove from all PMON counters */ 
        for(i=0;i<DIGI_CPB_PMON_COUNTERS_PER_PORT;i++)
        {
            result = digi_cpb_pmon_chnl_add_drop_internal_cfg(digi_handle,
                                                              input_pc_ptr,
                                                              i,
                                                              TRUE,
                                                              FALSE);
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_cpb_chnl_demap */

/*******************************************************************************
* digi_oduksw_chnl_demap
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function provides ODUK Switch demapping functionality.
*
*
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   *output_pc_ptr      - Destination DPI port / channel pair for the channel
*                         mapping to be performed.
*                         Accepts the pointer to one of the following channel
*                         handle types: \n\n
*                           digi_odu_struct_t \n
*                           digi_ilkn_chnl_t \n
*                           digi_mapper_chnl_t \n
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_oduksw_chnl_demap(digi_handle_t *digi_handle,
                                        util_global_switch_data_t *output_pc_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;

    /* variable definition */
    util_global_switch_data_def_t *output_pc_data_ptr = NULL;
    util_global_oduk_port_data_t *local_output_pc_ptr = (util_global_oduk_port_data_t*)output_pc_ptr;
    coreotn_handle_t *coreotn_handle = NULL;
    util_global_switch_data_t* input_pc_ptr;
    util_global_oduk_port_data_t* local_input_pc_ptr = NULL;
    util_global_oduk_port_data_t local_input_pc;
    UINT32 oduk_output_port;
    BOOL is_broadcast = FALSE;
    BOOL is_multicast = FALSE;
    /*UINT8 chnl_state;
      UINT32 i;*/
    UINT32 i;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* Check arguments */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != output_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;


    /* Check that given handle belongs to digi handle */
    result = digi_oduksw_chnl_validate(digi_handle, output_pc_ptr);

    if (PMC_SUCCESS != result)
    {
        PMC_ATOMIC_RETURN(digi_handle, result);
    }

    DIGI_CHNL_HANDLE_MAGIC_CHECK(output_pc_data_ptr);

    local_output_pc_ptr = &(output_pc_data_ptr->oduk_data);

    PMC_ASSERT(local_output_pc_ptr->port_type < UTIL_GLOBAL_ODUK_PORT_NOT_USED, DIGI_ERR_INVALID_ARG, 0, 0);

    if ((local_output_pc_ptr->op_state.map_state.is_input_mapped == FALSE) &&
        (local_output_pc_ptr->op_state.map_state.is_output_mapped == FALSE)) 
    {

        /* Already un-mapped */ 
        /* Return SUCCUESS */
        PMC_ATOMIC_RETURN(digi_handle,PMC_SUCCESS);

    } 
    else if (local_output_pc_ptr->op_state.active_state == UTIL_GLOBAL_CHNL_ACTIVE_STATE_ACTIVE) 
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_ODUKSW_STILL_ACTIVE);
    }


    /* retrieve required CPB handle */
    coreotn_handle = digi_handle->coreotn_handle;
    oduk_output_port = local_output_pc_ptr->port_type;
    result = coreotn_oduksw_chnl_source_and_type_test(coreotn_handle,
                                                      local_output_pc_ptr->port_type,
                                                      local_output_pc_ptr->channel,
                                                      (UINT32*)&(local_input_pc.port_type),
                                                      &(local_input_pc.channel),
                                                      &is_broadcast,
                                                      &is_multicast);

    
    if (result==PMC_SUCCESS &&
        local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_MAPOTN)
    {
        if (FALSE == ((digi_mapper_chnl_def_t *)output_pc_ptr)->switch_data.cpb_data.op_state.map_state.is_input_mapped)
        {
            result =  digi_map_opu_csf_int_cfg(digi_handle, (digi_mapper_chnl_def_t *)output_pc_ptr, local_input_pc.channel, TRUE);
        }
    }


    if (PMC_SUCCESS == result)
    {
        result = coreotn_oduksw_chnl_deprov(coreotn_handle,
                                            (coreotn_oduksw_input_port_type_t)local_input_pc.port_type,
                                            local_input_pc.channel,
                                            (coreotn_oduksw_output_port_type_t)local_output_pc_ptr->port_type,
                                            local_output_pc_ptr->channel);
    }
         
    if (PMC_SUCCESS == result)
    {       
        /* Clear OSUKSW DB 
         */
        result = coreotn_oduksw_db_entry_clear(digi_handle->coreotn_handle,
                                               (coreotn_oduksw_output_port_type_t)local_output_pc_ptr->port_type,
                                               local_output_pc_ptr->channel);
    }
    
    if (result == PMC_SUCCESS) 
    {

        /* We need to look up the input_chnl based on this output chnl. */
        input_pc_ptr = digi_oduksw_input_port_get(digi_handle,
                                                  local_input_pc.port_type,
                                                  local_input_pc.channel,
                                                  DIGI_ILKN_CHNL_TARGET_ODUK);

        PMC_ASSERT(input_pc_ptr != NULL, DIGI_ERR_INVALID_ARG, 0, 0);

        local_input_pc_ptr = &(((util_global_switch_data_def_t*)input_pc_ptr)->oduk_data);

        if (local_input_pc_ptr->op_state.map_state.input_map_count > 0)
        {
            local_input_pc_ptr->op_state.map_state.input_map_count--;
        }
        if (local_input_pc_ptr->op_state.map_state.input_map_count == 0) 
        {
            local_input_pc_ptr->op_state.map_state.is_input_mapped = FALSE;
        }

        local_output_pc_ptr->op_state.map_state.is_output_mapped = FALSE;
    }

    if (result == PMC_SUCCESS) 
    {
    
        /* When a channel is deprovisioned, also remove from all PMON counters */ 
        for(i=0;i<DIGI_CPB_PMON_COUNTERS_PER_PORT && 
                PMC_SUCCESS == result;i++)
        {
            result = digi_cpb_pmon_chnl_add_drop_internal_cfg(digi_handle,
                                                              input_pc_ptr,
                                                              i,
                                                              FALSE,
                                                              FALSE);
        }
    }

    if(UTIL_GLOBAL_ODUK_PORT_COREOTN == local_output_pc_ptr->port_type &&
       local_output_pc_ptr->odu_level == UTIL_GLOBAL_LEVEL_HO_ODU &&
       digi_handle->var.odu_chnl_payload[local_output_pc_ptr->channel] == DIGI_ODU_UNCHANNELIZED)
    {
        if(result == PMC_SUCCESS)
        {

            result = coreotn_odu4_calendar_pinch_set(digi_handle->coreotn_handle,
                                                     (coreotn_oduksw_output_port_type_t)local_output_pc_ptr->port_type,
                                                     FALSE);
        }

        if(result == PMC_SUCCESS)
        {
            /*Set deinterleaver FIFO threshold (OTU_FRM_DINTLV_XOFF_THRES)
              back to default of 0x085 */
            if(result == PMC_SUCCESS)
            {

                if(digi_handle->var.prod_app != DIGI_PROD_APP_SYSOTN_CARD)
                {
                    result = lineotn_otu_frm_dintlv_xoff_thres_set(digi_handle->lineotn_handle,
                                                                   local_output_pc_ptr->channel,    
                                                                   0x85);                                               
                }
                else
                {
                    result = lineotn_otu_frm_dintlv_xoff_thres_set(digi_handle->sysotn_handle,
                                                                   local_output_pc_ptr->channel,    
                                                                   0x85);
                }
            }
        }
    }



#ifdef PMC_INTERNAL_COREOTN_POWER
    /* powerdown oduksw */
    digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_OPTIMAL,COREOTN_ODUKSW);                 
#endif    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_oduksw_chnl_demap */

/*******************************************************************************
* digi_cbr_client_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions the processing resources associated with a CBR
*   client.  These resources are subsequently available for usage with other
*   provisioning operations.
*
*
*
* INPUTS:
*   *digi_handle   - pointer to DIGI handle instance.
*   *chnl_ctxt_pptr - pointer to CBRC channel handle of the instance to be
*                     deprovisioned.
*
*
* OUTPUTS:
*   None.
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cbr_client_deprov(digi_handle_t *digi_handle,
                                        digi_cbr_client_chnl_t **chnl_ctxt_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    UINT32                               chnl;
    digi_cbr_client_chnl_def_t          *cbr_chnl_handle_ptr;
    digi_serdes_port_t                  *port_ctxt_ptr = NULL;
    digi_serdes_port_rate_prov_state_t   serdes_port_prov_state; 

    PMC_ATOMIC_ENTRY(digi_handle);
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    
    /* Check arguments */
    if ((chnl_ctxt_pptr == NULL) || (*chnl_ctxt_pptr == NULL) ||
        PMC_SUCCESS != digi_cbr_chnl_handle_validate(digi_handle, *chnl_ctxt_pptr)) {

        result = DIGI_ERR_INVALID_ARG;

    } 
    else {

        cbr_chnl_handle_ptr = (digi_cbr_client_chnl_def_t*)(*chnl_ctxt_pptr);

        DIGI_CHNL_HANDLE_MAGIC_CHECK(cbr_chnl_handle_ptr);

        if ((cbr_chnl_handle_ptr->switch_data.cpb_data.op_state.map_state.is_input_mapped == TRUE) ||
            (cbr_chnl_handle_ptr->switch_data.cpb_data.op_state.map_state.is_output_mapped == TRUE)) {

            result = DIGI_ERR_CPB_STILL_MAPPED;

        } else if (cbr_chnl_handle_ptr->switch_data.cpb_data.port_type != UTIL_GLOBAL_CPB_PORT_CBRC) {

            result = DIGI_ERR_INVALID_ARG;
        }

        chnl = digi_cbr_channel_num_get(digi_handle, *chnl_ctxt_pptr);

        /* PROV_STATE SHALL BE UPDATED IN THE FIRST ATOMIC SECTION */
        if (PMC_SUCCESS == result)
        {
            cbr_chnl_handle_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
        }


        /* deactivate and unprovision RX CBR client */  
        if (PMC_SUCCESS == result) 
        {
            result = cbrc_port_deactivate(digi_handle->cbrc_handle,
                                          CBRC_PORT_DIR_RX,
                                          chnl);
        }
        if (PMC_SUCCESS == result)
        {
            result = cbrc_port_deactivate(digi_handle->cbrc_handle,
                                          CBRC_PORT_DIR_TX,
                                          chnl);
        }
        
        if (PMC_SUCCESS == result)
        {
            result = cbrc_sdh_pmg_deactivate(digi_handle->cbrc_handle,
                                             CBRC_PORT_DIR_RX,
                                             chnl);
        }        
        
        if (PMC_SUCCESS == result)
        {
            result = cbrc_port_unprovision(digi_handle->cbrc_handle,
                                           chnl);
        }

        if (PMC_SUCCESS == result) {
            result = digi_cbrc_db_deprov_cfg(digi_handle, chnl);
        }
        
        if (PMC_SUCCESS == result)
        {
            result = digi_port_ctxt_from_channel_number_get(digi_handle,
                                                            DIGI_SERDES_PROV_STATE_CBRC,
                                                            chnl, 
                                                            &port_ctxt_ptr);
        }
        if (PMC_SUCCESS == result)
        {
            /* check if we have an active loopback on this segment */
            serdes_port_prov_state = digi_serdes_port_prov_status_get(digi_handle, ((digi_serdes_port_def_t*)(port_ctxt_ptr))->port_uid); 
            if (DIGI_SERDES_PORT_RATE_STATE_PROV_FACILITY_LPBK == serdes_port_prov_state || DIGI_SERDES_PORT_RATE_STATE_PROV_DIAG_LPBK == serdes_port_prov_state) 
            { 
                result = DIGI_ERR_LOOPBACK_STILL_ACTIVE; 
            } 
        }  

        if (PMC_SUCCESS == result)
        {
            /* deactivate SerDes Port and put in lowest energy state */
            result = digi_serdes_port_deprov(digi_handle, port_ctxt_ptr);
        }

        if (PMC_SUCCESS == result)
        {
            result = digi_serdes_port_lifd_sifd_subsytem_disable(digi_handle,
                                                                 ((digi_serdes_port_def_t*)(port_ctxt_ptr))->port_uid);
            /* We should never get here as this means our state is corrupt */
            PMC_ASSERT(PMC_SUCCESS == result, result, 0, 0);

            if (PMC_SUCCESS == result) {
                result = digi_post_mld_prov_state_set(digi_handle,
                                                      ((digi_serdes_port_def_t*)(port_ctxt_ptr))->port_uid,
                                                      DIGI_SERDES_PROV_STATE_UNASSIGNED);
                /* We should never get here as this means our state is corrupt */
                PMC_ASSERT(PMC_SUCCESS == result, result, 0, 0);
           
            } 

            if (PMC_SUCCESS == result) {

                result = digi_serdes_port_rate_state_set(digi_handle, 
                                                         port_ctxt_ptr, 
                                                         LAST_DIGI_SERDES_PORT_MODE, 
                                                         DIGI_SERDES_PROV_STATE_UNASSIGNED, 
                                                         DIGI_SERDES_PORT_RATE_STATE_DEPROV);
                if (PMC_SUCCESS == result)
                {
                    digi_chnl_ptr_initialize((util_global_switch_data_def_t*)*(chnl_ctxt_pptr));
                    ((digi_cbr_client_chnl_def_t *)*(chnl_ctxt_pptr))->port_uid = DIGI_SERDES_UNASSIGNED;
                    *chnl_ctxt_pptr = NULL;
                }
            }
        }
    }
        
    /* determine state of the CBRC SS and if no resources provisioned bring SS to lowpwr/reset state */
    if(PMC_SUCCESS == result)
    {
        digi_cbrc_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
    }
    

    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_cbr_client_deprov */


/*******************************************************************************
* digi_otn_mapper_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions the resources used to perform client mapping
*   between CPB and ODUKSW subsystems.  The resources allocated to a provisioned
*   mapping operation will include a CORE OTN 4th stage framer and potentially
*   a slice within the ENET_LINE subsystem.  The set of resource used by the
*   mapper channel will be deallocated and available for usage for future
*   provisioning to the same or other modes.
*
*
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance.
*   *chnl_ctxt_pptr - pointer to mapper channel handle of the instance to be
*                     deprovisioned.
*
*
* OUTPUTS:
*   None.
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_mapper_deprov(digi_handle_t *digi_handle,
                                        digi_mapper_chnl_t **chnl_ctxt_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;


    digi_mapper_chnl_def_t *mapper_chnl_handle_ptr;
    UINT32 mapotn_chnl;
    BOOL8 is_umbilical_pmon = FALSE, is_enet_line_link = FALSE;
    UINT32 enet_line_link = 0xffffffff;

    mapotn_src_dest_t mapotn_src = LAST_MAPOTN_DEST;
    mapotn_src_dest_t mapotn_dest = LAST_MAPOTN_DEST;
    util_global_map_adapt_func_t adapt_mode = UTIL_GLOBAL_MAP_NO_RATE;
    util_global_map_adapt_func_t dummy_adapt_mode = UTIL_GLOBAL_MAP_NO_RATE;
    util_global_mapping_mode_t mapotn_mapping_mode = UTIL_GLOBAL_NO_MAP;

    coreotn_odu_chnl_prov_mode_t prov_mode = LAST_COREOTN_CHNL_PROV_MODE;

    PMC_ATOMIC_ENTRY(digi_handle);
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Check arguments */
    if ((chnl_ctxt_pptr == NULL) || 
        (*chnl_ctxt_pptr == NULL) ||
        (PMC_SUCCESS != digi_mapper_chnl_handle_validate(digi_handle, *chnl_ctxt_pptr))) {

        result = DIGI_ERR_INVALID_ARG;

    }

    /* confirm MCPB resources not provisioned against ENET_LINE resource */
    if (PMC_SUCCESS == result)
    {
        result = digi_enet_channel_mcpb_clean_test(digi_handle, *chnl_ctxt_pptr);
        if(result == DIGI_ERR_MCPB_PATH_STILL_CONNECTED)
        {
            util_global_switch_data_t *enet_handle_ptr = NULL;
            /* Get enhanced PMON ENET handle */
            enet_handle_ptr = digi_enet_lldp_companion_pmon_get(digi_handle, *chnl_ctxt_pptr, TRUE);
            if(enet_handle_ptr)
            {
                /* Delete MCPB resource which is provisioned against enhanced ENET for LLDP feature */
                digi_enet_cpu_extract_pkt_cfg(digi_handle, ENET_INGRESS, enet_handle_ptr, FALSE, FALSE);
                result = PMC_SUCCESS;
            }
        }
    }    

    if(result == PMC_SUCCESS)
    {

        mapper_chnl_handle_ptr = (digi_mapper_chnl_def_t*)(*chnl_ctxt_pptr);

        DIGI_CHNL_HANDLE_MAGIC_CHECK(mapper_chnl_handle_ptr);

        mapotn_chnl = mapper_chnl_handle_ptr->mapotn_chnl;
        is_umbilical_pmon = digi_enet_is_enhanced_pmon_umbilical_case(digi_handle, 
                                                                      mapper_chnl_handle_ptr, 
                                                                      mapper_chnl_handle_ptr->enet_pmon);


        is_enet_line_link = (mapper_chnl_handle_ptr->switch_data.cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE &&
                             mapper_chnl_handle_ptr->switch_data.cpb_data.data_source == 1 );

        if ((mapper_chnl_handle_ptr->switch_data.cpb_data.op_state.map_state.is_input_mapped == TRUE) ||
            (mapper_chnl_handle_ptr->switch_data.cpb_data.op_state.map_state.is_output_mapped == TRUE)) {

            result = DIGI_ERR_CPB_STILL_MAPPED;

            /* deprovision ENET_LINE and MAPOTN if both part of the data path segment */
        } 
        else if(is_enet_line_link || is_umbilical_pmon) 
        {
            enet_line_link = mapper_chnl_handle_ptr->enet_pmon_data->switch_data.cpb_data.channel;  


            if(result == PMC_SUCCESS)
            {
                result = enet_rx_deactivate(digi_handle->enet_line_handle, enet_line_link,
                                            digi_handle->enet_line_handle->var.ch_datapath[enet_line_link]);       
            }

            if(result == PMC_SUCCESS)
            {
                result = enet_tx_deactivate(digi_handle->enet_line_handle, enet_line_link,
                                            digi_handle->enet_line_handle->var.ch_datapath[enet_line_link]);       
            }

            if (result == PMC_SUCCESS)
            {
                result = enet_datapath_uncfg(digi_handle->enet_line_handle, enet_line_link);
            }

            if (result == PMC_SUCCESS)
            {
                /* Uninitialize the subsystem if no channels provisioned against it */
                digi_enet_line_energy_state_set(digi_handle, 0,ENET_UNPROV_DATAPATH,PMC_ENERGY_STATE_REQUEST_OPTIMAL);
            }

            if(result == PMC_SUCCESS)
            {
                if(digi_handle->var.etrans_dcpb_use_model == FALSE)
                {
                    digi_num_odus_and_map_type_deprov_set(digi_handle,
                                                          mapper_chnl_handle_ptr->switch_data.cpb_data.port_type,
                                                          mapotn_chnl);
                } else {
                    digi_num_odus_and_map_type_etrans_deprov_set(digi_handle,
                                                                 mapper_chnl_handle_ptr->switch_data.cpb_data.port_type,
                                                                 enet_line_link);
                }
                if(result == PMC_SUCCESS)
                {
                    digi_mapper_src_dest_get(digi_handle,
                                             digi_handle->handle_pool.mapper_chnl[mapotn_chnl].mode,
                                             digi_handle->handle_pool.mapper_chnl[mapotn_chnl].enet_pmon,
                                             &mapotn_src,
                                             &mapotn_dest);
                    digi_mapotn_mode_params_convert(digi_handle->handle_pool.mapper_chnl[mapotn_chnl].mode,
                                                    &adapt_mode,
                                                    &dummy_adapt_mode);
                    result = mapotn_mapping_mode_get(digi_handle->mapotn_handle, 
                                                     adapt_mode,
                                                     &mapotn_mapping_mode);
                }

                if(result == PMC_SUCCESS && mapotn_mapping_mode != UTIL_GLOBAL_GFP && mapotn_src == MAPOTN_DEST_ENET)
                {
                    /* activate MAPOTN MPMO for the case where it is internally used on the ETRANS path */
                    result = mapotn_mpmo_ch_deactivate(digi_handle->mapotn_handle, mapotn_chnl);
                }

                if(result == PMC_SUCCESS && !(mapotn_mapping_mode == UTIL_GLOBAL_GFP))
                {
                    result = mapotn_demapper_deactivate( digi_handle->mapotn_handle, mapotn_chnl);
                }
                if(result == PMC_SUCCESS && mapotn_src == MAPOTN_DEST_ENET && mapotn_mapping_mode != UTIL_GLOBAL_GFP)
                {
                    digi_opsa_cfg_one_tgmp_txjc_cfc_fifo_clrb(digi_handle,
                                                              mapotn_chnl,
                                                              FALSE);    
                }

                if(result == PMC_SUCCESS && !(mapotn_mapping_mode == UTIL_GLOBAL_GFP && mapotn_src == MAPOTN_DEST_CPB))
                {
                    result = mapotn_mapper_deactivate(digi_handle->mapotn_handle, mapotn_chnl);
                }

                if(result == PMC_SUCCESS)
                {
                    result = mapotn_demapper_unprov(digi_handle->mapotn_handle, mapotn_chnl);
                }

                if(result == PMC_SUCCESS)
                {
                    result = digi_enet_mapotn_mpmo_deprov(digi_handle, mapotn_chnl, mapper_chnl_handle_ptr->mode);
                }
                if(result == PMC_SUCCESS)
                {
                    result = mapotn_mapper_unprov(digi_handle->mapotn_handle, mapotn_chnl);
                }
            }
            
            /* Shut off ENET1/2 DCSU if ENET is in start state */
            if(result == PMC_SUCCESS)
            {
                digi_dcsu_conditional_uninit(digi_handle, DIGI_DCSU_INST_ENET1);
                digi_dcsu_conditional_uninit(digi_handle, DIGI_DCSU_INST_ENET2);
                digi_dcsu_conditional_uninit(digi_handle, DIGI_DCSU_INST_ENET3);
            }

        }
        /* deprovision only MAPOTN as ENET_LINE not part of data path segment */
        else if(mapper_chnl_handle_ptr->switch_data.cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_MAPOTN &&
                mapper_chnl_handle_ptr->switch_data.cpb_data.data_source == 1 )
        {
            if(digi_handle->var.etrans_dcpb_use_model == FALSE)
                digi_num_odus_and_map_type_deprov_set(digi_handle,
                                                      mapper_chnl_handle_ptr->switch_data.cpb_data.port_type,
                                                      mapotn_chnl);
            if(result == PMC_SUCCESS)
            {
                digi_mapotn_mode_params_convert(digi_handle->handle_pool.mapper_chnl[mapotn_chnl].mode,
                                                &adapt_mode,
                                                &dummy_adapt_mode);
                result = mapotn_mapping_mode_get(digi_handle->mapotn_handle, 
                                                 adapt_mode,
                                                 &mapotn_mapping_mode);
            }
            
            if(result == PMC_SUCCESS && !(mapotn_mapping_mode == UTIL_GLOBAL_GFP))
            {
                result = mapotn_demapper_deactivate(digi_handle->mapotn_handle, mapotn_chnl);
            }

            if(result == PMC_SUCCESS)
            {
                digi_mapper_src_dest_get(digi_handle,
                                         digi_handle->handle_pool.mapper_chnl[mapotn_chnl].mode,
                                         digi_handle->handle_pool.mapper_chnl[mapotn_chnl].enet_pmon,
                                         &mapotn_src,
                                         &mapotn_dest);
                digi_mapotn_mode_params_convert(digi_handle->handle_pool.mapper_chnl[mapotn_chnl].mode,
                                                &adapt_mode,
                                                &dummy_adapt_mode);
                result = mapotn_mapping_mode_get(digi_handle->mapotn_handle, 
                                                 adapt_mode,
                                                 &mapotn_mapping_mode);
            }


            if(result == PMC_SUCCESS && !(mapotn_mapping_mode == UTIL_GLOBAL_GFP && mapotn_src == MAPOTN_DEST_CPB))
            {
                result = mapotn_mapper_deactivate(digi_handle->mapotn_handle, mapotn_chnl);
            }


            if(result == PMC_SUCCESS)
            {
                result = mapotn_demapper_unprov(digi_handle->mapotn_handle, mapotn_chnl);
            }        
            if(result == PMC_SUCCESS)
            {
                result = digi_enet_mapotn_mpmo_deprov(digi_handle, mapotn_chnl, mapper_chnl_handle_ptr->mode);
            }
            if(result == PMC_SUCCESS)
            {
                result = mapotn_mapper_unprov(digi_handle->mapotn_handle, mapotn_chnl);
            }

        }
        else
        {
            result = DIGI_ERR_INVALID_ARG;
        }

        /* PROV_STATE SHALL BE UPDATED IN THE FIRST ATOMIC SECTION */
        if (PMC_SUCCESS == result)
        {
            mapper_chnl_handle_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
            digi_handle->handle_pool.s4_odu_struct[mapotn_chnl].switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
        }


        /* deprovision COREOTN 4th stage framer */
        /* the coreotn channel id is the same as mapotn_chnl */
        if(result == PMC_SUCCESS)
        {
            result = coreotn_stg4_rx_chnl_prov(digi_handle->coreotn_handle,
                                               mapotn_chnl,
                                               0);
        }
        if(result == PMC_SUCCESS)
        {
            result = coreotn_stg4_tx_chnl_prov(digi_handle->coreotn_handle,
                                               mapotn_chnl,
                                               0);
        }
       
        PMC_ATOMIC_YIELD(digi_handle,0);
       
        if(result == PMC_SUCCESS)
        {
            result = digi_mapper_db_deprov_cfg(digi_handle,
                                               mapper_chnl_handle_ptr->switch_data.cpb_data.port_type,
                                               mapotn_chnl,
                                               enet_line_link,
                                               is_umbilical_pmon);
        }

        /* determine state of the MAPOTN SS and if no resources provisioned bring SS to lowpwr/reset state */
        if(result==PMC_SUCCESS)
        {
            digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_OPTIMAL,COREOTN_STG4);
            digi_mapotn_energy_state_set(digi_handle, mapper_chnl_handle_ptr->mode, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
        }

        if (is_enet_line_link || is_umbilical_pmon) {
            digi_enet_client_chnl_def_t* enet_chnl_ptr = NULL;

            enet_chnl_ptr = mapper_chnl_handle_ptr->enet_pmon_data;

            if (enet_chnl_ptr != NULL) {

                /* Reset the handle to the default state */
                digi_chnl_ptr_initialize(&(enet_chnl_ptr->switch_data));

                digi_enet_pmon_line_usage_set(digi_handle,
                                              enet_line_link,
                                              enet_chnl_ptr->mode,
                                              FALSE);

            } else {

                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
            }
        }

        if (PMC_SUCCESS == result)
        {
            result = coreotn_odu_chnl_prov_mode_get(digi_handle->coreotn_handle, &prov_mode);
        }

        if (PMC_SUCCESS == result)
        {
            if (prov_mode != COREOTN_ODU_CHNL_PROV_ALL)
            {
                digi_chnl_ptr_initialize((util_global_switch_data_def_t*)*(chnl_ctxt_pptr));
            }
            else {
                util_global_cpb_connect_t *oduk_connect_data_pptr = NULL;
                coreotn_oduksw_connect_data_state_get(digi_handle->coreotn_handle,
                                                      &oduk_connect_data_pptr);
                if (oduk_connect_data_pptr->chnl[UTIL_GLOBAL_ODUK_PORT_MAPOTN][mapotn_chnl].mst.state == UTIL_GLOBAL_CHNL_START)
                {
                    digi_chnl_ptr_initialize((util_global_switch_data_def_t*)*(chnl_ctxt_pptr));
                }
            }

        }
        /* Note: The above does not reset the special ENET_PMON field */
        mapper_chnl_handle_ptr->enet_pmon = DIGI_NO_PMON;
        mapper_chnl_handle_ptr->enet_pmon_data = NULL;
        mapper_chnl_handle_ptr->odu_data = LAST_DIGI_ODUK;
        mapper_chnl_handle_ptr->odu_flex_data = 0;
        mapper_chnl_handle_ptr->primary_group = LAST_DIGI_MAPPER_PRIMARY_GROUP;
        mapper_chnl_handle_ptr->secondary_group = LAST_DIGI_MAPPER_SECONDARY_GROUP;

        mapper_chnl_handle_ptr->post_mld_index = 255;
        *chnl_ctxt_pptr = NULL;       
    }

    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_mapper_deprov */





/*******************************************************************************
* digi_otn_server_lo_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions a low order or a mid order ODU framer and 
*   recovers device resources so they are available for other provisioning 
*   operations. 
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance.
*   **lo_odu_chnl_ctxt_pptr - pointer to ODU framer to configured MO or LO ODU  
*                             container
*   **ho_odu_chnl_ctxt_pptr - pointer to ODU framer to configured HO or MO ODU 
*                             container
*
* OUTPUTS:
*    None.
*
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_lo_deprov(digi_handle_t *digi_handle,
                                           digi_otn_odu_chnl_t **lo_odu_chnl_ctxt_pptr,
                                           digi_otn_odu_chnl_t **ho_odu_chnl_ctxt_pptr)
{
    PMC_ERROR result;

    PMC_ATOMIC_ENTRY(digi_handle);

    result = digi_otn_server_lo_deprov_internal(digi_handle,
                                                lo_odu_chnl_ctxt_pptr,
                                                ho_odu_chnl_ctxt_pptr,
                                                DIGI_OTN_DEPROV_RX_AND_TX,
                                                TRUE);


    
    PMC_ATOMIC_RETURN(digi_handle, result);
  

} /* digi_otn_server_lo_deprov */




/*******************************************************************************
* digi_otn_server_lo_deprov_asym
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions a low order or a mid order ODU framer and 
*   recovers device resources so they are available for other provisioning 
*   operations. 
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance.
*   **lo_odu_chnl_ctxt_pptr - pointer to ODU framer to configured MO or LO ODU  
*                             container
*   **ho_odu_chnl_ctxt_pptr - pointer to ODU framer to configured HO or MO ODU 
*                             container
*   deprov_flavour          - DIGI_OTN_DEPROV_RX : deprov RX only
*                             DIGI_OTN_DEPROV_TX : deprov TX only
*                             DIGI_OTN_DEPROV_RX_AND_TX : deprov both RX/TX segement
*                                     (same as digi_otn_server_lo_deprov)
*
* OUTPUTS:
*   None.
*
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_lo_deprov_asym(digi_handle_t *digi_handle,
                                                digi_otn_odu_chnl_t **lo_odu_chnl_ctxt_pptr,
                                                digi_otn_odu_chnl_t **ho_odu_chnl_ctxt_pptr,
                                                digi_otn_asym_deprov_t deprov_flavour)
{
    PMC_ERROR result;
    
    PMC_ATOMIC_ENTRY(digi_handle);
    
    
    result = digi_otn_server_lo_deprov_internal(digi_handle,
                                                lo_odu_chnl_ctxt_pptr,
                                                ho_odu_chnl_ctxt_pptr,
                                                deprov_flavour,
                                                TRUE);
    
    
    
    PMC_ATOMIC_RETURN(digi_handle, result);

} /* digi_otn_server_lo_deprov_asym */




#ifndef DOXYGEN_PUBLIC_ONLY

/*******************************************************************************
* digi_otn_server_lo_deprov_internal
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions a low order or a mid order ODU framer and 
*   recovers device resources so they are available for other provisioning 
*   operations. 
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance.
*   **lo_odu_chnl_ctxt_pptr - pointer to ODU framer to configured MO or LO ODU  
*                             container
*   **ho_odu_chnl_ctxt_pptr - pointer to ODU framer to configured HO or MO ODU 
*                             container
*   deprov_flavour          - DIGI_OTN_DEPROV_RX : deprov RX only
*                             DIGI_OTN_DEPROV_TX : deprov TX only
*                             DIGI_OTN_DEPROV_RX_AND_TX : deprov both RX/TX segement
*                                     (same as digi_otn_server_lo_deprov)
*   deprov_ho_cfg           - TRUE : deprovision  RFRM/TFRM
*                             FALSE : preserve RFRM/TFRM configuration
*
* OUTPUTS:
*   None.
*
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_lo_deprov_internal(digi_handle_t *digi_handle,
                                                     digi_otn_odu_chnl_t **lo_odu_chnl_ctxt_pptr,
                                                     digi_otn_odu_chnl_t **ho_odu_chnl_ctxt_pptr,
                                                     digi_otn_asym_deprov_t deprov_flavour,
                                                     BOOL deprov_ho_cfg)
{
    PMC_ERROR result = PMC_SUCCESS;

    /* variable declaration */     
    digi_otn_odu_ri_rcp_dst_cfg_t rcp_cfg;
    digi_otn_mux_stages_t mux_stage = LAST_DIGI_OTN_MUX_STAGES;
    odu_struct_t *ho_odu_struct_ptr = NULL;
    odu_struct_t *lo_odu_struct_ptr = NULL;
    odu_struct_t *s3b_odu_struct_ptr = NULL;
    UINT32 ho_chnl_id;
    UINT32 lo_chnl_id;
    UINT32 i;

    BOOL8 deprov_deactivate_rx = FALSE;
    BOOL8 deprov_deactivate_tx = FALSE;
    BOOL8 last_segment = FALSE;
    
    coreotn_odu_chnl_prov_mode_t prov_mode = LAST_COREOTN_CHNL_PROV_MODE; 
    
    PMC_ENTRY();
    
    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != lo_odu_chnl_ctxt_pptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != ho_odu_chnl_ctxt_pptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(LAST_DIGI_OTN_DEPROV_NUM >= deprov_flavour, DIGI_ERR_INVALID_ARG, 0, 0);


    /* retrieve the odu_struct for this ho channel */
    ho_odu_struct_ptr = (odu_struct_t*)(*ho_odu_chnl_ctxt_pptr);
    PMC_ASSERT(ho_odu_struct_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    
    lo_odu_struct_ptr = (odu_struct_t*)(*lo_odu_chnl_ctxt_pptr);
    PMC_ASSERT(lo_odu_struct_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    
    if ((PMC_SUCCESS != digi_ho_odu_struct_handle_validate(digi_handle, *ho_odu_chnl_ctxt_pptr)) &&
        (PMC_SUCCESS != digi_mo_odu_struct_handle_validate(digi_handle, *ho_odu_chnl_ctxt_pptr)))
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    if ((PMC_SUCCESS != digi_mo_odu_struct_handle_validate(digi_handle, *lo_odu_chnl_ctxt_pptr)) &&
        (PMC_SUCCESS != digi_lo_odu_struct_handle_validate(digi_handle, *lo_odu_chnl_ctxt_pptr)))
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }


    /* retrieve ho dci channel id */
    ho_chnl_id = ho_odu_struct_ptr->mem_ptr->chnl_id;
    lo_chnl_id = lo_odu_struct_ptr->mem_ptr->chnl_id;


    /* Decide if this is the last segment to get deprovisioned */
    if(deprov_flavour == DIGI_OTN_DEPROV_RX_AND_TX)
    {
        deprov_deactivate_rx = TRUE;
        deprov_deactivate_tx = TRUE;
        last_segment = TRUE;
    }
    else if(deprov_flavour == DIGI_OTN_DEPROV_RX)
    {

        deprov_deactivate_rx = TRUE;
        deprov_deactivate_tx = FALSE;

        /* check if TX segment is still active */
        last_segment = TRUE;

        for (i = 0; i < 80; i++)
        {
            if (ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_tx[i] == lo_chnl_id)
            {
                if(ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.tx_trib_port[i] != DIGI_TRIBPORT_UNUSED)
                {
                    last_segment = FALSE;
                }
            }
        }    

    }
    else if(deprov_flavour == DIGI_OTN_DEPROV_TX)
    {

        deprov_deactivate_rx = FALSE;
        deprov_deactivate_tx = TRUE;

        /* check if RX segment is still active */
        last_segment = TRUE;

        for (i = 0; i < 80; i++)
        {
            if (ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_rx[i] == lo_chnl_id)
            {
                if(ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.rx_trib_port[i] != DIGI_TRIBPORT_UNUSED)
                {
                    last_segment = FALSE;
                }
            }
        }   

    }

    /* check if this odu_struct is an active odu_struct 
    ** return an error if not active
    */
    if (!(lo_odu_struct_ptr->active)) PMC_RETURN(DIGI_ERR_INVALID_ODU_CHNL_CTXT); 
       
    if(deprov_deactivate_rx)
    {
        if (lo_odu_struct_ptr->switch_data.oduk_data.op_state.map_state.is_input_mapped == TRUE) 
        {

            PMC_RETURN(DIGI_ERR_ODUKSW_STILL_MAPPED);
        }

        if (lo_odu_struct_ptr->mem_ptr->payload_format != (util_global_odu_line_payload_t)DIGI_ODU_UNCHANNELIZED)
        {
            if (lo_odu_struct_ptr->mem_ptr->trib_slot_ctxt.num_sub_container_rx != 0)
            {
                /* there are active LO channels in the HO, cannot deprov */
                PMC_RETURN(DIGI_ERR_INVALID_ODU_CHNL_DEPROV);
            }
        }

    }
    
    if(deprov_deactivate_tx)
    {
        if (lo_odu_struct_ptr->switch_data.oduk_data.op_state.map_state.is_output_mapped == TRUE)
        {

            PMC_RETURN(DIGI_ERR_ODUKSW_STILL_MAPPED);
        }

        if (lo_odu_struct_ptr->mem_ptr->payload_format != (util_global_odu_line_payload_t)DIGI_ODU_UNCHANNELIZED)
        {
            if (lo_odu_struct_ptr->mem_ptr->trib_slot_ctxt.num_sub_container_tx != 0)
            {
                /* there are active LO channels in the HO, cannot deprov */
                PMC_RETURN(DIGI_ERR_INVALID_ODU_CHNL_DEPROV);
            }
        }
    }
                
    s3b_odu_struct_ptr = &(digi_handle->handle_pool.s3b_odu_struct[lo_chnl_id]);
    PMC_ASSERT(s3b_odu_struct_ptr != NULL, DIGI_ERR_INVALID_PTR, 0, 0);
    
    if ((UINT32)ho_odu_struct_ptr->mem_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_HO_ODU)
    {     
        /* deprov mo channel */
        mux_stage = DIGI_OTN_MUX_STAGES_ONE;
    }
    else if ((UINT32)ho_odu_struct_ptr->mem_ptr->odu_level == (UINT32)DIGI_ODU_STRUCT_LEVEL_MO_ODU) 
    {
        /* deprov lo channels */
        mux_stage = DIGI_OTN_MUX_STAGES_TWO;
    }

    if (PMC_SUCCESS == result)
    {
        result = coreotn_odu_chnl_prov_mode_get(digi_handle->coreotn_handle,
                                                &prov_mode);
    } 

    /* PROV_STATE SHALL BE UPDATED IN THE FIRST ATOMIC SECTION */
    if (PMC_SUCCESS == result && TRUE == deprov_ho_cfg)
    {
        /* automatically disable RI_RCP port
           don't check error, the RI_RCP may not be enabled */
        digi_otn_odu_ri_rcp_extract_cfg(digi_handle,lo_odu_struct_ptr,&rcp_cfg,0,FALSE);
        digi_otn_odu_bdi_bei_biae_insert_cfg(digi_handle,lo_odu_struct_ptr,0);

        if (prov_mode == (coreotn_odu_chnl_prov_mode_t)DIGI_OTN_ODU_CHNL_PROV_IN_INCREMENT)
        {
            lo_odu_struct_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
            if (mux_stage == DIGI_OTN_MUX_STAGES_TWO
                || (mux_stage == DIGI_OTN_MUX_STAGES_ONE && lo_odu_struct_ptr->mem_ptr->payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED))
                
            {
                s3b_odu_struct_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
            }
        }
    }

    if(deprov_deactivate_tx)
    {
        if (PMC_SUCCESS == result)
        {
            result = coreotn_tx_lo_chnl_deactivate(digi_handle->coreotn_handle,
                                                   lo_chnl_id,
                                                   ho_chnl_id,
                                                   (coreotn_mux_stage_t)mux_stage);
        }


        /*clean up maintenance signal context*/
        if(lo_odu_struct_ptr->switch_data.oduk_data.lineotn_src)
        {
            if(lo_odu_struct_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_MO_ODU &&
               deprov_ho_cfg)
            {
                digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_MO_LINE, lo_chnl_id, FALSE);
            }
            else if(lo_odu_struct_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_LO_ODU)
            {
                digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_LO_LINE, lo_chnl_id, FALSE);
            }

            if(lo_odu_struct_ptr->mem_ptr->payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
            {
                digi_otn_channel_nominal_set(digi_handle, COREOTN_RX_LINE, lo_chnl_id, FALSE);
            }
        }
        else
        {
            digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_MO_SYS, lo_chnl_id, FALSE);
            
            if(lo_odu_struct_ptr->mem_ptr->payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
            {
                digi_otn_channel_nominal_set(digi_handle, COREOTN_RX_SYS, lo_chnl_id, FALSE);
            }
        }
    }

    if(deprov_deactivate_rx)
    {
        if (PMC_SUCCESS == result)
        {
            result = coreotn_rx_lo_chnl_deactivate(digi_handle->coreotn_handle,
                                                   lo_chnl_id,
                                                   ho_chnl_id,
                                                   (coreotn_mux_stage_t)mux_stage);
        }

    }

    if (PMC_SUCCESS == result && mux_stage == DIGI_OTN_MUX_STAGES_ONE &&
        (lo_odu_struct_ptr->mem_ptr->payload_format == UTIL_GLOBAL_ODU_TS_1G25 || 
         lo_odu_struct_ptr->mem_ptr->payload_format == UTIL_GLOBAL_ODU_TS_2G5 ||
         lo_odu_struct_ptr->mem_ptr->payload_format == UTIL_GLOBAL_ODU_NULL) &&
        deprov_deactivate_tx)
    {
        digi_opsa_cfg_one_fmf1_txjc_cfc_fifo_clrb(digi_handle,
                                                  lo_chnl_id,
                                                  FALSE);
    } 
     
    if (PMC_SUCCESS == result)
    {                                       
        if (mux_stage == DIGI_OTN_MUX_STAGES_ONE)
        {
            /* deprov a MO channel */
            /* remove LO channel from FMF1 */
            if(deprov_deactivate_rx)
            {
                result = coreotn_rx_lo_chnl_deprov(digi_handle->coreotn_handle,
                                                   (coreotn_mux_stage_t)mux_stage,
                                                   lo_chnl_id,
                                                   ho_chnl_id,
                                                   deprov_ho_cfg);
            }
            PMC_ATOMIC_YIELD(digi_handle,0);

            if (PMC_SUCCESS == result && deprov_deactivate_tx)
            {
                result = coreotn_tx_lo_chnl_deprov(digi_handle->coreotn_handle,
                                                   (coreotn_mux_stage_t)mux_stage,
                                                   lo_chnl_id,
                                                   ho_chnl_id,
                                                   deprov_ho_cfg);
            }

            /* if configured with SS_OPERATIONAL_MODE, deprov MO channle in FMF2 here */
            /* Already checked that MO has no children. This is safe to perform here */
            
            if (PMC_SUCCESS == result && digi_handle->var.mo_prov_state_tx[lo_chnl_id] == TRUE)
            {
                /* remove HO channel from FMF2 */
                if(deprov_deactivate_tx)
                {
                    result = coreotn_tx_ho_chnl_deactivate(digi_handle->coreotn_handle,
                                                           lo_chnl_id,
                                                           (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO);
                }

                if (PMC_SUCCESS == result && deprov_deactivate_tx)
                {
                    result = coreotn_tx_ho_chnl_deprov(digi_handle->coreotn_handle,
                                                       lo_chnl_id,
                                                       (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO,
                                                       TRUE,
                                                       TRUE);

                }

                if (PMC_SUCCESS == result && deprov_deactivate_tx)
                {

                    digi_handle->var.mo_prov_state_tx[lo_chnl_id] = FALSE; 
                }
            }


            if (PMC_SUCCESS == result && digi_handle->var.mo_prov_state_rx[lo_chnl_id] == TRUE)
            {
                
                if (deprov_deactivate_rx)
                {
                    result = coreotn_rx_ho_chnl_deactivate(digi_handle->coreotn_handle,
                                                           lo_chnl_id,
                                                           (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO);

                    if (PMC_SUCCESS == result)
                    {
                        result = coreotn_rx_ho_chnl_deprov(digi_handle->coreotn_handle,
                                                           lo_chnl_id,
                                                           (coreotn_mux_stage_t)DIGI_OTN_MUX_STAGES_TWO,
                                                           TRUE);

                    }

                    if (PMC_SUCCESS == result)
                    {
                        digi_handle->var.mo_prov_state_rx[lo_chnl_id] = FALSE;
                    }
                }
            }
                                                               

#ifdef PMC_INTERNAL_COREOTN_POWER
            /* not yet debugged */
            digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_OPTIMAL,COREOTN_ODUKP);                
#endif


            if(deprov_deactivate_tx)
            {
                if (TRUE == pmc_coreotn_schd_extra_channel_revision(&digi_handle->base))
                {
                    if (ho_chnl_id != lo_chnl_id)
                    {
                        if (PMC_SUCCESS == result)
                        {
                            result = coreotn_odtu_mux_lo_chnl_deactivate_only(digi_handle->coreotn_handle, lo_chnl_id);
                        }
                    }
                }
            }
            
            
            if(last_segment &&
               deprov_ho_cfg)
            {
                /* update payload_mode for MO channel to release */
                digi_handle->var.odu_chnl_payload[DIGI_NUM_HO_ODU_CHNL_MAX+lo_chnl_id] = LAST_DIGI_ODU_PAYLOAD_FORMAT;     
            }


        }
        else if (mux_stage == DIGI_OTN_MUX_STAGES_TWO)
        {
            /* deprov a LO channel */
            if (PMC_SUCCESS == result)
            {

                if(deprov_deactivate_rx)
                {
                    result = coreotn_rx_lo_chnl_deprov(digi_handle->coreotn_handle,
                                                       (coreotn_mux_stage_t)mux_stage,
                                                       lo_chnl_id,
                                                       ho_chnl_id,
                                                       deprov_ho_cfg);
                }
                PMC_ATOMIC_YIELD(digi_handle,0);

                if (PMC_SUCCESS == result && deprov_deactivate_tx)
                {
                    result = coreotn_tx_lo_chnl_deprov(digi_handle->coreotn_handle,
                                                       (coreotn_mux_stage_t)mux_stage,
                                                       lo_chnl_id,
                                                       ho_chnl_id,
                                                       deprov_ho_cfg);
                }
            }

            if (PMC_SUCCESS == result && prov_mode == (coreotn_odu_chnl_prov_mode_t)DIGI_OTN_ODU_CHNL_PROV_ALL)
            {
                result = coreotn_rx_mo_chnl_deactivate(digi_handle->coreotn_handle, lo_chnl_id);
            }

            if (PMC_SUCCESS == result && last_segment)
            {                
                /* update payload mode for LO channel to release */
                digi_handle->var.odu_chnl_payload[DIGI_NUM_HO_ODU_CHNL_MAX+DIGI_NUM_MO_ODU_CHNL_MAX+lo_chnl_id] = LAST_DIGI_ODU_PAYLOAD_FORMAT;
            }
            
            /* update the state of MO channel provisioning state */
        }     
    }    

    PMC_ATOMIC_YIELD(digi_handle,0);


    if (PMC_SUCCESS == result && (prov_mode == (coreotn_odu_chnl_prov_mode_t)DIGI_OTN_ODU_CHNL_PROV_IN_INCREMENT))
    { 
        
        /* update the parent odu struct */
        if(deprov_deactivate_rx)
        {
            ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.num_sub_container_rx--;
        }
    
        if (deprov_deactivate_tx)
        {
            ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.num_sub_container_tx--;
        }    
    
    
        /* free the channel id */
        for (i = 0; i < UTIL_GLOBAL_MAX_NUM_TS; i++)
        {
        
            if(deprov_deactivate_tx)
            {
                if (ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_tx[i] == lo_chnl_id)
                {
                    ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_tx[i] = DIGI_DCI_CHANNEL_UNASSIGNED;
                    ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.tx_trib_port[i] = DIGI_TRIBPORT_UNUSED;
                }
            }
        
            if(deprov_deactivate_rx)
            {
                if (ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_rx[i] == lo_chnl_id)
                {
                    ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_rx[i] = DIGI_DCI_CHANNEL_UNASSIGNED;
                    ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.rx_trib_port[i] = DIGI_TRIBPORT_UNUSED;
                }
            }
            
        }    
    
        PMC_ATOMIC_YIELD(digi_handle,0);
        /*
        ** cleaning up of the DB 
        */
  
        if(PMC_SUCCESS == result)
        {
            if (mux_stage == DIGI_OTN_MUX_STAGES_ONE)
            {
                if (deprov_deactivate_tx)
                {
                    result = coreotn_db_mo_entry_update(digi_handle->coreotn_handle,
                                                        UTIL_GEN_DB_LINE_CORE_OTN_TX_DB,  
                                                        lo_chnl_id);
                }
                PMC_ATOMIC_YIELD(digi_handle,0);
            
                if (PMC_SUCCESS == result && deprov_deactivate_rx)
                {
                    result = coreotn_db_mo_entry_update(digi_handle->coreotn_handle,  
                                                        UTIL_GEN_DB_LINE_CORE_OTN_RX_DB,  
                                                        lo_chnl_id);
                }
            
            }
            else if (mux_stage == DIGI_OTN_MUX_STAGES_TWO)
            {
                if(deprov_deactivate_tx)
                {
                    result = coreotn_db_lo_entry_update(digi_handle->coreotn_handle,  
                                                        UTIL_GEN_DB_LINE_CORE_OTN_TX_DB,  
                                                        lo_chnl_id);
                }
                PMC_ATOMIC_YIELD(digi_handle,0);
                if (PMC_SUCCESS == result && deprov_deactivate_rx)
                {
                    result = coreotn_db_lo_entry_update(digi_handle->coreotn_handle,
                                                        UTIL_GEN_DB_LINE_CORE_OTN_RX_DB,
                                                        lo_chnl_id);
                }
            }
        }
     
        /* Only clean up channel pointer context if this RX and TX segment have been provision (last_segment==TRUE) */
        if (PMC_SUCCESS == result &&
            last_segment) {
    
            /* deactivate the odu struct */
            lo_odu_struct_ptr->active = FALSE;
    
            if (digi_handle->var.otn_cfg_mode == DIGI_OTN_DIRECT_DEVICE_CONFIG) {
    
                if (mux_stage == DIGI_OTN_MUX_STAGES_TWO
                    || (mux_stage == DIGI_OTN_MUX_STAGES_ONE && lo_odu_struct_ptr->mem_ptr->payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED))
                
                {
                    /* deactivate the 3b odu_struct */
                    digi_chnl_ptr_initialize((util_global_switch_data_def_t*)s3b_odu_struct_ptr);
                    s3b_odu_struct_ptr = NULL;
                }
                
                if(deprov_ho_cfg)
                {
                    digi_chnl_ptr_initialize((util_global_switch_data_def_t*)lo_odu_struct_ptr);
                    *lo_odu_chnl_ctxt_pptr = NULL; 
                }
                
            } else {
                                                                                           
                PMC_RETURN(DIGI_ERR_NO_SW_CONTENT);

            }
        }
        else if (PMC_SUCCESS == result &&
                 FALSE == last_segment &&
                 (UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG ==
                  lo_odu_struct_ptr->switch_data.header.prov_state &&
                  TRUE == lo_odu_struct_ptr->active))
        {
            lo_odu_struct_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED;
        }
    }
        
    PMC_RETURN(result);
} /* digi_otn_server_lo_deprov_internal */

#endif /* DOXYGEN_PUBLIC_ONLY */

/*******************************************************************************
* digi_otn_server_ho_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions a high order ODU framer and recovers device
*   resources so they are available for other provisioning operations.
*
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance.
*   **odu_chnl_ctxt_pptr    - pointer to ODU framer to configured HO ODU 
*                             container
*   **otn_server_pptr       - pointer to OTU framer to configureed OTU container
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_ho_deprov(digi_handle_t *digi_handle,
                                           digi_otn_odu_chnl_t  **odu_chnl_ctxt_pptr,
                                           digi_otn_server_chnl_t **otn_server_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;

    BOOL8 is_src_sysotn_server;
    digi_otn_server_chnl_def_t *otn_server_ptr = NULL;
    odu_struct_t *ho_odu_struct_ptr = NULL;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_pptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != odu_chnl_ctxt_pptr, DIGI_ERR_INVALID_PTR, 0, 0);


    otn_server_ptr = (digi_otn_server_chnl_def_t *)(*otn_server_pptr);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);

    if (PMC_SUCCESS != digi_otn_server_chnl_handle_validate(digi_handle, *otn_server_pptr) &&
        PMC_SUCCESS != digi_sysotn_server_chnl_handle_validate(digi_handle, *otn_server_pptr))
    {       
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }
    PMC_ASSERT(otn_server_ptr->dci_chnl< DIGI_SERDES_XFI_LANES_MAX, DIGI_ERR_INVALID_ARG, otn_server_ptr->dci_chnl, 0);
    PMC_ASSERT(otn_server_ptr->dsi_base_chnl < DIGI_SERDES_XFI_LANES_MAX || 17==otn_server_ptr->dsi_base_chnl, DIGI_ERR_INVALID_ARG, otn_server_ptr->dsi_base_chnl, 0);
    PMC_ASSERT(otn_server_ptr->dsi_serdes_type <  (UINT8)LAST_LINE_OTN_DSI_TYPE , DIGI_ERR_INVALID_ARG, otn_server_ptr->dsi_base_chnl, 0);

    if (PMC_SUCCESS != digi_ho_odu_struct_handle_validate(digi_handle, *odu_chnl_ctxt_pptr) &&
        (FALSE == otn_server_ptr->sys_line_src && DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE && 
         PMC_SUCCESS != digi_lo_odu_struct_handle_validate(digi_handle, *odu_chnl_ctxt_pptr)))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }

    /* retrieve the odu_struct for this ho channel */
    ho_odu_struct_ptr = (odu_struct_t*)(*odu_chnl_ctxt_pptr);
    PMC_ASSERT(ho_odu_struct_ptr != NULL, DIGI_ERR_OOM, 0, 0);
    
    /* check if this odu_struct is an active odu_struct 
    ** return an error if not active
    */
    if (ho_odu_struct_ptr->active == FALSE) 
    {    
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ODU_CHNL_CTXT); 

    } 
    else if ((ho_odu_struct_ptr->switch_data.oduk_data.op_state.map_state.is_input_mapped == TRUE) ||
             (ho_odu_struct_ptr->switch_data.oduk_data.op_state.map_state.is_output_mapped == TRUE)) 
    {
        PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_ODUKSW_STILL_MAPPED);

    } 
    else if (ho_odu_struct_ptr->mem_ptr->payload_format != (util_global_odu_line_payload_t)DIGI_ODU_UNCHANNELIZED) 
    {  
        /* check if there are any sub-structures within this HO channel */
        if (ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.num_sub_container_rx != 0 ||
            ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.num_sub_container_tx != 0)
        {
            /* there are active LO channels in the HO, cannot deprov */
            PMC_ATOMIC_RETURN(digi_handle,DIGI_ERR_INVALID_ODU_CHNL_DEPROV);
        }
    }

    /* first look up to see if the server is sourced from LINEOTN or SYSOTN */
    is_src_sysotn_server = otn_server_ptr->sys_line_src;

    /* LINEOTN */
    if (is_src_sysotn_server == FALSE) 
    {
        /* is this a SYSOTN application ? */
        if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE) 
        { 

            /* For SYSOTN applications were server is source from LINEOTN.
               This should de-provision the ODUKSW <-> LINEOTN segment */


            result = digi_otn_server_ho_sysapp_internal_deprov(digi_handle,
                                                               odu_chnl_ctxt_pptr,
                                                               otn_server_ptr);

        } 
        else 
        { /* FALSE */

            result = digi_otn_server_ho_internal_deprov(digi_handle,
                                                        odu_chnl_ctxt_pptr,
                                                        otn_server_ptr,
                                                        is_src_sysotn_server,
                                                        TRUE,
                                                        TRUE);

        }

        /* SYSOTN */
    } 
    else 
    { /* TRUE */
       
        /* de-provision the COREOTN HO segment (SYSOTN -> COREOTN HO in FMF2) */
        result = digi_otn_server_ho_internal_deprov(digi_handle,
                                                    odu_chnl_ctxt_pptr,
                                                    otn_server_ptr,
                                                    is_src_sysotn_server,
                                                    TRUE,
                                                    TRUE);

    }
    /* deactivate the odu struct */
    ho_odu_struct_ptr->active = FALSE;

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_otn_server_ho_deprov */

/*******************************************************************************
* digi_otn_server_line_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions resources associated with Serdes, LINEOTN and
*   COREOTN first state framer that were previously provisioned for processing
*   a signal.\n\n
*
*  Following this call the freed resources are available for use by future
*  provision operations
*
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*
*   **otn_server_pptr      - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.

* OUTPUTS:
*   None.
*
* RETURNS: 
*   PMC_SUCCESS - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_line_deprov( digi_handle_t *digi_handle,
                                              digi_otn_server_chnl_t **otn_server_pptr)

{
    PMC_ERROR   rc = PMC_SUCCESS;
    
    BOOL        dsi_state_configured = FALSE;
    digi_otn_server_chnl_def_t* otn_server_ptr=NULL;
    digi_post_mld_dsi_ctxt_t *p_post_mld_lanes = NULL;
    digi_serdes_port_t* port_ctxt_ptr = NULL;
    digi_serdes_port_rate_prov_state_t serdes_port_prov_state;  
    digi_serdes_prov_state_t prov_state;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_pptr, DIGI_ERR_NULL_HANDLE, 0, 0);

    otn_server_ptr = (digi_otn_server_chnl_def_t*)(*otn_server_pptr);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(otn_server_ptr->dci_chnl< DIGI_SERDES_XFI_LANES_MAX, DIGI_ERR_INVALID_ARG, otn_server_ptr->dci_chnl, 0);
    PMC_ASSERT(otn_server_ptr->dsi_base_chnl < DIGI_SERDES_XFI_LANES_MAX || 17==otn_server_ptr->dsi_base_chnl, DIGI_ERR_INVALID_ARG, otn_server_ptr->dsi_base_chnl, 0);
    PMC_ASSERT(otn_server_ptr->dsi_serdes_type <  (UINT8)LAST_LINE_OTN_DSI_TYPE , DIGI_ERR_INVALID_ARG, otn_server_ptr->dsi_base_chnl, 0);
    
    if (PMC_SUCCESS != digi_otn_server_chnl_handle_validate(digi_handle, *otn_server_pptr))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }

    /* check if the associated COREOTN HO channel has been deprovisioned properly */
    if (otn_server_ptr->sys_line_src == FALSE && DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE)
    {
        /* LINE side in SYSOTN application so check lo_odu_struct */
        if (digi_handle->handle_pool.lo_odu_struct[otn_server_ptr->dci_chnl].switch_data.header.prov_state 
            == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG)
        {
            rc = PMC_SUCCESS;
        }
        else {
            rc = DIGI_ERR_HO_ODU_STILL_PROVISIONED;
        }
    }
    else {
        if (digi_handle->handle_pool.ho_odu_struct[otn_server_ptr->dci_chnl].switch_data.header.prov_state 
            == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG)
        {
            rc = PMC_SUCCESS;
        }
        else {
            rc = DIGI_ERR_HO_ODU_STILL_PROVISIONED;
        }
    }

    if (PMC_SUCCESS == rc)
    {
        port_ctxt_ptr = digi_port_ctxt_no_type_find(digi_handle, otn_server_ptr->port_uid);

        if (port_ctxt_ptr == NULL) {

            PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, otn_server_ptr->port_uid, 0);

        } 
    }

    if (PMC_SUCCESS == rc) {
        rc = digi_by_port_uid_post_mld_prov_state_get(digi_handle, 
                                                      otn_server_ptr->port_uid,
                                                      &prov_state);
        PMC_ASSERT(PMC_SUCCESS == rc, DIGI_ERR_INVALID_ARG, otn_server_ptr->port_uid, 0);

    }

    if (PMC_SUCCESS == rc) {
        
        PMC_ASSERT(prov_state == DIGI_SERDES_PROV_STATE_LINEOTN, DIGI_ERR_INVALID_ARG, otn_server_ptr->port_uid, prov_state);

        /* check if we have an active loopback on this segment */
        /* CHECK SERDES LOOPBACK */
        serdes_port_prov_state = digi_serdes_port_prov_status_get(digi_handle, ((digi_serdes_port_def_t*)(port_ctxt_ptr))->port_uid); 
        if (DIGI_SERDES_PORT_RATE_STATE_PROV_FACILITY_LPBK == serdes_port_prov_state || DIGI_SERDES_PORT_RATE_STATE_PROV_DIAG_LPBK == serdes_port_prov_state) 
        { 
            rc = DIGI_ERR_LOOPBACK_STILL_ACTIVE; 
        } 
        /* CHECK LINEOTN LOOPBACK */
        if (PMC_SUCCESS == rc)
        {
            if (TRUE == otn_server_ptr->loopback_enabled)
            {
                rc = DIGI_ERR_LOOPBACK_STILL_ACTIVE; 
            }
        }
    }

    /* PROV_STATE SHALL BE UPDATED IN THE FIRST ATOMIC SECTION */
    if (PMC_SUCCESS == rc)
    {
        otn_server_ptr->header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
        digi_otn_channel_nominal_set(digi_handle, LINEOTN_TX, otn_server_ptr->dci_chnl, FALSE);
    }

    /* Configure LOF monitoring in FW */
    if ( PMC_SUCCESS == rc &&
         TRUE == pmc_lof_monitoring_in_fw(&digi_handle->base))
    {
        rc = lineotn_lof_mon_fw_cfg(digi_handle->lineotn_handle,
                                    otn_server_ptr->dsi_base_chnl,
                                    (lineotn_dsi_type_t)otn_server_ptr->dsi_serdes_type,
                                    FALSE);
    }
    PMC_ATOMIC_YIELD(digi_handle,0);
    if(PMC_SUCCESS == rc) 
    {
        /* deprovision stream, which includes any provisioned FEC */
        rc = lineotn_stream_deprov(digi_handle->lineotn_handle,otn_server_ptr->dsi_base_chnl,(lineotn_dsi_type_t)otn_server_ptr->dsi_serdes_type);
        PMC_ATOMIC_YIELD(digi_handle,0);
        /* determine state of the LINEOTN SS and if no resources provisioned bring SS to lowpwr/reset state */
        if(PMC_SUCCESS==rc)
        {
            digi_lineotn_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
            PMC_ATOMIC_YIELD(digi_handle,0);
        }

    }

    /* Configure PMON related items for FEC */
    if ( PMC_SUCCESS == rc )
    {
        rc = digi_pmon_fw_fec_cfg(digi_handle);
        PMC_ATOMIC_YIELD(digi_handle,0);
    }

    if(PMC_SUCCESS == rc) {
        /* deactivate SerDes Port and put in lowest energy state */
        rc = digi_serdes_port_deprov(digi_handle, port_ctxt_ptr);
        PMC_ATOMIC_YIELD(digi_handle,0);
        if(PMC_SUCCESS == rc)
        {
            /* last step - update the prov state with unassigned status */
            p_post_mld_lanes=digi_first_post_mld_dsi_find(digi_handle,otn_server_ptr->port_uid);
            
            if( p_post_mld_lanes != NULL )
            {
                if( DIGI_SERDES_PROV_STATE_LINEOTN == p_post_mld_lanes->prov_state )  /* port found - check that it is configured and assigned to lineotn */
                {

                    rc = digi_serdes_port_lifd_sifd_subsytem_disable(digi_handle,
                                                                     otn_server_ptr->port_uid);
                    /* We should never get here as this means our state is corrupt */
                    PMC_ASSERT(PMC_SUCCESS == rc, rc, 0, 0);
                    
                    if (PMC_SUCCESS == rc) {
                        rc = digi_post_mld_prov_state_set(digi_handle,otn_server_ptr->port_uid,DIGI_SERDES_PROV_STATE_UNASSIGNED); /* if this is lineotn port - unassign it  */
                        if(PMC_SUCCESS == rc)
                        {

                            rc = digi_serdes_port_rate_state_set(digi_handle, 
                                                                 port_ctxt_ptr, 
                                                                 LAST_DIGI_SERDES_PORT_MODE, 
                                                                 DIGI_SERDES_PROV_STATE_UNASSIGNED, 
                                                                 DIGI_SERDES_PORT_RATE_STATE_DEPROV);
                            
                            if (PMC_SUCCESS == rc)
                            {
                                dsi_state_configured = TRUE;
                            }
                        }
                        else
                            rc = DIGI_ERR_INVALID_ARG; /* this is not a lineotn port/dsi lane or,serdes is not initialized or,already provisioned as lineotn - exit */

                    }
                }
                else
                    rc = DIGI_ERR_NO_DSI_ALLOC_PROV; 
            }
            else
                rc = DIGI_ERR_NO_DSI_ALLOC_PROV;

            if(!dsi_state_configured) /* we did not find the specified port number */
                rc = DIGI_ERR_INVALID_ARG;  /* if we got to this line - this a bug, exit and report */

            /* reset digi_otn_server_chnl_t memeory */
            otn_server_ptr->header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;
            *otn_server_pptr = NULL;
        }

        if(PMC_SUCCESS == rc)
        {
            digi_dcsu_conditional_uninit(digi_handle, DIGI_DCSU_INST_OTN2);
        }

    }


    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_otn_server_line_deprov */

/*******************************************************************************
* digi_otn_server_sys_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions resources associated with System Serdes, SYSOTN and
*   COREOTN first state framer that were previously provisioned for processing
*   a signal.\n\n
*
*  Following this call the freed resources are available for use by future
*  provision operations
*
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*
*   **otn_server_pptr      - Pointer to a pointer to a resource allocation
*                            context for the OTN server configured against the
*                            specified serdes port.

* OUTPUTS:
*   None.
*
* RETURNS: 
*   PMC_SUCCESS - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_sys_deprov(digi_handle_t *digi_handle,
                                            digi_otn_server_chnl_t **otn_server_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;

    lineotn_handle_t* sysotn_handle;
    digi_otn_server_chnl_def_t* otn_server_ptr;

    UINT32 dsi_stream;
    lineotn_dsi_type_t dsi_type;
    UINT32 port_uid;

    digi_serdes_prov_state_t prov_state;
    digi_serdes_port_t* port_ctxt_ptr;
    digi_serdes_port_rate_prov_state_t serdes_port_prov_state;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* Check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != otn_server_pptr, DIGI_ERR_NULL_HANDLE, 0, 0);


    otn_server_ptr = (digi_otn_server_chnl_def_t*)(*otn_server_pptr);
    PMC_ASSERT(NULL != otn_server_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);

    if (PMC_SUCCESS != digi_sysotn_server_chnl_handle_validate(digi_handle, *otn_server_pptr))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG);
    }

    DIGI_CHNL_HANDLE_MAGIC_CHECK(otn_server_ptr);

    /* Set some local variables that are used more than once.*/
    sysotn_handle = digi_handle->sysotn_handle;
    dsi_stream = otn_server_ptr->dsi_base_chnl; 
    dsi_type = (lineotn_dsi_type_t)otn_server_ptr->dsi_serdes_type;
    port_uid = otn_server_ptr->port_uid;
    PMC_ASSERT((dsi_stream < DIGI_SERDES_XFI_LANES_MAX) || (17 == dsi_stream), DIGI_ERR_INVALID_ARG, dsi_stream, 0);

    /* Find port_ctxt_ptr from otn_server_ptr */
    port_ctxt_ptr = digi_port_ctxt_no_type_find(digi_handle, port_uid);

    if (port_ctxt_ptr == NULL) {

        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, port_uid, 0);

    } else if (digi_by_port_uid_post_mld_prov_state_get(digi_handle, 
                                                        port_uid,
                                                        &prov_state) != PMC_SUCCESS) {

        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, port_uid, 0);

    } else if (prov_state != DIGI_SERDES_PROV_STATE_SYSOTN) {

        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, port_uid, prov_state);

    } else {
        /* check if we have an active loopback on this segment */
        serdes_port_prov_state = digi_serdes_port_prov_status_get (digi_handle, port_uid);

        if ((serdes_port_prov_state == DIGI_SERDES_PORT_RATE_STATE_PROV_FACILITY_LPBK) || 
            (serdes_port_prov_state == DIGI_SERDES_PORT_RATE_STATE_PROV_DIAG_LPBK)) {

            result = DIGI_ERR_LOOPBACK_STILL_ACTIVE;
        }
        else if (DIGI_SERDES_PORT_RATE_STATE_PROV != serdes_port_prov_state)
        {
            result = DIGI_ERR_SERDES_PORT_NOT_PROV;
        }

        /* PROV_STATE SHALL BE UPDATED IN THE FIRST ATOMIC SECTION */
        if (PMC_SUCCESS == result)
        {
            otn_server_ptr->header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
            digi_otn_channel_nominal_set(digi_handle, SYSOTN_TX, otn_server_ptr->dci_chnl, FALSE);
        }

        /* Configure LOF monitoring in FW */
        if (result == PMC_SUCCESS &&
            TRUE == pmc_lof_monitoring_in_fw(&digi_handle->base))
        {
            result = lineotn_lof_mon_fw_cfg(sysotn_handle,
                                            dsi_stream,
                                            dsi_type,
                                            FALSE);
            PMC_ATOMIC_YIELD(digi_handle,0);
        }

        /* remove any configured FEC */
        if (result == PMC_SUCCESS) {

            result = lineotn_fec_cfg(sysotn_handle,
                                     dsi_stream,
                                     dsi_type,
                                     LINE_OTN_FEC_NONE);
            PMC_ATOMIC_YIELD(digi_handle,0);
        }

        /* deprovision data stream */
        if (result == PMC_SUCCESS) {

            result = lineotn_stream_deprov(sysotn_handle,
                                           dsi_stream,
                                           dsi_type);
            PMC_ATOMIC_YIELD(digi_handle,0);
        }

        /* Deactivate SERDES PORT and put in lowest energy state. */
        if (result == PMC_SUCCESS) {

            result = digi_serdes_port_deprov(digi_handle,
                                             port_ctxt_ptr);
            PMC_ATOMIC_YIELD(digi_handle,0);
            /* update serdes rate state */
            if (result == PMC_SUCCESS) {

                result = digi_serdes_port_rate_state_set(digi_handle, 
                                                         port_ctxt_ptr, 
                                                         LAST_DIGI_SERDES_PORT_MODE, 
                                                         DIGI_SERDES_PROV_STATE_UNASSIGNED, 
                                                         DIGI_SERDES_PORT_RATE_STATE_DEPROV);
            }

            /* update the post mld prov state */
            if (result == PMC_SUCCESS) {

                result = digi_post_mld_prov_state_set(digi_handle,
                                                      port_uid,
                                                      DIGI_SERDES_PROV_STATE_UNASSIGNED);
            }
        }

        /* Disable the lifd sifd subsystem */
        if (result == PMC_SUCCESS) {

            result = digi_serdes_port_lifd_sifd_subsytem_disable(digi_handle,
                                                                 port_uid);
        }
        PMC_ATOMIC_YIELD(digi_handle,0);
        /* change energy state to OPTIMAL */
        if (result == PMC_SUCCESS) {

            /* This function returns void */
            digi_sysotn_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
        }

        /* reset digi_otn_server_chnl_t memeory */
        if (result == PMC_SUCCESS) {

            otn_server_ptr->header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;
            *otn_server_pptr = NULL;
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_otn_server_sys_deprov */














/*******************************************************************************
* digi_reg_read
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Read DIGI data.
*
*
* INPUTS:
*   digi_handle - pointer to DIGI handle instance.
*   vaddr       - chip address from which to read data from. Note that this
*                 address is relative to base address of the chip.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32 - value read from vaddr
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_reg_read(digi_handle_t *digi_handle, UINT32 vaddr)
{
    UINT32 value;

    PMC_ATOMIC_ENTRY(digi_handle);
    value = digi_reg_read_internal(digi_handle, vaddr);
    PMC_ATOMIC_RETURN(digi_handle,value);
}

/*******************************************************************************
* digi_mem_write
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Write DIGI data. Note that this function utilizes the porting interface
*   pmc_sys_mem_write() which typically does not perform an endian swap since
*   the data is considered a byte array.
*
* INPUTS:
*   digi_handle - pointer to DIGI handle instance.
*   vaddr       - chip address to which to write data. Note that this
*                 address is relative to base address of the chip.
*   len         - number of bytes to write
*   data_ptr    - pointer to data store provided by the caller.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_mem_write(digi_handle_t *digi_handle, UINT32 vaddr, UINT32 len, UINT8 *data_ptr)
{    
#ifdef PMC_TESTS 
    PMC_ATOMIC_ENTRY_VOID(digi_handle);
#else 
    PMC_ATOMIC_ENTRY(digi_handle);
#endif

    digi_mem_write_internal(digi_handle, vaddr, len,data_ptr);

    PMC_ATOMIC_RETURN(digi_handle);
}

/*******************************************************************************
* digi_reg_write
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Write a DIGI register. Note that this function utilizes the porting interface
*   pmc_sys_reg_write() which may perform a system dependent endian swap.
*
* INPUTS:
*   digi_handle - pointer to DIGI handle instance.
*   vaddr       - chip address to which to write data. Note that this
*                 address is relative to base address of the chip.
*   data        - data to write.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_reg_write(digi_handle_t *digi_handle, UINT32 vaddr, UINT32 data)
{    
    pmc_sys_handle_t *hndl;
#ifdef PMC_TESTS 
    PMC_ATOMIC_ENTRY_VOID(digi_handle);
#else 
    PMC_ATOMIC_ENTRY(digi_handle);
#endif

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->base.sys_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    hndl = digi_handle->base.sys_handle;
    pmc_sys_reg_write(hndl, vaddr, data);

    PMC_ATOMIC_RETURN(digi_handle);
}

#ifndef DOXYGEN_PUBLIC_ONLY
/*******************************************************************************
* digi_event_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Initialize digi event subsystem. The caller should configure the 
*   event_cfg structure before calling this function. \n
*   The stucture contains the following fields:\n
*       -forever              - Run the event loop while forever=TRUE
*       -polling_mode         - if TRUE use polling, if False use interrupts.
*       -polling_mode_wait_us - Polling mode delay
*       -cb                   - Event callback function.
*       -cb_paramter;         - Parameter to pass to the callback function. \n
*
* INPUTS:
*   digi_handle   - pointer to DIGI handle instance.
*   event_cfg_ptr - pointer to the event_cfg structure.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_event_init(digi_handle_t *digi_handle, digi_event_cfg_t *event_cfg_ptr)
{
    PMC_ENTRY();
    /* 
     * If polling, digi_event_loop directly polls the int status 
     * For interrupt mode, initialize pmc_sys event handling 
     */
    PMC_ASSERT(event_cfg_ptr->cb != NULL,DIGI_ERR_INVALID_ARG,0,0);
    if(event_cfg_ptr->polling_mode == FALSE) 
    {
        pmc_sys_event_init(digi_handle->base.sys_handle);
        pmc_sys_event_register(digi_handle->base.sys_handle, event_cfg_ptr);
    }

    PMC_RETURN();
}

/*******************************************************************************
* digi_event_destroy
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Destroy digi event subsystem.
*
*
* INPUTS:
*   digi_handle - pointer to DIGI handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_event_destroy(digi_handle_t *digi_handle)
{
    PMC_ENTRY();

    pmc_sys_event_destroy(digi_handle->base.sys_handle);

    PMC_RETURN();
}

/*******************************************************************************
* digi_event_monitor
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Monitor interrupt events either by polling the interrupt status register
*   or by using interrupts.
*
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   event_cfg_ptr   - Event configuration (polling mode/interrupt)
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_event_monitor(digi_handle_t *digi_handle, digi_event_cfg_t * event_cfg_ptr)
{
    UINT32 value = 0;
    UINT32 irq_mask = PCIE_OB_IRQ_MASK; /* IPI + SS_INT[1] */

    PMC_ENTRY();

    if(event_cfg_ptr->polling_mode == TRUE)
    {
        /* Directly read top level register containing event information. */
        do
        {
            PMC_OS_USLEEP(event_cfg_ptr->polling_mode_wait_us);
            /* If value read is not zero, call the registered callback. */
            value = digi_reg_read_internal(digi_handle, PCIE_OB_IRQ_RSTAT_REG);
            if((value & irq_mask) != 0 )
            {
                event_cfg_ptr->cb(event_cfg_ptr->cb_parameter);
            }
        } while(event_cfg_ptr->forever);
    }
    else
    {
        /* Do kernel assisted event monitoring. */
        pmc_sys_event_monitor(digi_handle->base.sys_handle, event_cfg_ptr);
    }

    PMC_RETURN();
}


/*******************************************************************************
* digi_mem_write_internal
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Write DIGI data. Note that this function utilizes the porting interface
*   pmc_sys_mem_write() which typically does not perform an endian swap since
*   the data is considered a byte array.
*
* INPUTS:
*   digi_handle - pointer to DIGI handle instance.
*   vaddr       - chip address to which to write data. Note that this
*                 address is relative to base address of the chip.
*   len         - number of bytes to write
*   data_ptr    - pointer to data store provided by the caller.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*    This function does not require PMC_ENTRY or PMC_RETURN do to its high call
*    rate.
*
*******************************************************************************/
PUBLIC void digi_mem_write_internal(digi_handle_t *digi_handle, UINT32 vaddr, UINT32 len, UINT8 *data_ptr)
{    
    pmc_sys_handle_t *hndl = NULL;
    PMC_ENTRY();

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->base.sys_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    hndl = digi_handle->base.sys_handle;

    pmc_sys_mem_write(hndl, vaddr, len, data_ptr);

    PMC_RETURN();
}

/*******************************************************************************
* FUNCTION: digi_int_param_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks digi interrupt input parameters with interrupt table pointer
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - channel handle to check if provisioned. Can be NULL.
*   int_type        - interrupt table type
*   int_table_ptr   - pointer to interrupt table. Can be NULL.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_int_param_check(digi_handle_t    *digi_handle,
                                      void             *chnl_handle,
                                      digi_int_type_t   int_type,
                                      void             *int_table_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
   
    if (int_type >= LAST_DIGI_INT_TYPE)
    {
        result = DIGI_ERR_INVALID_ARG;
    }

    
    if (NULL != chnl_handle)
    {
        if (int_type != DIGI_INT_LINK_TYPE_SIFD && 
            !util_global_is_chnl_prov(chnl_handle))
        {
            PMC_RETURN(DIGI_ERR_PMON_CHNL_NOT_PROV);
        }
    }


    PMC_RETURN(result);
} /* digi_int_param_check */


/*******************************************************************************
* FUNCTION: digi_int_chnl_param_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks digi interrupt chnl operator input parameters with interrupt table pointer
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   chnl_handle     - channel handle to check if provisioned.
*   int_type        - interrupt table type
*   int_table_ptr   - pointer to interrupt table.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_int_chnl_param_check(digi_handle_t    *digi_handle,
                                           void             *chnl_handle,
                                           digi_int_type_t   int_type,
                                           void             *int_table_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
   
    if (int_type >= LAST_DIGI_INT_TYPE)
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    
    if (NULL == chnl_handle)
    {
        PMC_RETURN(DIGI_ERR_NULL_HANDLE);
    }
    
    if (NULL == int_table_ptr)
    {
        PMC_RETURN(DIGI_ERR_NULL_HANDLE);
    }

    DIGI_CHNL_HANDLE_MAGIC_CHECK(chnl_handle);

    if (!util_global_is_chnl_prov(chnl_handle))
    {
        PMC_RETURN(DIGI_ERR_PMON_CHNL_NOT_PROV);
    }

    PMC_RETURN(result);
} /* digi_int_chnl_param_check */


/*******************************************************************************
* FUNCTION: digi_int_link_range_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Determines the range of links to retrieve interrupts for based on channel
*   handle and interrupt type.
*
* INPUTS:
*   digi_handle     - Pointer to subsystem handle
*   chnl_handle     - Pointer to channel handle
*   int_type        - Interrupt type
*
* OUTPUTS:
*   start_link      - Start link to retrieve
*   end_link        - End link to retrieve
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_int_link_range_get(digi_handle_t      *digi_handle,
                                         void               *chnl_handle,
                                         digi_int_type_t     int_type,
                                         UINT32             *start_link,
                                         UINT32             *end_link)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();
    
    if (DIGI_INT_TYPE_DEVICE == int_type)
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    if (int_type >= LAST_DIGI_INT_TYPE)
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    if ((NULL == start_link) || (NULL == end_link))
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }


    switch (int_type)
    {
    case DIGI_INT_TYPE_ENET_LINE:
    case DIGI_INT_TYPE_ENET_SYS:
    case DIGI_INT_CHNL_TYPE_ENET_LINE:
    case DIGI_INT_CHNL_TYPE_ENET_SYS:
        if (IS_DIGI_INT_ALL_CHNLS(chnl_handle))
        {
            *start_link  = 0;
            *end_link    = DIGI_ENET_CHNL_MAX;
        }
        else
        {
            result = digi_enet_channel_num_get(digi_handle,
                                               (digi_enet_client_chnl_t *) chnl_handle,
                                               start_link);
            if (PMC_SUCCESS == result)
            {
                *end_link    = *start_link + 1;
            }
        }
        break;
            
    case DIGI_INT_TYPE_CBR:
    case DIGI_INT_CHNL_TYPE_CBR:
        if (IS_DIGI_INT_ALL_CHNLS(chnl_handle))
        {
            *start_link  = 0;
            *end_link    = CBRC_MAX_CHANNELS;
        }
        else
        {           
            *start_link  = digi_cbr_channel_num_get(digi_handle,
                                                    (digi_cbr_client_chnl_t *) chnl_handle);
            *end_link    = *start_link + 1;
        }
        break;

    case DIGI_INT_TYPE_OTN_MAPPER:
    case DIGI_INT_CHNL_TYPE_OTN_MAPPER:
    case DIGI_INT_CHNL_TYPE_OTN_MAPPER_ENET_ETRANS:
    case DIGI_INT_CHNL_TYPE_OTN_MAPPER_ENET_PMON:
        if (IS_DIGI_INT_ALL_CHNLS(chnl_handle))
        {
            *start_link  = 0;
            *end_link    = DIGI_MAPOTN_CHNL_MAX;
        }
        else
        {
            digi_mapper_channel_num_get(digi_handle,
                                        (digi_mapper_chnl_t *) chnl_handle,
                                        start_link,
                                        NULL,
                                        NULL,
                                        NULL);
            *end_link    = *start_link + 1;
        }
        break;

    case DIGI_INT_CHNL_TYPE_OTN_SERVER:
        if (IS_DIGI_INT_ALL_CHNLS(chnl_handle))
        {
            *start_link  = 0;
            *end_link    = DIGI_OTN_SERVER_CHNL_MAX;
        }
        else
        {
            *start_link  = digi_lineotn_dci_chnl_get(digi_handle,
                                                     (digi_otn_server_chnl_t *) chnl_handle);
            *end_link    = *start_link + 1;
        }
        break;
    case DIGI_INT_CHNL_TYPE_OTN_SERVER_SYS:
        if (IS_DIGI_INT_ALL_CHNLS(chnl_handle))
        {
            *start_link  = 0;
            *end_link    = DIGI_OTN_SERVER_SYS_CHNL_MAX;
        }
        else
        {
            *start_link  = digi_lineotn_dci_chnl_get(digi_handle,
                                                     (digi_otn_server_chnl_t *) chnl_handle);
            *end_link    = *start_link + 1;
        }
        break;

    case DIGI_INT_CHNL_TYPE_OTN_ODU:
        /* digi_otn_odu_int_link_range_get() handles this for ODU handles */
        result = DIGI_ERR_NO_SW_CONTENT;
        break;

    case DIGI_INT_CHNL_TYPE_CPB:
        break;
    
    case DIGI_INT_TYPE_SIFD:
    case DIGI_INT_LINK_TYPE_SIFD:
        if (IS_DIGI_INT_ALL_CHNLS(chnl_handle))
        {
            *start_link  = 0;
            *end_link    = DIGI_SIFD_ILKN_NUM;
        }
        else
        {
            *start_link  = digi_sifd_inst_get(digi_handle, (digi_ilkn_link_t*) chnl_handle);
            *end_link    = *start_link + 1;
        }
        break;
        
    case DIGI_INT_CHNL_TYPE_SIFD_ENET_PMON:
        if (IS_DIGI_INT_ALL_CHNLS(chnl_handle))
        {
            *start_link  = 0;
            *end_link = DIGI_ENET_CHNL_MAX;
        }
        else
        {
            result  = digi_sifd_chnl_index_get(digi_handle, (digi_ilkn_chnl_t*) chnl_handle, start_link);
            /*
             * For the individual channel case need to extract the pmon
             * data handle and extract the channel value used in that
             * handle to ensure that the start/end link is in 0-11 range
             * and not 0-254 range as it would be if returning the ilkn
             * channel value.
             */

            if (PMC_SUCCESS == result && ((digi_ilkn_chnl_def_t*)chnl_handle)->enet_pmon_data)
            {
                enet_handle_t  *enet_ptr;
                result = digi_sifd_enet_pmon_handle_get(digi_handle,
                                                        (digi_ilkn_chnl_def_t *)chnl_handle,
                                                        &enet_ptr,
                                                        start_link);
                /*
                 * Note that digi_sifd_enet_pmon_handle_get does not ever
                 * return error.  If there was an error enet_ptr is set to
                 * NULL so check that it is valid. Otherwise reset the 
                 * start and end links to 0.
                 */
                if (PMC_SUCCESS == result && NULL != enet_ptr)
                {
                    *end_link = *start_link + 1;
                }
                else
                {
                    *start_link = 0;
                    *end_link = 0;
                    result = DIGI_ERR_INVALID_ARG;
                }
            }
            else
            {
                *start_link = 0;
                *end_link = 0;
            }
        }
        break;
        
        
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, int_type, LAST_DIGI_INT_TYPE);
        break;
    } /* end switch */
    


    PMC_RETURN(result);
} /* digi_int_link_range_get */




/*******************************************************************************
* FUNCTION: digi_int_en_table_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves internal enabled interrupts table for aggregation interrupt types.
*
* INPUTS:
*   digi_handle     - Pointer to subsystem handle
*   int_type        - Aggregated interrupt type
*
* OUTPUTS:
*  int_en_table_pptr - Pointer to enabled interrupt aggregated table
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_int_en_table_get(digi_handle_t        *digi_handle,
                                       digi_int_type_t       int_type,
                                       void                **int_en_table_pptr)
{
    PMC_ERROR           result = PMC_SUCCESS;
    digi_int_t         *digi_enabled_ptr;

    PMC_ENTRY();
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    if (int_type >= LAST_DIGI_INT_TYPE)
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    if (IS_DIGI_INT_CHNL_TYPE(int_type))
    {
        PMC_RETURN(DIGI_ERR_INT_ONLY_AGG_TYPE_ALLOWED);
    }

    if (NULL == int_en_table_pptr)
    {
        PMC_RETURN(DIGI_ERR_NULL_HANDLE);
    }

    digi_enabled_ptr = digi_handle->var.enabled_int;

    switch (int_type)
    {
    case DIGI_INT_TYPE_DEVICE:
        *int_en_table_pptr = (void *) &digi_enabled_ptr->device;
        break;

    case DIGI_INT_TYPE_PMON:
        *int_en_table_pptr = (void *) &digi_enabled_ptr->pmon;
        break;

    case DIGI_INT_TYPE_ENET_LINE:
        *int_en_table_pptr = (void *) &digi_enabled_ptr->enet_line;
        break;
        
    case DIGI_INT_TYPE_ENET_SYS:
        *int_en_table_pptr = (void *) &digi_enabled_ptr->enet_sys;
        break;
            
    case DIGI_INT_TYPE_CBR:
        *int_en_table_pptr = (void *) &digi_enabled_ptr->cbr;
        break;

    case DIGI_INT_TYPE_OTN_MAPPER:
        *int_en_table_pptr = (void *) &digi_enabled_ptr->mapper;
        break;

    case DIGI_INT_TYPE_OTN:
        *int_en_table_pptr = (void *) &digi_enabled_ptr->otn;
        break;
      
    case DIGI_INT_TYPE_SIFD:
        *int_en_table_pptr = (void *) &digi_enabled_ptr->sifd;
        break;

    case DIGI_INT_TYPE_CPB:
        PMC_ASSERT(FALSE, DIGI_ERR_NO_SW_CONTENT, 0, 0);
        break;

    default:
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, int_type, LAST_DIGI_INT_TYPE);
        break;
    } /* end switch */

    PMC_RETURN(result);
} /* digi_int_en_table_get */

/*******************************************************************************
* FUNCTION: digi_int_info_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retreives the internal interrupt info for the interrupt type 
*
* INPUTS:
*   digi_handle      - Pointer to digi handle
*   int_type         - aggregation or channel interrupt table type to retrieve
*
*
* OUTPUTS:
*   int_info_pptr    - pointer to internal interrupt info
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_int_info_get(digi_handle_t    *digi_handle,
                                   digi_int_type_t   int_type,
                                   digi_int_info_t **int_info_pptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    result = digi_int_param_check(digi_handle, NULL, int_type, int_info_pptr);

    if (PMC_SUCCESS == result)
    {
        *int_info_pptr = &digi_handle->var.int_info_ary->int_info[int_type];
    }

    PMC_RETURN(result);
} /* digi_int_info_get */

/*******************************************************************************
* FUNCTION: digi_int_is_cb_registered()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks if a user callback is registered for the provided interrupt type
*
* INPUTS:
*   digi_handle      - Pointer to digi handle
*   int_type         - aggregation or channel interrupt table type
*
* OUTPUTS:
*
* RETURNS:
*   BOOL -  TRUE: user callback exists for this int_type\n
*           FALSE: user callback does not exist for this int_type
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL digi_int_is_cb_registered(digi_handle_t    *digi_handle,
                                      digi_int_type_t   int_type)
{
    PMC_ERROR            result = PMC_SUCCESS;
    digi_int_info_t     *int_info_ptr;

    PMC_ENTRY();
    

    if (PMC_SUCCESS == result)
    {
        result = digi_int_info_get(digi_handle, int_type, &int_info_ptr);
    }


    if (PMC_SUCCESS == result)
    {
        if (NULL == int_info_ptr->user_cb)
        {
            PMC_RETURN(FALSE);
        }
        else
        {
            PMC_RETURN(TRUE);
        }
    }

    PMC_RETURN(FALSE);
} /* digi_int_is_cb_registered */

/*******************************************************************************
* FUNCTION: digi_int_is_any_cb_registered()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks if at least one interrupt type has a callback registed.  
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*
* OUTPUTS:
*
* RETURNS:
*   TRUE            - At least one interrupt type has a callback registered.\n
*   FALSE           - No callbacks are registered for any interrupt types
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_int_is_any_cb_registered(digi_handle_t    *digi_handle)
{
    UINT32          i;

    PMC_ENTRY();

    for (i = 0; i < LAST_DIGI_INT_TYPE; i++)
    {
        if (TRUE == digi_int_is_cb_registered(digi_handle, (digi_int_type_t) i))
        {
            PMC_RETURN(TRUE);
        }
    }

    PMC_RETURN(FALSE);
} /* digi_int_is_any_cb_registered */


/*******************************************************************************
* FUNCTION: digi_int_callback_run()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Calls user callback registered for the provided interrupt type
*
* INPUTS:
*   digi_handle      - Pointer to digi handle
*   chnl_handle      - Channel handle if channelized interrupt type (optional)
*   int_type         - aggregation or channel interrupt table type
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_int_callback_run(digi_handle_t    *digi_handle,
                                       void*             chnl_handle,
                                       digi_int_type_t   int_type)
{
    PMC_ERROR            result = PMC_SUCCESS;
    digi_int_info_t     *int_info_ptr;
    void                *token;

    PMC_ENTRY();
    
    if (PMC_SUCCESS == result)
    {
        result = digi_int_info_get(digi_handle, int_type, &int_info_ptr);
    }


    if (PMC_SUCCESS == result)
    {
        if (NULL == int_info_ptr->user_cb)
        {
            PMC_ASSERT(0, DIGI_ERR_CODE_ASSERT, 0, 0);
        }
        else
        {
            token = int_info_ptr->token;
            result = int_info_ptr->user_cb(digi_handle, token, chnl_handle, int_type);
        }
    }

    PMC_RETURN(result);
} /* digi_int_callback_run */


/*******************************************************************************
* FUNCTION: digi_int_callback_set()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Sets a callback and token for the given interrupt table. 
*
* INPUTS:
*   digi_handle      - Pointer to digi handle
*   int_type         - aggregation or channel interrupt table type
*   token            - user token to store. NULL if not used.
*   token_size       - size of token in bytes. 0 if not used.
*   user_cb          - callback to be registered against this interrupt type
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_int_callback_set(digi_handle_t        *digi_handle,
                                       digi_int_type_t       int_type,
                                       void                 *token,
                                       UINT32                token_size,
                                       digi_int_cb_fcn       user_cb)
{
    PMC_ERROR            result = PMC_SUCCESS;
    digi_int_info_t     *int_info_ptr;
    
    PMC_ENTRY();

    if (NULL == user_cb)
    {
        PMC_RETURN(DIGI_ERR_NULL_HANDLE);
    }

    if (PMC_SUCCESS == result)
    {
        result = digi_int_info_get(digi_handle, int_type, &int_info_ptr);
    }

    if (PMC_SUCCESS == result)
    {
        /* Store callback */
        int_info_ptr->user_cb = user_cb;

        /* Remove existing token */
        if (NULL != int_info_ptr->token)
        {
            PMC_FREE(&int_info_ptr->token);
            int_info_ptr->token_size = 0;
        }

        /* Store new token */
        if ((NULL != token) && (0 != token_size))
        {
            int_info_ptr->token = PMC_CALLOC(token_size);
            PMC_MEMCPY(int_info_ptr->token, token, token_size);
            int_info_ptr->token_size = token_size;
        }
    }



    PMC_RETURN(result);
} /* digi_int_callback_set */

/*******************************************************************************
* digi_first_post_mld_dsi_find
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to find the first post mld context of type
*   digi_post_mld_dsi_ctxt_t matching the specified port_uid
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   port_uid           - the unique identifier of the SERDES port.
*                        To find the first unused one use:
*                        DIGI_SERDES_UNASSIGNED
*
* OUTPUTS:
*
* RETURNS:
*   A pointer to the requested matching digi_post_mld_dsi_ctxt_t structure,
*   or NULL if there are no more available or the requested one could not be
*   found.
*
* NOTES:
*
*******************************************************************************/
PUBLIC digi_post_mld_dsi_ctxt_t* digi_first_post_mld_dsi_find(digi_handle_t *digi_handle,
                                                              UINT32 port_uid)
{
    digi_post_mld_dsi_ctxt_t* rp = NULL;
    UINT8 i = 0;

    PMC_ENTRY();

    for (i = 0; i < DIGI_SERDES_DSI_LANES_MAX; i ++) {

        /* Check the line side first */
        if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].port_uid == port_uid) {

            rp = &(digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i]);
            break;

            /* Check the system side second */
        } else if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].port_uid == port_uid) {

            rp = &(digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i]);
            break;
        }
    }

    PMC_RETURN(rp);
} /* digi_first_post_mld_dsi_find */

/*******************************************************************************
* digi_by_mld_index_post_mld_map_type_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to get the mapper allocation state of the
*   digi_post_mld_dsi_ctxt_t matching at the specified post_mld_index
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   post_mld_index     - the index of the post mld lane
*
* OUTPUTS:
*   map_type           - the map type to get on the matching port_uid.
*                        See digi_mapper_alloc_t for more information.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*   *map_type is only valid upon return of PMC_SUCCESS.
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_by_mld_index_post_mld_map_type_get(digi_handle_t *digi_handle,
                                                         UINT8 post_mld_index,
                                                         digi_mapper_alloc_t *map_type)
{
    PMC_ENTRY();

    *map_type = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[post_mld_index].map_type;

    PMC_RETURN(PMC_SUCCESS);
} /* digi_by_mld_index_post_mld_map_type_get */

/*******************************************************************************
* digi_by_mld_index_post_mld_map_type_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to set the mapper allocation state of the
*   digi_post_mld_dsi_ctxt_t matching at the specified post_mld_index
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   post_mld_index     - the index of the post mld lane
*   port_type          - the port type either ENET_LINE or ENET_SYS
*   map_type           - the map type to set on the matching post_mld_index.
*                        See digi_mapper_alloc_t for more information.
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_by_mld_index_post_mld_map_type_set(digi_handle_t *digi_handle,
                                                         UINT8 post_mld_index,
                                                         util_global_cpb_port_t port_type,
                                                         digi_mapper_alloc_t map_type)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;

    PMC_ENTRY();

    if ((port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE) ||
        (port_type == UTIL_GLOBAL_CPB_PORT_MAPOTN)) 
    {

        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[post_mld_index].map_type = map_type;
        rc = PMC_SUCCESS;

    } 
    else if (port_type == UTIL_GLOBAL_CPB_PORT_ENET_SYS) 
    {
        /* Should be a NO-OP */
        /* Mapped as an ENET_SYS application */
        rc = PMC_SUCCESS;
    }
    else 
    {
        /* Bad state */
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    PMC_RETURN(rc);
} /* digi_by_mld_index_post_mld_map_type_set */

/*******************************************************************************
* digi_handle_init_status_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function that returns DIGI handle initialization status.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   BOOL8 - TRUE when digi handle is initialized, FALSE otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 digi_handle_init_status_get(digi_handle_t    *digi_handle)
{
    BOOL8 rc;

    PMC_ENTRY();
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    rc = (digi_handle->var.digi_state == DIGI_STATE_HANDLE_INIT) || (digi_handle->var.digi_state == DIGI_STATE_DEVICE_INIT);
    
    PMC_RETURN(rc);
} /* digi_handle_init_status_get */


/*******************************************************************************
* digi_device_init_status_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function that returns DIGI device initialization status.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   BOOL8 - TRUE when digi device is initialized, FALSE otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 digi_device_init_status_get(digi_handle_t    *digi_handle)
{
    BOOL8 rc;

    PMC_ENTRY();
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    rc = (digi_handle->var.digi_state == DIGI_STATE_DEVICE_INIT);
    
    PMC_RETURN(rc);
} /* digi_device_init_status_get */

#endif /*DOXYGEN_PUBLIC_ONLY */







/*
*  Exported Interface Internal Testing Functions - Start
*/

#ifndef DOXYGEN_PUBLIC_ONLY

/*******************************************************************************
* digi_cpb_chnl_resize
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function is for internal testing only and is not intended to be released
*   as part of customer facing Applib.\n\n
*
*   This function resizes a CPB channel FIFO associated with the specified 
*   destination port channel.
*
* INPUTS:

*   *digi_handle     - pointer to DIGI handle instance.
*   *output_pc_ptr   - Destination DPI port / channel pair for the channel to
*                      be activated.  Accepts the pointer to one of the
*                      following channel handle types: \n\n
*                      digi_enet_client_chnl_t \n
*                      digi_cbr_client_chnl_t \n
*                      digi_ilkn_chnl_t \n
*                      digi_mapper_chnl_t \n
*    num_blocks      - Number of blocks to resize FIFO to. Must be a non-zero
*                      value.
*
*
* OUTPUTS: 
*   None. 
*
* RETURNS: 
*   PMC_SUCCESS - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_chnl_resize(digi_handle_t *digi_handle,
                                      util_global_switch_data_t *output_pc_ptr,
                                      UINT32 num_blocks)
{
    PMC_ERROR result = PMC_SUCCESS;

    /* implementation notes:
       call cpb_chnl_resize_wrapper() API after extracting the channel handle.
    */

    /* variable definition */
    util_global_switch_data_def_t *output_pc_data_ptr = NULL;
    util_global_cpb_port_data_t *local_output_pc_ptr = (util_global_cpb_port_data_t*)output_pc_ptr;
    cpb_handle_t *cpb_handle = NULL;
    UINT32 cpb_output_port;

    PMC_ENTRY();

    /* Check arguments */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != output_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;

    PMC_ASSERT(output_pc_data_ptr!=NULL, DIGI_ERR_INVALID_ARG, 0, 0);

    DIGI_CHNL_HANDLE_MAGIC_CHECK(output_pc_data_ptr);

    local_output_pc_ptr = &(output_pc_data_ptr->cpb_data);

    PMC_ASSERT(local_output_pc_ptr->port_type < UTIL_GLOBAL_CPB_PORT_NOT_USED, DIGI_ERR_INVALID_ARG, 0, 0);

    PMC_ASSERT(num_blocks != 0, DIGI_ERR_INVALID_ARG, 0, 0);


    /* retrieve required CPB handle */
    cpb_handle = digi_handle->dcpb_handle;
    cpb_output_port = local_output_pc_ptr->port_type;

    if( result == PMC_SUCCESS )
    {
        result = cpb_queue_resize_wrapper ( cpb_handle, cpb_output_port,
                                            local_output_pc_ptr->channel,
                                            num_blocks);

    }

    PMC_RETURN(result);

} /* digi_cpb_chnl_resize */

/*******************************************************************************
* digi_ocpb_chnl_resize
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function is for internal testing only and is not intended to be released
*   as part of customer facing Applib.\n\n
*
*   This function resizes an OCPB channel FIFO associated with the specified 
*   destination port channel.
*
* INPUTS:

*   *digi_handle     - pointer to DIGI handle instance.
*   *output_pc_ptr   - Destination DPI port / channel pair for the channel to
*                      be activated.  Accepts the pointer to one of the
*                      following channel handle types: \n\n
*                      digi_enet_client_chnl_t \n
*                      digi_cbr_client_chnl_t \n
*                      digi_ilkn_chnl_t \n
*                      digi_mapper_chnl_t \n
*    num_blocks      - Number of blocks to resize FIFO to. Must be a non-zero
*                      value.
*
*
* OUTPUTS:
*   None. 
* 
* RETURNS: 
*   PMC_SUCCESS - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ocpb_chnl_resize(digi_handle_t *digi_handle,
                                       util_global_switch_data_t *output_pc_ptr,
                                       UINT32 num_blocks)
{
    PMC_ERROR result = PMC_SUCCESS;

    /* implementation notes:
       call cpb_chnl_resize_wrapper() API after extracting the channel handle.
    */

    /* variable definition */
    util_global_switch_data_def_t *output_pc_data_ptr = NULL;
    util_global_oduk_port_data_t *local_output_pc_ptr = (util_global_oduk_port_data_t*)output_pc_ptr; 
    UINT32 cpb_output_port;

    PMC_ENTRY();

    /* Check arguments */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != output_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;

    PMC_ASSERT(output_pc_data_ptr!=NULL, DIGI_ERR_INVALID_ARG, 0, 0);

    DIGI_CHNL_HANDLE_MAGIC_CHECK(output_pc_data_ptr);

    local_output_pc_ptr = &(output_pc_data_ptr->oduk_data);

    PMC_ASSERT((UINT32)local_output_pc_ptr->port_type < (UINT32)UTIL_GLOBAL_CPB_PORT_NOT_USED, DIGI_ERR_INVALID_ARG, 0, 0);

    PMC_ASSERT(num_blocks != 0, DIGI_ERR_INVALID_ARG, 0, 0);


    /* retrieve required CPB handle */
    cpb_output_port = local_output_pc_ptr->port_type;

    if( result == PMC_SUCCESS )
    {
        result = coreotn_oduksw_queue_resize_wrapper (digi_handle->coreotn_handle, cpb_output_port,
                                                      local_output_pc_ptr->channel,
                                                      num_blocks);
    }

    PMC_RETURN(result);

} /* digi_ocpb_chnl_resize */

/*******************************************************************************
* digi_mcpb_enet_mux_mode_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function initializes MCPB MUX mode to select ENET LINE or ENET SYS.
*
* INPUTS:
*   *digi_handle             - pointer to DIGI handle instance.
*    cpb_enet_port_type      - type of the CPB port
*    enable                  - When TRUE MCPB mux associated to CPB port is enabled,
*                              otherwise it is disabled should there be no connections
*                              provisioned or activated against ENET_LINE or ENET_SYS
*                              subsystems.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_mcpb_enet_mux_mode_init(digi_handle_t                    *digi_handle,
                                              util_global_mcpb_port_t           cpb_enet_port_type,
                                              BOOL8                             enable)
{
    PMC_ERROR rc = PMC_SUCCESS;
    BOOL8 bypass_cfg = FALSE;
    cpb_handle_t *mcpb_hndl_ptr;
    cpb_mcpb_mux_mode_t mode = LAST_CPB_MCPB_MUX_MODE;

    PMC_ENTRY();

    mcpb_hndl_ptr = digi_handle->mcpb_handle;

    /* if disabling and no ENET_LINE/ENET_SYS connections reset context to allow
       mux re-configuration */
    if (FALSE == enable && TRUE == cpb_mcpb_enet_connect_start_state_test(mcpb_hndl_ptr))
    {
        mode = CPB_MCPB_MUX_MODE_DISABLED;
        digi_handle->var.mcpb_ctxt.mcpb_mux_mode_init = FALSE;
        bypass_cfg = TRUE;
    }
    else
    {
        switch(cpb_enet_port_type)
        {
        case UTIL_GLOBAL_MCPB_PORT_ENET_LINE:
            mode = CPB_MCPB_MUX_MODE_ENET_LINE;
            break;
        case UTIL_GLOBAL_MCPB_PORT_ENET_SYS:
            mode = CPB_MCPB_MUX_MODE_ENET_SYS;
            break;
        default:
            /* if not requesting valid mode silently return success with no action*/
            bypass_cfg = TRUE;
            break;
        }
    }

    if(PMC_SUCCESS == rc && TRUE == enable)
    {
        /* ensure MCPB in running state to allow register configuration */
        digi_mcpb_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RUNNING);
    }

    if (PMC_SUCCESS == rc && bypass_cfg == FALSE)
    {
        if (FALSE == digi_handle->var.mcpb_ctxt.mcpb_mux_mode_init)
        {
            /* keep mcpb mode in ctxt to avoid write over or create a MCPB_init function */
            rc = cpb_mcpb_mux_mode_init(mcpb_hndl_ptr, mode);
            if (PMC_SUCCESS == rc)
            {
                digi_handle->var.mcpb_ctxt.mcpb_mux_mode_init = TRUE;
            }
        } else {
            /* if already initialized, confirm the requested matches the configured state */
            if(mode != cpb_mcpb_mux_mode_init_get(mcpb_hndl_ptr)) rc = DIGI_ERR_MCPB_INVALID_PORT;
        }
    }

    PMC_RETURN(rc);
}/* digi_mcpb_enet_mux_mode_init */

/*******************************************************************************
* digi_mcpb_port_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function initializes one set of ingress/egress MCPB port.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*    egr_port           - type of the egress port
*    ingr_port          - type of the ingress port
*    rate               - rate associated to ingress/egress port
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_mcpb_port_init(digi_handle_t                    *digi_handle,
                                     cpb_mcpb_egr_output_port_type_t   egr_port,
                                     cpb_mcpb_ingr_input_port_type_t   ingr_port,
                                     UINT32                            rate) /* create rate for mcpb port */
{
    BOOL8  mcpb_egress_mux_output_enabled   = TRUE;
    cpb_xfer_mode_t xfer_mode                         = CPB_PACKET;
    BOOL8 mcpb_header_removal               = FALSE;
    cpb_handle_t *mcpb_hndl_ptr;
    PMC_ERROR rc;
    
    PMC_ENTRY();

    mcpb_hndl_ptr = digi_handle->mcpb_handle;


    /*   # initialize MCPB Ingress MUX inputs, Egress MUX outputs and MCPB DCS instances */
    rc = cpb_ingress_mux_input_init(mcpb_hndl_ptr, ingr_port, xfer_mode, mcpb_header_removal);
    

    /*      # initialize 0-5 MCPB Egress MUX output ports  */
    
    if (PMC_SUCCESS == rc)
    {
        if (LAST_CPB_MCPB_EGRESS_PORT > egr_port)
        {
            rc = cpb_egress_mux_output_init(mcpb_hndl_ptr, egr_port, xfer_mode, mcpb_egress_mux_output_enabled);
        }
        else
        {
            rc = DIGI_ERR_UNKNOWN;
        }
    }

    PMC_RETURN(rc);
} /* digi_mcpb_port_init */


/*******************************************************************************
* digi_mcpb_port_uninit
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function uninitializes one set of ingress/egress MCPB port.
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*    egr_port          - type of the egress port
*    ingr_port         - type of the ingress port
*
* OUTPUTS:
*   None.
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_mcpb_port_uninit(digi_handle_t                    *digi_handle,
                                       cpb_mcpb_egr_output_port_type_t   egr_port,
                                       cpb_mcpb_ingr_input_port_type_t   ingr_port)
{
    
    BOOL8  mcpb_egress_mux_output_disabled   = FALSE;
    cpb_xfer_mode_t xfer_mode                         = CPB_PACKET;
    cpb_handle_t *mcpb_hndl_ptr;
    PMC_ERROR rc;
    
    PMC_ENTRY();

    mcpb_hndl_ptr = digi_handle->mcpb_handle;
    rc = cpb_mcpb_mux_mode_init(mcpb_hndl_ptr, CPB_MCPB_MUX_MODE_DISABLED);

    if (PMC_SUCCESS == rc)
    {
        if (LAST_CPB_MCPB_EGRESS_PORT > egr_port)
        {
            rc = cpb_egress_mux_output_init(mcpb_hndl_ptr, egr_port, xfer_mode, mcpb_egress_mux_output_disabled);
        }
        else
        {
            rc = DIGI_ERR_UNKNOWN;
        }
    }

    PMC_RETURN(rc);
} /* digi_mcpb_port_uninit */

/*******************************************************************************
* digi_mcpb_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function provisions one MCPB channel.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*    egr_port           - type of the egress port
*    egr_chnl           - egress channel
*    ingr_port          - type of the ingress port
*    ingr_chnl          - ingres channel 
*    rate               - channel rate
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS when operation is successful otherwise a descriptive error code is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_mcpb_chnl_prov(digi_handle_t                     *digi_handle,
                                     cpb_mcpb_egr_output_port_type_t    egr_port,
                                     UINT32                             egr_chnl,
                                     cpb_mcpb_ingr_input_port_type_t    ingr_port,
                                     UINT32                             ingr_chnl,
                                     UINT32                             rate)
{
    UINT32 halt_buffer = 1;
    cpb_handle_t *mcpb_hndl_ptr;
    PMC_ERROR rc = PMC_SUCCESS;
    
    PMC_ENTRY();

    /* check port and channel values */
    /* check that ports are initalized */
    
    mcpb_hndl_ptr = digi_handle->mcpb_handle;

    /* determine state of the CPB SS and if in lowpwr/reset state transition 
     * to a configurable state */
    digi_mcpb_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RUNNING);
    PMC_ATOMIC_YIELD(digi_handle,0);   

    /* set halt_buffer size based on the current rate */
    digi_mcpb_halt_buffer_size_set (egr_port, ingr_port, rate, &halt_buffer);


    if (PMC_SUCCESS == rc)
    {
        /* if we are going from CPU <-> ENET, or MGMT -> ENET, set scbs by rate */
        /* otherwise just assign one entry */
        if (!((ingr_port == CPB_MCPB_ING_LINE_IM_EXT && egr_port == CPB_MCPB_EGR_CPU) || 
            (ingr_port == CPB_MCPB_ING_SYS_IM_EXT && egr_port == CPB_MCPB_EGR_CPU) ||
            (ingr_port == CPB_MCPB_ING_LINE_EM_EXT && egr_port == CPB_MCPB_EGR_CPU) ||
            (ingr_port == CPB_MCPB_ING_SYS_EM_EXT && egr_port == CPB_MCPB_EGR_CPU) ||
            (ingr_port == CPB_MCPB_ING_LINE_REF && egr_port == CPB_MCPB_EGR_CPU) ||
            (ingr_port == CPB_MCPB_ING_CPU_INS && egr_port == CPB_MCPB_EGR_SYS_ING) || 
            (ingr_port == CPB_MCPB_ING_CPU_INS && egr_port == CPB_MCPB_EGR_LINE_ING) ||
            (ingr_port == CPB_MCPB_ING_CPU_INS && egr_port == CPB_MCPB_EGR_SYS_EG) ||
            (ingr_port == CPB_MCPB_ING_CPU_INS && egr_port == CPB_MCPB_EGR_LINE_EG) ||
            (ingr_port == CPB_MCPB_ING_FEGE_INS && egr_port == CPB_MCPB_EGR_SYS_ING) || 
            (ingr_port == CPB_MCPB_ING_FEGE_INS && egr_port == CPB_MCPB_EGR_LINE_ING) ||
            (ingr_port == CPB_MCPB_ING_FEGE_INS && egr_port == CPB_MCPB_EGR_SYS_EG) ||
            (ingr_port == CPB_MCPB_ING_FEGE_INS && egr_port == CPB_MCPB_EGR_LINE_EG))) {
            /* use lowest rate possible so we only get 1 entry in the calendar */
            rate = 1;
        }
    }

    /* Configure MCPB port and channel - MCPB Slave, Master and DCS interfaces
       are configured within cpb_mcpb_chnl_prov() */ 
    if (PMC_SUCCESS == rc)
    {
        rc = cpb_mcpb_chnl_prov(mcpb_hndl_ptr, egr_port, egr_chnl, rate, UTIL_SCHD_1M_BIT_SEC, halt_buffer);        
        PMC_ATOMIC_YIELD(digi_handle,0);

        /* determine if the MCPB egress port and channel has been successfully
           configured. cpb_mcpb_chnl_prov() will return error CPB_ERR_CHNL_ALREADY_EXSITS
           if channel is already provisioned (channel state != START), or PMC_SUCCESS if
           it applies the configuration of the channel. If the channel not in
           the STATE state this API must have previously been called and the channel is
           assumed to be provisioned and activated. */

        if (!(PMC_SUCCESS == rc || CPB_ERR_CHNL_ALREADY_EXISTS == rc))
        {
            cpb_chnl_deprov(mcpb_hndl_ptr, egr_port, egr_chnl, FALSE);
            PMC_ATOMIC_YIELD(digi_handle,0);
        }

    }

    /*   # activate MCPB egress channel */
    if (PMC_SUCCESS == rc)
    {
        rc = cpb_chnl_activate(mcpb_hndl_ptr, egr_port, egr_chnl);
        PMC_ATOMIC_YIELD(digi_handle,0);
        if (PMC_SUCCESS != rc)
        {
            (void)cpb_chnl_deactivate(mcpb_hndl_ptr, egr_port, egr_chnl);
            PMC_ATOMIC_YIELD(digi_handle,0);
            cpb_chnl_deprov(mcpb_hndl_ptr, egr_port, egr_chnl, FALSE);
            PMC_ATOMIC_YIELD(digi_handle,0);

        }
        else
        {
            rc = mcpb_dpi_slave_port_chnl_flush(mcpb_hndl_ptr,
                                                egr_port,
                                                egr_chnl,
                                                ingr_port,
                                                ingr_chnl); 
            PMC_ATOMIC_YIELD(digi_handle,0);                                    
        }         
    }

    if(PMC_SUCCESS == rc || CPB_ERR_CHNL_ALREADY_EXISTS == rc)
    {
        /* update alternate queue DPI slave port channel init status in context */
        switch(ingr_port)
        {
            /* egr_chnl will have a range 0 to 11 corresponding to ENET_LINE/SYS link */
        case CPB_MCPB_ING_CPU_INS:
            if(egr_port == CPB_MCPB_EGR_SYS_ING || egr_port == CPB_MCPB_EGR_LINE_ING)
            {
                digi_handle->var.mcpb_ctxt.mcpb_dcs_num_registered_chnl[DIGI_MCPB_DPI_0_1_CPU_CHNLS] |= 1 << egr_chnl;
            } 
            else if(egr_port == CPB_MCPB_EGR_SYS_EG || egr_port == CPB_MCPB_EGR_LINE_EG) 
            {
                digi_handle->var.mcpb_ctxt.mcpb_dcs_num_registered_chnl[DIGI_MCPB_DPI_2_3_CPU_CHNLS] |= 1 << egr_chnl;
            }
            break;
        case CPB_MCPB_ING_FEGE_INS:
            if(egr_port == CPB_MCPB_EGR_SYS_ING || egr_port == CPB_MCPB_EGR_LINE_ING)
            {
                digi_handle->var.mcpb_ctxt.mcpb_dcs_num_registered_chnl[DIGI_MCPB_DPI_0_1_MGMT_CHNLS] |= 1 << egr_chnl;
            } 
            else if(egr_port == CPB_MCPB_EGR_SYS_EG || egr_port == CPB_MCPB_EGR_LINE_EG) 
            {
                digi_handle->var.mcpb_ctxt.mcpb_dcs_num_registered_chnl[DIGI_MCPB_DPI_2_3_MGMT_CHNLS] |= 1 << egr_chnl;
            }
            break;
        default:
            /* not an alternate queue related port */
            break;
        }
    }

    /* redirect CPB_ERR_CHNL_ALREADY_EXSITS error code to PMC_SUCCESS as channel 
       has already been brought up okay */

    if (CPB_ERR_CHNL_ALREADY_EXISTS == rc) rc = PMC_SUCCESS;

    PMC_RETURN(rc);
}/* digi_mcpb_chnl_prov */

/*******************************************************************************
* digi_mcpb_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions one MCPB channel.
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*    egr_port          - type of the egress port
*    egr_chnl          - egress channel
*    ingr_port         - type of the ingress port
*    ingr_chnl         - ingres channel  
*
* OUTPUTS:
*   None.
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_mcpb_chnl_deprov(digi_handle_t                     *digi_handle,
                                       cpb_mcpb_egr_output_port_type_t    egr_port,
                                       UINT32                             egr_chnl,
                                       cpb_mcpb_ingr_input_port_type_t    ingr_port,
                                       UINT32                             ingr_chnl)
{
    cpb_handle_t *mcpb_hndl_ptr;
    BOOL8 clear_to_deprov = TRUE;
    PMC_ERROR rc = PMC_SUCCESS;
    
    PMC_ENTRY();

    /* check port and channel values */
    /* check that ports are initalized */
    
    mcpb_hndl_ptr = digi_handle->mcpb_handle;

    /* for alternate queue applications, ensure that both CPU and MGMT sources are
       not in use before physically performing tear down. */
    if(PMC_SUCCESS == rc)
    {
        /* update alternate queue DPI slave port channel init status in context */
        switch(ingr_port)
        {
            /* egr_chnl will have a range 0 to 11 corresponding to ENET_LINE/SYS link */
        case CPB_MCPB_ING_CPU_INS:
            if(egr_port == CPB_MCPB_EGR_SYS_ING || egr_port == CPB_MCPB_EGR_LINE_ING)
            {
                /* clear the provision state context for the CPU channel */
                digi_handle->var.mcpb_ctxt.mcpb_dcs_num_registered_chnl[DIGI_MCPB_DPI_0_1_CPU_CHNLS] &= ~(1 << egr_chnl);
                /* prevent tear down if the MGMT port is still provisioned in context */
                if(digi_handle->var.mcpb_ctxt.mcpb_dcs_num_registered_chnl[DIGI_MCPB_DPI_0_1_MGMT_CHNLS] & (1 << egr_chnl))
                    clear_to_deprov = FALSE;
            } 
            else if(egr_port == CPB_MCPB_EGR_SYS_EG || egr_port == CPB_MCPB_EGR_LINE_EG) 
            {
                /* clear the provision state context for the CPU channel */
                digi_handle->var.mcpb_ctxt.mcpb_dcs_num_registered_chnl[DIGI_MCPB_DPI_2_3_CPU_CHNLS] &= ~(1 << egr_chnl);
                /* prevent tear down if the MGMT port is still provisioned in context */
                if(digi_handle->var.mcpb_ctxt.mcpb_dcs_num_registered_chnl[DIGI_MCPB_DPI_2_3_MGMT_CHNLS] & (1 << egr_chnl))
                    clear_to_deprov = FALSE;
            }
            break;
        case CPB_MCPB_ING_FEGE_INS:
            if(egr_port == CPB_MCPB_EGR_SYS_ING || egr_port == CPB_MCPB_EGR_LINE_ING)
            {
                /* clear the provision state context for the CPU channel */
                digi_handle->var.mcpb_ctxt.mcpb_dcs_num_registered_chnl[DIGI_MCPB_DPI_0_1_MGMT_CHNLS] &= ~(1 << egr_chnl);
                /* prevent tear down if the MGMT port is still provisioned in context */
                if(digi_handle->var.mcpb_ctxt.mcpb_dcs_num_registered_chnl[DIGI_MCPB_DPI_0_1_CPU_CHNLS] & (1 << egr_chnl))
                    clear_to_deprov = FALSE;
            } 
            else if(egr_port == CPB_MCPB_EGR_SYS_EG || egr_port == CPB_MCPB_EGR_LINE_EG) 
            {
                /* clear the provision state context for the CPU channel */
                digi_handle->var.mcpb_ctxt.mcpb_dcs_num_registered_chnl[DIGI_MCPB_DPI_2_3_MGMT_CHNLS] &= ~(1 << egr_chnl);
                /* prevent tear down if the MGMT port is still provisioned in context */
                if(digi_handle->var.mcpb_ctxt.mcpb_dcs_num_registered_chnl[DIGI_MCPB_DPI_2_3_CPU_CHNLS] & (1 << egr_chnl))
                    clear_to_deprov = FALSE;
            }
            break;
        default:
            /* not an alternate queue related port */
            break;
        }
    }


    if(clear_to_deprov == TRUE)
    {
        /*   # Deactivate MCPB egress channel */    
        if (PMC_SUCCESS == rc)
        {
            rc = cpb_chnl_deactivate(mcpb_hndl_ptr, egr_port, egr_chnl);
            PMC_ATOMIC_YIELD(digi_handle,0);
        }
        
        /* # Deprovision MCPB egress channel */
        if (PMC_SUCCESS == rc)
        {
            rc = cpb_chnl_deprov(mcpb_hndl_ptr, egr_port, egr_chnl, FALSE);
            PMC_ATOMIC_YIELD(digi_handle,0);
        }    
    
        /* determine state of the CPB SS and if no resources provisioned bring SS to lowpwr/reset state */
        if(PMC_SUCCESS == rc)
        {
            digi_mcpb_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
        }
    }

    PMC_RETURN(rc);
}/* digi_mcpb_chnl_deprov */

/*******************************************************************************
* digi_mcpb_enet_port_type_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The function returns the ENET port type selected in MCPB.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*  UTIL_GLOBAL_MCPB_PORT_ENET_LINE or UTIL_GLOBAL_MCPB_PORT_ENET_SYS when a ENET ss 
*  is connected ortherwise LAST_UTIL_GLOBAL_MCPB_PORT.
*
* NOTES:
*   
*******************************************************************************/
PUBLIC util_global_mcpb_port_t digi_mcpb_enet_port_type_get(digi_handle_t *digi_handle)
{
    
    PMC_ENTRY();

    if(digi_handle->var.mcpb_ctxt.mcpb_mux_mode_init == FALSE)
        PMC_RETURN(LAST_UTIL_GLOBAL_MCPB_PORT);

    switch(cpb_mcpb_mux_mode_init_get(digi_handle->mcpb_handle))
    {
    case CPB_MCPB_MUX_MODE_ENET_LINE:
        PMC_RETURN(UTIL_GLOBAL_MCPB_PORT_ENET_LINE);
        break;  
    case CPB_MCPB_MUX_MODE_ENET_SYS:
        PMC_RETURN(UTIL_GLOBAL_MCPB_PORT_ENET_SYS);
        break;            
    case LAST_CPB_MCPB_MUX_MODE:
        PMC_RETURN(LAST_UTIL_GLOBAL_MCPB_PORT);
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        break;
    }
    PMC_RETURN(LAST_UTIL_GLOBAL_MCPB_PORT);

}/* digi_mcpb_enet_port_type_get */

#endif /* DOXYGEN_PUBLIC_ONLY */


/*
*  Exported Interface Internal Testing Functions - End
*/

/*
** Private Functions
*/

#ifndef DOXYGEN_PUBLIC_ONLY

/*******************************************************************************
* digi_reg_read_internal
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Read DIGI data.
*
*
* INPUTS:
*   digi_handle - pointer to DIGI handle instance.
*   vaddr       - chip address from which to read data from. Note that this
*                 address is relative to base address of the chip.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32 - value read
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32 digi_reg_read_internal(digi_handle_t *digi_handle, UINT32 vaddr)
{
    pmc_sys_handle_t *hndl = NULL;
    UINT32 value;

    PMC_ENTRY();

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != digi_handle->base.sys_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    hndl = digi_handle->base.sys_handle;
    value = pmc_sys_reg_read(hndl, vaddr);

    PMC_RETURN(value);
}

/*******************************************************************************
* FUNCTION: digi_toc_cfg()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures and enables the Top of Calendar indicators to each of the
*   subystems with DCS or SCBS3 calendars. The purpose of the TOC indications
*   is to synchronize all of the calendars within the device on each clock domain.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   enable                 - TRUE to enable, FALSE to move to reset.
*
* OUTPUTS:
*   None
*
* RETURNS:
*   None
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_toc_cfg(digi_handle_t* digi_handle,
                          BOOL enable)
{
    UINT16        toc;

    PMC_ENTRY();

    UINT8 digi_rst_or_actv = DIGI_RESET;
    UINT8 digi_enable_or_disable = DIGI_DISABLE;
    pmc_energy_state_request_t energy_state;
    

    if (enable == TRUE) {

        digi_rst_or_actv = DIGI_ACTIVE;
        digi_enable_or_disable = DIGI_ENABLE;
        energy_state = PMC_ENERGY_STATE_REQUEST_RUNNING;

        /* Bring M1 out of low power */
        digi_m1_energy_state_set(digi_handle, energy_state);

    } else {

        digi_rst_or_actv = DIGI_RESET;
        digi_enable_or_disable = DIGI_DISABLE;
        energy_state = PMC_ENERGY_STATE_REQUEST_RESET;
    }
    
    /* Bring top level TOC out of reset */
    digi_m1_field_TOC_CAL_349_SW_RST_set(NULL, digi_handle, digi_rst_or_actv);
    digi_m1_field_TOC_CAL_500_SW_RST_set(NULL, digi_handle, digi_rst_or_actv);

    /* Enable global TOC */
    digi_m1_field_CNT_349_EN_set(NULL, digi_handle, digi_enable_or_disable);
    digi_m1_field_CNT_500_EN_set(NULL, digi_handle, digi_enable_or_disable);

    /* Enable SS TOCs */
    toc = DIGI_TOC_SYSOTN |
        DIGI_TOC_ENET_LINE |
        DIGI_TOC_ENET_SYS |
        DIGI_TOC_CBRC |
        DIGI_TOC_MAPOTN |
        DIGI_TOC_SIFD |
        DIGI_TOC_LINEOTN |
        DIGI_TOC_COREOTN |
        DIGI_TOC_DCPB;

    digi_m1_field_SS_TOC_349_EN_set(NULL, digi_handle, toc);
    digi_m1_field_SS_TOC_500_EN_set(NULL, digi_handle, toc);

    if (enable == FALSE) {

        /* Hold M1 in reset*/
        digi_m1_energy_state_set(digi_handle, energy_state);
    }

    PMC_RETURN();
} /* digi_toc_cfg */
#endif /* DOXYGEN_PUBLIC_ONLY */

/*******************************************************************************
* FUNCTION: digi_int_init()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Initializes/deinitializes interrupt and status support.
*   To operate in polling mode, set int_type = CPUIF_INT_DISABLE.
*   To operate with interrupts, set int_type = CPUIF_INT_LEGACY, 
*   CPUIF_INT_MSI or CPUIF_INT_MSI_X.
*
*   If enable is set to TRUE, this function initializes the internal
*   callback table to a clean state. This function must be run before
*   any callbacks are registered.
*
*   If enable is set to FALSE, this function frees all memory allocated
*   for the tokens associated with each interrupt type.
*
* INPUTS:
*   digi_handle     - Pointer to subsystem handle
*   enable          - Enables/disables interrupt and status support.
*   int_type        - Host Interrupt type 
*   
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_int_init(digi_handle_t   *digi_handle,
                               cpuif_int_t      int_type,
                               BOOL             enable)
{
    PMC_ERROR            result = PMC_SUCCESS;
    UINT32               i;
    digi_int_info_t     *int_info_ptr;
    hostmsg_handle_t *cpu_handle = NULL;
    UINT32 irq_mask = PCIE_OB_IRQ_MASK; /* IPI + SS_INT[1] */

    PMC_ATOMIC_ENTRY(digi_handle);

    /* 
     * Enable/disable interrupts
     *  -Note: Interrupts will be disabled if enable=FALSE or if the caller sets
     *   int_type = CPU_INT_DISABLE
     */
      
    /* use a hostmsg handle to access cpup34k block  */        
    cpu_handle = (hostmsg_handle_t *)(digi_handle->base.common_info->hostmsg_handle);
    cpuif_int_cfg((pmc_handle_t *)cpu_handle,(enable ? int_type : CPUIF_INT_DISABLE),irq_mask);

    /*
     * Set the top level mask that will be assigned to the SYSOTN top level
     * register if this is a SYSOTN application. It is defined as a global
     * do not have to change an existing API and that the register cannot
     * be set until the application type is known and this function can be
     * called before or after digi_device_init.
     * if CPUIF_INT_DISABLE then the top level interrupt is not required as
     * polling will be used and as such does not need to beset.
     * If DEVICE_PIN then ensure the value sets bits in the upper 3rd of 
     * the register. 
     * Else set the bits in the second set of reqisters so that interrupts
     * will be routed to PCIe.
     * Note: Set only if this is a sysotn application or the application
     * has not yet been set indicating digi_device_init has not been called
     */
    if (DIGI_PROD_APP_SYSOTN_CARD == digi_handle->var.prod_app ||
        LAST_DIGI_PROD_APP == digi_handle->var.prod_app)
    {
        if (CPUIF_INT_DISABLE == int_type)
        {
            lineotn_interrupt_type_save(digi_handle->sysotn_handle,
                                        SYSOTN_INTR_TYPE_CPUIF_INT_DISABLE);
        }
        else if (CPUIF_INT_DEVICE_PIN == int_type)
        {
            lineotn_interrupt_type_save(digi_handle->sysotn_handle,
                                        SYSOTN_INTR_TYPE_CPUIF_INT_DEVICE_PIN);
        }
        else
        {
            lineotn_interrupt_type_save(digi_handle->sysotn_handle,
                                        SYSOTN_INTR_TYPE_CPUIF_INT_OTHER);
        }
    }
    if (TRUE == enable)
    {
        /* Initialize local structures */
        for (i = 0; i < LAST_DIGI_INT_TYPE; i++)
        {
            int_info_ptr = &digi_handle->var.int_info_ary->int_info[i];

            int_info_ptr->user_cb = NULL;   
            int_info_ptr->token = NULL;
            int_info_ptr->token_size = 0;
        }
    
        PMC_MEMSET(digi_handle->var.enabled_otn_int, 0, sizeof(digi_int_otn_t));
        PMC_MEMSET(digi_handle->var.enabled_int, 0, sizeof(digi_int_t));
    }
    else
    {
        /* Deinitialize */
        for (i = 0; i < LAST_DIGI_INT_TYPE; i++)
        {
            if (NULL != digi_handle->var.int_info_ary->int_info[i].token)
            {
                PMC_FREE(&digi_handle->var.int_info_ary->int_info[i].token);
                digi_handle->var.int_info_ary->int_info[i].token_size = 0;
            }
        }
    }

    /* Enable/disable IPI interrupts for enhanced ddeg 
     * The specific interrupts per stage and per channel still need to be
     * enabled individually in FW, so we can turn this aggregation interrupt on.
     */
    if (PMC_SUCCESS == result)
    {
        result = digi_pmon_ipi_int_enable(digi_handle,
                                          DIGI_PMON_IPI_TYPE_DDEG_ENH,
                                          enable);
    }
    
    if (PMC_SUCCESS == result)
    {
        result = digi_pmon_ipi_int_enable(digi_handle,
                                          DIGI_PMON_IPI_TYPE_DDEG_BURSTY,
                                          enable);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_int_init */


/*******************************************************************************
* FUNCTION: digi_int_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Searches enabled interrupt bits in all subsystems of the device.
*
*   The callback associated
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*
* OUTPUTS: 
*   None. 
*
* RETURNS: 
*   PMC_SUCCESS - on success, error otherwise. 
*
* NOTES:

*******************************************************************************/
PUBLIC PMC_ERROR digi_int_enabled_check(digi_handle_t          *digi_handle)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    result = digi_int_enabled_check_internal(digi_handle);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_int_enabled_check */

#ifndef DOXYGEN_PUBLIC_ONLY
/*******************************************************************************
* FUNCTION: digi_int_top_otn_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks the top level coreotn summary registers to determine
*   if there is active interrupt in the requested CoreOTN blocks (ODU or FO2).
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   int_type        - OTN_ODU or OTN_MAPPER_FO2 interrupt type
*
* OUTPUTS:
*   int_found_ptr   - Returns TRUE if an active interrupt is found
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_int_top_otn_enabled_check(digi_handle_t    *digi_handle,
                                                 digi_int_type_t   int_type,
                                                 BOOL             *int_found_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();
    
    PMC_ASSERT(digi_handle    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_found_ptr  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    switch (int_type)
    {
    case DIGI_INT_TYPE_OTN:
        result = coreotn_int_top_enabled_check(digi_handle->coreotn_handle,
                                               COREOTN_INT_TYPE_ODUKP,
                                               int_found_ptr);
        break;

    case DIGI_INT_TYPE_OTN_MAPPER:
        result = coreotn_int_top_enabled_check(digi_handle->coreotn_handle,
                                               COREOTN_INT_TYPE_STG4,
                                               int_found_ptr);
        break;
        
    default:
        PMC_ASSERT(NULL, DIGI_ERR_INVALID_ARG, 0, 0);
        break;
    } /* end switch */
    

    PMC_RETURN(result);
} /* digi_int_top_otn_enabled_check */

/*******************************************************************************
* FUNCTION: digi_int_top_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks the aggregated top level interrupt summary register to determine
*   if there is active interrupt in the requested subsystem.
*  
*   DIGI_INT_TYPE_OTN will check LineOTN and CoreOTN (except FO2) interrupts.
*   DIGI_INT_TYPE_OTN_MAPPER will check MapOTN and FO2 interrupts.
* 
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   int_type        - Aggregated interrupt type
*
* OUTPUTS:
*   int_found_ptr   - Returns TRUE if an active interrupt is found
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_int_top_enabled_check(digi_handle_t    *digi_handle,
                                            digi_int_type_t   int_type,
                                            BOOL             *int_found_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;
    UINT32          int_summary;
    UINT32          summary_bit[DIGI_INT_CHNL_TYPE_START];
    pmc_handle_t   *cpu_handle;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle    != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_found_ptr  != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(DIGI_INT_TYPE_PMON != int_type, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(DIGI_INT_TYPE_CPB  != int_type, DIGI_ERR_INVALID_ARG, 0, 0);

    /* Only aggregated interrup types are supported */
    if (IS_DIGI_INT_CHNL_TYPE(int_type))
    {
        PMC_RETURN(DIGI_ERR_INT_ONLY_AGG_TYPE_ALLOWED);
    }



    cpu_handle = (pmc_handle_t *)(digi_handle->base.common_info->hostmsg_handle);


    summary_bit[DIGI_INT_TYPE_DEVICE]       = 0x000003FF;
    summary_bit[DIGI_INT_TYPE_SIFD]         = DIGI_INT_IRQ_MASK_SIFD;
    summary_bit[DIGI_INT_TYPE_CBR]          = DIGI_INT_IRQ_MASK_CBRC;
    summary_bit[DIGI_INT_TYPE_ENET_SYS ]    = DIGI_INT_IRQ_MASK_ENET_SYS;
    summary_bit[DIGI_INT_TYPE_ENET_LINE]    = DIGI_INT_IRQ_MASK_ENET_LINE;
    summary_bit[DIGI_INT_TYPE_OTN_MAPPER]   = DIGI_INT_IRQ_MASK_MAPOTN;
    summary_bit[DIGI_INT_TYPE_OTN]          = DIGI_INT_IRQ_MASK_LINEOTN; /* Line OTN only, no SYSOTN */


    /* Retrieve interrupt summary */
    int_summary = int_agr_field_DEVICE_RSTAT_get(NULL, cpu_handle);



    /* Check subsystem bit mask against device status */
    if (int_summary & summary_bit[int_type])
    {
        *int_found_ptr = TRUE;
    }


    /* Additional checks for OTN RFRM and MAPPER FO2 */
    if ((FALSE == *int_found_ptr) &&
        ((DIGI_INT_TYPE_OTN == int_type) ||
         (DIGI_INT_TYPE_OTN_MAPPER == int_type)))
    {
        /* Check CoreOTN */
        result = digi_int_top_otn_enabled_check(digi_handle,
                                                int_type,
                                                int_found_ptr);   
    } 

    PMC_RETURN(result);
} /* digi_int_top_enabled_check */

#endif /* DOXYGEN_PUBLIC_ONLY */
/*******************************************************************************
* FUNCTION: digi_int_monitor_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function enables the monitoring of interrupts. Registered callbacks will
*   be invoked in response to interrupts. In polling mode, interrupts will be
*   checked at the frequency specified by polling_mode_wait_us. If interrupt mode
*   is enabled, pmc_sys_event_monitor is called to wait for events.
*   If forever is set, this function will continue until interrupt checking is
*   disabled by calling digi_int_monitor_disable.
*   
*   
* INPUTS:
*   digi_handle          - Pointer to subsystem handle
*   polling_mode         - if TRUE use polling, if FALSE use interrupts.
*   polling_mode_wait_us - Polling mode delay
*   forever              - Run the event loop for ever.
*   
*
* OUTPUTS:
*   None.
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_int_monitor_cfg(digi_handle_t *digi_handle, 
                                      BOOL polling_mode, 
                                      UINT32 polling_mode_wait_us, 
                                      BOOL forever)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_event_cfg_t * event_cfg_ptr = digi_handle->var.event_cfg;

    PMC_ATOMIC_ENTRY(digi_handle);
    event_cfg_ptr->polling_mode = polling_mode; 
    event_cfg_ptr->polling_mode_wait_us = polling_mode_wait_us; 
    event_cfg_ptr->cb = digi_int_event_callback; 
    event_cfg_ptr->cb_parameter = digi_handle; 
    event_cfg_ptr->forever = forever; 
    digi_event_init(digi_handle,event_cfg_ptr);
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_int_monitor_cfg */

/*******************************************************************************
* FUNCTION: digi_int_monitor
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function monitors interrupts. Registered callbacks will
*   be invoked in response to interrupts. The  In polling mode, interrupts will be
*   checked at the frequency specified by polling_mode_wait_us. If interrupt mode
*   is enabled, pmc_sys_event_monitor is called to wait for events.
*   If forever is set, this function will continue until interrupt checking is
*   disabled by calling digi_int_monitor_disable.
*   
*   
* INPUTS:
*   digi_handle          - Pointer to subsystem handle
*   
*
* OUTPUTS:
*   None.
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_int_monitor(digi_handle_t *digi_handle)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_event_cfg_t * event_cfg_ptr = digi_handle->var.event_cfg;
    
    PMC_ENTRY();
    digi_event_monitor(digi_handle,event_cfg_ptr);
    
    PMC_RETURN(result);
} /* digi_int_monitor */


/*******************************************************************************
* FUNCTION: digi_int_monitor_disable
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function disables the monitoring of interrupts. The event loop will
*   terminate when the next event occurs.
*   
*   
* INPUTS:
*   digi_handle          - Pointer to subsystem handle
*
* OUTPUTS:
*
* RETURNS:
*   None 
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_int_monitor_disable(digi_handle_t *digi_handle)
{

#ifdef PMC_TESTS 
    PMC_ATOMIC_ENTRY_VOID(digi_handle);
#else 
    PMC_ATOMIC_ENTRY(digi_handle);
#endif

    digi_handle->var.event_cfg->forever = FALSE; 
    
    PMC_ATOMIC_RETURN(digi_handle);
} /* digi_int_monitor_disable */


/*******************************************************************************
* FUNCTION: digi_int_device_aggregator_enable
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function enables the propagation of one or more interrupts to the 
*   device pin or PCIE interrupt. The int_type parameter specifies whether to 
*   configure the device pin or PCIE interrupt enables. \n
*
*   The enable_mask paramter specifies which interrupts should be enabled. This
*   function only enables interrupts. To disable interrupts use 
*   digi_int_device_aggregator_disable.
*  
*   For example, to enable the PMON interrupt: \n
*       -digi_int_device_aggregator_enable(digi_handle, DIGI_INT_IRQ_MASK_PMON) \n
*
*
*   To enable the coreotn and lineotn interrupts: \n
*       -digi_int_device_agg_set(digi_handle,  \n
*               DIGI_INT_IRQ_MASK_COREOTN | DIGI_INT_IRQ_MASK_LINEOTN)  \n
*   
*
* INPUTS:
*   digi_handle  - DIGI handle.
*   int_type     - To configure the interrupt aggregator for the device 
*                  pin irq set to CPUIF_INT_DEVICE.\n
*                  To configure the interrupt aggregator for a PCIE irq use: \n
*                      CPUIF_INT_MSI, CPUIF_INT_MSI_X or CPUIF_INT_LEGACY.
*   int_enable  - Determines which interrupts to enable. If a bit is set to 1,
*                  then the corresponding interrupt will be enabled. If a bit
*                  is 0, the interrupt mask will not be changed for that 
*                  interrupt. See digi_int_irq_mask_t for an enumeration of 
*                  the interrupt bit values.
*
* OUTPUTS:
*
* RETURNS:
*   None
*
* NOTES:
*   This function is primarily added for debug purposes. It should not be
*   necessary to configure the aggregator interrupt enables. It should be 
*   sufficient to enable/disable interrupts within the various sub-blocks.
*
*******************************************************************************/
PUBLIC void digi_int_device_aggregator_enable(digi_handle_t *digi_handle,
                                              cpuif_int_t int_type,     
                                              UINT32 int_enable)
{
    pmc_handle_t * cpu_handle;
#ifdef PMC_TESTS 
    PMC_ATOMIC_ENTRY_VOID(digi_handle);
#else 
    PMC_ATOMIC_ENTRY(digi_handle);
#endif

    cpu_handle = (pmc_handle_t *)(digi_handle->base.common_info->hostmsg_handle);

    cpuif_int_device_aggregator_set(cpu_handle, int_type, int_enable);
    
    PMC_ATOMIC_RETURN(digi_handle);
} /* digi_int_device_aggregator_enable */

/*******************************************************************************
* FUNCTION: digi_int_device_aggregator_disable
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function disables the propagation of one or more interrupts to the
*   device pin or PCIE interrupt. The int_type parameter specifies whether to 
*   configure the device pin or the PCIE interrupt. \n
*
*   The disable_mask paramter specifies which interrupts should be enabled. 
*  
*   For example, to disable the shared PMON interrupt: \n
*       -digi_int_device_aggregator_disable(digi_handle, DIGI_INT_IRQ_MASK_PMON) \n
*
*   Warning: disabling the PMON interrupt will also disable the propagation of
*   the DDEG interrupt.\n
*
*   To disable the coreotn and lineotn interrupts: \n
*       -digi_int_device_aggregator_disable(digi_handle,  \n
*               DIGI_INT_IRQ_MASK_COREOTN | DIGI_INT_IRQ_MASK_LINEOTN) \n
*
* INPUTS:
*   digi_handle  - DIGI handle.
*   int_type     - To configure the interrupt aggregator for the device 
*                  pin irq use CPUIF_INT_DEVICE.\n
*                  To configure the interrupt aggregator for a PCIE irq use: \n
*                      CPUIF_INT_MSI, CPUIF_INT_MSI_X or CPUIF_INT_LEGACY.
*   int_disable - Determines which interrupts to disable. If a bit is set to 1,
*                  then the corresponding interrupt will be disabled. If a bit
*                  is set 0, the interrupt mask for that interrupt will not be 
*                  changed. See digi_int_irq_mask_t for an enumeration of the
*                  interrupt bit values.
*
* OUTPUTS:
*
* RETURNS:
*   None
*
* NOTES:
*   This function is primarily added for debug purposes. It should not be
*   necessary to disable the aggregator interrupt enables. It should be 
*   sufficient to enable/disable interrupts within the various sub-blocks.
*
*******************************************************************************/
PUBLIC void digi_int_device_aggregator_disable(digi_handle_t *digi_handle,
                                               cpuif_int_t int_type,     
                                               UINT32 int_disable)
{
    pmc_handle_t * cpu_handle;
#ifdef PMC_TESTS 
    PMC_ATOMIC_ENTRY_VOID(digi_handle);
#else 
    PMC_ATOMIC_ENTRY(digi_handle);
#endif 

    cpu_handle = (pmc_handle_t *)(digi_handle->base.common_info->hostmsg_handle);

    cpuif_int_device_aggregator_clr(cpu_handle, int_type, int_disable);
    
    PMC_ATOMIC_RETURN(digi_handle);
} /* digi_int_device_aggregator_disable */


/*******************************************************************************
* FUNCTION: digi_int_device_aggregator_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function retrieves a bit mask indicating which interrupts are enabled. 
*   The int_type parameter specifies whether to retrieve the device pin or 
*   PCIE interrupt enables. 
*
*   For example, to check if COREOTN interrupts are being propaged to the device
*   pin interrupt: \n
*       irq_enables = digi_int_device_aggregator_get(digi_handle, \n
*                                                    CPUIF_INT_DEVICE);\n
*       coreotn_interrupt_enable = (irq_enables & DIGI_INT_IRQ_MASK_COREOTN); \n
*         
* INPUTS:
*   digi_handle  - digi handle
*   int_type     - To configure the irq mask for the device pin irq use 
*                    CPUIF_INT_DEVICE\n
*                  To configure the irq mask for a PCIE irq use:  \n
*                    CPUIF_INT_MSI, CPUIF_INT_MSI_X or CPUIF_INT_LEGACY.
*
* OUTPUTS:
*
* RETURNS:
*   UINT32 - Each bit that is set to 1 corresponds to an interrupt that is 
*            enabled. See digi_int_irq_mask_t.
*       
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 digi_int_device_aggregator_get(digi_handle_t *digi_handle,
                                             cpuif_int_t int_type)
{
    pmc_handle_t * cpu_handle;
    UINT32 int_enable;

    PMC_ATOMIC_ENTRY(digi_handle);

    cpu_handle = (pmc_handle_t *)(digi_handle->base.common_info->hostmsg_handle);

    int_enable = cpuif_int_device_aggregator_get(cpu_handle, int_type);
    
    PMC_ATOMIC_RETURN(digi_handle, int_enable);
} /* digi_int_device_aggregator_get */

#ifndef DOXYGEN_PUBLIC_ONLY
/*******************************************************************************
* FUNCTION: digi_int_event_callback()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   DIGI Int monitoring. 
*   
*   
* INPUTS:
*   digi_handle     - digi_handle pointer
*   
*
* OUTPUTS:
*
* RETURNS:
*   None
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_int_event_callback(void *digi_handle)
{
    digi_handle_t *handle = (digi_handle_t *)digi_handle;
    PMC_ERROR result;
    PMC_ENTRY();
    result = digi_int_enabled_check(handle);
    PMC_RETURN();
} /* digi_int_event_callback */

/*******************************************************************************
* FUNCTION: digi_int_enabled_check_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Searches enabled interrupt bits in all subsystems of the device.
*
*   The callback associated
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*
* OUTPUTS: 
*    None. 
*
* RETURNS: 
*   PMC_SUCCESS - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_int_enabled_check_internal(digi_handle_t          *digi_handle)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    /* If no callbacks registered against any subsystem, then return */
    if (FALSE == digi_int_is_any_cb_registered(digi_handle))
    {
        PMC_RETURN(DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE); 
    }

    if ((PMC_SUCCESS == result) || (DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE == result))
    {
        result = digi_device_int_enabled_check_internal(digi_handle);
    }

    if ((PMC_SUCCESS == result) || (DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE == result))
    {
        result = digi_pmon_int_enabled_check_internal(digi_handle);
    }
    
    if ((PMC_SUCCESS == result) || (DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE == result))
    {
        result = digi_otn_int_enabled_check_internal(digi_handle);
    }

    if ((PMC_SUCCESS == result) || (DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE == result))
    {
        result = digi_cbr_int_enabled_check_internal(digi_handle);
    }
    
    if ((PMC_SUCCESS == result) || (DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE == result))
    {
        result = digi_mapper_int_enabled_check_internal(digi_handle);
    }
    
    if ((PMC_SUCCESS == result) || (DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE == result))
    {
        result = digi_enet_line_int_enabled_check_internal(digi_handle);
    }
    
    if ((PMC_SUCCESS == result) || (DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE == result))
    {
        result = digi_enet_sys_int_enabled_check_internal(digi_handle);
    }
    
    if ((PMC_SUCCESS == result) || (DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE == result))
    {
        result = digi_sifd_int_enabled_check_internal(digi_handle);
    }
    
    if (DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE == result)
    {
        result = PMC_SUCCESS;
    }

    PMC_RETURN(result);
} /* digi_int_enabled_check_internal */

/*******************************************************************************
* digi_oduksw_sifd_db_clear
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API clears database entries used by an SIFD channel in the relevant
*   databases.
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   sifd_ilkn_inst    - Enum, defining SIFD interface
*   chnl              - SIFD channel
*   sifd_db           - TRUE means sifd DB, FALSE is for oduksw
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERROR - SUCCESS if all goes well or an appropriate error value.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_oduksw_sifd_db_clear(digi_handle_t *digi_handle,
                                           digi_sifd_ilkn_inst_t sifd_ilkn_inst,
                                           UINT32 chnl,
                                           BOOL8 sifd_db)
{
    util_global_oduk_port_t oduk_port;
    util_gen_db_id_t dcs_inst;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    switch(sifd_ilkn_inst)
    {
    case DIGI_SIFD_ILKN1:
        dcs_inst = (util_gen_db_id_t)0;
        oduk_port = UTIL_GLOBAL_ODUK_PORT_ILKN1;
        break;
    case DIGI_SIFD_ILKN2:
        dcs_inst = (util_gen_db_id_t)1;
        oduk_port = UTIL_GLOBAL_ODUK_PORT_ILKN2;
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
        break;
    }
    if (FALSE == sifd_db)
    {
        result = coreotn_oduksw_db_entry_clear(digi_handle->coreotn_handle,
                                               (coreotn_oduksw_output_port_type_t)sifd_ilkn_inst,
                                               chnl);
    }

 
    PMC_RETURN(result);

} /* digi_oduksw_sifd_db_clear */


/*******************************************************************************
* digi_device_init_params_validate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs simple parameter validation for the call to
*   digi_device init.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *sifd_1_cfg_ptr          - pointer to configuration structure detailing
*                            ILKN1 configuration.  If ILKN1 unused, set to NULL
*   *sifd_2_cfg_ptr          - pointer to configuration structure detailing
*                            ILKN2 configuration.  If ILKN2 unused, set to NULL
*   prod_app               - Enum, defining the major product application that
*                            device is being configured to support
*   mux_stages             - Defines the maximum number of stages of OTN mapping
*                            the CORE_OTN subsystem will support.\n
*                            2: Two stages of multiplexing\n
*                            1: One stage of multiplexing\n
*                            0: No stages of multiplexing
*   **ilkn_1_ctxt_pptr     - A pointer to a pointer to a data structure defining
*                            how the first ilkn blk was configured based on the
*                            input parameters.
*   **ilkn_2_ctxt_pptr     - A pointer to a pointer to a data structure defining
*                            how the second ilkn blk was configured based on
*                            the input parameters.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_device_init_params_validate(digi_handle_t *digi_handle,
                                                   digi_sifd_ilkn_1_cfg_t *sifd_1_cfg_ptr,
                                                   digi_sifd_ilkn_2_cfg_t *sifd_2_cfg_ptr,
                                                   digi_prod_app_t prod_app,
                                                   digi_otn_mux_stages_t mux_stages,
                                                   digi_ilkn_link_t **ilkn_1_ctxt_pptr,
                                                   digi_ilkn_link_t **ilkn_2_ctxt_pptr)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;

    PMC_ENTRY();

    if (digi_handle == NULL) {

        rc = DIGI_ERR_NULL_HANDLE;

    } else if (prod_app >= LAST_DIGI_PROD_APP) {
        rc = DIGI_ERR_INVALID_ARG;

    } else if (mux_stages >= LAST_DIGI_OTN_MUX_STAGES) {

        rc = DIGI_ERR_INVALID_ARG;

    } else if (ilkn_1_ctxt_pptr == NULL) {

        rc = DIGI_ERR_NULL_HANDLE;

    } else if (ilkn_2_ctxt_pptr == NULL) {

        rc = DIGI_ERR_NULL_HANDLE;

    } else {

        rc = PMC_SUCCESS;

    }
    
    if(rc == PMC_SUCCESS)
    {
        /* For LINE card, *no* system serdes should be configured. */
        if ((digi_handle->var.cage_cfg.is_sys_cage_cfg == TRUE) && 
            (prod_app != DIGI_PROD_APP_TRANSMUXPONDER_CARD &&
             prod_app != DIGI60_PROD_APP_TRANSMUXPONDER_SYS_CLIENT_CARD &&  
             prod_app != DIGI_PROD_APP_100G_3_X_40G_CFP_CARD &&
             prod_app != DIGI_PROD_APP_SYSOTN_CARD)) {
            
            rc = DIGI_ERR_SERDES_SYSTEM_SERDES_DEFINED;
        }

        /* For TRANSMUXPONDER & CFP card at least some system serdes should be configured. */
        if ((digi_handle->var.cage_cfg.is_sys_cage_cfg == FALSE) && 
            (prod_app == DIGI_PROD_APP_TRANSMUXPONDER_CARD ||
             prod_app == DIGI60_PROD_APP_TRANSMUXPONDER_SYS_CLIENT_CARD || 
             prod_app == DIGI_PROD_APP_100G_3_X_40G_CFP_CARD ||
             prod_app == DIGI_PROD_APP_SYSOTN_CARD)) {
            
            rc = DIGI_ERR_SERDES_NO_SYSTEM_SERDES_DEFINED; 
        }
    }

    /* For SYSOTN mode, only NONE or ONE stage muxing is supported */
    if(rc == PMC_SUCCESS)
    {
        /*if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) && (mux_stages > DIGI_OTN_MUX_STAGES_ONE)) */
        if (prod_app == DIGI_PROD_APP_SYSOTN_CARD && mux_stages > DIGI_OTN_MUX_STAGES_ONE)
        {
            rc = DIGI_ERR_INVALID_ARG;
        }
    }

    if(rc == PMC_SUCCESS)
    {
        if(digi_sys_serdes_pin_use_collision_test(digi_handle, sifd_1_cfg_ptr, sifd_2_cfg_ptr) == TRUE)
        {
            rc = DIGI_ERR_SERDES_PIN_ALLOC_COLLISION;
        }
    }    

    if(rc == PMC_SUCCESS)
    {
        if(digi_sys_serdes_bp_csu_multi_rate_test(digi_handle, sifd_1_cfg_ptr, sifd_2_cfg_ptr) == TRUE)
        {
            rc = DIGI_ERR_SERDES_CSU_MULTIRATE_REQUEST;
        }
    }  

    if(rc == PMC_SUCCESS && sifd_1_cfg_ptr != NULL)
    {
        if( (sifd_1_cfg_ptr->ilkn.lane_mask | 
             (sifd_1_cfg_ptr->lane.blk_to_E1_enable_mask | sifd_1_cfg_ptr->lane.blk_to_N1_enable_mask | sifd_1_cfg_ptr->lane.blk_to_N2_enable_mask))
            != ( sifd_1_cfg_ptr->lane.blk_to_E1_enable_mask | sifd_1_cfg_ptr->lane.blk_to_N1_enable_mask | sifd_1_cfg_ptr->lane.blk_to_N2_enable_mask))
        {
            rc = DIGI_ERR_INVALID_ARG;
        }
    }

    if(rc == PMC_SUCCESS && sifd_2_cfg_ptr != NULL)
    {
        if( (sifd_2_cfg_ptr->ilkn.lane_mask | 
             (sifd_2_cfg_ptr->lane.blk_to_E1_enable_mask | sifd_2_cfg_ptr->lane.blk_to_N1_enable_mask | sifd_2_cfg_ptr->lane.blk_to_N2_enable_mask))
            != ( sifd_2_cfg_ptr->lane.blk_to_E1_enable_mask | sifd_2_cfg_ptr->lane.blk_to_N1_enable_mask | sifd_2_cfg_ptr->lane.blk_to_N2_enable_mask))
        {
            rc = DIGI_ERR_INVALID_ARG;
        }
    }

    if(rc == PMC_SUCCESS && IS_DIGI60(digi_handle))    
    {
        if (sifd_1_cfg_ptr != NULL) {
            if ((sifd_1_cfg_ptr->ilkn.lane_mask > 0x3FFF) || (sifd_1_cfg_ptr->lane.blk_to_N1_enable_mask != 0) || (sifd_1_cfg_ptr->lane.blk_to_N2_enable_mask !=0)) {
                rc = DIGI_ERR_INVALID_ARG;
            }
        }
        
        if (sifd_2_cfg_ptr != NULL) {
            if (sifd_2_cfg_ptr->ilkn.lane_mask > 0xFFFF) {
                rc = DIGI_ERR_INVALID_ARG;
            }
        }
    }

    /* If ILKN is in ODUkSW 2B header mode 0, then if must only receive data from the ODUkSW interfacce */
    if(rc == PMC_SUCCESS && sifd_1_cfg_ptr != NULL)
    {
        if(sifd_1_cfg_ptr->ilkn.oduksw_header == DIGI_SIFD_ODUKSW_ILKN_HEADER_2B &&
           sifd_1_cfg_ptr->ilkn.oduksw_2b_header_mode == 0 &&
           sifd_1_cfg_ptr->ilkn.cpb_intf_en == 1)
        {
            rc = DIGI_ERR_INVALID_ARG;
        }
    }
    if(rc == PMC_SUCCESS && sifd_2_cfg_ptr != NULL)
    {
        if(sifd_2_cfg_ptr->ilkn.oduksw_header == DIGI_SIFD_ODUKSW_ILKN_HEADER_2B &&
           sifd_2_cfg_ptr->ilkn.oduksw_2b_header_mode == 0 &&
           sifd_2_cfg_ptr->ilkn.cpb_intf_en == 1)
        {
            rc = DIGI_ERR_INVALID_ARG;
        }
    }


    PMC_RETURN(rc);

} /* digi_device_init_params_validate */



/*******************************************************************************
* FUNCTION: digi_cbr_lane_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Validates the lane configuration for CBR clients.
*   
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   port_uid        - Unique user assigned value for identifying
*                     serdes port.  The value 0xFFFFFFFF
*                     DIGI_SERDES_UNASSIGNED is reserved as the
*                     default unassigned setting.
*   mode            - Serdes mode: 10G, 40G, 40G SFI.S
*   intf_type       - Interface type
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_cbr_lane_validate(digi_handle_t          *digi_handle,
                                         UINT32                  port_uid,
                                         cbrc_serdes_type_t      mode,
                                         digi_serdes_intf_t      intf_type)
{
    PMC_ERROR       rc = DIGI_ERR_UNKNOWN;
    UINT8           pin_count = 0;
    BOOL            pin_valid = FALSE;
    BOOL            serdes_tbl[LAST_DIGI_PROD_APP][DIGI_SERDES_SYSTEM_INTF+1] = DIGI_CBR_SERDES_PROD_APP_TABLE;
    digi_prod_app_t prod_app;
    
    PMC_ENTRY();

    /* 
     *  SFI-51 serdes will have 0 XFI pins so no need to validate
     */
    if (CBRC_SERDES_TYPE_40G_SFI51 == mode)
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    PMC_ASSERT(intf_type < (INT32)(sizeof(serdes_tbl[0])/sizeof(serdes_tbl[0][0])), DIGI_ERR_INVALID_ARG, 0, 0);

    /* Check LINE and SYS inputs for product application */
    prod_app = DIGI_PROD_APP_GET(digi_handle);
    PMC_ASSERT(prod_app < (INT32)(sizeof(serdes_tbl)/sizeof(serdes_tbl[0])), DIGI_ERR_INVALID_ARG, 0, 0);

    if (FALSE == serdes_tbl[prod_app][intf_type])
    {
        PMC_RETURN(DIGI_ERR_CBR_INCORRECT_SERDES_FOR_PROD_APP);
    }



  
    pin_count = digi_num_xfi_pins_in_use(digi_handle, port_uid);

    if (pin_count == DIGI_SERDES_LINE_LANES_NONE) {
        /* This could also be mapped from the back */
        pin_count = digi_num_sys_pins_in_use(digi_handle, port_uid);

        if (pin_count == DIGI_SERDES_LINE_LANES_NONE) {

            rc =  DIGI_ERR_SERDES_XFI_NO_PIN_PROV;

        } else {

            pin_valid = TRUE;
        }

    } else {
        pin_valid = TRUE;
    }


    if (pin_valid == TRUE) {
        if (pin_count == DIGI_SERDES_LINE_LANES_FOR_10G) {
            if (mode == CBRC_SERDES_TYPE_10G_XFI) {
                rc = PMC_SUCCESS;
            } else {
                rc = DIGI_ERR_PORT_PROV_RATE_FAIL;
            }

        } else if (pin_count == DIGI_SERDES_LINE_LANES_FOR_40G)  {
            if ((mode == CBRC_SERDES_TYPE_40G_STL)) {
                rc = PMC_SUCCESS;
            } else {
                rc = DIGI_ERR_PORT_PROV_RATE_FAIL;
            }

        } else if (pin_count == DIGI_SERDES_LINE_LANES_FOR_40G_SFIS) {
            if (mode == CBRC_SERDES_TYPE_40G_SFIS)
            {
                rc = PMC_SUCCESS;
            } else {
                rc = DIGI_ERR_PORT_PROV_RATE_FAIL;
            }

        } else if (pin_count == DIGI_SERDES_LINE_LANES_FOR_100G) {
            rc = DIGI_ERR_INVALID_ARG;

        } else {
            rc = DIGI_ERR_PORT_PROV_RATE_FAIL;
        }
    }

    PMC_RETURN(rc);
} /* digi_cbr_lane_validate */

/*******************************************************************************
* digi_mapotn_mode_params_convert
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the adaptaion function and mapping
*   mode for mapper.
*
* INPUTS:
*   mode             - the otn payload mapping modes
*
* OUTPUTS:
*   *map_mode        - pointer to storage of equivalent adaptaion function 
*                      mapping mode
*   *demap_mode      - pointer to storage of equivalent adaptaion function 
*                      demapping mode
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_mapotn_mode_params_convert(digi_mapping_mode_t mode,
                                            util_global_map_adapt_func_t* map_mode,
                                            util_global_map_adapt_func_t* demap_mode)
{
    PMC_ENTRY();

    *demap_mode = UTIL_GLOBAL_MAP_NO_RATE;

    switch(mode) {
    case DIGI_MAP_ODUKP_PACKET_GFP:
        *map_mode = UTIL_GLOBAL_MAP_ODUKP_PACKET_GFP;
        break;
    case DIGI_MAP_ODU4P_100_GE_GFP:
    case DIGI_MAP_ODU4P_100_GE_GFP_ENET:
        *map_mode = UTIL_GLOBAL_MAP_ODU4P_100_GE_GFP;
        break;
    case DIGI_MAP_ODU3P_40_GE_GFP:
    case DIGI_MAP_ODU3P_40_GE_GFP_ENET:
        *map_mode = UTIL_GLOBAL_MAP_ODU3P_40_GE_GFP;
        break;
    case DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP:
    case DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP_ENET:
        *map_mode = UTIL_GLOBAL_MAP_ODU2P_10_GE_7_3_GFP;
        break;
    case DIGI_MAP_ODU2P_PKT_10_GE_7_3_GFP:
        *map_mode = UTIL_GLOBAL_MAP_ODU2P_10_GE_7_3_GFP;
        break;
    case DIGI_MAP_ODU2P_10_GE_6_2_GFP:
    case DIGI_MAP_ODU2P_10_GE_6_2_GFP_ENET:
        *map_mode = UTIL_GLOBAL_MAP_ODU2P_10_GE_6_2_GFP;
        break;
    case DIGI_MAP_ODU2P_FC_800_GMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU2P_FC_800_GMP;
        break;
    case DIGI_MAP_ODU2EP_10G_GDPS_GMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU2EP_10G_GDPS_GMP;
        break;
    case DIGI_MAP_ODU2P_5G_GDPS_GMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU2P_5G_GDPS_GMP;
        break;
    case DIGI_MAP_ODU2P_CPRI_5_GMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU2P_CPRI_5_GMP;
        break;
    case DIGI_MAP_ODU2P_CPRI_10_GMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU2P_CPRI_7_GMP;
        break;
    case DIGI_MAP_ODU2P_CPRI_6_GMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU2P_CPRI_6_GMP;
        break;
    case DIGI_MAP_ODU3P_CBR_40_GE_GMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU3P_40_GE_GMP;
        break;
    case DIGI_MAP_ODU3P_PKT_40_GE_GMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU3P_40_GE_GMP;
        break;    
    case DIGI_MAP_ODU4P_CBR_100_GE_GMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU4P_100_GE_GMP;
        break;
    case DIGI_MAP_ODU4P_PKT_100_GE_GMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU4P_100_GE_GMP;
        break;
    case DIGI_MAP_ODUFLEX_5G_GDPS_BMP:
        *map_mode = UTIL_GLOBAL_MAP_ODUFLEX_5G_GDPS_BMP;
        break;
    case DIGI_MAP_ODUFLEX_10G_GDPS_BMP:
        *map_mode = UTIL_GLOBAL_MAP_ODUFLEX_10G_GDPS_BMP;
        break;
    case DIGI_MAP_ODUFLEX_CPRI_5_BMP:
        *map_mode = UTIL_GLOBAL_MAP_ODUFLEX_CPRI_5_BMP;
        break;
    case DIGI_MAP_ODUFLEX_CPRI_10_BMP:
        *map_mode = UTIL_GLOBAL_MAP_ODUFLEX_CPRI_7_BMP;
        break;
    case DIGI_MAP_ODUFLEX_CPRI_6_BMP:
        *map_mode = UTIL_GLOBAL_MAP_ODUFLEX_CPRI_6_BMP;
        break;
    case DIGI_MAP_ODUFLEX_FC_800_BMP:
        *map_mode = UTIL_GLOBAL_MAP_ODUFLEX_FC_800_BMP;
        break;
    case DIGI_MAP_ODU2EP_FC_1200_GFP:
        *map_mode   = UTIL_GLOBAL_MAP_ODU2EP_FC_1200_BMP;
        *demap_mode = UTIL_GLOBAL_MAP_ODU2EP_FC_1200_GFP;
        break;
    case DIGI_MAP_ODU2FP_FC_1200_BMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU2FP_FC_1200_BMP;
        break;
    case DIGI_MAP_ODU1FP_FC_1200_BMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU1FP_FC_1200_BMP;
        break;
    case DIGI_MAP_ODU1EP_CBR_10G3_7_2_BMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU1EP_CBR_10G3_7_2_BMP;
        break;
    case DIGI_MAP_ODU2EP_CBR_10G3_7_1_BMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU2EP_CBR_10G3_7_1_BMP;
        break;
    case DIGI_MAP_ODU1EP_PKT_10G3_7_2_BMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU1EP_CBR_10G3_7_2_BMP;
        break;
    case DIGI_MAP_ODU2EP_PKT_10G3_7_1_BMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU2EP_CBR_10G3_7_1_BMP;
        break;
    case DIGI_MAP_ODU3P_OC_768_CBR_BMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU3P_OC_768_CBR_BMP;
        break;
    case DIGI_MAP_ODU2P_OC_192_CBR_BMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU2P_OC_192_CBR_BMP;
        break;
    case DIGI_MAP_ODU3P_OC_768_CBR_AMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU3P_OC_768_CBR_AMP;
        break;
    case DIGI_MAP_ODU2P_OC_192_CBR_AMP:
        *map_mode = UTIL_GLOBAL_MAP_ODU2P_OC_192_CBR_AMP;
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        break;
    }

    /* Set demap mode to be same as map mode for all adaptations other than 
     * FC1200 ODU2e */
    if (UTIL_GLOBAL_MAP_NO_RATE == *demap_mode)
    {
        *demap_mode = *map_mode;
    }

    PMC_RETURN();
} /* digi_mapotn_mode_params_convert */

 
/*******************************************************************************
* digi_oduk_params_convert
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the ODUk data and post MLD secondary 
*   group size based on the ODUk frame type.
*
* INPUTS:
*   odu_data         - the ODUk frame type
*   odu_flex_data    - Number of ODU0 tributary slots making up the ODUFlex
*                     container.
*
* OUTPUTS:
*   *oduk_data       - pointer to storage of equivalent ODUk frame data
*   *group_size      - pointer to storage of post MLD secondary group size
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_oduk_params_convert(digi_oduk_t odu_data,
                                     UINT32 odu_flex_data,
                                     util_global_odukp_type_t* oduk_data,
                                     digi_group_size_t* group_size)
{
    PMC_ENTRY();

    switch(odu_data) {
    case DIGI_ODUK_ODU0:
        *oduk_data = UTIL_GLOBAL_ODU0;
        *group_size = DIGI_GRP_SIZE_10G;
        break;
    case DIGI_ODUK_ODU1:
        *oduk_data = UTIL_GLOBAL_ODU1;
        *group_size = DIGI_GRP_SIZE_10G;
        break;
    case DIGI_ODUK_ODU1E:
        *oduk_data = UTIL_GLOBAL_ODU1E;
        *group_size = DIGI_GRP_SIZE_10G;
        break;
    case DIGI_ODUK_ODU1F:
        *oduk_data = UTIL_GLOBAL_ODU1F;
        *group_size = DIGI_GRP_SIZE_10G;
        break;
    case DIGI_ODUK_ODU2:
        *oduk_data = UTIL_GLOBAL_ODU2;
        *group_size = DIGI_GRP_SIZE_10G;
        break;
    case DIGI_ODUK_ODU2E:
        *oduk_data = UTIL_GLOBAL_ODU2E;
        *group_size = DIGI_GRP_SIZE_10G;
        break;
    case DIGI_ODUK_ODU2F:
        *oduk_data = UTIL_GLOBAL_ODU2F;
        *group_size = DIGI_GRP_SIZE_10G;
        break;
    case DIGI_ODUK_ODU3:
        *oduk_data = UTIL_GLOBAL_ODU3;
        *group_size = DIGI_GRP_SIZE_40G;
        break;
    case DIGI_ODUK_ODU3E1:
        *oduk_data = UTIL_GLOBAL_ODU3E1;
        *group_size = DIGI_GRP_SIZE_40G;
        break;
    case DIGI_ODUK_ODU3E2:
        *oduk_data = UTIL_GLOBAL_ODU3E2;
        *group_size = DIGI_GRP_SIZE_40G;
        break;
    case DIGI_ODUK_ODU4:
        *oduk_data = UTIL_GLOBAL_ODU4;
        *group_size = DIGI_GRP_SIZE_100G;
        break;
    case DIGI_ODUK_ODUFLEX:
        *oduk_data = UTIL_GLOBAL_ODUFLEX_GFP;
        if(odu_flex_data <= DIGI_MAX_NUM_ODU0_IN_10G)
        {
            *group_size = DIGI_GRP_SIZE_10G;
        }
        else if(odu_flex_data <= DIGI_MAX_NUM_ODU0_IN_40G)
        {
            *group_size = DIGI_GRP_SIZE_40G;
        }
        else if(odu_flex_data <= DIGI_MAX_NUM_ODU0_IN_100G)
        {
            *group_size = DIGI_GRP_SIZE_100G;
        }
        else 
        {
            *group_size = LAST_DIGI_GRP_SIZE;
        }
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        break;
    }

    PMC_RETURN();
} /* digi_oduk_params_convert */


/*******************************************************************************
* digi_mapotn_enet_params_convert
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the ENET datapath mode based on
*   otn payload mapping mode.
*
* INPUTS:
*   map_mode         - the otn payload mapping modes
*
* OUTPUTS:
*   *e_mode          - pointer to storage of equivalent ENET datapath mode
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_mapotn_enet_params_convert(digi_mapping_mode_t map_mode,
                                             enet_datapath_t* e_mode)
{
    PMC_ENTRY();

    switch(map_mode) {
    case DIGI_MAP_ODU4P_100_GE_GFP:
        *e_mode = ENET_MAPOTN_GFP_GSUP43_6_2_100GE_MAC;
        break;
    case DIGI_MAP_ODU4P_100_GE_GFP_ENET:
        *e_mode = ENET_MAPOTN_GFP_GSUP43_6_2_100GE_MAC_PMON;
        break;
    case DIGI_MAP_ODU3P_40_GE_GFP:
        *e_mode = ENET_MAPOTN_GFP_GSUP43_6_2_40GE_MAC;
        break;
    case DIGI_MAP_ODU3P_40_GE_GFP_ENET:
        *e_mode = ENET_MAPOTN_GFP_GSUP43_6_2_40GE_MAC_PMON;
        break;
    case DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP:
    case DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP_ENET:
        *e_mode = ENET_MAPOTN_GFP_GSUP43_7_3_10GE_MAC_PMON;
        break;
    case DIGI_MAP_ODU2P_PKT_10_GE_7_3_GFP:
        *e_mode = ENET_MAPOTN_GFP_GSUP43_7_3_10GE_MAC;
        break;    
    case DIGI_MAP_ODU2P_10_GE_6_2_GFP:
        *e_mode = ENET_MAPOTN_GFP_GSUP43_6_2_10GE_MAC;
        break;
    case DIGI_MAP_ODU2P_10_GE_6_2_GFP_ENET:
        *e_mode = ENET_MAPOTN_GFP_GSUP43_6_2_10GE_MAC_PMON;
        break;
    case DIGI_MAP_ODU4P_CBR_100_GE_GMP:
        *e_mode = ENET_MAPOTN_GMP_G709_100GE_MAC_PMON;
        break;
    case DIGI_MAP_ODU4P_PKT_100_GE_GMP:
        *e_mode = ENET_MAPOTN_GMP_G709_100GE_MAC;
        break;    
    case DIGI_MAP_ODU3P_CBR_40_GE_GMP:
        *e_mode = ENET_MAPOTN_GMP_G709_40GE_MAC_PMON;
        break;
    case DIGI_MAP_ODU3P_PKT_40_GE_GMP:
        *e_mode = ENET_MAPOTN_GMP_G709_40GE_MAC;
        break;    
    case DIGI_MAP_ODU1EP_CBR_10G3_7_2_BMP:
        *e_mode = ENET_MAPOTN_BMP_GSUP43_10GE_MAC_PMON;
        break;
    case DIGI_MAP_ODU2EP_CBR_10G3_7_1_BMP:
        *e_mode = ENET_MAPOTN_BMP_GSUP43_10GE_MAC_PMON;
        break;
    case DIGI_MAP_ODU1EP_PKT_10G3_7_2_BMP:
        *e_mode = ENET_MAPOTN_BMP_GSUP43_10GE_MAC;
        break;
    case DIGI_MAP_ODU2EP_PKT_10G3_7_1_BMP:
        *e_mode = ENET_MAPOTN_BMP_GSUP43_10GE_MAC;
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        break;
    }

    PMC_RETURN();
} /* digi_mapotn_enet_params_convert */


/*******************************************************************************
* digi_mapotn_digi_enet_params_convert
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the ENET datapath mode based on
*   otn payload mapping mode.
*
* INPUTS:
*   map_mode         - the otn payload mapping modes
*
* OUTPUTS:
*   *digi_e_mode     - pointer to storage of equivalent ENET datapath mode
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_mapotn_digi_enet_params_convert(digi_mapping_mode_t map_mode,
                                                  digi_enet_mode_t* digi_e_mode)
{
    PMC_ENTRY(); 

    switch(map_mode) 
    {
    case DIGI_MAP_ODU4P_100_GE_GFP:
    case DIGI_MAP_ODU4P_100_GE_GFP_ENET:
    case DIGI_MAP_ODU4P_CBR_100_GE_GMP:
    case DIGI_MAP_ODU4P_PKT_100_GE_GMP:
        *digi_e_mode = DIGI_ENET_SERDES_100GE_TRANSPARENT;
        break;
    case DIGI_MAP_ODU3P_40_GE_GFP:
    case DIGI_MAP_ODU3P_40_GE_GFP_ENET:
    case DIGI_MAP_ODU3P_CBR_40_GE_GMP:
    case DIGI_MAP_ODU3P_PKT_40_GE_GMP:
        *digi_e_mode = DIGI_ENET_SERDES_40GE_TRANSPARENT;
        break;
    case DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP:
    case DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP_ENET:
    case DIGI_MAP_ODU2P_PKT_10_GE_7_3_GFP:
    case DIGI_MAP_ODU2P_10_GE_6_2_GFP:
    case DIGI_MAP_ODU2P_10_GE_6_2_GFP_ENET:
    case DIGI_MAP_ODU1EP_CBR_10G3_7_2_BMP:
    case DIGI_MAP_ODU2EP_CBR_10G3_7_1_BMP:
    case DIGI_MAP_ODU1EP_PKT_10G3_7_2_BMP:
    case DIGI_MAP_ODU2EP_PKT_10G3_7_1_BMP:
        *digi_e_mode = DIGI_ENET_SERDES_10GE_TRANSPARENT;
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        break;
    }

    PMC_RETURN();
} /* digi_mapotn_digi_enet_params_convert */

/*******************************************************************************
* digi_mpma_csi_type_params_convert
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the CSI type mode in MPMA.
*
* INPUTS:
*   opsa_csi_type         - the OPSA CSI type
*
* OUTPUTS:
*   *csi_type     - pointer to storage of equivalent MPMA CSI type
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_mpma_csi_type_params_convert(digi_opsa_csi_type_t opsa_csi_type,
                                               mpma_csi_type_t* csi_type)
{
    PMC_ENTRY(); 

    switch(opsa_csi_type) 
    {
    case DIGI_OPSA_CSI_NORMAL:
        *csi_type = MPMA_CSI_NORMAL;
        break;
    case DIGI_OPSA_CSI_SSF:
        *csi_type = MPMA_CSI_SSF;
        break;
    case DIGI_OPSA_CSI_SF:
        *csi_type = MPMA_CSI_SF;
        break;
    case DIGI_OPSA_CSI_SD:
        *csi_type = MPMA_CSI_SD;
        break;        
    case DIGI_OPSA_CSI_FORCE_TO:
        *csi_type = MPMA_CSI_FORCE_TO;
        break;
    case DIGI_OPSA_CSI_FORCE_AWAY:
        *csi_type = MPMA_CSI_FORCE_AWAY;
        break;                
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        break;
    }

    PMC_RETURN();
} /* digi_mpma_csi_type_params_convert */

/*******************************************************************************
* digi_mapper_post_mld_index_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the post_mld index the primary and 
*   and secondary group and the number of 10G secondary groups required.
*
* INPUTS:
*   group_size        - mumber of 10G secondary groups required for the mapper
*                       application see enum type digi_group_size_t
*   p_group           - Enum, Primary group to configure mapper channel
*                       against.
*   s_group           - Enum, Secondary group to configure mapper channel
*                       against.
*
*
* OUTPUTS:
*   post_mld_index    - the ENET_LINE link to be configured
*
* RETURNS:
*   None.
*
* NOTES:
*  ENET_LINE link is 1:1 mapped with the post mld index. So this function 
*  can be used to determine the link.
*******************************************************************************/
PRIVATE void digi_mapper_post_mld_index_get(digi_mapper_primary_group_t p_group,
                                            digi_mapper_secondary_group_t s_group,
                                            digi_group_size_t group_size,
                                            UINT32 *post_mld_index)
{

    PMC_ENTRY();

    PMC_ASSERT(s_group < LAST_DIGI_MAPPER_SECONDARY_GROUP,DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(p_group < LAST_DIGI_MAPPER_PRIMARY_GROUP,DIGI_ERR_INVALID_ARG, 0, 0);

    if(DIGI_MAPPER_PRIMARY_GROUP_DONT_CARE   == p_group &&
       DIGI_MAPPER_SECONDARY_GROUP_DONT_CARE == s_group)
    {
        *post_mld_index = 0;
        PMC_RETURN();
    }
    
    switch(group_size)
    {
    case DIGI_GRP_SIZE_10G:
        *post_mld_index = p_group * 4 + s_group%4;
        break;
    case DIGI_GRP_SIZE_40G:
        *post_mld_index = p_group * 4;
        break;
    case DIGI_GRP_SIZE_100G:
        *post_mld_index = 0;
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
        break;
    }
    
    
    PMC_RETURN();
} /* digi_mapper_post_mld_index_get */


/*******************************************************************************
* digi_post_mld_dsi_schd_entry_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine scheduler addresses corresponding to
*   post MLD DSI lanes specified with dsi_mask.
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   dsi_mask          - mask to identify the set of post MLD DSI lanes assigned
*                       to for processing a Serdes Signal
*
*
* OUTPUTS:
*   schd_addr_alloc   - Array to identify scheduler addresses corresponding to
*                       post MLD DSI lanes specified with dsi_mask
*                       TRUE: scheduler address associated with post MLD DSI
*                       lane \n
*                       FALSE: scheduler address not associated with post MLD
*                       DSI lane \n
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_post_mld_dsi_schd_entry_get(digi_handle_t *digi_handle,
                                             UINT16 dsi_mask,
                                             BOOL *schd_addr_alloc)
{
    /* this provides the spreadsheet data of lane assignment from dsi lane
       to scheduler addresses as needed by MAPTON, ENET_LINE/SYS, CBRC, CPB, ODUKSW, FO2 */
    UINT8 i = 0;
    UINT8 j = 0;
    UINT8 k = 0;
    UINT8 index = 0;

    PMC_ENTRY();

    /*initialize the schd_addr_alloc*/
    for(i=0; i<DIGI_SCHD_96_ENTRY; i++)
    {
        schd_addr_alloc[i] = FALSE;
    }

    for(i=0; i<DIGI_POST_MLD_DSI_LANE_MAX; i++)
    {
        if (dsi_mask & DIGI_SCHD_ALLOC_BITMASK) {
            j = (i/4)+((i%4)*3);
            for(k=0; k<DIGI_SCHD_10G_ENTRY_NUM; k++)
            {
                index = j+(k*DIGI_SCHD_ENTRY_SPREAD);
                if(index<DIGI_SCHD_96_ENTRY)
                {
                    schd_addr_alloc[index] = TRUE;
                } else {
                    PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                }
            }
        }
        dsi_mask = dsi_mask >> 1;
    }

    PMC_RETURN();

} /* digi_post_mld_dsi_schd_entry_get */


/*******************************************************************************
* digi_mapper_post_mld_dsi_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine Post MDL DSI based on primary and
*   secondary group.
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   p_group           - Enum, Primary group to configure mapper channel
*                       against.
*   s_group           - Enum, Secondary group to configure mapper channel
*                       against.
*   group_size        - mumber of 10G secondary groups required for the mapper
*                       application see enum type digi_group_size_t
*
*
* OUTPUTS:
*   *dsi_mask_ptr     - mask to identify the set of post MLD DSI lanes assigned
*                       to for processing a Serdes Signal
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_mapper_post_mld_dsi_get(digi_handle_t *digi_handle,
                                          digi_mapper_primary_group_t p_group,
                                          digi_mapper_secondary_group_t s_group,
                                          digi_group_size_t group_size,
                                          UINT16 *dsi_mask_ptr)
{
    /*
      concern:  we are naming this 'post_mld_dsi', we are asking for entries in the
      'shadow' of this 'post_mld_dsi', is this the right name for the API or do we
      bring in concept of shadow?
    */

    UINT32 post_mld_dsi_lane = 0;
    UINT16 dsi_mask = 0;

    PMC_ENTRY();

    PMC_ASSERT(s_group < LAST_DIGI_MAPPER_SECONDARY_GROUP,DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(p_group < LAST_DIGI_MAPPER_PRIMARY_GROUP,DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(group_size < LAST_DIGI_GRP_SIZE,DIGI_ERR_INVALID_ARG, 0, 0);

    digi_mapper_post_mld_index_get(p_group, s_group, group_size, &post_mld_dsi_lane);

    if(DIGI_MAPPER_PRIMARY_GROUP_DONT_CARE   == p_group &&
       DIGI_MAPPER_SECONDARY_GROUP_DONT_CARE == s_group )
    {
        dsi_mask = DIGI_POST_MLD_DSI_120G_BITMASK;
    }
    else if (DIGI_MAPPER_PRIMARY_GROUP_DONT_CARE  == p_group &&
             DIGI_MAPPER_SECONDARY_GROUP_DONT_CARE > s_group )
    {
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }
    else
    {
        switch(group_size)
        {
        case DIGI_GRP_SIZE_10G:

            /* If a particular 40G group is specified,then use a 40g mask */
            if(DIGI_MAPPER_PRIMARY_GROUP_DONT_CARE != p_group && DIGI_MAPPER_SECONDARY_GROUP_DONT_CARE == s_group)
            {
                dsi_mask = DIGI_POST_MLD_DSI_40G_BITMASK;
            }
            else
            {
                dsi_mask = DIGI_POST_MLD_DSI_10G_BITMASK;
            }
            break;
        case DIGI_GRP_SIZE_40G:
            dsi_mask = DIGI_POST_MLD_DSI_40G_BITMASK;
            break;
        case DIGI_GRP_SIZE_100G:
            dsi_mask = DIGI_POST_MLD_DSI_100G_BITMASK;
            break;
        default:
            PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
            break;
        }
    }
    dsi_mask = dsi_mask << post_mld_dsi_lane;
    PMC_LOG_TRACE("post_mld_dsi_lane is:%d\n",post_mld_dsi_lane);
    *dsi_mask_ptr = dsi_mask;
    PMC_LOG_TRACE("dsi_mask_ptr is:%d\n",dsi_mask);

    PMC_RETURN();
} /* digi_mapper_post_mld_dsi_get */

/*******************************************************************************
* digi_mapper_db_test_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API test/update the scheduler address for all DB (MAPOTN, ENET, CPB) to
*   ensure no allocation conflict and updates the relevant database set with the
*   appropriate channel data.
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   schd_addr         - calendar offset to be read and set for channel data.
*                       Valid values 0 to 95.
*   cpb_port_type     - CPB output port see enum type util_global_cpb_port_t
*   enet_line_as_pmon - Set the enet line db up if enet line is to only be used
*                       as pmon.
*   mapper_chnl       - Mapper Channel to be configured
*                       Valid values 0 to 95.
*   enet_link         - ENET line link to be configured
*                       Valid values 0 to 11.
*
*
* OUTPUTS:
*
*
* RETURNS:
*   BOOL              - Success indication of updating the potential scheduler
*                       offset:\n
*                       TRUE:  Scheduler entry available and updated with
*                              provided channel data\n
*                       FALSE: Scheduler entry already occupied. No
*                              modification to db entry.
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL digi_mapper_db_test_update(digi_handle_t *digi_handle,
                                        UINT32 schd_addr,
                                        util_global_cpb_port_t cpb_port_type,
                                        BOOL8 enet_line_as_pmon,
                                        UINT32 mapper_chnl,
                                        UINT32 enet_link)
{
    UINT32 output_port_ptr;
    UINT32 output_chnl_ptr;
    UINT32 rd_channel_id_ptr;
    UINT32 chnl;
    UINT32 cpb_chnl;
    UINT32 link;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* test all db for this entry being available */

    if((UTIL_GLOBAL_CPB_PORT_ENET_LINE == cpb_port_type) ||
       (enet_line_as_pmon == TRUE)) {

        PMC_LOG_TRACE("check ENET DB\n");
        result = enet_db_entry_get(digi_handle->enet_line_handle, schd_addr,
                                   &link);
        if(DIGI_SCHD_ENTRY_UNASSGINED != link)
        {
            PMC_RETURN(FALSE);
        }
    }

    if(PMC_SUCCESS == result)
    {
        result = cpb_dcs_db_entry_get(digi_handle->dcpb_handle,
                                      DIGI_SCHD_MAPPER_DCS_INSTANCE, schd_addr,
                                      &output_port_ptr,
                                      &output_chnl_ptr,
                                      &rd_channel_id_ptr);
        if(DIGI_SCHD_ENTRY_UNASSGINED != rd_channel_id_ptr )
        {
            PMC_RETURN(FALSE);
        }
    }
    if(PMC_SUCCESS == result)
    {
        result = mapotn_db_entry_get(digi_handle->mapotn_handle, schd_addr, &chnl);
        if(DIGI_SCHD_ENTRY_UNASSGINED != chnl)
        {
            PMC_RETURN(FALSE);
        }
    }

    /* write all database with appropriate values */
    if(PMC_SUCCESS == result)
    {
        if((UTIL_GLOBAL_CPB_PORT_ENET_LINE == cpb_port_type) ||
           (enet_line_as_pmon == TRUE)) {

            /* write to ENET DB */
            PMC_LOG_TRACE("write to ENET DB\n");
            result = enet_db_entry_set(digi_handle->enet_line_handle, schd_addr,
                                       enet_link);
        }

        if(UTIL_GLOBAL_CPB_PORT_ENET_LINE == cpb_port_type) {

            cpb_chnl = enet_link;
        }
        else
        {
            cpb_chnl = mapper_chnl;
        }
    }

    if(PMC_SUCCESS == result)
    {
        result = cpb_dcs_db_entry_set(digi_handle->dcpb_handle,
                                      DIGI_SCHD_MAPPER_DCS_INSTANCE,
                                      schd_addr,
                                      cpb_port_type,
                                      cpb_chnl);
    }

    if(PMC_SUCCESS == result)
    {
        result = mapotn_db_entry_set(digi_handle->mapotn_handle, schd_addr, mapper_chnl);
    }

    if(PMC_SUCCESS != result)
    {
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    PMC_RETURN(TRUE);

} /* digi_mapper_db_test_update */


/*******************************************************************************
* digi_mapper_enet_line_db_test_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API test/update the scheduler address for all DB (MAPOTN, ENET, CPB) to
*   ensure no allocation conflict and updates the relevant database set with the
*   appropriate channel data.
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   schd_addr         - calendar offset to be read and set for channel data.
*                       Valid values 0 to 95.
*   cpb_port_type     - CPB output port see enum type util_global_cpb_port_t
*   enet_line_as_pmon - Set the enet line db up if enet line is to only be used
*                       as pmon.
*   mapper_chnl       - Mapper Channel to be configured
*                       Valid values 0 to 95.
*   enet_link         - ENET line link to be configured
*                       Valid values 0 to 11.
*
*
* OUTPUTS:
*
*
* RETURNS:
*   BOOL              - Success indication of updating the potential scheduler
*                       offset:\n
*                       TRUE:  Scheduler entry available and updated with
*                              provided channel data\n
*                       FALSE: Scheduler entry already occupied. No
*                              modification to db entry.
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL digi_mapper_enet_line_db_test_update(digi_handle_t *digi_handle,
                                                  UINT32 schd_addr,
                                                  util_global_cpb_port_t cpb_port_type,
                                                  BOOL8 enet_line_as_pmon,
                                                  UINT32 mapper_chnl,
                                                  UINT32 enet_link)
{
    UINT32 output_port_ptr;
    UINT32 output_chnl_ptr;
    UINT32 rd_channel_id_ptr;
    UINT32 link;
    BOOL8 include_enet_line = FALSE, include_dcpb = FALSE;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* determine relevant db */
    if(UTIL_GLOBAL_CPB_PORT_ENET_LINE == cpb_port_type)
    {
        /* DCPB will use ENET_LINE DCS port */
        include_enet_line = TRUE;
        include_dcpb = TRUE;
    } else if (enet_line_as_pmon == TRUE) {
        /* DCPB will use MAPOTN DCS port */
        include_enet_line = TRUE;
    }

    /* test all relevant db for this entry being available */
    if(include_enet_line == TRUE)
    {

        PMC_LOG_TRACE("check ENET DB\n");
        result = enet_db_entry_get(digi_handle->enet_line_handle, schd_addr,
                                   &link);
        if(DIGI_SCHD_ENTRY_UNASSGINED != link)
        {
            PMC_RETURN(FALSE);
        }
    }

    if(PMC_SUCCESS == result && include_dcpb == TRUE)
    {
        result = cpb_dcs_db_entry_get(digi_handle->dcpb_handle,
                                      DIGI_SCHD_ENET_LINE_DCS_INSTANCE, schd_addr,
                                      &output_port_ptr,
                                      &output_chnl_ptr,
                                      &rd_channel_id_ptr);
        if(DIGI_SCHD_ENTRY_UNASSGINED != rd_channel_id_ptr )
        {
            PMC_RETURN(FALSE);
        }
    }

    /* write all database with appropriate values */
    if(PMC_SUCCESS == result && include_enet_line == TRUE)
    {
        if((UTIL_GLOBAL_CPB_PORT_ENET_LINE == cpb_port_type) ||
           (enet_line_as_pmon == TRUE)) {

            /* write to ENET DB */
            PMC_LOG_TRACE("write to ENET DB\n");
            result = enet_db_entry_set(digi_handle->enet_line_handle, schd_addr,
                                       enet_link);
        }
    }

    if(PMC_SUCCESS == result && include_dcpb == TRUE)
    {
        result = cpb_dcs_db_entry_set(digi_handle->dcpb_handle,
                                      DIGI_SCHD_ENET_LINE_DCS_INSTANCE,
                                      schd_addr,
                                      cpb_port_type,
                                      enet_link);
    }

    if(PMC_SUCCESS != result)
    {
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    PMC_RETURN(TRUE);

} /* digi_mapper_enet_line_db_test_update */

/*******************************************************************************
* digi_mapper_mapotn_db_test_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API test/update the scheduler address for all DB (MAPOTN, ENET, CPB) to
*   ensure no allocation conflict and updates the relevant database set with the
*   appropriate channel data.
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   schd_addr         - calendar offset to be read and set for channel data.
*                       Valid values 0 to 95.
*   cpb_port_type     - CPB output port see enum type util_global_cpb_port_t
*   enet_line_as_pmon - Set the enet line db up if enet line is to only be used
*                       as pmon.
*   mapper_chnl       - Mapper Channel to be configured
*                       Valid values 0 to 95.
*   enet_link         - ENET line link to be configured
*                       Valid values 0 to 11.
*
*
* OUTPUTS:
*
*
* RETURNS:
*   BOOL              - Success indication of updating the potential scheduler
*                       offset:\n
*                       TRUE:  Scheduler entry available and updated with
*                              provided channel data\n
*                       FALSE: Scheduler entry already occupied. No
*                              modification to db entry.
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL digi_mapper_mapotn_db_test_update(digi_handle_t *digi_handle,
                                               UINT32 schd_addr,
                                               util_global_cpb_port_t cpb_port_type,
                                               BOOL8 enet_line_as_pmon,
                                               UINT32 mapper_chnl,
                                               UINT32 enet_link)
{
    UINT32 output_port_ptr;
    UINT32 output_chnl_ptr;
    UINT32 rd_channel_id_ptr;
    UINT32 chnl;
    BOOL8 include_dcpb = FALSE;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);


    /* determine relevant db */
    if(UTIL_GLOBAL_CPB_PORT_MAPOTN == cpb_port_type)
    {
        include_dcpb = TRUE;
    }

    /* test all relevant db for this entry being available */
    if(PMC_SUCCESS == result && include_dcpb == TRUE)
    {
        result = cpb_dcs_db_entry_get(digi_handle->dcpb_handle,
                                      DIGI_SCHD_MAPPER_DCS_INSTANCE, schd_addr,
                                      &output_port_ptr,
                                      &output_chnl_ptr,
                                      &rd_channel_id_ptr);
        if(DIGI_SCHD_ENTRY_UNASSGINED != rd_channel_id_ptr )
        {
            PMC_RETURN(FALSE);
        }
    }
    if(PMC_SUCCESS == result)
    {
        result = mapotn_db_entry_get(digi_handle->mapotn_handle, schd_addr, &chnl);
        if(DIGI_SCHD_ENTRY_UNASSGINED != chnl)
        {
            PMC_RETURN(FALSE);
        }
    }

    /* write all required database with appropriate values */
    if(PMC_SUCCESS == result && include_dcpb == TRUE)
    {
        result = cpb_dcs_db_entry_set(digi_handle->dcpb_handle,
                                      DIGI_SCHD_MAPPER_DCS_INSTANCE,
                                      schd_addr,
                                      cpb_port_type,
                                      mapper_chnl);
    }

    if(PMC_SUCCESS == result)
    {
        result = mapotn_db_entry_set(digi_handle->mapotn_handle, schd_addr, mapper_chnl);
    }

    if(PMC_SUCCESS != result)
    {
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    PMC_RETURN(TRUE);

} /* digi_mapper_mapotn_db_test_update */



/*******************************************************************************
* digi_mapper_db_clear
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API clears database entries used by a mapper channel in the relevant
*   databases
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   cpb_port_type     - CPB output port see enum type util_global_cpb_port_t
*   mapper_chnl       - Mapper Channel
*                       Valid values 0 to 95.
*   enet_link         - ENET line link
*                       Valid values 0 to 11.
*   is_umbilical_case - TRUE if we are in ENET_LINE umbilical mode. FALSE
*                       otherwise.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_mapper_db_clear(digi_handle_t *digi_handle,
                                       util_global_cpb_port_t cpb_port_type,
                                       UINT32 mapper_chnl,
                                       UINT32 enet_link,
                                       BOOL8 is_umbilical_case)
{

    UINT32 cpb_chnl;
    UINT32 dcs_schd_inst = DIGI_SCHD_MAPPER_DCS_INSTANCE;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* determine which db have entries to clear */
    if ((UTIL_GLOBAL_CPB_PORT_ENET_LINE == cpb_port_type) || (is_umbilical_case == TRUE)) 
    {
        /*Need to remove entries from ENET DB */
        PMC_LOG_TRACE("clear ENET DB\n");
        result = enet_db_entry_clear(digi_handle->enet_line_handle, enet_link);
    }
    cpb_chnl = ((UTIL_GLOBAL_CPB_PORT_ENET_LINE == cpb_port_type) ? enet_link : mapper_chnl);


    if(UTIL_GLOBAL_CPB_PORT_ENET_LINE == cpb_port_type && digi_handle->var.etrans_dcpb_use_model == TRUE)
    {
        dcs_schd_inst = DIGI_SCHD_ENET_LINE_DCS_INSTANCE;
    }

    if(PMC_SUCCESS == result)
    {
        result = cpb_dcs_db_entry_clear(digi_handle->dcpb_handle,
                                        dcs_schd_inst,
                                        cpb_port_type,
                                        cpb_chnl);
    }

    if(PMC_SUCCESS == result)
    {
        result = mapotn_db_entry_clear(digi_handle->mapotn_handle, mapper_chnl);
    }

    PMC_RETURN(result);

} /* digi_mapper_db_clear */


/*******************************************************************************
* digi_mapper_db_prov_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API retrieves scheduling resources avaliable to the channel being
*   provisioned.  It tests to ensure no allocation conflict and updates the
*   relevant database set with the appropriate channel data.
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   p_group           - Enum, Primary group to configure mapper channel
*                       against.
*   s_group           - Enum, Secondary group to configure mapper channel
*                       against.
*   group_size        - mumber of 10G secondary groups required for the mapper
*                       application see enum type digi_group_size_t
*   cpb_port_type     - CPB output port see enum type util_global_cpb_port_t
*   enet_line_as_pmon - Set the enet line db up if enet line is to only be used
*                       as pmon.
*   mapper_chnl       - Mapper Channel to be configured
*                       Valid values 0 to 95.
*   enet_link         - ENET line link to be configured
*                       Valid values 0 to 11.
*   num_cal_entry_req - Nnumber of required calendar entires
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_mapper_db_prov_cfg(digi_handle_t *digi_handle,
                                          digi_mapper_primary_group_t p_group,
                                          digi_mapper_secondary_group_t s_group,
                                          digi_group_size_t group_size,
                                          util_global_cpb_port_t cpb_port_type,
                                          BOOL8 enet_line_as_pmon,
                                          UINT32 mapper_chnl,
                                          UINT32 enet_link,
                                          UINT32 num_cal_entry_req)
{
    UINT16 dsi_mask;
    BOOL schd_addr_alloc[DIGI_SCHD_96_ENTRY];
    UINT32 i = 0; /* counter */
    UINT32 j = 0; /* counter */
    UINT8 success_update = 0;
    BOOL update = FALSE;
    UINT32 sched_mask[][DIGI_NUM_ODU0S_PER_LANE_MAX] = DIGI_SCHED_MASK;

    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(s_group < LAST_DIGI_MAPPER_SECONDARY_GROUP,DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(p_group < LAST_DIGI_MAPPER_PRIMARY_GROUP,DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(group_size < LAST_DIGI_GRP_SIZE,DIGI_ERR_INVALID_ARG, 0, 0);

    if(cpb_port_type < UTIL_GLOBAL_CPB_PORT_MAPOTN || cpb_port_type > UTIL_GLOBAL_CPB_PORT_ENET_LINE)
    {
        result = DIGI_ERR_INVALID_ARG;
    }

    if(PMC_SUCCESS == result)
    {
        /* get entries */
        digi_mapper_post_mld_dsi_get(digi_handle, p_group, s_group, group_size, &dsi_mask);
        digi_post_mld_dsi_schd_entry_get(digi_handle, dsi_mask, schd_addr_alloc);

        /* test all db for this entry being available */
        /* write all database with appropriate values */
        for (i = 0; i < DIGI_SERDES_DSI_LANES_MAX; i++) {
            for (j = 0; j < DIGI_NUM_ODU0S_PER_LANE_MAX; j++) {

                if(schd_addr_alloc[sched_mask[i][j]] == TRUE)
                {
                    PMC_LOG_TRACE("schd_addr:%d  success_update:%d\n", sched_mask[i][j], success_update);

                    if(digi_handle->var.etrans_dcpb_use_model == FALSE)
                    {
                        update = digi_mapper_db_test_update(digi_handle, sched_mask[i][j], cpb_port_type,
                                                            enet_line_as_pmon, mapper_chnl, enet_link);
                    } else {
                        update = digi_mapper_enet_line_db_test_update(digi_handle, sched_mask[i][j], cpb_port_type,
                                                                      enet_line_as_pmon, mapper_chnl, enet_link);
                    }
                    if(TRUE == update)
                    {
                        success_update ++;
                        if(success_update == num_cal_entry_req)
                        {
                            i = DIGI_SERDES_DSI_LANES_MAX;
                            j = DIGI_NUM_ODU0S_PER_LANE_MAX;
                        }
                    }
                }
            }
        }

        /*if(num_cal_entry_req > success_update)*/
        if(num_cal_entry_req != success_update)
        {
            /*remove all entries that was added if not enough recources was available  */
            result = digi_mapper_db_clear(digi_handle, cpb_port_type, mapper_chnl,
                                          enet_link, FALSE);

            if(PMC_SUCCESS == result)
            {
                result = DIGI_ERR_SCHD_INSUFFICIENT_RESOURCES_AVAILABLE;
            }
        }

        if(PMC_SUCCESS == result && digi_handle->var.etrans_dcpb_use_model == TRUE)
        {
            /* retrieve a full mask of calendar entries to select for the MAPOTN SS */
            digi_mapper_post_mld_dsi_get(digi_handle, DIGI_MAPPER_PRIMARY_GROUP_DONT_CARE, DIGI_MAPPER_SECONDARY_GROUP_DONT_CARE, DIGI_GRP_SIZE_100G, &dsi_mask);
            digi_post_mld_dsi_schd_entry_get(digi_handle, dsi_mask, schd_addr_alloc);

            success_update = 0;
            /* test all db for this entry being available */
            /* write all database with appropriate values */
            for (i = 0; i < DIGI_SERDES_DSI_LANES_MAX; i++) {
                for (j = 0; j < DIGI_NUM_ODU0S_PER_LANE_MAX; j++) {
    
                    if(schd_addr_alloc[sched_mask[i][j]] == TRUE)
                    {
                        PMC_LOG_TRACE("schd_addr:%d  success_update:%d\n", sched_mask[i][j], success_update);

                        update = digi_mapper_mapotn_db_test_update(digi_handle, sched_mask[i][j], cpb_port_type,
                                                                   enet_line_as_pmon, mapper_chnl, enet_link);
                        if(TRUE == update)
                        {
                            success_update ++;
                            if(success_update == num_cal_entry_req)
                            {
                                i = DIGI_SERDES_DSI_LANES_MAX;
                                j = DIGI_NUM_ODU0S_PER_LANE_MAX;
                            }
                        }
                    }
                }
            }

            /*if(num_cal_entry_req > success_update)*/
            if(num_cal_entry_req != success_update)
            {
                /*remove all entries that was added if not enough recources was available  */
                result = digi_mapper_db_clear(digi_handle, cpb_port_type, mapper_chnl,
                                              enet_link, FALSE);
    
                if(PMC_SUCCESS == result)
                {
                    result = DIGI_ERR_SCHD_INSUFFICIENT_RESOURCES_AVAILABLE;
                }
            }

        }
    }
    PMC_RETURN(result);

} /* digi_mapper_db_prov_cfg */


/*******************************************************************************
* digi_mapper_db_deprov_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API frees database entries used by a channel in the releveant databases
*   as part of a higher level channel deprovisioning operation. \n\n
*
*   The entries are now available for usage by other channels in future
*   provision operations.
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   cpb_port_type     - CPB output port see enum type util_global_cpb_port_t
*   mapper_chnl       - Mapper Channel to be deprovisioned.
*                       Valid values 0 to 95.
*   enet_link         - ENET line link to be deprovisioned.
*                       Valid values 0 to 11.
*   is_umbilical_case - TRUE if we are in ENET_LINE umbilical mode. FALSE
*                       otherwise.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_mapper_db_deprov_cfg(digi_handle_t *digi_handle,
                                           util_global_cpb_port_t cpb_port_type,
                                           UINT32 mapper_chnl,
                                           UINT32 enet_link,
                                           BOOL8 is_umbilical_case)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    result = digi_mapper_db_clear(digi_handle, cpb_port_type, mapper_chnl,
                                  enet_link, is_umbilical_case);

    PMC_RETURN(result);

} /* digi_mapper_db_deprov_cfg */


/*******************************************************************************
* digi_coreotn_ho_db_clear
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API clears database entries used by a COREOTN HO channel in the relevant
*   databases
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   ho_chnl_id        - COREOTN HO Channel ID.  
*                       Valid values 0 to 95.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_coreotn_ho_db_clear(digi_handle_t *digi_handle,
                                           UINT32 ho_chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();
    
    result = coreotn_db_ho_entry_update(digi_handle->coreotn_handle, UTIL_GEN_DB_LINE_CORE_OTN_RX_DB, 
                                        ho_chnl_id);
 
    if (PMC_SUCCESS == result)
    {
        result = coreotn_db_ho_entry_update(digi_handle->coreotn_handle, UTIL_GEN_DB_LINE_CORE_OTN_TX_DB, 
                                            ho_chnl_id);
    }      
    
    PMC_RETURN(result);                                                                            
} /* digi_coreotn_ho_db_clear */                  


/*******************************************************************************
* digi_cbrc_prov_params_convert
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the groupsize for CBRC
*
* INPUTS:
*   mode             - the digi CBR mode
*
* OUTPUTS:
*   *group_size      - the number of post MLD DSI lanes required for this mode.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_cbrc_prov_params_convert(digi_cbr_client_mode_t mode,
                                          digi_group_size_t* group_size)
{
    PMC_ENTRY();

    switch(mode) {
    case DIGI_CBR_CLIENT_40G_STS768:
    case DIGI_CBR_CLIENT_40G_STM256:
        *group_size = DIGI_GRP_SIZE_40G;
        break;

    case DIGI_CBR_CLIENT_10G_STS192:
    case DIGI_CBR_CLIENT_10G_STM64:
    case DIGI_CBR_CLIENT_10G_FC1200_ODU1F:
    case DIGI_CBR_CLIENT_10G_FC1200_ODU2F:
    case DIGI_CBR_CLIENT_10G_FC1200_GFP_ODU2E:
    case DIGI_CBR_CLIENT_10G_FC800:
    case DIGI_CBR_CLIENT_10G_CPRI_5G:
    case DIGI_CBR_CLIENT_10G_CPRI_6G:
    case DIGI_CBR_CLIENT_10G_CPRI_10G:
    case DIGI_CBR_CLIENT_10G_GDPS_5G:
    case DIGI_CBR_CLIENT_10G_GDPS_10G:
    case DIGI_CBR_CLIENT_10G_STS192_PRBS:
    case DIGI_CBR_CLIENT_10G_STM64_PRBS:
    case DIGI_CBR_CLIENT_10G_8B_10B_IDLE:
    case DIGI_CBR_CLIENT_10G_64B_66B_IDLE:
    case DIGI_CBR_CLIENT_10G_8B_10B_ARB:    
        *group_size = DIGI_GRP_SIZE_10G;
        break;

    default:
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        break;
    }

    PMC_RETURN();
} /* digi_cbrc_prov_params_convert */

/*******************************************************************************
* digi_cbrc_db_test_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API test/update the scheduler address for all DB (CBRC, CPB) to
*   ensure no allocation conflict and updates the relevant database set with the
*   appropriate CBRC port data.
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   schd_addr         - calendar offset to be read and set for port data.
*                       Valid values 0 to 95.
*   cbrc_port         - CBRC port to be configured
*                       Valid values 0 to 11.
*   cbrc_dcs_inst     - CBRC DCS instance 
*   no_cpb_cfg        - TRUE: do not test/populated CPB DCS entries, FALES:
*                       test/populated DCS entries.
*
*
* OUTPUTS:
*
*
* RETURNS:
*   BOOL              - Success indication of updating the potential scheduler
*                       offset:\n
*                       TRUE:  Scheduler entry available and updated with
*                              provided channel data\n
*                       FALSE: Scheduler entry already occupied. No
*                              modification to db entry.
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL digi_cbrc_db_test_update(digi_handle_t *digi_handle,
                                      UINT32 schd_addr,
                                      UINT32 cbrc_port, 
                                      UINT32 cbrc_dcs_inst,
                                      BOOL8  no_cpb_cfg)
{
    UINT32 output_port_ptr;
    UINT32 output_chnl_ptr;
    UINT32 rd_channel_id_ptr;
    UINT32 port;
    UINT32 db_instance;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* test all db for this entry being available */
    for(db_instance = 0; db_instance < LAST_CBRC_DB_ID; db_instance++)
    {
        if(PMC_SUCCESS == result)
        {
            result = cbrc_db_entry_get(digi_handle->cbrc_handle, (cbrc_db_id_t)db_instance, schd_addr, &port);
            if(DIGI_SCHD_ENTRY_UNASSGINED != port)
            {
                PMC_RETURN(FALSE);
            }
        }
    }

    if(PMC_SUCCESS == result && no_cpb_cfg == FALSE)
    {
        result = cpb_dcs_db_entry_get(digi_handle->dcpb_handle,
                                      cbrc_dcs_inst, schd_addr,
                                      &output_port_ptr,
                                      &output_chnl_ptr,
                                      &rd_channel_id_ptr);
        if(DIGI_SCHD_ENTRY_UNASSGINED != rd_channel_id_ptr )
        {
            PMC_RETURN(FALSE);
        }
    }

    /* write all database with appropriate values */
    /* write to CBRC DB */
    for(db_instance = 0; db_instance < LAST_CBRC_DB_ID; db_instance++)
    {
        if(PMC_SUCCESS == result)
        {
            result = cbrc_db_entry_set(digi_handle->cbrc_handle, (cbrc_db_id_t)db_instance, schd_addr, cbrc_port);
        }
    }

    if(PMC_SUCCESS == result && no_cpb_cfg == FALSE)
    {
        result = cpb_dcs_db_entry_set(digi_handle->dcpb_handle,
                                      cbrc_dcs_inst,
                                      schd_addr,
                                      UTIL_GLOBAL_CPB_PORT_CBRC,
                                      cbrc_port);
    }

    if(PMC_SUCCESS != result)
    {
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    PMC_RETURN(TRUE);

} /* digi_cbrc_db_test_update */

/*******************************************************************************
* digi_cbrc_db_prov_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API retrieves scheduling resources avaliable to the CBRC port being
*   provisioned.  It tests to ensure no allocation conflict and updates the 
*   relevant database set with the appropriate port data.
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   group_size        - mumber of 10G secondary groups required for the enet
*                       application see enum type digi_group_size_t
*   cbrc_port         - CBRC port to be configured
*                       Valid values 0 to 11.
*   no_cpb_cfg        - TRUE: do not test/populated CPB DCS entries, FALES:
*                       test/populated DCS entries.
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cbrc_db_prov_cfg(digi_handle_t *digi_handle,
                                       digi_group_size_t group_size,
                                       UINT32 cbrc_port,
                                       BOOL8 no_cpb_cfg)
{
    UINT16 dsi_mask;
    BOOL schd_addr_alloc[DIGI_SCHD_96_ENTRY];
    UINT32 schd_addr;
    UINT8 success_update = 0;
    UINT32 num_cal_entry_req = 0;
    BOOL update = FALSE;
    UINT32 dummy;
    UINT32 cbrc_dcs_inst;

    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(group_size < LAST_DIGI_GRP_SIZE,DIGI_ERR_INVALID_ARG, 0, 0);
    
    switch(group_size)
    {
    case DIGI_GRP_SIZE_10G:
        num_cal_entry_req = 8;
        break;
    case DIGI_GRP_SIZE_40G:
        num_cal_entry_req = 32;
        break;
    case DIGI_GRP_SIZE_100G:
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
        break;
    }
    
    
    result = digi_cpb_pop_port_get(digi_handle,
                                   UTIL_GLOBAL_CPB_PORT_CBRC,
                                   0,
                                   &cbrc_dcs_inst,
                                   &dummy);
                                   
    PMC_LOG_TRACE("cbrc_dcs_inst: %d\n", cbrc_dcs_inst);

    
    if(PMC_SUCCESS == result)
    {
        /* get entries */
        digi_enet_post_mld_dsi_get(digi_handle, cbrc_port, group_size, &dsi_mask);
        digi_post_mld_dsi_schd_entry_get(digi_handle, dsi_mask, schd_addr_alloc);

        /* test all db for this entry being available */
        /* write all database with appropriate values */
        for(schd_addr=0; schd_addr<DIGI_SCHD_96_ENTRY; schd_addr++)
        {
            if(TRUE == schd_addr_alloc[schd_addr])
            {
                PMC_LOG_TRACE("schd_addr:%d  success_update:%d\n", schd_addr, success_update);
                update = digi_cbrc_db_test_update(digi_handle, schd_addr,
                                                  cbrc_port, cbrc_dcs_inst, no_cpb_cfg);
                if(TRUE == update)
                {
                    success_update ++;
                }
            }
        }

        if(num_cal_entry_req != success_update)
        {
            /*remove all entries that was added if not enough recources was available  */
            result = digi_cbrc_db_clear(digi_handle, cbrc_port, cbrc_dcs_inst);

            if(PMC_SUCCESS == result)
            {
                result = DIGI_ERR_SCHD_INSUFFICIENT_RESOURCES_AVAILABLE;
            }
        }
    }
    PMC_RETURN(result);

} /* digi_cbrc_db_prov_cfg */


/*******************************************************************************
* digi_cbrc_db_clear
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API clears database entries used by an CBRC port in the relevant
*   databases.
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   cbrc_port         - CBRC port to be configured
*                       Valid values 0 to 11.
*   cbrc_dcs_inst     - CBRC DCS instance 
*
*
* OUTPUTS:
*   None.
*   
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_cbrc_db_clear(digi_handle_t *digi_handle,
                                     UINT32 cbrc_port, 
                                     UINT32 cbrc_dcs_inst)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 db_instance;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    for(db_instance=0; db_instance<LAST_CBRC_DB_ID; db_instance++)
    {
        if(PMC_SUCCESS == result)
        {
            result = cbrc_db_entry_clear(digi_handle->cbrc_handle, (cbrc_db_id_t)db_instance, cbrc_port);
        }
    }

    if(PMC_SUCCESS == result)
    {
        result = cpb_dcs_db_entry_clear(digi_handle->dcpb_handle,
                                        cbrc_dcs_inst,
                                        UTIL_GLOBAL_CPB_PORT_CBRC,
                                        cbrc_port);
    }

    PMC_RETURN(result);

} /* digi_cbrc_db_clear */


/*******************************************************************************
* digi_cbrc_db_deprov_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API frees database entries used by an CBRC port in the releveant
*   databases as part of a higher level port deprovisioning operation. \n\n
*
*   The entries are now available for usage by other ports in future
*   provision operations.
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   cbrc_port         - CBRC port to be configured
*                       Valid values 0 to 11.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cbrc_db_deprov_cfg(digi_handle_t *digi_handle,
                                         UINT32 cbrc_port)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 dummy;
    UINT32 cbrc_dcs_inst;

    PMC_ENTRY();
    
    result = digi_cpb_pop_port_get(digi_handle,
                                   UTIL_GLOBAL_CPB_PORT_CBRC,
                                   0,
                                   &cbrc_dcs_inst,
                                   &dummy);
                                   
    if(PMC_SUCCESS == result)
    {                      
        result = digi_cbrc_db_clear(digi_handle, cbrc_port, 
                                    cbrc_dcs_inst);
    }

    PMC_RETURN(result);

} /* digi_cbrc_db_deprov_cfg */

/*******************************************************************************
* digi_oduksw_sifd_db_test_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API test/update the scheduler address for all DB related to SIFD (ODUKSW DCS) 
*   to ensure no allocation conflict and updates the relevant database set with the
*   appropriate sifd channel data.
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   sifd_ilkn_inst    - Enum, defining SIFD interface
*   schd_addr         - calendar offset to be read and set for link data.
*                       Valid values 0 to 95.
*   chnl              - SIFD channel
*   sifd_db           - TRUE means sifd DB, FALSE is for oduksw
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   BOOL              - Success indication of updating the potential scheduler
*                       offset:\n
*                       TRUE:  Scheduler entry available and updated with
*                              provided channel data\n
*                       FALSE: Scheduler entry already occupied. No
*                              modification to db entry.
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL digi_oduksw_sifd_db_test_update(digi_handle_t *digi_handle,
                                             digi_sifd_ilkn_inst_t sifd_ilkn_inst,
                                             UINT32 schd_addr,
                                             UINT32 chnl,
                                             BOOL8 sifd_db)
{
    util_global_oduk_port_t oduk_port;
    util_gen_db_id_t dcs_inst;
    UINT32 dcs_schd_addr = schd_addr;
    UINT32 output_port, output_chnl, rd_channel_id;
    

    PMC_ERROR result = PMC_SUCCESS;   

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    switch(sifd_ilkn_inst)
    {
    case DIGI_SIFD_ILKN1:
        dcs_inst = (util_gen_db_id_t)CPB_DCS_INST_0;
        oduk_port = UTIL_GLOBAL_ODUK_PORT_ILKN1;
        break;
    case DIGI_SIFD_ILKN2:
        dcs_inst = (util_gen_db_id_t)CPB_DCS_INST_1;
        oduk_port = UTIL_GLOBAL_ODUK_PORT_ILKN2;
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
        break;
    }

    PMC_LOG_TRACE("oduksw dcs instance: %d\n", dcs_inst);     

    /* test all db for this entry being available */
    if(PMC_SUCCESS == result)
    {
        result = coreotn_oduksw_db_entry_get(digi_handle->coreotn_handle,
                                             (coreotn_oduksw_output_port_type_t)oduk_port,
                                             dcs_schd_addr,
                                             &output_port,
                                             &output_chnl,
                                             &rd_channel_id);
                                             
        if(DIGI_SCHD_ENTRY_UNASSGINED != rd_channel_id )
        {
            PMC_RETURN(FALSE);
        }
    }

    if (FALSE == sifd_db)
    {
        /* write all database with appropriate values */
        if(PMC_SUCCESS == result)
        {
            result = coreotn_oduksw_db_entry_set(digi_handle->coreotn_handle,
                                                 (coreotn_oduksw_output_port_type_t)oduk_port,
                                                 dcs_schd_addr,
                                                 chnl);
        }
    }


    if(PMC_SUCCESS != result)
    {
        PMC_ASSERT(FALSE, result, 0, 0);
    }

    PMC_RETURN(TRUE);

} /* digi_oduksw_sifd_db_test_update */

/*******************************************************************************
* digi_oduksw_sifd_db_prov_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API retrieves scheduling resources avaliable to the ENET SYS link
*   being provisioned.  It tests to ensure no allocation conflict and updates
*   the relevant database set with the appropriate link data.
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   sifd_ilkn_inst    - Enum, defining SIFD interface
*   chnl              - SIFD channel
*   num_cal_entry_req - Number of scheduler entries required
*   sifd_db           - TRUE means sifd DB, FALSE is for oduksw
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_oduksw_sifd_db_prov_cfg(digi_handle_t *digi_handle,
                                               digi_sifd_ilkn_inst_t sifd_ilkn_inst,
                                               UINT32 chnl,
                                               UINT8 num_cal_entry_req,
                                               BOOL8 sifd_db)
{
    UINT32 schd_addr;
    UINT8 success_update = 0;
    UINT32 num_current_entries = DIGI_SCHD_96_ENTRY + 1;
    BOOL update = FALSE;

    util_global_oduk_port_t oduk_port;
    util_gen_db_id_t dcs_inst = LAST_UTIL_GEN_DB;

    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl < 104,DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(num_cal_entry_req <= DIGI_SCHD_96_ENTRY,DIGI_ERR_INVALID_ARG, 0, 0);
     

    switch(sifd_ilkn_inst)
    {
    case DIGI_SIFD_ILKN1:
        dcs_inst = (util_gen_db_id_t)CPB_DCS_INST_0;
        oduk_port = UTIL_GLOBAL_ODUK_PORT_ILKN1;
        break;
    case DIGI_SIFD_ILKN2:
        dcs_inst = (util_gen_db_id_t)CPB_DCS_INST_1;
        oduk_port = UTIL_GLOBAL_ODUK_PORT_ILKN2;
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
        break;
    }
    
    PMC_LOG_TRACE("oduksw dcs instance: %d\n", dcs_inst);                              

    /* determine how many entries already exist for the channel, if any, then 
       generate a driver error. */
    if(PMC_SUCCESS == result &&
       0 != num_cal_entry_req)
    {
        result = coreotn_oduksw_dcs_db_num_entry_get(digi_handle->coreotn_handle,
                                                     (coreotn_oduksw_output_port_type_t)dcs_inst,
                                                     chnl,
                                                     &num_current_entries);
                                                     
        /*PMC_ASSERT(num_current_entries == 0, DIGI_ERR_CODE_ASSERT, 0, 0);*/
    }

    if(PMC_SUCCESS == result)
    {

            for(schd_addr=0; schd_addr<DIGI_SCHD_96_ENTRY; schd_addr++)
            {
      
                PMC_LOG_TRACE("schd_addr:%d  success_update:%d\n", schd_addr, success_update);
                update = digi_oduksw_sifd_db_test_update(digi_handle, sifd_ilkn_inst, schd_addr, chnl,sifd_db);
                if(TRUE == update)
                {
                    success_update ++;
                }
                if(num_cal_entry_req == success_update)
                {
                    schd_addr = DIGI_SCHD_96_ENTRY;
                }
            }


        if(num_cal_entry_req != success_update)
        {
            /*remove all entries that was added if not enough recources was available  */
            result = digi_oduksw_sifd_db_clear(digi_handle, sifd_ilkn_inst, chnl,sifd_db);

            if(PMC_SUCCESS == result)
            {
                result = DIGI_ERR_SCHD_INSUFFICIENT_RESOURCES_AVAILABLE;
            }
        }
    }
    PMC_RETURN(result);

} /* digi_oduksw_sifd_db_prov_cfg */


/*******************************************************************************
* digi_oduk_rate_param_convert
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to convert DIGI ODUK rate to UTIL_GLOBAL ODUKP type.
*
* INPUTS:
*   oduk_type        - the oduk data enumerate
*
* OUTPUTS:
*   *odu_type        - equivalent odu_type in Enum
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_oduk_rate_param_convert( digi_oduk_t oduk_type,
                                               util_global_odukp_type_t *odu_type )
{
    PMC_ENTRY();

    switch(oduk_type)
    {  
    case DIGI_ODUK_ODU0:
        *odu_type = UTIL_GLOBAL_ODU0;
        break;
    case DIGI_ODUK_ODU1:
        *odu_type = UTIL_GLOBAL_ODU1;
        break;
    case DIGI_ODUK_ODU2:
        *odu_type = UTIL_GLOBAL_ODU2;
        break;
    case DIGI_ODUK_ODU2E:
        *odu_type = UTIL_GLOBAL_ODU2E;
        break;
    case DIGI_ODUK_ODU1E:
        *odu_type = UTIL_GLOBAL_ODU1E;
        break;
    case DIGI_ODUK_ODU2F:
        *odu_type = UTIL_GLOBAL_ODU2F;
        break;
    case DIGI_ODUK_ODU1F:
        *odu_type = UTIL_GLOBAL_ODU1F;
        break;
    case DIGI_ODUK_ODU3:
        *odu_type = UTIL_GLOBAL_ODU3;
        break;
    case DIGI_ODUK_ODU3E2:
        *odu_type = UTIL_GLOBAL_ODU3E2;
        break;
    case DIGI_ODUK_ODU3E1:
        *odu_type = UTIL_GLOBAL_ODU3E1;
        break;
    case DIGI_ODUK_ODU4:
        *odu_type = UTIL_GLOBAL_ODU4;
        break;
    default:
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* digi_oduk_rate_param_convert */

/*******************************************************************************
* digi_odu_rate_param_convert
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to convert UTIL_GLOBAL ODUKP type to DIGI ODUK rate type.
*
* INPUTS:
*   odu_type        -  odu_type in Enum
*
* OUTPUTS:
*   *oduk_type        - equivalent oduk data enumerate
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_odu_rate_param_convert(util_global_odukp_type_t odu_type,
                                             digi_oduk_t *oduk_type)
{
    PMC_ENTRY();

    switch(odu_type)
    {  
    case UTIL_GLOBAL_ODU0:
        *oduk_type = DIGI_ODUK_ODU0;
        break;
    case UTIL_GLOBAL_ODU1:
        *oduk_type = DIGI_ODUK_ODU1;
        break;
    case UTIL_GLOBAL_ODU2:
        *oduk_type = DIGI_ODUK_ODU2;
        break;
    case UTIL_GLOBAL_ODU2E:
        *oduk_type = DIGI_ODUK_ODU2E;
        break;
    case UTIL_GLOBAL_ODU1E:
        *oduk_type = DIGI_ODUK_ODU1E;
        break;
    case UTIL_GLOBAL_ODU2F:
        *oduk_type = DIGI_ODUK_ODU2F;
        break;
    case UTIL_GLOBAL_ODU1F:
        *oduk_type = DIGI_ODUK_ODU1F;
        break;
    case UTIL_GLOBAL_ODU3:
        *oduk_type = DIGI_ODUK_ODU3;
        break;
    case UTIL_GLOBAL_ODU3E2:
        *oduk_type = DIGI_ODUK_ODU3E2;
        break;
    case UTIL_GLOBAL_ODU3E1:
        *oduk_type = DIGI_ODUK_ODU3E1;
        break;
    case UTIL_GLOBAL_ODU4:
        *oduk_type = DIGI_ODUK_ODU4;
        break;
    default:
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* digi_odu_rate_param_convert */


/*******************************************************************************
* digi_oduk_rate_num_cal_slot_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to calculate the number of calendar entries 
*   that are assigned to DIGI ODUK rate. 
*   For ODUFlex client, num_cal_slots will be 1 as only one channel ID will
*   be reserved.
*
* INPUTS:
*   client_oduk_type        - the oduk data enumerate for LO ODU rate
*   server_oduk_type        - the oduk data enumerate for HO ODU rate 
*
* OUTPUTS:
*   *num_cal_slots          - number of calendar entries occupied by the client
*                             oduk.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_oduk_rate_num_cal_slot_get( util_global_odukp_type_t client_oduk_type,
                                                  util_global_odukp_type_t server_oduk_type,
                                                  UINT32 *num_cal_slots )
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();

    switch(client_oduk_type)
    { 
    case UTIL_GLOBAL_ODU0:
        *num_cal_slots = 1;
        break;
    case UTIL_GLOBAL_ODU1:
        *num_cal_slots = 2;
        break;
    case UTIL_GLOBAL_ODU2:
        *num_cal_slots = 8;
        break;
    case UTIL_GLOBAL_ODU2E:
        if (server_oduk_type == UTIL_GLOBAL_ODU3E1 
            || server_oduk_type == UTIL_GLOBAL_ODU3E2
            || server_oduk_type == UTIL_GLOBAL_ODU4)
        {
            *num_cal_slots = 8;
        }
        else if (server_oduk_type == UTIL_GLOBAL_ODU3)
        {
            *num_cal_slots = 9;
        }
        else {
            *num_cal_slots = 0; 
            result = DIGI_ERR_INVALID_ARG;
        }
        break;
    case UTIL_GLOBAL_ODU1E:
    case UTIL_GLOBAL_ODU2F:
    case UTIL_GLOBAL_ODU1F:
        if (server_oduk_type == UTIL_GLOBAL_ODU4
            || server_oduk_type == UTIL_GLOBAL_ODU3E2 
            || server_oduk_type == UTIL_GLOBAL_ODU3)
        {
            *num_cal_slots = 9;
        }
        else {  
            *num_cal_slots = 0;  
            result = DIGI_ERR_INVALID_ARG;
        }
        break;
    case UTIL_GLOBAL_ODU3:
        if (server_oduk_type == UTIL_GLOBAL_ODU4)
        {
            *num_cal_slots = 31;
        }
        else if (server_oduk_type == UTIL_GLOBAL_ODU3E2)
        {
            *num_cal_slots = 32;
        }
        else {
            *num_cal_slots = 0; 
            result = DIGI_ERR_INVALID_ARG;
        }             
        break;
    case UTIL_GLOBAL_ODU3E2:
    case UTIL_GLOBAL_ODU3E1:
        if (server_oduk_type == UTIL_GLOBAL_ODU4)
        {
            *num_cal_slots = 33;
        }
        else {
            *num_cal_slots = 0; 
            result = DIGI_ERR_INVALID_ARG;
        }            
        break;
    case UTIL_GLOBAL_ODU4:
        *num_cal_slots = 0; 
        result = DIGI_ERR_INVALID_ARG;
        break;
    case UTIL_GLOBAL_ODUFLEX_GFP:
    case UTIL_GLOBAL_ODUFLEX_CBR:
        *num_cal_slots = 1;
        break;
    default:
        *num_cal_slots = 0; 
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    PMC_RETURN(result);
} /* digi_oduk_rate_num_cal_slot_get */

/*******************************************************************************
* digi_coreotn_mapping_mode_convert
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the mapping mode of a COREOTN channel.
*
* INPUTS:
*   mapping_type     - the mapping mode enumerate
*
* OUTPUTS:
*   *mapping_mode    - equivalent mapping mode type in Enum
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_coreotn_mapping_mode_convert( digi_otn_mapping_type_t mapping_type,
                                                     util_global_mapping_mode_t *mapping_mode )
{
    PMC_ENTRY();

    switch(mapping_type)
    {
    case DIGI_OTN_MAP_AMP:
        *mapping_mode = UTIL_GLOBAL_AMP;
        break;
    case DIGI_OTN_MAP_GMP:
        *mapping_mode = UTIL_GLOBAL_GMP;
        break;
    case LAST_DIGI_OTN_MAP:
        *mapping_mode = UTIL_GLOBAL_NO_MAP;
        break;
    default:
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* digi_coreotn_mapping_mode_convert */

/*******************************************************************************
* digi_coreotn_mapping_mode_convert_reverse
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the mapping mode of a COREOTN channel.
*   (to convert from util_global_mapping_mode_t -> digi_otn_mapping_type_t)
*
* INPUTS:
*   mapping_type     - the mapping mode enumerate
*
* OUTPUTS:
*   *mapping_mode    - equivalent mapping mode type in Enum
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_coreotn_mapping_mode_convert_reverse(util_global_mapping_mode_t mapping_mode,
                                                            digi_otn_mapping_type_t *mapping_type)
{
    PMC_ENTRY();

    switch(mapping_mode)
    {
    case UTIL_GLOBAL_AMP:
        *mapping_type = DIGI_OTN_MAP_AMP;
        break;
    case UTIL_GLOBAL_GMP:
        *mapping_type = DIGI_OTN_MAP_GMP;
        break;
    case UTIL_GLOBAL_NO_MAP:
        *mapping_type = LAST_DIGI_OTN_MAP;
        break;
    default:
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* digi_coreotn_mapping_mode_convert_reverse */


/*******************************************************************************
* digi_oduksw_rate_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the rate information provided the client
*   data type.
*
* INPUTS:
*   rate_data        - the rate data enumerate
*
* OUTPUTS:
*   *odu_type        - equivalent odu_type in Enum
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_oduksw_rate_get( digi_oduksw_stream_t rate_data,
                                        util_global_odukp_type_t *odu_type )
{
    PMC_ENTRY();

    switch(rate_data)
    {
    case DIGI_ODUKSW_STREAM_CBR_ODU0:
        *odu_type = UTIL_GLOBAL_ODU0;
        break;
    case DIGI_ODUKSW_STREAM_CBR_ODU1:
        *odu_type = UTIL_GLOBAL_ODU1;
        break;
    case DIGI_ODUKSW_STREAM_CBR_ODU2:
        *odu_type = UTIL_GLOBAL_ODU2;
        break;
    case DIGI_ODUKSW_STREAM_CBR_ODU2E:
        *odu_type = UTIL_GLOBAL_ODU2E;
        break;
    case DIGI_ODUKSW_STREAM_CBR_ODU1E:
        *odu_type = UTIL_GLOBAL_ODU1E;
        break;
    case DIGI_ODUKSW_STREAM_CBR_ODU2F:
        *odu_type = UTIL_GLOBAL_ODU2F;
        break;
    case DIGI_ODUKSW_STREAM_CBR_ODU1F:
        *odu_type = UTIL_GLOBAL_ODU1F;
        break;
    case DIGI_ODUKSW_STREAM_CBR_ODU3:
        *odu_type = UTIL_GLOBAL_ODU3;
        break;
    case DIGI_ODUKSW_STREAM_CBR_ODU3E2:
        *odu_type = UTIL_GLOBAL_ODU3E2;
        break;
    case DIGI_ODUKSW_STREAM_CBR_ODU3E1:
        *odu_type = UTIL_GLOBAL_ODU3E1;
        break;
    case DIGI_ODUKSW_STREAM_CBR_ODU4:
        *odu_type = UTIL_GLOBAL_ODU4;
        break;
    case DIGI_ODUKSW_STREAM_CBR_ODUFLEX:
        *odu_type = UTIL_GLOBAL_ODUFLEX_CBR;
        break;
    case DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX:
        *odu_type = UTIL_GLOBAL_ODUFLEX_GFP;
        break;
    default:
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* digi_oduksw_rate_get */

/*******************************************************************************
* digi_cpb_rate_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the rate information provided the client
*   data type.
*
*
* INPUTS:
*   rate_data        - the rate data enumerate
*   num_odu0         - For rate_data set to DIGI_CPB_STREAM_PKT_GFPF_ODUFLEX,
*                      defines the number of ODU0 tributary slots associated
*                      with the ODUFLEX container.
*
* OUTPUTS:
*   rate             - the data rate value without unit
*   rate_unit        - the rate unit
*                       the actual data rate is rate*10^(rate_unit)
*   cpb_data         - 0: CBR   1: Packet
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_rate_get (digi_cpb_stream_t rate_data,
                                    UINT32 num_odu0,
                                    UINT32 *rate,
                                    util_schd_chnl_rate_exp_t *rate_unit,
                                    UINT32 *cpb_data)
{
    PMC_ENTRY();
    switch(rate_data)
    {
    case DIGI_CPB_STREAM_1G25:
        *rate = 1250; *rate_unit = UTIL_SCHD_1M_BIT_SEC; *cpb_data = 0;
        break;
    case DIGI_CPB_STREAM_2G5:
        *rate = 2500; *rate_unit = UTIL_SCHD_1M_BIT_SEC; *cpb_data = 0;
        break;
    case DIGI_CPB_STREAM_FLEX:
        *rate = 1250 * num_odu0; *rate_unit = UTIL_SCHD_1M_BIT_SEC; *cpb_data = 0;
        break;
    case DIGI_CPB_STREAM_10G:
        *rate = 10000; *rate_unit = UTIL_SCHD_1M_BIT_SEC; *cpb_data = 0;
        break;
    case DIGI_CPB_STREAM_40G:
        *rate = 40000; *rate_unit = UTIL_SCHD_1M_BIT_SEC; *cpb_data = 0;
        break;
    case DIGI_CPB_STREAM_100G:
        *rate = 100000; *rate_unit = UTIL_SCHD_1M_BIT_SEC; *cpb_data = 0;
        break;
    default:
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }
    PMC_RETURN(PMC_SUCCESS);
} /* digi_cpb_rate_get */

/*******************************************************************************
* digi_cpb_push_pop_port_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the push and pop port according to
*   the input port.
*
*
* INPUTS:
*   *digi_handle            - the pointer to the digi handle instance
*   input_port              - the input port
*   output_port             - the input port
*   data_source             - ultimate data source of input_port \n
*                             0: line SerDes \n
*                             1: ODUKSW \n
*                             Applicable to ENET_LINE input_port \n
*   data_dest               - ultimate data destination of output_port \n
*                             0: line SerDes \n
*                             1: ODUKSW \n
*                             Applicable to ENET_LINE input_port \n
*
*
* OUTPUTS:
*   ingress_mux_output_port - the first push_port_id that is valid
*   num_push_ports          - the number of valid push ports
*   egress_mux_input_port   - the first pop_port_id that is valid
*   num_pop_ports           - the number of valid pop ports
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_push_pop_port_get(digi_handle_t *digi_handle,
                                            util_global_cpb_port_t input_port,
                                            util_global_cpb_port_t output_port,
                                            UINT32 data_source,
                                            UINT32 data_dest,
                                            UINT32 *ingress_mux_output_port,
                                            UINT32 *num_push_ports,
                                            UINT32 *egress_mux_input_port,
                                            UINT32 *num_pop_ports )
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();
    switch(input_port)
    {
    case UTIL_GLOBAL_CPB_PORT_ILKN1:
        /* if device configured for CPB ILKN mode, P0 must be used */
        if(1 == digi_handle->var.sifd_ilkn_1_cfg.ilkn.cpb_intf_en)
        {
            *ingress_mux_output_port = 0;
        }
        else
        {
            PMC_RETURN(DIGI_ERR_INVALID_ARG);
        }
        break;
    case UTIL_GLOBAL_CPB_PORT_ILKN2:
        /* if device configured for CPB ILKN mode, P1 must be used */
        if(1 == digi_handle->var.sifd_ilkn_2_cfg.ilkn.cpb_intf_en)
        {
            *ingress_mux_output_port = 1;
        }
        else
        {
            PMC_RETURN(DIGI_ERR_INVALID_ARG);
        }
        break;
    case UTIL_GLOBAL_CPB_PORT_CBRC:
        if(DIGI_CBRC_IS_LINE_INTF(digi_handle)){
            /* CBRC from line serdes must use P2 */
            *ingress_mux_output_port = 2;
        } else if(DIGI_CBRC_IS_SYS_INTF(digi_handle)){
            /* CBRC from system serdes may use P0 or P1, try to assign P1 first,
               return error as none available */
            if(0 == digi_handle->var.sifd_ilkn_2_cfg.ilkn.cpb_intf_en){
                *ingress_mux_output_port = 1;
                *num_pop_ports = 1;
            } else if(0 == digi_handle->var.sifd_ilkn_1_cfg.ilkn.cpb_intf_en) {
                *ingress_mux_output_port = 0;
                *num_push_ports = 1;
            } else {
                PMC_RETURN(DIGI_ERR_INVALID_ARG);
            }
        } else {
            PMC_RETURN(DIGI_ERR_INVALID_ARG);
        }
        break;
    case UTIL_GLOBAL_CPB_PORT_MAPOTN:
        /* MAPOTN must use P3 */
        *ingress_mux_output_port = 3;
        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
        /* ENET_LINE may target P2/P3 P2 if signal bound for Serdes, P3 if signal bound for ODUKSW */
        if(0 == data_source){
            *ingress_mux_output_port = 2;
        } else if(1 == data_source) {
            if(digi_handle->var.etrans_dcpb_use_model == FALSE)
            {
                *ingress_mux_output_port = 3;            
            } else {
                *ingress_mux_output_port = 2;            
            }
        } else {
            PMC_RETURN(DIGI_ERR_INVALID_ARG);
        }
        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
        /* ENET_SYS system serdes may use P0 or P1, try to assign P1 first,
           return error as none available */
        if(0 == digi_handle->var.sifd_ilkn_2_cfg.ilkn.cpb_intf_en){
            *ingress_mux_output_port = 1;
            *num_pop_ports = 1;
        } else if(0 == digi_handle->var.sifd_ilkn_1_cfg.ilkn.cpb_intf_en){
            *ingress_mux_output_port = 0;
            *num_pop_ports = 1;
        } else {
            PMC_RETURN(DIGI_ERR_INVALID_ARG);
        }
        break;
    default:
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    result = digi_cpb_pop_port_get(digi_handle,
                                   output_port,
                                   data_dest,
                                   egress_mux_input_port,
                                   num_pop_ports);
                                       


    PMC_RETURN(result);
} /* digi_cpb_push_pop_port_get */


/*******************************************************************************
* digi_cpb_pop_port_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the push and pop port according to
*   the input port.
*
*
* INPUTS:
*   *digi_handle            - the pointer to the digi handle instance
*   output_port             - the input port
*   data_dest               - ultimate data destination of output_port \n
*                             0: line SerDes \n
*                             1: ODUKSW \n
*                             Applicable to ENET_LINE input_port \n
*
*
* OUTPUTS:
*   egress_mux_input_port   - the first pop_port_id that is valid
*   num_pop_ports           - the number of valid pop ports
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_pop_port_get(digi_handle_t *digi_handle,
                                       util_global_cpb_port_t output_port,
                                       UINT32 data_dest,
                                       UINT32 *egress_mux_input_port,
                                       UINT32 *num_pop_ports)
{
    PMC_ENTRY();
    switch(output_port)
    {
    case UTIL_GLOBAL_CPB_PORT_ILKN1:
        /* if device configured for CPB ILKN mode, P0 must be used */
        if(1 == digi_handle->var.sifd_ilkn_1_cfg.ilkn.cpb_intf_en)
        {
            *egress_mux_input_port = 0;
        }
        else
        {
            PMC_RETURN(DIGI_ERR_INVALID_ARG);
        }
        break;
    case UTIL_GLOBAL_CPB_PORT_ILKN2:
        /* if device configured for CPB ILKN2 mode, P1 must be used */
        if(1 == digi_handle->var.sifd_ilkn_2_cfg.ilkn.cpb_intf_en)
        {
            *egress_mux_input_port = 1;
        }
        else
        {
            PMC_RETURN(DIGI_ERR_INVALID_ARG);
        }
        break;
    case UTIL_GLOBAL_CPB_PORT_CBRC:
        if(DIGI_CBRC_IS_LINE_INTF(digi_handle)){
            /* CBRC from line serdes must use P2*/
            *egress_mux_input_port = 2;
        } else if(DIGI_CBRC_IS_SYS_INTF(digi_handle)){
            /* CBRC from system serdes may use P0 or P1, try to assign P1 first,
               return error as none available */
            if(0 == digi_handle->var.sifd_ilkn_2_cfg.ilkn.cpb_intf_en){
                *egress_mux_input_port = 1;
                *num_pop_ports = 1;
            } else if(0 == digi_handle->var.sifd_ilkn_1_cfg.ilkn.cpb_intf_en) {
                *egress_mux_input_port = 0;
                *num_pop_ports = 1;
            } else {
                PMC_RETURN(DIGI_ERR_INVALID_ARG);
            }
        } else {
            PMC_RETURN(DIGI_ERR_INVALID_ARG);
        }
        break;
    case UTIL_GLOBAL_CPB_PORT_MAPOTN:
        /* MAPOTN must use P3 */
        *egress_mux_input_port = 3;
        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
        /* ENET_LINE may target P2/P3 P2 if signal bound for Serdes, P3 if signal bound for ODUKSW */
        if(data_dest == 1) {
            if(digi_handle->var.etrans_dcpb_use_model == FALSE)
            {
                *egress_mux_input_port = 3;            
            } else {
                *egress_mux_input_port = 2;            
            }
            *num_pop_ports = 1;
        } else {
            *egress_mux_input_port = 2;
            *num_pop_ports = 1;
        }
        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
        /* ENET_SYS system serdes may use P0 or P1, try to assign P1 first,
           return error as none available */
        if(0 == digi_handle->var.sifd_ilkn_2_cfg.ilkn.cpb_intf_en){
            *egress_mux_input_port = 1;
            *num_pop_ports = 1;
        } else if(0 == digi_handle->var.sifd_ilkn_1_cfg.ilkn.cpb_intf_en){
            *egress_mux_input_port = 0;
            *num_pop_ports = 1;
        } else {
            PMC_RETURN(DIGI_ERR_INVALID_ARG);
        }
        break;
    default:
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }
    PMC_RETURN(PMC_SUCCESS);
} /* digi_cpb_pop_port_get */

/*******************************************************************************
* digi_cpb_input_port_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function initializes an input port of the CPB instance in the DIGI
*   instance.  This function will perform CPB instantiation specific
*   configuration of the respective port.
*
*
* INPUTS:
*   *digi_handle          - pointer to DIGI handle instance.
*   cpb_emul_type         - for emulation only:
*                           0 : ingress CPB
*                           1 : egress CPB
*   input_port            - Ingress Mux Input Port, identifies the subsystem
*                           associated port to be enabled
*   cpb_xfer_mode         - Enum, defining the output interface type.  Only
*                           valid for SIFD ports.  Otherwise transfer modes
*                           internally set.
*                           Only valid DCPB/OCPB instantiations for input_port
*                           0 and 1.
*   hdr_removal_size      - header size for header removal config
*                           supported values : 0-6 bytes
*                           set to 0 for the port not supporting header removal
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_input_port_init(digi_handle_t *digi_handle,
                                          UINT32 cpb_emul_type,
                                          util_global_cpb_port_t input_port,
                                          cpb_xfer_mode_t cpb_xfer_mode,
                                          UINT32 hdr_removal_size)
{
    PMC_ENTRY();
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_ERROR result = cpb_ingress_mux_input_init(digi_handle->dcpb_handle,input_port,cpb_xfer_mode,hdr_removal_size);

    PMC_RETURN(result);
} /* digi_cpb_input_port_init */

/*******************************************************************************
* digi_cpb_output_port_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function initializes an output port of the CPB instance in the DIGI
*   instance.  This function will perform CPB instantiation specific
*   configuration of the respective port.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   cpb_emul_type         - for emulation only:
*                           0 : ingress CPB
*                           1 : egress CPB
*   output_port           - Output port
*   cpb_xfer_mode         - Enum, defining the output interface type.  Only
*                           valid for SIFD ports.  Otherwise transfer modes
*                           internally set.
*                           Only valid DCPB/OCPB instantiations for input_port
*                           0 and 1.
*   mode                  - Enum, State of Egress Mux Output Port
*                           0 : Disabled
*                           1 : Enabled (non-SIFD)
*                           2 : Enabled (SIFD)
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_cpb_output_port_init(digi_handle_t *digi_handle,
                                            UINT32 cpb_emul_type,
                                            util_global_cpb_port_t output_port,
                                            UINT32 cpb_xfer_mode,
                                            cpb_dcs_instance_mode_t mode)
{
    PMC_ERROR result;
    UINT32 enable;
    PMC_ENTRY();
    
    enable = (mode == CPB_DCS_DISABLED ? 0:1);
        
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    result = cpb_egress_mux_output_init( digi_handle->dcpb_handle,output_port,(cpb_xfer_mode_t)cpb_xfer_mode,enable);
    if(result) PMC_RETURN(result);
    PMC_RETURN(PMC_SUCCESS);
} /* digi_cpb_output_port_init */

/*******************************************************************************
* digi_handle_init_children
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to tidy the initialization required for digi_handle_init.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*  PMC_SUCCESS - Initialization was successful
*  PMC_ERROR   - Otherwise
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_handle_init_children(digi_handle_t *digi_handle)
{
    UINT32 i;
    PMC_ERROR result = PMC_SUCCESS;

    cpb_schd_populate_t schdpopulate_mode_mcpb[4] = {CPB_SCHD_POPULATE_LOCAL,
                                                     CPB_SCHD_POPULATE_LOCAL,
                                                     CPB_SCHD_POPULATE_LOCAL,
                                                     CPB_SCHD_POPULATE_LOCAL};
    cpb_schd_populate_t schdpopulate_mode_dcpb[4] = {CPB_SCHD_POPULATE_DB,
                                                     CPB_SCHD_POPULATE_DB,
                                                     CPB_SCHD_POPULATE_DB,
                                                     CPB_SCHD_POPULATE_DB};
    cbrc_handle_init_cfg_t cbrc_handle_init_cfg;
    cbrc_handle_init_cfg.schd_populate_mode[0] = CBRC_SCHD_POPULATE_DB; /* CBRC's scs3 set to DB mode */
    cbrc_handle_init_cfg.schd_populate_mode[1] = CBRC_SCHD_POPULATE_DB; /* CBRC's mpmo set to DB mode */

    PMC_ENTRY();

    result = hostmsg_handle_init((pmc_handle_t*)digi_handle);

    if (PMC_SUCCESS != result)
    {
        PMC_RETURN(result);
    }

    cpb_handle_init(digi_handle->dcpb_handle, CPB_INSTANCE_DCPB, schdpopulate_mode_dcpb, (pmc_block_energy_state_enum)1, NULL, 0);
    cpb_handle_init(digi_handle->mcpb_handle, CPB_INSTANCE_MCPB, schdpopulate_mode_mcpb, (pmc_block_energy_state_enum)1, NULL, 0);
    sifd_handle_init(digi_handle->sifd_handle);
    lifd_handle_init(digi_handle->lifd_handle);
    cbrc_handle_init(digi_handle->cbrc_handle, &cbrc_handle_init_cfg);
    /*for lineotn_handle, call handle init with lineotn_mode == TRUE */
    lineotn_handle_init(digi_handle->lineotn_handle, TRUE);
    /*for sysotn_handle, call handle init with lineotn_mode == FALSE */
    lineotn_handle_init(digi_handle->sysotn_handle, FALSE);
    enet_handle_init(digi_handle->enet_sys_handle, ENET_SYS, ENET_SCHD_POPULATE_DB);
    enet_handle_init(digi_handle->enet_line_handle, ENET_LINE, ENET_SCHD_POPULATE_DB);
    mapotn_handle_init(digi_handle->mapotn_handle, MAPOTN_DB_MODE_EXTERNAL);
    coreotn_handle_init(digi_handle->coreotn_handle);
    s16_handle_init(digi_handle->s16_sys_handle);
    s16_handle_init(digi_handle->s16_line_handle);
    
    for (i = 0; i <  DIGI_SERDES_MAX_T8_2X; i++) 
    {
        t8_handle_init(digi_handle->bp_lr_t8_handle[i]); 
    }
    
    c8_handle_init(digi_handle->bp_sr_c8_handle); 
    
    for (i = 0; i <  DIGI_GE_SERDES_D8_2X_MAX; i++) 
    {            
        d8_tx_2x_handle_init(digi_handle->ge_intf_handle->d8_tx_2x_handle[i]); 
        d8_rx_2x_handle_init(digi_handle->ge_intf_handle->d8_rx_2x_handle[i]); 
    } 
    
    for (i = 0; i < DIGI_SERDES_MAX_SFI51_D8_TXRX_18X; i++) 
    { 
        sfi51_d8_tx_18x_handle_init(digi_handle->sfi51_d8_tx_18x_handle[i]); 
        sfi51_d8_rx_18x_handle_init(digi_handle->sfi51_d8_rx_18x_handle[i]); 
    } 


    mgmt_fege_handle_init(digi_handle->mgmt_fege_handle);

    PMC_RETURN(result);
    
} /* digi_handle_init_children */

/*******************************************************************************
* digi_handle_init_alloc
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to tidy the initialization required for digi_handle_init.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_handle_init_alloc(digi_handle_t *digi_handle)

{
    UINT8 i = 0; /* Counter */

    PMC_ENTRY();

    /* Set all cage cfg to FALSE */
    digi_handle->var.cage_cfg.is_line_cfp = FALSE;
    digi_handle->var.cage_cfg.is_line_cage_cfg = FALSE;
    digi_handle->var.cage_cfg.is_sys_cfp = FALSE;
    digi_handle->var.cage_cfg.is_sys_cage_cfg = FALSE;

    digi_handle->var.line_port_bw.is_port_cfp = FALSE;
    digi_handle->var.line_port_bw.total_port_bw_cfgd = DIGI_PORT_BANDWIDTH_NONE;
    digi_handle->var.sys_port_bw.is_port_cfp = FALSE;
    digi_handle->var.sys_port_bw.total_port_bw_cfgd = DIGI_PORT_BANDWIDTH_NONE;

    /* Set ENET Enhanced PMON usage to Zero */
    digi_handle->var.digi_enet_pmon_line_usage = 0;
    digi_handle->var.digi_enet_pmon_sys_usage = 0;
    digi_handle->var.digi_enet_pmon_GSUP43_7_3_sys_usage = DIGI_SERDES_PIN_NOT_USED;
    digi_handle->var.digi_enet_pmon_GSUP43_7_3_sys_clk_type = DIGI_ENET_GSUP43_PMON_CLK_SRC_NONE;

    /* Set all SERDES to unassigned state */
    for (i = 0; i < DIGI_NUM_SFI51_PORTS_MAX; i++) {
        digi_handle->var.port_ctxt.sfi51_port_ctxt[i].port_uid
            = DIGI_SERDES_UNASSIGNED;
    }

    for (i = 0; i < DIGI_NUM_LINE_PORTS_MAX; i++) {
        digi_handle->var.port_ctxt.line_port_ctxt[i].port_uid
            = DIGI_SERDES_UNASSIGNED;
    }

    for (i = 0; i < DIGI_NUM_SYS_PORTS_MAX; i++) {
        digi_handle->var.port_ctxt.sys_port_ctxt[i].port_uid = DIGI_SERDES_UNASSIGNED;
    }

    for (i = 0; i < DIGI_SERDES_XFI_LANES_MAX; i++) {
        digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid = DIGI_SERDES_UNASSIGNED;
        digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].cage_id = DIGI_SERDES_PIN_NOT_USED;
        digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].los_pin = DIGI_SERDES_PIN_NOT_USED;
        digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].post_mux_dsi_lane = DIGI_SERDES_PIN_NOT_USED;
    }

    for (i = 0; i < DIGI_NUM_SFI51_PORTS_MAX; i++) {
        digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[i].port_uid = DIGI_SERDES_UNASSIGNED;  
    
    }

    for (i = 0; i < DIGI_SERDES_SYS_LANES_MAX; i++) {
        digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid = DIGI_SERDES_UNASSIGNED;
        digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].cage_id = DIGI_SERDES_PIN_NOT_USED;
        digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].los_pin = DIGI_SERDES_PIN_NOT_USED;
        digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].post_mux_dsi_lane = DIGI_SERDES_PIN_NOT_USED;
    }

    for (i = 0; i < DIGI_SERDES_DSI_LANES_MAX; i++) {

        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].lane_index = i;
        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].cage_uid = DIGI_SERDES_PIN_NOT_USED;
        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].port_uid = DIGI_SERDES_UNASSIGNED;
        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].prov_state = DIGI_SERDES_PROV_STATE_NO_SERDES;
        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].lane_index = i;
        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].cage_uid = DIGI_SERDES_PIN_NOT_USED;
        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].port_uid = DIGI_SERDES_UNASSIGNED;
        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].prov_state = DIGI_SERDES_PROV_STATE_NO_SERDES;
    }


    for (i = 0; i < DIGI_SIFD_ILKN_ARB_DPI_CHANS_MAX; i++) {
        digi_handle->var.tx_ilkn_1_bcw_dpi_map[i] = DIGI_SIFD_ILKN_NULL_CAL_ENTRY;
        digi_handle->var.rx_ilkn_1_bcw_dpi_map[i] = DIGI_SIFD_ILKN_NULL_CAL_ENTRY;
        digi_handle->var.tx_ilkn_2_bcw_dpi_map[i] = DIGI_SIFD_ILKN_NULL_CAL_ENTRY;
        digi_handle->var.rx_ilkn_2_bcw_dpi_map[i] = DIGI_SIFD_ILKN_NULL_CAL_ENTRY;
    }

    /* initialize PGMRCLK context */
    PMC_MEMSET((void *)&digi_handle->var.pgmrclk_ctxt, 0x0, sizeof(digi_pgmrclk_ctxt_t));


    /* Interlaken instance initialization */
    digi_handle->handle_pool.ilkn_link[DIGI_SIFD_ILKN1].ilkn_inst = DIGI_SIFD_ILKN1;
    digi_handle->handle_pool.ilkn_link[DIGI_SIFD_ILKN2].ilkn_inst = DIGI_SIFD_ILKN2;

    for (i = 0; i < DIGI_SIFD_ILKN_ARB_DPI_CHANS_MAX; i++) {

        /* ILKN 1 handles */
        digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
        digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;
        digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
        digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_NOT_USED;

        digi_handle->handle_pool.ilkn_1_chnl[i].sifd_path = DIGI_SIFD_PATH_ILKN_1;

        /* ILKN 2 handles */
        digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
        digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;
        digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
        digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_NOT_USED;

        digi_handle->handle_pool.ilkn_2_chnl[i].sifd_path = DIGI_SIFD_PATH_ILKN_2;

        if (i < DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX) {

            /* The CPB Channels run from 0 -> (DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX - 1) */
            digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.cpb_data.channel = i;
            digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.oduk_data.channel = DIGI_SIFD_ILKN_ODUK_DPI_CHNLS_MAX;

            digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.cpb_data.channel = i;
            digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.oduk_data.channel = DIGI_SIFD_ILKN_ODUK_DPI_CHNLS_MAX;

        } else {

            /* The ODUK Channels run from 0 -> (DIGI_SIFD_ILKN_ODUK_DPI_CHNLS_MAX - 1) */
            digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.cpb_data.channel = DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX;
            digi_handle->handle_pool.ilkn_1_chnl[i].switch_data.oduk_data.channel = (i - DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX);

            digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.cpb_data.channel = DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX;
            digi_handle->handle_pool.ilkn_2_chnl[i].switch_data.oduk_data.channel = (i - DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX);

        }
    }

    for (i = 0; i < DIGI_ENET_LINE_CHNL_MAX; i++) {

        digi_handle->handle_pool.enet_line_chnl[i].switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
        digi_handle->handle_pool.enet_line_chnl[i].switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;
        digi_handle->handle_pool.enet_line_chnl[i].switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
        digi_handle->handle_pool.enet_line_chnl[i].switch_data.cpb_data.channel = i;
        digi_handle->handle_pool.enet_line_chnl[i].switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_NOT_USED;
    }

    for (i = 0; i < DIGI_ENET_SYS_CHNL_MAX; i++) {

        digi_handle->handle_pool.enet_sys_chnl[i].switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
        digi_handle->handle_pool.enet_sys_chnl[i].switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;
        digi_handle->handle_pool.enet_sys_chnl[i].switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
        digi_handle->handle_pool.enet_sys_chnl[i].switch_data.cpb_data.channel = i;
        digi_handle->handle_pool.enet_sys_chnl[i].switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_NOT_USED;
    }

    for (i = 0; i < DIGI_MAPOTN_CHNL_MAX; i++) {

        digi_handle->handle_pool.mapper_chnl[i].switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
        digi_handle->handle_pool.mapper_chnl[i].switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
        digi_handle->handle_pool.mapper_chnl[i].switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_NOT_USED;
    }

    for (i = 0; i < DIGI_OTN_SERVER_CHNL_MAX; i++)
    {
        PMC_CTXT_REGISTER_PTR(&digi_handle->handle_pool.otn_server_chnl[i].odu_struct_ptr, digi_handle);
    }
    PMC_CTXT_REGISTER_PTR(&digi_handle->handle_pool.sysotn_server_chnl.odu_struct_ptr, digi_handle);
    for (i = 0; i < DIGI_OTN_SERVER_HO_CHNL_MAX; i++) {

        digi_handle->handle_pool.ho_odu_struct[i].switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
        digi_handle->handle_pool.ho_odu_struct[i].switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;
        digi_handle->handle_pool.ho_odu_struct[i].mem_ptr = &(digi_handle->handle_pool.ho_odu_chnl[i]);
        PMC_CTXT_REGISTER_PTR(&digi_handle->handle_pool.ho_odu_struct[i].mem_ptr, digi_handle);
    }

    for (i = 0; i < DIGI_OTN_SERVER_MO_CHNL_MAX; i++) {

        digi_handle->handle_pool.mo_odu_struct[i].switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
        digi_handle->handle_pool.mo_odu_struct[i].switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;
        digi_handle->handle_pool.mo_odu_struct[i].mem_ptr = &(digi_handle->handle_pool.mo_odu_chnl[i]);
        PMC_CTXT_REGISTER_PTR(&digi_handle->handle_pool.mo_odu_struct[i].mem_ptr, digi_handle);
    }

    for (i = 0; i < DIGI_OTN_SERVER_LO_CHNL_MAX; i++) {

        digi_handle->handle_pool.lo_odu_struct[i].switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
        digi_handle->handle_pool.lo_odu_struct[i].switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;
        digi_handle->handle_pool.lo_odu_struct[i].mem_ptr = &(digi_handle->handle_pool.lo_odu_chnl[i]);
        PMC_CTXT_REGISTER_PTR(&digi_handle->handle_pool.lo_odu_struct[i].mem_ptr, digi_handle);
    }



    for (i = 0; i < DIGI_OTN_SERVER_LO_CHNL_MAX; i++) {

        digi_handle->handle_pool.s3b_odu_struct[i].switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
        digi_handle->handle_pool.s3b_odu_struct[i].switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;
        digi_handle->handle_pool.s3b_odu_struct[i].mem_ptr = &(digi_handle->handle_pool.s3b_odu_chnl[i]);
        PMC_CTXT_REGISTER_PTR(&digi_handle->handle_pool.s3b_odu_struct[i].mem_ptr, digi_handle);
    } 

    /* mem_ptr can write to dummy locations (not required for fast APS reconfig) */
    for (i = 0; i < DIGI_OTN_SERVER_LO_CHNL_MAX; i++) {

        digi_handle->handle_pool.s4_odu_struct[i].switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
        digi_handle->handle_pool.s4_odu_struct[i].switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;
        digi_handle->handle_pool.s4_odu_struct[i].mem_ptr = &(digi_handle->handle_pool.dummy_odu_chnl_stg4);
        PMC_CTXT_REGISTER_PTR(&digi_handle->handle_pool.s4_odu_struct[i].mem_ptr, digi_handle);
        digi_handle->handle_pool.s4_odu_struct[i].mem_ptr->chnl_id = i;
    }


    for (i = 0; i < DIGI_OTN_SERVER_HO_CHNL_MAX; i++) {

        digi_handle->handle_pool.sysotn_line_struct[i].switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
        digi_handle->handle_pool.sysotn_line_struct[i].switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;
        digi_handle->handle_pool.sysotn_line_struct[i].mem_ptr = &(digi_handle->handle_pool.dummy_odu_chnl_stg2_sysotn);
        PMC_CTXT_REGISTER_PTR(&digi_handle->handle_pool.sysotn_line_struct[i].mem_ptr, digi_handle);
        digi_handle->handle_pool.sysotn_line_struct[i].mem_ptr->chnl_id = i;
    }

    PMC_RETURN();
} /* digi_handle_init_alloc */



/*******************************************************************************
* digi_cpb_mpmo_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function tests the output port to determine if MPMO configuration is
*   required.  If required it will provision the MPMO to ensure that it's 
*   configuration settings match those of the MPMA data source it is receiving
*   OPSA packets from.
*
*   Should the output port not require this configuration, this function makes
*   no device modification and returns successfully.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   input_port       - CPB input port 
*   input_channel    - CPB input port channel
*   output_port      - CPB output port
*   output_channel   - CPB output port channel
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_cpb_mpmo_prov(digi_handle_t *digi_handle, 
                                     util_global_cpb_port_t input_port, 
                                     UINT32 input_channel, 
                                     util_global_cpb_port_t output_port, 
                                     UINT32 output_channel)
{
    PMC_ERROR result = PMC_SUCCESS;
    BOOL8 mpmo_cfg_req = FALSE;
    UINT32 pkt_size_ptr = 0;
    UINT32 pkt_per_int_ptr = 0;
    UINT32 pkt_per_n_ptr = 0;
    UINT32 pkt_per_d_ptr = 0;
    DOUBLE epsilon_ptr = 0;
    BOOL8  is_sonet = FALSE;

    PMC_ENTRY();

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    switch(output_port)
    {
    case UTIL_GLOBAL_CPB_PORT_ILKN1:
    case UTIL_GLOBAL_CPB_PORT_ILKN2:
        mpmo_cfg_req = FALSE;
        break;
    case UTIL_GLOBAL_CPB_PORT_CBRC:
        result = cbrc_mpmo_cfg_get(digi_handle->cbrc_handle, output_channel, &mpmo_cfg_req);
        break;
    case UTIL_GLOBAL_CPB_PORT_MAPOTN:
        result = mapotn_mapper_mpmo_cfg_get(digi_handle->mapotn_handle, output_channel, &mpmo_cfg_req);
        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
        result = enet_mpmo_cfg_get(digi_handle->enet_line_handle, output_channel, &mpmo_cfg_req);
        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
        result = enet_mpmo_cfg_get(digi_handle->enet_sys_handle, output_channel, &mpmo_cfg_req);
        break;
    case UTIL_GLOBAL_CPB_PORT_NOT_USED:
    case LAST_UTIL_GLOBAL_CPB_PORT:
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        break;
    }

    if(result==PMC_SUCCESS && mpmo_cfg_req == TRUE){
        switch(input_port)
        {
        case UTIL_GLOBAL_CPB_PORT_CBRC:
            PMC_LOG_TRACE("get MPMA data from CBRC\n");
            result = cbrc_mpma_data_get(digi_handle->cbrc_handle,input_channel,&pkt_size_ptr,&pkt_per_int_ptr,&pkt_per_n_ptr,&pkt_per_d_ptr,&epsilon_ptr);
            is_sonet = cbrc_port_is_sonet_get(digi_handle->cbrc_handle,input_channel);
            break;
        case UTIL_GLOBAL_CPB_PORT_MAPOTN:
            PMC_LOG_TRACE("get MPMA data from MAPOTN\n");
            result = mapotn_mpma_data_get(digi_handle->mapotn_handle,input_channel,&pkt_size_ptr,&pkt_per_int_ptr,&pkt_per_n_ptr,&pkt_per_d_ptr,&epsilon_ptr);
            break;
        case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
            PMC_LOG_TRACE("get MPMA data from ENET_LINE\n");
            result = enet_mpma_data_get(digi_handle->enet_line_handle,input_channel,&pkt_size_ptr,&pkt_per_int_ptr,&pkt_per_n_ptr,&pkt_per_d_ptr,&epsilon_ptr);
            break;
        case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
            PMC_LOG_TRACE("get MPMA data from ENET_SYS\n");
            result = enet_mpma_data_get(digi_handle->enet_sys_handle,input_channel,&pkt_size_ptr,&pkt_per_int_ptr,&pkt_per_n_ptr,&pkt_per_d_ptr,&epsilon_ptr);
            break;
        case UTIL_GLOBAL_CPB_PORT_ILKN1:
        case UTIL_GLOBAL_CPB_PORT_ILKN2:
        case UTIL_GLOBAL_CPB_PORT_NOT_USED:
        case LAST_UTIL_GLOBAL_CPB_PORT:
        default:
            PMC_LOG_TRACE("Generate an assertion as invalid mapping being requested.\n");
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
            break;
        }
    }

    PMC_LOG_TRACE("pkt_size_ptr:%d,pkt_per_int_ptr:%d,pkt_per_n_ptr:%d,pkt_per_d_ptr:%d\n", pkt_size_ptr,pkt_per_int_ptr,pkt_per_n_ptr,pkt_per_d_ptr);

    if(result==PMC_SUCCESS && mpmo_cfg_req == TRUE){
        switch(output_port)
        {
        case UTIL_GLOBAL_CPB_PORT_CBRC:
            result = cbrc_mpmo_prov(digi_handle->cbrc_handle,output_channel,pkt_size_ptr,pkt_per_int_ptr,pkt_per_n_ptr,pkt_per_d_ptr);
            break;
        case UTIL_GLOBAL_CPB_PORT_MAPOTN:
            result = mapotn_mapper_mpmo_prov(digi_handle->mapotn_handle,output_channel,pkt_size_ptr,pkt_per_int_ptr,pkt_per_n_ptr,pkt_per_d_ptr, is_sonet);
            break;
        case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
            result = enet_mpmo_prov(digi_handle->enet_line_handle,output_channel,pkt_size_ptr,pkt_per_int_ptr,pkt_per_n_ptr,pkt_per_d_ptr);
            break;
        case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
            result = enet_mpmo_prov(digi_handle->enet_sys_handle,output_channel,pkt_size_ptr,pkt_per_int_ptr,pkt_per_n_ptr,pkt_per_d_ptr);
            break;
        case UTIL_GLOBAL_CPB_PORT_ILKN1:
        case UTIL_GLOBAL_CPB_PORT_ILKN2:
        case UTIL_GLOBAL_CPB_PORT_NOT_USED:
        case LAST_UTIL_GLOBAL_CPB_PORT:
        default:
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
            break;
        }
    }

    PMC_RETURN(result);
} /* digi_cpb_mpmo_prov */


/*******************************************************************************
* digi_cpb_mpmo_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions an MPMO channel associated with a DCBP output
*   port.
*
*   Should the output port not require this configuration, this function makes
*   no device modification and returns successfully.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   output_port      - CPB output port
*   output_channel   - CPB output port channel
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_cpb_mpmo_deprov(digi_handle_t *digi_handle,  
                                       util_global_cpb_port_t output_port, 
                                       UINT32 output_channel)
{
    PMC_ERROR result = PMC_SUCCESS;
    BOOL8 mpmo_cfg_req = FALSE;

    PMC_ENTRY();

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    switch(output_port)
    {
    case UTIL_GLOBAL_CPB_PORT_ILKN1:
    case UTIL_GLOBAL_CPB_PORT_ILKN2:
        mpmo_cfg_req = FALSE;
        break;
    case UTIL_GLOBAL_CPB_PORT_CBRC:
        result = cbrc_mpmo_cfg_get(digi_handle->cbrc_handle, output_channel, &mpmo_cfg_req);
        break;
    case UTIL_GLOBAL_CPB_PORT_MAPOTN:
        result = mapotn_mapper_mpmo_cfg_get(digi_handle->mapotn_handle, output_channel, &mpmo_cfg_req);
        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
        result = enet_mpmo_cfg_get(digi_handle->enet_line_handle, output_channel, &mpmo_cfg_req);
        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
        result = enet_mpmo_cfg_get(digi_handle->enet_sys_handle, output_channel, &mpmo_cfg_req);
        break;
    case UTIL_GLOBAL_CPB_PORT_NOT_USED:
    case LAST_UTIL_GLOBAL_CPB_PORT:
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        break;
    }

    if(result==PMC_SUCCESS && mpmo_cfg_req == TRUE){
        switch(output_port)
        {
        case UTIL_GLOBAL_CPB_PORT_CBRC:
            result = cbrc_mpmo_deprov(digi_handle->cbrc_handle, output_channel);
            break;
        case UTIL_GLOBAL_CPB_PORT_MAPOTN:
            result = mapotn_mapper_mpmo_deprov(digi_handle->mapotn_handle,output_channel);
            break;
        case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
            result = enet_mpmo_deprov(digi_handle->enet_line_handle,output_channel);
            break;
        case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
            result = enet_mpmo_deprov(digi_handle->enet_sys_handle,output_channel);
            break;
        case UTIL_GLOBAL_CPB_PORT_ILKN1:
        case UTIL_GLOBAL_CPB_PORT_ILKN2:
        case UTIL_GLOBAL_CPB_PORT_NOT_USED:
        case LAST_UTIL_GLOBAL_CPB_PORT:
        default:
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
            break;
        }
    }

    PMC_RETURN(result);
} /* digi_cpb_mpmo_deprov */


/*******************************************************************************
* digi_post_mld_prov_state_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to set the provisioned state of the
*   digi_post_mld_dsi_ctxt_t matching the specified port_uid
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   port_uid           - the unique identifier of the SERDES port.
*   prov_state         - the state to set this port to on all found MLD dsi
*                        lanes
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_post_mld_prov_state_set(digi_handle_t *digi_handle,
                                              UINT32 port_uid,
                                              digi_serdes_prov_state_t prov_state)

{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    BOOL xfi_set = FALSE;
    BOOL sys_set = FALSE;
    UINT8 i = 0; /* counter */

    PMC_ENTRY();

    for (i = 0; i < DIGI_SERDES_DSI_LANES_MAX; i ++) {

        /* Check the line side first */
        if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].port_uid == port_uid) {

            digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].prov_state = prov_state;
            xfi_set = TRUE;
        }
        /* Check the system side second */
        if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].port_uid == port_uid) {

            digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].prov_state = prov_state;
            sys_set = TRUE;
        }
    }

    if (xfi_set == TRUE) {

        rc = PMC_SUCCESS;

    } else if (sys_set == TRUE) {

        rc = PMC_SUCCESS;

    } else if ((xfi_set == TRUE) && (sys_set == TRUE)) {

        /* Bad state */
        /* Cannot have one port defined over both interfaces */
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    PMC_RETURN(rc);
} /* digi_post_mld_prov_state_set */


#ifdef PMC_DEPRECATED

/* LCOV_EXCL_START */

/*******************************************************************************
* digi_by_mld_index_post_mld_prov_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   DEPRECATED-Function has been marked as deprecated starting in the 3.05 release
*
*   This is a helper function to get the provisioned state of the
*   digi_post_mld_dsi_ctxt_t given the post_mld_index
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   post_mld_index     - the post mld index.
*
* OUTPUTS:
*   *prov_state        - the provisioned state to of this port. See
*                        digi_serdes_prov_state_t enum for more information.
*
* RETURNS:
*   DIGI_ERR_POST_MLD_DSI_LANE_NOT_FOUND on failure, PMC_SUCCESS otherwise.
*
* NOTES:
*   *prov_state is only valid upon return of PMC_SUCCESS.
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_by_mld_index_post_mld_prov_state_get(digi_handle_t *digi_handle,
                                                           UINT8 post_mld_index,
                                                           digi_serdes_prov_state_t* prov_state)

{
    PMC_ERROR rc = DIGI_ERR_POST_MLD_DSI_LANE_NOT_FOUND;
    BOOL xfi_set = FALSE;
    BOOL sys_set = FALSE;

    PMC_ENTRY();

    /* Check the line side first */
    if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[post_mld_index].port_uid != DIGI_SERDES_UNASSIGNED) {

        *prov_state = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[post_mld_index].prov_state;
        xfi_set = TRUE;
    } 

    /* Check the system side second */
    if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[post_mld_index].port_uid != DIGI_SERDES_UNASSIGNED) {

        *prov_state = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[post_mld_index].prov_state;
        sys_set = TRUE;
    }

    if (xfi_set == TRUE) {

        rc = PMC_SUCCESS;

    } else if (sys_set == TRUE) {

        rc = PMC_SUCCESS;

    } else if ((xfi_set == TRUE) && (sys_set == TRUE)) {

        /* Bad state */
        /* Cannot have one port defined over both interfaces */
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    PMC_RETURN(rc);
} /* digi_by_mld_index_post_mld_prov_state_get */

/* LCOV_EXCL_STOP */

#endif /* PMC_DEPRECATED */


/*******************************************************************************
* digi_by_port_uid_num_line_xfi_lanes_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to get the number of xfi line side lanes matching 
*   the specified port_uid.
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   port_uid           - the unique identifier of the SERDES port.
*
* OUTPUTS:
*   None
*
* RETURNS:
*   UINT32 - number of lanes matching the specified port_uid
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32 digi_by_port_uid_num_line_xfi_lanes_get(digi_handle_t *digi_handle,
                                                       UINT32 port_uid)
{
    UINT32 i;
    UINT32 result = 0;
    
    PMC_ENTRY();
    
    if (DIGI_SERDES_UNASSIGNED != port_uid )
    {
        
        for ( i = 0; i < DIGI_SERDES_XFI_LANES_MAX; i++)
        {
            if(digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid == port_uid)
            {
                result += 1;
            }
        }
    }
    PMC_RETURN(result);
} /* digi_by_port_uid_num_line_xfi_lanes_get */

/*******************************************************************************
* digi_by_port_uid_num_sfi51_lanes_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to get the number of sfi51 lanes matching 
*   the specified port_uid.
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   port_uid           - the unique identifier of the SERDES port.
*
* OUTPUTS:
*   None
*
* RETURNS:
*   UINT32 - number of lanes matching the specified port_uid
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32 digi_by_port_uid_num_sfi51_lanes_get(digi_handle_t *digi_handle,
                                                    UINT32 port_uid)
{
    UINT32 i;
    UINT32 result = 0;
    
    PMC_ENTRY();
    
    if (DIGI_SERDES_UNASSIGNED != port_uid )
    {
        for (i = 0; i < DIGI_NUM_SFI51_PORTS_MAX; i++) 
        {
            if(digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[i].port_uid == port_uid)
            {
                result += 1;
            }
        }        
    }
    PMC_RETURN(result);
} /* digi_by_port_uid_num_sfi51_lanes_get */

/*******************************************************************************
* digi_by_port_uid_num_sys_xfi_lanes_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to get the number of xfi sys side lanes matching 
*   the specified port_uid.
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   port_uid           - the unique identifier of the SERDES port.
*
* OUTPUTS:
*   None
*
* RETURNS:
*   UINT32 - number of lanes matching the specified port_uid
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32 digi_by_port_uid_num_sys_xfi_lanes_get(digi_handle_t *digi_handle,
                                                      UINT32 port_uid)
{
    UINT32 i;
    UINT32 result = 0;
    
    PMC_ENTRY();
    
    if (DIGI_SERDES_UNASSIGNED != port_uid )
    {
        
        for ( i = 0; i < DIGI_SERDES_SYS_LANES_MAX; i++)
        {
            if(digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid == port_uid)
            {
                result += 1;
            }
        }
    }
    PMC_RETURN(result);
} /* digi_by_port_uid_num_sys_xfi_lanes_get */

/*******************************************************************************
* digi_by_port_uid_num_port_get 
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to get the number of port matching the specified 
*   port_uid
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   port_uid           - the unique identifier of the SERDES port.
*
* OUTPUTS:
*   None
*
* RETURNS:
*   UINT32 - number of port matching the specified port_uid
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32 digi_by_port_uid_num_port_get(digi_handle_t *digi_handle,
                                             UINT32 port_uid)
{
    UINT32 result = 0;
    
    PMC_ENTRY();
       
    result = digi_by_port_uid_num_line_xfi_lanes_get(digi_handle, port_uid);
        
    if (result == 0)
    {
        result = digi_by_port_uid_num_sfi51_lanes_get(digi_handle, port_uid);
    }

    if (result == 0)
    {        
        result = digi_by_port_uid_num_sys_xfi_lanes_get(digi_handle, port_uid);
    }

    PMC_RETURN(result);
} /* digi_by_port_uid_num_port_get */

/*******************************************************************************
* digi_by_port_uid_post_mld_prov_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to get the provisioned state of the
*   digi_post_mld_dsi_ctxt_t matching the specified port_uid
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   port_uid           - the unique identifier of the SERDES port.
*
* OUTPUTS:
*   *prov_state        - the provisioned state to of this port. See
*                        digi_serdes_prov_state_t enum for more information.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*   *prov_state is only valid upon return of PMC_SUCCESS.
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_by_port_uid_post_mld_prov_state_get(digi_handle_t *digi_handle,
                                                          UINT32 port_uid,
                                                          digi_serdes_prov_state_t* prov_state)

{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    BOOL xfi_set = FALSE;
    BOOL sys_set = FALSE;
    UINT8 i = 0; /* counter */

    PMC_ENTRY();

    for (i = 0; i < DIGI_SERDES_DSI_LANES_MAX; i ++) {

        /* Check the line side first */
        if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].port_uid == port_uid) {

            *prov_state = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].prov_state;
            xfi_set = TRUE;
        } 

        /* Check the system side second */
        if (digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].port_uid == port_uid) {

            *prov_state = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].prov_state;
            sys_set = TRUE;
        }
    }

    if (xfi_set == TRUE) {

        rc = PMC_SUCCESS;

    } else if (sys_set == TRUE) {

        rc = PMC_SUCCESS;

    } else if ((xfi_set == TRUE) && (sys_set == TRUE)) {

        /* Bad state */
        /* Cannot have one port defined over both interfaces */
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    PMC_RETURN(rc);
} /* digi_by_port_uid_post_mld_prov_state_get */


/*******************************************************************************
* digi_mapotn_prov_new_mapper_state_get 
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to get the new mapper state given the current
*   state and what the mapper is trying to accomplish with some other
*   variables.
*
* INPUTS:
*   in_map_type        - the current map type that the mapper will use to
*                        determine the next state.
*                        See digi_mapper_alloc_t for more information.
*   enet_pmon          - Set to TRUE if ENET PMON path is being used.
*   mapotn_dest        - Set to which SS is the destination.
*                        See mapotn_src_dest_t for more information.
*
* OUTPUTS:
*   out_map_type       - the new map type that the mapper will be set to once
*                        provisioning is successfull. 
*                        See digi_mapper_alloc_t for more information.
*
* RETURNS:
*   DIGI_ERR_MAPPER_ENET_LINE_RESOURCE_IN_USE on failure
*   PMC_SUCCESS otherwise.
*
* NOTES:
*   *out_map_type is only valid upon return of PMC_SUCCESS.
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_mapotn_prov_new_mapper_state_get(digi_mapper_alloc_t in_map_type,
                                                        BOOL enet_pmon,
                                                        mapotn_src_dest_t mapotn_dest,
                                                        digi_mapper_alloc_t *out_map_type)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;

    PMC_ENTRY();

    if ((mapotn_dest == MAPOTN_DEST_ENET) || (mapotn_dest == MAPOTN_DEST_CPB_ENET)) {

        if (in_map_type == DIGI_MAPPER_ALLOC_ENET_LINE) {

            /* We cannot accomodate this request as the needed ENET
               LINE resource is already in use. */
            rc = DIGI_ERR_MAPPER_ENET_LINE_RESOURCE_IN_USE;

        } else if (in_map_type == DIGI_MAPPER_ALLOC_UNUSED) {

            *out_map_type = DIGI_MAPPER_ALLOC_MAPPER_WITH_ENET_LINE;
            rc = PMC_SUCCESS;

        } else {

            /* Assert */
            rc = DIGI_ERR_CODE_ASSERT;
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        }

    } else if (mapotn_dest == MAPOTN_DEST_CPB) {

        if (in_map_type == DIGI_MAPPER_ALLOC_ENET_LINE) {

            *out_map_type = DIGI_MAPPER_ALLOC_MAPPER_AND_ENET_LINE;
            rc = PMC_SUCCESS;

        } else if (in_map_type == DIGI_MAPPER_ALLOC_UNUSED) {

            *out_map_type = DIGI_MAPPER_ALLOC_MAPPER_WITHOUT_ENET_LINE;
            rc = PMC_SUCCESS;

        } else {

            /* Assert */
            rc = DIGI_ERR_CODE_ASSERT;
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        }
    }

    PMC_RETURN(rc);
} /* digi_mapotn_prov_new_mapper_state_get */

/*******************************************************************************
* digi_mapotn_deprov_new_mapper_state_get 
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to get the new mapper state given the current
*   state and what the mapper is trying to accomplish with some other
*   variables.
*
* INPUTS:
*   in_map_type        - the current map type that the mapper will use to
*                        determine the next state.
*                        See digi_mapper_alloc_t for more information.
*   port_type          - Set to util_global_cpb_port_t corresponding to the
*                        SS this is provisioned against. See
*                        util_global_cpb_port_t for more information
*
* OUTPUTS:
*   out_map_type       - the new map type that the mapper will be set to once
*                        provisioning is successfull. 
*                        See digi_mapper_alloc_t for more information.
*
* RETURNS:
*   DIGI_ERR_MAPPER_NOT_MAPPED on failure, PMC_SUCCESS otherwise.
*
* NOTES:
*   *out_map_type is only valid upon return of PMC_SUCCESS.
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_mapotn_deprov_new_mapper_state_get(digi_mapper_alloc_t in_map_type,
                                                          util_global_cpb_port_t port_type,
                                                          digi_mapper_alloc_t *out_map_type)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;

    PMC_ENTRY();

    if (port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE)
    {

        if (in_map_type == DIGI_MAPPER_ALLOC_ENET_LINE) {

            /* We cannot accomodate this request as this resource does not
               appear to have been mapped. */
            rc = DIGI_ERR_MAPPER_NOT_MAPPED;

        } else if (in_map_type == DIGI_MAPPER_ALLOC_MAPPER_WITH_ENET_LINE) {

            *out_map_type = DIGI_MAPPER_ALLOC_UNUSED;
            rc = PMC_SUCCESS;
        } else if (DIGI_MAPPER_ALLOC_UNUSED == in_map_type) {
            *out_map_type = DIGI_MAPPER_ALLOC_UNUSED;
            rc = PMC_SUCCESS;
        } else {

            /* Assert */
            rc = DIGI_ERR_CODE_ASSERT;
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        }

    } else if (port_type == UTIL_GLOBAL_CPB_PORT_MAPOTN) {

        if (in_map_type == DIGI_MAPPER_ALLOC_MAPPER_AND_ENET_LINE) {

            *out_map_type = DIGI_MAPPER_ALLOC_ENET_LINE;
            rc = PMC_SUCCESS;

        } else if (in_map_type == DIGI_MAPPER_ALLOC_MAPPER_WITHOUT_ENET_LINE) {

            *out_map_type = DIGI_MAPPER_ALLOC_UNUSED;
            rc = PMC_SUCCESS;

        } else if (in_map_type == DIGI_MAPPER_ALLOC_ENET_LINE) {

            /* This is the case where we are using the umbillical for PMON */
            *out_map_type = DIGI_MAPPER_ALLOC_UNUSED;
            rc = PMC_SUCCESS;

        } else if (in_map_type == DIGI_MAPPER_ALLOC_MAPPER_WITH_ENET_LINE) {

            /* This is the case where we are using the umbillical for PMON */
            *out_map_type = DIGI_MAPPER_ALLOC_UNUSED;
            rc = PMC_SUCCESS;

        } else if (DIGI_MAPPER_ALLOC_UNUSED == in_map_type) {
            *out_map_type = DIGI_MAPPER_ALLOC_UNUSED;
            rc = PMC_SUCCESS;
        } else {

            /* Assert */
            rc = DIGI_ERR_CODE_ASSERT;
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        }
    } else {

        /* Assert */
        rc = DIGI_ERR_CODE_ASSERT;
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    PMC_RETURN(rc);
} /* digi_mapotn_deprov_new_mapper_state_get */



/*******************************************************************************
* digi_by_mld_index_num_odus_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to get the number of odus on a particular 
*   post mld index.
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   post_mld_index     - the index of the post mld lane
*
* OUTPUTS:
*   *num_odus          - the number of odu zeroes (ODU0) on this post mld lane.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*   *map_type is only valid upon return of PMC_SUCCESS.
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_by_mld_index_num_odus_get(digi_handle_t *digi_handle,
                                                 UINT8 post_mld_index,
                                                 UINT32 *num_odus)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    BOOL xfi_set = FALSE;
    BOOL sys_set = FALSE;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(num_odus != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(post_mld_index < DIGI_SERDES_DSI_LANES_MAX, DIGI_ERR_INVALID_ARG, 0, 0);

    xfi_set = TRUE;
    if ((xfi_set == TRUE) || (sys_set == TRUE)) {

        *num_odus = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[post_mld_index].num_odu0;
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
} /* digi_by_mld_index_num_odus_get */

/*******************************************************************************
* digi_by_mld_index_num_odus_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to set the number of odus on a particular 
*   post mld index.
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   post_mld_index     - the index of the post mld lane
*   num_odus           - the number of odu zeroes (ODU0) on this post mld lane.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*   *map_type is only valid upon return of PMC_SUCCESS.
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_by_mld_index_num_odus_set(digi_handle_t *digi_handle,
                                                 UINT8 post_mld_index,
                                                 UINT32 num_odus)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    BOOL xfi_set = FALSE;
    BOOL sys_set = FALSE;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(num_odus <= DIGI_NUM_ODU0S_PER_LANE_MAX, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(post_mld_index < DIGI_SERDES_DSI_LANES_MAX, DIGI_ERR_INVALID_ARG, 0, 0);

    xfi_set = TRUE;
    
    sys_set = TRUE;


    if ((sys_set == TRUE) || (xfi_set == TRUE)) {

        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[post_mld_index].num_odu0 = num_odus;
        rc = PMC_SUCCESS;

    } else {

        /* Bad state */
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    PMC_RETURN(rc);
} /* digi_by_mld_index_num_odus_set */


/*******************************************************************************
* digi_port_ctxt_from_channel_number_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to get a handle to the port based on 
*   CBRC/LINEOTN channel
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance
*   prov_state         - indicates the SS the port is provisioned against.
*   chnl               - the SS channel.
*
* OUTPUTS:
*   **port_ctxt_pptr   - a pointer to a pointer SERDES port context 
*
* RETURNS:
*   PMC_SUCCESS, specific error otherwise.
*
* NOTES:
*   **port_ctxt_pptr is only valid upon return of PMC_SUCCESS.
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_port_ctxt_from_channel_number_get(digi_handle_t *digi_handle,
                                                        digi_serdes_prov_state_t prov_state,
                                                        UINT32 chnl,
                                                        digi_serdes_port_t **port_ctxt_pptr)
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    BOOL line_set = FALSE;
    BOOL sys_set = FALSE;
    digi_serdes_prov_state_t line_prov_state;
    digi_serdes_prov_state_t sys_prov_state;
    UINT32 port_uid = DIGI_SERDES_PROV_STATE_UNASSIGNED;
    UINT8 i = 0; /* counter */

    PMC_ENTRY();

    PMC_ASSERT(port_ctxt_pptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl<DIGI_SERDES_DSI_LANES_MAX, DIGI_ERR_NULL_HANDLE, 0, 0);

    if (prov_state == DIGI_SERDES_PROV_STATE_LINEOTN) {

        /*
         * LINEOTN case cannot immediately look up the port_uid as it is not 
         * necessarilly 1:1 mapped with the channel and post mld lane.
         * Assert here so the user is aware of this fact. */

        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);

    } else {

        /* CBRC subsystem may use channel 0 to process SFI5.1 on post_mld_dsi_line_ctxt[11:8]
           in this case, post_mld_dsi_line_ctxt[0] would not be able to be provisioned 
           against CBRC subsystem */

        /* Only do this for non LINEOTN applications as LINEOTN is not
         * necessarilly 1:1 mapped with the channel and post mld lane. */

        line_prov_state
            = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[chnl].prov_state;
        sys_prov_state
            = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[chnl].prov_state;

        if(prov_state == DIGI_SERDES_PROV_STATE_CBRC && chnl == 0 && 
           line_prov_state != DIGI_SERDES_PROV_STATE_CBRC && 
           sys_prov_state != DIGI_SERDES_PROV_STATE_CBRC)
        {
            port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[8].port_uid;
            line_set = TRUE;
            /* raise assertion if this third option for port_uid associated with CBRC channel 0 is not met */
            PMC_ASSERT(digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[8].prov_state == DIGI_SERDES_PROV_STATE_CBRC, DIGI_ERR_CODE_ASSERT, 0, 0);
        }
        else if ((line_prov_state == prov_state)  && 
                 (prov_state != DIGI_SERDES_PROV_STATE_ENET_SYS)) 
        {
            /* Check the line side first */
            port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[chnl].port_uid;
            line_set = TRUE;
        
            /* Check the system side second */
        } 
        else if (((prov_state == DIGI_SERDES_PROV_STATE_ENET_LINE)  ||
                  (prov_state == DIGI_SERDES_PROV_STATE_ENET_SYS) ||
                  (prov_state == DIGI_SERDES_PROV_STATE_CBRC)) &&
                 (sys_prov_state == prov_state)) 
        {

            port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[chnl].port_uid;
            sys_set = TRUE;
        }
    }

    if (line_set == TRUE) {

        for (i=0; i < DIGI_NUM_LINE_PORTS_MAX; i++) {

            if (digi_handle->var.port_ctxt.line_port_ctxt[i].port_uid == port_uid) {

                *port_ctxt_pptr = &(digi_handle->var.port_ctxt.line_port_ctxt[i]);

                rc = PMC_SUCCESS;
                break;
            }
        }

        /* SFI51 case */

        if (rc != PMC_SUCCESS) {

            for (i=0; i < DIGI_NUM_SFI51_PORTS_MAX; i++) {

                if (digi_handle->var.port_ctxt.sfi51_port_ctxt[i].port_uid == port_uid) {

                    *port_ctxt_pptr = &(digi_handle->var.port_ctxt.sfi51_port_ctxt[i]);

                    rc = PMC_SUCCESS;
                    break;
                }
            }
        }

    } else if (sys_set == TRUE) {

        for (i=0; i < DIGI_NUM_SYS_PORTS_MAX; i++) {

            if (digi_handle->var.port_ctxt.sys_port_ctxt[i].port_uid == port_uid) {

                *port_ctxt_pptr = &(digi_handle->var.port_ctxt.sys_port_ctxt[i]);

                rc = PMC_SUCCESS;
                break;
            }
        }

    } else if ((line_set == TRUE) && (sys_set == TRUE)) {

        /* Bad state */
        /* Cannot have one port defined over both interfaces */
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    PMC_RETURN(rc);
} /* digi_port_ctxt_from_channel_number_get */

/*******************************************************************************
* digi_sfi51_bus_ctxt_find
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to find the first bus context of type
*   digi_sfi51_bus_ctxt_t matching the specified port_uid
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   port_uid           - the unique identifier of the SERDES port.
*                        To find the first unused one use:
*                        DIGI_SERDES_UNASSIGNED
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   digi_sfi51_bus_ctxt_t - A pointer to the requested matching digi_sfi51_bus_ctxt_t structure,
*   or NULL if there are no more available or the requested one could not be
*   found.
*
* NOTES:
*
*******************************************************************************/
PUBLIC digi_sfi51_bus_ctxt_t* digi_sfi51_bus_ctxt_find(digi_handle_t *digi_handle,
                                                       UINT32 port_uid)
{
    digi_sfi51_bus_ctxt_t* rp = NULL;
    UINT8 i = 0;

    PMC_ENTRY();

    for (i = 0; i < DIGI_NUM_SFI51_PORTS_MAX; i ++) {

        if (digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[i].port_uid == port_uid) {

            rp = &(digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[i]);
            break;
        }
    }

    PMC_RETURN(rp);
} /* digi_sfi51_bus_ctxt_find */

/*******************************************************************************
* digi_num_xfi_pins_in_use
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to find the number of XFI pins in use by the
*   specified port_uid
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   port_uid           - the unique identifier of the SERDES port.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT8 - The number of pins in use by a given port_uid.
*   Zero if no pins are in use by this port_uid
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT8 digi_num_xfi_pins_in_use(digi_handle_t *digi_handle,
                                      UINT32 port_uid)
{
    UINT8 i = 0;
    UINT8 count = 0;

    PMC_ENTRY();

    for (i = 0; i < DIGI_SERDES_XFI_LANES_MAX; i ++) {

        if (digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid
            == port_uid) {
            count++;
        }
    }

    PMC_RETURN(count);
} /* digi_num_xfi_pins_in_use */


/*******************************************************************************
* digi_num_sys_pins_in_use
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function to find the number of SYS pins in use by the
*   specified port_uid
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   port_uid           - the unique identifier of the SERDES port.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT8 - The number of pins in use by a given port_uid.
*   Zero if no pins are in use by this port_uid
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT8 digi_num_sys_pins_in_use(digi_handle_t *digi_handle,
                                      UINT32 port_uid)
{
    UINT8 i = 0;
    UINT8 count = 0;

    PMC_ENTRY();

    for (i = 0; i < DIGI_SERDES_XFI_LANES_MAX; i ++) {

        if (digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid
            == port_uid) {
            count++;
        }
    }

    PMC_RETURN(count);
} /* digi_num_sys_pins_in_use */


/*******************************************************************************
* digi_cpb_ilkn_xfer_data_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to map the device level transfer mode to CPB
*   SS module local transfer mode.
*
* INPUTS:
*   xfer               - enum, defining device level transfer mode
*   burst              - enum, defining device level burst mode
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   cpb_xfer_mode_t    - definies the CPB SS module transfer mode for the 
*                        device level mode
*
* NOTES:
*
*******************************************************************************/
PRIVATE cpb_xfer_mode_t digi_cpb_ilkn_xfer_data_get(digi_sifd_xfer_mode_t xfer, digi_sifd_burst_t burst)
{
    PMC_ENTRY();
    
    if(xfer==DIGI_SIFD_XFER_MODE_SEGMENT){
        switch(burst){
        case DIGI_SIFD_BURST_128:
            PMC_RETURN(CPB_SEGMENT_BURST_128);
            break;
        case DIGI_SIFD_BURST_192:
            PMC_RETURN(CPB_SEGMENT_BURST_192);
            break;
        case DIGI_SIFD_BURST_256:
            PMC_RETURN(CPB_SEGMENT_BURST_256);
            break;
        default:
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
            break;
        }
    } else if(xfer==DIGI_SIFD_XFER_MODE_PACKET) {
        switch(burst){
        case DIGI_SIFD_BURST_128:
            PMC_RETURN(CPB_PACKET_BURST_128);
            break;
        case DIGI_SIFD_BURST_192:
            PMC_RETURN(CPB_PACKET_BURST_192);
            break;
        case DIGI_SIFD_BURST_256:
            PMC_RETURN(CPB_PACKET_BURST_256);
            break;
        default:
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
            break;
        }
    } else {
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    PMC_RETURN((cpb_xfer_mode_t)DIGI_ERR_INVALID_ARG);

} /* digi_cpb_ilkn_xfer_data_get */


/*******************************************************************************
* digi_dcpb_mapotn_head_hole_match
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to find the head/tail byte length insertion needed
*   for DCPB to match with MAPOTN.
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   *output_pc_ptr     - Destination DPI port / chanel pair for the channel
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - if everything went OK, number of error codes otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_dcpb_mapotn_head_hole_match(digi_handle_t *digi_handle,
                                                  util_global_switch_data_t *output_pc_ptr)
{
    BOOL8 is_broadcast = FALSE;
    BOOL8 is_multicast = FALSE;
    cpb_handle_t* cpb_handle = NULL;
    util_global_switch_data_def_t *local_output_sw_ptr = (util_global_switch_data_def_t *)output_pc_ptr;
    util_global_cpb_port_data_t *local_output_pc_ptr = &(local_output_sw_ptr->cpb_data);
    util_global_cpb_port_data_t local_input_pc;

    UINT32 head_byte_len;
    BOOL8   tail_ins_en;

    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* Check arguments */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);



    PMC_ASSERT(NULL != digi_handle->dcpb_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    cpb_handle = digi_handle->dcpb_handle;
    result = cpb_chnl_source_and_type_test( cpb_handle,
                                            local_output_pc_ptr->port_type,
                                            local_output_pc_ptr->channel,
                                            (UINT32*)&(local_input_pc.port_type),
                                            &(local_input_pc.channel),
                                            &is_broadcast,
                                            &is_multicast);

    if(result) PMC_RETURN(result);



    /*PMC_LOG_TRACE("local_output_pc_ptr->port_type %d\n", local_output_pc_ptr->port_type);
      PMC_LOG_TRACE("local_input_pc.port_type %d\n", local_input_pc.port_type);

      PMC_LOG_TRACE("cpb_input_port %d\n", cpb_input_port);
      PMC_LOG_TRACE("cpb_output_port %d\n", cpb_output_port);*/

    result = mapotn_head_tail_size_get(digi_handle->mapotn_handle, local_output_pc_ptr->channel, &head_byte_len, &tail_ins_en);
    PMC_LOG_TRACE("head_byte_len :%d\n", head_byte_len);
    PMC_LOG_TRACE("tail_ins_en :%d\n", tail_ins_en);


    PMC_ASSERT(local_output_pc_ptr->channel < DIGI_MAPOTN_CHNL_MAX, DIGI_ERR_INVALID_ARG, 0, 0);

    if( (local_input_pc.port_type == UTIL_GLOBAL_CPB_PORT_ILKN1 || local_input_pc.port_type == UTIL_GLOBAL_CPB_PORT_ILKN2) &&
        digi_handle->handle_pool.mapper_chnl[local_output_pc_ptr->channel].mode == DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP)
    
    {
        head_byte_len -= 4;
    }

    if(PMC_SUCCESS == result)
    {
        /* Call the following functions*/
        result = cpb_chnl_hole_inst_head_cfg( cpb_handle, local_output_pc_ptr->port_type, local_output_pc_ptr->channel, head_byte_len);
        if(result) PMC_RETURN(result);

        result = cpb_chnl_hole_inst_tail_cfg( cpb_handle, local_output_pc_ptr->port_type, local_output_pc_ptr->channel, tail_ins_en);
        if(result) PMC_RETURN(result);

    }

    PMC_RETURN(result);

} /* digi_dcpb_mapotn_head_hole_match */

/*******************************************************************************
* digi_fec_init
* ___________________________________________________________________________
*
* DESCRIPTION:
*  Send host message to firmware to initialize FEC
*
* INPUTS:
*   digi_handle -DIGI device handle
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*   None.
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_fec_init(digi_handle_t *digi_handle) 
{
    PMC_ERROR result = PMC_SUCCESS;        
    UINT32 init_fec = 1;
    UINT32 data[1];

    PMC_ENTRY();

    PMC_ASSERT((NULL != digi_handle), HOSTMSG_ERR_INVALID_PARAMETERS, 0, 0);


    data[0] = init_fec;

    {
        HOSTMSG_DECLARE_CFG_MSG_STAT(stat);
        result = hostmsg_send_cfg_message((pmc_handle_t*)digi_handle,MODID_LINEOTN,HOSTMSG_CMD_CFG_LINEOTN_INIT_FEC_ST,data,1,stat);
    }

    PMC_RETURN(result);

} /* End: digi_fec_init() */

/*******************************************************************************
* digi_populate_100_dsi_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function is a private implementation of second part of the digi device dsi
*   post mux and post mld lanes allocation algorithm.
*   requested digi configuration is specified in structures in the digi handle.
*   the algorithm works the following way:
*       1. first step (digi_dsi_lane_allocation) analyzes digi structures and tallies all
*          the requested dsi lanes and their interfaces (OTU2,OTL3.4,SFIS,
*          SFI5.1). once the information is gathered the algorithm will go
*          over a pre-defined digi configuration table and choose the configuration
*          the best matches the requested resources.
*          for this function, configuration rates can be one of the following:
*          - 100G configurations
*          - 2x100G configurations (100G on each interface XFI/SYS)
*
*       2. for 100G configurations we are not using the digi configuration
*          table but rather allocate resources by the number of ports
*          allocated.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*
*   bus_type               - unsiged, specifies the bus to configure:
*                            DSI_ALLOC_SYS_LANES_IDX
*                            DSI_ALLOC_XFI_LANES_IDX
*
*   num_100G_dsi_lanes     - pointer to a 2 byte array that specifies
*                            the number of 100G lanes requested for
*                            XFI/SYS sides.
* OUTPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*                            with relevant structure updated with
*                            algorithm allocations.
*
* RETURNS:
*   PMC_SUCCESS
*   DIGI_ERR_INVALID_ARG - upon failure to find a dsi lanes allocation
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_populate_100_dsi_cfg(digi_handle_t *digi_handle,
                                            UINT8          bus_type,
                                            UINT8*         num_100G_dsi_lanes)
{
    UINT8 i = 0;
    UINT8 k = 0;
    UINT32 port_id = 0;
    UINT8 lane_counter = 0;
    digi_serdes_port_def_t *port_def_ptr = NULL;

    PMC_ENTRY();

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != num_100G_dsi_lanes, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(bus_type<=DSI_ALLOC_XFI_LANES_IDX, DIGI_ERR_INVALID_ARG, 0, 0);

    if(DSI_ALLOC_SYS_LANES_IDX==bus_type)
    {
        /* find the first port id that is allocated */
        for(k=0;k<DIGI_SERDES_SYS_LANES_MAX;k++)
            if(digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[k].port_uid != DIGI_SERDES_UNASSIGNED)
                break;

        if(k<DIGI_SERDES_SYS_LANES_MAX)
            port_id = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[k].port_uid; /* all 100G lanes have the same port id */
        else
            PMC_RETURN(DIGI_ERR_INVALID_ARG); /* we did not find any valid port id !!! */

        lane_counter = 0;

        /* port context struct requires only 1 init configuration per port */
        port_def_ptr = digi_port_ctxt_find(digi_handle, port_id,DIGI_SERDES_SYSTEM_INTF);            
        PMC_ASSERT(port_def_ptr != NULL,DIGI_ERR_NULL_HANDLE,0,0); 
        /* The port_uid should have been saved in the port_ctxt in digi_serdes_port_init */                        
        port_def_ptr->init = TRUE;

        /* populate 100G configuration */
        if(DSI_ALLOC_100G_MIN_DSI_LANE_NUM == num_100G_dsi_lanes[DSI_ALLOC_SYS_LANES_IDX]) /* this is an OTL 4.10 configuration */
        {
            for(i=0;i<DIGI_SERDES_SYS_LANES_MAX;i++)
            {
                if (digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid == port_id) /* go over defined port id's only */
                {
                    digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].post_mux_dsi_lane = lane_counter;
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[lane_counter].port_uid = port_id;
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[lane_counter].cage_uid = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[k].cage_id;/* 100G all lanes have the same cage id */
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[lane_counter].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;
                    lane_counter++;
                }
            }
        }
        else if ((DSI_ALLOC_100G_MIN_DSI_LANE_NUM+1)==num_100G_dsi_lanes[DSI_ALLOC_SYS_LANES_IDX]) /* this is an SFIS n=10+1 configuration */
        {
            for(i=0;i<DIGI_SERDES_SYS_LANES_MAX;i++)
            {
                if (digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid == port_id) /* go over defined port id's only */
                {
                    digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].post_mux_dsi_lane = lane_counter;

                    if(lane_counter<10) /* assumption - last lane (lane 10) is a skew lane */
                    {
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[lane_counter].port_uid = port_id;
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[lane_counter].cage_uid= digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[k].cage_id;/* 100G all lanes have the same cage id */
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[lane_counter].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;
                    }
                    lane_counter++;
                }
            }

        }
        else /* this is an SFIS 2x n=5+1 configuration */
        {
            for(i=0;i<num_100G_dsi_lanes[DSI_ALLOC_SYS_LANES_IDX];i++)
            {
                digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].post_mux_dsi_lane = i;

                if(i<10) /* post mld has only 10 lanes */
                {
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[lane_counter].port_uid = port_id;
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[lane_counter].cage_uid= digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[k].cage_id; /* 100G all lanes have the same cage id */
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[lane_counter].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;

                }
            }

        }
    }
    else /* xfi 100G configuration */
    {
        /* find the first port id that is allocated */
        for(k=0;k<DIGI_SERDES_XFI_LANES_MAX;k++)
            if(digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[k].port_uid != DIGI_SERDES_UNASSIGNED)
                break;

        if(k<DIGI_SERDES_XFI_LANES_MAX)
            port_id = digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[k].port_uid; /* all 100G lanes have the same port id */
        else
            PMC_RETURN(DIGI_ERR_INVALID_ARG); /* we did not find any valid port id !!! */

        /* port context struct requires only 1 init configuration per port */
        port_def_ptr = digi_port_ctxt_find(digi_handle, port_id,DIGI_SERDES_LINE_INTF);            
        PMC_ASSERT(port_def_ptr != NULL,DIGI_ERR_NULL_HANDLE,0,0); 
        /* The port_uid should have been saved in the port_ctxt in digi_serdes_port_init */                        
        port_def_ptr->init = TRUE;

        lane_counter = 0;

        /* populate 100G configuration */
        if(DSI_ALLOC_100G_MIN_DSI_LANE_NUM ==num_100G_dsi_lanes[DSI_ALLOC_XFI_LANES_IDX]) /* this is an OTL 4.10 configuration */
        {
            for(i=0;i<DIGI_SERDES_XFI_LANES_MAX;i++)
            {
                if (digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid == port_id)
                {
                    digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].post_mux_dsi_lane = lane_counter;
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[lane_counter].port_uid = port_id;
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[lane_counter].cage_uid= digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[k].cage_id; /* 100G all lanes have the same cage id */
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[lane_counter].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;
                    lane_counter++;
                }
            }
            
        }
        else if ((DSI_ALLOC_100G_MIN_DSI_LANE_NUM+1)==num_100G_dsi_lanes[DSI_ALLOC_XFI_LANES_IDX]) /* this is an SFIS n=10+1 configuration */
        {
            for(i=0;i<DIGI_SERDES_XFI_LANES_MAX;i++)
            {
                if (digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid == port_id)
                {
                    digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].post_mux_dsi_lane = lane_counter;

                    if(lane_counter<10) /* assumption - last lane (lane 10) is a skew lane */
                    {
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[lane_counter].port_uid = port_id;
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[lane_counter].cage_uid= digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[k].cage_id;/* 100G all lanes have the same cage id */
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[lane_counter].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;
                    }
                    lane_counter++;
                }
            }

        }
        else /* this is an SFIS 2x n=5+1 configuration */
        {
            for(i=0;i<num_100G_dsi_lanes[DSI_ALLOC_XFI_LANES_IDX];i++)
            {
                digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].post_mux_dsi_lane = i;

                if(i<10) /* post mld has only 10 lanes */
                {
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[lane_counter].port_uid = port_id;
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[lane_counter].cage_uid= digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[k].cage_id;/* 100G all lanes have the sam cage id */
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[lane_counter].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;
                }

            }

        }
    }

    PMC_RETURN(PMC_SUCCESS);

}/* digi_populate_100_dsi_cfg */

/*******************************************************************************
* digi_populate_10_40_dsi_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function is a private implementation of second part of the digi device dsi
*   post mux and post mld lanes allocation algorithm.
*   requested digi configuration is specified in structures in the digi handle.
*   the algorithm works the following way:
*       1. first step (digi_dsi_lane_allocation) analyzes digi structures and tallies all
*          the requested dsi lanes and their interfaces (OTU2,OTL3.4,SFIS,
*          SFI5.1). once the information is gathered the algorithm will go
*          over a pre-defined digi configuration table and choose the configuration
*          the best matches the requested resources.
*          for this function, configuration rates can be one of the following:
*          - 120G configurations made out of combinations of 10/40G lanes
*          - 2x120G configurations (120G on each interface XFI/SYS)
*
*       2. once the configuration is chosen the algorithm will retrieve
*          a descriptive configuration bit mask signature and based on this
*          signature will populate the post mux/dsi lanes.
*          this part is done at this function.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*
*   sfis_40g_num           - pointer to a 2 byte array that specifies
*                            the number of 40G SFIS lanes requested for
*                            XFI/SYS sides.
*
*   sfis_40g_port_idx_bm   - pointer to a 2 byte array that holds 1 bit
*                            for every SFIS port configured on XFI/SYS sides.
*                            the bit position in the bit mask is the index
*                            into the digi handle structure that holds
*                            the record of this port.
*
*   otl_40g_num            - pointer to a 2 byte array that specifies
*                            the number of 40G OTL3.4 lanes requested for
*                            XFI/SYS sides.
*
*   otl_40g_port_idx_bm    - pointer to a 2 byte array that holds 1 bit
*                            for every OTL3.4 port configured on XFI/SYS sides.
*                            the bit position in the bit mask is the index
*                            into the digi handle structure that holds
*                            the record of this port.
*
*   otu2_10g_num           - pointer to a 2 byte array that specifies
*                            the number of 10G OTU2 lanes requested for
*                            XFI/SYS sides.
*
*   otu2_10g_port_idx_bm   - pointer to a 2 byte array that holds 1 bit
*                            for every OTU2 port configured on XFI/SYS sides.
*                            the bit position in the bit mask is the index
*                            into the digi handle structure that holds
*                            the record of this port.
*
*   config_signature        - Selected configuration signature  bit mask
*
* OUTPUTS:
*   *digi_handle            - pointer to DIGI handle instance.
*                             with relevant structure updated with
*                             algorithm allocations.
*
* RETURNS:
*   PMC_SUCCESS
*   DIGI_ERR_INVALID_ARG - upon failure to find a dsi lanes allocation
*
* NOTES:
* explantion of the configuration signature bit map:
* cfg_signature_bm is a configuration descriptive bit map to specify how each lane is allocated
* according to the following map:
* bits 0-11 - each bit is a 10G lane. bit lane number is the bit position in the 0-11 bit range.
*
* bit  12   - when 1-> lanes 0-3 are 40G, when 0->  lanes 0-3 are 4x10G
* bit  13   - when 1-> lanes 4-7 are 40G, when 0->  lanes 4-7 are 4x10G
* bit  14   - when 1-> lanes 8-11 are 40G,when 0->  lanes 8-11 are 4x10G
*
* bits 15,16- 00-> lanes 0-3 interface is OTL,
*             01-> lanes 0-3 interface is SFIS,
*             10-> lanes 0-3 interface is SFI5.1 bus A,
*             11-> lanes 0-3 interface is SFI5.1 bus B
*
* bits 17,18- 00-> lanes 4-7 interface is OTL,
*             01-> lanes 4-7 interface is SFIS,
*             10-> lanes 4-7 interface is SFI5.1 bus A,
*             11-> lanes 4-7 interface is SFI5.1 bus B
*
* bits 19,20- 00-> lanes 8-11 interface is OTL,
*             01-> lanes 8-11 interface is SFIS,
*             10-> lanes 8-11 interface is SFI5.1 bus A,
*             11-> lanes 8-11 interface is SFI5.1 bus B
*
* bits 21-31- not used
*******************************************************************************/
PRIVATE PMC_ERROR digi_populate_10_40_dsi_cfg(digi_handle_t *digi_handle,
                                              UINT8*  sfis_40g_num,
                                              UINT16* sfis_40g_port_idx_bm,
                                              UINT8*  otl_40g_num,
                                              UINT16* otl_40g_port_idx_bm,
                                              UINT8*  otu2_10g_num,
                                              UINT16* otu2_10g_port_idx_bm,
                                              UINT32  config_signature)
{

    UINT8     i  = 0;                                       /* general purpose loop variables                                               */
    UINT8     j  = 0;
    UINT8     k  = 0;
    UINT8     m  = 0;
    UINT8     n  = 0;
    UINT8     dsi_lane               = 0;                   /* post mld dsi lane                                                            */
    UINT8     sfis_post_mux_dsi_lane = 0;                   /* sfis post mux lane                                                           */
    UINT8     dsi_lanes[DSI_ALLOC_40G_DSI_LANE_NUM+1];      /* dsi lane array to keep track of the user requested lanes (pins)              */
    UINT8     sfi51_bus     = 0;                            /* sfi 5.1 bus selection variable                                               */
    UINT32    port_id       = 0;                            /* port id container variable used for better code readability                  */
    UINT8     port_idx      = 0;                            /* port idx variable keeps the port array index in the user request arrays      */
    BOOL      sfi51_bus_configured[2] = {FALSE,FALSE};      /* sfi 5.1 state variable to mark that a sfi 5.1 bus was configured             */
    UINT8     cage_id = DIGI_SERDES_PIN_NOT_USED;           /* cage id container variable used for better code readability                  */
    digi_serdes_port_def_t *port_def_ptr = NULL;            /* port context structure pointer                                               */

    PMC_ENTRY();

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != sfis_40g_num, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != sfis_40g_port_idx_bm, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otl_40g_num, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otl_40g_port_idx_bm, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otu2_10g_num, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != otu2_10g_port_idx_bm, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(config_signature > 0, DIGI_ERR_INVALID_ARG,config_signature, 0);


    /* configure sfi 5.1 lanes - go over the configuration signature and analyze the bits:  */
    /* bits 15,16 - lanes 0-3, bits 17,18 - lanes 4-7, bits 19,20 - lanes 8-11              */
    i=15;   /* i index goes over configuration signature bits 15 -20                        */
    j=0;    /* j index is for going over 40G range 0,4,8 to set the base dsi lane           */

    for(sfi51_bus=0;sfi51_bus<DSI_ALLOC_SFI51_BUS_NUM;sfi51_bus++)  /* go over the two sfi 5.1 buses */
    {
        /* if the user has a port configured - we need to allocate resources to it */
        if(digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[sfi51_bus].port_uid != DIGI_SERDES_UNASSIGNED)
        {
            /* go over the confguration signature bits (15-20) and find the allocation for this bus */
            do
            {
                if(sfi51_bus_configured[sfi51_bus]) /* once one allocation is found - stop */
                    break;

                /* does bus B is used in this configuration ? */
                if( ((UINT32)config_signature & (UINT32)(DSI_ALLOC_2BIT_BITMASK<<i)) == (UINT32)(DSI_ALLOC_SFI_BUS_B_BITMASK<<i))
                {
                    port_def_ptr = digi_port_ctxt_find(digi_handle, digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[sfi51_bus].port_uid, DIGI_SERDES_SFI_51_INTF); 
                    if (port_def_ptr == NULL)
                    {
                        port_def_ptr = &(digi_handle->var.port_ctxt.sfi51_port_ctxt[sfi51_bus]);
                    }

                    /* was bus B already provisioned ? - if yes - this is a re-provision case */
                    if(port_def_ptr->init != TRUE)
                    {
                        /* First time provisioning of bus B */
                        port_def_ptr->init = TRUE;
                        digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[sfi51_bus].post_mux_2G5_bus_allocation = DIGI_POST_MUX_BUS_1;

                        /* find the dsi lanes that corrensponds to this port id */
                        for(k=0;k<DSI_ALLOC_40G_DSI_LANE_NUM;k++)
                        {
                            dsi_lane = j+k;     /* j+k --> map to 40G 0,4,8 + dsi lane (0-3) */

                            /* sfi 5.1 post mld lanes are allocated on the LIFD (line) side */
                            digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[dsi_lane].port_uid = digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[sfi51_bus].port_uid;
                            digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[dsi_lane].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;
                            /* remove configured 10G lanes from the configuration bit mask */
                            config_signature &= ~(DSI_ALLOC_10G_BITMASK << dsi_lane);

                        }

                    }
                    else /* this a reprovsion case - remove the provisioned lanes from the signature */
                    {
                        for(k=0;k<DSI_ALLOC_40G_DSI_LANE_NUM;k++)
                        {
                            dsi_lane = j+k;     /* j+k --> map to 40G 0,4,8 + dsi lane (0-3) */

                            /* remove configured 10G lanes from the configuration bit mask */
                            config_signature &= ~(DSI_ALLOC_10G_BITMASK << dsi_lane);
                        }
                    }

                    /* mark this bus as configured */
                    sfi51_bus_configured[sfi51_bus]= TRUE;


                }
                /* does bus A is used in this configuration ? */
                else if( ((UINT32)config_signature & (UINT32)(DSI_ALLOC_2BIT_BITMASK<<i)) == (UINT32)(DSI_ALLOC_SFI_BUS_A_BITMASK<<i))
                {
                    /* First time provisioning of bus A */
                    if(digi_handle->var.port_ctxt.sfi51_port_ctxt[sfi51_bus].init != TRUE)
                    {
                        /* First time provisioning of bus A */
                        digi_handle->var.port_ctxt.sfi51_port_ctxt[sfi51_bus].init = TRUE;
                        digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[sfi51_bus].post_mux_2G5_bus_allocation = DIGI_POST_MUX_BUS_0;

                        for(k=0;k<DSI_ALLOC_40G_DSI_LANE_NUM;k++)
                        {
                            dsi_lane = j+k;     /* j+k --> map to 40G 0,4,8 + dsi lane (0-3) */

                            /* sfi 5.1 post mld lanes are allocated on the LIFD (line) side */
                            digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[dsi_lane].port_uid = digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[sfi51_bus].port_uid;
                            digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[dsi_lane].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;

                            /* remove configured 10G lanes from the configuration bit mask */
                            config_signature &= ~(DSI_ALLOC_10G_BITMASK << dsi_lane);
                        }
                    }
                    else /* remove the provisioned lanes from the signature */
                    {
                        for(k=0;k<DSI_ALLOC_40G_DSI_LANE_NUM;k++)
                        {
                            dsi_lane = j+k;     /* j+k --> map to 40G 0,4,8 + dsi lane (0-3) */

                            /* remove configured 10G lanes from the configuration bit mask */
                            config_signature &= ~(DSI_ALLOC_10G_BITMASK << dsi_lane);
                        }
                    }

                    /* mark this bus as configured */
                    sfi51_bus_configured[sfi51_bus]= TRUE;
                }
                i+=2;   /* forward i to check next 2 bits */
                j+=4;   /* forward j to point to the beginning of next 4 lanes */
            }while(i<20);

            /* set DIGI60_SFI51 */
            if (IS_DIGI60(digi_handle))
            {
                UINT32 value;
                UINT32 vaddr = 0x248;
                value = digi_reg_read_internal(digi_handle, vaddr);
                pmc_sys_reg_write(digi_handle->base.sys_handle, vaddr, (value | 0x2));
            }

        } /* if (sfi51_bus_ctxt[sfi51_bus].port_uid != DIGI_SERDES_UNASSIGNED) */
    } /* for */


    /* configure sfis lanes - go over the configuration signature and analyze the bits:     */
    /* bits 15,16 - lanes 0-3, bits 17,18 - lanes 4-7, bits 19,20 - lanes 8-11              */
    /* i index goes over configuration signature bits 15 -20                                */
    /* j index is for going over 40G range 0,4,8 to set the base dsi lane                   */
    /* m index is for going over post mux 40G range of 5 lanes (0-4,5-9)                    */
    for(i=15,j=0,m=0;i<20; i+=2,j+=4,m+=5)
    {
        PMC_MEMSET(dsi_lanes,0,sizeof(dsi_lanes)) ;

        /* is any sfis is present in this configuration signature? */
        if( ((UINT32)config_signature & (UINT32)(DSI_ALLOC_2BIT_BITMASK<<i)) == (UINT32)(DSI_ALLOC_SFIS_BITMASK<<i) )
        {
            if(sfis_40g_num[DSI_ALLOC_SYS_LANES_IDX] > 0 ) /* have we counted any sfis on sys side - if yes- configure sys lanes */
            {
                /* find the first port array index for a port to be configured */
                for(k=0;k<DSI_ALLOC_MAX_PORT_NUM;k++)
                    if(sfis_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX] & (0x1<<k))
                        break;

                if(k<DSI_ALLOC_MAX_PORT_NUM)
                {
                    /* based on k - extract port id and port idx for later use */
                    port_id = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[k].port_uid;
                    port_idx = k;
                }
                else
                    PMC_RETURN(DIGI_ERR_INVALID_ARG); /* we did not find any valid port index !!! */


                /* keep track of the user requested lanes (pins)        */
                /* group the dsi lanes that have the same port id       */
                n=0;
                for(k=0;k<DSI_ALLOC_MAX_PORT_NUM;k++)
                {
                    if(digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[k].port_uid == port_id)
                    {
                        dsi_lanes[n] = k;
                        n++;
                    }
                }

                /* port context struct requires only 1 init configuration per port */
                port_def_ptr = digi_port_ctxt_find(digi_handle, port_id,DIGI_SERDES_SYSTEM_INTF);            
                PMC_ASSERT(port_def_ptr != NULL,DIGI_ERR_NULL_HANDLE,0,0); 

                for(k=0;k<DSI_ALLOC_40G_DSI_LANE_NUM+1;k++) /* sfis has extra lane at the post mux side */
                {
                    dsi_lane = j+k;     /* j+k --> map to 40G 0,4,8 + dsi lane (0-3) - this will be used for post mld lanes */
                    sfis_post_mux_dsi_lane = m+k; /* update the post mux count */

                    if(port_def_ptr->init != TRUE) /* make sure the port is not provisioned */
                    {
                        if(k<DSI_ALLOC_40G_DSI_LANE_NUM) /* post mux/mld configuration */
                        {
                            /* update the post mux user arrays based on the dsi_lanes array */
                            digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[dsi_lanes[k]].post_mux_dsi_lane = sfis_post_mux_dsi_lane;

                            /* update the post mld user arrays based on the dsi_lane variable */
                            digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[dsi_lane].port_uid = port_id;
                            digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[dsi_lane].cage_uid = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[port_idx].cage_id;
                            digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[dsi_lane].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;

                        }
                        else /* extra lane post mux configuration - no post mld lane*/
                        {
                            digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[dsi_lanes[k]].post_mux_dsi_lane = sfis_post_mux_dsi_lane;
                        }
                    }

                    if(DSI_ALLOC_40G_DSI_LANE_NUM==k)
                        /* mark port as provisioned as last step */                        
                        port_def_ptr->init = TRUE;

                    /* remove configured 10G lanes from the configuration bit mask */
                    config_signature &= ~(DSI_ALLOC_10G_BITMASK << dsi_lane);
                }

                /* remove the count for this port */
                sfis_40g_num[DSI_ALLOC_SYS_LANES_IDX]--;
                sfis_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX] &= ~(0x1<<port_idx);

            }
            else if(sfis_40g_num[DSI_ALLOC_XFI_LANES_IDX] > 0 ) /* have we counted any sfis on xfi side - if yes- configure xfi lanes */
            {
                /* find the first port array index for a port to be configured */
                for(k=0;k<DSI_ALLOC_MAX_PORT_NUM;k++)
                    if(sfis_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX] & (0x1<<k))
                        break;

                if(k<DSI_ALLOC_MAX_PORT_NUM)
                {
                    /* based on k - extract port id and port idx for later use */
                    port_id = digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[k].port_uid;
                    port_idx = k;
                }
                else
                    PMC_RETURN(DIGI_ERR_INVALID_ARG); /* we did not find any valid port index !!! */


                /* keep track of the user requested lanes (pins)        */
                /* group the dsi lanes that have the same port id       */
                n=0;
                for(k=0;k<DSI_ALLOC_MAX_PORT_NUM;k++)
                {
                    if(digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[k].port_uid == port_id)
                    {
                        dsi_lanes[n] = k;
                        n++;
                    }
                }

                /* port context struct requires only 1 init configuration per port */
                port_def_ptr = digi_port_ctxt_find(digi_handle, port_id,DIGI_SERDES_LINE_INTF);            
                PMC_ASSERT(port_def_ptr != NULL,DIGI_ERR_NULL_HANDLE,0,0); 

                for(k=0;k<DSI_ALLOC_40G_DSI_LANE_NUM+1;k++) /* sfis has extra lane post mux */
                {
                    dsi_lane = j+k;     /* j+k --> map to 40G 0,4,8 + dsi lane (0-3) - this will be used for post mld lanes */
                    sfis_post_mux_dsi_lane = m+k;   /* update the post mux count */

                    if(port_def_ptr->init != TRUE) /* make sure the port is not provisioned */
                    {
                        if(k<DSI_ALLOC_40G_DSI_LANE_NUM) /* post mux/mld configuration */
                        {
                            /* update the post mux user arrays based on the dsi_lanes array */
                            digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[dsi_lanes[k]].post_mux_dsi_lane = sfis_post_mux_dsi_lane;

                            /* update the post mld user arrays based on the dsi_lane variable */
                            digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[dsi_lane].port_uid = port_id;
                            digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[dsi_lane].cage_uid = digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[port_idx].cage_id;
                            digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[dsi_lane].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;

                        }
                        else /* extra lane post mux configuration - no post mld lane*/
                        {
                            digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[dsi_lanes[k]].post_mux_dsi_lane = sfis_post_mux_dsi_lane;
                        }
                    }

                    if(DSI_ALLOC_40G_DSI_LANE_NUM==k)
                        /* mark port as provisioned as last step */                        
                        port_def_ptr->init = TRUE;

                    /* remove configured 10G lanes from the configuration bit mask */
                    config_signature &= ~(DSI_ALLOC_10G_BITMASK << dsi_lane);
                }

                /* remove the count for this port */
                sfis_40g_num[DSI_ALLOC_XFI_LANES_IDX]--;
                sfis_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX] &= ~(0x1<<port_idx);

            }
            else
            {
                /* configure only what was requested - this coonfiguration was less the max configuration  */
                /* since this is the last item to configure - no point continuing                          */
                break;
            }
        }
    }


    /* configure otl lanes - go over the configuration signature and analyze the bits:      */
    /* bits 15,16 - lanes 0-3, bits 17,18 - lanes 4-7, bits 19,20 - lanes 8-11              */
    /* i index goes over configuration signature bits 15 -20                                */
    /* j index is for going over 40G range 0,4,8 to set the base dsi lane                   */
    /* m index goes over configuration signature bits 12,13,14:                             */
    /* bit 12 - lanes 0-3                                                                   */
    /* bit 13 - lanes 4-7                                                                   */
    /* bit 14 - lanes 8-11                                                                  */
    m = (12-1); /* this is done on purpose                                                  */

    for(i=15,j=0;i<20; i+=2,j+=4)  /* j index is for going over 40G range 0,4,8 to set the base dsi lane */
    {
        m++; /* increase m index to hit bit 12 and on of the configuration signature */
        PMC_MEMSET(dsi_lanes,0,sizeof(dsi_lanes)) ;

        if( (config_signature & (DSI_ALLOC_2BIT_BITMASK<<i)) == (DSI_ALLOC_OTL_BITMASK<<i) &&   /* are we OTL? */
            (config_signature & (DSI_ALLOC_40G_BITMASK<<m)))          /* make sure we 40G configuration */
        {

            if(otl_40g_num[DSI_ALLOC_XFI_LANES_IDX] > 0 ) /* have we counted any otl on xfi side - if yes- configure xfi lanes */
            {
                /* find the first port array index for a port to be configured */
                for(k=0;k<DSI_ALLOC_MAX_PORT_NUM;k++)
                    if(otl_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX] & (0x1<<k))
                        break;

                if(k<DSI_ALLOC_MAX_PORT_NUM)
                {
                    /* based on k - extract port id and port idx for later use */
                    port_id = digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[k].port_uid;
                    port_idx = k;
                }
                else
                    PMC_RETURN(DIGI_ERR_INVALID_ARG); /* we did not find any valid port index !!! */


                /* keep track of the user requested lanes (pins)        */
                /* group the dsi lanes that have the same port id       */
                n=0;
                for(k=0;k<DSI_ALLOC_MAX_PORT_NUM;k++)
                {
                    if(digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[k].port_uid == port_id)
                    {
                        dsi_lanes[n] = k;
                        n++;
                    }
                }

                /* port context struct requires only 1 init configuration per port */
                port_def_ptr = digi_port_ctxt_find(digi_handle, port_id,DIGI_SERDES_LINE_INTF);            
                PMC_ASSERT(port_def_ptr != NULL,DIGI_ERR_NULL_HANDLE,0,0); 

                for(k=0;k<DSI_ALLOC_40G_DSI_LANE_NUM;k++)
                {
                    dsi_lane = j+k;     /* j+k --> map to 40G 0,4,8 + dsi lane (0-3) */
                    if(port_def_ptr->init != TRUE) /* make sure the port is no provisioned */
                    {
                        /* update the post mux user arrays based on the dsi_lanes array */
                        digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[dsi_lanes[k]].post_mux_dsi_lane = dsi_lane;

                        /* update the post mld user arrays based on the dsi_lane variable */
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[dsi_lane].port_uid = port_id;
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[dsi_lane].cage_uid =digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[port_idx].cage_id;
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[dsi_lane].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;

                    }
                    if((DSI_ALLOC_40G_DSI_LANE_NUM-1)==k)
                        /* mark port as provisioned as last step */                        
                        port_def_ptr->init = TRUE;
                    
                    /* remove configured 10G lanes from the configuration bit mask */
                    config_signature &= ~(DSI_ALLOC_10G_BITMASK << dsi_lane);
                    
                }

                /* write off the configured interfaces ports so we will not configure them again */
                otl_40g_num[DSI_ALLOC_XFI_LANES_IDX]--;
                otl_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX] &= ~(0x1<<port_idx);

            }
            else if(otl_40g_num[DSI_ALLOC_SYS_LANES_IDX] > 0 )  /* have we counted any otl on sys side - if yes- configure sys lanes */
            {
                /* find the first port array index for a port to be configured */
                for(k=0;k<DSI_ALLOC_MAX_PORT_NUM;k++)
                    if(otl_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX] & (0x1<<k))
                        break;

                if(k<DSI_ALLOC_MAX_PORT_NUM)
                {
                    /* based on k - extract port id and port idx for later use */
                    port_id = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[k].port_uid;
                    port_idx = k;
                }
                else
                    PMC_RETURN(DIGI_ERR_INVALID_ARG); /* we did not find any valid port index !!! */


                /* keep track of the user requested lanes (pins)        */
                /* group the dsi lanes that have the same port id       */
                n=0;
                for(k=0;k<DSI_ALLOC_MAX_PORT_NUM;k++)
                {
                    if(digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[k].port_uid == port_id)
                    {
                        dsi_lanes[n] = k;
                        n++;
                    }
                }

                /* port context struct requires only 1 init configuration per port */
                port_def_ptr = digi_port_ctxt_find(digi_handle, port_id,DIGI_SERDES_SYSTEM_INTF);            
                PMC_ASSERT(port_def_ptr != NULL,DIGI_ERR_NULL_HANDLE,0,0); 

                for(k=0;k<DSI_ALLOC_40G_DSI_LANE_NUM;k++)
                {

                    dsi_lane = j+k;     /* j+k --> map to 40G 0,4,8 + dsi lane (0-3) */
                    if( port_def_ptr->init != TRUE) /* make sure the port is not provisioned */
                    {
                        /* update the post mux user arrays based on the dsi_lanes array */
                        digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[dsi_lanes[k]].post_mux_dsi_lane = dsi_lane;

                        /* update the post mld user arrays based on the dsi_lane variable */
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[dsi_lane].port_uid = port_id;
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[dsi_lane].cage_uid =digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[port_idx].cage_id;
                        digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[dsi_lane].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;
                    }

                    if((DSI_ALLOC_40G_DSI_LANE_NUM-1)==k)
                        /* mark port as provisioned as last step */                        
                        port_def_ptr->init = TRUE;

                    /* remove configured 10G lanes from the configuration bit mask */
                    config_signature &= ~(DSI_ALLOC_10G_BITMASK << dsi_lane);
                }

                /* write off the configured interfaces ports so we will not configure them again */
                otl_40g_num[DSI_ALLOC_SYS_LANES_IDX]--;
                otl_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX] &= ~(0x1<<port_idx);

            }
            else
            {
                /* configure only what was requested - this coonfiguration was less the max configuration  */
                /* since this is the last item to configure - no point continuing                          */
                break;
            }
        }
    }

    /* configure otu2 lanes. since we zeroed all lanes of 40G in the 0-11 section of the  configuration signature bit map,  */
    /* all that is left there now is 10G lanes                                                                              */
    for(i=0 ;i< DSI_ALLOC_10G_DSI_LANE_NUM ;i++ )
    {
        if((config_signature & (DSI_ALLOC_10G_BITMASK<<i)) )
        {
            if(otu2_10g_num[DSI_ALLOC_SYS_LANES_IDX] > 0) /* have we counted any otu2 on sys side - if yes- configure sys lanes */
            {

                /* find the first port array index for a port to be configured */
                for(k=0;k<DSI_ALLOC_MAX_PORT_NUM;k++)
                    if(otu2_10g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX] & (0x1<<k))
                        break;

                if(k<DSI_ALLOC_MAX_PORT_NUM)
                {
                    /* based on k - extract port id,port idx and cage id for later use */
                    port_id  = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[k].port_uid;
                    port_idx = k;
                    cage_id  = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[k].cage_id;
                }
                else
                    PMC_RETURN(DIGI_ERR_INVALID_ARG); /* we did not find any valid port index !!! */

                /* port context struct requires only 1 init configuration per port */
                port_def_ptr = digi_port_ctxt_find(digi_handle, port_id,DIGI_SERDES_SYSTEM_INTF);            
                PMC_ASSERT(port_def_ptr != NULL,DIGI_ERR_NULL_HANDLE,0,0); 

                if( port_def_ptr->init != TRUE) /* make sure the port is not provisioned */
                {
                    /* update the post mux user arrays based on the port_idx  */
                    digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[port_idx].post_mux_dsi_lane = i;

                    /* update the post mld user arrays based on the configuration bit position i index */
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].port_uid = port_id;
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].cage_uid = cage_id;
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[i].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;

                    /* mark port as provisioned as last step */                        
                    port_def_ptr->init = TRUE;

                }

                /* remove configured 10G lanes from the configuration bit mask */
                config_signature &= ~(0x1<<i);

                /* write off the configured interfaces ports so we will not configure them again */
                otu2_10g_num[DSI_ALLOC_SYS_LANES_IDX]--;
                otu2_10g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX] &= ~(0x1<<port_idx);

                /* look for other ports with the same cage id - we want to allocate all bonded  ports */
                /* to the same post mld group of lanes.                                               */
                for(n=0 ;n< DSI_ALLOC_10G_DSI_LANE_NUM ;n++ )
                {
                    /* do not configure again the port we just configured above         */
                    /* since these are 10G lanes port ids are different for each lane   */
                    /* find the ports that belong to the same cage id                   */
                    if(cage_id == digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[n].cage_id &&
                       port_id != digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[n].port_uid )
                    {
                        /* find the next 10G lane to allocate based on the configuartion signature */
                        for(k=0 ;k< DSI_ALLOC_10G_DSI_LANE_NUM ;k++ )
                            if((config_signature & (DSI_ALLOC_10G_BITMASK<<k)) )
                                break;

                        if(k>=DSI_ALLOC_10G_DSI_LANE_NUM)
                            PMC_RETURN(DIGI_ERR_INVALID_ARG); /* we did not find any valid port index !!! */

                        if(otu2_10g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX] & (0x1<<n))
                        {
                            port_id = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[n].port_uid;
                            port_idx = n;

                            /* port context struct requires only 1 init configuration per port */
                            port_def_ptr = digi_port_ctxt_find(digi_handle, port_id,DIGI_SERDES_SYSTEM_INTF);            
                            PMC_ASSERT(port_def_ptr != NULL,DIGI_ERR_NULL_HANDLE,0,0); 

                            if( port_def_ptr->init != TRUE ) /* make sure the port is not provisioned */
                            {
                                /* update the post mux user arrays based on the port_idx (n) variable */
                                digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[port_idx].post_mux_dsi_lane = k;

                                /* update the post mld user arrays based on the configuration bit position k index */
                                digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[k].port_uid = port_id;
                                digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[k].cage_uid = cage_id;
                                digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[k].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;

                                /* mark port as provisioned as last step */                        
                                port_def_ptr->init = TRUE;
                            }

                            /* remove configured 10G lanes from the configuration bit mask */
                            config_signature &= ~(0x1<<k);

                            /* write off the configured interfaces ports so we will not configure them again */
                            otu2_10g_num[DSI_ALLOC_SYS_LANES_IDX]--;
                            otu2_10g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX] &= ~(0x1<<port_idx);
                        }
                    }
                }

            }
            else if(otu2_10g_num[DSI_ALLOC_XFI_LANES_IDX] > 0 ) /* have we counted any otu2 on xfi side - if yes- configure xfi lanes */
            {

                /* find the first port index */
                for(k=0;k<DSI_ALLOC_MAX_PORT_NUM;k++)
                    if(otu2_10g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX] & (0x1<<k))
                        break;

                if(k<DSI_ALLOC_MAX_PORT_NUM)
                {
                    /* based on k - extract port id,port idx and cage id for later use */
                    port_id = digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[k].port_uid;
                    port_idx = k;
                    cage_id  = digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[k].cage_id;
                }
                else
                    PMC_RETURN(DIGI_ERR_INVALID_ARG); /* we did not find any valid port index !!! */


                /* port context struct requires only 1 init configuration per port */
                port_def_ptr = digi_port_ctxt_find(digi_handle, port_id,DIGI_SERDES_LINE_INTF);            
                PMC_ASSERT(port_def_ptr != NULL,DIGI_ERR_NULL_HANDLE,0,0); 

                if( port_def_ptr->init != TRUE) /* make sure the port is no provisioned */
                {
                    /* update the post mux user arrays based on the port_idx  */
                    digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[port_idx].post_mux_dsi_lane = i;
                    
                    /* update the post mld user arrays based on the configuration bit position i index */
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].port_uid = port_id;
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].cage_uid = cage_id;
                    digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[i].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;

                    /* mark port as provisioned as last step */                        
                    port_def_ptr->init = TRUE;
                }

                /* remove configured 10G lanes from the configuration bit mask */
                config_signature &= ~(DSI_ALLOC_10G_BITMASK<<i);
                
                /* write off the configured interfaces ports so we will not configure them again */
                otu2_10g_num[DSI_ALLOC_XFI_LANES_IDX]--;
                otu2_10g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX] &= ~(0x1<<port_idx);
                
                /* look for other ports with the same cage id - we want to allocate all bonded  ports */
                /* to the same post mld group of lanes.                                               */
                for(n=0 ;n< DSI_ALLOC_10G_DSI_LANE_NUM ;n++ )
                {
                    /* do not configure again the port we just configured above         */
                    /* since these are 10G lanes port ids are different for each lane   */
                    /* find the ports that belong to the same cage id                   */
                    if(cage_id == digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[n].cage_id &&
                       port_id != digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[n].port_uid )
                    {

                        /* find the next 10G lane to allocate based on the configuartion signature */
                        for(k=0 ;k< DSI_ALLOC_10G_DSI_LANE_NUM ;k++ )
                            if((config_signature & (DSI_ALLOC_10G_BITMASK<<k)) )
                                break;

                        if(k>=DSI_ALLOC_10G_DSI_LANE_NUM)
                            PMC_RETURN(DIGI_ERR_INVALID_ARG); /* we did not find any valid port index !!! */

                        if(otu2_10g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX] & (0x1<<n))
                        {
                            port_id = digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[n].port_uid;
                            port_idx = n;

                            /* port context struct requires only 1 init configuration per port */
                            port_def_ptr = digi_port_ctxt_find(digi_handle, port_id,DIGI_SERDES_LINE_INTF);            
                            PMC_ASSERT(port_def_ptr != NULL,DIGI_ERR_NULL_HANDLE,0,0); 

                            if( port_def_ptr->init != TRUE ) /* make sure the port is no provisioned */
                            {
                                /* update the post mux user arrays based on the port_idx (n) variable */
                                digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[port_idx].post_mux_dsi_lane = k;

                                /* update the post mld user arrays based on the configuration bit position k index */
                                digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[k].port_uid = port_id;
                                digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[k].cage_uid = cage_id;
                                digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[k].prov_state = DIGI_SERDES_PROV_STATE_UNASSIGNED;

                                /* mark port as provisioned as last step */                        
                                port_def_ptr->init = TRUE;

                            }

                            /* remove configured 10G lanes from the configuration bit mask */
                            config_signature &= ~(0x1<<k);

                            /* write off the configured interfaces ports so we will not configure them again */
                            otu2_10g_num[DSI_ALLOC_XFI_LANES_IDX]--;
                            otu2_10g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX] &= ~(0x1<<port_idx);
                        }
                    }
                }


            }
            else
            {
                /* configured only what was requested - this coonfiguration was les the max configurations */
                /* since this is the last item to configure - no point continuing                          */
                break;
            }

        }
    }

    PMC_RETURN(PMC_SUCCESS);
}/* digi_populate_10_40_dsi_cfg */

/*******************************************************************************
* digi_dsi_lane_allocation
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function is the implementation of the digi device dsi post mux and post
*   mld lanes per requested digi configuration. requested digi configuration is
*   specified in structures in the digi handle.
*   the algorithm  works the following way:
*       1. first step (this function) analyzes digi structures and tallies all
*          the requested dsi lanes and their interfaces (OTU2,OTL3.4,SFIS,
*          SFI5.1). once the information is gathered the algorithm will go
*          over a pre-defined digi configuration table and choose the configuration
*          the best matches the requested resources.
*          configuration rates can be one of the following:
*          - 100G configurations
*          - 120G configurations made out of combinations of 10/40G lanes
*          - 2x100G configurations (100G on each interface XFI/SYS)
*          - 2x120G configurations (120G on each interface XFI/SYS)
*
*       2. once the configuration is chosen the algorithm will retrieve
*          a descriptive configuration bit mask signature and based on this
*          signature will populate the post mux/dsi lanes.
*          this part is done at the digi_populate_10_40_dsi_cfg  and
*          digi_populate_100_dsi_cfg functions.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*
* OUTPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*                            with relevant structure updated with
*                            algorithm allocations.
*
*   line_interface_only    - if only need init line interface.
* RETURNS:
*   PMC_SUCCESS
*   DIGI_ERR_INVALID_ARG - upon failure to find a dsi lanes allocation
*
* NOTES:
*   1. For best practices it is recommended to call the algorithm with the
*      MAXIMUM intended resources needed allocation.
*      calling the algorithm with less than MAXIMUM intended resources
*      will allocate the FIRST configuration that matches the requested resources.
*      Adding more resources in a later time might require the user to deprovision
*      the current configuration and provision again with new resources added.
*
*   2. for 100G configurations we are not using the digi configuration
*      table but rather allocate resources by counting the number of ports allocated.
*******************************************************************************/
PUBLIC PMC_ERROR digi_dsi_lane_allocation(digi_handle_t *digi_handle, BOOL8 line_interface_only)
{
    PMC_ERROR rc = PMC_SUCCESS;                     /* return code                                                                  */

    UINT8     i  = 0;                               /* general purpose loop variables                                               */
    UINT8     k  = 0;
    UINT8     n  = 0;
    BOOL      xfi_100G_cfg = FALSE;                 /* XFI/SYS 100G boolean flags set to TRUE when we detected 100G configuration   */
    BOOL      sys_100G_cfg = FALSE;
    UINT8     num_100G_dsi_lanes[2]  = {0,0};       /* tally variables for SYS(index 0)/XFI(index 1) configurations                 */
    UINT8     otl_40g_num [2]        = {0,0};
    UINT8     sfis_40g_num[2]        = {0,0};
    UINT8     otu2_10g_num[2]        = {0,0};
    UINT8     sfi51_40g_num          = 0;
    UINT16    otl_40g_port_idx_bm [2]= {0,0};       /* port index bit mask variables SYS(index 0)/XFI(index 1) configurations       */
    UINT16    otu2_10g_port_idx_bm[2]= {0,0};
    UINT16    sfis_40g_port_idx_bm[2]= {0,0};
    UINT8     same_port_ids_num = 0;                /* counter for ports with the same port id                                      */
    UINT32    port_ids[DIGI_SERDES_SYS_LANES_MAX];  /* a 12 UINT32 array to mark port ids as already counted                        */
    BOOL      port_found = FALSE;                   /* a boolean to set to TRUE when a port id is found in the port_ids array       */
    UINT8     total_otl   = 0;                      /* sum of all tallied interfaces (how many we have of each type)                */
    UINT8     total_sfis  = 0;
    UINT8     total_otu2  = 0;
    UINT16    total_bandwidth = 0;                  /* total bandwidth requested in this allocation                                 */
    BOOL sys_ports_empty = FALSE;
    BOOL xfi_ports_empty = FALSE;

    PMC_ENTRY();

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* clean the port ids array before we start counting the different interfaces */
    PMC_MEMSET(port_ids,DIGI_SERDES_UNASSIGNED,sizeof(port_ids));

    /* go over the configuration structures and extract the number of each interface */
    /* start with SYS side */
  if(!line_interface_only)
  {
    for(i=0;i<DIGI_SERDES_SYS_LANES_MAX;i++)
    {
        /* count only configured ports */
        if(digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid!= DIGI_SERDES_UNASSIGNED )
        {
            same_port_ids_num = 0; /* this counts how many of the current port_uid we have */

            for(k=0;k<DIGI_SERDES_SYS_LANES_MAX;k++)
                if(digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid == digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[k].port_uid)
                    same_port_ids_num++;

            /* this code is to make sure we count the same port ids only once           */
            /* search for the port in the port_ids array - has it been counted before?  */
            port_found = FALSE;
            for(n=0;n<DIGI_SERDES_SYS_LANES_MAX;n++)
                if(port_ids[n]==digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid )
                    port_found = TRUE;      /* port has already been counted - we will not count it again */

            if(!port_found)  /* port was never counted - add port to the port_ids list and tally */
            {
                for(n=0;n<DIGI_SERDES_SYS_LANES_MAX;n++)  /* find the first empty place on port_ids list */
                {
                    if( port_ids[n]==DIGI_SERDES_UNASSIGNED )
                    {
                        port_ids[n]=digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid;
                        break;
                    }
                }

                switch(same_port_ids_num)
                {
                case 1: /* this is a 10G port id */
                    otu2_10g_num[DSI_ALLOC_SYS_LANES_IDX]++;
                    otu2_10g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX] |= (0x1<<i);
                    break;

                case 4: /* this is a 40G OTL port id */
                    otl_40g_num[DSI_ALLOC_SYS_LANES_IDX]++;
                    otl_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX] |= (0x1<<i);
                    break;

                case 5:  /* this is a 40G OTL port id */
                    sfis_40g_num[DSI_ALLOC_SYS_LANES_IDX]++;
                    sfis_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX] |= (0x1<<i);
                    break;

                case 10: /* this 100G cage */
                case 11:
                case 12:
                    sys_100G_cfg = TRUE;
                    num_100G_dsi_lanes[DSI_ALLOC_SYS_LANES_IDX] = same_port_ids_num;
                    break;

                default:
                    rc = DIGI_ERR_INVALID_ARG;
                    break;
                }
            }
        }

    }
  }
    if (PMC_SUCCESS == rc)
    {
        /* clean the port ids array before we start counting the different interfaces */
        PMC_MEMSET(port_ids,DIGI_SERDES_UNASSIGNED,sizeof(port_ids));

        /* go over the configuration structures and extract the number of each interface */
        /* now count XFI side */
        for(i=0;i<DIGI_SERDES_XFI_LANES_MAX;i++)
        {
            if(digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid != DIGI_SERDES_UNASSIGNED ) /* count only configured ports */
            {
                same_port_ids_num = 0;          /* this counts how many of the current port_uid we have */
                for(k=0;k<DIGI_SERDES_XFI_LANES_MAX;k++)
                    if(digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid == digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[k].port_uid)
                        same_port_ids_num++;

                /* this code is to make sure we count the same port ids only once           */
                /* search for the port in the port_ids array - has it been counted before?  */
                port_found = FALSE;
                for(n=0;n<DIGI_SERDES_XFI_LANES_MAX;n++)
                    if(port_ids[n]==digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid )
                        port_found = TRUE;  /* port has already been counted - we will not count it again */

                if(!port_found) /* port was never counted - add port to the port_ids list and tally */
                {
                    for(n=0;n<DIGI_SERDES_XFI_LANES_MAX;n++) /* find the first empty place on the port_ids list */
                    {
                        if(port_ids[n]==DIGI_SERDES_UNASSIGNED)
                        {
                            port_ids[n]=digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid;
                            break;
                        }
                    }

                    switch(same_port_ids_num)
                    {
                    case 1: /* this is a 10G port id */
                        otu2_10g_num[DSI_ALLOC_XFI_LANES_IDX]++;
                        otu2_10g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX] |= (0x1<<i);
                        break;

                    case 4: /* this is a 40G OTL port id */
                        otl_40g_num[DSI_ALLOC_XFI_LANES_IDX]++;
                        otl_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX] |= (0x1<<i);
                        break;

                    case 5:  /* this is a 40G OTL port id */
                        sfis_40g_num[DSI_ALLOC_XFI_LANES_IDX]++;
                        sfis_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX] |= (0x1<<i);
                        break;

                    case 10: /* this 100G cage */
                    case 11:
                    case 12:
                        xfi_100G_cfg = TRUE;
                        num_100G_dsi_lanes[DSI_ALLOC_XFI_LANES_IDX] = same_port_ids_num;
                        break;

                    default:
                        rc = DIGI_ERR_INVALID_ARG;
                        break;
                    }

                }
            }
        }
    }

    if (PMC_SUCCESS == rc)
    {
        /* last step of tally - count sfi 5.1 ports */
        for(i=0;i<DIGI_NUM_SFI51_PORTS_MAX;i++)
            if( digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[i].port_uid != DIGI_SERDES_UNASSIGNED )
                sfi51_40g_num++;
    }

    /* second stage - compare with known configurations. now that we know how many of each  */
    /* resource is needed lets try and find a configuration that matches the needs          */
    if( PMC_SUCCESS == rc )
    {
        if( sys_100G_cfg || xfi_100G_cfg ) /* this is a 100G configuration - allocate resources accordingly */
        {

            /* if we got this far then we can populate the 100G lanes   */
            /* could be that we have 2x100G configuration               */
            if(sys_100G_cfg)
            {
                total_bandwidth+=100;
                rc = digi_populate_100_dsi_cfg(digi_handle,DSI_ALLOC_SYS_LANES_IDX,&num_100G_dsi_lanes[0]); /* 0 index is on purpose !!! */
            
                if(10 == num_100G_dsi_lanes[DSI_ALLOC_SYS_LANES_IDX])
                    digi_handle->var.sysotn_cfg_num = 0;  /* 100G  OTL4.10 */
                else if(11 == num_100G_dsi_lanes[DSI_ALLOC_SYS_LANES_IDX])
                    digi_handle->var.sysotn_cfg_num = 1;  /* 100G  SFIS-S(10+1) */
            
            }

            if( PMC_SUCCESS==rc && xfi_100G_cfg)
            {
                /* based on the number of lanes keep the configuration number in the digi handle */
                /* it will be required later for lineotn SS provisioning                         */
                /* this is done on only on the XFI side                                          */
                if(10 == num_100G_dsi_lanes[DSI_ALLOC_XFI_LANES_IDX])
                    digi_handle->var.lineotn_cfg_num = 0;  /* 100G  OTL4.10 */
                else if(11 == num_100G_dsi_lanes[DSI_ALLOC_XFI_LANES_IDX])
                    digi_handle->var.lineotn_cfg_num = 1;  /* 100G  SFIS-S(10+1) */
                else
                    digi_handle->var.lineotn_cfg_num = 2;  /* 100G  2xSFI-S](5+1) */

                total_bandwidth+=100;
                rc=digi_populate_100_dsi_cfg(digi_handle,DSI_ALLOC_XFI_LANES_IDX,&num_100G_dsi_lanes[0]);/* 0 index is on purpose !!! */
            }


        }

        if( PMC_SUCCESS==rc && total_bandwidth < 200 ) /* if we already configured 200G there is no point going into 40/10G */
        {
            UINT16 total_bw_40_10g_cfg = 0; /* local copy of the 40/10G configuration */
            UINT32 pins_used = 0;

            /* done with 100G configurations. now look at 40/10G configurations */
            /* calculate the total bandwidth for 10/40G configurations          */
            total_otl   = otl_40g_num[DSI_ALLOC_SYS_LANES_IDX] + otl_40g_num[DSI_ALLOC_XFI_LANES_IDX];
            total_sfis  = sfis_40g_num[DSI_ALLOC_SYS_LANES_IDX]+ sfis_40g_num[DSI_ALLOC_XFI_LANES_IDX];
            total_otu2  = otu2_10g_num[DSI_ALLOC_SYS_LANES_IDX]+ otu2_10g_num[DSI_ALLOC_XFI_LANES_IDX];
            total_bw_40_10g_cfg = (total_otl+total_sfis+sfi51_40g_num)*40 + total_otu2*10;

            pins_used = total_otl*4 + total_sfis*5 + total_otu2;
            if(total_bandwidth != 0)
                pins_used += 10;

            total_bandwidth += total_bw_40_10g_cfg; /* add to the total BW */

            if(otl_40g_num[DSI_ALLOC_SYS_LANES_IDX] == 0 && sfis_40g_num[DSI_ALLOC_SYS_LANES_IDX] == 0 && otu2_10g_num[DSI_ALLOC_SYS_LANES_IDX] == 0)
                sys_ports_empty = TRUE;

            if(otl_40g_num[DSI_ALLOC_XFI_LANES_IDX] == 0 && sfis_40g_num[DSI_ALLOC_XFI_LANES_IDX] == 0 && otu2_10g_num[DSI_ALLOC_XFI_LANES_IDX] == 0 && sfi51_40g_num == 0)
                xfi_ports_empty = TRUE;


            /* at this point, total_bandwidth could be 0 if there is not port configured 
               a use case is when we only configure the BP interface 
            */
            if( total_bandwidth > 0 )  {   
                if(total_bw_40_10g_cfg > 0) /* this is a 40G/10G configuration */
                {   
                    if((total_bandwidth <= 120) && (pins_used <= 12))
                    {
                        /* first - go over the configuration table and try to find an exact match */
                        for(i=0;i<DSI_ALLOC_MAX_CFG_NUM;i++)
                        {  
                            if( sfi51_40g_num == digi_handle->cfg.digi_cfg_tbl[i].sfi51_40g_num &&
                                total_sfis == digi_handle->cfg.digi_cfg_tbl[i].sfis_40g_num &&
                                total_otl == digi_handle->cfg.digi_cfg_tbl[i].otl_40g_num &&
                                total_otu2 == digi_handle->cfg.digi_cfg_tbl[i].otu2_10g_num )
                                break;

                        }

                        if(i<DSI_ALLOC_MAX_CFG_NUM)
                        {  
                            PMC_LOG_TRACE("Line %d Find the exact match configure table item at %d.\n", __LINE__, i);
                            /* have found a configuration - extract signature and fill structures */
                            rc = digi_populate_10_40_dsi_cfg(digi_handle,
                                                             &sfis_40g_num[0],
                                                             &sfis_40g_port_idx_bm[0],
                                                             &otl_40g_num[0],
                                                             &otl_40g_port_idx_bm[0],
                                                             &otu2_10g_num[0],
                                                             &otu2_10g_port_idx_bm[0],
                                                             digi_handle->cfg.digi_cfg_tbl[i].cfg_signature_bm);

                        }
                        else /* no exact configuration found - try to find one that will accomodate user needs */
                        {
                            for(i=0;i<DSI_ALLOC_MAX_CFG_NUM;i++)
                            {
                                if( sfi51_40g_num <= digi_handle->cfg.digi_cfg_tbl[i].sfi51_40g_num &&
                                    total_sfis <= digi_handle->cfg.digi_cfg_tbl[i].sfis_40g_num &&
                                    total_otl <= digi_handle->cfg.digi_cfg_tbl[i].otl_40g_num &&
                                    total_otu2 <= digi_handle->cfg.digi_cfg_tbl[i].otu2_10g_num )
                                    break;

                            }
                            if(i<DSI_ALLOC_MAX_CFG_NUM)
                            {
                                PMC_LOG_TRACE("Line %d Find best match configure table item at %d.\n", __LINE__, i);
                                /* have found a configuration - extract signature and fill structures */
                                rc = digi_populate_10_40_dsi_cfg(digi_handle,
                                                                 &sfis_40g_num[0],
                                                                 &sfis_40g_port_idx_bm[0],
                                                                 &otl_40g_num[0],
                                                                 &otl_40g_port_idx_bm[0],
                                                                 &otu2_10g_num[0],
                                                                 &otu2_10g_port_idx_bm[0],
                                                                 digi_handle->cfg.digi_cfg_tbl[i].cfg_signature_bm);

                            }
                            else /* no configuration found - report error and exit */
                            {
                                rc = DIGI_ERR_INVALID_ARG;
                            }

                        }

                        /* Only reset the lineotn_cfg_num if we haven't set it
                         * in the 100G case */
                        if ((rc == PMC_SUCCESS) && (xfi_100G_cfg == FALSE)) {

                            /* based on the index to the config table - save the config number
                             * it will be required later for lineotn SS provisioning */
                            digi_handle->var.lineotn_cfg_num = digi_handle->cfg.digi_cfg_tbl[i].cfg_num;
                        }

                    }
                    else /* more than 120G -> allocate 2x120G that could for each xfi/sys interface */
                    {
                        for(k=0;k<=DSI_ALLOC_XFI_LANES_IDX;k++) /* allocate for each interface seperatley - index 0-->sys, index 1-->xfi */
                        {
                            UINT8  temp_sfis_40g_num;
                            UINT16 temp_sfis_40g_port_idx_bm;
                            UINT8  temp_otl_40g_num;
                            UINT16 temp_otl_40g_port_idx_bm;
                            UINT8  temp_otu2_10g_num;
                            UINT16 temp_otu2_10g_port_idx_bm;
                            UINT8  total_sfi51;

                            if(( k==DSI_ALLOC_SYS_LANES_IDX && sys_100G_cfg ) || /* sys interface is already configured as 100G */
                               ( k==DSI_ALLOC_XFI_LANES_IDX && xfi_100G_cfg ) )  /* xfi interface is already configured as 100G */
                                continue;

                            /* count totals only for the relevant interface that is being configured */
                            total_otl   = otl_40g_num[k] ;
                            total_sfis  = sfis_40g_num[k];
                            total_otu2  = otu2_10g_num[k];

                            if(k==DSI_ALLOC_SYS_LANES_IDX) /* sys interface does not have a sfi5.1 */
                                total_sfi51 = 0;
                            else
                                total_sfi51 = sfi51_40g_num;

                            /* first - go over the configuration table and try to find an exact match */
                            for(i=0;i<DSI_ALLOC_MAX_CFG_NUM;i++)
                            {
                                if( total_sfi51 == digi_handle->cfg.digi_cfg_tbl[i].sfi51_40g_num &&
                                    total_sfis == digi_handle->cfg.digi_cfg_tbl[i].sfis_40g_num &&
                                    total_otl == digi_handle->cfg.digi_cfg_tbl[i].otl_40g_num &&
                                    total_otu2 == digi_handle->cfg.digi_cfg_tbl[i].otu2_10g_num )
                                    break;

                            }

                            if(i<DSI_ALLOC_MAX_CFG_NUM)
                            {
                                /* when populating sys, temporarily zero xfi fields */
                                /* this is required for the population algorithm to ignore the xfi side */
                                if(k==DSI_ALLOC_SYS_LANES_IDX)
                                {
                                    /* store for later */
                                    temp_sfis_40g_num           = sfis_40g_num[DSI_ALLOC_XFI_LANES_IDX];
                                    temp_sfis_40g_port_idx_bm   = sfis_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX];
                                    temp_otl_40g_num            = otl_40g_num[DSI_ALLOC_XFI_LANES_IDX];
                                    temp_otl_40g_port_idx_bm    = otl_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX];
                                    temp_otu2_10g_num           = otu2_10g_num[DSI_ALLOC_XFI_LANES_IDX];
                                    temp_otu2_10g_port_idx_bm   = otu2_10g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX];

                                    /* zero fields */
                                    sfis_40g_num[DSI_ALLOC_XFI_LANES_IDX]           = 0;
                                    sfis_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX]   = 0;
                                    otl_40g_num[DSI_ALLOC_XFI_LANES_IDX]            = 0;
                                    otl_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX]    = 0;
                                    otu2_10g_num[DSI_ALLOC_XFI_LANES_IDX]           = 0;
                                    otu2_10g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX]   = 0;


                                }
                                else /* when populating xfi, temporarily zero sys fields */
                                {    /* this is required for the population algorithm to ignore the sys side */

                                    /* store for later */
                                    temp_sfis_40g_num           = sfis_40g_num[DSI_ALLOC_SYS_LANES_IDX];
                                    temp_sfis_40g_port_idx_bm   = sfis_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX];
                                    temp_otl_40g_num            = otl_40g_num[DSI_ALLOC_SYS_LANES_IDX];
                                    temp_otl_40g_port_idx_bm    = otl_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX];
                                    temp_otu2_10g_num           = otu2_10g_num[DSI_ALLOC_SYS_LANES_IDX];
                                    temp_otu2_10g_port_idx_bm   = otu2_10g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX];

                                    /* zero fields */
                                    sfis_40g_num[DSI_ALLOC_SYS_LANES_IDX]           = 0;
                                    sfis_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX]   = 0;
                                    otl_40g_num[DSI_ALLOC_SYS_LANES_IDX]            = 0;
                                    otl_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX]    = 0;
                                    otu2_10g_num[DSI_ALLOC_SYS_LANES_IDX]           = 0;
                                    otu2_10g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX]   = 0;

                                }

                                /* have found a configuration - extract signature and fill structures */
                                rc = digi_populate_10_40_dsi_cfg(digi_handle,
                                                                 &sfis_40g_num[0],
                                                                 &sfis_40g_port_idx_bm[0],
                                                                 &otl_40g_num[0],
                                                                 &otl_40g_port_idx_bm[0],
                                                                 &otu2_10g_num[0],
                                                                 &otu2_10g_port_idx_bm[0],
                                                                 digi_handle->cfg.digi_cfg_tbl[i].cfg_signature_bm);


                                /* Done populating sys, restore xfi fields */
                                if(k==DSI_ALLOC_SYS_LANES_IDX)
                                {
                                    /* restore xfi values */
                                    sfis_40g_num[DSI_ALLOC_XFI_LANES_IDX]           = temp_sfis_40g_num;
                                    sfis_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX]   = temp_sfis_40g_port_idx_bm;
                                    otl_40g_num[DSI_ALLOC_XFI_LANES_IDX]            = temp_otl_40g_num;
                                    otl_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX]    = temp_otl_40g_port_idx_bm;
                                    otu2_10g_num[DSI_ALLOC_XFI_LANES_IDX]           = temp_otu2_10g_num;
                                    otu2_10g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX]   = temp_otu2_10g_port_idx_bm;

                                }
                                else /* Done populating xfi, restore sys fields */
                                {
                                    /* restore sys values */
                                    sfis_40g_num[DSI_ALLOC_SYS_LANES_IDX]           = temp_sfis_40g_num;
                                    sfis_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX]   = temp_sfis_40g_port_idx_bm;
                                    otl_40g_num[DSI_ALLOC_SYS_LANES_IDX]            = temp_otl_40g_num;
                                    otl_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX]    = temp_otl_40g_port_idx_bm;
                                    otu2_10g_num[DSI_ALLOC_SYS_LANES_IDX]           = temp_otu2_10g_num;
                                    otu2_10g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX]   = temp_otu2_10g_port_idx_bm;
                                }


                                if(rc != PMC_SUCCESS)
                                    break;

                            }
                            else /* no exact configuration found - try to find one that will accomodate user needs */
                            {
                                for(i=0;i<DSI_ALLOC_MAX_CFG_NUM;i++)
                                {
                                    if( total_sfi51 <= digi_handle->cfg.digi_cfg_tbl[i].sfi51_40g_num &&
                                        total_sfis <= digi_handle->cfg.digi_cfg_tbl[i].sfis_40g_num &&
                                        total_otl <= digi_handle->cfg.digi_cfg_tbl[i].otl_40g_num &&
                                        total_otu2 <= digi_handle->cfg.digi_cfg_tbl[i].otu2_10g_num )
                                        break;

                                }

                                if(i<DSI_ALLOC_MAX_CFG_NUM)
                                {

                                    /* when populating sys, temporarily zero xfi fields */
                                    /* this is required for the population algorithm to ignore the sys side */
                                    if(k==DSI_ALLOC_SYS_LANES_IDX)
                                    {
                                        /* store for later */
                                        temp_sfis_40g_num           = sfis_40g_num[DSI_ALLOC_XFI_LANES_IDX];
                                        temp_sfis_40g_port_idx_bm   = sfis_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX];
                                        temp_otl_40g_num            = otl_40g_num[DSI_ALLOC_XFI_LANES_IDX];
                                        temp_otl_40g_port_idx_bm    = otl_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX];
                                        temp_otu2_10g_num           = otu2_10g_num[DSI_ALLOC_XFI_LANES_IDX];
                                        temp_otu2_10g_port_idx_bm   = otu2_10g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX];

                                        /* zero fields */
                                        sfis_40g_num[DSI_ALLOC_XFI_LANES_IDX]           = 0;
                                        sfis_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX]   = 0;
                                        otl_40g_num[DSI_ALLOC_XFI_LANES_IDX]            = 0;
                                        otl_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX]    = 0;
                                        otu2_10g_num[DSI_ALLOC_XFI_LANES_IDX]           = 0;
                                        otu2_10g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX]   = 0;


                                    }
                                    else /* when populating xfi, temporarily zero sys fields */
                                    {    /* this is required for the population algorithm to ignore the xfi side */
                                        /* store for later */
                                        temp_sfis_40g_num           = sfis_40g_num[DSI_ALLOC_SYS_LANES_IDX];
                                        temp_sfis_40g_port_idx_bm   = sfis_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX];
                                        temp_otl_40g_num            = otl_40g_num[DSI_ALLOC_SYS_LANES_IDX];
                                        temp_otl_40g_port_idx_bm    = otl_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX];
                                        temp_otu2_10g_num           = otu2_10g_num[DSI_ALLOC_SYS_LANES_IDX];
                                        temp_otu2_10g_port_idx_bm   = otu2_10g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX];

                                        /* zero fields */
                                        sfis_40g_num[DSI_ALLOC_SYS_LANES_IDX]           = 0;
                                        sfis_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX]   = 0;
                                        otl_40g_num[DSI_ALLOC_SYS_LANES_IDX]            = 0;
                                        otl_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX]    = 0;
                                        otu2_10g_num[DSI_ALLOC_SYS_LANES_IDX]           = 0;
                                        otu2_10g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX]   = 0;

                                    }

                                    /* have found a configuration - extract signature and fill structures */
                                    rc = digi_populate_10_40_dsi_cfg(digi_handle,
                                                                     &sfis_40g_num[0],
                                                                     &sfis_40g_port_idx_bm[0],
                                                                     &otl_40g_num[0],
                                                                     &otl_40g_port_idx_bm[0],
                                                                     &otu2_10g_num[0],
                                                                     &otu2_10g_port_idx_bm[0],
                                                                     digi_handle->cfg.digi_cfg_tbl[i].cfg_signature_bm);


                                    /* Done populating sys, restore xfi fields */
                                    if(k==DSI_ALLOC_SYS_LANES_IDX)
                                    {
                                        /* restore xfi values */
                                        sfis_40g_num[DSI_ALLOC_XFI_LANES_IDX]           = temp_sfis_40g_num;
                                        sfis_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX]   = temp_sfis_40g_port_idx_bm;
                                        otl_40g_num[DSI_ALLOC_XFI_LANES_IDX]            = temp_otl_40g_num;
                                        otl_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX]    = temp_otl_40g_port_idx_bm;
                                        otu2_10g_num[DSI_ALLOC_XFI_LANES_IDX]           = temp_otu2_10g_num;
                                        otu2_10g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX]   = temp_otu2_10g_port_idx_bm;

                                    }
                                    else /* Done populating xfi, restore sys fields */
                                    {
                                        /* restore sys values */
                                        sfis_40g_num[DSI_ALLOC_SYS_LANES_IDX]           = temp_sfis_40g_num;
                                        sfis_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX]   = temp_sfis_40g_port_idx_bm;
                                        otl_40g_num[DSI_ALLOC_SYS_LANES_IDX]            = temp_otl_40g_num;
                                        otl_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX]    = temp_otl_40g_port_idx_bm;
                                        otu2_10g_num[DSI_ALLOC_SYS_LANES_IDX]           = temp_otu2_10g_num;
                                        otu2_10g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX]   = temp_otu2_10g_port_idx_bm;
                                    }

                                    if(rc != PMC_SUCCESS)
                                        break;


                                }
                                else /* no configuration found - report error and exit */
                                {
                                    rc = DIGI_ERR_INVALID_ARG;
                                    break;
                                }

                            }

                            /* Only reset the lineotn_cfg_num if we haven't set it
                             * in the 100G case */
                            if ((rc == PMC_SUCCESS) &&
                                (k == DSI_ALLOC_XFI_LANES_IDX) &&
                                (xfi_100G_cfg == FALSE)) {

                                /* based on the index to the config table - save the config number
                                 * it will be required later for lineotn SS provisioning
                                 * this is done only on xfi side */
                                digi_handle->var.lineotn_cfg_num = digi_handle->cfg.digi_cfg_tbl[i].cfg_num;
                            }
                        }
                    }
                }
            }
        }
    }

    PMC_RETURN(rc);
}/* digi_dsi_lane_allocation */

/*******************************************************************************
* digi_otn_cfg_mode_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function is used to set OTN configuration mode. 
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*
* OUTPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*                            with relevant structure updated with
*                            algorithm allocations.
*
* RETURNS:
*   PMC_SUCCESS
*   DIGI_ERR_INVALID_ARG - upon failure to find a dsi lanes allocation
*
* NOTES:
*   None
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_cfg_mode_set(digi_handle_t *digi_handle)
{
    PMC_ERROR rc = PMC_SUCCESS;                     /* return code                                                                  */

    UINT8     i  = 0;                               /* general purpose loop variables                                               */
    UINT8     k  = 0;
    UINT8     n  = 0;
    BOOL      xfi_100G_cfg = FALSE;                 /* XFI/SYS 100G boolean flags set to TRUE when we detected 100G configuration   */
    BOOL      sys_100G_cfg = FALSE;
    UINT8     num_100G_dsi_lanes[2]  = {0,0};       /* tally variables for SYS(index 0)/XFI(index 1) configurations                 */
    UINT8     otl_40g_num [2]        = {0,0};
    UINT8     sfis_40g_num[2]        = {0,0};
    UINT8     otu2_10g_num[2]        = {0,0};
    UINT8     sfi51_40g_num          = 0;
    UINT16    otl_40g_port_idx_bm [2]= {0,0};       /* port index bit mask variables SYS(index 0)/XFI(index 1) configurations       */
    UINT16    otu2_10g_port_idx_bm[2]= {0,0};
    UINT16    sfis_40g_port_idx_bm[2]= {0,0};
    UINT8     same_port_ids_num = 0;                /* counter for ports with the same port id                                      */
    UINT32    port_ids[DIGI_SERDES_SYS_LANES_MAX];  /* a 12 UINT32 array to mark port ids as already counted                        */
    BOOL      port_found = FALSE;                   /* a boolean to set to TRUE when a port id is found in the port_ids array       */
    UINT8     total_otl   = 0;                      /* sum of all tallied interfaces (how many we have of each type)                */
    UINT8     total_sfis  = 0;
    UINT8     total_otu2  = 0;
    UINT16    total_bandwidth = 0;                  /* total bandwidth requested in this allocation                                 */
    BOOL sys_ports_empty = FALSE;
    BOOL xfi_ports_empty = FALSE;

    PMC_ENTRY();

    /* check inputs */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* clean the port ids array before we start counting the different interfaces */
    PMC_MEMSET(port_ids,DIGI_SERDES_UNASSIGNED,sizeof(port_ids));

    /* go over the configuration structures and extract the number of each interface */
    /* start with SYS side */
    for(i=0;i<DIGI_SERDES_SYS_LANES_MAX;i++)
    {
        /* count only configured ports */
        if(digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid!= DIGI_SERDES_UNASSIGNED )
        {
            same_port_ids_num = 0; /* this counts how many of the current port_uid we have */

            for(k=0;k<DIGI_SERDES_SYS_LANES_MAX;k++)
                if(digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid == digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[k].port_uid)
                    same_port_ids_num++;

            /* this code is to make sure we count the same port ids only once           */
            /* search for the port in the port_ids array - has it been counted before?  */
            port_found = FALSE;
            for(n=0;n<DIGI_SERDES_SYS_LANES_MAX;n++)
                if(port_ids[n]==digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid )
                    port_found = TRUE;      /* port has already been counted - we will not count it again */

            if(!port_found)  /* port was never counted - add port to the port_ids list and tally */
            {
                for(n=0;n<DIGI_SERDES_SYS_LANES_MAX;n++)  /* find the first empty place on port_ids list */
                {
                    if( port_ids[n]==DIGI_SERDES_UNASSIGNED )
                    {
                        port_ids[n]=digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid;
                        break;
                    }
                }

                switch(same_port_ids_num)
                {
                case 1: /* this is a 10G port id */
                    otu2_10g_num[DSI_ALLOC_SYS_LANES_IDX]++;
                    otu2_10g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX] |= (0x1<<i);
                    break;

                case 4: /* this is a 40G OTL port id */
                    otl_40g_num[DSI_ALLOC_SYS_LANES_IDX]++;
                    otl_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX] |= (0x1<<i);
                    break;

                case 5:  /* this is a 40G OTL port id */
                    sfis_40g_num[DSI_ALLOC_SYS_LANES_IDX]++;
                    sfis_40g_port_idx_bm[DSI_ALLOC_SYS_LANES_IDX] |= (0x1<<i);
                    break;

                case 10: /* this 100G cage */
                case 11:
                case 12:
                    sys_100G_cfg = TRUE;
                    num_100G_dsi_lanes[DSI_ALLOC_SYS_LANES_IDX] = same_port_ids_num;
                    break;

                default:
                    rc = DIGI_ERR_INVALID_ARG;
                    break;
                }
            }
        }

    }

    if (PMC_SUCCESS == rc)
    {
        /* clean the port ids array before we start counting the different interfaces */
        PMC_MEMSET(port_ids,DIGI_SERDES_UNASSIGNED,sizeof(port_ids));

        /* go over the configuration structures and extract the number of each interface */
        /* now count XFI side */
        for(i=0;i<DIGI_SERDES_XFI_LANES_MAX;i++)
        {
            if(digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid != DIGI_SERDES_UNASSIGNED ) /* count only configured ports */
            {
                same_port_ids_num = 0;          /* this counts how many of the current port_uid we have */
                for(k=0;k<DIGI_SERDES_XFI_LANES_MAX;k++)
                    if(digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid == digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[k].port_uid)
                        same_port_ids_num++;

                /* this code is to make sure we count the same port ids only once           */
                /* search for the port in the port_ids array - has it been counted before?  */
                port_found = FALSE;
                for(n=0;n<DIGI_SERDES_XFI_LANES_MAX;n++)
                    if(port_ids[n]==digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid )
                        port_found = TRUE;  /* port has already been counted - we will not count it again */

                if(!port_found) /* port was never counted - add port to the port_ids list and tally */
                {
                    for(n=0;n<DIGI_SERDES_XFI_LANES_MAX;n++) /* find the first empty place on the port_ids list */
                    {
                        if(port_ids[n]==DIGI_SERDES_UNASSIGNED)
                        {
                            port_ids[n]=digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid;
                            break;
                        }
                    }

                    switch(same_port_ids_num)
                    {
                    case 1: /* this is a 10G port id */
                        otu2_10g_num[DSI_ALLOC_XFI_LANES_IDX]++;
                        otu2_10g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX] |= (0x1<<i);
                        break;

                    case 4: /* this is a 40G OTL port id */
                        otl_40g_num[DSI_ALLOC_XFI_LANES_IDX]++;
                        otl_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX] |= (0x1<<i);
                        break;

                    case 5:  /* this is a 40G OTL port id */
                        sfis_40g_num[DSI_ALLOC_XFI_LANES_IDX]++;
                        sfis_40g_port_idx_bm[DSI_ALLOC_XFI_LANES_IDX] |= (0x1<<i);
                        break;

                    case 10: /* this 100G cage */
                    case 11:
                    case 12:
                        xfi_100G_cfg = TRUE;
                        num_100G_dsi_lanes[DSI_ALLOC_XFI_LANES_IDX] = same_port_ids_num;
                        break;

                    default:
                        rc = DIGI_ERR_INVALID_ARG;
                        break;
                    }

                }
            }
        }
    }

    if (PMC_SUCCESS == rc)
    {
        /* last step of tally - count sfi 5.1 ports */
        for(i=0;i<DIGI_NUM_SFI51_PORTS_MAX;i++)
            if( digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[i].port_uid != DIGI_SERDES_UNASSIGNED )
                sfi51_40g_num++;
    }

    /* second stage - compare with known configurations. now that we know how many of each  */
    /* resource is needed lets try and find a configuration that matches the needs          */
    if( PMC_SUCCESS == rc )
    {
        if( sys_100G_cfg || xfi_100G_cfg ) /* this is a 100G configuration - allocate resources accordingly */
        {
            /* if we got this far then we can populate the 100G lanes   */
            /* could be that we have 2x100G configuration               */
            if(sys_100G_cfg)
            {
                total_bandwidth+=100;
                /*rc = digi_populate_100_dsi_cfg(digi_handle,DSI_ALLOC_SYS_LANES_IDX,&num_100G_dsi_lanes[0]);*/ /* 0 index is on purpose !!! */
            
                if(10 == num_100G_dsi_lanes[DSI_ALLOC_SYS_LANES_IDX])
                    digi_handle->var.sysotn_cfg_num = 0;  /* 100G  OTL4.10 */
                else if(11 == num_100G_dsi_lanes[DSI_ALLOC_SYS_LANES_IDX])
                    digi_handle->var.sysotn_cfg_num = 1;  /* 100G  SFIS-S(10+1) */
            
            }

            if( PMC_SUCCESS==rc && xfi_100G_cfg)
            {
                /* based on the number of lanes keep the configuration number in the digi handle */
                /* it will be required later for lineotn SS provisioning                         */
                /* this is done on only on the XFI side                                          */
                if(10 == num_100G_dsi_lanes[DSI_ALLOC_XFI_LANES_IDX])
                    digi_handle->var.lineotn_cfg_num = 0;  /* 100G  OTL4.10 */
                else if(11 == num_100G_dsi_lanes[DSI_ALLOC_XFI_LANES_IDX])
                    digi_handle->var.lineotn_cfg_num = 1;  /* 100G  SFIS-S(10+1) */
                else
                    digi_handle->var.lineotn_cfg_num = 2;  /* 100G  2xSFI-S](5+1) */

                total_bandwidth+=100;
                /*rc=digi_populate_100_dsi_cfg(digi_handle,DSI_ALLOC_XFI_LANES_IDX,&num_100G_dsi_lanes[0]);*//* 0 index is on purpose !!! */
            }
        }

        if( PMC_SUCCESS==rc && total_bandwidth < 200 ) /* if we already configured 200G there is no point going into 40/10G */
        {
            UINT16 total_bw_40_10g_cfg = 0; /* local copy of the 40/10G configuration */
            UINT32 pins_used = 0;

            /* done with 100G configurations. now look at 40/10G configurations */
            /* calculate the total bandwidth for 10/40G configurations          */
            total_otl   = otl_40g_num[DSI_ALLOC_SYS_LANES_IDX] + otl_40g_num[DSI_ALLOC_XFI_LANES_IDX];
            total_sfis  = sfis_40g_num[DSI_ALLOC_SYS_LANES_IDX]+ sfis_40g_num[DSI_ALLOC_XFI_LANES_IDX];
            total_otu2  = otu2_10g_num[DSI_ALLOC_SYS_LANES_IDX]+ otu2_10g_num[DSI_ALLOC_XFI_LANES_IDX];
            total_bw_40_10g_cfg = (total_otl+total_sfis+sfi51_40g_num)*40 + total_otu2*10;

            pins_used = total_otl*4 + total_sfis*5 + total_otu2;
            if(total_bandwidth != 0)
                pins_used += 10;

            total_bandwidth += total_bw_40_10g_cfg; /* add to the total BW */

            if(otl_40g_num[DSI_ALLOC_SYS_LANES_IDX] == 0 && sfis_40g_num[DSI_ALLOC_SYS_LANES_IDX] == 0 && otu2_10g_num[DSI_ALLOC_SYS_LANES_IDX] == 0)
                sys_ports_empty = TRUE;

            if(otl_40g_num[DSI_ALLOC_XFI_LANES_IDX] == 0 && sfis_40g_num[DSI_ALLOC_XFI_LANES_IDX] == 0 && otu2_10g_num[DSI_ALLOC_XFI_LANES_IDX] == 0 && sfi51_40g_num == 0)
                xfi_ports_empty = TRUE;


            /* at this point, total_bandwidth could be 0 if there is not port configured 
               a use case is when we only configure the BP interface 
            */
            if( total_bandwidth > 0 )  {   
                if(total_bw_40_10g_cfg > 0) /* this is a 40G/10G configuration */
                {   
                    if((total_bandwidth <= 120) && (pins_used <= 12))
                    {
                        /* first - go over the configuration table and try to find an exact match */
                        for(i=0;i<DSI_ALLOC_MAX_CFG_NUM;i++)
                        {  
                            if( sfi51_40g_num == digi_handle->cfg.digi_cfg_tbl[i].sfi51_40g_num &&
                                total_sfis == digi_handle->cfg.digi_cfg_tbl[i].sfis_40g_num &&
                                total_otl == digi_handle->cfg.digi_cfg_tbl[i].otl_40g_num &&
                                total_otu2 == digi_handle->cfg.digi_cfg_tbl[i].otu2_10g_num )
                                break;

                        }

                        if(i>=DSI_ALLOC_MAX_CFG_NUM)
                        { 
                             /* no exact configuration found - try to find one that will accomodate user needs */
                            for(i=0;i<DSI_ALLOC_MAX_CFG_NUM;i++)
                            {
                                if( sfi51_40g_num <= digi_handle->cfg.digi_cfg_tbl[i].sfi51_40g_num &&
                                    total_sfis <= digi_handle->cfg.digi_cfg_tbl[i].sfis_40g_num &&
                                    total_otl <= digi_handle->cfg.digi_cfg_tbl[i].otl_40g_num &&
                                    total_otu2 <= digi_handle->cfg.digi_cfg_tbl[i].otu2_10g_num )
                                    break;

                            }
                            if(i>=DSI_ALLOC_MAX_CFG_NUM)
                            {
                                /* no configuration found - report error and exit */
                                rc = DIGI_ERR_INVALID_ARG;
                            }

                        }

                        /* Only reset the lineotn_cfg_num if we haven't set it
                         * in the 100G case */
                        if ((rc == PMC_SUCCESS) && (xfi_100G_cfg == FALSE)) {

                            /* based on the index to the config table - save the config number
                             * it will be required later for lineotn SS provisioning */
                            digi_handle->var.lineotn_cfg_num = digi_handle->cfg.digi_cfg_tbl[i].cfg_num;
                        }

                    }
                    else /* more than 120G -> allocate 2x120G that could for each xfi/sys interface */
                    {
                        for(k=0;k<=DSI_ALLOC_XFI_LANES_IDX;k++) /* allocate for each interface seperatley - index 0-->sys, index 1-->xfi */
                        {
                            UINT8  total_sfi51;

                            if(( k==DSI_ALLOC_SYS_LANES_IDX && sys_100G_cfg ) || /* sys interface is already configured as 100G */
                               ( k==DSI_ALLOC_XFI_LANES_IDX && xfi_100G_cfg ) )  /* xfi interface is already configured as 100G */
                                continue;

                            /* count totals only for the relevant interface that is being configured */
                            total_otl   = otl_40g_num[k] ;
                            total_sfis  = sfis_40g_num[k];
                            total_otu2  = otu2_10g_num[k];

                            if(k==DSI_ALLOC_SYS_LANES_IDX) /* sys interface does not have a sfi5.1 */
                                total_sfi51 = 0;
                            else
                                total_sfi51 = sfi51_40g_num;

                            /* first - go over the configuration table and try to find an exact match */
                            for(i=0;i<DSI_ALLOC_MAX_CFG_NUM;i++)
                            {
                                if( total_sfi51 == digi_handle->cfg.digi_cfg_tbl[i].sfi51_40g_num &&
                                    total_sfis == digi_handle->cfg.digi_cfg_tbl[i].sfis_40g_num &&
                                    total_otl == digi_handle->cfg.digi_cfg_tbl[i].otl_40g_num &&
                                    total_otu2 == digi_handle->cfg.digi_cfg_tbl[i].otu2_10g_num )
                                    break;

                            }

                            if(i>=DSI_ALLOC_MAX_CFG_NUM)
                            {
                                /* no exact configuration found - try to find one that will accomodate user needs */
                                for(i=0;i<DSI_ALLOC_MAX_CFG_NUM;i++)
                                {
                                    if( total_sfi51 <= digi_handle->cfg.digi_cfg_tbl[i].sfi51_40g_num &&
                                        total_sfis <= digi_handle->cfg.digi_cfg_tbl[i].sfis_40g_num &&
                                        total_otl <= digi_handle->cfg.digi_cfg_tbl[i].otl_40g_num &&
                                        total_otu2 <= digi_handle->cfg.digi_cfg_tbl[i].otu2_10g_num )
                                        break;

                                }

                                if(i>=DSI_ALLOC_MAX_CFG_NUM)
                                {
                                    /* no configuration found - report error and exit */
                                    rc = DIGI_ERR_INVALID_ARG;
                                    break;
                                }

                            }

                            /* Only reset the lineotn_cfg_num if we haven't set it
                             * in the 100G case */
                            if ((rc == PMC_SUCCESS) &&
                                (k == DSI_ALLOC_XFI_LANES_IDX) &&
                                (xfi_100G_cfg == FALSE)) {

                                /* based on the index to the config table - save the config number
                                 * it will be required later for lineotn SS provisioning
                                 * this is done only on xfi side */
                                digi_handle->var.lineotn_cfg_num = digi_handle->cfg.digi_cfg_tbl[i].cfg_num;
                            }
                        }
                    }
                }
            }
        }
    }

    PMC_RETURN(rc);
}
#endif /* DOXYGEN_PUBLIC_ONLY */

/*******************************************************************************
* digi_ilkn_chnl_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function applies static configuration required for independent
*   channels transferred across ILKN interface.\n\n

*   For proper device operation, no traffic should be transferred through 
*   this channel before function call.\n\n
*
*   DIGI Applib internally specifies the DPI channel ID.\n\n 
*
*   For each channel the API sets the chnl_ctxt_pptr value.  This pointer is
*   used for future API calls for provisioing data flows against a channel. \n\n
*
*   For ODUKSW with optional 2B and 4B headers enabled, the fields 
*
*   For ODUKSW with Rx 2B header Mode 0 enabled, the rx_2B_header value must be
*   unique for each channel configured.  In this mode, tx_ilkn_bcw_chnl and
*   rx_ilkn_bcw_chnl may be replicated. \n\n
*   
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *ilkn_ctxt_ptr         - Interlaken configuration information obtained
*                            from digi_device_cfg(). Either the configuration
*                            for ILKN1 or ILKN2 will need to be passed here to
*                            configure a channel against either ILKN blk.
*   target                 - Subsystem to source/sink data for the channel.
*                            See digi_ilkn_chnl_target_t for more information.
*   tx_ilkn_bcw_chnl       - Defines the burst control word channel that will be
*                            associated with the outbound channel.
*                            Used for output_port ILKN1/ILKN2 only.
*   tx_2b_header           - Defines the 2B header for source ODUKSW channels.
*   tx_4b_header           - Defines the 4B header for source ODUKSW channels.
*   rx_ilkn_bcw_chnl       - Defines the burst control word channel that will be
*                            associated with the inbound channel
*   rx_2b_header           - Defines the 2B header for sink ODUKSW channels.
*   rx_4b_header           - Defines the expected 4B header for sink ODUKSW channels.
*
* OUTPUTS:
*   **chnl_ctxt_pptr       - a pointer to a pointer to a digi_ilkn_chnl_t
*                            structure consisting of a channel data this is
*                            returned to the user.
*
* RETURNS:
*   PMC_SUCCESS, DIGI_ERR_ILKN_IS_ACTIVE, DIGI_ERR_INVALID_ARG,
*   or values from sub-functions
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_chnl_cfg(digi_handle_t *digi_handle,
                                    digi_ilkn_link_t *ilkn_ctxt_ptr,
                                    digi_ilkn_chnl_target_t target,
                                    UINT32 tx_ilkn_bcw_chnl,
                                    UINT16 tx_2b_header,
                                    UINT32 tx_4b_header,
                                    UINT32 rx_ilkn_bcw_chnl,
                                    UINT16 rx_2b_header,
                                    UINT32 rx_4b_header,                                
                                    digi_ilkn_chnl_t **chnl_ctxt_pptr)
{
    PMC_ERROR result = DIGI_ERR_UNKNOWN;

    digi_ilkn_link_def_t* digi_ilkn_link_data_ptr;
    digi_sifd_ilkn_inst_t digi_sifd_ilkn_inst;

    UINT32 chnl_index;
    UINT8  chnl_id = 0;
    digi_ilkn_chnl_def_t* tmp_chnl_ptr = NULL;
    UINT32 ilkn_index = 0;

    PMC_ATOMIC_ENTRY(digi_handle);


    result = digi_ilkn_chnl_cfg_params_validate(digi_handle,
                                                ilkn_ctxt_ptr,
                                                target,
                                                tx_ilkn_bcw_chnl,
                                                tx_2b_header,
                                                tx_4b_header,
                                                rx_ilkn_bcw_chnl,
                                                rx_2b_header,
                                                rx_4b_header, 
                                                chnl_ctxt_pptr);
    if (result == PMC_SUCCESS) {
        digi_ilkn_link_data_ptr = (digi_ilkn_link_def_t*)ilkn_ctxt_ptr;
        digi_sifd_ilkn_inst = digi_ilkn_link_data_ptr->ilkn_inst;

        /* get the first available channel to provision */
        result = digi_ilkn_unused_chnl_get(digi_handle, 
                                           target,
                                           digi_sifd_ilkn_inst, 
                                           &chnl_index); 

        if (result == PMC_SUCCESS) {

            if (digi_sifd_ilkn_inst == DIGI_SIFD_ILKN1) {

                tmp_chnl_ptr = &(digi_handle->handle_pool.ilkn_1_chnl[chnl_index]);

            } else if (digi_sifd_ilkn_inst == DIGI_SIFD_ILKN2) {

                tmp_chnl_ptr = &(digi_handle->handle_pool.ilkn_2_chnl[chnl_index]);
            } else {
                /*
                 * For completeness adding assert here to ensure that
                 * it is  not possible to dereference tmp_chnl_ptr if
                 * not valid.
                 */
                PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
            }
                
            if (target == DIGI_ILKN_CHNL_TARGET_CPB) {

                chnl_id = tmp_chnl_ptr->switch_data.cpb_data.channel;

            } else if (target == DIGI_ILKN_CHNL_TARGET_ODUK) {

                chnl_id = tmp_chnl_ptr->switch_data.oduk_data.channel;

            } else {

                /* Shouldn't be possible to enter here due to previous
                 * validation of arguments */
                PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
            } 

            result = sifd_ilkn_rx_chnl_cfg(digi_handle->sifd_handle,
                                           (sifd_ilkn_inst_t)digi_sifd_ilkn_inst, 
                                           rx_ilkn_bcw_chnl,
                                           target,
                                           chnl_id,
                                           rx_4b_header,                                
                                           rx_2b_header);

            if (result == PMC_SUCCESS) {
                                     
                result = sifd_ilkn_tx_chnl_cfg(digi_handle->sifd_handle,
                                               (sifd_ilkn_inst_t)digi_sifd_ilkn_inst,
                                               target,
                                               chnl_id,
                                               tx_ilkn_bcw_chnl,
                                               tx_4b_header,                                
                                               tx_2b_header); 

                if (result == PMC_SUCCESS) {

                    /* Success path */

                    if (digi_sifd_ilkn_inst == DIGI_SIFD_ILKN1) {

                        tmp_chnl_ptr->switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_ILKN1;
                        tmp_chnl_ptr->switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_ILKN1;

                    } else if (digi_sifd_ilkn_inst == DIGI_SIFD_ILKN2) {

                        tmp_chnl_ptr->switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_ILKN2;
                        tmp_chnl_ptr->switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_ILKN2;
                    }

                    /* Should have been set in initialization, but keep idempotent  */
                    tmp_chnl_ptr->switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;

                    /* Turn the opposite of the target to "NOT USED" */
                    if (target == DIGI_ILKN_CHNL_TARGET_ODUK) {

                        tmp_chnl_ptr->switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;

                    } else {

                        tmp_chnl_ptr->switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_NOT_USED;
                    }

                    tmp_chnl_ptr->switch_data.cpb_data.data_source = 0;

                    /* Initialize the following for mapping purposes */
                    tmp_chnl_ptr->switch_data.cpb_data.op_state.map_state.input_map_count = 0;
                    tmp_chnl_ptr->switch_data.cpb_data.op_state.map_state.is_input_mapped = FALSE;
                    tmp_chnl_ptr->switch_data.cpb_data.op_state.map_state.is_output_mapped = FALSE;
                    tmp_chnl_ptr->switch_data.cpb_data.op_state.active_state = UTIL_GLOBAL_CHNL_ACTIVE_STATE_INACTIVE;

                    /* ILKN specific portion */
                    tmp_chnl_ptr->target = target;
                    tmp_chnl_ptr->tx_ilkn_info.ilkn_bcw_chnl = tx_ilkn_bcw_chnl;
                    tmp_chnl_ptr->tx_ilkn_info.ilkn_2b_header = tx_2b_header;
                    tmp_chnl_ptr->tx_ilkn_info.ilkn_4b_header = tx_4b_header;
                    tmp_chnl_ptr->rx_ilkn_info.ilkn_bcw_chnl = rx_ilkn_bcw_chnl;
                    tmp_chnl_ptr->rx_ilkn_info.ilkn_2b_header = rx_2b_header;
                    tmp_chnl_ptr->rx_ilkn_info.ilkn_4b_header = rx_4b_header;

                    /* It is now configured */
                    tmp_chnl_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
                    tmp_chnl_ptr->rate = 0;
                    tmp_chnl_ptr->rx_fc_reach_extend = FALSE;
                    *chnl_ctxt_pptr = tmp_chnl_ptr;

                    /* ILKN 1 BCW to DPI Channel Mapping Table channel configuration */     
                    if (digi_sifd_ilkn_inst == DIGI_SIFD_ILKN1)
                    {
                        if (target == DIGI_ILKN_CHNL_TARGET_ODUK)
                        {
                            if (DIGI_SIFD_BCW_CHANNEL_NULL == digi_handle->var.tx_ilkn_1_bcw_dpi_map[tx_ilkn_bcw_chnl])
                            {
                                digi_handle->var.tx_ilkn_1_bcw_dpi_map[tx_ilkn_bcw_chnl] = chnl_id + DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX;
                            }
                            else
                            {
                                digi_handle->var.tx_ilkn_1_bcw_dpi_map[tx_ilkn_bcw_chnl] = DIGI_SIFD_BCW_CHANNEL_LINK;
                            }
                            digi_handle->var.rx_ilkn_1_bcw_dpi_map[rx_ilkn_bcw_chnl] = chnl_id + DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX;
                        } 
                        else
                        {
                            if (DIGI_SIFD_BCW_CHANNEL_NULL == digi_handle->var.tx_ilkn_1_bcw_dpi_map[tx_ilkn_bcw_chnl])
                            {
                                digi_handle->var.tx_ilkn_1_bcw_dpi_map[tx_ilkn_bcw_chnl] = chnl_id;
                                digi_handle->var.rx_ilkn_1_bcw_dpi_map[rx_ilkn_bcw_chnl] = chnl_id;
                            }
                            else 
                            {
                                result = DIGI_ERR_TX_BCW_CHANNEL_ID_AMBIGUOUS;
                            }
                        }
                        ilkn_index = 0;
                    }
                    /* ILKN 2 BCW to DPI Channel Mapping Table channel configuration */     
                    else if (digi_sifd_ilkn_inst == DIGI_SIFD_ILKN2)
                    {
                        if (target == DIGI_ILKN_CHNL_TARGET_ODUK)
                        {
                            if (DIGI_SIFD_BCW_CHANNEL_NULL == digi_handle->var.tx_ilkn_2_bcw_dpi_map[tx_ilkn_bcw_chnl])
                            {
                                digi_handle->var.tx_ilkn_2_bcw_dpi_map[tx_ilkn_bcw_chnl] = chnl_id + DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX;
                            }
                            else
                            {
                                digi_handle->var.tx_ilkn_2_bcw_dpi_map[tx_ilkn_bcw_chnl] = DIGI_SIFD_BCW_CHANNEL_LINK;
                            }
                            digi_handle->var.rx_ilkn_2_bcw_dpi_map[rx_ilkn_bcw_chnl] = chnl_id + DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX;
                        }
                        else 
                        {
                            if (DIGI_SIFD_BCW_CHANNEL_NULL == digi_handle->var.tx_ilkn_2_bcw_dpi_map[tx_ilkn_bcw_chnl])
                            {
                                digi_handle->var.tx_ilkn_2_bcw_dpi_map[tx_ilkn_bcw_chnl] = chnl_id;
                                digi_handle->var.rx_ilkn_2_bcw_dpi_map[rx_ilkn_bcw_chnl] = chnl_id;
                            }
                            else 
                            {
                                result = DIGI_ERR_TX_BCW_CHANNEL_ID_AMBIGUOUS;
                            }
                        }
                        ilkn_index = 1;
                    }
                    /*
                     * Set the BCW channel bit to 1 indicating it is
                     * assigned. The outer index is the ILKN 1 or 2,
                     * the inner index is one of the 8 channel values
                     * and the result of the modulo arithmetic is the
                     * bit being set.
                     */
                    digi_handle->var.rx_bcw_chnl_id_assigned[ilkn_index][rx_ilkn_bcw_chnl/DIGI_WORD_BIT_SIZE] |= 1 << (rx_ilkn_bcw_chnl % DIGI_WORD_BIT_SIZE);

                }
            } 
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_ilkn_chnl_cfg */

/*******************************************************************************
* digi_ilkn_chnl_uncfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*     This function releases an ILKN channel handle and the channel data 
*     associated with the channel handle.  The channel must be deprovisoned with 
*     digi_ilkn_cpb_chnl_deprov() or digi_ilkn_oduksw_chnl_deprov() prior to 
*     calling this API.\n\n
*
*     It allows for an ILKN channel to be migrated between ODUKSW and CPB 
*     interfaces.  Once the channel data is released, digi_ilkn_chnl_cfg() may 
*     be called to reuse these properties.\n\n
*
*     It is critical that the Fabric Egress not send data on the ILKN channel 
*     associated with the channel handle while digi_ilkn_chnl_uncfg() and 
*     digi_ilkn_chnl_cfg() are called.  Failure to do so may lead to corruption 
*     of data on other operational channels.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   **chnl_ctxt_pptr       - pointer to a pointer of a digi_ilkn_chnl_t
*                            structure consisting of a channel data this is
*                            unconfigured.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - when API execution is successful otherwise a descriptive
*                 error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_chnl_uncfg(digi_handle_t          *digi_handle,
                                      digi_ilkn_chnl_t      **chnl_ctxt_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_ilkn_chnl_def_t *chnl_data_ptr;
    digi_ilkn_chnl_def_t *tmp_chnl_ptr;
    digi_ilkn_link_t *ilkn_link_ptr = NULL;
    digi_sifd_ilkn_inst_t sifd_ilkn_inst;
    UINT32                  tx_ilkn_bcw_chnl;
    UINT32                  rx_ilkn_bcw_chnl;
    UINT32 ilkn_index   = 0;
    UINT32 i            = 0;
    UINT32 bcw_chnl_cnt = 0;
    UINT8  chnl_id      = 0;
    coreotn_odu_chnl_prov_mode_t prov_mode = COREOTN_ODU_CHNL_PROV_IN_INCREMENT;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(chnl_ctxt_pptr != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    /* Check that given handles belong to digi handle */
    DIGI_ILKN_CHNL_HANDLE_CHECK(digi_handle, *chnl_ctxt_pptr, result);

    /* check that DIGI device is initialized */
    if(FALSE == digi_device_init_status_get(digi_handle))
    {
        result = DIGI_ERR_DEVICE_NOT_INIT;
    }

    /* cast input pointer */
    chnl_data_ptr = (digi_ilkn_chnl_def_t*)*chnl_ctxt_pptr;
    
    DIGI_CHNL_HANDLE_MAGIC_CHECK(chnl_data_ptr);
                   
    /* Check that the channel is only in CONFIG state */     
    /* check that is not unconfigured */
    if (chnl_data_ptr->switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) 
    {
        result = DIGI_ERR_ILKN_CHNL_UNCONFIG;
    }   
    /* check that is not provisioned */
    if (TRUE == util_global_rx_or_tx_chnl_prov_status_get(chnl_data_ptr->switch_data.header.prov_state))
    {
        result = DIGI_ERR_ILKN_CHNL_ALREADY_PROV;
    }

    /* remove ILKN channel entries in ILKN TX and RX flow control calendar */
    if (PMC_SUCCESS == result)
    {
        result = digi_sifd_fc_calendar_chnl_entries_remove(digi_handle,
                                                           chnl_data_ptr);
    }

    /* Retrieve ILKN instance ID associated to channel */
    if (PMC_SUCCESS == result)
    {
        result =  digi_ilkn_inst_get(chnl_data_ptr, &sifd_ilkn_inst);
    }

    /* retrieve ILKN link assocaited to channel */
    if (PMC_SUCCESS == result)
    {
        ilkn_link_ptr = (digi_ilkn_link_t *)&digi_handle->handle_pool.ilkn_link[(UINT32)sifd_ilkn_inst];
    }

    /* cleanup channel context */
    if (PMC_SUCCESS == result)
    {
        /* get ODU channel provisioning mode */
        result = coreotn_odu_chnl_prov_mode_get(digi_handle->coreotn_handle, &prov_mode);
                                                   
        if (PMC_SUCCESS == result && (COREOTN_ODU_CHNL_PROV_ALL == prov_mode || COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK == prov_mode))
        {
            tx_ilkn_bcw_chnl = chnl_data_ptr->tx_ilkn_info.ilkn_bcw_chnl;
            rx_ilkn_bcw_chnl = chnl_data_ptr->rx_ilkn_info.ilkn_bcw_chnl;
            /* flag to denote deferred unconfig */
            chnl_data_ptr->target = LAST_DIGI_ILKN_CHNL_TARGET;
            chnl_data_ptr->rate = 0;
        }
        else
        {
            chnl_data_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;
            tx_ilkn_bcw_chnl = chnl_data_ptr->tx_ilkn_info.ilkn_bcw_chnl;
            rx_ilkn_bcw_chnl = chnl_data_ptr->rx_ilkn_info.ilkn_bcw_chnl;
            chnl_data_ptr->switch_data.oduk_data.port_type = LAST_UTIL_GLOBAL_ODUK_PORT;
            chnl_data_ptr->switch_data.cpb_data.port_type = LAST_UTIL_GLOBAL_CPB_PORT;
            
            /* Should have been set in initialization, but keep idempotent  */
            chnl_data_ptr->switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;        
            chnl_data_ptr->switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
            chnl_data_ptr->switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_NOT_USED;
            
            chnl_data_ptr->switch_data.cpb_data.data_source = 0;
            
            /* Initialize the following for mapping purposes */
            chnl_data_ptr->switch_data.cpb_data.op_state.map_state.input_map_count = 0;
            chnl_data_ptr->switch_data.cpb_data.op_state.map_state.is_input_mapped = FALSE;
            chnl_data_ptr->switch_data.cpb_data.op_state.map_state.is_output_mapped = FALSE;
            chnl_data_ptr->switch_data.cpb_data.op_state.active_state = UTIL_GLOBAL_CHNL_ACTIVE_STATE_INACTIVE;
            chnl_data_ptr->switch_data.oduk_data.op_state.map_state.input_map_count = 0;
            chnl_data_ptr->switch_data.oduk_data.op_state.map_state.is_input_mapped = FALSE;
            chnl_data_ptr->switch_data.oduk_data.op_state.map_state.is_output_mapped = FALSE;
            chnl_data_ptr->switch_data.oduk_data.op_state.active_state = UTIL_GLOBAL_CHNL_ACTIVE_STATE_INACTIVE;
            chnl_data_ptr->target = LAST_DIGI_ILKN_CHNL_TARGET;
            chnl_data_ptr->rate = 0;
            chnl_data_ptr->rx_fc_reach_extend = FALSE;
        }
        /*
         * Set the BCW channel bit to 1 indicating it is
         * assigned. The outer index is the ILKN 1 or 2,
         * the inner index is one of the 8 channel values
         * and the result of the modulo arithmetic is the
         * bit being set.
         */ /* ILKN 1 BCW to DPI Channel Mapping Table channel configuration */     
        if (sifd_ilkn_inst == DIGI_SIFD_ILKN1)
        {
            if (DIGI_SIFD_BCW_CHANNEL_LINK == digi_handle->var.tx_ilkn_1_bcw_dpi_map[tx_ilkn_bcw_chnl])
            {
                bcw_chnl_cnt = 0;
                for (i = 0; i < DIGI_SIFD_ILKN_ARB_DPI_CHANS_MAX; i++)
                {
                    tmp_chnl_ptr = &digi_handle->handle_pool.ilkn_1_chnl[i];
                    if ( (UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG == tmp_chnl_ptr->switch_data.header.prov_state) &&
                         (tx_ilkn_bcw_chnl                   == tmp_chnl_ptr->tx_ilkn_info.ilkn_bcw_chnl) )
                    {
                        bcw_chnl_cnt++;
                        if (DIGI_ILKN_CHNL_TARGET_ODUK == tmp_chnl_ptr->target)
                        {
                            chnl_id = tmp_chnl_ptr->switch_data.oduk_data.channel + DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX;
                        }
                        if (DIGI_ILKN_CHNL_TARGET_CPB == tmp_chnl_ptr->target)
                        {
                            chnl_id = tmp_chnl_ptr->switch_data.cpb_data.channel;
                        }
                    }
                }
                if (bcw_chnl_cnt > 1)
                {
                    digi_handle->var.tx_ilkn_1_bcw_dpi_map[tx_ilkn_bcw_chnl] = DIGI_SIFD_BCW_CHANNEL_LINK;
                }
                else if (bcw_chnl_cnt == 1)
                {
                    digi_handle->var.tx_ilkn_1_bcw_dpi_map[tx_ilkn_bcw_chnl] = chnl_id;
                }
            }
            else
            {
                digi_handle->var.tx_ilkn_1_bcw_dpi_map[tx_ilkn_bcw_chnl] = DIGI_SIFD_ILKN_NULL_CAL_ENTRY;
            }
            digi_handle->var.rx_ilkn_1_bcw_dpi_map[rx_ilkn_bcw_chnl] = DIGI_SIFD_ILKN_NULL_CAL_ENTRY;

            ilkn_index = 0;
        }
        /* ILKN 2 BCW to DPI Channel Mapping Table channel configuration */     
        else if (sifd_ilkn_inst == DIGI_SIFD_ILKN2)
        {
            if (DIGI_SIFD_BCW_CHANNEL_LINK == digi_handle->var.tx_ilkn_2_bcw_dpi_map[tx_ilkn_bcw_chnl])
            {
                bcw_chnl_cnt = 0;
                for (i = 0; i < DIGI_SIFD_ILKN_ARB_DPI_CHANS_MAX; i++)
                {
                    tmp_chnl_ptr = &digi_handle->handle_pool.ilkn_2_chnl[i];
                    if ( (UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG == tmp_chnl_ptr->switch_data.header.prov_state) &&
                         (tx_ilkn_bcw_chnl                   == tmp_chnl_ptr->tx_ilkn_info.ilkn_bcw_chnl) )
                    {
                        bcw_chnl_cnt++;
                        if (DIGI_ILKN_CHNL_TARGET_ODUK == tmp_chnl_ptr->target)
                        {
                            chnl_id = tmp_chnl_ptr->switch_data.oduk_data.channel + DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX;
                        }
                        if (DIGI_ILKN_CHNL_TARGET_CPB == tmp_chnl_ptr->target)
                        {
                            chnl_id = tmp_chnl_ptr->switch_data.cpb_data.channel;
                        }
                    }
                }
                if (bcw_chnl_cnt > 1)
                {
                    digi_handle->var.tx_ilkn_2_bcw_dpi_map[tx_ilkn_bcw_chnl] = DIGI_SIFD_BCW_CHANNEL_LINK;
                }
                else if (bcw_chnl_cnt == 1)
                {
                    digi_handle->var.tx_ilkn_2_bcw_dpi_map[tx_ilkn_bcw_chnl] = chnl_id;
                }
            }
            else
            {
                digi_handle->var.tx_ilkn_2_bcw_dpi_map[tx_ilkn_bcw_chnl] = DIGI_SIFD_ILKN_NULL_CAL_ENTRY;
            }
            digi_handle->var.rx_ilkn_2_bcw_dpi_map[rx_ilkn_bcw_chnl] = DIGI_SIFD_ILKN_NULL_CAL_ENTRY;

            ilkn_index = 1;
        }
        digi_handle->var.rx_bcw_chnl_id_assigned[ilkn_index][rx_ilkn_bcw_chnl/DIGI_WORD_BIT_SIZE] = ~(~digi_handle->var.rx_bcw_chnl_id_assigned[ilkn_index][rx_ilkn_bcw_chnl/DIGI_WORD_BIT_SIZE] | (1 << (rx_ilkn_bcw_chnl % DIGI_WORD_BIT_SIZE)));
        
        *chnl_ctxt_pptr = NULL;
    }

    PMC_ATOMIC_RETURN(digi_handle,result);

} /* digi_ilkn_chnl_uncfg */

/*******************************************************************************
* digi_ilkn_chnl_cfg_lock
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This function puts both interlaken interfaces into a configurable state
*   to allow for the application of per channel level static configuration.\n\n
*
*   It is a device hardware requirement for the user to statically configure 
*   Interlaken channel and header mappings prior to the transfer of any traffic
*   across the Interlaken interface.\n\n
*
*   To achieve this, the following API sequence must be followed:\n
*   1) call digi_ilkn_chnl_cfg_lock() to enable static channel configuration\n
*   2) call digi_ilkn_chnl_cfg() for each channel that will be used for the
*      lifetime of operation of the device instance
*   3) call digi_ilkn_chnl_cfg_unlock() to return the interfaces to an
*      operational state \n\n
*
*   During this configuration, the Interlaken backplane interface state will be
*   down, ICW (idle control words) will not be generated by the device and flow
*   control will not be operational.
*   
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_chnl_cfg_lock(digi_handle_t *digi_handle)
{
    /*PMC_ERROR result = DIGI_ERR_UNKNOWN;*/
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    result = digi_ilkn_chnl_cfg_lock_internal(digi_handle);
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_ilkn_chnl_cfg_lock */

/*******************************************************************************
* digi_ilkn_chnl_cfg_unlock
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This function puts both interlaken interfaces into an opertational state
*   following the application of per channel level static configuration.\n\n
*
*   See digi_ilkn_chnl_cfg_lock() API description for details of usage.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_chnl_cfg_unlock(digi_handle_t *digi_handle)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    if (digi_handle == NULL) {

        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);

    } else {

        if (DIGI_SIFD_PATH_ILKN_1 == digi_handle->var.sifd_1_major_mode)
        {
            result = sifd_ilkn_enable(digi_handle->sifd_handle,
                                      (sifd_ilkn_inst_t)digi_handle->handle_pool.ilkn_link[DIGI_SIFD_ILKN1].ilkn_inst,
                                      SIFD_ILKN_ENABLE);
        }

        if (result == PMC_SUCCESS) {
            if (DIGI_SIFD_PATH_ILKN_2 == digi_handle->var.sifd_2_major_mode)
            {
                result = sifd_ilkn_enable(digi_handle->sifd_handle,
                                          (sifd_ilkn_inst_t)digi_handle->handle_pool.ilkn_link[DIGI_SIFD_ILKN2].ilkn_inst,
                                          SIFD_ILKN_ENABLE);
            }
        }

        if (result == PMC_SUCCESS) {
            digi_handle->var.is_ilkn_enabled = TRUE;
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_ilkn_chnl_cfg_unlock */

/*******************************************************************************
* digi_ilkn_chnl_cfg_rx_reset
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This function controls the IL_RX_SOFT reset field.  This field controls the
*   receive activation state of an ILKN instance.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *ilkn_intf_handle      - pointer to ILKN Interface handle instance.
*   enable                 - TRUE: Receive ILKN out of reset \n
*                            FALSE: Receive ILKN in reset
*
* OUTPUTS:
*   None.
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_chnl_cfg_rx_reset(digi_handle_t *digi_handle, 
                                             digi_ilkn_link_t *ilkn_intf_handle,
                                             BOOL enable)
{
    sifd_ilkn_en_t cfg_value;
    digi_sifd_ilkn_inst_t ilkn_inst;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    if (digi_handle == NULL) {

        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);

    } else {

        ilkn_inst = digi_sifd_inst_get(digi_handle, ilkn_intf_handle);

        cfg_value = enable == TRUE ? SIFD_ILKN_ENABLE:SIFD_ILKN_DISABLE;

        result = sifd_ilkn_rx_enable(digi_handle->sifd_handle,
                                     (sifd_ilkn_inst_t)ilkn_inst,
                                     cfg_value);
        if (result == PMC_SUCCESS) {
            digi_handle->var.is_ilkn_enabled = TRUE;
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_ilkn_chnl_cfg_rx_reset */


/*******************************************************************************
* digi_m1_rate_monitor_cfg_set           
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  Configure DIGI_M1 rate monitor to enable ethernet line timing mode.\n
*
*  Ethernet Line Timing is where a transmit data stream is timed with the clock from \n
*  any active receive data stream in the system or the PTP clock. An extra \n
*  rate monitoring block (PMM) is used to  measure the selected receive data \n
*  stream or PTP clock. The output rate modulation control signal (ckctl) is \n
*  then used by the ACB of any/all of the LINE and SYSTEM SERDES to control \n
*  the transmit rate.
*
*  This function is configuring communal resources required to enable \n
*  line timing on an ethernet channels. digi_enet_tx_timing_mode_set be used \n
*  to enable line timing mode. The rate monitor cannot be disabled when there \n
*  are active ethernet channels that use it.
*
*  Depending on the PMM reference clock source, we assume proper has been\n
*  properly setup. For DIGI_M1_PMM_LITE_CL K_REF_PTP, we enable the PTP DCSU.\n
*  For PGMRCLKx, digi_pgmrclk_div_cfg API  shall be used to properly configure \n
*  the clock.
*
* INPUTS:
*   *digi_handle   - pointer to DIGI handle instance
*   ref_clk_src    - The PMM reference clock source
*   ref_clk_freq   - The clock frequency of the specicied clock source.\n
*                    This value is specified in Hz and shall be within the\n
*                     125E6 to 152.52E6 range.
*   enable         - TRUE: enable rate monitor\n
*                    FALSE : disbale rate monitor
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_m1_rate_monitor_cfg_set(digi_handle_t *digi_handle,
                                              digi_m1_pmm_lite_clk_ref_t ref_clk_src,
                                              DOUBLE ref_clk_freq,
                                              BOOL8 enable)
{
    PMC_ERROR rc = PMC_SUCCESS;
    UINT32 itr;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* check handles */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(LAST_DIGI_M1_PMM_LITE_CLK_REF_CLK > ref_clk_src, DIGI_ERR_INVALID_ARG, 0, 0);

    if ( DIGI_M1_PTP_CLK_MIN > ref_clk_freq || DIGI_M1_PTP_CLK_MAX < ref_clk_freq)
    {
        rc = DIGI_ERR_INVALID_ARG;
    }
    /* check if there is any active LINKs that use line timing mode*/
    for (itr = 0;itr < DIGI_ENET_LINE_CHNL_MAX && PMC_SUCCESS == rc; itr++)
    {
        if (digi_handle->handle_pool.enet_line_chnl[itr].timing_mode == DIGI_ENET_TX_LINE_TIMING_MODE) 
        {
            rc = DIGI_ERR_ACTIVE_ENET_LINE_TIMING_LINK;
        }        
    }
    for (itr = 0;itr < DIGI_ENET_SYS_CHNL_MAX && PMC_SUCCESS == rc; itr++)
    {
        if (digi_handle->handle_pool.enet_sys_chnl[itr].timing_mode == DIGI_ENET_TX_LINE_TIMING_MODE) 
        {
            rc = DIGI_ERR_ACTIVE_ENET_LINE_TIMING_LINK;
        }        
    }
   
    if (PMC_SUCCESS == rc)
    {
        if (TRUE == enable)
        {
            /* define configuration */
            digi_handle->var.digi_m1_ctxt.pmm_lite_pkt_period = DIGI_M1_PMM_PACKET_PERIOD;
            digi_handle->var.digi_m1_ctxt.pmm_lite_pkt_size = 
                (UINT32) PMC_ROUND(((DOUBLE) digi_handle->var.digi_m1_ctxt.pmm_lite_pkt_period * ref_clk_freq)/UTIL_GLOBAL_REF_FREQ );    
            digi_handle->var.digi_m1_ctxt.pmm_lite_dsm_denom = 
                (UINT32) PMC_ROUND(UTIL_GLOBAL_REF_FREQ/ (2*UTIL_OPSA_PI*digi_handle->var.digi_m1_ctxt.pmm_lite_pkt_period*DIGI_M1_PMM_FC));
            digi_handle->var.digi_m1_ctxt.pmm_lite_ref_clk_freq = ref_clk_freq;
            digi_handle->var.digi_m1_ctxt.pmm_lite_ref_clk_src = ref_clk_src;
            if (ref_clk_src == DIGI_M1_PMM_LITE_CLK_REF_PTP)
            {
                /* bring up the DCSU */
                digi_dcsu_conditional_init(digi_handle, DIGI_DCSU_INST_PTP);
            }
            /* configure DIGI_M1 */
        } else 
        {               
            if (ref_clk_src == DIGI_M1_PMM_LITE_CLK_REF_PTP)
            {
                digi_dcsu_conditional_uninit (digi_handle,DIGI_DCSU_INST_PTP);
            }        
        }
        /* configure DIGI_M1*/
        digi_m1_pmm_ptp_cfg(digi_handle,enable);
        
        /* set that it is now configured */
        digi_handle->var.digi_m1_ctxt.is_pmm_lite_configured = enable;
    }

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /* digi_m1_rate_monitor_cfg_set */

/*******************************************************************************
* digi_m1_rate_monitor_cfg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  Get the configuration of the DIGI_M1 rate monitor.
*
* INPUTS:
*   *digi_handle   - pointer to DIGI handle instance
*
* OUTPUTS:
*   ref_clk_src    - The PMM reference clock source. Only valid when enable is TRUE.
*   ref_clk_freq   - The clock frequency of the specicied clock source.\n
*                    This value is specified in Hz and shall be within the\n
*                     125E6 to 152.52E6 range.\n
*                    Only valid when enable is TRUE.
*   enable         - TRUE: rate monitor is enabled\n
*                    FALSE : rate monitor is disabled
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_m1_rate_monitor_cfg_get(digi_handle_t *digi_handle,
                                              digi_m1_pmm_lite_clk_ref_t *ref_clk_src,
                                              DOUBLE *ref_clk_freq,
                                              BOOL8 *enable)
{
    PMC_ERROR rc = PMC_SUCCESS;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check handles */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    *enable       = digi_handle->var.digi_m1_ctxt.is_pmm_lite_configured;
    *ref_clk_src  = digi_handle->var.digi_m1_ctxt.pmm_lite_ref_clk_src;
    *ref_clk_freq = digi_handle->var.digi_m1_ctxt.pmm_lite_ref_clk_freq;

    PMC_ATOMIC_RETURN(digi_handle,rc);
} /*  digi_m1_rate_monitor_cfg_get */

/*******************************************************************************
* digi_serdes_m1_rate_monitor_drop_prov           
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  Configure a LINE_S16 or SYS_S16 Serdes pin to reproduce the DIGI_M1 rate 
*  monitor output.\n\n
*
*  An unused Serdes Pin must be selected.  The LINE_S16 or SYS_S16 pin will be 
*  rejected if is is assigned to a cage or Serdes Port Tx Reference clock.  
*  A SYS_S16 pin will also be rejected if it is assigned for processing ILKN 
*  backplane interface.\n\n
*
*  The Serdes pin must be powered for this functionality to work.  The generated
*  output clock will be transferred to the Serdes pin and may optionally be brought
*  out to a PGMRCLK interface pin with API digi_pgmrclk_div_cfg().\n\n
*
*  A Serdes Port handle is output from the API for usage with the 
*  digi_serdes_m1_rate_monitor_drop_deprov().\n\n
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   identifier             - Unique user assigned value for identifying
*                            serdes port.  The value 0xFFFFFFFF
*                            DIGI_SERDES_UNASSIGNED is reserved as the
*                            default unassigned setting.
*   intf                   - enum, defining the serdes interface the port
*                            is associated with.  Must be LINE_S16 or SYS_S16.
*   pin                    - The pin index on which the LOS is carried.
*                            Valid values are any pin within SYS_LOS[11:0] or 
*                            LINE_LOS[11:0] bus interfaces.
*
* OUTPUTS:
*   output_clk_freq_ptr - output clock frequency in Hz
*   port_ctxt_pptr      - serdes port handle
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_serdes_m1_rate_monitor_drop_prov(digi_handle_t *digi_handle, 
                                                       UINT32 identifier,
                                                       digi_serdes_intf_t intf, 
                                                       UINT8 pin, 
                                                       DOUBLE *output_clk_freq_ptr,
                                                       digi_serdes_port_t **port_ctxt_pptr)
{
    digi_serdes_port_def_t *port_def_ptr = NULL;
    UINT32 module_lane[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
    UINT8 gb_count;
    PMC_ERROR result = PMC_SUCCESS;
    UINT8 cage_pin_count;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* verify that the intf is SYS_S16 or LINE_S16 */
    /* verify the serdes pin is free for usage */

    PMC_ASSERT(pin < 12, DIGI_ERR_CODE_ASSERT, 0, 0);
    module_lane[pin] = 0x0;

    if (digi_is_port_uid_unique(digi_handle, identifier) == FALSE) 
    {
        result = DIGI_ERR_SERDES_PORT_ALREADY_PROV;
    }

    if(result == PMC_SUCCESS)
    {
        switch(intf)
        {
        case DIGI_SERDES_LINE_INTF:
            result = digi_line_lane_validate_and_count(digi_handle,
                                                       module_lane,
                                                       module_lane,
                                                       DIGI_SERDES_PORT_NO_LOS_SOURCE,
                                                       NULL,
                                                       &gb_count,
                                                       &cage_pin_count);
            if(result == DIGI_ERR_SERDES_NO_CAGE_PROV) result = PMC_SUCCESS;
            break;
        case DIGI_SERDES_SYSTEM_INTF:
            /* confirm no SYS_S16 assigned to backplane interface */
            if(((digi_handle->var.sifd_ilkn_1_cfg.lane.blk_to_N1_enable_mask & 0xFFFF) & (1 << pin))||
               (((digi_handle->var.sifd_ilkn_2_cfg.lane.blk_to_N1_enable_mask & 0xFF) << 8) & (1 << pin)))
            {
                result = DIGI_ERR_SERDES_SYS_PIN_ALREADY_PROV;
            }
            /* confirm no cage assigned to S16 Serdes */
            result = digi_sys_lane_validate_and_count(digi_handle,
                                                      module_lane,
                                                      module_lane,
                                                      DIGI_SERDES_PORT_NO_LOS_SOURCE,
                                                      NULL,
                                                      &gb_count,
                                                      &cage_pin_count);
            if(result == DIGI_ERR_SERDES_NO_CAGE_PROV) result = PMC_SUCCESS;

            break;
        default:
            result = DIGI_ERR_INVALID_ARG;
            break;
        }

    }

    /* set Serdes Context for this pin, the pin will be treated as 
       a stand alone transmit clock */
    if(PMC_SUCCESS == result)
    {
        port_def_ptr = digi_port_ctxt_find(digi_handle,
                                           DIGI_SERDES_UNASSIGNED,
                                           intf);
        if (port_def_ptr == NULL) 
        {
            result = DIGI_ERR_SERDES_ALL_PORTS_PROV;
        }
        else
        {
            port_def_ptr->master_lane = pin;
            port_def_ptr->port_uid = identifier;
            port_def_ptr->intf = intf;
            port_def_ptr->los_pin = DIGI_SERDES_PORT_NO_LOS_SOURCE;
            port_def_ptr->s16_clk_cfg.pin_index = DIGI_SERDES_PIN_NOT_USED;

            if(intf == DIGI_SERDES_LINE_INTF)
            {
                digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[pin].port_uid = identifier;
            }
            else
            {
                digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[pin].port_uid = identifier;
            }

            *port_ctxt_pptr = (digi_serdes_port_t*)port_def_ptr;
        }
    }

    /* enable pattern generation on the serdes port */
    if (PMC_SUCCESS == result)
    {
        util_serdes_patt_gen_cfg_t patt_gen_cfg;
        s16_port_mode_t s16_port_mode = S16_PORT_MODE_10G312;
        digi_serdes_s16_clk_patt_gen_cfg_get(digi_handle, TRUE, DIGI_S16_CLK_DIVIDER_64, &patt_gen_cfg);
        if(intf == DIGI_SERDES_LINE_INTF)
        {
            result = s16_patt_gen_cfg(digi_handle->s16_line_handle, pin, s16_port_mode, &patt_gen_cfg);                    
        }
        else
        {
            result = s16_patt_gen_cfg(digi_handle->s16_sys_handle, pin, s16_port_mode, &patt_gen_cfg);
        }
    }

    /* configure the serdes pin for 10.3125E9 rate */
    if(PMC_SUCCESS == result)
    {
        result = digi_serdes_port_prov(digi_handle,
                                       (digi_serdes_port_t*)port_def_ptr,
                                       DIGI_SERDES_PORT_MODE_S16_10_GE);
    }

    /* configure the S16 ACB source to be DIGI_M1 PMM_LITE */
    if(PMC_SUCCESS == result)
    {
        digi_enet_client_chnl_def_t dummy_pc;
        digi_enet_client_chnl_def_t *dummy_pc_ptr = &dummy_pc;
        digi_serdes_cfg_action_t serdes_cfg_action = DIGI_SERDES_PROV;
        UINT32 i;

        dummy_pc.switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_ENET_LINE;
        dummy_pc.serdes_mode = DIGI_SERDES_PORT_MODE_S16_10_GE;
        
        for(i=0; i<2 && result==PMC_SUCCESS; i++)
        {
            if(i==1) serdes_cfg_action = DIGI_SERDES_ACTIVATE;
            switch(intf) {
    
            case DIGI_SERDES_LINE_INTF:
                result = digi_non_otn_acb_ckctl_line_cfg(digi_handle,
                                                         (util_global_switch_data_t*)dummy_pc_ptr,
                                                         (util_global_switch_data_t*)dummy_pc_ptr,
                                                         serdes_cfg_action,
                                                         DIGI_SERDES_ACB_MODE_C,
                                                         1,
                                                         identifier,
                                                         port_def_ptr->master_lane,
                                                         DIGI_ENET_TX_LINE_TIMING_MODE);
    
                break;
            case DIGI_SERDES_SYSTEM_INTF:
                result = digi_non_otn_acb_ckctl_sys_cfg(digi_handle,
                                                        (util_global_switch_data_t*)dummy_pc_ptr,
                                                        (util_global_switch_data_t*)dummy_pc_ptr,
                                                        serdes_cfg_action,
                                                        DIGI_SERDES_ACB_MODE_C,
                                                        1,
                                                        identifier,
                                                        port_def_ptr->master_lane,
                                                        DIGI_ENET_TX_LINE_TIMING_MODE);
                break;
            default:
                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                break;
            }
        }
    }

    if(PMC_SUCCESS == result)
    {
        *output_clk_freq_ptr = 10.3125E9/20.0;
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /*  digi_serdes_m1_rate_monitor_drop_prov */

/*******************************************************************************
* digi_serdes_m1_rate_monitor_drop_deprov           
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  Removes configuration performed by digi_serdes_m1_rate_monitor_drop_prov().\n\n
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   **port_ctxt_pptr       - serdes port handle
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_serdes_m1_rate_monitor_drop_deprov(digi_handle_t *digi_handle, 
                                                         digi_serdes_port_t **port_ctxt_pptr)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    
    if (port_ctxt_pptr == NULL) {
        result = DIGI_ERR_NULL_HANDLE;
    }
    else if (result == PMC_SUCCESS && *port_ctxt_pptr == NULL) {

        result = DIGI_ERR_NULL_HANDLE;

    }     
    if(result == PMC_SUCCESS)
    {
        result = digi_serdes_port_ctxt_validate(digi_handle, *port_ctxt_pptr); 
    }
    if (result == PMC_SUCCESS &&((digi_serdes_port_def_t*)*port_ctxt_pptr)->port_uid == DIGI_SERDES_UNASSIGNED) {
        result = DIGI_ERR_INVALID_ARG;
    } 

    /* test to confirm that this is not the extra Tx clock or the pin */
    if(result == PMC_SUCCESS)
    {
        if(((digi_serdes_port_def_t*)*port_ctxt_pptr)->s16_clk_cfg.pin_index != DIGI_SERDES_PIN_NOT_USED)
        {
            result = DIGI_ERR_INVALID_ARG;
        }
    }
    /* test to confirm this port is not associated with a Serdes cage_id */
    if(result == PMC_SUCCESS)
    {
        UINT32 i;
        switch(((digi_serdes_port_def_t*)*port_ctxt_pptr)->intf) { 
        case DIGI_SERDES_LINE_INTF:
            for(i=0; i<DIGI_SERDES_XFI_LANES_MAX && PMC_SUCCESS==result; i++)
            {
                if(digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].cage_id != DIGI_SERDES_PIN_NOT_USED &&
                   digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid == ((digi_serdes_port_def_t*)*port_ctxt_pptr)->port_uid)
                {
                    result = DIGI_ERR_INVALID_ARG;
                }
            }
            break;
        case DIGI_SERDES_SYSTEM_INTF:
            for(i=0; i<DIGI_SERDES_XFI_LANES_MAX && PMC_SUCCESS==result; i++)
            {
                if(digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].cage_id != DIGI_SERDES_PIN_NOT_USED &&
                   digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid == ((digi_serdes_port_def_t*)*port_ctxt_pptr)->port_uid)
                {
                    result = DIGI_ERR_INVALID_ARG;
                }
            }
            break;
        default:
            /* the serdes port interface is not associated with m1 rate monitor */
            result = DIGI_ERR_INVALID_ARG;
            break;
        }
    }

    /* unwind configuration performed by digi_serdes_m1_rate_monitor_drop_prov() */
    if (result == PMC_SUCCESS) {
        result = digi_serdes_port_deprov(digi_handle,
                                         port_ctxt_pptr);
    }    

    if (result == PMC_SUCCESS) {
        *port_ctxt_pptr = NULL;
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /*  digi_serdes_m1_rate_monitor_drop_deprov */

/*******************************************************************************
* digi_gsup43_7_3_legacy_mode_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  This function configures a GSUP43 7.3 datapath to use legacy UPI 
*  values.\n
*  To enable GSUP43 7.3 legacy Mode for datapaths that use ETRANS
*  (MAPOTN <-> ETRANS - EMAC <-> DCPB) call this function with 
*  data_frame_upi=0xfd and ordered_set_upi=0xfe. The mapper channel should be 
*  provisioned with DIGI_MAP_ODU2P_PKT_10_GE_7_3_GFP.\n\n
*    
*  To enable GSUP43 7.3 Legacy Mode for datapaths that use EPMM 
*  (MAPOTN <-> CPB <-> EPMM) call this function with data_frame_upi=0xfd and 
*  ordered_set_upi=0xfe. The mapper channel should be should be provisioned 
*  with DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP_ENET. The channel must be mapped
*  before calling this function (i.e. call digi_cpb_chnl_map before calling 
*  digi_gsup43_7_3_legacy_mode_cfg).\n\n
*    
*  For EPMM legacy mode, the FW consequential action configuration should 
*  include the following:\n
*  digi_client2trunk_tables_cmf_t tab;\n
*  tab.port_action_cmf.enable_monitoring = TRUE;\n
*  tab.conseq_action_cmf.enet_epmm_local_fault_mon.monitor_defect=TRUE;\n
*  tab.conseq_action_cmf.enet_epmm_local_fault_mon.action1\n
*       = INSERT_ENET_EPMM_GFP_ORDERED_SET;\n
*  tab.conseq_action_cmf.enet_epmm_local_fault_mon.priority_idx = 1;\n
*  tab.conseq_action_cmf.enet_epmm_remote_fault_mon.monitor_defect = TRUE;\n
*  tab.conseq_action_cmf.enet_epmm_remote_fault_mon.action1  \n
*     = INSERT_ENET_EPMM_GFP_ORDERED_SET;\n
*  tab.conseq_action_cmf.enet_epmm_remote_fault_mon.priority_idx = 2;\n
*
*  result = digi_cmf_clienttotrunk_conseq_action_cfg(digi_handle, \n
*       mapper_chnl_ptr, &tab);\n
*
*  result = digi_cmf_clienttotrunk_tables_update(digi_handle, \n
*           mapper_chnl_ptr);\n
*  
*  For EPMM legacy mode, to enable the LOS-> Local Fault consequential\n
*  action, FW should also be configured with:\n
*  tab.conseq_action_cmf.enet_epmm_loss_signal_mon.monitor_defect = TRUE;\n
*  tab.conseq_action_cmf.enet_epmm_loss_signal_mon.action1 \n
*       = INSERT_ENET_ING_GSUP43_C73_LF_LEGACY_MODE;\n
*  tab.conseq_action_cmf.enet_epmm_loss_signal_mon.priority_idx = 3;\n\n
*
*  result = digi_cmf_clienttotrunk_conseq_action_cfg(digi_handle,  \n
*       mapper_chnl_ptr, &tab);\n
*
*  result = digi_cmf_clienttotrunk_tables_update(digi_handle, mapper_chnl_ptr);\n
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   *channel_ptr    - MAPOTN channel handle 
*   data_frame_upi  - Data frame UPI value. Set to 0xfd for legacy mode.
*   ordered_set_upi - Ordered set UPI value. Set to 0xfe for legacy mode.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - when API execution is successful otherwise a descriptive\n
*                 error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_gsup43_7_3_legacy_mode_cfg(digi_handle_t *digi_handle,
                                                 digi_mapper_chnl_t *channel_ptr,
                                                 UINT8 data_frame_upi,
                                                 UINT8 ordered_set_upi)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_mapper_chnl_def_t *mapper_chnl_ptr= (digi_mapper_chnl_def_t *)channel_ptr;
    util_global_switch_data_t   *enet_chnl_switch_ptr = channel_ptr;
    UINT32 mapotn_chnl;
    BOOL etrans_mode = FALSE, epmm_mode = FALSE;
    BOOL std_mode = FALSE;
    UINT8 os_val = 0xff;
    UINT8 upi_sel = 0;
    digi_enet_tx_mac_fault_t mac_fault_mode = DIGI_ENET_TX_MAC_FAULT_AUTOMATIC;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check handles */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    result = digi_mapper_chnl_handle_validate(digi_handle,channel_ptr);

    /* Check if it's epmm or etrans */
    if (result == PMC_SUCCESS)
    {
        etrans_mode = (mapper_chnl_ptr->mode == DIGI_MAP_ODU2P_PKT_10_GE_7_3_GFP);
        mapotn_chnl = mapper_chnl_ptr->mapotn_chnl;

        if (!etrans_mode)
        {
            enet_chnl_switch_ptr = (util_global_switch_data_def_t*)digi_cpb_input_port_get(digi_handle, channel_ptr);

            if (enet_chnl_switch_ptr != NULL)
            {
                if (digi_enet_channel_is_GSUP43_7_3_TRANSPARENT_mode((digi_enet_client_chnl_def_t *)enet_chnl_switch_ptr))
                {
                    epmm_mode = TRUE;
                }
                else
                {
                    result =  DIGI_ERR_GSUP43_7_3_INVALID_DATAPATH;
                }
            }
            else
            {
                result = DIGI_ERR_CHNL_NOT_MAPPED;
            }
        }
    }
    
    /* Must be either etrans or epmm ... */
    if (!etrans_mode && !epmm_mode)
    {
        PMC_ATOMIC_RETURN(digi_handle, result);
    }

    std_mode = (data_frame_upi == DIGI_ENET_GSUP43_C73_PKT_TYPE && ordered_set_upi == DIGI_ENET_GSUP43_C73_OS_TYPE);

    os_val  = (std_mode ? DIGI_ENET_GSUP43_C73_OS_TYPE : 0xff);
    upi_sel = (std_mode ? TRUE : FALSE);
    mac_fault_mode = (std_mode ? DIGI_ENET_TX_MAC_FAULT_AUTOMATIC : DIGI_ENET_TX_MAC_FAULT_DISABLED);


    /* Note: for etrans - the enet_chnl_switch_ptr used below is a mapper chnl ptr */
    if (result == PMC_SUCCESS)
    {
        result = digi_enet_tx_upi_set(digi_handle, enet_chnl_switch_ptr, data_frame_upi, ordered_set_upi, FALSE);
    }
    if (result == PMC_SUCCESS && epmm_mode)
    {
        result = digi_enet_rx_upi_set(digi_handle, enet_chnl_switch_ptr, DIGI_ENET_GSUP43_C73_PKT_TYPE, os_val);
    }
    if (result == PMC_SUCCESS)
    {
        result = digi_mapper_gfp_tx_upi_set(digi_handle, channel_ptr, data_frame_upi); 
    }
    if (result == PMC_SUCCESS)
    {
        result = mapotn_tgfpf_chnl_upi_sel_set(digi_handle->mapotn_handle, mapotn_chnl, upi_sel); 
    }
    if (result == PMC_SUCCESS && etrans_mode)
    {
        result = digi_enet_tx_mac_fault_insert_ctrl(digi_handle, channel_ptr, mac_fault_mode);
    } 
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /*  digi_gsup43_7_3_legacy_mode_cfg */

/*******************************************************************************
* digi_gsup43_7_3_legacy_mode_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  This function returns TRUE if the GSUP43 7.3 datapath is configured to use
*  non-standard UPI values.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance
*   channel_ptr         - MAPOTN channel handle 
*   data_frame_upi_ptr  - Data frame UPI value. 
*   ordered_set_upi_ptr - Ordered set UPI value. 
*   enabled_ptr         - TRUE: legacy UPI mode is enabled\n
*                         FALSE: legacy UPI mode is disabled\n
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - when API execution is successful otherwise a descriptive\n
*                 error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_gsup43_7_3_legacy_mode_get(digi_handle_t *digi_handle,
                                                 digi_mapper_chnl_t *channel_ptr,
                                                 UINT8 *data_frame_upi_ptr,
                                                 UINT8 *ordered_set_upi_ptr,
                                                 BOOL8 *enabled_ptr) 
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_mapper_chnl_def_t *mapper_chnl_ptr= (digi_mapper_chnl_def_t *)channel_ptr;
    util_global_switch_data_t   *enet_chnl_switch_ptr = channel_ptr;
    util_global_switch_data_t *input_sw_ptr = NULL;
    UINT32 mapotn_chnl;
    BOOL etrans_mode = FALSE, epmm_mode = FALSE;
    BOOL8 dummy_val;
    PMC_ATOMIC_ENTRY(digi_handle);

    /* check handles */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    result = digi_mapper_chnl_handle_validate(digi_handle,channel_ptr);

    /* Check if it's epmm or etrans */
    if (result == PMC_SUCCESS)
    {
        etrans_mode = (mapper_chnl_ptr->mode == DIGI_MAP_ODU2P_PKT_10_GE_7_3_GFP);
        mapotn_chnl = mapper_chnl_ptr->mapotn_chnl;
        if (!etrans_mode)
        {
            digi_opsa_src_chnl_hndl_for_dest_get(digi_handle, channel_ptr, FALSE, &input_sw_ptr);
            enet_chnl_switch_ptr = (util_global_switch_data_def_t *)input_sw_ptr;
            if (digi_enet_channel_is_GSUP43_7_3_TRANSPARENT_mode((digi_enet_client_chnl_def_t *)enet_chnl_switch_ptr))
            {
                epmm_mode = TRUE;
            }
        }
    }
    
    /* Must be either etrans or epmm ... */
    if (!etrans_mode && !epmm_mode)
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_GSUP43_7_3_INVALID_DATAPATH);
    }

    if (result == PMC_SUCCESS)
    {
        result = digi_enet_tx_upi_get(digi_handle, enet_chnl_switch_ptr, data_frame_upi_ptr, ordered_set_upi_ptr, &dummy_val);
    }
    *enabled_ptr = ((*ordered_set_upi_ptr != DIGI_ENET_GSUP43_C73_OS_TYPE) || (*data_frame_upi_ptr != DIGI_ENET_GSUP43_C73_PKT_TYPE));
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /*  digi_gsup43_7_3_legacy_mode_get */


/*******************************************************************************
* digi_gsup43_7_3_increase_orderred_set_rate
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  This function configures a transparent GSUP43 7.3 datapath to generate a 
*  higher rate of ordered sets.  This function is only applicable to a datapath 
*  that contains a MAPOTN <-> CPB <-> ENET (EPMM) segment.
*
*  In addition to calling this function, the FW consequential action 
*  configuration should include the following:
*    digi_client2trunk_tables_cmf_t tab;\n
*    tab.port_action_cmf.enable_monitoring = TRUE;\n
*    tab.conseq_action_cmf.enet_epmm_local_fault_mon.monitor_defect = TRUE;\n
*    tab.conseq_action_cmf.enet_epmm_local_fault_mon.action1 \n
*       = INSERT_ENET_EPMM_GFP_ORDERED_SET;\n
*    tab.conseq_action_cmf.enet_epmm_local_fault_mon.priority_idx = 1;\n
*    tab.conseq_action_cmf.enet_epmm_remote_fault_mon.monitor_defect = TRUE;\n
*    tab.conseq_action_cmf.enet_epmm_remote_fault_mon.action1 \n
*       = INSERT_ENET_EPMM_GFP_ORDERED_SET;\n
*    tab.conseq_action_cmf.enet_epmm_remote_fault_mon.priority_idx= 2;\n
*    result = digi_cmf_clienttotrunk_conseq_action_cfg(digi_handle, \n
*       mapper_chnl_ptr, &tab);\n\n
*
*    result = digi_cmf_clienttotrunk_tables_update(digi_handle,\n
*       mapper_chnl_ptr);\n\n
*
* To enable the LOS-> Local Fault consequential action, the FW consequential 
*  action configuration should also include:
*    tab.conseq_action_cmf.enet_epmm_loss_signal_mon.monitor_defect = TRUE;\n
*    tab.conseq_action_cmf.enet_epmm_loss_signal_mon.action1\n
*        = INSERT_ENET_ING_GSUP43_C73_LF_HIGH_FREQ_MODE;\n
*    tab.conseq_action_cmf.enet_epmm_loss_signal_mon.priority_idx = 3;\n
*    result = digi_cmf_clienttotrunk_conseq_action_cfg(digi_handle, \n
*       mapper_chnl, &tab);\n
*
*    result = digi_cmf_clienttotrunk_tables_update(digi_handle, \n
*       mapper_chnl);\n
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   channel_ptr     - MAPOTN channel handle 
*   enable          - TRUE: enable mode\n
*                     FALSE: disable mode\n
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - when API execution is successful otherwise a descriptive\n
*                 error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_gsup43_7_3_increase_orderred_set_rate(digi_handle_t *digi_handle,
                                                            digi_mapper_chnl_t *channel_ptr,
                                                            BOOL8 enable) 
{
    PMC_ERROR result = PMC_SUCCESS;
    util_global_switch_data_def_t *enet_chnl_switch_ptr = NULL;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    result = digi_mapper_chnl_handle_validate(digi_handle,channel_ptr);

    /* Check if EPMM */
    if (result == PMC_SUCCESS)
    {
        enet_chnl_switch_ptr = (util_global_switch_data_def_t*)digi_cpb_input_port_get(digi_handle, channel_ptr);

        if (enet_chnl_switch_ptr == NULL || !digi_enet_channel_is_GSUP43_7_3_TRANSPARENT_mode((digi_enet_client_chnl_def_t *)enet_chnl_switch_ptr))
        {
            result = DIGI_ERR_GSUP43_7_3_NOT_EPMM;
        }
    }
    
    /* Configure TGFPF UPI */
    if (result == PMC_SUCCESS)
    {
        result = digi_gsup43_7_3_tgfpf_upi_set(digi_handle, channel_ptr, (enable ? DIGI_ENET_GSUP43_C73_OS_TYPE : DIGI_ENET_GSUP43_C73_PKT_TYPE), 1);
    }
    
    PMC_ATOMIC_RETURN(digi_handle,result);
} /*  digi_gsup43_7_3_increase_ordered_set_rate */

/*******************************************************************************
* digi_gsup43_7_3_increase_orderred_set_rate_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  Returns true if the transparent GSUP43 7.3 datapath is confiugred to generate 
*  a higher rate of ordered sets.  This function is only applicable to a datapath 
*  that contains a MAPOTN <-> CPB <-> ENET (EPMM) segment.
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   channel_ptr     - MAPOTN channel handle 
*   enabled_ptr     - TRUE if enabled
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - when API execution is successful otherwise a descriptive\n
*                 error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_gsup43_7_3_increase_orderred_set_rate_get(digi_handle_t *digi_handle,
                                                                digi_mapper_chnl_t *channel_ptr,
                                                                BOOL8 *enabled_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    util_global_switch_data_def_t *enet_chnl_switch_ptr = NULL;
    UINT32 upi_value = 0;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    *enabled_ptr = 0;

    result = digi_mapper_chnl_handle_validate(digi_handle,channel_ptr);

    /* Check if EPMM */
    if (result == PMC_SUCCESS)
    {
        enet_chnl_switch_ptr = (util_global_switch_data_def_t*)digi_cpb_input_port_get(digi_handle, channel_ptr);

        if (enet_chnl_switch_ptr == NULL || !digi_enet_channel_is_GSUP43_7_3_TRANSPARENT_mode((digi_enet_client_chnl_def_t *)enet_chnl_switch_ptr))
        {
            result = DIGI_ERR_GSUP43_7_3_NOT_EPMM;
        }
    }
    if (result == PMC_SUCCESS)
    {
        result = digi_mapper_gfp_tx_upi_get(digi_handle,channel_ptr, &upi_value); 
    }
    if (result == PMC_SUCCESS)
    {    
        *enabled_ptr = (upi_value == DIGI_ENET_GSUP43_C73_OS_TYPE);
    }
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_gsup43_7_3_increased_orderred_set_rate_get */

/*******************************************************************************
* digi_gsup43_7_3_tgfpf_upi_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  This function configures the TGFPF upi and upi_sel values for a GSUP43 7.3 
*  datapath. 
*
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance
*   channel_ptr     - MAPOTN channel handle 
*   upi             - TGFPF upi 
*   upi_sel         - UPI select
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - when API execution is successful otherwise a descriptive\n
*                 error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_gsup43_7_3_tgfpf_upi_set(digi_handle_t *digi_handle,
                                               digi_mapper_chnl_t *channel_ptr,
                                               UINT32 upi,
                                               UINT32 upi_sel)
{
    PMC_ERROR result = PMC_SUCCESS;
    digi_mapper_chnl_def_t *mapper_chnl_ptr= (digi_mapper_chnl_def_t *)channel_ptr;
    UINT32 mapotn_chnl;

    PMC_ATOMIC_ENTRY(digi_handle);


    /* check handles */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    result = digi_mapper_chnl_handle_validate(digi_handle,channel_ptr);

    mapotn_chnl = mapper_chnl_ptr->mapotn_chnl;
    if (result == PMC_SUCCESS)
    {
        result = digi_mapper_gfp_tx_upi_set(digi_handle, channel_ptr, upi); 
    }
    if (result == PMC_SUCCESS)
    {
        result = mapotn_tgfpf_chnl_upi_sel_set(digi_handle->mapotn_handle, mapotn_chnl, upi_sel); 
    }
    PMC_ATOMIC_RETURN(digi_handle,result);
} /*  digi_gsup43_7_3_tgfpf_upi_set */


/*******************************************************************************
* digi_cm_status_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  Retrieves the value of CM_STATUS of the CM_STAT_REG register for the
*  particular channel handle. Only FMF1, FMF2 or MAPOTN handles are valid
*  and the value is based on the specific 0-95 channel.  Error returned if
*  handle is not in range for the particular handle type, or 
*  is unprovisioned.
*
*
* INPUTS:
*  digi_handle     - pointer to DIGI handle instance.
*  chnl_hndl_ptr   - Reference to the channel handle being queried.
*
*
* OUTPUTS:
*  value_ptr       - Reference to hold the result of the register.
*
* RETURNS:
*  PMC_SUCCESS - Success
*  PMC_ERROR   - Otherwise
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cm_status_get(digi_handle_t *digi_handle,
                                    util_global_switch_data_t *chnl_hndl_ptr,
                                    UINT32 *value_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    util_global_switch_data_def_t *chnl_hndl_def_ptr = NULL;
    coreotn_fmf_inst_t fmf_instance = LAST_COREOTN_FMF_INST;

    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != value_ptr, DIGI_ERR_NULL_HANDLE, 0, 0);    

    if (NULL == chnl_hndl_ptr)
    {
        result = DIGI_ERR_NULL_HANDLE;
    }
    else if (FALSE == util_global_is_chnl_prov(chnl_hndl_ptr))
    {
        result = DIGI_ERR_STATUS_CHNL_NOT_PROV;
    }

    if (PMC_SUCCESS == result)
    {
        chnl_hndl_def_ptr = (util_global_switch_data_def_t *)chnl_hndl_ptr;
    
        switch (chnl_hndl_def_ptr->oduk_data.port_type)
        {
          case UTIL_GLOBAL_ODUK_PORT_MAPOTN:
            result = digi_mapper_chnl_handle_validate(digi_handle, 
                                                      chnl_hndl_ptr);
            break;

          case UTIL_GLOBAL_ODUK_PORT_COREOTN:
            /*
             * If this is SYSOTN and not MO ODU level then return an error
             * Else if MO ODU then set the FMF level based on whether this
             * is SYS or LINE OTN. LO order ODU is only valid for LINE in 
             * NON SYSOTN application.
             */
            if (TRUE == DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) &&
                UTIL_GLOBAL_LEVEL_MO_ODU != chnl_hndl_def_ptr->oduk_data.odu_level)
            {
                result = DIGI_ERR_INVALID_PORT_TYPE;
            }
            else if (UTIL_GLOBAL_LEVEL_MO_ODU == chnl_hndl_def_ptr->oduk_data.odu_level)
            {
                result = digi_mo_odu_struct_handle_validate(digi_handle, 
                                                            chnl_hndl_ptr);

                if (TRUE == DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
                {
                    fmf_instance = COREOTN_FMF_INST_2;
                }
                else
                {
                    fmf_instance = COREOTN_FMF_INST_1;
                }
            }
            else if (UTIL_GLOBAL_LEVEL_LO_ODU == chnl_hndl_def_ptr->oduk_data.odu_level)
            {
                result = digi_lo_odu_struct_handle_validate(digi_handle, 
                                                            chnl_hndl_ptr);
                fmf_instance = COREOTN_FMF_INST_2;
            }
            else
            {
                result = DIGI_ERR_INVALID_PORT_TYPE;
            }
            break;

        default:
          result = DIGI_ERR_INVALID_PORT_TYPE;
          break;
        }
    }

    if (PMC_SUCCESS == result)
    {
        UINT32 chnl = chnl_hndl_def_ptr->oduk_data.channel;

        if (UTIL_GLOBAL_ODUK_PORT_MAPOTN == chnl_hndl_def_ptr->oduk_data.port_type)
        {
            mapotn_cm_status_get(digi_handle->mapotn_handle,
                                 chnl,
                                 value_ptr);
        }
        else
        {
            coreotn_cm_status_get(digi_handle->coreotn_handle,
                                  fmf_instance,
                                  chnl,
                                  value_ptr);
        }
    }
 
    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_cm_status_get */


#ifndef DOXYGEN_PUBLIC_ONLY
/*******************************************************************************
* digi_mapper_src_dest_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine source/destination for mapper channel.
*
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   mode              - Enum, OPU payload mapping modes.
*   enet_pmon         - 10GE/40GE/100GE passive monitoring of CBR Ethernet
*                       signals.\n
*                       TRUE: ENET_LINE used for PMON of signal transferred
*                             transferredbetween MAPOTN and CPB\n
*                       FALSE: ENET_LINE not used\n
*   *mapper_src       - a pointer to the mapper source
*   *mapper_dest      - a pointer to the mapper destination
*
*
* OUTPUTS:

*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_mapper_src_dest_get(digi_handle_t *digi_handle,
                                     digi_mapping_mode_t mode,
                                     BOOL enet_pmon,
                                     mapotn_src_dest_t *mapper_src,
                                     mapotn_src_dest_t *mapper_dest)
{
    mapotn_src_dest_t src;
    mapotn_src_dest_t dest;

    PMC_ENTRY();

    PMC_ASSERT(mode < LAST_DIGI_MAP, DIGI_ERR_INVALID_ARG, 0, 0);

    if( DIGI_MAP_ODU4P_100_GE_GFP == mode ||
        DIGI_MAP_ODU3P_40_GE_GFP == mode ||
        DIGI_MAP_ODU2P_10_GE_6_2_GFP == mode ||
        DIGI_MAP_ODU2P_PKT_10_GE_7_3_GFP == mode ||
        DIGI_MAP_ODU3P_PKT_40_GE_GMP == mode ||
        DIGI_MAP_ODU4P_PKT_100_GE_GMP == mode || 
        DIGI_MAP_ODU1EP_PKT_10G3_7_2_BMP == mode ||
        DIGI_MAP_ODU2EP_PKT_10G3_7_1_BMP == mode )
    {
        dest = MAPOTN_DEST_ENET;
        src = MAPOTN_DEST_ENET;

    } else if (DIGI_MAP_ODU4P_100_GE_GFP_ENET == mode ||
               DIGI_MAP_ODU3P_40_GE_GFP_ENET == mode ||
               DIGI_MAP_ODU2P_10_GE_6_2_GFP_ENET == mode ||
               DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP_ENET == mode) {

        if ((DIGI60_PROD_APP_IS_TRANSMUXPONDER_SYS_CLIENT_CARD(digi_handle) || DIGI60_PROD_APP_IS_TRANSMUXPONDER_CARD(digi_handle) || DIGI_PROD_APP_IS_TRANSMUXPONDER_CARD(digi_handle))
            && (TRUE == enet_pmon)) {

            dest = MAPOTN_DEST_CPB_ENET;
            src = MAPOTN_DEST_CPB;

        } else {

            dest = MAPOTN_DEST_CPB;
            src = MAPOTN_DEST_CPB;
        }

    } else if ((DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP == mode ||
                DIGI_MAP_ODU3P_CBR_40_GE_GMP == mode ||
                DIGI_MAP_ODU4P_CBR_100_GE_GMP == mode ||
                DIGI_MAP_ODU1EP_CBR_10G3_7_2_BMP == mode ||
                DIGI_MAP_ODU2EP_CBR_10G3_7_1_BMP == mode) && TRUE == enet_pmon)
    {
        if (DIGI60_PROD_APP_IS_TRANSMUXPONDER_SYS_CLIENT_CARD(digi_handle) || DIGI60_PROD_APP_IS_TRANSMUXPONDER_CARD(digi_handle) || DIGI_PROD_APP_IS_TRANSMUXPONDER_CARD(digi_handle)) 
        {
            dest = MAPOTN_DEST_CPB_ENET;
            src = MAPOTN_DEST_CPB;
        } else {
            dest = MAPOTN_DEST_CPB;
            src = MAPOTN_DEST_CPB;
        }
    } 
    else
    {
        dest = MAPOTN_DEST_CPB;
        src = MAPOTN_DEST_CPB;
    }
    
    *mapper_src = src;
    *mapper_dest = dest;

    PMC_RETURN();
} /* digi_mapper_src_dest_get */

/*******************************************************************************
* digi_enet_mapotn_mpmo_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function tests the adaptation function type to determine if MAPOTN
*   MPMO configuration is required to match CBR data stream from ENET_LINE
*   subsystem.  Otherwise function returns successfully.
*
*   If MAPOTN ENET_LINE dependent MPMO provisioning is required, then the
*   MAPOTN MPMO will be provisioned to be compatible with the stream from
*   ENET_LINE.
*
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   chnl             - MAPOTN DCI channel
*   mode             - adaptation function of MAPOTN
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_enet_mapotn_mpmo_prov(digi_handle_t *digi_handle,
                                             UINT32 chnl,
                                             digi_mapping_mode_t mode)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 pkt_size_ptr = 48;
    UINT32 pkt_per_int_ptr = 0;
    UINT32 pkt_per_n_ptr = 0;
    UINT32 pkt_per_d_ptr = 1;

    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(mode < LAST_DIGI_MAP, DIGI_ERR_INVALID_ARG, 0, 0);


    if(DIGI_MAP_ODU1EP_PKT_10G3_7_2_BMP == mode ||
       DIGI_MAP_ODU2EP_PKT_10G3_7_1_BMP == mode ||
       DIGI_MAP_ODU3P_PKT_40_GE_GMP == mode ||
       DIGI_MAP_ODU4P_PKT_100_GE_GMP == mode)
    {
        result = mapotn_mapper_mpmo_prov(digi_handle->mapotn_handle,chnl,pkt_size_ptr,pkt_per_int_ptr,pkt_per_n_ptr,pkt_per_d_ptr,FALSE);
    }
    else
    {
        result = PMC_SUCCESS;
    }


    PMC_RETURN(result);
} /* digi_enet_mapotn_mpmo_prov */

/*******************************************************************************
* digi_enet_mapotn_mpmo_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function tests the adaptation function type to determine if MAPOTN
*   MPMO configuration is required to match CBR data stream from ENET_LINE
*   subsystem.  Otherwise function returns successfully.
*
*   If MAPOTN ENET_LINE dependent MPMO provisioning is required, then the
*   MAPOTN MPMO will be deprovisioned.
*
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   chnl             - MAPOTN DCI channel
*   mode             - adaptation function of MAPOTN
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_enet_mapotn_mpmo_deprov(digi_handle_t *digi_handle,
                                               UINT32 chnl,
                                               digi_mapping_mode_t mode)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();

    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(mode < LAST_DIGI_MAP, DIGI_ERR_INVALID_ARG, 0, 0);

    if(DIGI_MAP_ODU1EP_PKT_10G3_7_2_BMP == mode ||
       DIGI_MAP_ODU2EP_PKT_10G3_7_1_BMP == mode ||
       DIGI_MAP_ODU3P_PKT_40_GE_GMP == mode ||
       DIGI_MAP_ODU4P_PKT_100_GE_GMP == mode)
    {
        result = mapotn_mapper_mpmo_deprov(digi_handle->mapotn_handle,chnl);
    }
    else
    {
        result = PMC_SUCCESS;
    }


    PMC_RETURN(result);
} /* digi_enet_mapotn_mpmo_deprov */

/*******************************************************************************
* digi_post_mld_dsi_lane_status_count
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the number of ODU0s on a particular
*   primary group and secondary group.
*
*
* INPUTS:
*   chnl              - 96 schedule entries with the provisioned chanels.
*   lane              - The post mld dsi lane to look for the match_chnl.
*   match_chnl        - the channel to search for.\n
*
* OUTPUTS:
* 
*   *num_entries      - the number of entries matching match_chnl
*
* RETURNS:
*   None
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_post_mld_dsi_lane_status_count(UINT32 chnl[MAPOTN_NUM_CHANL],
                                                 UINT16 lane,
                                                 UINT32 match_chnl,
                                                 UINT32 *num_entries)
{
    UINT16 i = 0; /* counter */
    UINT32 sched_mask[][DIGI_NUM_ODU0S_PER_LANE_MAX] = DIGI_SCHED_MASK;
    UINT32 count = 0 /* coutner */;

    PMC_ENTRY();

    for (i = 0; i < DIGI_NUM_ODU0S_PER_LANE_MAX; i++) {

        if (chnl[sched_mask[lane][i]] == 0xFF) {

        } else if (chnl[sched_mask[lane][i]] == match_chnl) {

            count++;
        } 
    }

    *num_entries = count;

    PMC_RETURN();
} /* digi_post_mld_dsi_lane_status_count */

/*******************************************************************************
* digi_num_post_mld_lanes_required
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine the number of lanes required for a
*   given number of calendar entries.
*
* INPUTS:
*   num_entries       - the number of calendar entries required.
*
* OUTPUTS:
* 
*   *num_lanes        - the number of lanes required for the input number
*                       of calendar entries.
*
* RETURNS:
*   PMC_SUCCESS on success, DIGI_ERR_INVALID_ARG otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_num_post_mld_lanes_required(UINT32 num_entries,
                                                   UINT16 *num_lanes)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    if (num_entries <= DIGI_NUM_CAL_ENTRIES_IN_10G) {

        *num_lanes = DIGI_NUM_DSI_LANES_IN_10G;

    } else if  (num_entries <= DIGI_NUM_CAL_ENTRIES_IN_20G) {

        *num_lanes = DIGI_NUM_DSI_LANES_IN_20G;

    } else if  (num_entries <= DIGI_NUM_CAL_ENTRIES_IN_30G) {

        *num_lanes = DIGI_NUM_DSI_LANES_IN_30G;

    } else if  (num_entries <= DIGI_NUM_CAL_ENTRIES_IN_40G) {

        *num_lanes = DIGI_NUM_DSI_LANES_IN_40G;

    } else if  (num_entries <= DIGI_NUM_CAL_ENTRIES_IN_50G) {

        *num_lanes = DIGI_NUM_DSI_LANES_IN_50G;

    } else if  (num_entries <= DIGI_NUM_CAL_ENTRIES_IN_60G) {

        *num_lanes = DIGI_NUM_DSI_LANES_IN_60G;

    } else if  (num_entries <= DIGI_NUM_CAL_ENTRIES_IN_70G) {

        *num_lanes = DIGI_NUM_DSI_LANES_IN_70G;

    } else if  (num_entries <= DIGI_NUM_CAL_ENTRIES_IN_80G) {

        *num_lanes = DIGI_NUM_DSI_LANES_IN_80G;

    } else if  (num_entries <= DIGI_NUM_CAL_ENTRIES_IN_90G) {

        *num_lanes = DIGI_NUM_DSI_LANES_IN_90G;

    } else if  (num_entries <= DIGI_NUM_CAL_ENTRIES_IN_100G) {

        *num_lanes = DIGI_NUM_DSI_LANES_IN_100G;

    } else {

        result = DIGI_ERR_INVALID_ARG;
    }

    PMC_RETURN(result);
} /* digi_num_post_mld_lanes_required */

/*******************************************************************************
* digi_determine_resource_available
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine if there is enough space to 
*   accomodate the number of ODU0s in the mapper.
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*   p_group           - Enum, Primary group to determine resource availability
*   s_group           - Enum, Secondary group to determine resource availability
*   post_mld_index    - the post mld index of the lane we are starting at
*                       to examine for potential available resources. 
*   num_cal_entries   - the number of calendar entries (ODU0s) required.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_determine_resource_available(digi_handle_t *digi_handle,
                                                    digi_mapper_primary_group_t p_group,
                                                    digi_mapper_secondary_group_t s_group, 
                                                    UINT16 post_mld_index, 
                                                    UINT32 num_cal_entries)
{
    PMC_ERROR result = DIGI_ERR_UNKNOWN;

    UINT16 num_lanes = 0;
    UINT16 i = 0; /* counter */
    UINT32 avail_odus = 0;
    digi_post_mld_dsi_ctxt_t* post_mld_ctxt_ptr;
    UINT16 num_lanes_max = 0; 

    PMC_ENTRY();

    result = digi_num_post_mld_lanes_required(num_cal_entries, &num_lanes);
    PMC_ASSERT(result == PMC_SUCCESS,result,0,0);

    /* The first three cases ensure that we don't try to provision anything
       in a trivially malicious manner */
    if ((num_lanes == DIGI_NUM_DSI_LANES_IN_100G) && (post_mld_index != 0)) {

        /* INSUFFICIENT resources */
        result = DIGI_ERR_ODU0_INSUFFICIENT_RESOURCES_AVAILABLE;

    } else if ((num_lanes == DIGI_NUM_DSI_LANES_IN_40G) && 
               ((post_mld_index == 1) || (post_mld_index == 2) || (post_mld_index == 3) ||
                (post_mld_index == 5) || (post_mld_index == 6) || (post_mld_index == 7) ||
                (post_mld_index == 9) || (post_mld_index == 10) || (post_mld_index == 11))) {

        /* INSUFFICIENT resources */
        result = DIGI_ERR_ODU0_INSUFFICIENT_RESOURCES_AVAILABLE;

    } else {

        post_mld_ctxt_ptr = &digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[0];

        if ((p_group == DIGI_MAPPER_PRIMARY_GROUP_DONT_CARE) && 
            (s_group == DIGI_MAPPER_SECONDARY_GROUP_DONT_CARE) && 
            (post_mld_index == 0)) 
        {
            num_lanes_max = DIGI_SERDES_DSI_LANES_MAX;
        }
        else if (p_group != DIGI_MAPPER_PRIMARY_GROUP_DONT_CARE && num_lanes <= DIGI_NUM_DSI_LANES_IN_40G)
        {
            /* If a particular primary group is specified then check for available time slots within that group */
            switch(p_group) 
            {
            case  DIGI_MAPPER_PRIMARY_GROUP_0: num_lanes_max =     DIGI_NUM_DSI_LANES_IN_40G; break;
            case  DIGI_MAPPER_PRIMARY_GROUP_1: num_lanes_max = 2 * DIGI_NUM_DSI_LANES_IN_40G; break;
            case  DIGI_MAPPER_PRIMARY_GROUP_2: num_lanes_max = 3 * DIGI_NUM_DSI_LANES_IN_40G; break;
            default: PMC_ASSERT(TRUE,DIGI_ERR_INVALID_ARG, 0,0);
            }
        } 
        else if ((post_mld_index + num_lanes) <= DIGI_SERDES_DSI_LANES_MAX) 
        {
            num_lanes_max = post_mld_index + num_lanes;
        } 
        else 
        {
            num_lanes_max = 0;
            result = DIGI_ERR_ODU0_INSUFFICIENT_RESOURCES_AVAILABLE;
        }

        if(PMC_SUCCESS == result)
        {
            /* Go from current lane to number of lanes you need.
             * Check for available ODU0 slots. */
            for (i = post_mld_index; i < num_lanes_max; i++) 
            {
                avail_odus = avail_odus + (DIGI_NUM_ODU0S_PER_LANE_MAX - (post_mld_ctxt_ptr[i].num_odu0));
            }
    
            if (avail_odus < num_cal_entries) 
            {
                /* INSUFFICIENT resources */
                result = DIGI_ERR_ODU0_INSUFFICIENT_RESOURCES_AVAILABLE;
    
            } 
            else {
                result = PMC_SUCCESS;
            }
        }
    }

    PMC_RETURN(result);
} /* digi_determine_resource_available */

/*******************************************************************************
* digi_num_odus_and_map_type_prov_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to set the number of odu0s used and the map_type
*   on each post mld_dsi_lane on provisioning.
*
* INPUTS:
*   *digi_handle      - a pointer to the digi_handle_t
*   post_mld_index    - The starting post_mld_index to start the provising
*                       from.
*   num_cal_entries   - The number of calendar entries required.
*   enet_pmon         - TRUE if enet_pmon is requiredk, FALSE otherwise.
*   mapotn_dest       - The destination of where MAPOTN is going.
*                       See mapotn_src_dest_t for more information.
*
* OUTPUTS:
*   NONE.
* 
* RETURNS:
*   NONE
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_num_odus_and_map_type_prov_set(digi_handle_t *digi_handle,
                                                 UINT16 post_mld_index, 
                                                 UINT32 num_cal_entries,
                                                 BOOL enet_pmon,
                                                 mapotn_src_dest_t mapotn_dest)
{
    PMC_ERROR result = DIGI_ERR_UNKNOWN;

    UINT32 avail_odus = 0;
    UINT16 i = 0; /*counter */
    UINT16 num_odus = 0;

    digi_post_mld_dsi_ctxt_t* post_mld_ctxt_ptr;

    digi_mapper_alloc_t map_type = DIGI_MAPPER_ALLOC_UNUSED;
    digi_mapper_alloc_t new_map_type = DIGI_MAPPER_ALLOC_UNUSED;

    PMC_ENTRY();

    post_mld_ctxt_ptr = &(digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[0]);

    /* We assume that the inputs are valid at this point */
    for (i = post_mld_index; i < DIGI_SERDES_DSI_LANES_MAX; i++) {

        if (post_mld_ctxt_ptr[i].num_odu0 == 0) {

            result = digi_by_mld_index_post_mld_map_type_get(digi_handle, i, &map_type);

            result |= digi_mapotn_prov_new_mapper_state_get(map_type, enet_pmon, mapotn_dest, &new_map_type);

            result |= digi_by_mld_index_post_mld_map_type_set(digi_handle, i, UTIL_GLOBAL_CPB_PORT_ENET_LINE, new_map_type);
            PMC_ASSERT(result == PMC_SUCCESS,result,0,0);
        } 

        avail_odus = DIGI_NUM_ODU0S_PER_LANE_MAX - (post_mld_ctxt_ptr[i].num_odu0);

        if (num_cal_entries > avail_odus) {

            num_odus = DIGI_NUM_ODU0S_PER_LANE_MAX;
            num_cal_entries = num_cal_entries - avail_odus;
        } else {

            num_odus = DIGI_NUM_ODU0S_PER_LANE_MAX - (avail_odus - num_cal_entries);
            num_cal_entries = 0;
            result = PMC_SUCCESS;
        }

        result = digi_by_mld_index_num_odus_set(digi_handle, i, num_odus);
        PMC_ASSERT(result == PMC_SUCCESS,result,0,0);

        if (num_cal_entries == 0)
        {
            result = PMC_SUCCESS;
            break;
        }
    }

    if (result != PMC_SUCCESS) {
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    PMC_RETURN();
} /* digi_num_odus_and_map_type_prov_set */

/*******************************************************************************
* digi_num_odus_and_map_type_deprov_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to set the number of odu0s used and the map_type
*   on each post mld_dsi_lane on de-provisioning.
*
* INPUTS:
*   *digi_handle      - a pointer to the digi_handle_t
*   port_type         - The type of port. See util_golbal_cpb_port_t for more
*                       information.
*   map_chnl          - the map channel required to perform a reverse look up
*
* OUTPUTS:
*   NONE.
* 
* RETURNS:
*   NONE.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_num_odus_and_map_type_deprov_set(digi_handle_t *digi_handle,
                                                  util_global_cpb_port_t port_type,
                                                  UINT32 map_chnl)
{
    UINT32 chnl[DIGI_SCHD_96_ENTRY];
    UINT8 i = 0; /* counter */
    UINT32 num_odus = 0;
    UINT32 num_entries = 0;

    digi_mapper_alloc_t map_type = DIGI_MAPPER_ALLOC_UNUSED;
    digi_mapper_alloc_t new_map_type = DIGI_MAPPER_ALLOC_UNUSED;

    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    result = mapotn_db_entry_all_get(digi_handle->mapotn_handle, chnl);

    for (i = 0; i < DIGI_SERDES_DSI_LANES_MAX && result == PMC_SUCCESS; i++) {

        digi_post_mld_dsi_lane_status_count(chnl,
                                            i,
                                            map_chnl,
                                            &num_entries);
        if (num_entries > 0) {

            if (digi_by_mld_index_num_odus_get(digi_handle,
                                               i,
                                               &num_odus) != PMC_SUCCESS) {
                break;
            } else {

                if (num_entries > num_odus) {
                    num_odus = 0;
                } else {
                    num_odus = num_odus - num_entries;
                }

                if (digi_by_mld_index_num_odus_set(digi_handle,
                                                   i,
                                                   num_odus) != PMC_SUCCESS) 
                {
                    break;
                }
            }

            /* Only change the map type if nothing is mapped any more */
            if (num_odus == 0) 
            {
             
                result = digi_by_mld_index_post_mld_map_type_get(digi_handle,
                                                                 i,
                                                                 &map_type);
                if(PMC_SUCCESS == result)
                {
                    if (DIGI_MAPPER_ALLOC_UNUSED != map_type)
                    {
                        result = digi_mapotn_deprov_new_mapper_state_get(map_type, 
                                                                         port_type,
                                                                         &new_map_type);

                        if(PMC_SUCCESS == result)
                        {
                            result = digi_by_mld_index_post_mld_map_type_set(digi_handle,
                                                                             i,
                                                                             port_type,
                                                                             new_map_type);
                        }
                    }
                }
            }
        }
    }


    if (i < DIGI_SERDES_DSI_LANES_MAX) { 
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, i, 0);
    }

    PMC_ASSERT(result==PMC_SUCCESS, DIGI_ERR_CODE_ASSERT, 0, 0);

    PMC_RETURN();

} /* digi_num_odus_and_map_type_deprov_set */

/*******************************************************************************
* digi_num_odus_and_map_type_etrans_deprov_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to set the number of odu0s used and the map_type
*   on each post mld_dsi_lane on de-provisioning.
*
*   The usage of this API is specific to ETRANS channels
*
* INPUTS:
*   *digi_handle      - a pointer to the digi_handle_t
*   port_type         - The type of port. See util_golbal_cpb_port_t for more
*                       information.
*   enet_chnl         - the enet channel required to perform a reverse look up
*
* OUTPUTS:
*   NONE.
* 
* RETURNS:
*   NONE.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_num_odus_and_map_type_etrans_deprov_set(digi_handle_t *digi_handle,
                                                         util_global_cpb_port_t port_type,
                                                         UINT32 enet_chnl)
{
    UINT32 chnl[DIGI_SCHD_96_ENTRY];
    UINT8 i = 0; /* counter */
    UINT32 num_odus = 0;
    UINT32 num_entries = 0;

    digi_mapper_alloc_t map_type = DIGI_MAPPER_ALLOC_UNUSED;
    digi_mapper_alloc_t new_map_type = DIGI_MAPPER_ALLOC_UNUSED;

    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();


    result = enet_db_entry_all_get(digi_handle->enet_line_handle, chnl);

    for (i = 0; i < DIGI_SERDES_DSI_LANES_MAX && result == PMC_SUCCESS; i++) {

        digi_post_mld_dsi_lane_status_count(chnl,
                                            i,
                                            enet_chnl,
                                            &num_entries);
        if (num_entries > 0) {

            if (digi_by_mld_index_num_odus_get(digi_handle,
                                               i,
                                               &num_odus) != PMC_SUCCESS) {
                break;
            } else {

                if (num_entries > num_odus) {
                    num_odus = 0;
                } else {
                    num_odus = num_odus - num_entries;
                }

                if (digi_by_mld_index_num_odus_set(digi_handle,
                                                   i,
                                                   num_odus) != PMC_SUCCESS) {
                    break;
                }
            }

            /* Only change the map type if nothing is mapped any more */
            if (num_odus == 0) 
            {                
                result = digi_by_mld_index_post_mld_map_type_get(digi_handle,
                                                                 i,
                                                                 &map_type);
                if(PMC_SUCCESS == result)
                {
                    if (DIGI_MAPPER_ALLOC_UNUSED != map_type)
                    {
                        result = digi_mapotn_deprov_new_mapper_state_get(map_type, 
                                                                         port_type,
                                                                         &new_map_type);
                        
                        if(PMC_SUCCESS == result)
                        {
                            result = digi_by_mld_index_post_mld_map_type_set(digi_handle,
                                                                             i,
                                                                             port_type,
                                                                             new_map_type);
                        }
                    }
                }
            }
        }
    }


    if (i < DIGI_SERDES_DSI_LANES_MAX) { 
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, i, 0);
    }

    PMC_ASSERT(result==PMC_SUCCESS, DIGI_ERR_CODE_ASSERT, 0, 0);

    PMC_RETURN();

} /* digi_num_odus_and_map_type_etrans_deprov_set */

/*******************************************************************************
* digi_serdes_port_lifd_sifd_mux_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function configures the LIFD and or SIFD mux in order to provide
*   mapping between Post Mux DSI Lanes and Transmit/Receive Serdes Pins. \n\n
*
*  The API processes internal pin context to identify the required mapping.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_def_ptr          - Serdes port pointer for which LIFD and or SIFD 
*                            muxing to be configured
*   subsystem_type         - Enum, defining the subsystem that the serdes
*                            port is to be routed to.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_serdes_port_lifd_sifd_mux_cfg(digi_handle_t *digi_handle,
                                                    digi_serdes_port_def_t *port_def_ptr,
                                                    xifd_dsis_type_t subsystem_type) 
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    UINT32 i;
    UINT32 j;

    PMC_ENTRY();

    /* CFP application is a special case where system ports are routed to line side */
    if( (port_def_ptr->init == 1) &&
        (port_def_ptr->port_uid != DIGI_SERDES_UNASSIGNED) &&
        DIGI_PROD_APP_GET(digi_handle) == DIGI_PROD_APP_100G_3_X_40G_CFP_CARD && 
        port_def_ptr->intf == DIGI_SERDES_SYSTEM_INTF)
    {
        /* Route all the serdes XFI to the line side */
        for(i = DIGI_SERDES_XFI_LANES_MAX, j= 0; i< DIGI_SERDES_DSIS_LANES_MAX; i++, j++) 
        {
            if (digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[j].port_uid == port_def_ptr->port_uid)
            {                
                sifd_line_side_route_configure(digi_handle->sifd_handle,
                                               i,
                                               TRUE);
            }
        }
        rc = digi_serdes_lifd_xfi_configure(digi_handle, port_def_ptr, subsystem_type);        
    }
    /* if the port is valid */
    else if( (port_def_ptr->init == 1) &&
             (port_def_ptr->port_uid != DIGI_SERDES_UNASSIGNED))
    {
        /* handle each interface type seperately */
        switch(port_def_ptr->intf)
        {
        case DIGI_SERDES_LINE_INTF:
            rc = digi_serdes_lifd_xfi_configure(digi_handle, port_def_ptr, subsystem_type);
            break;
        case DIGI_SERDES_SYSTEM_INTF:
            rc = digi_serdes_sifd_configure(digi_handle, port_def_ptr, subsystem_type);
            break;            
        case DIGI_SERDES_SFI_51_INTF:
            rc = digi_serdes_lifd_sfi51_configure(digi_handle, port_def_ptr, subsystem_type);
            break;
        default:
            rc = DIGI_ERR_INVALID_ARG;
            break;
        } /* end switch */

    } /* end if port init == 1 */

    PMC_RETURN(rc);
} /* digi_serdes_port_lifd_sifd_mux_cfg */

/*******************************************************************************
* digi_serdes_port_lifd_mux_align_rx_tx_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function configures the LIFD mux in order to provide
*   mapping between Post Mux DSI Lanes and Transmit/Receive Serdes Pins. \n\n
*   This function configures the post-mld lanes such as there a symetric meaning
*   RX lanes == TX lanes to allow DIAGNOSTIC loopback.
*
*  The API processes internal pin context to identify the required mapping.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_def_ptr          - Serdes port pointer for which LIFD and or SIFD 
*                            muxing to be configured
*   subsystem_type         - Enum, defining the subsystem that the serdes
*                            port is to be routed to.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_serdes_port_lifd_mux_align_rx_tx_cfg(digi_handle_t *digi_handle,
                                                                digi_serdes_port_def_t *port_def_ptr,
                                                                xifd_dsis_type_t subsystem_type) 
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;
    UINT32 i;
    UINT32 j;

    PMC_ENTRY();

    /* CFP application is a special case where system ports are routed to line side */
    if( (port_def_ptr->init == 1) &&
        (port_def_ptr->port_uid != DIGI_SERDES_UNASSIGNED) &&
        DIGI_PROD_APP_GET(digi_handle) == DIGI_PROD_APP_100G_3_X_40G_CFP_CARD && 
        port_def_ptr->intf == DIGI_SERDES_SYSTEM_INTF)
    {
        /* Route all the serdes XFI to the line side */
        for(i = DIGI_SERDES_XFI_LANES_MAX, j= 0; i< DIGI_SERDES_DSIS_LANES_MAX; i++, j++) 
        {
            if (digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[j].port_uid == port_def_ptr->port_uid)
            {                
                sifd_line_side_route_configure(digi_handle->sifd_handle,
                                               i,
                                               TRUE);
            }
        }
        rc = digi_serdes_lifd_xfi_align_tx_rx_configure(digi_handle, port_def_ptr, subsystem_type);        
    }
    /* if the port is valid */
    else if( (port_def_ptr->init == 1) &&
             (port_def_ptr->port_uid != DIGI_SERDES_UNASSIGNED))
    {
        /* handle each interface type seperately */
        switch(port_def_ptr->intf)
        {
        case DIGI_SERDES_LINE_INTF:
            rc = digi_serdes_lifd_xfi_align_tx_rx_configure(digi_handle, port_def_ptr, subsystem_type);
            break;
        default:
            rc = DIGI_ERR_INVALID_ARG;
            break;
        } /* end switch */

    } /* end if port init == 1 */

    PMC_RETURN(rc);
} /* digi_serdes_port_lifd_mux_align_rx_tx_cfg */

/*******************************************************************************
* digi_serdes_port_lifd_sifd_mux_pin_los_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function configures the LIFD and or SIFD mux in order to provide
*   mapping between Post Mux DSI Lanes and Transmit/Receive Serdes Pins. \n\n
*
*  The API processes internal pin context to identify the required mapping.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *port_def_ptr          - Serdes port pointer for which LIFD and or SIFD 
*                            muxing to be configured
*   enable                 - enable or disable.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_serdes_port_lifd_sifd_mux_pin_los_cfg(digi_handle_t            *digi_handle,
                                                            digi_serdes_port_def_t   *port_def_ptr,
                                                            BOOL8                    enable) 
{
    PMC_ERROR rc = DIGI_ERR_UNKNOWN;

    PMC_ENTRY();

    /* if the port is valid */
    if( (port_def_ptr->init == 1) &&
        (port_def_ptr->port_uid != DIGI_SERDES_UNASSIGNED))
    {
        /* handle each interface type seperately */
        switch(port_def_ptr->intf)
        {
        case DIGI_SERDES_LINE_INTF:
            rc = digi_serdes_lifd_xfi_pin_los_cfg(digi_handle, port_def_ptr, enable);
            break;
        case DIGI_SERDES_SYSTEM_INTF:
            if (digi_handle->var.prod_app != DIGI_PROD_APP_100G_3_X_40G_CFP_CARD)
            {
                rc = digi_serdes_sifd_pin_los_cfg(digi_handle, port_def_ptr, enable);
            }
            else
            {
                rc = digi_serdes_lifd_xfi_pin_los_cfg(digi_handle, port_def_ptr, enable);
            } 
            break;             
        case DIGI_SERDES_SFI_51_INTF:
            rc = digi_serdes_lifd_sfi51_pin_los_cfg(digi_handle, port_def_ptr, enable);
            break;
        default:
            rc = DIGI_ERR_INVALID_ARG;
            break;
        } /* end switch */

    } /* end if port init == 1 */

    PMC_RETURN(rc);
} /* digi_serdes_port_lifd_sifd_mux_pin_los_cfg */

/*******************************************************************************
* digi_cpb_internal_chnl_map
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper used by both digi_cpb_chnl_map and 
*   digi_enet_enhanced_pmon_map.  It does the bulk of the work for cpb chnl 
*   mapping.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *input_pc_ptr    - util_global_switch_data_t pointer defining inbound port
*   *output_pc_ptr   - util_global_switch_data_t pointer defining outbound port
*   rate_data        - enum, client stream types of signal passing through CPB.
*                      For DIGI_CPB_STREAM_PKT_GFPF_ODUFLEX, client_num_odu0 
*                      must be provided
*   client_num_odu0  - For DIGI_CPB_STREAM_PKT_GFPF_ODUFLEX, number of ODU0 
*                      container associated with ODUFLEX signal.
*   halt_buffer      - CPB FIFO buffer room to capture in flight data in
*                      the event that CPB FIFO generates an upstream flow
*                      control signal.  Used in cases where ENET utilizes
*                      pause flow control and where a channel is fed from
*                      SIFD and asserts XOFF flow control.  halt_buffer is
*                      specified in units of blocks.  The block size in bytes 
*                      per unit is: 12288 bytes.
*                      Applicable to client_data containing:
*                      "DIGI_CPB_STREAM_PKT_"
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_internal_chnl_map(digi_handle_t *digi_handle,
                                            util_global_switch_data_t *input_pc_ptr,
                                            util_global_switch_data_t *output_pc_ptr,
                                            digi_cpb_stream_t rate_data,
                                            UINT32 client_num_odu0,
                                            UINT32 halt_buffer)
{
    UINT32 rate = 0, cpb_data = 0; /* cpb_data : 0 CBR, 1 packet */
    util_schd_chnl_rate_exp_t rate_unit = UTIL_SCHD_1_BIT_SEC;
    UINT32 ingress_mux_output_port = 4, egress_mux_input_port = 4; /* initialize to illegal values */
    cpb_handle_t *cpb_handle;
    UINT32 num_push_ports = 1, num_pop_ports = 1; /* number of push/pop port choices*/
    BOOL port_state = FALSE;
    digi_sifd_xfer_mode_t xfer_mode = (digi_sifd_xfer_mode_t)0;
    digi_sifd_ilkn_inst_t sifd_ilkn_inst = LAST_DIGI_SIFD_ILKN;
    UINT32 dcs_mode = 1;
    UINT32 data_dest, dummy;
    digi_ilkn_chnl_def_t *chnl_data_ptr = NULL;
    BOOL tx_type_header, rx_type_header;
    UINT32 sop_hole_size;
    BOOL enet_mirror_mode = FALSE;

    util_global_switch_data_def_t *input_pc_data_ptr = NULL;
    util_global_switch_data_def_t *output_pc_data_ptr = NULL;

    util_global_cpb_port_data_t *local_input_pc_ptr = NULL;
    util_global_cpb_port_data_t *local_output_pc_ptr = NULL;
    /*
     * If this is an enet line or sys output_pc_ptr that is not used in a
     * MAPOTN channel handle, is not an enet mirror resource then check
     * the LF OS_INSERT_ENE
     */
    BOOL8 enet_lf_force_check = FALSE;

    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* Check arguments */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_ASSERT(NULL != digi_handle->dcpb_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    PMC_ASSERT(NULL != input_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(NULL != output_pc_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    cpb_handle = digi_handle->dcpb_handle;

    input_pc_data_ptr = (util_global_switch_data_def_t *)input_pc_ptr;
    output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;

    DIGI_CHNL_HANDLE_MAGIC_CHECK(input_pc_data_ptr);
    DIGI_CHNL_HANDLE_MAGIC_CHECK(output_pc_data_ptr);

    local_input_pc_ptr = &(input_pc_data_ptr->cpb_data);
    local_output_pc_ptr = &(output_pc_data_ptr->cpb_data);

    PMC_ASSERT(local_input_pc_ptr->port_type < UTIL_GLOBAL_CPB_PORT_NOT_USED, DIGI_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(local_output_pc_ptr->port_type < UTIL_GLOBAL_CPB_PORT_NOT_USED, DIGI_ERR_INVALID_ARG, 0, 0);

    /* check the input chnl id is within the range */
    result = cpb_chnl_range_check( cpb_handle,
                                   local_input_pc_ptr->port_type,
                                   local_input_pc_ptr->channel,
                                   local_output_pc_ptr->port_type,
                                   local_output_pc_ptr->channel);

    if (result == PMC_SUCCESS) 
    {

        result = digi_cpb_prov_and_map_state_check(digi_handle,
                                                   input_pc_data_ptr, 
                                                   output_pc_data_ptr);
    }

    if (result == PMC_SUCCESS) 
    {
        result = digi_cpb_test_unsupported_mappings(digi_handle, 
                                                    local_input_pc_ptr,
                                                    local_output_pc_ptr);
    }
    if (result == PMC_SUCCESS)
    {
        result = digi_cpb_test_rate_compatibility(digi_handle,
                                                  input_pc_ptr,
                                                  output_pc_ptr,
                                                  rate_data,
                                                  client_num_odu0,
                                                  halt_buffer);
    }

    if(result==PMC_SUCCESS) {

        /* print log info*/
        PMC_LOG_TRACE("\n DIGI CPB channel mapping ... ");
        PMC_LOG_TRACE("\ninput port: %u \
                \ninput chnl: %u    \
                \noutput port: %u               \
                \noutput chnl: %u \n",
                      local_input_pc_ptr->port_type,
                      local_input_pc_ptr->channel,
                      local_output_pc_ptr->port_type,
                      local_output_pc_ptr->channel);

        if(local_output_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE){
            data_dest = (enet_is_link_mapotn_test(digi_handle->enet_line_handle, local_output_pc_ptr->channel, &dummy) == TRUE) ? 1:0;
        } else {
            data_dest = 0;
        }

        /* determine the ingress_mux_output_port, and egress_mux_input_port, function will return
           error if the requested port mapping is invalid */
        result = digi_cpb_push_pop_port_get( digi_handle,
                                             local_input_pc_ptr->port_type,
                                             local_output_pc_ptr->port_type,
                                             local_input_pc_ptr->data_source,
                                             data_dest,
                                             &ingress_mux_output_port,
                                             &num_push_ports,
                                             &egress_mux_input_port,
                                             &num_pop_ports );

        /* Check if the output is an enet line mirror port. If it is, change the egress_input_port to 3. */
        enet_mirror_mode = digi_cpb_enet_mirror_chk(digi_handle, output_pc_ptr);
        if (enet_mirror_mode)
        {
            egress_mux_input_port = DIGI_SCHD_MAPPER_DCS_INSTANCE; 
            PMC_LOG_TRACE("Enet line mirror mode - egress_mux_input_port = %d\n", egress_mux_input_port);
        }
        else if (0 == data_dest && 
                 (UTIL_GLOBAL_CPB_PORT_ENET_LINE == local_output_pc_ptr->port_type ||
                  UTIL_GLOBAL_CPB_PORT_ENET_SYS == local_output_pc_ptr->port_type))
          
          {
            /*
             * If the output_pc_ptr that is being mapped is not an enet
             * mirror port, is not used in a MAPOTN channel handle, and
             * is enet_line or enet_sys then local fault force may be in
             * play which will be checked at the end of this funciton.
             */
            enet_lf_force_check = TRUE;
        }
    }


    if(result==PMC_SUCCESS)
    {
        result = digi_cpb_rate_get(rate_data, client_num_odu0, &rate, &rate_unit, &cpb_data);
    }

    if(result==PMC_SUCCESS)
    {
        /* determine state of the CPB SS and if in lowpwr/reset state transition to a configurable state */
        digi_dcpb_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RUNNING);
    }


    if(result==PMC_SUCCESS)
    {
        /*test if the CPB input port and output port has been initialized, if not initialized, initialized
          the port first.
          Note: SIFD1 and SIFD2 ports are initialized as part of digi_sifd_config() called from
          digi_device_init() 
          Note: These ports will be left initialized:
          Scenario 1: SIFD interface present, for the life of the device till digi_device_restart() called
          Scenario 2: No SIFD interface present, till all channels are deprovisioned through CPB then
          entire CPB SS put in reset, disabling these ports */

        port_state = cpb_port_init_state_get( cpb_handle, CPB_PORT_TYPE_DPI_SLAVE, local_input_pc_ptr->port_type);
        if(FALSE == port_state)
        {
            if(UTIL_GLOBAL_CPB_PORT_ENET_SYS == local_input_pc_ptr->port_type || 
               (UTIL_GLOBAL_CPB_PORT_CBRC == local_input_pc_ptr->port_type && 
                DIGI_CBRC_IS_SYS_INTF(digi_handle)))
            {
                result = cpb_dcpb_ingress_mux_output_init( cpb_handle, ingress_mux_output_port, CPB_DCPB_IGR_SIFD_SEL_CBRC_ENET);                    
            }
            result = digi_cpb_input_port_init( digi_handle, 0, local_input_pc_ptr->port_type,(cpb_xfer_mode_t)0,0);
        }
    }

    if(result==PMC_SUCCESS)
    {
        port_state = cpb_port_init_state_get( cpb_handle, CPB_PORT_TYPE_DPI_MASTER, local_output_pc_ptr->port_type);
        if(FALSE == port_state)
        {
            result = digi_cpb_output_port_init( digi_handle, 0, local_output_pc_ptr->port_type, xfer_mode,(cpb_dcs_instance_mode_t)1);
        }
    }

    if(result==PMC_SUCCESS)
    {
        /* test if the DCS instance has been initialized or not, if not initialize DCS */
        port_state = cpb_port_init_state_get( cpb_handle, CPB_PORT_TYPE_DCS, egress_mux_input_port);
        if(FALSE == port_state)
        {
            result = cpb_egress_mux_input_init( cpb_handle, egress_mux_input_port,
                                                (cpb_xfer_mode_t)xfer_mode, (cpb_dcs_instance_mode_t)dcs_mode );
        }
    }

    /* check that ILKN1 or 2 channel rate is valid */
    if (result == PMC_SUCCESS) 
    {
        if(local_output_pc_ptr->port_type==UTIL_GLOBAL_CPB_PORT_ILKN1 || 
           local_output_pc_ptr->port_type==UTIL_GLOBAL_CPB_PORT_ILKN2)
        {  
            digi_ilkn_chnl_def_t *ilkn_chnl_data_ptr;
            ilkn_chnl_data_ptr =  (digi_ilkn_chnl_def_t*) output_pc_ptr;
            if (0 == ilkn_chnl_data_ptr->rate)
            {
                result = DIGI_ERR_SCHD_RESOURCE_NOT_AVAILABLE;
            }
        }
    }

    if (result == PMC_SUCCESS) {

        /* if interlaken input port set hdr_en fields of cpb_chnl_prov*/ 
        if ((local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN1) || 
            (local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN2))
        {
            switch(local_input_pc_ptr->port_type)
            {
            case UTIL_GLOBAL_CPB_PORT_ILKN1:
                sifd_ilkn_inst = DIGI_SIFD_ILKN1;
                break;
            case UTIL_GLOBAL_CPB_PORT_ILKN2:
                sifd_ilkn_inst = DIGI_SIFD_ILKN2;
                break;
            default:
                PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
                break;
            }

            chnl_data_ptr = digi_ilkn_cpb_chnl_handle_get(digi_handle, sifd_ilkn_inst, local_input_pc_ptr->channel);

            if(chnl_data_ptr != NULL)
            {
                rx_type_header = chnl_data_ptr->rx_type_header;

                if(local_output_pc_ptr->port_type==UTIL_GLOBAL_CPB_PORT_MAPOTN)
                {
                    if(digi_handle->handle_pool.mapper_chnl[local_output_pc_ptr->channel].mode == DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP)
                    {
                        if(rx_type_header != 1)
                        {
                            result = DIGI_ERR_SIFD_INCOMPATIBLE_HEADER_TYPE;
                        }
                        rx_type_header = 0;
                    }
                }
                else if(local_output_pc_ptr->port_type==UTIL_GLOBAL_CPB_PORT_ILKN1 || local_output_pc_ptr->port_type==UTIL_GLOBAL_CPB_PORT_ILKN2)
                {                  
                    /* Loopback */
                    rx_type_header = 0;
                    sifd_type_en_cfg(digi_handle->sifd_handle, 
                                     (sifd_ilkn_inst_t)sifd_ilkn_inst,
                                     0,
                                     0);
                }
            }
            else
            {
                result = PMC_ERR_FAIL;
            }        
        } else {
            rx_type_header = 1;
        }
    }
    

    if(result==PMC_SUCCESS)
    {
        /* provision the mapping between source and destination channel */
        result = cpb_chnl_prov(cpb_handle,
                               local_input_pc_ptr->port_type,
                               local_input_pc_ptr->channel,
                               ingress_mux_output_port, 
                               egress_mux_input_port,
                               local_output_pc_ptr->port_type,
                               local_output_pc_ptr->channel,
                               rate,
                               rate_unit,
                               cpb_data,
                               halt_buffer,
                               rx_type_header,
                               FALSE);
        PMC_ATOMIC_YIELD(digi_handle,0);
    }

    if(PMC_SUCCESS == result &&
       UTIL_GLOBAL_CPB_PORT_ENET_LINE == local_output_pc_ptr->port_type &&
       (DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT == digi_handle->handle_pool.enet_line_chnl[local_output_pc_ptr->channel].mode ||
        DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT_RX_PMON == digi_handle->handle_pool.enet_line_chnl[local_output_pc_ptr->channel].mode))
    {
        result = cpb_dpi_mstr_port_chnl_zone_0_1_zone_1_2_thresh_cfg(cpb_handle,
                                                                     local_output_pc_ptr->port_type,
                                                                     local_output_pc_ptr->channel,
                                                                     0,
                                                                     0);
    }

    if(result==PMC_SUCCESS)
    {
        /* perform Interlaken DPI master port SOP_HOLE_SIZE configuration if required for TYPE header */
        if(local_output_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN1 || local_output_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN2)
        {
            switch(local_output_pc_ptr->port_type)
            {
            case UTIL_GLOBAL_CPB_PORT_ILKN1:
                sifd_ilkn_inst = DIGI_SIFD_ILKN1;
                break;
            case UTIL_GLOBAL_CPB_PORT_ILKN2:
                sifd_ilkn_inst = DIGI_SIFD_ILKN2;
                break;
            default:
                PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
                break;
            }
    
            chnl_data_ptr = digi_ilkn_cpb_chnl_handle_get(digi_handle, sifd_ilkn_inst, local_output_pc_ptr->channel);

            if(chnl_data_ptr != NULL)
            {
                tx_type_header = chnl_data_ptr->tx_type_header;
                sop_hole_size = (tx_type_header==1)? 4:0;
    
                if(local_input_pc_ptr->port_type==UTIL_GLOBAL_CPB_PORT_ILKN1 || local_input_pc_ptr->port_type==UTIL_GLOBAL_CPB_PORT_ILKN2)
                {
                    /* Loopback */
                    sop_hole_size = 0;
                }
    
    
                result = cpb_chnl_hole_inst_head_cfg(digi_handle->dcpb_handle,
                                                     local_output_pc_ptr->port_type,
                                                     local_output_pc_ptr->channel,
                                                     sop_hole_size);
            }
            else
            {
                result = PMC_ERR_FAIL;
            }
        }
    }

    /* provision MPMO if required as part of the datapath */   
    if(result==PMC_SUCCESS)
    {
        result = digi_cpb_mpmo_prov(digi_handle, 
                                    local_input_pc_ptr->port_type, 
                                    local_input_pc_ptr->channel, 
                                    local_output_pc_ptr->port_type, 
                                    local_output_pc_ptr->channel);    
    
    }

    if (PMC_SUCCESS == result)
    {
        if (local_input_pc_ptr->port_type==UTIL_GLOBAL_CPB_PORT_MAPOTN &&
            FALSE == ((digi_mapper_chnl_def_t *)input_pc_ptr)->switch_data.oduk_data.op_state.map_state.is_output_mapped)
        {
            result =  digi_map_opu_csf_int_cfg(digi_handle, (digi_mapper_chnl_def_t *)input_pc_ptr, local_output_pc_ptr->channel, TRUE);
        }
    }
    if (PMC_SUCCESS == result && TRUE == enet_lf_force_check)
    {
        result = digi_enet_lf_force_set(digi_handle,
                                        (digi_enet_client_chnl_def_t *)output_pc_ptr,
                                        TRUE, TRUE);
    }

    if (result==PMC_SUCCESS) 
    {

        local_input_pc_ptr->op_state.map_state.input_map_count++;
        local_input_pc_ptr->op_state.map_state.is_input_mapped = TRUE;
        local_output_pc_ptr->op_state.map_state.is_output_mapped = TRUE;
    }     

    PMC_RETURN(result);
} /* digi_cpb_internal_chnl_map */

/*******************************************************************************
* digi_cpb_internal_chnl_demap
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper used by both digi_cpb_chnl_demap and 
*   digi_enet_enhanced_pmon_demap.  It does the bulk of the work for cpb chnl 
*   demapping.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *cpb_handle      - The cpb handle.
*   cpb_output_port  - The cpb output port.
*   *input_pc_ptr    - util_global_switch_data_t pointer defining inbound port
*   *output_pc_ptr   - util_global_switch_data_t pointer defining outbound port
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_internal_chnl_demap(digi_handle_t* digi_handle,
                                              cpb_handle_t* cpb_handle,
                                              UINT32 cpb_output_port,
                                              util_global_switch_data_t * input_pc_ptr,
                                              util_global_switch_data_t * output_pc_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
 
    util_global_switch_data_def_t* input_switch_data_ptr = (util_global_switch_data_def_t*)input_pc_ptr;
    util_global_switch_data_def_t* output_switch_data_ptr = (util_global_switch_data_def_t*)output_pc_ptr;
    util_global_cpb_port_data_t *local_input_pc_ptr = &(input_switch_data_ptr->cpb_data);
    util_global_cpb_port_data_t *local_output_pc_ptr = &(output_switch_data_ptr->cpb_data);

    PMC_ENTRY();

    if (PMC_SUCCESS == result)
    {
        if (local_input_pc_ptr->port_type==UTIL_GLOBAL_CPB_PORT_MAPOTN &&
            FALSE == ((digi_mapper_chnl_def_t *)input_pc_ptr)->switch_data.oduk_data.op_state.map_state.is_output_mapped)
        {
            result =  digi_map_opu_csf_int_cfg(digi_handle, (digi_mapper_chnl_def_t *)input_pc_ptr, local_output_pc_ptr->channel, FALSE);
        }
    }

    result = digi_cpb_mpmo_deprov(digi_handle, 
                                  local_output_pc_ptr->port_type, 
                                  local_output_pc_ptr->channel); 

    if(result==PMC_SUCCESS)
    {
        result = cpb_chnl_deprov(cpb_handle, cpb_output_port, local_output_pc_ptr->channel, FALSE);
    }

    if (result == PMC_SUCCESS) {

        if (local_input_pc_ptr->op_state.map_state.input_map_count > 0) {
            local_input_pc_ptr->op_state.map_state.input_map_count--;
        }
        if (local_input_pc_ptr->op_state.map_state.input_map_count == 0) {
            local_input_pc_ptr->op_state.map_state.is_input_mapped = FALSE;
        }

        local_output_pc_ptr->op_state.map_state.is_output_mapped = FALSE;
    }

    if (PMC_SUCCESS == result &&
        (UTIL_GLOBAL_CPB_PORT_ENET_LINE == local_output_pc_ptr->port_type ||
         UTIL_GLOBAL_CPB_PORT_ENET_SYS == local_output_pc_ptr->port_type))
    {
        result = digi_enet_lf_force_set(digi_handle,
                                        (digi_enet_client_chnl_def_t *)output_pc_ptr,
                                        TRUE, FALSE);
    }
        
    /* determine state of the CPB SS and if no resources provisioned bring SS to lowpwr/reset state */
    if(result==PMC_SUCCESS)
    {
        digi_dcpb_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL);
    }

    PMC_RETURN(result);
} /* digi_cpb_internal_chnl_demap */
 
/*******************************************************************************
* digi_cpb_internal_chnl_activate
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper funciton for digi_cpb_chnl_activate.
*   This function provides graceful data path enabling of a client stream
*   passing through CPB subsystem in a single direction.  It performs data path
*   element reset and data flow enabling operations on all subsystems related to
*   the datapath.\n\n
*
*   The function takes in the output port and output channel to identify the
*   channel.  This allows for CPB broadcast and multicast implementations
*   to be supported with this interface.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *output_pc_ptr   - a pointer to the destination DPI port / chanel pair
*                      for the channel to be activated.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_internal_chnl_activate(digi_handle_t* digi_handle,
                                                 util_global_switch_data_t* output_pc_ptr)
{
    PMC_ERROR result;
    BOOL8 is_broadcast = FALSE;
    BOOL8 is_multicast = FALSE;
    BOOL8 is_reader_primary = FALSE;
    BOOL8 is_slave_zone_primary = FALSE;
    cpb_handle_t* cpb_handle = NULL;
    util_global_switch_data_def_t *local_output_sw_ptr = (util_global_switch_data_def_t *)output_pc_ptr;
    util_global_switch_data_def_t *local_input_sw_ptr;
    util_global_cpb_port_data_t *local_output_pc_ptr;
    util_global_cpb_port_data_t local_input_pc;
    UINT32 mapotn_chnl;
    util_global_switch_data_t *input_pc_ptr;
    util_global_cpb_port_data_t* local_input_pc_ptr = NULL;
    sifd_ilkn_inst_t sifd_ilkn_inst;
    BOOL8 is_otn_dp = FALSE;
    BOOL8 is_mapotn_etrans = FALSE;
    util_global_mapping_mode_t mapotn_mapping_mode = UTIL_GLOBAL_NO_MAP;
    util_global_map_adapt_func_t adapt_mode = UTIL_GLOBAL_MAP_NO_RATE;
    util_global_map_adapt_func_t dummy_adapt_mode = UTIL_GLOBAL_MAP_NO_RATE;

    PMC_ENTRY();

    local_output_pc_ptr = &(local_output_sw_ptr->cpb_data);

    /* Check arguments */
    PMC_ASSERT(digi_handle != NULL, DIGI_ERR_NULL_HANDLE, 0, 0);

    if (output_pc_ptr == NULL) {

        PMC_RETURN(DIGI_ERR_INVALID_ARG);

    } else if (local_output_sw_ptr->cpb_data.op_state.map_state.is_output_mapped == FALSE) {

        PMC_RETURN(DIGI_ERR_CPB_NOT_MAPPED);

    } else if (local_output_sw_ptr->cpb_data.op_state.active_state == UTIL_GLOBAL_CHNL_ACTIVE_STATE_ACTIVE) {

        PMC_RETURN(DIGI_ERR_CPB_ALREADY_ACTIVE);
    }

    PMC_ASSERT(NULL != digi_handle->dcpb_handle, DIGI_ERR_NULL_HANDLE, 0, 0);

    cpb_handle = digi_handle->dcpb_handle;


    result = cpb_chnl_source_type_and_primary_test(cpb_handle,
                                                   local_output_pc_ptr->port_type,
                                                   local_output_pc_ptr->channel,
                                                   (UINT32*)&(local_input_pc.port_type),
                                                   &(local_input_pc.channel),
                                                   &is_broadcast,
                                                   &is_multicast,
                                                   &is_reader_primary,
                                                   &is_slave_zone_primary);
    input_pc_ptr = digi_cpb_input_port_get(digi_handle, output_pc_ptr);

    /* Make sure that input_pc_ptr is not propagated further as invalid. */
    if(input_pc_ptr == NULL)
    {
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    local_input_pc_ptr = &(((util_global_switch_data_def_t*)input_pc_ptr)->cpb_data);

    if(result) PMC_RETURN(result);
    /*[YY] get the source parameters of the destination channel, also tests if
      if is a broadcast or multicast channel */

    /*  [YY] based on the destination subsystem, determine the activate function to call*/
    switch(local_output_pc_ptr->port_type)
    {
    case UTIL_GLOBAL_CPB_PORT_ILKN1:
    case UTIL_GLOBAL_CPB_PORT_ILKN2:
        /*
         * There is nothing to be done here of ILKN1 or ILKN2 as activation at 
         * this level should have occurred when the channel was 
         * provisioned. The CPB DPI Master XON/XOFF signal should be 
         * configured below when cpb_chnl_activate is called.
         */
        break;

    case UTIL_GLOBAL_CPB_PORT_CBRC:
        result = cbrc_sdh_pmg_activate(digi_handle->cbrc_handle,CBRC_PORT_DIR_TX,local_output_pc_ptr->channel);        
        if(PMC_SUCCESS == result)
        {         
            result = cbrc_mpmo_activate(digi_handle->cbrc_handle,local_output_pc_ptr->channel);
        }

        break;
    case UTIL_GLOBAL_CPB_PORT_MAPOTN:
        result = digi_dcpb_mapotn_head_hole_match(digi_handle, output_pc_ptr);
        if(result) PMC_RETURN(result);

        PMC_LOG_TRACE("\nCPB testing: calling cpb channel activate ... \n");
        result = cpb_chnl_activate( cpb_handle, local_output_pc_ptr->port_type, local_output_pc_ptr->channel);
        if(result) PMC_RETURN(result);
        PMC_LOG_TRACE("\nCPB testing: calling mapotn tx channel activate ... \n");
      

        

        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
        PMC_LOG_TRACE("\nCPB testing: calling enet line tx channel activate ... \n");
        PMC_ASSERT(local_output_pc_ptr->channel < DIGI_ENET_CHNL_MAX, DIGI_ERR_INVALID_ARG, 0, 0);
        if(enet_is_link_mapotn_test(digi_handle->enet_line_handle, local_output_pc_ptr->channel, &mapotn_chnl) == TRUE)
        {
            is_mapotn_etrans = TRUE;
        }
        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
        break;
    default:
        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }
    if(result)PMC_RETURN(result);

    if(local_output_pc_ptr->port_type != UTIL_GLOBAL_CPB_PORT_MAPOTN)
    {
        /* [YY] call the cpb_chnl_activate function */
        PMC_LOG_TRACE("\nCPB testing: calling cpb channel activate ... \n");
        result = cpb_chnl_activate( cpb_handle, local_output_pc_ptr->port_type, local_output_pc_ptr->channel);
        if(result) PMC_RETURN(result);
    }

    PMC_LOG_TRACE("\nbroadcast = %u multicast = %u\n",(UINT32)is_broadcast,(UINT32)is_multicast);
 
    local_input_sw_ptr = (util_global_switch_data_def_t*)input_pc_ptr;

    if(is_slave_zone_primary == TRUE) 
    {
        /* [YY] if it is neither a broadcast nor multicast chnl, activate the source, otherwise the source
           is already activated */
        switch(local_input_pc.port_type)
        {
        case UTIL_GLOBAL_CPB_PORT_ILKN1:
        case UTIL_GLOBAL_CPB_PORT_ILKN2:
            /*
             * For ILKN1 and ILKN2 the channel should be activated as a 
             * result of the cpb_chnl_activate and as such there is 
             * nothing to here. Simply break out of the loop
             */
            break;
        case UTIL_GLOBAL_CPB_PORT_CBRC:
            break;
        case UTIL_GLOBAL_CPB_PORT_MAPOTN:
            PMC_LOG_TRACE("\nCPB testing: calling mapotn rx channel activate ... \n");
            if (PMC_SUCCESS == result)
            {
                result = coreotn_fo2_mpmo_ch_activate(digi_handle->coreotn_handle,
                                                      local_input_pc.channel);
                if (PMC_SUCCESS == result)
                {
                    digi_mapotn_mode_params_convert(digi_handle->handle_pool.mapper_chnl[local_input_pc.channel].mode,
                                                    &adapt_mode,
                                                    &dummy_adapt_mode);
                    result = mapotn_mapping_mode_get(digi_handle->mapotn_handle, 
                                                     adapt_mode,
                                                     &mapotn_mapping_mode);
                    
                    if (PMC_SUCCESS == result  && mapotn_mapping_mode == UTIL_GLOBAL_GFP)
                    {
                        result = mapotn_demapper_activate(digi_handle->mapotn_handle,  local_input_pc.channel);
                    }                                        
                }
            }
            break;
        case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
            if(result == PMC_SUCCESS)
            {                
                /* If MAPOTN/ENET_LINE in datapath, both of these need to be activated!!!!*/
                if(enet_is_link_mapotn_test(digi_handle->enet_line_handle, local_input_pc.channel, &mapotn_chnl) == TRUE)
                {   
                    result = coreotn_fo2_mpmo_ch_activate(digi_handle->coreotn_handle,
                                                          mapotn_chnl);
                    if (PMC_SUCCESS == result)
                    {
                        digi_mapotn_mode_params_convert(digi_handle->handle_pool.mapper_chnl[mapotn_chnl].mode,
                                                        &adapt_mode,
                                                        &dummy_adapt_mode);
                        result = mapotn_mapping_mode_get(digi_handle->mapotn_handle, 
                                                         adapt_mode,
                                                         &mapotn_mapping_mode);

                        if (PMC_SUCCESS == result  && mapotn_mapping_mode == UTIL_GLOBAL_GFP)
                        {
                            result = mapotn_demapper_activate(digi_handle->mapotn_handle, mapotn_chnl);
                        }                                        
                    }
                }
            }                          
            break;
        case UTIL_GLOBAL_CPB_PORT_ENET_SYS:

            break;
        default:
            PMC_RETURN(DIGI_ERR_INVALID_ARG);
        }
        if(result)PMC_RETURN(result);
    }
    
    /* Check if Datapath is OTN <-> ENET, and set serdes Maximum PPM in consequence */
    if (result == PMC_SUCCESS)
    {
        /* Only check ACB configuration when we are not in enhanced PMON
         * mode */
        if (digi_is_enhanced_enet_pmon_path(input_pc_ptr, output_pc_ptr) == FALSE) 
        {
            /* retrieve datapath status */
            is_otn_dp = digi_serdes_is_otn_dp_get(digi_handle,
                                                  local_output_pc_ptr->port_type,
                                                  local_input_pc_ptr);
            PMC_LOG_TRACE("in %s - check if OTN DP %d\n", __FUNCTION__, is_otn_dp);
        }
    }


    /* ACB provisioning (lane alignement/timing + CKCTL routing when required */
    if( (result==PMC_SUCCESS) &&
        (UTIL_GLOBAL_CPB_PORT_ENET_LINE == local_output_pc_ptr->port_type ||
         UTIL_GLOBAL_CPB_PORT_ENET_SYS == local_output_pc_ptr->port_type ||
         UTIL_GLOBAL_CPB_PORT_CBRC == local_output_pc_ptr->port_type))
    {

        /* Only perform ACB configuration when we are not in enhanced PMON
         * mode */
        if (digi_is_enhanced_enet_pmon_path(input_pc_ptr, output_pc_ptr) == FALSE) 
        {
            PMC_LOG_TRACE("about to call digi_non_otn_acb_ckctl_cfg\n");
            result = digi_non_otn_acb_ckctl_cfg(digi_handle, input_pc_ptr, output_pc_ptr, DIGI_SERDES_PROV,LAST_DIGI_ENET_TX_TIMING_MODE);
            if (PMC_SUCCESS == result)
            {            
                result = digi_non_otn_acb_ckctl_cfg(digi_handle, input_pc_ptr, output_pc_ptr , DIGI_SERDES_ACTIVATE,LAST_DIGI_ENET_TX_TIMING_MODE);
            }
            if (PMC_SUCCESS == result &&
                (UTIL_GLOBAL_CPB_PORT_ENET_LINE == local_output_pc_ptr->port_type ||
                 UTIL_GLOBAL_CPB_PORT_ENET_SYS == local_output_pc_ptr->port_type))
            {
                if (TRUE == is_otn_dp)
                {            
                    /* if it's a OTN -> ENET datapath, set ENET serdes maximum PPM such as =
                       150% of (ENET MAX_ PPM + OTN MAX PPM) */
                    result = digi_non_otn_acb_ckctl_cfg(digi_handle, input_pc_ptr, output_pc_ptr, DIGI_SERDES_ENET_OTN_MAX_PPM_SET, LAST_DIGI_ENET_TX_TIMING_MODE);
                }
                /* digi_non_otn_acb_ckctl_cfg does not provision or activate acb ft related to ENENT MAC channel */
                /* call digi_non_otn_acb_ckctl_cfg to configure multi lane aligner for ENET MAC 40G or 100G channel */
                if (PMC_SUCCESS == result && FALSE == is_mapotn_etrans)
                {
                    result = digi_non_otn_acb_ckctl_cfg(digi_handle, input_pc_ptr, output_pc_ptr, DIGI_SERDES_PROV_ALIGNER_ONLY,LAST_DIGI_ENET_TX_TIMING_MODE);
                }
            }
        }   
    }

    if(result == PMC_SUCCESS)
    {
        digi_opsa_cpb_activate_cfg(digi_handle,
                                   input_pc_ptr, 
                                   output_pc_ptr,
                                   is_reader_primary,
                                   is_slave_zone_primary,
                                   DIGI_OPSA_CFG_ACTION_ACTIVATE,
                                   FALSE);
    }
                                  
                                  
    if(result == PMC_SUCCESS)
    {
        local_output_pc_ptr->op_state.active_state = UTIL_GLOBAL_CHNL_ACTIVE_STATE_ACTIVE;
        local_input_sw_ptr->cpb_data.op_state.map_state.dest_active_count++;
    }
    /* Update SIFD flow control calendar if needed */
    /* TX data */
    if ((local_output_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN1 ||
         local_output_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN2))
    {
        sifd_ilkn_inst = local_output_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN1 ? SIFD_COPI_ILKN1 : SIFD_COPI_ILKN2;
        
        if (result == PMC_SUCCESS)
            result = digi_sifd_fc_calendar_update(digi_handle, 
                                                  sifd_ilkn_inst, 
                                                  (UINT32)local_output_pc_ptr->port_type,
                                                  TRUE, /* TRUE means TX data direction */
                                                  FALSE, /* TRUE means it's for ODUk switch, not CPB */
                                                  SIFD_ILKN_NULL_CAL_ENTRY);
    }
    /* RX data */
    if ((local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN1 ||
         local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN2) && (is_slave_zone_primary == TRUE))
    {
        sifd_ilkn_inst = local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN1 ? SIFD_COPI_ILKN1 : SIFD_COPI_ILKN2;
        
        if (result == PMC_SUCCESS)
            result = digi_sifd_fc_calendar_update(digi_handle, 
                                                  sifd_ilkn_inst,
                                                  (UINT32)local_output_pc_ptr->port_type,
                                                  FALSE, /* FALSE means RX data direction */
                                                  FALSE,
                                                  SIFD_ILKN_NULL_CAL_ENTRY);
    }

    PMC_RETURN(result);
} /* digi_cpb_internal_chnl_activate */

/*******************************************************************************
* digi_cpb_internal_chnl_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper funciton for digi_cpb_chnl_deactivate.
*
*   This function gracefully disables the elements of a data path flowing
*   through CPB for one direction.
*
*   In the case of a broadcast or multicast channel in CPB subsystem, the
*   reader will be disabled, and the writer will remain enabled.  Except if the
*   reader is the primary reader and broadcast or multicast readers are still
*   active.  In this case an error will be returned.  This error is recoverable,
*   in order for this datapath to be deactivated, each non-primary reader port
*   needs to be deactivated prior to deactivating the primary reader for the
*   write port.
*
*
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *output_pc_ptr   - Destination DPI port / channel pair for the channel to
*                      be activated.  Accepts the pointer to one of the
*                      following channel handle types: \n\n
*                      digi_enet_client_chnl_t \n
*                      digi_cbr_client_chnl_t \n
*                      digi_ilkn_chnl_t \n
*                      digi_mapper_chnl_t \n
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_internal_chnl_deactivate(digi_handle_t *digi_handle,
                                                   util_global_switch_data_t *output_pc_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;

    /* variable definition */
    UINT32 ingress_mux_input_port = LAST_UTIL_GLOBAL_CPB_PORT, ingress_mux_input_port_chnl;
    UINT32 link;
    BOOL8 is_multicast = FALSE;
    BOOL8 is_broadcast = FALSE;
    BOOL8 is_reader_primary = FALSE;
    BOOL8 is_slave_zone_primary = FALSE;
    util_global_switch_data_def_t *output_pc_data_ptr = NULL;
    util_global_switch_data_def_t *local_input_sw_ptr = NULL;
    util_global_cpb_port_data_t *local_output_pc_ptr = (util_global_cpb_port_data_t*)output_pc_ptr;
    enet_datapath_t enet_datatype = LAST_ENET_DATAPATH;
    cpb_handle_t *cpb_handle = NULL;
    UINT32 cpb_output_port;
    UINT32 mapotn_chnl;
    util_global_switch_data_t *input_pc_ptr;
    sifd_ilkn_inst_t sifd_ilkn_inst;
    BOOL8 is_mapotn_etrans = FALSE;
    util_global_mapping_mode_t mapotn_mapping_mode = UTIL_GLOBAL_NO_MAP;
    util_global_map_adapt_func_t adapt_mode = UTIL_GLOBAL_MAP_NO_RATE;
    util_global_map_adapt_func_t dummy_adapt_mode = UTIL_GLOBAL_MAP_NO_RATE;

    PMC_ENTRY();

    output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;

    local_output_pc_ptr = &(output_pc_data_ptr->cpb_data);

    PMC_ASSERT(local_output_pc_ptr->port_type < UTIL_GLOBAL_CPB_PORT_NOT_USED, DIGI_ERR_INVALID_ARG, 0, 0);

    /* retrieve required CPB handle */
    cpb_handle = digi_handle->dcpb_handle;
    cpb_output_port = local_output_pc_ptr->port_type;

    if( result == PMC_SUCCESS )
    {
        result = cpb_chnl_source_type_and_primary_test(cpb_handle,
                                                       local_output_pc_ptr->port_type,
                                                       local_output_pc_ptr->channel,
                                                       &ingress_mux_input_port,
                                                       &ingress_mux_input_port_chnl,
                                                       &is_broadcast,
                                                       &is_multicast,
                                                       &is_reader_primary,
                                                       &is_slave_zone_primary);
    }

    if(ingress_mux_input_port == UTIL_GLOBAL_CPB_PORT_ENET_LINE || ingress_mux_input_port == UTIL_GLOBAL_CPB_PORT_ENET_SYS)
    {
        BOOL8 use_backup = FALSE;

        result = cpb_chnl_backup_status(digi_handle->dcpb_handle, ingress_mux_input_port, ingress_mux_input_port_chnl, &use_backup);

        if(result == CPB_ERR_NO_BACKUP_SETUP)
        {
            result = PMC_SUCCESS;
        }
        else
        {
            PMC_RETURN(DIGI_ERR_BACKUP_STILL_PROV);
        }        
    }

    if( (result == PMC_SUCCESS) && 
        (is_broadcast || is_multicast || is_reader_primary || is_slave_zone_primary))
    {
        result = cpb_chnl_switch(cpb_handle,
                                 local_output_pc_ptr->port_type,
                                 local_output_pc_ptr->channel);

        if( result == PMC_SUCCESS )
        {
            result = cpb_chnl_source_type_and_primary_test(cpb_handle,
                                                           local_output_pc_ptr->port_type,
                                                           local_output_pc_ptr->channel,
                                                           &ingress_mux_input_port,
                                                           &ingress_mux_input_port_chnl,
                                                           &is_broadcast,
                                                           &is_multicast,
                                                           &is_reader_primary,
                                                           &is_slave_zone_primary);
        }
    }

    input_pc_ptr = digi_cpb_input_port_get(digi_handle, output_pc_ptr);
    local_input_sw_ptr = (util_global_switch_data_def_t*)input_pc_ptr;

    /* Avoid dereferencing NULL ptr bellow. */
    PMC_ASSERT(input_pc_ptr != NULL, DIGI_ERR_INVALID_ARG, 0, 0); 

    if(result == PMC_SUCCESS)
    {
        digi_opsa_cpb_activate_cfg(digi_handle,
                                   input_pc_ptr, 
                                   output_pc_ptr,
                                   is_reader_primary,
                                   is_slave_zone_primary,
                                   DIGI_OPSA_CFG_ACTION_DEACTIVATE,
                                   FALSE);
    } 

    /* ACB deprovisioning (lane alignement/timing + CKCTL routing when required */
    if( (result==PMC_SUCCESS) &&
        (UTIL_GLOBAL_CPB_PORT_ENET_LINE == local_output_pc_ptr->port_type ||
         UTIL_GLOBAL_CPB_PORT_ENET_SYS == local_output_pc_ptr->port_type ||
         UTIL_GLOBAL_CPB_PORT_CBRC == local_output_pc_ptr->port_type))
    {
        if(UTIL_GLOBAL_CPB_PORT_ENET_LINE == local_output_pc_ptr->port_type  &&
           TRUE == enet_is_link_mapotn_test(digi_handle->enet_line_handle, local_output_pc_ptr->channel, &mapotn_chnl))
        {
            is_mapotn_etrans = TRUE;
        }
        
        /* Only perform ACB configuration when we are not in enhanced PMON
         * mode */
        if (FALSE == is_mapotn_etrans && digi_is_enhanced_enet_pmon_path(input_pc_ptr, output_pc_ptr) == FALSE) 
        {
            result = digi_non_otn_acb_ckctl_cfg(digi_handle, input_pc_ptr, output_pc_ptr , DIGI_SERDES_DEACTIVATE,LAST_DIGI_ENET_TX_TIMING_MODE);
            if (PMC_SUCCESS == result)
            {
                result = digi_non_otn_acb_ckctl_cfg(digi_handle, input_pc_ptr, output_pc_ptr , DIGI_SERDES_DEPROV,LAST_DIGI_ENET_TX_TIMING_MODE);
            }
        }
    }

    /* If it's a broadcast or multicast primary channel, then only deactivate 
     * if there are no secondary readers active */
    if(is_multicast == TRUE && is_reader_primary == TRUE && 
       local_input_sw_ptr->cpb_data.op_state.map_state.dest_active_count > 1) 
        result = DIGI_ERR_PRIMARY_UNABLE_TO_DEACTIVATE;
    if(is_broadcast == TRUE && is_slave_zone_primary == TRUE &&
       local_input_sw_ptr->cpb_data.op_state.map_state.dest_active_count > 1) 
        result = DIGI_ERR_PRIMARY_UNABLE_TO_DEACTIVATE;

    /* Update SIFD flow control calendar if needed */
    /* TX data */

    if ((local_output_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN1 ||
         local_output_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN2))
    {
        sifd_ilkn_inst = local_output_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN1 ? SIFD_COPI_ILKN1 : SIFD_COPI_ILKN2;
        PMC_ATOMIC_YIELD(digi_handle,0);
        if (result == PMC_SUCCESS)
            result = digi_sifd_fc_calendar_update(digi_handle, 
                                                  sifd_ilkn_inst, 
                                                  (UINT32)local_output_pc_ptr->port_type,
                                                  TRUE, /* TRUE means TX data direction */
                                                  FALSE, /* TRUE means it's for ODUk switch, not CPB */
                                                  local_output_pc_ptr->channel);
    }
    /* RX data */
    if ((local_input_sw_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ILKN1 ||
         local_input_sw_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ILKN2) && (is_slave_zone_primary == TRUE))
    {
        sifd_ilkn_inst = local_input_sw_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ILKN1 ? SIFD_COPI_ILKN1 : SIFD_COPI_ILKN2;

        if (result == PMC_SUCCESS)
            PMC_ATOMIC_YIELD(digi_handle,0);
        result = digi_sifd_fc_calendar_update(digi_handle, 
                                              sifd_ilkn_inst,
                                              (UINT32)local_input_sw_ptr->cpb_data.port_type,
                                              FALSE, /* FALSE means RX data direction */
                                              FALSE,
                                              local_input_sw_ptr->cpb_data.channel);
    }


 
    /* Disable data source if it is not used by other downstream data paths */
    /* If it's a broadcast or multicast, it needs to be the primary */
    if( result == PMC_SUCCESS && 
        ( (is_broadcast == FALSE && is_multicast == FALSE) ||
          (is_broadcast == TRUE && is_slave_zone_primary == TRUE) ||
          (is_multicast == TRUE && is_reader_primary == TRUE) ) )
    {
        switch(ingress_mux_input_port)
        {
        case UTIL_GLOBAL_CPB_PORT_ILKN1:
        case UTIL_GLOBAL_CPB_PORT_ILKN2:
            /*
             * For ILKN1 and ILKN2 all that is require is to call the 
             * cpb_chnl_deactivate.
             */
            break;
        case UTIL_GLOBAL_CPB_PORT_CBRC:
            break;
        case UTIL_GLOBAL_CPB_PORT_MAPOTN:
            digi_mapotn_mode_params_convert(digi_handle->handle_pool.mapper_chnl[ingress_mux_input_port_chnl].mode,
                                            &adapt_mode,
                                            &dummy_adapt_mode);
            result = mapotn_mapping_mode_get(digi_handle->mapotn_handle, 
                                             adapt_mode,
                                             &mapotn_mapping_mode);
            
            if (PMC_SUCCESS == result  && mapotn_mapping_mode == UTIL_GLOBAL_GFP)
            {
                result = mapotn_demapper_deactivate(digi_handle->mapotn_handle, ingress_mux_input_port_chnl);
            }                                        
            if (PMC_SUCCESS == result)
            {
                result = coreotn_fo2_mpmo_ch_deactivate(digi_handle->coreotn_handle,
                                                        ingress_mux_input_port_chnl);
            }
            break;
        case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
            /* deactivate the MAPOTN demapper if part of data path */
            link = ingress_mux_input_port_chnl;
            enet_datatype = (digi_handle->enet_line_handle)->var.ch_datapath[link];

            if(enet_is_link_mapotn_test(digi_handle->enet_line_handle, link, &mapotn_chnl) == TRUE)
            {
                digi_mapotn_mode_params_convert(digi_handle->handle_pool.mapper_chnl[mapotn_chnl].mode,
                                                &adapt_mode,
                                                &dummy_adapt_mode);
                result = mapotn_mapping_mode_get(digi_handle->mapotn_handle, 
                                                 adapt_mode,
                                                 &mapotn_mapping_mode);
                
                if (PMC_SUCCESS == result  && mapotn_mapping_mode == UTIL_GLOBAL_GFP)
                {
                    result = mapotn_demapper_deactivate(digi_handle->mapotn_handle, mapotn_chnl);
                }                                        
                if (PMC_SUCCESS == result)
                {
                    result = coreotn_fo2_mpmo_ch_deactivate(digi_handle->coreotn_handle,
                                                            mapotn_chnl);
                }
            }
            break;
        case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
            break;
        default:
            result = DIGI_ERR_INVALID_ARG;
        }
    }

    if(result == PMC_SUCCESS)
    {
        result = cpb_chnl_deactivate(cpb_handle, cpb_output_port, local_output_pc_ptr->channel);
    }

    /* Deactivate downstream subsystems respecting any sequence they may have */
    if(result == PMC_SUCCESS)
    {
        switch(local_output_pc_ptr->port_type)
        {
        case UTIL_GLOBAL_CPB_PORT_ILKN1:
        case UTIL_GLOBAL_CPB_PORT_ILKN2:
            /*
             * For ILKN1 an ILKN2 there is nothing to be done so break out.
             */
            break;
        case UTIL_GLOBAL_CPB_PORT_CBRC:
            result = cbrc_sdh_pmg_deactivate(digi_handle->cbrc_handle,CBRC_PORT_DIR_TX,local_output_pc_ptr->channel);        
            if(PMC_SUCCESS == result)
            {
                result = cbrc_mpmo_deactivate(digi_handle->cbrc_handle,local_output_pc_ptr->channel);
            }
            break;
        case UTIL_GLOBAL_CPB_PORT_MAPOTN:
            break;
        case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
            break;
        case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
            break;
        default:
            result = DIGI_ERR_INVALID_ARG;
        }
    }

    if (result == PMC_SUCCESS) {

        local_output_pc_ptr->op_state.active_state = UTIL_GLOBAL_CHNL_ACTIVE_STATE_INACTIVE;
        local_input_sw_ptr->cpb_data.op_state.map_state.dest_active_count--;
    }

    PMC_RETURN(result);

} /* digi_cpb_internal_chnl_deactivate */

/*******************************************************************************
* digi_enet_pmon_line_usage_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The is a helper function that sets the appropriate bits in the
*   enet_pmon_line_usage bitfield.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   enet_link              - the ethernet link
*   mode                   - the ethernet mode that the link is 
*                            provisioned as. This is used to determine the size
*                            of the link.
*   in_use                 - Set to TRUE to turn the bits on/in_use or
*                            FALSE to turn the bits off/not_in_use.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC void digi_enet_pmon_line_usage_set(digi_handle_t* digi_handle,
                                          UINT32 enet_link, 
                                          digi_enet_mode_t mode,
                                          BOOL in_use)
{
    enet_datapath_t e_mode;
    digi_group_size_t group_size;
    UINT16 bit_mask = 0;
    UINT16 i; 
    UINT8 num_lanes_req = 0;
    PMC_ENTRY();

    /* returns void */
    digi_enet_line_prov_params_convert(mode, &e_mode, &group_size);

    switch(group_size)
    {
    case DIGI_GRP_SIZE_10G:
        num_lanes_req = DIGI_SERDES_LINE_LANES_FOR_10G;
        break;
    case DIGI_GRP_SIZE_40G:
        num_lanes_req = DIGI_SERDES_LINE_LANES_FOR_40G;
        break;
    case DIGI_GRP_SIZE_100G:
        num_lanes_req = DIGI_SERDES_LINE_LANES_FOR_100G;
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
        break;
    }


    for (i = enet_link; i < (enet_link + num_lanes_req); i++) {

        bit_mask = bit_mask | (1 << i);
    }

    if (in_use == TRUE) {

        digi_handle->var.digi_enet_pmon_line_usage = digi_handle->var.digi_enet_pmon_line_usage | bit_mask;

    } else {

        digi_handle->var.digi_enet_pmon_line_usage = digi_handle->var.digi_enet_pmon_line_usage & ~bit_mask;
    }
    
    PMC_RETURN();
} /* digi_enet_pmon_line_usage_set */

/*******************************************************************************
* FUNCTION: digi_cbr_client_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The is a helper function which obtains a digi_cbr_client_chnl_def_t and populates
*   the values based on the links passed in.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   serdes_mode            - Configuration mode for serdes port
*   cbrc_link              - the cbrc link
*   mux_link               - the mux link
*   port_uid               - Serdes port identifier that connects to this
*                            cbcrc handle.
*   mode                   - CBRC mode used to derive the serdes mode.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   digi_cbr_client_chnl_def_t - pointer to the CBRC chnl_ctxt.
*
* NOTES:
*
*
*******************************************************************************/
PRIVATE digi_cbr_client_chnl_def_t* digi_cbr_client_chnl_get(digi_handle_t* digi_handle, 
                                                             digi_serdes_port_mode_t serdes_mode,
                                                             UINT32 cbrc_link, 
                                                             UINT32 mux_link,
                                                             UINT32 port_uid,
                                                             digi_cbr_client_mode_t mode)
{
    digi_cbr_client_chnl_def_t* chnl_ctxt_ptr;

    PMC_ENTRY();


    if (digi_handle->handle_pool.cbr_chnl[cbrc_link].switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) {

        chnl_ctxt_ptr = &(digi_handle->handle_pool.cbr_chnl[cbrc_link]);

    } else {

        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    /* Reset the handle to the default state */
    digi_chnl_ptr_initialize(&(chnl_ctxt_ptr->switch_data));

    /* DSI chnl info */
    chnl_ctxt_ptr->serdes_mode   = serdes_mode;
    chnl_ctxt_ptr->mux_dsi_chnl  = mux_link; 
   
    /* Switch info */
    chnl_ctxt_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
   
    /* CPB info */
    chnl_ctxt_ptr->switch_data.cpb_data.port_type   = UTIL_GLOBAL_CPB_PORT_CBRC;
    chnl_ctxt_ptr->switch_data.cpb_data.channel     = cbrc_link;
    chnl_ctxt_ptr->switch_data.cpb_data.data_source = 0;   /* 0 = line serdes */
    chnl_ctxt_ptr->port_uid = port_uid;
    chnl_ctxt_ptr->mode = mode;

    PMC_RETURN(chnl_ctxt_ptr);
} /* digi_cbr_client_chnl_get */

/*******************************************************************************
* digi_mapper_client_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The is a helper function which obtains a digi_mapper_chnl_def_t and populates
*   the values based on the links passed in.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   oduk_chnl              - the oduk channel
*   cpb_chnl               - the cpb channel
*   cpb_port_type          - the type of cpb port we are.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   digi_mapper_chnl_def_t - pointer to the mapotn chnl_ctxt.
*
* NOTES:
*
*
*******************************************************************************/
PRIVATE digi_mapper_chnl_def_t* digi_mapper_client_chnl_get(digi_handle_t* digi_handle, 
                                                            UINT32 oduk_chnl, 
                                                            UINT32 cpb_chnl,
                                                            util_global_cpb_port_t cpb_port_type)
{
    digi_mapper_chnl_def_t* chnl_ctxt_ptr;

    PMC_ENTRY();

    if (digi_handle->handle_pool.mapper_chnl[oduk_chnl].switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) {

        chnl_ctxt_ptr = &(digi_handle->handle_pool.mapper_chnl[oduk_chnl]);

    } else {

        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    /* Reset the handle to the default state */
    digi_chnl_ptr_initialize(&(chnl_ctxt_ptr->switch_data));

    chnl_ctxt_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;

    chnl_ctxt_ptr->switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_MAPOTN;
    chnl_ctxt_ptr->switch_data.oduk_data.channel = oduk_chnl;

    chnl_ctxt_ptr->switch_data.cpb_data.port_type = cpb_port_type;
    chnl_ctxt_ptr->switch_data.cpb_data.channel = cpb_chnl;
    chnl_ctxt_ptr->switch_data.cpb_data.data_source = 1;

    /* initialize odu_struct for stg4 */
    odu_struct_default_set((odu_struct_t *)&(digi_handle->handle_pool.s4_odu_struct[oduk_chnl]));
    
    /* set-up the odu_struct for tcm monitoring appliactions */   
    digi_handle->handle_pool.s4_odu_struct[oduk_chnl].switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
    digi_handle->handle_pool.s4_odu_struct[oduk_chnl].switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_MAPOTN;
    digi_handle->handle_pool.s4_odu_struct[oduk_chnl].switch_data.oduk_data.channel = oduk_chnl;
    digi_handle->handle_pool.s4_odu_struct[oduk_chnl].switch_data.oduk_data.odu_level = UTIL_GLOBAL_LEVEL_4_ODU;

    digi_handle->handle_pool.s4_odu_struct[oduk_chnl].switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
    digi_handle->handle_pool.s4_odu_struct[oduk_chnl].switch_data.cpb_data.channel = 0;

    /* update the channel ID and ODU level */
    digi_handle->handle_pool.s4_odu_struct[oduk_chnl].mem_ptr->chnl_id = oduk_chnl;
    digi_handle->handle_pool.s4_odu_struct[oduk_chnl].mem_ptr->odu_level =  ODU_STRUCT_LEVEL_4_ODU;


    PMC_RETURN(chnl_ctxt_ptr);
} /* digi_mapper_client_chnl_get */

/*******************************************************************************
* digi_otn_server_line_client_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The is a helper function which obtains a digi_otn_server_chnl_def_t.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   dci_chnl               - the dci channel
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   digi_otn_server_chnl_def_t - pointer to the otn server line chnl_ctxt.
*
* NOTES:
*
*
*******************************************************************************/
PRIVATE digi_otn_server_chnl_def_t* digi_otn_server_line_client_chnl_get(digi_handle_t* digi_handle, 
                                                                         UINT32 dci_chnl)
{
    digi_otn_server_chnl_def_t* chnl_ctxt_ptr = NULL;

    PMC_ENTRY();

    if (digi_handle->handle_pool.otn_server_chnl[dci_chnl].header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) {

        chnl_ctxt_ptr = &(digi_handle->handle_pool.otn_server_chnl[dci_chnl]);

    }
    else
    {
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    chnl_ctxt_ptr->header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
    chnl_ctxt_ptr->header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;

    PMC_RETURN(chnl_ctxt_ptr);
} /* digi_otn_server_line_client_chnl_get */


/*******************************************************************************
* digi_sysotn_server_line_client_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The is a helper function which obtains a digi_otn_server_chnl_def_t.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   digi_otn_server_chnl_def_t  - pointer to the otn server line chnl_ctxt.
*
* NOTES:
*
*
*******************************************************************************/
PRIVATE digi_otn_server_chnl_def_t* digi_sysotn_server_line_client_chnl_get(digi_handle_t* digi_handle)
{
    digi_otn_server_chnl_def_t* chnl_ctxt_ptr;

    PMC_ENTRY();

    if (digi_handle->handle_pool.sysotn_server_chnl.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) {

        chnl_ctxt_ptr = &(digi_handle->handle_pool.sysotn_server_chnl);

    } else {

        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    chnl_ctxt_ptr->header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
    chnl_ctxt_ptr->header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;

    PMC_RETURN(chnl_ctxt_ptr);
} /* digi_sysotn_server_line_client_chnl_get */


/*******************************************************************************
* digi_otn_server_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The is a helper function which obtains a digi_otn_server_chnl_def_t.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   dci_chnl               - the dci channel
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   digi_otn_server_chnl_def_t - pointer to the otn server line chnl_ctxt.
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC digi_otn_server_chnl_def_t* digi_otn_server_chnl_get(digi_handle_t* digi_handle, 
                                                            UINT32 dci_chnl)
{
    digi_otn_server_chnl_def_t* chnl_ctxt_ptr;

    PMC_ENTRY();
    
    chnl_ctxt_ptr = &(digi_handle->handle_pool.otn_server_chnl[dci_chnl]);

    PMC_RETURN(chnl_ctxt_ptr);
} /* digi_otn_server_chnl_get */

/*******************************************************************************
* digi_sysotn_server_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The is a helper function which obtains a digi_otn_server_chnl_def_t.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   digi_otn_server_chnl_def_t - pointer to the otn server line chnl_ctxt.
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC digi_otn_server_chnl_def_t* digi_sysotn_server_chnl_get(digi_handle_t* digi_handle)
{
    digi_otn_server_chnl_def_t* chnl_ctxt_ptr;

    PMC_ENTRY();
    
    chnl_ctxt_ptr = &(digi_handle->handle_pool.sysotn_server_chnl);

    PMC_RETURN(chnl_ctxt_ptr);
} /* digi_sysotn_server_chnl_get */


/*******************************************************************************
* digi_ho_odu_struct_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The is a helper function which obtains a ho_odu_struct. 
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance.
*   chnl_id                 - the ho channel id
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   odu_struct_t           - pointer to the odu_struct_t.
*
* NOTES:
*
*
*******************************************************************************/
PRIVATE odu_struct_t* digi_ho_odu_struct_chnl_get(digi_handle_t* digi_handle, 
                                                  UINT32 chnl_id)
{
    odu_struct_t* chnl_ctxt_ptr;

    PMC_ENTRY();

    if (digi_handle->handle_pool.ho_odu_struct[chnl_id].switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) {

        chnl_ctxt_ptr = &(digi_handle->handle_pool.ho_odu_struct[chnl_id]);

    } else {

        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }
    
    /* check channel range */
    if (chnl_id >= DIGI_OTN_SERVER_HO_CHNL_MAX)
    {
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
    } 

    /* initialize odu_struct fields */
    odu_struct_default_set((odu_struct_t *)chnl_ctxt_ptr);

    /* Reset the handle to the default state */
    digi_chnl_ptr_initialize(&(chnl_ctxt_ptr->switch_data));

    chnl_ctxt_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;

    chnl_ctxt_ptr->switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_COREOTN;
    chnl_ctxt_ptr->switch_data.oduk_data.channel = chnl_id;

    chnl_ctxt_ptr->switch_data.oduk_data.odu_level = UTIL_GLOBAL_LEVEL_HO_ODU;

    chnl_ctxt_ptr->switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
    chnl_ctxt_ptr->switch_data.cpb_data.channel = 0;

    PMC_RETURN(chnl_ctxt_ptr);
} /* digi_ho_odu_struct_chnl_get */

/*******************************************************************************
* digi_mo_odu_struct_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The is a helper function which obtains a mo_odu_struct. 
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   chnl_id                - the mo channel id
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   odu_struct_t - pointer to the odu_struct_t.
*
* NOTES:
*
*
*******************************************************************************/
PRIVATE odu_struct_t* digi_mo_odu_struct_chnl_get(digi_handle_t* digi_handle, 
                                                  UINT32 chnl_id)
{
    odu_struct_t* chnl_ctxt_ptr;

    PMC_ENTRY();

    if (digi_handle->handle_pool.mo_odu_struct[chnl_id].switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) {

        chnl_ctxt_ptr = &(digi_handle->handle_pool.mo_odu_struct[chnl_id]);

    } else {

        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }
    
    /* check channel range */
    if (chnl_id >= DIGI_OTN_SERVER_MO_CHNL_MAX)
    {
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
    } 

    /* initialize odu_struct fields */
    odu_struct_default_set((odu_struct_t *)chnl_ctxt_ptr);
    
    /* Reset the handle to the default state */
    digi_chnl_ptr_initialize(&(chnl_ctxt_ptr->switch_data));

    chnl_ctxt_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;

    chnl_ctxt_ptr->switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_COREOTN;
    chnl_ctxt_ptr->switch_data.oduk_data.channel = chnl_id;
    
    chnl_ctxt_ptr->switch_data.oduk_data.odu_level = UTIL_GLOBAL_LEVEL_MO_ODU;
    
    chnl_ctxt_ptr->switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
    chnl_ctxt_ptr->switch_data.cpb_data.channel = 0;

    PMC_RETURN(chnl_ctxt_ptr);
} /* digi_mo_odu_struct_chnl_get */

/*******************************************************************************
* digi_lo_odu_struct_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The is a helper function which obtains a lo_odu_struct. 
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance.
*   chnl_id                 - the lo channel id
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   odu_struct_t            - pointer to the odu_struct_t.
*
* NOTES:
*
*
*******************************************************************************/
PRIVATE odu_struct_t* digi_lo_odu_struct_chnl_get(digi_handle_t* digi_handle, 
                                                  UINT32 chnl_id)
{
    odu_struct_t* chnl_ctxt_ptr;

    PMC_ENTRY();

    if (digi_handle->handle_pool.lo_odu_struct[chnl_id].switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) {

        chnl_ctxt_ptr = &(digi_handle->handle_pool.lo_odu_struct[chnl_id]);

    } else {

        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }
    
    /* check channel range */
    if (chnl_id >= DIGI_OTN_SERVER_LO_CHNL_MAX)
    {
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
    }            
    
    /* initialize odu_struct fields */
    odu_struct_default_set((odu_struct_t *)chnl_ctxt_ptr);

    /* Reset the handle to the default state */
    digi_chnl_ptr_initialize(&(chnl_ctxt_ptr->switch_data));

    chnl_ctxt_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;

    chnl_ctxt_ptr->switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_COREOTN;
    chnl_ctxt_ptr->switch_data.oduk_data.channel = chnl_id;
    
    chnl_ctxt_ptr->switch_data.oduk_data.odu_level = UTIL_GLOBAL_LEVEL_LO_ODU;

    chnl_ctxt_ptr->switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
    chnl_ctxt_ptr->switch_data.cpb_data.channel = 0;

    chnl_ctxt_ptr->mem_ptr->odu_level = ODU_STRUCT_LEVEL_LO_ODU;
    chnl_ctxt_ptr->mem_ptr->chnl_id = chnl_id;

    PMC_RETURN(chnl_ctxt_ptr);
} /* digi_lo_odu_struct_chnl_get */  

/*******************************************************************************
* digi_s3b_odu_struct_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The is a helper function which obtains a stage 3B_odu_struct. 
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   chnl_id             - the lo channel id
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   odu_struct_t        - pointer to the odu_struct_t.
*
* NOTES:
*
*
*******************************************************************************/
PRIVATE odu_struct_t* digi_s3b_odu_struct_chnl_get(digi_handle_t* digi_handle, 
                                                   UINT32 chnl_id)
{
    odu_struct_t* chnl_ctxt_ptr = NULL;

    PMC_ENTRY();

    if (digi_handle->handle_pool.s3b_odu_struct[chnl_id].switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) {

        chnl_ctxt_ptr = &(digi_handle->handle_pool.s3b_odu_struct[chnl_id]);

    } else {

        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }
    
    /* check channel range */
    if (chnl_id >= DIGI_OTN_SERVER_LO_CHNL_MAX)
    {
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
    }            
    
    /* initialize odu_struct fields */
    odu_struct_default_set((odu_struct_t *)chnl_ctxt_ptr);

    /* Reset the handle to the default state */
    digi_chnl_ptr_initialize(&(chnl_ctxt_ptr->switch_data));

    chnl_ctxt_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;

    chnl_ctxt_ptr->switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_COREOTN;
    chnl_ctxt_ptr->switch_data.oduk_data.channel = chnl_id;
    
    chnl_ctxt_ptr->switch_data.oduk_data.odu_level = UTIL_GLOBAL_LEVEL_3B_ODU;

    chnl_ctxt_ptr->switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
    chnl_ctxt_ptr->switch_data.cpb_data.channel = 0;

    chnl_ctxt_ptr->mem_ptr->odu_level = ODU_STRUCT_LEVEL_3B_ODU;
    chnl_ctxt_ptr->mem_ptr->chnl_id = chnl_id;

    PMC_RETURN(chnl_ctxt_ptr);
} /* digi_s3b_odu_struct_chnl_get */


/*******************************************************************************
* digi_sysapp_line_odu_struct_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The is a helper function which obtains a lo_odu_struct. 
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance.
*   chnl_id                 - the lo channel id
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   odu_struct_t            - pointer to the odu_struct_t.
*
* NOTES:
*
*
*******************************************************************************/
PRIVATE odu_struct_t* digi_sysapp_line_odu_struct_chnl_get(digi_handle_t* digi_handle, 
                                                           UINT32 chnl_id)
{
    odu_struct_t* chnl_ctxt_ptr;

    odu_struct_t* sysline_ctxt_ptr;

    PMC_ENTRY();


    /*First, setup up odu_struct relating to TFRM12/RFRM12 (this is the one that will be returned by this function) */

    if (digi_handle->handle_pool.lo_odu_struct[chnl_id].switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) {

        /* SYSOTN mode will only use up to 1x of muxing.  Use the lo_odu_struct to
           keep track of the ODUKSW <-> LINE segment */
        chnl_ctxt_ptr = &(digi_handle->handle_pool.lo_odu_struct[chnl_id]);

    } else {

        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }
    
    /* initialize odu_struct fields */
    odu_struct_default_set((odu_struct_t *)chnl_ctxt_ptr);

    /* Reset the handle to the default state */
    digi_chnl_ptr_initialize(&(chnl_ctxt_ptr->switch_data));

    chnl_ctxt_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;

    chnl_ctxt_ptr->switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_ILKN1; 
    chnl_ctxt_ptr->switch_data.oduk_data.channel = chnl_id;
    
    chnl_ctxt_ptr->switch_data.oduk_data.odu_level = UTIL_GLOBAL_LEVEL_LO_ODU; 

    chnl_ctxt_ptr->switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
    chnl_ctxt_ptr->switch_data.cpb_data.channel = 0;

    chnl_ctxt_ptr->mem_ptr->odu_level = ODU_STRUCT_LEVEL_LO_ODU;
    chnl_ctxt_ptr->mem_ptr->chnl_id = chnl_id;


    /* now, set up the "SYSOTN_LINE" odu_struct pointer (this is the TFRM96/RFRM96 that could be used for
       TCM monitoring */

    if (digi_handle->handle_pool.sysotn_line_struct[chnl_id].switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG) {

        sysline_ctxt_ptr = &(digi_handle->handle_pool.sysotn_line_struct[chnl_id]);

    } else {

        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    /* Reset the handle to the default state */
    digi_chnl_ptr_initialize(&(sysline_ctxt_ptr->switch_data));

    sysline_ctxt_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;

    sysline_ctxt_ptr->switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_ILKN1;

    sysline_ctxt_ptr->switch_data.oduk_data.channel = chnl_id;
    
    sysline_ctxt_ptr->switch_data.oduk_data.odu_level = UTIL_GLOBAL_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC;

    sysline_ctxt_ptr->switch_data.cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
    sysline_ctxt_ptr->switch_data.cpb_data.channel = 0;

    sysline_ctxt_ptr->mem_ptr->odu_level = ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC;
    sysline_ctxt_ptr->mem_ptr->chnl_id = chnl_id;

    PMC_RETURN(chnl_ctxt_ptr);
} /* digi_sysapp_line_odu_struct_chnl_get */






/*******************************************************************************
* digi_cpb_input_port_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper used by both digi_cpb_chnl_demap to determine
*   the input port channel context given the output port channel context.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *output_pc_ptr   - util_global_switch_data_t pointer defining outbound port
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   util_global_switch_data_t  - A pointer to the util_global_switch_data_t defining the inbound port
*
* NOTES:
*
*******************************************************************************/
PUBLIC util_global_switch_data_t* digi_cpb_input_port_get(digi_handle_t* digi_handle,
                                                          util_global_switch_data_t *output_pc_ptr)
{
    UINT32 ingress_mux_input_port;
    UINT32 ingress_mux_input_port_chnl;
    BOOL8 is_broadcast = FALSE;
    BOOL8 is_multicast = FALSE;
        
    util_global_switch_data_t* input_pc_ptr = NULL;
    util_global_switch_data_def_t* output_pc_data_ptr = (util_global_switch_data_def_t*)output_pc_ptr;

    PMC_ENTRY();

    if (output_pc_data_ptr->header.data_key != UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID) {

        PMC_RETURN(NULL);

    } else if (output_pc_data_ptr->cpb_data.op_state.map_state.is_output_mapped == FALSE) {

        PMC_RETURN(NULL);
    }

    if (cpb_chnl_source_and_type_test(digi_handle->dcpb_handle,
                                      output_pc_data_ptr->cpb_data.port_type, 
                                      output_pc_data_ptr->cpb_data.channel,
                                      &ingress_mux_input_port,
                                      &ingress_mux_input_port_chnl,
                                      &is_broadcast,
                                      &is_multicast) != PMC_SUCCESS) {

        /* We can't determine our state. Assert. */
        PMC_RETURN(NULL);
    } else {
        /*
         * Moved the retrieval of the input port to its own function so that
         * it could also be accessible to other entities that wish to 
         * retrieve a digi handle given the port and channel value.
         */ 
        input_pc_ptr = digi_cpb_retrieve_input_port(digi_handle,
                                                    ingress_mux_input_port,
                                                    ingress_mux_input_port_chnl);
    }

    PMC_RETURN(input_pc_ptr);
} /* digi_cpb_input_port_get */



/*******************************************************************************
* FUNCTION: digi_cpb_port_chnl_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function to retrieve the CPB port and port chnl number from channel
*   handles.
*
* INPUTS:
*   digi_handle     - Pointer to digi handle
*   chnl_handle     - Pointer to a channel handle with switch data
*
* OUTPUTS:
*   port_ptr        - CPB Port id
*   chnl_ptr        - CPB Port chnl id
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_port_chnl_get(digi_handle_t               *digi_handle,
                                        util_global_switch_data_t   *chnl_handle,
                                        UINT32                      *port_ptr,
                                        UINT32                      *chnl_ptr)
{
    PMC_ERROR                        result = PMC_SUCCESS;
    util_global_switch_data_def_t   *switch_data;

    PMC_ENTRY();
        
    DIGI_CHNL_HANDLE_MAGIC_CHECK (chnl_handle);

    switch_data = (util_global_switch_data_def_t *) chnl_handle;

    *port_ptr = (UINT32) switch_data->cpb_data.port_type;
    *chnl_ptr = (UINT32) switch_data->cpb_data.channel;

    PMC_RETURN(result);
} /* digi_cpb_port_chnl_get */



/*******************************************************************************
* digi_oduksw_input_port_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper used by digi_oduksw_chnl_demap to determine
*   the input port channel context given the output port channel context.
*
* INPUTS:
*   *digi_handle                    - pointer to DIGI handle instance.
*   ingress_mux_input_port          - The ingress mux input port.
*   ingress_mux_input_port_chnl     - The ingress mux input port channel.
*   target                          - Used for ILKN1 or ILKN2 channels. 
*                                     Target determines whether the ingress 
*                                     channel should be increased if the target 
*                                     is not the CPB.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   util_global_switch_data_t  - A pointer to the util_global_switch_data_t defining the inbound port
*
* NOTES:
*
*******************************************************************************/
PUBLIC util_global_switch_data_t* digi_oduksw_input_port_get(digi_handle_t* digi_handle,
                                                             UINT32 ingress_mux_input_port,
                                                             UINT32 ingress_mux_input_port_chnl,
                                                             digi_ilkn_chnl_target_t target)
{
    PMC_ERROR result = DIGI_ERR_UNKNOWN;

    UINT32 chnl_id;
    UINT32 ho_chnl_id;
    UINT32                     num_of_recs = 0;
    coreotn_chnl_order_t       order_type;
    line_core_otn_db_query_res *q_result;
    util_global_switch_data_t* input_pc_ptr = NULL;

    PMC_ENTRY();

    /*
     * If the target is not CPB and the ingress port is ILKN1 or ILKN2 then the ingress
     * channel is in the upper 150 range versus the lower 150 range as is the case for CPB.
     * For completeness check the ingress channel against the DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX
     * in case some other entity has already handled this.
     */
    if (DIGI_ILKN_CHNL_TARGET_CPB != target &&
        (ingress_mux_input_port == UTIL_GLOBAL_ODUK_PORT_ILKN1 ||
         ingress_mux_input_port == UTIL_GLOBAL_ODUK_PORT_ILKN2) &&
        ingress_mux_input_port_chnl < DIGI_SIFD_ILKN_ODUK_DPI_CHNLS_MAX )
    {
        /*
         * For ILKN1 and SYSOTN ILKN is not actually used. In this case
         * do not want to increment the channel id.
         */
        if (!(ingress_mux_input_port == UTIL_GLOBAL_ODUK_PORT_ILKN1 &&
              digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD))
        {
            ingress_mux_input_port_chnl += DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX;
            PMC_ASSERT(ingress_mux_input_port_chnl < DIGI_SIFD_ILKN_ARB_DPI_CHANS_MAX,
                       DIGI_ERR_INVALID_ARG, 0, 0);
        }
    }

    switch(ingress_mux_input_port) {

    case UTIL_GLOBAL_ODUK_PORT_ILKN1:
        /*
         * For the SYSOTN App case ILKN1 is not where the data is. ILKN1 for
         * SYSOTN is the LineOTN connection in COREOTN which uses the lo 
         * channel structure in the digi_handle. Return that structure
         * instead.
         */
        if (digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
        {
            input_pc_ptr = (util_global_switch_data_t*)&(digi_handle->handle_pool.lo_odu_struct[ingress_mux_input_port_chnl]);
        }
        else
        {
            input_pc_ptr = (util_global_switch_data_t*)&(digi_handle->handle_pool.ilkn_1_chnl[ingress_mux_input_port_chnl]);
        }
        break;
    case UTIL_GLOBAL_ODUK_PORT_ILKN2:
        input_pc_ptr = (util_global_switch_data_t*)&(digi_handle->handle_pool.ilkn_2_chnl[ingress_mux_input_port_chnl]);
        break;
    case UTIL_GLOBAL_ODUK_PORT_COREOTN:

        /* Determine HO/MO/LO here */
        result = coreotn_chnl_id_and_order_get(digi_handle->coreotn_handle,
                                               ingress_mux_input_port_chnl,
                                               1, /*RX DB*/
                                               &chnl_id,
                                               &ho_chnl_id,
                                               &order_type,
                                               &num_of_recs,
                                               &q_result);

        if (result == PMC_SUCCESS) {

            switch(order_type) {

                /* This doesn't look correct. chnl_id being returned from coreotn_chnl_id_and_order_get() function is the HO channel ID
                ** not the current channel that needs to be demapped. input_pc_ptr will not be correct for MO and LO!!!
                ** - Fixed by adding a look-up for the current channel ID in coreotn_chnl_id_and_order_get()
                */
            case COREOTN_CHNL_ORDER_HO:
                input_pc_ptr = (util_global_switch_data_t*)&(digi_handle->handle_pool.ho_odu_struct[chnl_id]);
                break;
            case COREOTN_CHNL_ORDER_MO:
                input_pc_ptr = (util_global_switch_data_t*)&(digi_handle->handle_pool.mo_odu_struct[chnl_id]);
                break;
            case COREOTN_CHNL_ORDER_LO:
                input_pc_ptr = (util_global_switch_data_t*)&(digi_handle->handle_pool.lo_odu_struct[chnl_id]);
                break;
            default:
                PMC_ASSERT(FALSE, DIGI_ERR_UNKNOWN, 0, 0);
            }
        }
        break;
    case UTIL_GLOBAL_ODUK_PORT_MAPOTN:
        input_pc_ptr = (util_global_switch_data_t*)&(digi_handle->handle_pool.mapper_chnl[ingress_mux_input_port_chnl]);
        break;
    default:
        /* We can't determine our state. Assert. */
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    PMC_RETURN(input_pc_ptr);
} /* digi_oduksw_input_port_get */

/*******************************************************************************
* digi_sifd_config
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function which sets up the sifd-ilkn.
*
* INPUTS:
*   *digi_handle               - pointer to DIGI handle instance.
*   *digi_sifd_ilkn_1_cfg_ptr  - pointer to configuration structure detailing
*                                ILKN1 configuration.  If ILKN1 unused, set to 
*                                NULL
*   *digi_sifd_ilkn_2_cfg_ptr  - pointer to configuration structure detailing
*                                ILKN2 configuration.  If ILKN2 unused, set to 
*                                NULL
* OUTPUTS:
*   **ilkn_1_ctxt_pptr     - A pointer to a pointer to a data structure defining
*                            how the first ilkn blk was configured based on the
*                            input parameters.
*   **ilkn_2_ctxt_pptr     - A pointer to a pointer to a data structure defining
*                            how the second ilkn blk was configured based on
*                            the input parameters.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_sifd_config(digi_handle_t *digi_handle,
                                   digi_sifd_ilkn_1_cfg_t *digi_sifd_ilkn_1_cfg_ptr,
                                   digi_sifd_ilkn_2_cfg_t *digi_sifd_ilkn_2_cfg_ptr,
                                   digi_ilkn_link_t **ilkn_1_ctxt_pptr,
                                   digi_ilkn_link_t **ilkn_2_ctxt_pptr)
{
   
    PMC_ERROR result = PMC_SUCCESS;
    sifd_ilkn_1_cfg_t sifd_ilkn_1_cfg;
    sifd_ilkn_2_cfg_t sifd_ilkn_2_cfg;
    UINT32 digi_sifd_ilkn_1_cfg_t_size;
    UINT32 digi_sifd_ilkn_2_cfg_t_size;
    
    /* CPB SIFD interface configuration related variables */
    BOOL cpb_intf_en = FALSE;  
    digi_sifd_xfer_mode_t cpb_tx_xfer_mode = LAST_DIGI_SIFD_XFER_MODE;
    digi_sifd_xfer_mode_t cpb_rx_xfer_mode = LAST_DIGI_SIFD_XFER_MODE;
    digi_sifd_burst_t sifd_ilkn_burst = LAST_DIGI_SIFD_BURST;
    util_global_cpb_port_t ingress_mux_input_port = LAST_UTIL_GLOBAL_CPB_PORT;
    UINT32 ingress_mux_output_port = 999;
    UINT32 dcs_inst = 999;
    UINT32 i;
    util_global_cpb_port_t egress_mux_output_port = LAST_UTIL_GLOBAL_CPB_PORT;
    cpb_xfer_mode_t cpb_tx_xfer_mode_sub;
    cpb_xfer_mode_t cpb_rx_xfer_mode_sub;
    
    /* ODUKSW SIFD interface configuration related variables */
    BOOL oduksw_intf_en = FALSE;
    digi_sifd_xfer_mode_t oduksw_tx_xfer_mode = LAST_DIGI_SIFD_XFER_MODE;
    digi_sifd_xfer_mode_t oduksw_rx_xfer_mode = LAST_DIGI_SIFD_XFER_MODE;
    util_global_oduk_port_t oduksw_ingress_mux_input_port = LAST_UTIL_GLOBAL_ODUK_PORT;   
    util_global_oduk_port_t oduksw_egress_mux_output_port = LAST_UTIL_GLOBAL_ODUK_PORT;
    digi_sifd_burst_t oduksw_sifd_ilkn_burst = LAST_DIGI_SIFD_BURST;
    digi_sifd_oduksw_ilkn_header_t oduksw_header = LAST_DIGI_SIFD_ODUKSW_ILKN_HEADER;
    UINT32 dcs_mode;
    UINT32 oduksw_tx_xfer_mode_int;
    UINT32 oduksw_rx_xfer_mode_int;
    UINT32 hdr_removal_size;
    
    PMC_ENTRY();

    if (digi_sifd_ilkn_1_cfg_ptr != NULL) {

        digi_handle->var.sifd_1_major_mode = DIGI_SIFD_PATH_ILKN_1;

        if ( TRUE == digi_sifd_ilkn_1_cfg_ptr->ilkn.cpb_intf_en)
        {
            if (digi_handle->var.sifd_dcpb_in_use == DIGI_SIFD_2_USED) {

                digi_handle->var.sifd_dcpb_in_use = DIGI_SIFD_1_AND_2_USED;

            } else {

                digi_handle->var.sifd_dcpb_in_use = DIGI_SIFD_1_USED;
            }
        }
        digi_sifd_ilkn_1_cfg_t_size = sizeof(digi_sifd_ilkn_1_cfg_t);
        
        /* Copy the structure created by the client to the identical size var_t and
         * copy it to what should be the identical sifd structure for
         * configuring sifd. 
         */

        /* This memcpy is okay because both structures involved are of type digi_sifd_ilkn_1_cfg_t */  
        PMC_MEMCPY(&(digi_handle->var.sifd_ilkn_1_cfg), digi_sifd_ilkn_1_cfg_ptr, digi_sifd_ilkn_1_cfg_t_size);

        digi_copy_struct_ilkn_1_cfg(&sifd_ilkn_1_cfg, digi_sifd_ilkn_1_cfg_ptr);
                
        *ilkn_1_ctxt_pptr = &(digi_handle->handle_pool.ilkn_link[DIGI_SIFD_ILKN1]);

    }

    if (digi_sifd_ilkn_2_cfg_ptr != NULL) {

        digi_handle->var.sifd_2_major_mode = DIGI_SIFD_PATH_ILKN_2;
        if ( TRUE == digi_sifd_ilkn_2_cfg_ptr->ilkn.cpb_intf_en)
        {
            if (digi_handle->var.sifd_dcpb_in_use == DIGI_SIFD_1_USED) {

                digi_handle->var.sifd_dcpb_in_use = DIGI_SIFD_1_AND_2_USED;

            } else {

                digi_handle->var.sifd_dcpb_in_use = DIGI_SIFD_2_USED;
            }
        }

        /* This check is placed here so that we can ensure that both structures
         * remain the same size and instead of copying each element one at
         * a time we can shortent this with one MEMCPY. This does not take into
         * account, however, that the sizes may be the same, yet the internals
         * are different. */
        digi_sifd_ilkn_2_cfg_t_size = sizeof(digi_sifd_ilkn_2_cfg_t);

        
        /* Copy the structure created by the client to the identical size var_t and
         * copy it to what should be the identical sifd structure for
         * configuring sifd. 
         */
        PMC_MEMCPY(&(digi_handle->var.sifd_ilkn_2_cfg), digi_sifd_ilkn_2_cfg_ptr, digi_sifd_ilkn_2_cfg_t_size);
     
        digi_copy_struct_ilkn_2_cfg(&sifd_ilkn_2_cfg, digi_sifd_ilkn_2_cfg_ptr);
                
        *ilkn_2_ctxt_pptr = &(digi_handle->handle_pool.ilkn_link[DIGI_SIFD_ILKN2]);

    }

    /* initialize CPB SS DPI master ports and DCS instances driving SIFD1 and SIFD2
       if required */

    for(i=0; i<DIGI_SIFD_ILKN_NUM; i++)
    {
        switch(i)
        {
        case 0:
            if (digi_sifd_ilkn_1_cfg_ptr != NULL) {
                cpb_intf_en = digi_sifd_ilkn_1_cfg_ptr->ilkn.cpb_intf_en;
                cpb_tx_xfer_mode = digi_sifd_ilkn_1_cfg_ptr->ilkn.cpb_tx_xfer_mode;
                cpb_rx_xfer_mode = digi_sifd_ilkn_1_cfg_ptr->ilkn.rx_xfer_mode;
                sifd_ilkn_burst = digi_sifd_ilkn_1_cfg_ptr->ilkn.burst;
                ingress_mux_input_port = UTIL_GLOBAL_CPB_PORT_ILKN1;
                ingress_mux_output_port = UTIL_GLOBAL_CPB_PORT_ILKN1;
                dcs_inst = CPB_DCS_INST_0;
                egress_mux_output_port = UTIL_GLOBAL_CPB_PORT_ILKN1;
            } else {
                cpb_intf_en = FALSE;
            }
            break;
        case 1:
            if (digi_sifd_ilkn_2_cfg_ptr != NULL) {
                cpb_intf_en = digi_sifd_ilkn_2_cfg_ptr->ilkn.cpb_intf_en;
                cpb_tx_xfer_mode = digi_sifd_ilkn_2_cfg_ptr->ilkn.cpb_tx_xfer_mode;
                cpb_rx_xfer_mode = digi_sifd_ilkn_2_cfg_ptr->ilkn.rx_xfer_mode;               
                sifd_ilkn_burst = digi_sifd_ilkn_2_cfg_ptr->ilkn.burst;
                ingress_mux_input_port = UTIL_GLOBAL_CPB_PORT_ILKN2;
                ingress_mux_output_port = UTIL_GLOBAL_CPB_PORT_ILKN2;
                dcs_inst = CPB_DCS_INST_1;
                egress_mux_output_port = UTIL_GLOBAL_CPB_PORT_ILKN2;
            } else {
                cpb_intf_en = FALSE;
            }
            break;
        default:
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
            break;
        }

        if(cpb_intf_en == TRUE)
        {
            if(result==PMC_SUCCESS)
            {
                /* determine state of the CPB SS and if in lowpwr/reset state transition to a configurable state */
                digi_dcpb_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RUNNING);
            }
    
            PMC_ASSERT(cpb_tx_xfer_mode < LAST_DIGI_SIFD_XFER_MODE, DIGI_ERR_CODE_ASSERT, 0, 0);  
            PMC_ASSERT(cpb_rx_xfer_mode < LAST_DIGI_SIFD_XFER_MODE, DIGI_ERR_CODE_ASSERT, 0, 0);  
            switch(sifd_ilkn_burst)
            {
            case DIGI_SIFD_BURST_128:
                cpb_tx_xfer_mode_sub = (cpb_tx_xfer_mode == DIGI_SIFD_XFER_MODE_PACKET) ? CPB_PACKET_BURST_128:CPB_SEGMENT_BURST_128;
                cpb_rx_xfer_mode_sub = (cpb_rx_xfer_mode == DIGI_SIFD_XFER_MODE_PACKET) ? CPB_PACKET_BURST_128:CPB_SEGMENT_BURST_128;
                break;
            case DIGI_SIFD_BURST_192:
                cpb_tx_xfer_mode_sub = (cpb_tx_xfer_mode == DIGI_SIFD_XFER_MODE_PACKET) ? CPB_PACKET_BURST_192:CPB_SEGMENT_BURST_192;
                cpb_rx_xfer_mode_sub = (cpb_rx_xfer_mode == DIGI_SIFD_XFER_MODE_PACKET) ? CPB_PACKET_BURST_192:CPB_SEGMENT_BURST_192;               
                break;
            case DIGI_SIFD_BURST_256:
                cpb_tx_xfer_mode_sub = (cpb_tx_xfer_mode == DIGI_SIFD_XFER_MODE_PACKET) ? CPB_PACKET_BURST_256:CPB_SEGMENT_BURST_256;
                cpb_rx_xfer_mode_sub = (cpb_rx_xfer_mode == DIGI_SIFD_XFER_MODE_PACKET) ? CPB_PACKET_BURST_256:CPB_SEGMENT_BURST_256;               
                break;                
            default:
                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                break;
            }
    
            if(result==PMC_SUCCESS)
            {
                result = digi_cpb_input_port_init(digi_handle, 0, ingress_mux_input_port,
                                                  cpb_rx_xfer_mode_sub, DIGI_CPB_TYPE_HEADER_LENGTH);
            }
            if(result==PMC_SUCCESS)
            {
                result = cpb_dcpb_ingress_mux_output_init(digi_handle->dcpb_handle, ingress_mux_output_port, CPB_DCPB_IGR_SIFD_SEL_SIFD);
            }
    
            if(result==PMC_SUCCESS)
            {
                result = cpb_egress_mux_input_init(digi_handle->dcpb_handle, dcs_inst,
                                                   cpb_tx_xfer_mode_sub, CPB_DCS_EN_SIFD);
            }
    
            if(result==PMC_SUCCESS)
            {
                result = digi_cpb_output_port_init(digi_handle, 0, egress_mux_output_port,
                                                   cpb_tx_xfer_mode_sub, CPB_DCS_EN_SIFD);
            }
    
        }
    }

    /* initialize COREOTN ODUKSW SS DPI master ports and DCS instances driving SIFD1 
       and SIFD2 if required */
    for(i=0; i<DIGI_SIFD_ILKN_NUM; i++)
    {
        switch(i)
        {
        case 0:
            if (digi_sifd_ilkn_1_cfg_ptr != NULL) 
            {          
                /* ODUKSW port set-up */
                oduksw_intf_en = digi_sifd_ilkn_1_cfg_ptr->ilkn.oduksw_intf_en;
                oduksw_tx_xfer_mode = digi_sifd_ilkn_1_cfg_ptr->ilkn.oduksw_tx_xfer_mode;
                oduksw_rx_xfer_mode = digi_sifd_ilkn_1_cfg_ptr->ilkn.rx_xfer_mode;
                oduksw_sifd_ilkn_burst = digi_sifd_ilkn_1_cfg_ptr->ilkn.burst;
                oduksw_header = digi_sifd_ilkn_1_cfg_ptr->ilkn.oduksw_header;
                oduksw_ingress_mux_input_port = UTIL_GLOBAL_ODUK_PORT_ILKN1;
                oduksw_egress_mux_output_port = UTIL_GLOBAL_ODUK_PORT_ILKN1;
                dcs_mode = 2;
            } 
            else {
                oduksw_intf_en = FALSE;
            }
            break;
        case 1:
            if (digi_sifd_ilkn_2_cfg_ptr!=NULL)
            {   
                /* ODUKSW port set-up */
                oduksw_intf_en = digi_sifd_ilkn_2_cfg_ptr->ilkn.oduksw_intf_en;
                oduksw_tx_xfer_mode = digi_sifd_ilkn_2_cfg_ptr->ilkn.oduksw_tx_xfer_mode;
                oduksw_rx_xfer_mode = digi_sifd_ilkn_2_cfg_ptr->ilkn.rx_xfer_mode;
                oduksw_sifd_ilkn_burst = digi_sifd_ilkn_2_cfg_ptr->ilkn.burst;
                oduksw_header = digi_sifd_ilkn_2_cfg_ptr->ilkn.oduksw_header;
                oduksw_ingress_mux_input_port = UTIL_GLOBAL_ODUK_PORT_ILKN2;
                oduksw_egress_mux_output_port = UTIL_GLOBAL_ODUK_PORT_ILKN2;
                dcs_mode = 2;
            } 
            else {
                oduksw_intf_en = FALSE;
            }
            break;
        default:
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
            break;    
        }
        
        if (oduksw_intf_en == TRUE)
        {
            if (PMC_SUCCESS == result)
            {
                /* 
                   At this point, there is no data paths mapped in ODUKSW, this function set a flag 
                   to prevent optimizing energy on coreotn ODUKSW 
                */            
                digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_RUNNING,COREOTN_ODUKSW);     

                coreotn_ilkn_interface_enable(digi_handle->coreotn_handle,TRUE);
            }

            /*test if the CPB input port and output port has been initialized, if not initialized, initialized
              the port first */
            if (PMC_SUCCESS == result)
            {                                                 
                oduksw_tx_xfer_mode_int = digi_cpb_ilkn_xfer_data_get(oduksw_tx_xfer_mode, oduksw_sifd_ilkn_burst);
                oduksw_rx_xfer_mode_int = digi_cpb_ilkn_xfer_data_get(oduksw_rx_xfer_mode, oduksw_sifd_ilkn_burst);

                if (DIGI_SIFD_ODUKSW_ILKN_HEADER_2B_AND_4B == oduksw_header)
                {
                    hdr_removal_size = 6;
                }
                else if (DIGI_SIFD_ODUKSW_ILKN_HEADER_4B == oduksw_header)
                {
                    hdr_removal_size = 4;
                }
                else if (DIGI_SIFD_ODUKSW_ILKN_HEADER_2B == oduksw_header)
                {
                    hdr_removal_size = 2;
                }
                else  /* no header */
                {
                    hdr_removal_size = 0;
                }
                result = coreotn_oduksw_input_port_init(digi_handle->coreotn_handle, oduksw_ingress_mux_input_port,
                                                        (coreotn_oduksw_xfer_mode_t)oduksw_rx_xfer_mode_int, hdr_removal_size);
                                                                                              
                if (PMC_SUCCESS == result)
                {
                    result = coreotn_oduksw_egress_mux_input_init(digi_handle->coreotn_handle, oduksw_egress_mux_output_port, oduksw_tx_xfer_mode_int, dcs_mode); 
                }
                
                if (PMC_SUCCESS == result)
                {
                    result = coreotn_oduksw_output_port_init(digi_handle->coreotn_handle, oduksw_egress_mux_output_port, oduksw_tx_xfer_mode_int, 1); 
                }   
            }
        }                
    }                                                                                                                 

    /* Take SIFD subsystems out of reset if required */
    if ((PMC_SUCCESS == result) && 
        (TRUE == digi_sifd_system_required_test(digi_handle)))
    {
        digi_sifd_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RUNNING);
    }

    if (result == PMC_SUCCESS && digi_handle->var.prod_app == DIGI_PROD_APP_100G_3_X_40G_CFP_CARD)
    {
        result = digi_cfp_pins_allocate(digi_handle);
    }

    if (result == PMC_SUCCESS) {
        if(digi_sifd_ilkn_1_cfg_ptr == NULL &&  digi_sifd_ilkn_2_cfg_ptr == NULL)
        {
            result = sifd_mux_data_path_cfg(digi_handle->sifd_handle,
                                            NULL,
                                            NULL);
        }
        else if(digi_sifd_ilkn_1_cfg_ptr != NULL &&  digi_sifd_ilkn_2_cfg_ptr == NULL)
        {
            result = sifd_mux_data_path_cfg(digi_handle->sifd_handle,
                                            &sifd_ilkn_1_cfg,
                                            NULL);
        }
        else if(digi_sifd_ilkn_1_cfg_ptr == NULL &&  digi_sifd_ilkn_2_cfg_ptr != NULL)
        {
            result = sifd_mux_data_path_cfg(digi_handle->sifd_handle,
                                            NULL,
                                            &sifd_ilkn_2_cfg);
        }
        else    
        {
            result = sifd_mux_data_path_cfg(digi_handle->sifd_handle,
                                            &sifd_ilkn_1_cfg,
                                            &sifd_ilkn_2_cfg);
        }

    }

    if (result == PMC_SUCCESS) {
        result = digi_ilkn_chnl_cfg_lock_internal(digi_handle);
    }

    PMC_RETURN(result);
} /* digi_sifd_config */
  




/*******************************************************************************
* digi_non_otn_acb_ckctl_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper function to determine the ACB timing mode and the
*   serdes pin to apply the ACB routing by calling sub fucntion 
*   digi_non_otn_acb_ckctl_routing() does ACB timing routing for CPB related 
*   applications.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *input_pc_ptr    - util_global_switch_data_t pointer defining inbound port
*   *output_pc_ptr   - util_global_switch_data_t pointer defining outbound port
*    serdes_cfg_action - specify the action to perform
*   force_enet_timing_mode - when this config is set, ENET timing mode is forced 
*                            to the specified
* OUTPUTS:
*
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_non_otn_acb_ckctl_cfg(digi_handle_t *digi_handle,
                                            util_global_switch_data_t *input_pc_ptr, 
                                            util_global_switch_data_t *output_pc_ptr,
                                            digi_serdes_cfg_action_t serdes_cfg_action,
                                            digi_enet_tx_timing_mode_t force_enet_timing_mode)
{
    UINT32 port_uid = DIGI_SERDES_UNASSIGNED;
    digi_serdes_intf_t intf;
    UINT32 num_port;
    digi_serdes_port_def_t *port_def_ptr;
    util_global_switch_data_def_t *input_pc_data_ptr = NULL;
    util_global_switch_data_def_t *output_pc_data_ptr = NULL;

    util_global_cpb_port_data_t *local_input_pc_ptr = (util_global_cpb_port_data_t*)input_pc_ptr;
    util_global_cpb_port_data_t *local_output_pc_ptr = (util_global_cpb_port_data_t*)output_pc_ptr;
    
    digi_serdes_acb_mode_t acb_timing_mode = DIGI_SERDES_ACB_MODE_NOMINAL; 
    digi_enet_client_chnl_def_t *enet_chnl_handle_ptr;
    digi_mapper_chnl_def_t *mapper_chnl_handle_ptr;
    digi_mapping_mode_t mode;
    digi_enet_mode_t e_mode;
    PMC_ERROR result = PMC_SUCCESS;
    BOOL8 is_multi_lane = FALSE;
    
    PMC_ENTRY();
    
    
    input_pc_data_ptr = (util_global_switch_data_def_t *)input_pc_ptr;
    output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;
    
    local_input_pc_ptr = &(input_pc_data_ptr->cpb_data);
    local_output_pc_ptr = &(output_pc_data_ptr->cpb_data);
    
    
    if(local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE)
    {
        if(digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[local_input_pc_ptr->channel].map_type == DIGI_MAPPER_ALLOC_MAPPER_WITH_ENET_LINE)
        {
            mapper_chnl_handle_ptr = (digi_mapper_chnl_def_t*)(input_pc_ptr);
            mode = mapper_chnl_handle_ptr->mode;
        
            result = digi_mapotn_data_src_acb_mode_find(digi_handle, mode, &acb_timing_mode); 
            PMC_LOG_TRACE("DIGI_MAPPER_ALLOC_MAPPER_WITH_ENET_LINE mapping mode is:%d\n", mode);
        }
        else
        {
            enet_chnl_handle_ptr = (digi_enet_client_chnl_def_t*)(input_pc_ptr);
            e_mode = enet_chnl_handle_ptr->mode;
            result = digi_enet_data_src_acb_mode_find(digi_handle, e_mode, &acb_timing_mode);
            PMC_LOG_TRACE("NON DIGI_MAPPER_ALLOC_MAPPER_WITH_ENET_LINE mapping mode is:%d\n", e_mode);
            if (PMC_SUCCESS == result)
            {
                is_multi_lane = digi_enet_is_multi_lane_serdes_get(digi_handle,
                                                                   enet_chnl_handle_ptr);   
            }
        }
    }
    else if(local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ENET_SYS)
    {
        enet_chnl_handle_ptr = (digi_enet_client_chnl_def_t*)(input_pc_ptr);
        e_mode = enet_chnl_handle_ptr->mode;
        result = digi_enet_data_src_acb_mode_find(digi_handle, e_mode, &acb_timing_mode); 
        if (PMC_SUCCESS == result)
        {
            is_multi_lane = digi_enet_is_multi_lane_serdes_get(digi_handle,
                                                               enet_chnl_handle_ptr);               
        }
    }
    else if(local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_CBRC)
    {
        acb_timing_mode = DIGI_SERDES_ACB_MODE_C;
    }
    else if(local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_MAPOTN)
    {
        
        mapper_chnl_handle_ptr = (digi_mapper_chnl_def_t*)(input_pc_ptr);
        mode = mapper_chnl_handle_ptr->mode;
        
        result = digi_mapotn_data_src_acb_mode_find(digi_handle, mode, &acb_timing_mode);   
        
    }
    

    /* update ENET timing mode state and apply force it if applicable */
    if (PMC_SUCCESS == result && (UTIL_GLOBAL_CPB_PORT_ENET_LINE == local_output_pc_ptr->port_type ||
                                  UTIL_GLOBAL_CPB_PORT_ENET_SYS == local_output_pc_ptr->port_type))
    {
        if (force_enet_timing_mode == DIGI_ENET_TX_LOOP_TIMING_MODE)
        {
            acb_timing_mode = DIGI_SERDES_ACB_MODE_LOOP_TIMING;
        } else if (DIGI_ENET_TX_NOMINAL_TIMING_MODE == force_enet_timing_mode)
        {
            acb_timing_mode = DIGI_SERDES_ACB_MODE_NOMINAL;
        } else if(DIGI_ENET_TX_LINE_TIMING_MODE == force_enet_timing_mode)
        {
            /* we are in C mode, CKCTL mux will */
            acb_timing_mode = DIGI_SERDES_ACB_MODE_C;
        }             
    }
    PMC_LOG_TRACE("acb_timing_mode: %d \n", acb_timing_mode);
    PMC_LOG_TRACE("digi_handle->var.prod_app: %d \n", DIGI_PROD_APP_GET(digi_handle));
    PMC_LOG_TRACE("digi_handle->var.port_type: %d \n", local_output_pc_ptr->port_type);  

    
    if(((DIGI_SERDES_ACB_MODE_NOMINAL != acb_timing_mode && DIGI_SERDES_PROV_ALIGNER_ONLY != serdes_cfg_action) ||
        DIGI_SERDES_ENET_OTN_MAX_PPM_SET == serdes_cfg_action||
        ((is_multi_lane == TRUE && DIGI_SERDES_ACB_MODE_NOMINAL == acb_timing_mode) &&
         (DIGI_SERDES_PROV_ALIGNER_ONLY == serdes_cfg_action ||
          DIGI_SERDES_DEPROV == serdes_cfg_action ||
          DIGI_SERDES_DEACTIVATE == serdes_cfg_action))) 
       && PMC_SUCCESS == result)
    {
        if (DIGI_PROD_APP_IS_TRANSMUXPONDER_CARD(digi_handle)
            || DIGI60_PROD_APP_IS_TRANSMUXPONDER_SYS_CLIENT_CARD(digi_handle)) 

        {
            if((UTIL_GLOBAL_CPB_PORT_ENET_SYS == local_output_pc_ptr->port_type) ||
               (UTIL_GLOBAL_CPB_PORT_CBRC == local_output_pc_ptr->port_type &&
                DIGI_CBRC_IS_SYS_INTF(digi_handle)))
            {
                port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[local_output_pc_ptr->channel].port_uid;
            }
            else
            {
                port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[local_output_pc_ptr->channel].port_uid;
            }
        }
        else if (DIGI_PROD_APP_IS_100G_3X40G_CFP_CARD(digi_handle))
        {
            port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[local_output_pc_ptr->channel].port_uid;
            if(DIGI_SERDES_UNASSIGNED == port_uid)
            {
                port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[local_output_pc_ptr->channel].port_uid;
            }
        }
        else 
        {            
            if (UTIL_GLOBAL_CPB_PORT_CBRC == local_output_pc_ptr->port_type)
            {
                port_uid = ((digi_cbr_client_chnl_def_t*)output_pc_data_ptr)->port_uid;            
            }
            else
            {
                port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[local_output_pc_ptr->channel].port_uid;     
            }
        }
    
        /* Get the number of port, we need it to know we provision multi-lane alignment when the ACB is in nominal mode */
        /* it is also for the configuration of ACB in other timing mode */       
        num_port = digi_by_port_uid_num_port_get(digi_handle, port_uid);       
        /* convert num_port in number of data lane (SFI5.1 is an exception elsewhere */
        if (num_port >= DIGI_MIN_SERDES_LANES_FOR_100G) 
        {
            num_port = DIGI_MIN_SERDES_LANES_FOR_100G;

        } else if (num_port >= DIGI_MIN_SERDES_LANES_FOR_40G) 
        {
            num_port = DIGI_MIN_SERDES_LANES_FOR_40G;
        }
            
        /* Search for the port and find the interface */
        port_def_ptr = digi_port_ctxt_and_intf_find(digi_handle,
                                                    port_uid,
                                                    &intf);

        if (port_def_ptr != NULL) {

            switch(intf) {

            case DIGI_SERDES_LINE_INTF:
                result = digi_non_otn_acb_ckctl_line_cfg(digi_handle,
                                                         input_pc_ptr,
                                                         output_pc_ptr,
                                                         serdes_cfg_action,
                                                         acb_timing_mode,
                                                         num_port,
                                                         port_uid,
                                                         port_def_ptr->master_lane,
                                                         force_enet_timing_mode);

                break;
            case DIGI_SERDES_SFI_51_INTF:
                result = digi_non_otn_acb_ckctl_xfi51_cfg(digi_handle,
                                                          input_pc_ptr,
                                                          output_pc_ptr,
                                                          serdes_cfg_action,
                                                          acb_timing_mode,
                                                          num_port,
                                                          port_uid,
                                                          port_def_ptr->master_lane);
                break;
            case DIGI_SERDES_SYSTEM_INTF:
                result = digi_non_otn_acb_ckctl_sys_cfg(digi_handle,
                                                        input_pc_ptr,
                                                        output_pc_ptr,
                                                        serdes_cfg_action,
                                                        acb_timing_mode,
                                                        num_port,
                                                        port_uid,
                                                        port_def_ptr->master_lane,
                                                        force_enet_timing_mode);
                break;
            default:
                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                break;
            }

        }
        else
        {
            result = DIGI_ERR_SERDES_PORT_NOT_PROV;
        }
    }
    PMC_RETURN(result);
   
} /* digi_non_otn_acb_ckctl_cfg */



/*******************************************************************************
* digi_non_otn_acb_reprov_pkt_size_configs
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper function to determine the ACB timing mode and the
*   serdes pin to apply the ACB routing by calling sub fucntion 
*   digi_non_otn_acb_ckctl_routing() does ACB timing routing for CPB related 
*   applications.
*   
*   This API is only used when reprovisioning the packet size at the ODUKSW
*   at FO2.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *input_pc_ptr    - util_global_switch_data_t pointer defining inbound port
*   *output_pc_ptr   - util_global_switch_data_t pointer defining outbound port
*   force_enet_timing_mode - when this config is set, ENET timing mode is forced 
*                            to the specified
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_non_otn_acb_reprov_pkt_size_configs(digi_handle_t *digi_handle,
                                                           util_global_switch_data_t *input_pc_ptr, 
                                                           util_global_switch_data_t *output_pc_ptr,
                                                           digi_enet_tx_timing_mode_t force_enet_timing_mode)
{
    UINT32 port_uid;
    digi_serdes_intf_t intf;
    UINT32 num_port;
    digi_serdes_port_def_t *port_def_ptr;
    util_global_switch_data_def_t *input_pc_data_ptr = NULL;
    util_global_switch_data_def_t *output_pc_data_ptr = NULL;

    util_global_cpb_port_data_t *local_input_pc_ptr = (util_global_cpb_port_data_t*)input_pc_ptr;
    util_global_cpb_port_data_t *local_output_pc_ptr = (util_global_cpb_port_data_t*)output_pc_ptr;
    
    digi_serdes_acb_mode_t acb_timing_mode = DIGI_SERDES_ACB_MODE_NOMINAL; 
    digi_mapper_chnl_def_t *mapper_chnl_handle_ptr;
    digi_mapping_mode_t mode;
    PMC_ERROR result = PMC_SUCCESS;

    BOOL8 is_multicast = FALSE;
    BOOL8 is_broadcast = FALSE;
    BOOL8 is_reader_primary = FALSE;
    BOOL8 is_slave_zone_primary = FALSE;
    util_global_cpb_port_data_t local_input_pc;

    UINT32 i;
    UINT32 serdes_pin;
    acb_ft_prov_cfg_t acb_ft_prov_cfg;


    PMC_ENTRY();
    
    
    input_pc_data_ptr = (util_global_switch_data_def_t *)input_pc_ptr;
    output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;
    
    local_input_pc_ptr = &(input_pc_data_ptr->cpb_data);
    local_output_pc_ptr = &(output_pc_data_ptr->cpb_data);

      if(local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_MAPOTN)
    {
        mapper_chnl_handle_ptr = (digi_mapper_chnl_def_t*)(input_pc_ptr);
        mode = mapper_chnl_handle_ptr->mode;
        
        result = digi_mapotn_data_src_acb_mode_find(digi_handle, mode, &acb_timing_mode);   
    }
    else
    {
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }


    PMC_LOG_TRACE("acb_timing_mode: %d \n", acb_timing_mode);
    PMC_LOG_TRACE("digi_handle->var.prod_app: %d \n", DIGI_PROD_APP_GET(digi_handle));
    PMC_LOG_TRACE("digi_handle->var.port_type: %d \n", local_output_pc_ptr->port_type);  


    if(PMC_SUCCESS == result &&
       !(DIGI_SERDES_ACB_MODE_NOMINAL == acb_timing_mode))
    {
        
            if(result == PMC_SUCCESS)
            {
                    /*get the MPMO instance*/
                    result = cpb_chnl_source_type_and_primary_test(digi_handle->dcpb_handle,
                                                                   local_output_pc_ptr->port_type,
                                                                   local_output_pc_ptr->channel,
                                                                   (UINT32*)&(local_input_pc.port_type),
                                                                   &(local_input_pc.channel),
                                                                   &is_broadcast,
                                                                   &is_multicast,
                                                                   &is_reader_primary,
                                                                   &is_slave_zone_primary);
                }
        
            if(result == PMC_SUCCESS)
            {
                digi_opsa_cpb_activate_cfg(digi_handle,
                                           input_pc_ptr,
                                           output_pc_ptr,
                                           is_reader_primary,
                                           is_slave_zone_primary,
                                           DIGI_OPSA_CFG_ACTION_DEACTIVATE,
                                           FALSE); /*RELEASE*/
            }       
        
        
        if (DIGI_PROD_APP_IS_TRANSMUXPONDER_CARD(digi_handle)
            || DIGI60_PROD_APP_IS_TRANSMUXPONDER_SYS_CLIENT_CARD(digi_handle)) 
        {
            if((UTIL_GLOBAL_CPB_PORT_ENET_SYS == local_output_pc_ptr->port_type) ||
               (UTIL_GLOBAL_CPB_PORT_CBRC == local_output_pc_ptr->port_type &&
                DIGI_CBRC_IS_SYS_INTF(digi_handle)))
            {
                port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[local_output_pc_ptr->channel].port_uid;
            }
            else
            {
                port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[local_output_pc_ptr->channel].port_uid;
            }
        }
        else if (DIGI_PROD_APP_IS_100G_3X40G_CFP_CARD(digi_handle))
        {
            port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[local_output_pc_ptr->channel].port_uid;
            if(DIGI_SERDES_UNASSIGNED == port_uid)
            {
                port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[local_output_pc_ptr->channel].port_uid;
            }
        }
        else 
        {            
            port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[local_output_pc_ptr->channel].port_uid;            
        }
    
        /* Get the number of port, we need it to know we provision multi-lane alignment when the ACB is in nominal mode */
        /* it is also for the configuration of ACB in other timing mode */       
        num_port = digi_by_port_uid_num_port_get(digi_handle, port_uid);       
        /* convert num_port in number of data lane (SFI5.1 is an exception elsewhere */
        if (num_port >= DIGI_MIN_SERDES_LANES_FOR_100G) 
        {
            num_port = DIGI_MIN_SERDES_LANES_FOR_100G;

        } else if (num_port >= DIGI_MIN_SERDES_LANES_FOR_40G) 
        {
            num_port = DIGI_MIN_SERDES_LANES_FOR_40G;
        }
           




        /* Search for the port and find the interface */
        port_def_ptr = digi_port_ctxt_and_intf_find(digi_handle,
                                                    port_uid,
                                                    &intf);


        if (port_def_ptr != NULL) {

            PMC_MEMSET((void *)&acb_ft_prov_cfg, 0, sizeof(acb_ft_prov_cfg_t));

            switch(intf)
            {
            case DIGI_SERDES_LINE_INTF:

                for(i=0;i<DIGI_SERDES_XFI_LANES_MAX;i++)
                {
                    if(PMC_SUCCESS == result && digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid == port_uid)
                    {
                        serdes_pin = i;
                        acb_ft_prov_cfg.max_ppm = DIGI_SERDES_MAX_PPM_COMPUTE(DIGI_SERDES_ENET_MAX_PPM, DIGI_SERDES_ENET_MAX_PPM);

                        result = digi_serdes_non_otn_acb_reprov_pkt_size_configs(digi_handle, 
                                                                                 serdes_pin, 
                                                                                 port_def_ptr->master_lane ,
                                                                                 intf, 
                                                                                 input_pc_ptr, 
                                                                                 output_pc_ptr, 
                                                                                 acb_timing_mode,
                                                                                 num_port,
                                                                                 force_enet_timing_mode, 
                                                                                 (acb_ft_prov_cfg_t *)&acb_ft_prov_cfg);
                    }
                }

                break;
            case DIGI_SERDES_SYSTEM_INTF:

                for (i = 0; i < DIGI_SERDES_SYS_LANES_MAX; i++)
                {
                    if(PMC_SUCCESS == result && digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid == port_uid)
                    {
                        serdes_pin = i;
                        acb_ft_prov_cfg.max_ppm = DIGI_SERDES_MAX_PPM_COMPUTE(DIGI_SERDES_ENET_MAX_PPM, DIGI_SERDES_ENET_MAX_PPM);

                        result = digi_serdes_non_otn_acb_reprov_pkt_size_configs(digi_handle, 
                                                                                 serdes_pin, 
                                                                                 port_def_ptr->master_lane ,
                                                                                 intf, 
                                                                                 input_pc_ptr, 
                                                                                 output_pc_ptr, 
                                                                                 acb_timing_mode,
                                                                                 num_port,
                                                                                 force_enet_timing_mode, 
                                                                                 (acb_ft_prov_cfg_t *)&acb_ft_prov_cfg);
                    }
                }

                break;
            case DIGI_SERDES_SFI_51_INTF:

                for (i = 0; i < DIGI_NUM_SFI51_PORTS_MAX; i++) 
                {
                    if(PMC_SUCCESS == result && digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[i].port_uid == port_uid)
                    {
                        serdes_pin = i;
                        acb_ft_prov_cfg.max_ppm = DIGI_SERDES_MAX_PPM_COMPUTE(DIGI_SERDES_ENET_MAX_PPM, DIGI_SERDES_ENET_MAX_PPM);

                        result = digi_serdes_non_otn_acb_reprov_pkt_size_configs(digi_handle, 
                                                                                 serdes_pin, 
                                                                                 port_def_ptr->master_lane ,
                                                                                 intf, 
                                                                                 input_pc_ptr, 
                                                                                 output_pc_ptr, 
                                                                                 acb_timing_mode,
                                                                                 num_port,
                                                                                 force_enet_timing_mode, 
                                                                                 (acb_ft_prov_cfg_t *)&acb_ft_prov_cfg);
                    }
                }

                break;
            default:
                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                break;        
            }
        }
        else
        {
            result = DIGI_ERR_SERDES_PORT_NOT_PROV;
        }
        
            if(result == PMC_SUCCESS)
            {
                digi_opsa_cpb_activate_cfg(digi_handle,
                                           input_pc_ptr,
                                           output_pc_ptr,
                                           is_reader_primary,
                                           is_slave_zone_primary,
                                           DIGI_OPSA_CFG_ACTION_ACTIVATE,
                                           FALSE);
            }        
        
    }

    PMC_RETURN(result);
   
} /* digi_non_otn_acb_reprov_pkt_size_configs */

/*******************************************************************************
* digi_non_otn_acb_ckctl_line_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper function to determine the ACB timing mode and the
*   serdes pin to apply the ACB routing by calling sub fucntion 
*   digi_non_otn_acb_ckctl_routing() does ACB timing routing for CPB related 
*   applications.
*   This is for the line interface only.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *input_pc_ptr    - util_global_switch_data_t pointer defining inbound port
*   *output_pc_ptr   - util_global_switch_data_t pointer defining outbound port
*    serdes_cfg_action - specify the action to perform
*    acb_timing_mode - ACB mode of operation.
*    num_port        - the normalized num of lanes used.
*    port_uid        - the port_uid to match.
*    master_lane     - the lane to set as the master. This should be the first
*                      lane of the port
*   force_enet_timing_mode - when this config is set, ENET timing mode is forced 
*                            to the specified
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_non_otn_acb_ckctl_line_cfg(digi_handle_t *digi_handle,
                                                  util_global_switch_data_t *input_pc_ptr,
                                                  util_global_switch_data_t *output_pc_ptr,
                                                  digi_serdes_cfg_action_t serdes_cfg_action,
                                                  digi_serdes_acb_mode_t acb_timing_mode,
                                                  UINT32 num_port,
                                                  UINT32 port_uid,
                                                  UINT32 master_lane,
                                                  digi_enet_tx_timing_mode_t force_enet_timing_mode)
{
    UINT32 i;
    UINT32 ckctl_port;
    UINT32 serdes_pin; 
    digi_serdes_intf_t intf = DIGI_SERDES_LINE_INTF;
    acb_ft_prov_cfg_t  acb_ft_prov_cfg;
    BOOL8 use_digi_m1 = FALSE;
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 ckctl_port_offset = 0;
    PMC_ENTRY();

    /* Retrieve CKCTL port offset */
    if (DIGI_SERDES_PROV == serdes_cfg_action)
    {
        result = digi_otn_mpmo_ckctl_port_offset_get(digi_handle, intf, &ckctl_port_offset);
        use_digi_m1 = force_enet_timing_mode == DIGI_ENET_TX_LINE_TIMING_MODE?TRUE:FALSE;
    }
    
    for(i=0;i<DIGI_SERDES_XFI_LANES_MAX && PMC_SUCCESS == result;i++)
    {
        if(PMC_SUCCESS == result && digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid == port_uid)
        {
            serdes_pin = i; 
            acb_ft_prov_cfg.max_ppm = DIGI_SERDES_MAX_PPM_COMPUTE(DIGI_SERDES_ENET_MAX_PPM, DIGI_SERDES_ENET_MAX_PPM);
            PMC_LOG_TRACE("ENET MAX_PPM = %d\n", acb_ft_prov_cfg.max_ppm);
            switch (serdes_cfg_action)
            {
            case DIGI_SERDES_PROV:
            {
                ckctl_port = serdes_pin + ckctl_port_offset;   
                if (acb_timing_mode != DIGI_SERDES_ACB_MODE_LOOP_TIMING)
                {                    
                    result = digi_non_otn_acb_ckctl_routing(digi_handle, input_pc_ptr, output_pc_ptr, acb_timing_mode, intf, ckctl_port, use_digi_m1);   
                }
                if(PMC_SUCCESS == result)
                {
                    result = digi_serdes_non_otn_acb_cfg(digi_handle, 
                                                         serdes_pin, 
                                                         master_lane ,
                                                         intf, 
                                                         input_pc_ptr, 
                                                         output_pc_ptr, 
                                                         acb_timing_mode,
                                                         num_port,
                                                         force_enet_timing_mode, 
                                                         (acb_ft_prov_cfg_t *)&acb_ft_prov_cfg);

                }
                break;
            }
            case DIGI_SERDES_DEPROV:  
            {
                result = s16_deprov(digi_handle->s16_line_handle, serdes_pin);                      
                break;
            }
            case DIGI_SERDES_ACTIVATE: 
            {
                result = s16_activate(digi_handle->s16_line_handle, 
                                      serdes_pin, TRUE);  
                break;
            }
            case DIGI_SERDES_DEACTIVATE:
            {            
                if (PMC_SUCCESS == result)
                {
                    result = s16_deactivate(digi_handle->s16_line_handle, serdes_pin);      
                }
                break;
            }
            case DIGI_SERDES_ENET_OTN_MAX_PPM_SET:
                s16_max_ppm_set(digi_handle->s16_line_handle, serdes_pin,  DIGI_SERDES_MAX_PPM_COMPUTE(DIGI_SERDES_ENET_MAX_PPM, DIGI_SERDES_OTN_MAX_PPM));
                break;
            case DIGI_SERDES_PROV_ALIGNER_ONLY:
                acb_ft_prov_cfg.mode = ACB_FT_MODE_NOMINAL;
                result = s16_prov(digi_handle->s16_line_handle, serdes_pin,master_lane,&acb_ft_prov_cfg, S16_CLK_CFG_NOT_CLK_LANE);

                if(PMC_SUCCESS == result)
                {
                    result = s16_activate(digi_handle->s16_line_handle, 
                                          serdes_pin, TRUE); 
                }
                break;
            default:
            {
                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                break;
            }
            }             
        } 
    }
    /*  configure an additional serdes as a clock when it is configured */
    if (PMC_SUCCESS == result)
    {
        result = digi_s16_clk_acb_cfg(digi_handle, intf, port_uid, master_lane, serdes_cfg_action,&acb_ft_prov_cfg, FALSE);
    }
    PMC_RETURN(result);

} /* digi_non_otn_acb_ckctl_line_cfg */

/*******************************************************************************
* digi_non_otn_acb_ckctl_xfi51_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper function to determine the ACB timing mode and the
*   serdes pin to apply the ACB routing by calling sub fucntion 
*   digi_non_otn_acb_ckctl_routing() does ACB timing routing for CPB related 
*   applications.
*   This is for the xfi51 interface only.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *input_pc_ptr    - util_global_switch_data_t pointer defining inbound port
*   *output_pc_ptr   - util_global_switch_data_t pointer defining outbound port
*    serdes_cfg_action - specify the action to perform
*    acb_timing_mode - ACB mode of operation.
*    num_port        - the normalized num of lanes used.
*    port_uid        - the port_uid to match.
*    master_lane     - the lane to set as the master. This should be the first
*                      lane of the port
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_non_otn_acb_ckctl_xfi51_cfg(digi_handle_t *digi_handle,
                                                   util_global_switch_data_t *input_pc_ptr,
                                                   util_global_switch_data_t *output_pc_ptr,
                                                   digi_serdes_cfg_action_t serdes_cfg_action,
                                                   digi_serdes_acb_mode_t acb_timing_mode,
                                                   UINT32 num_port,
                                                   UINT32 port_uid,
                                                   UINT32 master_lane)
{
    UINT32 i;
    UINT32 ckctl_port;
    UINT32 serdes_pin; 
    digi_serdes_intf_t intf = DIGI_SERDES_SFI_51_INTF;
    PMC_ERROR result = PMC_SUCCESS;
    acb_ft_prov_cfg_t acb_ft_prov_cfg;
    UINT32 ckctl_port_offset = 0;

    PMC_ENTRY();

    /* Retrieve CKCTL port offset */
    if (DIGI_SERDES_PROV == serdes_cfg_action)
    {
        result = digi_otn_mpmo_ckctl_port_offset_get(digi_handle, intf, &ckctl_port_offset);
    }

    for (i = 0; i < DIGI_NUM_SFI51_PORTS_MAX && PMC_SUCCESS == result; i++) 
    {
        if(digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[i].port_uid == port_uid)
        {
            serdes_pin = i;
            acb_ft_prov_cfg.max_ppm = DIGI_SERDES_MAX_PPM_COMPUTE(DIGI_SERDES_ENET_MAX_PPM, DIGI_SERDES_ENET_MAX_PPM);

            ckctl_port = serdes_pin + ckctl_port_offset;
            
            switch (serdes_cfg_action)
            {
            case DIGI_SERDES_PROV:
            {
                if (acb_timing_mode != DIGI_SERDES_ACB_MODE_LOOP_TIMING)
                {                                        
                    result = digi_non_otn_acb_ckctl_routing(digi_handle, input_pc_ptr, output_pc_ptr, acb_timing_mode, intf, ckctl_port, FALSE );
                }
                if(PMC_SUCCESS == result)
                {
                    /* in SFI5.1 case, we don't care about the master lane */
                    result = digi_serdes_non_otn_acb_cfg(digi_handle, serdes_pin, master_lane ,intf, input_pc_ptr, output_pc_ptr, acb_timing_mode,num_port,LAST_DIGI_ENET_TX_TIMING_MODE,&acb_ft_prov_cfg);
                }       
                break;
            }
            case DIGI_SERDES_DEPROV:  
            {
                result = sfi51_d8_tx_18x_deprov(digi_handle->sfi51_d8_tx_18x_handle[i]);     
                break;
            }
            case DIGI_SERDES_ACTIVATE: 
            {
                result = sfi51_d8_tx_18x_activate(digi_handle->sfi51_d8_tx_18x_handle[i]);     
                break;
            }
            case DIGI_SERDES_DEACTIVATE:
            {
                result = sfi51_d8_tx_18x_deactivate(digi_handle->sfi51_d8_tx_18x_handle[i]);     
                break;
            }
            case DIGI_SERDES_ENET_OTN_MAX_PPM_SET:
                sfi51_d8_tx_18x_max_ppm_set(digi_handle->sfi51_d8_tx_18x_handle[i], DIGI_SERDES_MAX_PPM_COMPUTE(DIGI_SERDES_ENET_MAX_PPM, DIGI_SERDES_OTN_MAX_PPM));
                break;
            case DIGI_SERDES_PROV_ALIGNER_ONLY:
                acb_ft_prov_cfg.mode = ACB_FT_MODE_NOMINAL; 
                result = sfi51_d8_tx_18x_prov(digi_handle->sfi51_d8_tx_18x_handle[i], &acb_ft_prov_cfg);
                if (PMC_SUCCESS == result)
                {
                    result = sfi51_d8_tx_18x_activate(digi_handle->sfi51_d8_tx_18x_handle[i]);
                }
                break;
            default:
            {
                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                break;
            }
            }                
        }
        
    }

    PMC_RETURN(result);
} /* digi_non_otn_acb_ckctl_xfi51_cfg */

/*******************************************************************************
* digi_non_otn_acb_ckctl_sys_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper function to determine the ACB timing mode and the
*   serdes pin to apply the ACB routing by calling sub fucntion 
*   digi_non_otn_acb_ckctl_routing() does ACB timing routing for CPB related 
*   applications.
*   This is for the system interface only.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *input_pc_ptr    - util_global_switch_data_t pointer defining inbound port
*   *output_pc_ptr   - util_global_switch_data_t pointer defining outbound port
*    serdes_cfg_action - specify the action to perform
*    acb_timing_mode - ACB mode of operation.
*    num_port        - the normalized num of lanes used.
*    port_uid        - the port_uid to match.
*    master_lane     - the lane to set as the master. This should be the first
*                      lane of the port
*   force_enet_timing_mode - when this config is set, ENET timing mode is forced 
*                            to the specified
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_non_otn_acb_ckctl_sys_cfg(digi_handle_t *digi_handle,
                                                 util_global_switch_data_t *input_pc_ptr,
                                                 util_global_switch_data_t *output_pc_ptr,
                                                 digi_serdes_cfg_action_t serdes_cfg_action,
                                                 digi_serdes_acb_mode_t acb_timing_mode,
                                                 UINT32 num_port,
                                                 UINT32 port_uid,
                                                 UINT32 master_lane,
                                                 digi_enet_tx_timing_mode_t force_enet_timing_mode)
{
    UINT32 i;
    UINT32 ckctl_port;
    UINT32 serdes_pin; 
    acb_ft_prov_cfg_t  acb_ft_prov_cfg;
    digi_serdes_intf_t intf = DIGI_SERDES_SYSTEM_INTF;
    BOOL8 use_digi_m1 = FALSE;
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 ckctl_port_offset = 0;

    PMC_ENTRY();

    if (DIGI_SERDES_PROV == serdes_cfg_action)
    {
        /* Retrieve CKCTL port offset */
        result = digi_otn_mpmo_ckctl_port_offset_get(digi_handle, intf, &ckctl_port_offset);

        use_digi_m1 = force_enet_timing_mode == DIGI_ENET_TX_LINE_TIMING_MODE?TRUE:FALSE;
    }

    for (i = 0; i < DIGI_SERDES_SYS_LANES_MAX && PMC_SUCCESS == result; i++) 
    {
        if(digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid == port_uid)
        {
            serdes_pin = i;
            acb_ft_prov_cfg.max_ppm = DIGI_SERDES_MAX_PPM_COMPUTE(DIGI_SERDES_ENET_MAX_PPM, DIGI_SERDES_ENET_MAX_PPM);
            PMC_LOG_TRACE("ENET MAX_PPM = %d\n", acb_ft_prov_cfg.max_ppm);
    

            switch (serdes_cfg_action)
            {
            case DIGI_SERDES_PROV:
            {
                ckctl_port = serdes_pin + DIGI_SERDES_XFI_LANES_MAX + DIGI_NUM_SFI51_PORTS_MAX;
                if (acb_timing_mode != DIGI_SERDES_ACB_MODE_LOOP_TIMING)
                {                                                            
                    result = digi_non_otn_acb_ckctl_routing(digi_handle, input_pc_ptr, output_pc_ptr, acb_timing_mode, intf, ckctl_port, use_digi_m1);   
                }
                if(PMC_SUCCESS == result)
                {
                    result = digi_serdes_non_otn_acb_cfg(digi_handle, serdes_pin, master_lane ,intf, input_pc_ptr, output_pc_ptr, acb_timing_mode,num_port,force_enet_timing_mode,&acb_ft_prov_cfg);
                }
                break;
            }               
            case DIGI_SERDES_DEPROV:  
            {
                result = s16_deprov(digi_handle->s16_sys_handle, serdes_pin);                      
                break;
            }
            case DIGI_SERDES_ACTIVATE: 
            {
              result = s16_activate(digi_handle->s16_sys_handle, 
                                    serdes_pin, TRUE);  
                break;
            }
            case DIGI_SERDES_DEACTIVATE:
            {
                if (PMC_SUCCESS == result)
                {
                    result = s16_deactivate(digi_handle->s16_sys_handle, serdes_pin);      
                }
                break;
            }
            case DIGI_SERDES_ENET_OTN_MAX_PPM_SET:
                s16_max_ppm_set(digi_handle->s16_sys_handle, serdes_pin,  DIGI_SERDES_MAX_PPM_COMPUTE(DIGI_SERDES_ENET_MAX_PPM, DIGI_SERDES_OTN_MAX_PPM));
                break;
            case DIGI_SERDES_PROV_ALIGNER_ONLY:
                acb_ft_prov_cfg.mode = ACB_FT_MODE_NOMINAL;
                result = s16_prov(digi_handle->s16_sys_handle, serdes_pin,
                                  master_lane, &acb_ft_prov_cfg,
                                  S16_CLK_CFG_NOT_CLK_LANE);   

                if (PMC_SUCCESS == result)
                {
                    result = s16_activate(digi_handle->s16_sys_handle, 
                                          serdes_pin, TRUE); 
                }
                break;
            default:
            {
                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                break;
            }
            }   

            /*  configure an additional serdes as a clock when it is configured */
            if (PMC_SUCCESS == result)
            {
                result = digi_s16_clk_acb_cfg(digi_handle, intf, port_uid, master_lane, serdes_cfg_action,&acb_ft_prov_cfg, FALSE);
            }
        }
    }

    PMC_RETURN(result);
} /* digi_non_otn_acb_ckctl_sys_cfg */

/*******************************************************************************
* digi_non_otn_acb_ckctl_routing
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper function that applies ACB CKCTL routing for CPB 
*   related applications based on ACB timing mode.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *input_pc_ptr    - util_global_switch_data_t pointer defining inbound port
*   *output_pc_ptr   - util_global_switch_data_t pointer defining outbound port
*   acb_timing_mode  - ACB timing mode of operation see digi_serdes_acb_mode_t
*                      for valid values
*   intf             - Interface configuration related to, valid
*                      values:\n
*                      DIGI_SERDES_LINE_INTF\n
*                      DIGI_SERDES_SYSTEM_INTF\n
*                      DIGI_SERDES_SFI_51_INTF
*   ckctl_port       - clock control port number (0-25): \n
*                      Ports 0--11 are line side 10G SERDES. \n
*                      Ports 12--13 are line side 2.5G SERDES. \n
*                      Ports 14--25 are system side 10G SERDES. \n
*   use_digi_m1      - Force the use of DIGI_M1 CKCTL as the source
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_non_otn_acb_ckctl_routing(digi_handle_t *digi_handle,
                                                 util_global_switch_data_t *input_pc_ptr, 
                                                 util_global_switch_data_t *output_pc_ptr,
                                                 digi_serdes_acb_mode_t acb_timing_mode,
                                                 digi_serdes_intf_t intf,
                                                 UINT32 ckctl_port,
                                                 BOOL8 use_digi_m1)
{
    
    lifd_sig_src_type_t acb_if_sel_clk_source = LIFD_SRC_NONE;
    
    util_global_switch_data_def_t *input_pc_data_ptr = NULL;
    util_global_switch_data_def_t *output_pc_data_ptr = NULL;

    util_global_cpb_port_data_t *local_input_pc_ptr = (util_global_cpb_port_data_t*)input_pc_ptr;
    util_global_cpb_port_data_t *local_output_pc_ptr = (util_global_cpb_port_data_t*)output_pc_ptr;
    UINT32 serdes_lane;
    UINT32 port = 0, serdes_port = 0;
    UINT32 fo2_ckctl_port = 999;
    
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();
    
    input_pc_data_ptr = (util_global_switch_data_def_t *)input_pc_ptr;
    output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;
    
    local_input_pc_ptr = &(input_pc_data_ptr->cpb_data);
    local_output_pc_ptr = &(output_pc_data_ptr->cpb_data);
    
    PMC_LOG_TRACE("\n local_output_pc_ptr->port_type:%d\
               \n local_input_pc_ptr->port_type:%d\
               \n local_output_pc_ptr->channel:%d\
               \n local_input_pc_ptr->channel:%d\
               \n acb_timing_mode:%d\
               \n intf:%d\
               \n ckctl_port:%d\
               \n use_digi_m1:%d\n", 
                  local_output_pc_ptr->port_type, local_input_pc_ptr->port_type,local_output_pc_ptr->channel, 
                  local_input_pc_ptr->channel, acb_timing_mode, intf, ckctl_port,use_digi_m1);
    
    
    switch(local_output_pc_ptr->port_type)
    {
    case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
        if(TRUE == use_digi_m1)
        {
            acb_if_sel_clk_source = LIFD_SRC_DIG_M1; 
        }
        else if(DIGI_SERDES_ACB_MODE_B_ON_C == acb_timing_mode)
        {
            acb_if_sel_clk_source = LIFD_SRC_OTN_IPM_ENET;  
        }
        else if(DIGI_SERDES_ACB_MODE_B_AND_C == acb_timing_mode)
        {
            acb_if_sel_clk_source = LIFD_SRC_ENET; /* value of 0x2*/
        }
        else if(DIGI_SERDES_ACB_MODE_C == acb_timing_mode)
        {
            acb_if_sel_clk_source = LIFD_SRC_ENET; /* value of 0x2*/
        }
            
        if(DIGI_SERDES_SYSTEM_INTF == intf)
        {
            serdes_port = ckctl_port - (DIGI_SERDES_XFI_LANES_MAX + DIGI_NUM_SFI51_PORTS_MAX);
            lifd_serdes_c_ckctl_source_lane_get(digi_handle->lifd_handle, 
                                                (serdes_port + (LIFD_MAXIMUM_SUBSYSTEM_LANE + 1)),
                                                &port);
            fo2_ckctl_port = port;
        }
        else
        {
            port = ckctl_port;
        }
        result = enet_epmm_mpmo_ckctl_cfg(digi_handle->enet_line_handle, port, local_output_pc_ptr->channel, 1);
            
        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
        if(TRUE == use_digi_m1)
        {
            acb_if_sel_clk_source = (lifd_sig_src_type_t) 6;
        }
        else if(DIGI_SERDES_ACB_MODE_B_ON_C == acb_timing_mode)
        {
            acb_if_sel_clk_source =  (lifd_sig_src_type_t) 7;  /* value of 0x6 applied to register field */
        }
        else if(DIGI_SERDES_ACB_MODE_B_AND_C == acb_timing_mode)
        {
            acb_if_sel_clk_source = LIFD_SRC_ENET; /* value of 0x2*/
        }
        else if(DIGI_SERDES_ACB_MODE_C == acb_timing_mode)
        {
            acb_if_sel_clk_source = LIFD_SRC_ENET; /* value of 0x2*/
        }
            
        if(DIGI_SERDES_SYSTEM_INTF == intf)
        {
            port = ckctl_port - (DIGI_SERDES_XFI_LANES_MAX + DIGI_NUM_SFI51_PORTS_MAX);
        }
        else
        {
            port = ckctl_port;
        }

        result = enet_epmm_mpmo_ckctl_cfg(digi_handle->enet_sys_handle, port, local_output_pc_ptr->channel, 1);

        break;
    case UTIL_GLOBAL_CPB_PORT_CBRC:
        if(TRUE == use_digi_m1)
        {
            acb_if_sel_clk_source = LIFD_SRC_DIG_M1; 
        }
        else if(DIGI_SERDES_ACB_MODE_B_ON_C == acb_timing_mode)
        {
            acb_if_sel_clk_source = LIFD_SRC_OTN_IPM_CBRC; /* value of 0x1*/
        }
        else if(DIGI_SERDES_ACB_MODE_B_AND_C == acb_timing_mode)
        {
            acb_if_sel_clk_source = LIFD_SRC_CBRC; /* value of 0x0*/
        }
        else if(DIGI_SERDES_ACB_MODE_C == acb_timing_mode)
        {
            acb_if_sel_clk_source = LIFD_SRC_CBRC; /* value of 0x0*/
        }

        if(DIGI_SERDES_SYSTEM_INTF == intf && DIGI_PROD_APP_GET(digi_handle) == DIGI_PROD_APP_100G_3_X_40G_CFP_CARD)
        {
            serdes_port = ckctl_port - (DIGI_SERDES_XFI_LANES_MAX + DIGI_NUM_SFI51_PORTS_MAX);
            lifd_serdes_c_ckctl_source_lane_get(digi_handle->lifd_handle, 
                                                (serdes_port + (LIFD_MAXIMUM_SUBSYSTEM_LANE + 1)),
                                                &port);
            fo2_ckctl_port = port;

        }
        else
        {
            port = ckctl_port;
        }

        result = cbrc_mpmo_ckctl_cfg(digi_handle->cbrc_handle, port, local_output_pc_ptr->channel, 1);
            
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
        break;      
    }
    
    if(PMC_SUCCESS == result && (DIGI_SERDES_ACB_MODE_B_AND_C == acb_timing_mode|| 
                                 DIGI_SERDES_ACB_MODE_B_ON_C == acb_timing_mode) )
    {
        if(fo2_ckctl_port == 999) fo2_ckctl_port = ckctl_port;
        /*call coreotn FO2 mpmo config */
        result = coreotn_mpmo_ckctl_cfg(digi_handle->coreotn_handle, COREOTN_MPMO_TO_MAPOTN, fo2_ckctl_port, local_input_pc_ptr->channel, 1); 
    }
    
    if(PMC_SUCCESS == result)
    {
        if(DIGI_SERDES_SFI_51_INTF == intf)
        {
            serdes_lane = ckctl_port - 11;
            result = lifd_sfi_c_ckctl_source_select(digi_handle->lifd_handle, acb_if_sel_clk_source, (lifd_sfi5point1_int_t)(serdes_lane));
        }
        else if (DIGI_SERDES_SYSTEM_INTF == intf)
        {
            serdes_lane = ckctl_port - DIGI_NUM_SFI51_PORTS_MAX - DIGI_SERDES_XFI_LANES_MAX;
            if (DIGI_PROD_APP_IS_100G_3X40G_CFP_CARD(digi_handle))
            {
                /*set N1_SERD_ACB_SEL to 1*/
                result = sifd_serdes_acb_mux_configure(digi_handle->sifd_handle, serdes_lane+DIGI_SERDES_XFI_LANES_MAX, 1);
                result = lifd_serdes_c_ckctl_configure(digi_handle->lifd_handle, serdes_lane+DIGI_SERDES_XFI_LANES_MAX, acb_if_sel_clk_source);
            }  
            else
            {
                /*set N1_SERD_ACB_SEL to 0*/
                result = sifd_serdes_acb_mux_configure(digi_handle->sifd_handle, serdes_lane+DIGI_SERDES_XFI_LANES_MAX, 0);
                result = sifd_serdes_c_ckctl_configure(digi_handle->sifd_handle, serdes_lane, (sifd_sig_src_type_t)acb_if_sel_clk_source);
            }
        }   
        else if (DIGI_SERDES_LINE_INTF == intf)
        {
            serdes_lane = ckctl_port;
            result = lifd_serdes_c_ckctl_configure(digi_handle->lifd_handle, serdes_lane, acb_if_sel_clk_source);
        }
        else
        {
            PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
        }

    }
        
    PMC_RETURN(result);
   
} /* digi_non_otn_acb_ckctl_routing */

/*******************************************************************************
* digi_mapotn_data_src_acb_mode_find
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper function to decide on ACB timing mode between 
*   source B and C or source B on C when MAPOTN is the data source based on the 
*   mapping mode.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   mode             - Enum, OPU payload mapping modes.
*
*
* OUTPUTS:
*   acb_timing_mode  - ACB mode of operation 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_mapotn_data_src_acb_mode_find(digi_handle_t *digi_handle,
                                                    digi_mapping_mode_t mode,
                                                    digi_serdes_acb_mode_t *acb_timing_mode)
{
    digi_serdes_acb_mode_t acb_local_timing_mode = DIGI_SERDES_ACB_MODE_NOMINAL; 
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();
    
    PMC_LOG_TRACE("mapping mode:%d\n", mode);
    
    if(DIGI_MAP_ODU2P_FC_800_GMP        == mode || \
       DIGI_MAP_ODU2EP_10G_GDPS_GMP     == mode || \
       DIGI_MAP_ODU2P_5G_GDPS_GMP       == mode || \
       DIGI_MAP_ODU2P_CPRI_5_GMP        == mode || \
       DIGI_MAP_ODU2P_CPRI_10_GMP       == mode || \
       DIGI_MAP_ODU2P_CPRI_6_GMP        == mode || \
       DIGI_MAP_ODU3P_CBR_40_GE_GMP     == mode || \
       DIGI_MAP_ODU4P_CBR_100_GE_GMP    == mode || \
       DIGI_MAP_ODU3P_OC_768_CBR_AMP    == mode || \
       DIGI_MAP_ODU2P_OC_192_CBR_AMP    == mode)      
    {
        acb_local_timing_mode =  DIGI_SERDES_ACB_MODE_B_AND_C; 
    }
    else if(DIGI_MAP_ODUFLEX_5G_GDPS_BMP     == mode || \
            DIGI_MAP_ODUFLEX_10G_GDPS_BMP    == mode || \
            DIGI_MAP_ODUFLEX_CPRI_5_BMP      == mode || \
            DIGI_MAP_ODUFLEX_CPRI_10_BMP     == mode || \
            DIGI_MAP_ODUFLEX_CPRI_6_BMP      == mode || \
            DIGI_MAP_ODUFLEX_FC_800_BMP      == mode || \
            DIGI_MAP_ODU2FP_FC_1200_BMP      == mode || \
            DIGI_MAP_ODU1FP_FC_1200_BMP      == mode || \
            DIGI_MAP_ODU2EP_FC_1200_GFP      == mode || \
            DIGI_MAP_ODU1EP_CBR_10G3_7_2_BMP == mode || \
            DIGI_MAP_ODU2EP_CBR_10G3_7_1_BMP == mode || \
            DIGI_MAP_ODU3P_OC_768_CBR_BMP    == mode || \
            DIGI_MAP_ODU2P_OC_192_CBR_BMP    == mode)       
    {
        acb_local_timing_mode =  DIGI_SERDES_ACB_MODE_B_ON_C;
    }
    else
    {
        acb_local_timing_mode = DIGI_SERDES_ACB_MODE_NOMINAL;
    }
    
    *acb_timing_mode = acb_local_timing_mode;
    
    
    PMC_RETURN(result);
} /* digi_mapotn_data_src_acb_mode_find */



/*******************************************************************************
* digi_enet_data_src_acb_mode_find
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper function to decide on ACB timing mode between 
*   Nominal and Mode C when ENET is the data source based on the enet mode.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   mode             - ENET major processing modes
*
*
* OUTPUTS:
*   acb_timing_mode  - ACB mode of operation 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_enet_data_src_acb_mode_find(digi_handle_t *digi_handle,
                                                  digi_enet_mode_t mode,
                                                  digi_serdes_acb_mode_t *acb_timing_mode)
{
    digi_serdes_acb_mode_t acb_local_timing_mode = DIGI_SERDES_ACB_MODE_NOMINAL; 
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();
    
    PMC_LOG_TRACE("enet mode:%d\n", mode);
    
    
    if(DIGI_ENET_SERDES_100GE_TRANSPARENT                   == mode || \
       DIGI_ENET_SERDES_100GE_TRANSPARENT_RX_PMON           == mode || \
       DIGI_ENET_SERDES_40GE_TRANSPARENT                    == mode || \
       DIGI_ENET_SERDES_40GE_TRANSPARENT_RX_PMON            == mode || \
       DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT         == mode || \
       DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT_RX_PMON == mode || \
       DIGI_ENET_SERDES_10GE_TRANSPARENT                    == mode || \
       DIGI_ENET_SERDES_10GE_TRANSPARENT_RX_PMON            == mode )      
    {
        acb_local_timing_mode =  DIGI_SERDES_ACB_MODE_C; 
    }
    else
    {
        acb_local_timing_mode = DIGI_SERDES_ACB_MODE_NOMINAL;
    }
    
    *acb_timing_mode = acb_local_timing_mode;
    
    
    PMC_RETURN(result);
} /* digi_enet_data_src_acb_mode_find */

/*******************************************************************************
* digi_otn_acb_ckctl_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This is an internal helper function to configure CKCTL routing and the ACB.
*   It mat determine the serdes pin to apply the ACB routing by calling sub 
*   fucntion digi_otn_acb_ckctl_routing() does ACB timing routing for COREOTN 
*   related applications.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   *otn_server_ptr     - pointer to OTU framer 
*    serdes_cfg_action - specify the action to perform
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_acb_ckctl_cfg(digi_handle_t *digi_handle,
                                        digi_otn_server_chnl_def_t *otn_server_ptr,
                                        digi_serdes_cfg_action_t serdes_cfg_action)
{
    UINT32 port_uid;
    digi_serdes_intf_t intf;
    UINT32 num_10g_data_lane = 0;
    acb_ft_prov_cfg_t acb_ft_prov_cfg;
    digi_serdes_port_def_t *port_def_ptr;
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 ppm_max;
    digi_serdes_port_mode_t serdes_rate = LAST_DIGI_SERDES_PORT_MODE;
    
    PMC_ENTRY();

    port_uid = otn_server_ptr->port_uid;
    
    PMC_LOG_TRACE("port_uid:%d\n", port_uid);
    
    if (DIGI_SERDES_PROV == serdes_cfg_action || 
        DIGI_SERDES_PROV_WITH_CLK_AS_MASTER == serdes_cfg_action )
    {
        num_10g_data_lane = digi_serdes_num_10g_data_lane_get((util_global_odukp_type_t)otn_server_ptr->oduk_type);
    } 
    else if (DIGI_SERDES_PROV_ALIGNER_ONLY == serdes_cfg_action)
    {
        acb_ft_prov_cfg.mode = ACB_FT_MODE_NOMINAL;
    }

    /* Search for the port and find the interface */
    port_def_ptr = digi_port_ctxt_and_intf_find(digi_handle,
                                                port_uid,
                                                &intf);
    if (NULL != port_def_ptr)
    {
        /* compute MAX PMM diff */
        PMC_MEMSET((void *)&acb_ft_prov_cfg, 0, sizeof(acb_ft_prov_cfg_t));
        /* PPM depends on serdes rate */
        /* find master lane serdes rate to determine if serdes clock are over clocked */
        switch(intf)
        {
        case DIGI_SERDES_LINE_INTF:
            serdes_rate = digi_handle->var.serdes_ctxt.s16_line_lanes_rate[port_def_ptr->master_lane];
            break;
        case DIGI_SERDES_SYSTEM_INTF:
            serdes_rate = digi_handle->var.serdes_ctxt.s16_sys_lanes_rate[port_def_ptr->master_lane];
            break;
        case DIGI_SERDES_SFI_51_INTF:
            serdes_rate = digi_handle->var.serdes_ctxt.sfi51_lanes_rate[port_def_ptr->master_lane];
            break;
        default:
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
            break;        
        }

        /* set OTN-OTN PPM default maximum value */
        ppm_max = DIGI_SERDES_MAX_PPM_COMPUTE(DIGI_SERDES_OTN_MAX_PPM, DIGI_SERDES_OTN_MAX_PPM);
        /* if overclocked serdes, PPM range is 120 */
        if (DIGI_SERDES_PORT_MODE_S16_OTU1E == serdes_rate ||
            DIGI_SERDES_PORT_MODE_S16_OTU1F == serdes_rate ||
            DIGI_SERDES_PORT_MODE_S16_OTU2E == serdes_rate ||
            DIGI_SERDES_PORT_MODE_S16_OTU2F == serdes_rate )
        {
        
            ppm_max = DIGI_SERDES_MAX_PPM_COMPUTE(DIGI_OVRCLOCKED_SERDES_OTN_MAX_PPM, 
                                                  DIGI_OVRCLOCKED_SERDES_OTN_MAX_PPM);
        }

        acb_ft_prov_cfg.max_ppm = ppm_max;
        
        switch(intf) {
            
        case DIGI_SERDES_LINE_INTF:
            result = digi_otn_acb_ckctl_line_cfg(digi_handle, otn_server_ptr,
                                                 serdes_cfg_action,
                                                 num_10g_data_lane,
                                                 (acb_ft_prov_cfg_t *)&acb_ft_prov_cfg,
                                                 port_def_ptr->master_lane);
            break;

        case DIGI_SERDES_SFI_51_INTF:
            result = digi_otn_acb_ckctl_xfi51_cfg(digi_handle, otn_server_ptr,
                                                  serdes_cfg_action,
                                                  num_10g_data_lane,
                                                  &acb_ft_prov_cfg,
                                                  port_def_ptr->master_lane);
            break;

        case DIGI_SERDES_SYSTEM_INTF:
            result = digi_otn_acb_ckctl_sys_cfg(digi_handle, otn_server_ptr,
                                                serdes_cfg_action,
                                                num_10g_data_lane,
                                                &acb_ft_prov_cfg,
                                                port_def_ptr->master_lane);
            break;
        default:
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
            break;
        }
    }

    PMC_RETURN(result);

} /* digi_otn_acb_ckctl_cfg */

/*******************************************************************************
* digi_otn_acb_ckctl_line_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  
*   This is an internal helper function to configure CKCTL routing and the ACB. 
*   It mat determine the serdes pin to apply the ACB routing by calling sub 
*   fucntion digi_otn_acb_ckctl_routing() does ACB timing routing for COREOTN 
*   related applications.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *otn_server_ptr  - pointer to OTU framer 
*    serdes_cfg_action - specify the action to perform
*    num_10g_data_lane - Number of 10G data lane 
*   *acb_ft_prov_cfg - pointer to the acb configuration. See acb_ft_prov_cfg_t 
*                      for more information.
*    master_lane     - the lane to set as the master. This should be the first
*                      lane of the port
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_acb_ckctl_line_cfg(digi_handle_t *digi_handle,
                                              digi_otn_server_chnl_def_t *otn_server_ptr,
                                              digi_serdes_cfg_action_t serdes_cfg_action,
                                              UINT32 num_10g_data_lane,
                                              acb_ft_prov_cfg_t* acb_ft_prov_cfg,
                                              UINT32 master_lane)
{
    UINT32 port_uid;
    UINT32 chnl;
    UINT32 ckctl_port;
    UINT32 serdes_pin; 
    coreotn_mpmo_inst_t coreotn_mpmo_inst = LAST_COREOTN_MPMO_INST;
    digi_serdes_port_mode_t serdes_mode;
    digi_serdes_intf_t intf = DIGI_SERDES_LINE_INTF;
    UINT32 i;
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();

    port_uid = otn_server_ptr->port_uid;
    chnl = otn_server_ptr->dci_chnl;
    serdes_mode = otn_server_ptr->serdes_mode;

    for(i=0;i<DIGI_SERDES_XFI_LANES_MAX;i++)
    {
        if(PMC_SUCCESS == result && digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid == port_uid)
        {
            serdes_pin = i;
            ckctl_port = serdes_pin;

            switch (serdes_cfg_action) {
            case DIGI_SERDES_PROV:
            case DIGI_SERDES_PROV_WITH_CLK_AS_MASTER:
                result = digi_otn_acb_ckctl_routing(digi_handle, intf, ckctl_port, chnl,&coreotn_mpmo_inst);

                if(PMC_SUCCESS == result)
                {
                    result = digi_serdes_otn_acb_cfg(digi_handle, serdes_pin, 
                                                     master_lane, intf, serdes_mode, 
                                                     coreotn_mpmo_inst, chnl, num_10g_data_lane,acb_ft_prov_cfg, TRUE);
                }
                break;
            case DIGI_SERDES_PROV_ALIGNER_ONLY:

                result = s16_prov(digi_handle->s16_line_handle, serdes_pin, master_lane, acb_ft_prov_cfg,S16_CLK_CFG_NOT_CLK_LANE);
                if (PMC_SUCCESS == result)
                {
                    result = s16_activate(digi_handle->s16_line_handle, 
                                          serdes_pin, FALSE);
                }
                break;
            case DIGI_SERDES_DEPROV:

                result = s16_deprov(digi_handle->s16_line_handle, serdes_pin);
                break;
            case DIGI_SERDES_ACTIVATE:
                result = s16_activate(digi_handle->s16_line_handle, 
                                      serdes_pin, TRUE);
                break;
            case DIGI_SERDES_DEACTIVATE:
                if (PMC_SUCCESS == result)
                {
                    result = s16_deactivate(digi_handle->s16_line_handle, 
                                            serdes_pin);
                }
                break;
            default:
                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                break;
            }
        }
    }

    /*  configure an additional serdes as a clock when it is configured */
    if (PMC_SUCCESS == result)
    {
        BOOL8 is_clk_cfg_as_master = FALSE;

        if (DIGI_SERDES_PROV_WITH_CLK_AS_MASTER == serdes_cfg_action) 
        {
            is_clk_cfg_as_master = TRUE;    
            digi_serdes_port_def_t *port_def_ptr;
            port_def_ptr = digi_port_ctxt_find(digi_handle,port_uid,intf); 
            if (port_def_ptr != NULL && DIGI_SERDES_PIN_NOT_USED != port_def_ptr->s16_clk_cfg.pin_index) {                
                result = digi_otn_acb_ckctl_routing(digi_handle, intf, port_def_ptr->s16_clk_cfg.pin_index,chnl, &coreotn_mpmo_inst);   
                if (PMC_SUCCESS == result)
                {
                    lifd_serdes_tx_if_sel_update(digi_handle->lifd_handle,
                                                 port_def_ptr->s16_clk_cfg.pin_index,
                                                 XIFD_DSIS_OTN);
                }
            }
        }
        
        if (PMC_SUCCESS == result)
        {
            result = digi_s16_clk_acb_cfg(digi_handle, intf, port_uid, master_lane, serdes_cfg_action,acb_ft_prov_cfg,
                                          is_clk_cfg_as_master);
        }
    }

    PMC_RETURN(result); 

} /* digi_otn_acb_ckctl_line_cfg */

/*******************************************************************************
* digi_otn_acb_ckctl_xfi51_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  
*   This is an internal helper function to configure CKCTL routing and the ACB. 
*   It mat determine the serdes pin to apply the ACB routing by calling sub 
*   fucntion digi_otn_acb_ckctl_routing() does ACB timing routing for COREOTN 
*   related applications.
*   This is for the system interface only.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *otn_server_ptr  - pointer to OTU framer 
*    serdes_cfg_action - specify the action to perform
*    num_10g_data_lane - Number of 10G data lane 
*   *acb_ft_prov_cfg - pointer to the acb configuration. See acb_ft_prov_cfg_t 
*                      for more information.
*    master_lane     - the lane to set as the master. This should be the first
*                      lane of the port
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_acb_ckctl_xfi51_cfg(digi_handle_t *digi_handle,
                                               digi_otn_server_chnl_def_t *otn_server_ptr,
                                               digi_serdes_cfg_action_t serdes_cfg_action,
                                               UINT32 num_10g_data_lane,
                                               acb_ft_prov_cfg_t* acb_ft_prov_cfg,
                                               UINT32 master_lane)
{

    UINT32 port_uid;
    UINT32 chnl;
    UINT32 ckctl_port;
    UINT32 serdes_pin; 
    coreotn_mpmo_inst_t coreotn_mpmo_inst = LAST_COREOTN_MPMO_INST;
    digi_serdes_port_mode_t serdes_mode;
    digi_serdes_intf_t intf = DIGI_SERDES_SFI_51_INTF;
    UINT32 i;
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();

    port_uid = otn_server_ptr->port_uid;
    chnl = otn_server_ptr->dci_chnl;
    serdes_mode = otn_server_ptr->serdes_mode;

    for (i = 0; i < DIGI_NUM_SFI51_PORTS_MAX; i++) 
    {
        if(PMC_SUCCESS == result && digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[i].port_uid == port_uid)
        {
            serdes_pin = i;
            ckctl_port = serdes_pin + DIGI_SERDES_XFI_LANES_MAX;

            switch (serdes_cfg_action) {

            case DIGI_SERDES_PROV:

                result = digi_otn_acb_ckctl_routing(digi_handle, intf, ckctl_port, chnl,&coreotn_mpmo_inst);
                if(PMC_SUCCESS == result)
                {
                    result = digi_serdes_otn_acb_cfg(digi_handle, serdes_pin,
                                                     master_lane, intf,
                                                     serdes_mode, coreotn_mpmo_inst,
                                                     chnl, num_10g_data_lane,acb_ft_prov_cfg, TRUE);
                }
                break;
            case DIGI_SERDES_PROV_ALIGNER_ONLY:

                result = sfi51_d8_tx_18x_prov(digi_handle->sfi51_d8_tx_18x_handle[i], NULL);
                if (PMC_SUCCESS == result)
                {
                    result = sfi51_d8_tx_18x_activate(digi_handle->sfi51_d8_tx_18x_handle[i]);
                }
                break;
            case DIGI_SERDES_DEPROV:

                result = sfi51_d8_tx_18x_deprov(digi_handle->sfi51_d8_tx_18x_handle[i]);
                break;
            case DIGI_SERDES_ACTIVATE:

                result = sfi51_d8_tx_18x_activate(digi_handle->sfi51_d8_tx_18x_handle[i]);
                break;

            case DIGI_SERDES_DEACTIVATE:

                result = sfi51_d8_tx_18x_deactivate(digi_handle->sfi51_d8_tx_18x_handle[i]);
                break;

            default:

                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                break;
            }
        }
    }

    PMC_RETURN(result);

} /* digi_otn_acb_ckctl_xfi51_cfg */

/*******************************************************************************
* digi_otn_acb_ckctl_sys_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  
*   This is an internal helper function to configure CKCTL routing and the ACB. 
*   It mat determine the serdes pin to apply the ACB routing by calling sub 
*   fucntion digi_otn_acb_ckctl_routing() does ACB timing routing for COREOTN 
*   related applications.
*   This is for the system interface only.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *otn_server_ptr  - pointer to OTU framer 
*    serdes_cfg_action - specify the action to perform
*    num_10g_data_lane - Number of 10G data lane 
*   *acb_ft_prov_cfg - pointer to the acb configuration. See acb_ft_prov_cfg_t 
*                      for more information.
*    master_lane     - the lane to set as the master. This should be the first
*                      lane of the port
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_acb_ckctl_sys_cfg(digi_handle_t *digi_handle,
                                             digi_otn_server_chnl_def_t *otn_server_ptr,
                                             digi_serdes_cfg_action_t serdes_cfg_action,
                                             UINT32 num_10g_data_lane,
                                             acb_ft_prov_cfg_t* acb_ft_prov_cfg,
                                             UINT32 master_lane)
{

    UINT32 port_uid;
    UINT32 chnl;
    UINT32 ckctl_port;
    UINT32 serdes_pin;
    coreotn_mpmo_inst_t coreotn_mpmo_inst = LAST_COREOTN_MPMO_INST;
    digi_serdes_port_mode_t serdes_mode;
    digi_serdes_intf_t intf = DIGI_SERDES_SYSTEM_INTF;
    UINT32 i;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    port_uid = otn_server_ptr->port_uid;
    chnl = otn_server_ptr->dci_chnl;
    serdes_mode = otn_server_ptr->serdes_mode;

    for (i = 0; i < DIGI_SERDES_SYS_LANES_MAX; i++)
    {
        if(PMC_SUCCESS == result && digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid == port_uid)
        {
            serdes_pin = i;

            ckctl_port = serdes_pin + DIGI_SERDES_XFI_LANES_MAX + DIGI_NUM_SFI51_PORTS_MAX;
            intf = DIGI_SERDES_SYSTEM_INTF;

            switch (serdes_cfg_action) {

            case DIGI_SERDES_PROV:
            case DIGI_SERDES_PROV_WITH_CLK_AS_MASTER:

                result = digi_otn_acb_ckctl_routing(digi_handle, intf, ckctl_port, chnl,&coreotn_mpmo_inst);
                if(PMC_SUCCESS == result)
                {
                    result = digi_serdes_otn_acb_cfg(digi_handle, serdes_pin,
                                                     master_lane, intf,
                                                     serdes_mode, coreotn_mpmo_inst,
                                                     chnl,num_10g_data_lane,acb_ft_prov_cfg, TRUE);
                }
                break;
            case DIGI_SERDES_PROV_ALIGNER_ONLY:

                result = s16_prov(digi_handle->s16_sys_handle, serdes_pin, master_lane, acb_ft_prov_cfg,S16_CLK_CFG_NOT_CLK_LANE);
                if (PMC_SUCCESS == result)
                {
                    result = s16_activate(digi_handle->s16_sys_handle, 
                                          serdes_pin, TRUE);
                }
                break;
            case DIGI_SERDES_DEPROV:

                result = s16_deprov(digi_handle->s16_sys_handle, serdes_pin);
                break;
            case DIGI_SERDES_ACTIVATE:                
                result = s16_activate(digi_handle->s16_sys_handle, 
                                      serdes_pin, TRUE);
                break;
            case DIGI_SERDES_DEACTIVATE:
                if (PMC_SUCCESS == result)
                {
                    result = s16_deactivate(digi_handle->s16_sys_handle, serdes_pin);
                }
                break;
            default:

                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                break;
            }
        }
    }

    /*  configure an additional serdes as a clock when it is configured */
    if (PMC_SUCCESS == result)
    {

        BOOL8 is_clk_cfg_as_master = FALSE;

        if (DIGI_SERDES_PROV_WITH_CLK_AS_MASTER == serdes_cfg_action) 
        {
            is_clk_cfg_as_master = TRUE;
            digi_serdes_port_def_t *port_def_ptr;
            port_def_ptr = digi_port_ctxt_find(digi_handle,port_uid,intf); 
            if (port_def_ptr != NULL && DIGI_SERDES_PIN_NOT_USED != port_def_ptr->s16_clk_cfg.pin_index) {
                result = digi_otn_acb_ckctl_routing(digi_handle, intf, port_def_ptr->s16_clk_cfg.pin_index,chnl, &coreotn_mpmo_inst);   
                if (PMC_SUCCESS == result)
                {
                    sifd_serdes_tx_if_sel_update(digi_handle->sifd_handle,
                                                 port_def_ptr->s16_clk_cfg.pin_index,
                                                 SIFD_DSIS_OTN);
                }
            }
        }
        
        if (PMC_SUCCESS == result)
        {
            result = digi_s16_clk_acb_cfg(digi_handle, intf, port_uid, master_lane, serdes_cfg_action,acb_ft_prov_cfg, is_clk_cfg_as_master);
        }
    }

    PMC_RETURN(result);

} /* digi_otn_acb_ckctl_sys_cfg */


/*******************************************************************************
* digi_otn_acb_ckctl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  
*   This is an internal helper function to recover the serdes interface type,
*   the serdes_pin and the ckctl_port that is associated with a COREOTN
*   channel handle.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *pc_ptr          - switch channel data pointer
*
* OUTPUTS:
*   *intf_ptr            - interface type identified by function
*   *acb_inst_ptr        - ACB instance
*   *ckctl_port_addr_ptr - ckctl port address identified by function
*
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_otn_acb_ckctl_get(digi_handle_t *digi_handle,
                                   util_global_switch_data_t *pc_ptr,
                                   digi_serdes_intf_t *intf_ptr,
                                   UINT8 *acb_inst_ptr,
                                   UINT8 *ckctl_port_addr_ptr)
{
    UINT32 acb_inst = 255;
    UINT32 ckctl_port = 255;
    digi_serdes_intf_t intf = LAST_DIGI_SERDES_INTF;


    util_global_switch_data_def_t *pc_data_ptr = (util_global_switch_data_def_t *)pc_ptr;
    util_global_oduk_port_data_t *local_pc_ptr = &pc_data_ptr->oduk_data;
    UINT32 port_uid,i;
    
    digi_otn_server_chnl_def_t *otn_server_ptr = NULL;
    digi_serdes_port_def_t *port_def_ptr;

    PMC_ENTRY();

    switch(local_pc_ptr->port_type)
    {
    case UTIL_GLOBAL_ODUK_PORT_ILKN1:
        if(digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
        {
            /* ODUKSW port used by LINEOTN -> HO -> ODUKSW */
            /* LINEOTN channel handle is used by COREOTN_CTL */
            otn_server_ptr = &(digi_handle->handle_pool.otn_server_chnl[(local_pc_ptr->channel)]);
        } else 
        {
            /* that is an invalid case in non-sysotn mode */
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        }
        break;
    case UTIL_GLOBAL_ODUK_PORT_COREOTN:
        if(digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
        {
            /* ODUKSW port used by LINEOTN -> HO -> ODUKSW */
            otn_server_ptr = &(digi_handle->handle_pool.sysotn_server_chnl);             
        } else {
            PMC_ASSERT(local_pc_ptr->channel < DIGI_OTN_SERVER_CHNL_MAX, DIGI_ERR_CODE_ASSERT, 0, 0);
            /* LINEOTN channel handle is used by COREOTN_FO1 */
            otn_server_ptr = &(digi_handle->handle_pool.otn_server_chnl[(local_pc_ptr->channel)]);
        }
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    port_uid = otn_server_ptr->port_uid;

    port_def_ptr = digi_port_ctxt_and_intf_find(digi_handle,
                                                port_uid,
                                                &intf);
    acb_inst = port_def_ptr->master_lane;

    switch(intf)
    {
    case DIGI_SERDES_LINE_INTF:
        ckctl_port = acb_inst;
        break;
    case DIGI_SERDES_SFI_51_INTF:
        /* SFI 5.1 - there's one acb per interface */
        for (i=0; i < DIGI_NUM_SFI51_PORTS_MAX; i++) 
        {
            if (digi_handle->var.port_ctxt.sfi51_port_ctxt[i].port_uid == port_uid) 
                break;
        }
        PMC_ASSERT(i < DIGI_NUM_SFI51_PORTS_MAX, DIGI_ERR_CODE_ASSERT,0,0);
        acb_inst = i; 
        ckctl_port = acb_inst + DIGI_SERDES_XFI_LANES_MAX;
        break;
    case DIGI_SERDES_SYSTEM_INTF:
        if(DIGI_PROD_APP_GET(digi_handle) == DIGI_PROD_APP_100G_3_X_40G_CFP_CARD)
        {
            lifd_serdes_c_ckctl_source_lane_get(digi_handle->lifd_handle, 
                                                (acb_inst + (LIFD_MAXIMUM_SUBSYSTEM_LANE + 1)),
                                                &ckctl_port);
        }
        else
        {
            ckctl_port = acb_inst + DIGI_SERDES_XFI_LANES_MAX + DIGI_NUM_SFI51_PORTS_MAX;
        }
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    *acb_inst_ptr = (UINT8)acb_inst;
    *ckctl_port_addr_ptr = (UINT8)ckctl_port;
    *intf_ptr = intf;

    PMC_RETURN(); 

} /* digi_otn_acb_ckctl_get */

/*******************************************************************************
* digi_non_otn_acb_ckctl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  
*   This is an internal helper function to recover the serdes interface type,
*   the serdes_pin and the ckctl_port that is associated with a COREOTN
*   channel handle.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *pc_ptr          - switch channel data pointer
*
* OUTPUTS:
*   *intf_ptr            - interface type identified by function
*   *serdes_pin_ptr      - serdes pin identified by function
*   *ckctl_port_addr_ptr - ckctl port address identified by function
*   *fo2_ckctl_port_addr_ptr - fo2 ckctl port address identified by function
*
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_non_otn_acb_ckctl_get(digi_handle_t *digi_handle,
                                       util_global_switch_data_t *pc_ptr,
                                       digi_serdes_intf_t *intf_ptr,
                                       UINT8 *serdes_pin_ptr,
                                       UINT8 *ckctl_port_addr_ptr,
                                       UINT8 *fo2_ckctl_port_addr_ptr)
{
    UINT32 serdes_pin = 255;
    UINT32 ckctl_port = 255, fo2_ckctl_port = 255;
    digi_serdes_intf_t intf = LAST_DIGI_SERDES_INTF;
    

    util_global_switch_data_def_t *pc_data_ptr = (util_global_switch_data_def_t *)pc_ptr;
    util_global_cpb_port_data_t *local_pc_ptr = &pc_data_ptr->cpb_data;
    UINT32 port_uid = DIGI_SERDES_UNASSIGNED;
    UINT32 i;
    UINT32 acb_inst;

    digi_serdes_port_def_t *port_def_ptr;

    PMC_ENTRY();

    switch(local_pc_ptr->port_type)
    {
    case UTIL_GLOBAL_CPB_PORT_CBRC:
    case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
    case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
        if (DIGI_PROD_APP_IS_TRANSMUXPONDER_CARD(digi_handle)
            || DIGI60_PROD_APP_IS_TRANSMUXPONDER_SYS_CLIENT_CARD(digi_handle)) 
        {
            if((UTIL_GLOBAL_CPB_PORT_ENET_SYS == local_pc_ptr->port_type) ||
               (UTIL_GLOBAL_CPB_PORT_CBRC == local_pc_ptr->port_type &&
                DIGI_CBRC_IS_SYS_INTF(digi_handle)))
            {
                port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[local_pc_ptr->channel].port_uid;
            }
            else
            {
                port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[local_pc_ptr->channel].port_uid;
            }
        }
        else if (DIGI_PROD_APP_IS_100G_3X40G_CFP_CARD(digi_handle))
        {
            port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[local_pc_ptr->channel].port_uid;
            if(DIGI_SERDES_UNASSIGNED == port_uid)
            {
                port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_sys_ctxt[local_pc_ptr->channel].port_uid;
            }
        }
        else
        {
            if(local_pc_ptr->port_type==UTIL_GLOBAL_CPB_PORT_CBRC && local_pc_ptr->channel == 0)
            {
                /* CBRC SS channel 0 may be used for SFIS or SFI5.1 processing mutually exclusively these
                   use lane indexes 0 to 3 and 8 to 11 respectively, need to ensure proper set of lanes
                   recovered */
                if(DIGI_SERDES_PROV_STATE_CBRC == digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[local_pc_ptr->channel].prov_state)
                {
                    port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[local_pc_ptr->channel].port_uid;
                }
                else
                {
                    port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[8].port_uid;
                }
            }
            else
            {
                port_uid = digi_handle->var.post_mld_dsi_ctxt.post_mld_dsi_line_ctxt[local_pc_ptr->channel].port_uid;
            }
        }

        break;
    case UTIL_GLOBAL_CPB_PORT_MAPOTN:
    case UTIL_GLOBAL_CPB_PORT_ILKN1:
    case UTIL_GLOBAL_CPB_PORT_ILKN2:
    case UTIL_GLOBAL_CPB_PORT_NOT_USED:
    case LAST_UTIL_GLOBAL_CPB_PORT:
    default:
        /* cases that do not use MPMO */
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        break;
    }

    PMC_ASSERT(DIGI_SERDES_UNASSIGNED != port_uid, DIGI_ERR_CODE_ASSERT, 0, 0);
    port_def_ptr = digi_port_ctxt_and_intf_find(digi_handle,
                                                port_uid,
                                                &intf);
    serdes_pin = port_def_ptr->master_lane;

    switch(intf)
    {
    case DIGI_SERDES_LINE_INTF:
        fo2_ckctl_port = serdes_pin;
        break;
    case DIGI_SERDES_SFI_51_INTF:
        /* SFI 5.1 - there's one acb per interface */
        for (i=0; i < DIGI_NUM_SFI51_PORTS_MAX; i++) 
        {
            if (digi_handle->var.port_ctxt.sfi51_port_ctxt[i].port_uid == port_uid) 
                break;
        }
        PMC_ASSERT(i < DIGI_NUM_SFI51_PORTS_MAX, DIGI_ERR_CODE_ASSERT,0,0);
        acb_inst = i; 

        fo2_ckctl_port =  acb_inst + DIGI_SERDES_XFI_LANES_MAX;
        break;
    case DIGI_SERDES_SYSTEM_INTF:
        fo2_ckctl_port = serdes_pin + DIGI_SERDES_XFI_LANES_MAX + DIGI_NUM_SFI51_PORTS_MAX;
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }

    switch(local_pc_ptr->port_type)
    {
    case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
        if(DIGI_SERDES_SYSTEM_INTF == intf)
        {
            lifd_serdes_c_ckctl_source_lane_get(digi_handle->lifd_handle, 
                                                (serdes_pin + (LIFD_MAXIMUM_SUBSYSTEM_LANE + 1)),
                                                &ckctl_port);
            fo2_ckctl_port = ckctl_port;    
        }
        else
        {
            ckctl_port = fo2_ckctl_port;
        }
                
        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
        if(DIGI_SERDES_SYSTEM_INTF == intf)
        {
            ckctl_port = serdes_pin;
        }
        else
        {
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        }
        break;
    case UTIL_GLOBAL_CPB_PORT_CBRC:
        if(DIGI_SERDES_SYSTEM_INTF == intf && DIGI_PROD_APP_GET(digi_handle) == DIGI_PROD_APP_100G_3_X_40G_CFP_CARD)
        {
            lifd_serdes_c_ckctl_source_lane_get(digi_handle->lifd_handle, 
                                                (serdes_pin + (LIFD_MAXIMUM_SUBSYSTEM_LANE + 1)),
                                                &ckctl_port);
            fo2_ckctl_port = ckctl_port;
        }
        else
        {
            ckctl_port = fo2_ckctl_port;
        }
        break;
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
        break;      
    }

    *serdes_pin_ptr = (UINT8)serdes_pin;
    *ckctl_port_addr_ptr = (UINT8)ckctl_port;
    *fo2_ckctl_port_addr_ptr = (UINT8)fo2_ckctl_port;
    *intf_ptr = intf;

    PMC_RETURN(); 

} /* digi_non_otn_acb_ckctl_get */

/*******************************************************************************
* digi_otn_mpmo_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper function that provides the COREOTN mpmo instance type
*   and ACB source clock selector associated to device product.
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*    intf              - serdes interface: LINE, SYS or SFI51.
*
* OUTPUTS:
*  acb_if_sel_clk_source  - ACB source clock selector
*  coreotn_mpmo_inst      - mpmo instance that provides the CKCTL information
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_otn_mpmo_get(digi_handle_t          *digi_handle,
                              digi_serdes_intf_t      intf,
                              lifd_sig_src_type_t *acb_if_sel_clk_source,
                              coreotn_mpmo_inst_t    *coreotn_mpmo_inst)
{
    PMC_ENTRY();

    switch(intf)
    {
    case DIGI_SERDES_LINE_INTF:
        *acb_if_sel_clk_source = LIFD_SRC_OTN_LPM; /* value of 0x3*/
        if(DIGI_PROD_APP_IS_LINE_CARD(digi_handle) ||
           DIGI_PROD_APP_IS_TRANSMUXPONDER_CARD(digi_handle) ||
           DIGI60_PROD_APP_IS_LINE_CARD(digi_handle) ||
           DIGI60_PROD_APP_IS_TRANSMUXPONDER_CARD(digi_handle) ||
           DIGI60_PROD_APP_IS_TRANSMUXPONDER_SYS_CLIENT_CARD(digi_handle) ||
           DIGI_PROD_APP_IS_100G_3X40G_CFP_CARD(digi_handle))
        {
            /*call coreotn FO1 mpmo config */
            *coreotn_mpmo_inst = COREOTN_MPMO_TO_COREOTN;
        }
        else if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
        {
            /*call coreotn CTL mpmo config */
            *coreotn_mpmo_inst = COREOTN_MPMO_CORECTL;
        }
        else

        {
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        }
            
        break;
    case DIGI_SERDES_SYSTEM_INTF:
            
        *acb_if_sel_clk_source = LIFD_SRC_OTN_LPM; /* value of 0x3*/
        /*call coreotn FO1 mpmo config */
        *coreotn_mpmo_inst = COREOTN_MPMO_TO_COREOTN;
                
        break;
        
    case DIGI_SERDES_SFI_51_INTF:
        *acb_if_sel_clk_source = LIFD_SRC_OTN_LPM; /* value of 0x2*/
        if(DIGI_PROD_APP_IS_LINE_CARD(digi_handle) ||
           DIGI_PROD_APP_IS_TRANSMUXPONDER_CARD(digi_handle))
        {
            /*call coreotn FO1 mpmo config */
            *coreotn_mpmo_inst = COREOTN_MPMO_TO_COREOTN;
        }
        else if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle))
        {
            /*call coreotn CTL mpmo config */
            *coreotn_mpmo_inst = COREOTN_MPMO_CORECTL;
        }
        else if(DIGI60_PROD_APP_IS_LINE_CARD(digi_handle) ||
                DIGI60_PROD_APP_IS_TRANSMUXPONDER_CARD(digi_handle) ||
                DIGI60_PROD_APP_IS_TRANSMUXPONDER_SYS_CLIENT_CARD(digi_handle))
        {
            /*call coreotn FO1 mpmo config */
            *coreotn_mpmo_inst = COREOTN_MPMO_TO_COREOTN;
        }
        else
        {
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        }
            
        break;
            
    default:
        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
        break;
        
    }
 
    PMC_RETURN();
}/* digi_otn_mpmo_get */

/*******************************************************************************
* digi_otn_acb_ckctl_routing
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is an internal helper function that applies ACB CKCTL routing for COREOTN
*   related applications based on system interface.
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   intf               - Interface configuration related to, valid
*                        values:\n
*                        DIGI_SERDES_LINE_INTF\n
*                        DIGI_SERDES_SYSTEM_INTF\n
*                        DIGI_SERDES_SFI_51_INTF
*   ckctl_port         - clock control port number (0-25): \n
*                        Ports 0--11 are line side 10G SERDES. \n
*                        Ports 12--13 are line side 2.5G SERDES. \n
*                        Ports 14--25 are system side 10G SERDES. \n
*   chnl               - Channel ID that will map to clock control port
*   
*
* OUTPUTS:
*  coreotn_mpmo_inst   - mpmo instance that provides the CKCTL information
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_acb_ckctl_routing(digi_handle_t *digi_handle,
                                             digi_serdes_intf_t intf,
                                             UINT32 ckctl_port,   
                                             UINT32 chnl,
                                             coreotn_mpmo_inst_t *coreotn_mpmo_inst)
{
    lifd_sig_src_type_t acb_if_sel_clk_source;
    UINT32 serdes_lane;
    UINT32 port = 0, serdes_port = 0;
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();
    
    PMC_LOG_TRACE("\n digi_handle->var.prod_app:%d\
               \n intf:%d\
               \n ckctl_port:%d\
               \n chnl:%d\n", 
                  DIGI_PROD_APP_GET(digi_handle), intf, ckctl_port, chnl);

    digi_otn_mpmo_get(digi_handle, intf, &acb_if_sel_clk_source, coreotn_mpmo_inst);
    
    if(PMC_SUCCESS == result)
    {
        if(DIGI_SERDES_SYSTEM_INTF == intf  && DIGI_PROD_APP_GET(digi_handle) == DIGI_PROD_APP_100G_3_X_40G_CFP_CARD)
        {
            serdes_port = ckctl_port - (DIGI_SERDES_XFI_LANES_MAX + DIGI_NUM_SFI51_PORTS_MAX);
            lifd_serdes_c_ckctl_source_lane_get(digi_handle->lifd_handle, 
                                                (serdes_port + (LIFD_MAXIMUM_SUBSYSTEM_LANE + 1)),
                                                &port);

        }
        else
        {
            port = ckctl_port;
        }


        PMC_LOG_TRACE("coreotn_mpmo_inst:%d\n", *coreotn_mpmo_inst);
        result = coreotn_mpmo_ckctl_cfg(digi_handle->coreotn_handle, *coreotn_mpmo_inst, port, chnl, 1);
    }
   
    if(PMC_SUCCESS == result)
    {
        if(DIGI_SERDES_SFI_51_INTF == intf)
        {
            serdes_lane = ckctl_port - 11;
            result = lifd_sfi_c_ckctl_source_select(digi_handle->lifd_handle, acb_if_sel_clk_source, (lifd_sfi5point1_int_t)(serdes_lane));
        }
        else if(DIGI_SERDES_SYSTEM_INTF == intf)
        {
            serdes_lane = ckctl_port - DIGI_NUM_SFI51_PORTS_MAX - DIGI_SERDES_XFI_LANES_MAX;
            if (DIGI_PROD_APP_IS_100G_3X40G_CFP_CARD(digi_handle))
            {
                /*set N1_SERD_ACB_SEL to 1*/
                result = sifd_serdes_acb_mux_configure(digi_handle->sifd_handle, serdes_lane+DIGI_SERDES_XFI_LANES_MAX, 1);
                result = lifd_serdes_c_ckctl_configure(digi_handle->lifd_handle, serdes_lane+DIGI_SERDES_XFI_LANES_MAX, acb_if_sel_clk_source); 
            }  
            else
            {
                /*set N1_SERD_ACB_SEL to 0*/
                result = sifd_serdes_acb_mux_configure(digi_handle->sifd_handle, serdes_lane+DIGI_SERDES_XFI_LANES_MAX, 0);
                result = sifd_serdes_c_ckctl_configure(digi_handle->sifd_handle, serdes_lane, (sifd_sig_src_type_t)acb_if_sel_clk_source);
            }
        } 
        else if (DIGI_SERDES_LINE_INTF == intf)
        {
            serdes_lane = ckctl_port;
            result = lifd_serdes_c_ckctl_configure(digi_handle->lifd_handle, serdes_lane, acb_if_sel_clk_source);
        }
        else 
        {
            PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
        }
    }     
    
    PMC_RETURN(result);
   
} /* digi_otn_acb_ckctl_routing */

/*******************************************************************************
* digi_ilkn_chnl_state_reset
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function resets the ILKN channel state and port usage back to the default
*   state so that it is once again available for provisioning.
*
* INPUTS:
*   *digi_handle                    - pointer to digi handle.
*   channel                         - ILKN channel ID
*   ILKN1                           - boolean to indicate if this is for ILKN1 or ILKN2
*                                       TRUE ILKN1
*                                       FALSE ILKN2
*
* OUTPUTS:
*
* RETURNS:
*   None
* 
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_ilkn_chnl_state_reset(digi_handle_t *digi_handle, 
                                        UINT32 channel,
                                        BOOL8 ILKN1)
{
    PMC_ENTRY();

    digi_ilkn_chnl_def_t *chnl_data_ptr;


    if (ILKN1 == TRUE)
    {
        chnl_data_ptr = &digi_handle->handle_pool.ilkn_1_chnl[DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX+channel];
    }
    else {
        chnl_data_ptr = &digi_handle->handle_pool.ilkn_2_chnl[DIGI_SIFD_ILKN_CPB_DPI_CHNLS_MAX+channel];
    }

    if (chnl_data_ptr->switch_data.header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG &&
        chnl_data_ptr->target == LAST_DIGI_ILKN_CHNL_TARGET &&
        chnl_data_ptr->rate == 0) 
    {
        chnl_data_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;
        chnl_data_ptr->switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_NOT_USED;
    }

    PMC_RETURN();
} /* digi_ilkn_chnl_state_reset */

/*******************************************************************************
* digi_chnl_ptr_initialize
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function resets a channel handle back to the default state so that
*   it is once again available for provisioning.
*
* INPUTS:
*   *switch_data_ptr                 - pointer to channel handle.
*
* OUTPUTS:
*
* RETURNS:
*   None
* 
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_chnl_ptr_initialize(util_global_switch_data_def_t* switch_data_ptr)
{
    PMC_ENTRY();

    switch_data_ptr->header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
    switch_data_ptr->header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG;

    switch_data_ptr->cpb_data.port_type = UTIL_GLOBAL_CPB_PORT_NOT_USED;
    switch_data_ptr->cpb_data.op_state.map_state.input_map_count = 0;
    switch_data_ptr->cpb_data.op_state.map_state.is_input_mapped = FALSE;
    switch_data_ptr->cpb_data.op_state.map_state.is_output_mapped = FALSE;
    switch_data_ptr->cpb_data.op_state.active_state = UTIL_GLOBAL_CHNL_ACTIVE_STATE_INACTIVE;
    
    switch_data_ptr->oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_NOT_USED;
    switch_data_ptr->oduk_data.op_state.map_state.input_map_count = 0;
    switch_data_ptr->oduk_data.op_state.map_state.is_input_mapped = FALSE;
    switch_data_ptr->oduk_data.op_state.map_state.is_output_mapped = FALSE;
    switch_data_ptr->oduk_data.op_state.active_state = UTIL_GLOBAL_CHNL_ACTIVE_STATE_INACTIVE;

    PMC_RETURN();
} /* digi_chnl_ptr_initialize */

#endif /* DOXYGEN_PUBLIC_ONLY */

/*******************************************************************************
* FUNCTION: digi_device_int_register_cb()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Registers a callback for device interrupt table processing.
*
*   This callback will be called when an active interrupt is found at the device
*   level.
*
*   The callback will be called a minimum of zero times if no active interrupts
*   are found, or a maximum of one time if there is an interrupt in at least
*   one channel.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   token           - user token to be stored and passed back to callback\n
*                     Optional, can be NULL.
*   token_size      - token size in bytes\n
*                     Optional, can be 0.
*   user_cb         - callback to be registered against this interrupt type
*
* OUTPUTS:
*   None
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_device_int_register_cb(digi_handle_t      *digi_handle,
                                             void               *token,
                                             UINT32              token_size,
                                             digi_int_cb_fcn     user_cb)
{
    PMC_ERROR            result = PMC_SUCCESS;
    digi_int_type_t      int_type = DIGI_INT_TYPE_DEVICE;

    PMC_ATOMIC_ENTRY(digi_handle);
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);


    if (PMC_SUCCESS == result)
    {
        result = digi_int_callback_set(digi_handle,
                                       int_type,
                                       token,
                                       token_size,
                                       user_cb);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_device_int_register_cb */

/*******************************************************************************
* FUNCTION: digi_device_int_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts based on bits that are set in the device 
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to device interrupt table with bits set to
*                     enable interrupts
*
* OUTPUTS:
*   None
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_device_int_enable(digi_handle_t            *digi_handle,
                                        digi_device_int_t        *int_table_ptr)
{
    PMC_ERROR           result = PMC_SUCCESS;
    digi_int_type_t     int_type = DIGI_INT_TYPE_DEVICE;
    BOOL                enable;
    UINT32              i;

    digi_device_int_t  *int_en_table_ptr;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    /* Callback for interrupt table must be registered before enable ints */
    if (PMC_SUCCESS == result)
    {
        if(!digi_int_is_cb_registered(digi_handle, int_type))
        {
            result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
        }
    }

    /* Get internal enabled aggregate interrupt table to update */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       int_type,
                                       (void**) &int_en_table_ptr);

    }

    /* Enable interrupts */
    enable = TRUE;

    /* S16 Line */
    for (i = 0; (result == PMC_SUCCESS) && (i < DIGI_SERDES_XFI_LANES_MAX); i++)
    {
        result = s16_int_chnl_enable(digi_handle->s16_line_handle,
                                     i,
                                     &int_table_ptr->s16_line[i],
                                     &int_en_table_ptr->s16_line[i],
                                     enable);
        
    }
    
    /* S16 System */
    for (i = 0; (result == PMC_SUCCESS) && (i < S16_MAX_NUM_SERDES); i++)
    {
        result = s16_int_chnl_enable(digi_handle->s16_sys_handle,
                                     i,
                                     &int_table_ptr->s16_sys[i],
                                     &int_en_table_ptr->s16_sys[i],
                                     enable);
        
    }


    /* MGMT_FEGE */
    if (PMC_SUCCESS == result)
    {
        result = digi_enet_mgmt_fege_int_internal_enable(digi_handle,
                                                         &int_table_ptr->mgmt_fege,
                                                         &int_en_table_ptr->mgmt_fege,
                                                         enable);
    }

    /* DCSU */
    for (i = 0; (result == PMC_SUCCESS) && (i < DIGI_DCSU_MAX_INST); i++)
    {
        digi_dcsu_int_cfg(digi_handle,
                          (digi_dcsu_inst_t)i,
                          NULL == int_table_ptr ? NULL : &int_table_ptr->dcsu[i],
                          &int_en_table_ptr->dcsu[i],
                          enable);
    }
    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_device_int_enable */


/*******************************************************************************
* FUNCTION: digi_device_int_disable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Disables interrupts based on bits that are set in the device 
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to device interrupt table with bits set to
*                     disable interrupts
*
* OUTPUTS:
*   None
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_device_int_disable(digi_handle_t            *digi_handle,
                                         digi_device_int_t        *int_table_ptr)
{
    PMC_ERROR           result = PMC_SUCCESS;
    digi_int_type_t     int_type = DIGI_INT_TYPE_DEVICE;
    BOOL                enable;
    UINT32              i;
    digi_device_int_t  *int_en_table_ptr;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* Get internal enabled interrupt table to update */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       int_type,
                                       (void**) &int_en_table_ptr);

    }

    /* Disable interrupts */
    enable = FALSE;

    /* S16 Line */
    for (i = 0; (result == PMC_SUCCESS) && (i < DIGI_SERDES_XFI_LANES_MAX); i++)
    {
        result = s16_int_chnl_enable(digi_handle->s16_line_handle,
                                     i,
                                     &int_table_ptr->s16_line[i],
                                     &int_en_table_ptr->s16_line[i],
                                     enable);        
    }
    
    /* S16 System */
    for (i = 0; (result == PMC_SUCCESS) && (i < S16_MAX_NUM_SERDES); i++)
    {
        result = s16_int_chnl_enable(digi_handle->s16_sys_handle,
                                     i,
                                     &int_table_ptr->s16_sys[i],
                                     &int_en_table_ptr->s16_sys[i],
                                     enable);
        
    }


    /* MGMT_FEGE */
    if (PMC_SUCCESS == result)
    {
        result = digi_enet_mgmt_fege_int_internal_enable(digi_handle,
                                                         &int_table_ptr->mgmt_fege,
                                                         &int_en_table_ptr->mgmt_fege,
                                                         enable);
    }

    /* DCSU */
    for (i = 0; (result == PMC_SUCCESS) && (i < DIGI_DCSU_MAX_INST); i++)
    {
        digi_dcsu_int_cfg(digi_handle,
                          (digi_dcsu_inst_t)i,
                          NULL == int_table_ptr ? NULL : &int_table_ptr->dcsu[i],
                          &int_en_table_ptr->dcsu[i],
                          DIGI_DISABLE);
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_device_int_disable */


/*******************************************************************************
* FUNCTION: digi_device_int_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears interrupts based on bits that are set in the device 
*   interrupt table.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   int_table_ptr   - pointer to device interrupt table with bits set to
*                     clear interrupts
*   
* OUTPUTS:
*   None
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_device_int_clear(digi_handle_t            *digi_handle,
                                       digi_device_int_t        *int_table_ptr)
{
    PMC_ERROR               result = PMC_SUCCESS;
    digi_int_type_t         int_type = DIGI_INT_TYPE_DEVICE;
    digi_device_int_t      *int_en_table_ptr;
    UINT32                  i;
       
    PMC_ATOMIC_ENTRY(digi_handle);

    /* Get internal enabled interrupt table to update */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       int_type,
                                       (void**) &int_en_table_ptr);

    }

    /* Clear interrupts */

    /* S16 Line */
    for (i = 0; (result == PMC_SUCCESS) && (i < DIGI_SERDES_XFI_LANES_MAX); i++)
    {
        result = s16_int_chnl_clear(digi_handle->s16_line_handle,
                                    i,
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, s16_line[i]),
                                    &int_en_table_ptr->s16_line[i]);
        
    }
    
    /* S16 System */
    for (i = 0; (result == PMC_SUCCESS) && (i < S16_MAX_NUM_SERDES); i++)
    {
        result = s16_int_chnl_clear(digi_handle->s16_sys_handle,
                                    i,
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, s16_sys[i]),
                                    &int_en_table_ptr->s16_sys[i]);
        
    }

    
    /* MGMT_FEGE */
    if (PMC_SUCCESS == result)
    {
        result = digi_enet_mgmt_fege_int_clear(digi_handle,
                                               UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, mgmt_fege));
    }

    /* DCSU */
    for (i = 0; (result == PMC_SUCCESS) && (i < DIGI_DCSU_MAX_INST); i++)
    {
        digi_dcsu_int_clear(digi_handle,
                            (digi_dcsu_inst_t)i,
                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, dcsu[i]));
    }

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_device_int_clear */


/*******************************************************************************
* FUNCTION: digi_device_int_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves a device interrupt table with interrupt bits.
*
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*
* OUTPUTS:
*   int_table_ptr  - pointer to device interrupt table to store interrupt
*                    information
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_device_int_retrieve(digi_handle_t      *digi_handle,
                                          digi_device_int_t   *int_table_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;
    UINT32                       i;

    PMC_ATOMIC_ENTRY(digi_handle);


    PMC_MEMSET(int_table_ptr, 0, sizeof(digi_device_int_t));

    /* enable interrupt caching, clear cache */
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, TRUE, TRUE);

    /* S16 Line */
    for (i = 0; (result == PMC_SUCCESS) && (i < DIGI_SERDES_XFI_LANES_MAX); i++)
    {
        result = s16_int_chnl_retrieve(digi_handle->s16_line_handle,
                                       i,
                                       DIGI_INT_ALL_INTS,
                                       &int_table_ptr->s16_line[i]);
        
    }
    
    /* S16 System */
    for (i = 0; (result == PMC_SUCCESS) && (i < S16_MAX_NUM_SERDES); i++)
    {
        result = s16_int_chnl_retrieve(digi_handle->s16_sys_handle,
                                       i,
                                       DIGI_INT_ALL_INTS,
                                       &int_table_ptr->s16_sys[i]);
        
    }

    /* disable interrupt caching */
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, FALSE, FALSE);

    
    /* MGMT_FEGE */
    if (PMC_SUCCESS == result)
    {
        result = digi_enet_mgmt_fege_int_retrieve(digi_handle,
                                                  &int_table_ptr->mgmt_fege);
    }


    /* DCSU */
    for (i = 0; (result == PMC_SUCCESS) && (i < DIGI_DCSU_MAX_INST); i++)
    {
        digi_dcsu_int_retrieve(digi_handle,
                               (digi_dcsu_inst_t)i,
                               &int_table_ptr->dcsu[i]);
    }

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_device_int_retrieve */


/*******************************************************************************
* FUNCTION: digi_device_int_enabled_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves a device interrupt table with enabled interrupt bits.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*
* OUTPUTS:
*   int_table_ptr  - pointer to device interrupt table to store enabled interrupt
*                    information
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_device_int_enabled_get(digi_handle_t       *digi_handle,
                                             digi_device_int_t   *int_table_ptr)
{
    PMC_ERROR                        result = PMC_SUCCESS;
    digi_int_type_t                  int_type = DIGI_INT_TYPE_DEVICE;
    digi_device_int_t               *int_en_table_ptr;
    
    PMC_ATOMIC_ENTRY(digi_handle);

    PMC_MEMSET(int_table_ptr, 0, sizeof(digi_device_int_t));




    /* Get internal enabled interrupt table to check */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       int_type,
                                       (void**) &int_en_table_ptr);

    }
   

    if (PMC_SUCCESS == result)
    {
        /* Copy enabled table to output */
        PMC_MEMCPY(int_table_ptr, int_en_table_ptr, sizeof(*int_table_ptr));
    }

    

    PMC_ATOMIC_RETURN(digi_handle, result);
} /* digi_device_int_enabled_get */


/*******************************************************************************
* FUNCTION: digi_device_int_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Searches enabled interrupt bits at the device level.
*
*   The callback associated with the device interrupt type will be called
*   if an active interrupt is found. The callback will be
*   called a minimum of zero times if no active interrupts are found, or
*   a maximum of one time if there is an interrupt in at least one channel.
*
*   A callback must be registered for the interrupt type before this API
*   can be called.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   
* OUTPUTS:
*   None
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_device_int_enabled_check(digi_handle_t   *digi_handle)
{
    PMC_ERROR            result = PMC_SUCCESS;

    PMC_ATOMIC_ENTRY(digi_handle);

    result = digi_device_int_enabled_check_internal(digi_handle);

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_device_int_enabled_check */

/*******************************************************************************
* FUNCTION: digi_oduksw_opsa_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API is used to change the OPSA packet size on-the-fly (on a channel
*   that is operational).  This API is intended to operate on an ILKN->X
*   path, where the packet size changes on the ILKN channel.
*
*   This will perform the same functionality as the follow steps, but with
*   optimzed device accesses:
*      digi_oduksw_chnl_deactivate()
*      digi_oduksw_chnl_demap()
*      digi_oif_pkt_period_calc()
*      digi_oduksw_chnl_map() : 
*      digi_oduksw_chnl_activate()
*
*  This API does not support modifying the packet size at FO2 (towards the
*  mapper) when the demapped client is broadcasted/multicasted across
*  the DCPB.  If you try to perform this operation the software will return
*  an error code.
*  
* INPUTS:
*   *digi_handle    - pointer to DIGI handle instance.
*   *output_pc_ptr  - util_global_switch_data_t pointer defining outbound port
*                     of the ODUKSW (ILKN->"X")
*   pkt_size        - desired packet size to pass through ODUKSW.  The packet size
*                     and packet period information is used to configure
*                     packet maker and packet monitor blocks surrounding ODUKSW
*                     to monitor the client rate.
*   pkt_per_int     - integer portion of packet period
*   pkt_per_n       - numerator of the packet period
*   pkt_per_d       - denominator of the packet period
*   hys_buffer_en   - custom hysteresis buffer size mode:\n
*                     TRUE : custom hysteresis buffer size mode is enable 
*                     FALSE : custom hysteresis buffer size mode is disabled
*   hys_buffer      - hysteresis buffer size in refclk cycles
*   latency_s       - Maximum system latency outside the DIGI device.  
*                     Specified in units of 3.125 ns ticks.  The maximum 
*                     supported value is 38880 representing a maximum system 
*                     latency of 125 useconds.  This parameter is used to 
*                     configure the MPMO hold off delay following MPMOs
*                     reception of the first packet. Otherwise, set to 0.
*                     If the external latency is not changing when performing
*                     this update, provide the same value provided in
*                     digi_oduksw_chnl_map().
*   
* OUTPUTS:
*   None
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_oduksw_opsa_update(digi_handle_t *digi_handle,
                                         util_global_switch_data_t *output_pc_ptr,
                                         UINT32 pkt_size,
                                         UINT32 pkt_per_int,
                                         UINT32 pkt_per_n,
                                         UINT32 pkt_per_d,
                                         BOOL   hys_buffer_en, 
                                         UINT32 hys_buffer,
                                         UINT32 latency_s)
{
    PMC_ERROR result = PMC_SUCCESS;

    digi_otn_server_chnl_def_t *otn_server_ptr;
    BOOL is_output_ho_unchnl;
    BOOL is_sysotn_card;
    BOOL is_output_ilkn_1;
    util_global_switch_data_def_t *local_output_sw_ptr = (util_global_switch_data_def_t *)output_pc_ptr;
    util_global_oduk_port_data_t *local_output_pc_ptr = &(local_output_sw_ptr->oduk_data);
    odu_struct_t *odu_ptr; 

    util_global_cpb_port_t dest_port_type;
    UINT32 dest_channel;

    util_global_switch_data_t *cpb_output_port = NULL;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* reprovision the OPSA related configs in COREOTN*/
    if(result == PMC_SUCCESS)
    {

        result = coreotn_oduksw_reprov_pkt_size_configs(digi_handle->coreotn_handle,
                                                        (coreotn_oduksw_output_port_type_t)local_output_pc_ptr->port_type,
                                                        local_output_pc_ptr->odu_level,
                                                        local_output_pc_ptr->channel,
                                                        pkt_size,
                                                        pkt_per_int,
                                                        pkt_per_n,
                                                        pkt_per_d,
                                                        hys_buffer_en, 
                                                        hys_buffer,
                                                        latency_s);

    } 



    /*Decide if the ACB settings need to be updated.  ACB updates are only
      required for UNCHANNELIZED ODUs connecting from the LINEOTN or SYSOTN to
      the ODUKSW*/
 
    if (PMC_SUCCESS == result)
    {
        /* retrieve the values for the rest of our local variables */
        is_output_ho_unchnl = (local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_COREOTN  
                               && local_output_pc_ptr->odu_level == UTIL_GLOBAL_LEVEL_HO_ODU  
                               && digi_handle->var.odu_chnl_payload[local_output_pc_ptr->channel] == DIGI_ODU_UNCHANNELIZED);

        is_sysotn_card = (digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD);

        is_output_ilkn_1 = (local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_ILKN1);
        
    }

    /* activate lineotn tx if LINEOTN HO Framer is unchannelized    *OR*
     * if chnl of type ILKN and we are in DIGI_PROD_APP_SYSOTN_CARD      */
    if (PMC_SUCCESS == result &&
        ((is_output_ho_unchnl == TRUE) || 
         (is_output_ilkn_1 == TRUE && is_sysotn_card == TRUE)))
    {
        odu_ptr = (odu_struct_t *)output_pc_ptr;

        /* Disable ACB so we can update configs (PMM_ADAPT_ENABLE must be 0
           while changing the ACB configurations */
        if(is_output_ilkn_1 == TRUE && is_sysotn_card == TRUE)
        {
            digi_opsa_cfg_mpmo_one_port_drop(digi_handle,
                                             OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_CTL,
                                             odu_ptr->switch_data.oduk_data.channel);                                               
        }
        else
        {
            digi_opsa_cfg_mpmo_one_port_drop(digi_handle,
                                             OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_FO1,
                                             odu_ptr->switch_data.oduk_data.channel);        
        }


        if(local_output_pc_ptr->lineotn_src) {
            otn_server_ptr = digi_otn_server_chnl_get(digi_handle, local_output_pc_ptr->channel);

        } else {

            otn_server_ptr = digi_sysotn_server_chnl_get(digi_handle);
        }


        /* reprovision the ACB configs */
        if(result == PMC_SUCCESS)
        {
            result = digi_otn_acb_reprov_pkt_size_configs(digi_handle,
                                                          otn_server_ptr);
        }

          
        /*re-enable the ACB.  Note this API is used to remove nominal replacement
          when disabling OCI maintenance signal, but it will work for this
          application */
        if(result == PMC_SUCCESS)
        {
            result = digi_otn_remove_nominal_replacement(digi_handle,
                                                         odu_ptr);              
        }

    }

    /*if it's a MAPOTN port, see if client side ACB settings need updating*/
    if( (result==PMC_SUCCESS) && 
        local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_MAPOTN)
    {
        util_global_cpb_connect_t *cpb_connect_data_ptr = NULL;
        /*get the connection infomation across the CPB*/
        cpb_connect_data_state_get(digi_handle->dcpb_handle,
                                   &cpb_connect_data_ptr);

        /*find the primary destination across the CPB
          (does not support multicast)*/

        dest_port_type = (util_global_cpb_port_t)cpb_connect_data_ptr->chnl[local_output_pc_ptr->port_type][local_output_pc_ptr->channel].slv.dest_mst_port;
        dest_channel = cpb_connect_data_ptr->chnl[local_output_pc_ptr->port_type][local_output_pc_ptr->channel].slv.dest_mst_chnl;


      
          
        if(dest_port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE ||
           dest_port_type == UTIL_GLOBAL_CPB_PORT_ENET_SYS ||
           dest_port_type == UTIL_GLOBAL_CPB_PORT_CBRC)
        {

            if(dest_port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE)
            {
                cpb_output_port = (util_global_switch_data_t *)(&digi_handle->handle_pool.enet_line_chnl[dest_channel]);
            } else if(dest_port_type == UTIL_GLOBAL_CPB_PORT_ENET_SYS)
            {
                cpb_output_port =  (util_global_switch_data_t *)(&digi_handle->handle_pool.enet_sys_chnl[dest_channel]);
            } else if(dest_port_type == UTIL_GLOBAL_CPB_PORT_CBRC)
            {
                cpb_output_port =  (util_global_switch_data_t *)(&digi_handle->handle_pool.cbr_chnl[dest_channel]);
            }

            /* Only perform ACB configuration when we are not in enhanced PMON
             * mode */
            if (PMC_SUCCESS == result)
            {       

                /*call this API with input and output ports across the CPB*/

                result = digi_non_otn_acb_reprov_pkt_size_configs(digi_handle,
                                                                  local_output_sw_ptr,
                                                                  cpb_output_port,
                                                                  LAST_DIGI_ENET_TX_TIMING_MODE);
            }
        }
    }

    PMC_ATOMIC_RETURN(digi_handle,result);
} /* digi_oduksw_opsa_update */

#ifndef DOXYGEN_PUBLIC_ONLY

/*******************************************************************************
* digi_otn_acb_reprov_pkt_size_configs
* ______________________________________________________________________________
*
* DESCRIPTION:
*   API to reprovision ACB configs in the event of an OPSA packet size change.
*   This will only be used for UNCHANNELIZED ODUs connecting from LINE or
*   SYS to the ODUKSW.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   *otn_server_ptr     - pointer to OTU framer 
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_acb_reprov_pkt_size_configs(digi_handle_t *digi_handle,
                                                       digi_otn_server_chnl_def_t *otn_server_ptr)
{
    UINT32 port_uid;
    digi_serdes_intf_t intf;
    UINT32 num_10g_data_lane = 0;
    acb_ft_prov_cfg_t acb_ft_prov_cfg;
    digi_serdes_port_def_t *port_def_ptr;
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 ppm_max;
    digi_serdes_port_mode_t serdes_rate;
    digi_serdes_port_mode_t serdes_mode;
    UINT32 chnl;
    coreotn_mpmo_inst_t coreotn_mpmo_inst = LAST_COREOTN_MPMO_INST;
    UINT32 serdes_pin; 
    UINT32 i;
    lifd_sig_src_type_t dummy_acb_if_sel_clk_source;
    
    PMC_ENTRY();

    port_uid = otn_server_ptr->port_uid;
    chnl = otn_server_ptr->dci_chnl;
    serdes_mode = otn_server_ptr->serdes_mode;

    PMC_LOG_TRACE("port_uid:%d\n", port_uid);
    
    /* Search for the port and find the interface */
    port_def_ptr = digi_port_ctxt_and_intf_find(digi_handle,
                                                port_uid,
                                                &intf);
    if (NULL != port_def_ptr)
    {
        /* compute MAX PMM diff */
        PMC_MEMSET((void *)&acb_ft_prov_cfg, 0, sizeof(acb_ft_prov_cfg_t));
        /* PPM depends on serdes rate */
        /* find master lane serdes rate to determine if serdes clock are over clocked */
        switch(intf)
        {
        case DIGI_SERDES_LINE_INTF:
            serdes_rate = digi_handle->var.serdes_ctxt.s16_line_lanes_rate[port_def_ptr->master_lane];
            break;
        case DIGI_SERDES_SYSTEM_INTF:
            serdes_rate = digi_handle->var.serdes_ctxt.s16_sys_lanes_rate[port_def_ptr->master_lane];
            break;
        case DIGI_SERDES_SFI_51_INTF:
            serdes_rate = digi_handle->var.serdes_ctxt.sfi51_lanes_rate[port_def_ptr->master_lane];
            break;
        default:
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
            break;        
        }

        /* set OTN-OTN PPM default maximum value */
        ppm_max = DIGI_SERDES_MAX_PPM_COMPUTE(DIGI_SERDES_OTN_MAX_PPM, DIGI_SERDES_OTN_MAX_PPM);
        /* if overclocked serdes, PPM range is 120 */
        if (DIGI_SERDES_PORT_MODE_S16_OTU1E == serdes_rate ||
            DIGI_SERDES_PORT_MODE_S16_OTU1F == serdes_rate ||
            DIGI_SERDES_PORT_MODE_S16_OTU2E == serdes_rate ||
            DIGI_SERDES_PORT_MODE_S16_OTU2F == serdes_rate )
        {
        
            ppm_max = DIGI_SERDES_MAX_PPM_COMPUTE(DIGI_OVRCLOCKED_SERDES_OTN_MAX_PPM, 
                                                  DIGI_OVRCLOCKED_SERDES_OTN_MAX_PPM);
        }

        acb_ft_prov_cfg.max_ppm = ppm_max;
        
        num_10g_data_lane = digi_serdes_num_10g_data_lane_get((util_global_odukp_type_t)otn_server_ptr->oduk_type);

        digi_otn_mpmo_get(digi_handle, intf, &dummy_acb_if_sel_clk_source, &coreotn_mpmo_inst);


        switch(intf)
        {
        case DIGI_SERDES_LINE_INTF:

            for(i=0;i<DIGI_SERDES_XFI_LANES_MAX;i++)
            {
                if(PMC_SUCCESS == result && digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid == port_uid)
                {
                    serdes_pin = i;

                    result = digi_serdes_otn_acb_reprov_pkt_size_configs(digi_handle,
                                                                         serdes_pin, 
                                                                         port_def_ptr->master_lane,
                                                                         intf,
                                                                         serdes_mode, 
                                                                         coreotn_mpmo_inst,
                                                                         chnl,
                                                                         num_10g_data_lane,
                                                                         &acb_ft_prov_cfg);                  
                }
            }

            break;
        case DIGI_SERDES_SYSTEM_INTF:

            for (i = 0; i < DIGI_SERDES_SYS_LANES_MAX; i++)
            {
                if(PMC_SUCCESS == result && digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid == port_uid)
                {
                    serdes_pin = i;

                    result = digi_serdes_otn_acb_reprov_pkt_size_configs(digi_handle,
                                                                         serdes_pin, 
                                                                         port_def_ptr->master_lane,
                                                                         intf,
                                                                         serdes_mode, 
                                                                         coreotn_mpmo_inst,
                                                                         chnl,
                                                                         num_10g_data_lane,
                                                                         &acb_ft_prov_cfg);
                }
            }

            break;
        case DIGI_SERDES_SFI_51_INTF:
                    
            for (i = 0; i < DIGI_NUM_SFI51_PORTS_MAX; i++) 
            {
                if(PMC_SUCCESS == result && digi_handle->var.pin_bus_ctxt.sfi51_bus_ctxt[i].port_uid == port_uid)
                {
                    serdes_pin = i;

                    result = digi_serdes_otn_acb_reprov_pkt_size_configs(digi_handle,
                                                                         serdes_pin, 
                                                                         port_def_ptr->master_lane,
                                                                         intf,
                                                                         serdes_mode, 
                                                                         coreotn_mpmo_inst,
                                                                         chnl,
                                                                         num_10g_data_lane,
                                                                         &acb_ft_prov_cfg);
                }
            }

            break;
        default:
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
            break;        
        }


    }

    PMC_RETURN(result);

} /* digi_otn_acb_reprov_pkt_size_configs */

#endif /* DOXYGEN_PUBLIC_ONLY */

/*******************************************************************************
* digi_otn_payload_type_transition
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Used to transition the payload type of an empty HO container in RX and TX.
*   Can be used to transition the payload type for:
*      - HO channel
*      - MO channel (only for non-SYSOTN mode)
*
*   This will accomplish  similar configuration as calling digi_otn_server_ho_deprov()
*   then digi_otn_server_ho_prov() on the HO channel, or digi_otn_server_lo_deprov()
*   then digi_otn_server_lo_prov() on the MO channel.  However
*   all HO configurations are preserved (such as TCMs) through this transition so that 
*   the HO channel can still be monitored.
*
*   The sequence is also optimized for HO ODU4 to experience the least distuption 
*   to traffic (the channel will experience OOF).  For all other rate
*   transitions or for MO transitions LOF will be seen.
*
*   This API will also automatically provision the PM layer in the event that there
*   is a transition from UNCHANNELIZED->CHANNELIZED payload.
*
*   Supports the following transitions:
*
*   DIGI_ODU_UNCHANNELIZED --> DIGI_ODU_TS_1G25
*   DIGI_ODU_UNCHANNELIZED --> DIGI_ODU_TS_2G5
*   DIGI_ODU_UNCHANNELIZED --> DIGI_ODU_NULL
*   DIGI_ODU_TS_1G25 --> DIGI_ODU_UNCHANNELIZED
*   DIGI_ODU_TS_1G25 --> DIGI_ODU_NULL
*   DIGI_ODU_TS_1G25 --> DIGI_ODU_TS_2G5
*   DIGI_ODU_TS_2G5 --> DIGI_ODU_UNCHANNELIZED
*   DIGI_ODU_TS_2G5 --> DIGI_ODU_NULL
*   DIGI_ODU_TS_2G5 --> DIGI_ODU_TS_1G25
*   DIGI_ODU_NULL --> DIGI_ODU_UNCHANNELIZED
*   DIGI_ODU_NULL --> DIGI_ODU_TS_1G25
*   DIGI_ODU_NULL --> DIGI_ODU_TS_2G5
*
* INPUTS:
*   *digi_handle            - pointer to DIGI handle instance.
*   *odu_chnl_ctxt_ptr      - pointer to ODU channel
*   new_payload_mode        - The payload mode to transition to
*
* OUTPUTS:
*
* RETURNS:
*   None
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_payload_type_transition(digi_handle_t *digi_handle,
                                                  digi_otn_odu_chnl_t  *odu_chnl_ctxt_ptr,
                                                  digi_odu_line_payload_t new_payload_mode)
{

    PMC_ERROR result = PMC_SUCCESS;
    odu_struct_t *ho_odu_struct_ptr = NULL;
    odu_struct_t *odu_struct_ptr = NULL;
    digi_oduk_t oduk_type;
    DOUBLE client_bitrate;
    digi_otn_mapping_type_t mapping_mode = LAST_DIGI_OTN_MAP;
    UINT32 tx_trib_slot_mask[3];
    UINT32 rx_trib_slot_mask[3];
    BOOL is_src_sysotn_server;
    digi_otn_server_chnl_def_t *otn_server_ptr;
    UINT32 i;
    UINT32 ho_chnl_id;
    digi_odu_line_payload_t old_payload_mode;
    UINT16 dummy_pool_id;
    odu_struct_odu_frm_layer_struct_t rfrm_layers[ODU_SINK_MAX_PM_TCM_LAYERS];
    UINT32 num_layers = 0;
    odu_struct_odu_frm_pm_tcm_id_t rfrm_pm_parent = ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_DONT_CARE;
    BOOL operational_found;
    BOOL8 is_sysotn = FALSE;

    PMC_ATOMIC_ENTRY(digi_handle);

    /* retrieve the odu_struct for this ho channel */
    odu_struct_ptr = (odu_struct_t*)(odu_chnl_ctxt_ptr);
    PMC_ASSERT(odu_struct_ptr != NULL, DIGI_ERR_OOM, 0, 0);

    old_payload_mode = (digi_odu_line_payload_t)odu_struct_ptr->mem_ptr->payload_format;


    if( (digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD &&
         odu_struct_ptr->mem_ptr->odu_level != ODU_STRUCT_LEVEL_HO_ODU) ||
        (digi_handle->var.prod_app != DIGI_PROD_APP_SYSOTN_CARD &&
         (odu_struct_ptr->mem_ptr->odu_level != ODU_STRUCT_LEVEL_HO_ODU &&
          odu_struct_ptr->mem_ptr->odu_level != ODU_STRUCT_LEVEL_MO_ODU)))
    {
        PMC_ATOMIC_RETURN(digi_handle, DIGI_ERR_INVALID_ARG); 
    }


    if(odu_struct_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_HO_ODU)
    {
        if( odu_struct_ptr->switch_data.oduk_data.lineotn_src)
        {
            is_src_sysotn_server = FALSE;
            otn_server_ptr = digi_otn_server_chnl_get(digi_handle,
                                                      odu_struct_ptr->mem_ptr->chnl_id);
        }
        else
        {
            is_src_sysotn_server = TRUE;
            otn_server_ptr = digi_sysotn_server_chnl_get(digi_handle);
        }

        if(odu_struct_ptr->mem_ptr->odu_type == UTIL_GLOBAL_ODU4)
        {
            if(old_payload_mode == DIGI_ODU_UNCHANNELIZED &&
               new_payload_mode != DIGI_ODU_UNCHANNELIZED)
            {
                /*set DCI MUX to take from MPMO*/
                if(digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
                {
                    if(result == PMC_SUCCESS)
                    {
                        result = coreotn_dci_mux4_xoff_cfg(digi_handle->coreotn_handle,
                                                           COREOTN_FMF_INST_2, 
                                                           COREOTN_DCI_MUX4_LO_DCI_INTF, 
                                                           COREOTN_XOFF_SEL_ZERO);
                    }
                }
                else
                {
                    if(result == PMC_SUCCESS)
                    {
                        result = coreotn_dci_mux4_xoff_cfg(digi_handle->coreotn_handle,
                                                           COREOTN_FMF_INST_1, 
                                                           COREOTN_DCI_MUX4_LO_DCI_INTF, 
                                                           COREOTN_XOFF_SEL_ZERO);
                    }

                    if(result == PMC_SUCCESS)
                    {
                        result = coreotn_dci_mux4_xoff_cfg(digi_handle->coreotn_handle,
                                                           COREOTN_FMF_INST_2, 
                                                           COREOTN_DCI_MUX4_LO_DCI_INTF, 
                                                           COREOTN_XOFF_SEL_ZERO);
                    }

                }


                /*deprov, but do not deprovision FO1 schedule*/
                if(result == PMC_SUCCESS)
                {
                    result = digi_otn_server_ho_internal_deprov(digi_handle,
                                                                &odu_chnl_ctxt_ptr,
                                                                otn_server_ptr,
                                                                is_src_sysotn_server,
                                                                FALSE,
                                                                FALSE);
                }

          
                if(result == PMC_SUCCESS)
                {
                    result = digi_otn_server_ho_internal_prov(digi_handle,
                                                              otn_server_ptr,
                                                              DIGI_OTN_DIRECT_DEVICE_CONFIG,
                                                              new_payload_mode,
                                                              is_src_sysotn_server,
                                                              &odu_chnl_ctxt_ptr,
                                                              FALSE,
                                                              FALSE);
                }



                if(digi_handle->var.prod_app != DIGI_PROD_APP_SYSOTN_CARD)
                {
                    /*set back DCI MUX to take from MUX*/
                    if(result == PMC_SUCCESS)
                    {
                        result = digi_coreotn_dci_mux_xoff_cfg(digi_handle,
                                                               UTIL_GLOBAL_ODU4,
                                                               new_payload_mode);
                    }
                }
                else
                {
                    if(result == PMC_SUCCESS)
                    {
                        result = coreotn_dci_mux4_xoff_cfg(digi_handle->coreotn_handle,
                                                           COREOTN_FMF_INST_2, 
                                                           COREOTN_DCI_MUX4_ODTU_MUX, 
                                                           COREOTN_XOFF_SEL_ONE);
                    }
                }


                /*deprovision FO1 schedule*/
                if(result == PMC_SUCCESS)
                {
                    result = coreotn_tx_dummy_schd_deprov(digi_handle->coreotn_handle,
                                                          odu_struct_ptr->mem_ptr->chnl_id);
                }
                is_sysotn = FALSE;

                if(digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
                {
                    is_sysotn = TRUE;
                }
                result = coreotn_reset_mux(digi_handle->coreotn_handle,
                                           odu_struct_ptr->mem_ptr->chnl_id,
                                           is_sysotn);
            }
            else
            {
                /*provision FO1 schedule*/
                if(result == PMC_SUCCESS)
                {
                    result = coreotn_tx_dummy_schd_prov(digi_handle->coreotn_handle,
                                                        odu_struct_ptr->mem_ptr->chnl_id);
                }

                /*set DCI MUX to take from MPMO*/
                 if(digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
                {
                    if(result == PMC_SUCCESS)
                    {
                        result = coreotn_dci_mux4_xoff_cfg(digi_handle->coreotn_handle,
                                                           COREOTN_FMF_INST_2, 
                                                           COREOTN_DCI_MUX4_LO_DCI_INTF, 
                                                           COREOTN_XOFF_SEL_ZERO);
                    }
                }
                else
                {
                    if(result == PMC_SUCCESS)
                    {
                        result = coreotn_dci_mux4_xoff_cfg(digi_handle->coreotn_handle,
                                                           COREOTN_FMF_INST_1, 
                                                           COREOTN_DCI_MUX4_LO_DCI_INTF, 
                                                           COREOTN_XOFF_SEL_ZERO);
                    }

                    if(result == PMC_SUCCESS)
                    {
                        result = coreotn_dci_mux4_xoff_cfg(digi_handle->coreotn_handle,
                                                           COREOTN_FMF_INST_2, 
                                                           COREOTN_DCI_MUX4_LO_DCI_INTF, 
                                                           COREOTN_XOFF_SEL_ZERO);
                    }

                }


                if(result == PMC_SUCCESS)
                {
                    result = digi_otn_server_ho_internal_deprov(digi_handle,
                                                                &odu_chnl_ctxt_ptr,
                                                                otn_server_ptr,
                                                                is_src_sysotn_server,
                                                                FALSE,
                                                                FALSE);
                }

                /*prov but don't provision FO1 schedule*/
                if(result == PMC_SUCCESS)
                {
                    result = digi_otn_server_ho_internal_prov(digi_handle,
                                                              otn_server_ptr,
                                                              DIGI_OTN_DIRECT_DEVICE_CONFIG,
                                                              new_payload_mode,
                                                              is_src_sysotn_server,
                                                              &odu_chnl_ctxt_ptr,
                                                              FALSE,
                                                              FALSE);
                }

                
                /*set back DCI MUX to take from MUX*/
                if(digi_handle->var.prod_app != DIGI_PROD_APP_SYSOTN_CARD)
                {
                    /*set back DCI MUX to take from MUX*/
                    if(result == PMC_SUCCESS)
                    {
                        result = digi_coreotn_dci_mux_xoff_cfg(digi_handle,
                                                               UTIL_GLOBAL_ODU4,
                                                               new_payload_mode);
                    }
                }
                else
                {
                    if(result == PMC_SUCCESS)
                    {
                        result = coreotn_dci_mux4_xoff_cfg(digi_handle->coreotn_handle,
                                                           COREOTN_FMF_INST_2, 
                                                           COREOTN_DCI_MUX4_ODTU_MUX, 
                                                           COREOTN_XOFF_SEL_ONE);
                    }
                }
                is_sysotn = FALSE;

                if(digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
                {
                    is_sysotn = TRUE;
                }
                result = coreotn_reset_mux(digi_handle->coreotn_handle,
                                           odu_struct_ptr->mem_ptr->chnl_id,
                                           is_sysotn);
            }
        } /* if(odu_struct_ptr->mem_ptr->odu_type == UTIL_GLOBAL_ODU4) */
        else
        {
                /*deprov, but deprovision FO1 schedule*/
                if(result == PMC_SUCCESS)
                {
                    result = digi_otn_server_ho_internal_deprov(digi_handle,
                                                                &odu_chnl_ctxt_ptr,
                                                                otn_server_ptr,
                                                                is_src_sysotn_server,
                                                                FALSE,
                                                                TRUE);
                }

          
                if(result == PMC_SUCCESS)
                {
                    result = digi_otn_server_ho_internal_prov(digi_handle,
                                                              otn_server_ptr,
                                                              DIGI_OTN_DIRECT_DEVICE_CONFIG,
                                                              new_payload_mode,
                                                              is_src_sysotn_server,
                                                              &odu_chnl_ctxt_ptr,
                                                              FALSE,
                                                              TRUE);
                }

        }


    }
    else if(odu_struct_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_MO_ODU)
    {
        if(result == PMC_SUCCESS)
        {
            result = digi_odu_rate_param_convert(((odu_struct_t *)odu_chnl_ctxt_ptr)->mem_ptr->odu_type,
                                                 &oduk_type);
        }

        if(result == PMC_SUCCESS)
        {
            result = digi_coreotn_mapping_mode_convert_reverse(((odu_struct_t *)odu_chnl_ctxt_ptr)->mem_ptr->mapping_mode,
                                                               &mapping_mode);
        }
        client_bitrate = ((odu_struct_t *)odu_chnl_ctxt_ptr)->mem_ptr->client_bitrate;
        for (i = 0; i < 3; i++)
        {
            tx_trib_slot_mask[i] = ((odu_struct_t *)odu_chnl_ctxt_ptr)->mem_ptr->tx_trib_loc_mask[i];
            rx_trib_slot_mask[i] = ((odu_struct_t *)odu_chnl_ctxt_ptr)->mem_ptr->rx_trib_loc_mask[i];
        }

        
        if(result == PMC_SUCCESS)
        {
            result = coreotn_db_ho_chnl_id_get(digi_handle->coreotn_handle,
                                               0,
                                               (util_global_odu_level_t)UTIL_GLOBAL_LEVEL_MO_ODU,
                                               odu_struct_ptr->mem_ptr->chnl_id,
                                               &ho_chnl_id);
        }

        if(result == PMC_SUCCESS)
        {
            ho_odu_struct_ptr = &(digi_handle->handle_pool.ho_odu_struct[ho_chnl_id]); 
        }

        if(result == PMC_SUCCESS)
        {
            result = digi_otn_server_lo_deprov_internal(digi_handle,
                                                        &odu_chnl_ctxt_ptr,
                                                        (digi_otn_odu_chnl_t**)&ho_odu_struct_ptr,
                                                        DIGI_OTN_DEPROV_RX_AND_TX,
                                                        FALSE);
        }


        if(result == PMC_SUCCESS)
        {
            result = digi_otn_server_lo_prov_internal(digi_handle,
                                                      (digi_otn_odu_chnl_t*)ho_odu_struct_ptr,
                                                      DIGI_OTN_DIRECT_DEVICE_CONFIG,
                                                      oduk_type,
                                                      client_bitrate,
                                                      mapping_mode,
                                                      tx_trib_slot_mask,
                                                      rx_trib_slot_mask,
                                                      new_payload_mode,
                                                      &odu_chnl_ctxt_ptr,
                                                      FALSE);
        }
    }


    /* provision or unprovision the HO PM layer if the payload type has changed
       from UNCHANNELIZED to CHANNELIZED */
    if(new_payload_mode == DIGI_ODU_UNCHANNELIZED &&
       old_payload_mode != DIGI_ODU_UNCHANNELIZED)
    {
        if(result == PMC_SUCCESS)
        {
            result = odu_struct_rx_pm_tcmi_set(digi_handle->coreotn_handle,
                                               odu_struct_ptr,
                                               ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM,
                                               0,
                                               0,
                                               0,
                                               ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_DONT_CARE,
                                               ODU_STRUCT_PM_TCM_TT_TRANSPARENT,
                                               ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE,
                                               &dummy_pool_id);
        }

        if (PMC_SUCCESS == result)
        {
            result = odu_struct_rx_pm_tcmi_activate(digi_handle->coreotn_handle,
                                                    odu_struct_ptr);
        }



        if(result == PMC_SUCCESS)
        {
            result = odu_struct_tx_pm_tcmi_set(digi_handle->coreotn_handle,
                                               odu_struct_ptr,
                                               ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM,
                                               0,
                                               0,
                                               ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_DONT_CARE,
                                               ODU_STRUCT_PM_TCM_TT_TRANSPARENT,
                                               ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE,
                                               &dummy_pool_id);
        }

    }
    else if(old_payload_mode == DIGI_ODU_UNCHANNELIZED &&
            new_payload_mode != DIGI_ODU_UNCHANNELIZED)
    {
        /*provision the PM layer at the RFRM/TFRM*/
        if(result == PMC_SUCCESS)
        {
            result = odu_struct_rx_odu_pm_tcmi_layer_get(digi_handle->coreotn_handle,
                                                         odu_struct_ptr,
                                                         &rfrm_layers,
                                                         &num_layers);
        }

        if(num_layers == 0)
        {
            rfrm_pm_parent = ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_DCI;
        }
        else
        {
            /*find first operation parent to connect to*/
            operational_found = FALSE;
            for(i=0;i<num_layers;i++)
            {
                if(rfrm_layers[num_layers-1-i].tcm_mode != ODU_STRUCT_PM_TCM_NON_INTRUSIVE_MONITOR)
                {
                    operational_found = TRUE;
                    rfrm_pm_parent = rfrm_layers[num_layers-1-i].pm_tcm_num;
                }
            }

            if(operational_found == FALSE)
            {
                rfrm_pm_parent = ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_DCI;
            }
        }



        if(result == PMC_SUCCESS)
        {
            result = odu_struct_rx_pm_tcmi_set(digi_handle->coreotn_handle,
                                               odu_struct_ptr,
                                               ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM,
                                               0,
                                               0,
                                               0,
                                               rfrm_pm_parent,
                                               ODU_STRUCT_PM_TCM_TT_OPERATIONAL,
                                               ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE,
                                               &dummy_pool_id);
        }

        if (PMC_SUCCESS == result)
        {
            result = odu_struct_rx_pm_tcmi_activate(digi_handle->coreotn_handle,
                                                    odu_struct_ptr);
        }     

        if(result == PMC_SUCCESS)
        {
            result = odu_struct_tx_pm_tcmi_set(digi_handle->coreotn_handle,
                                               odu_struct_ptr,
                                               ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM,
                                               0,
                                               0,
                                               ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_DCI,
                                               ODU_STRUCT_PM_TCM_TT_OPERATIONAL,
                                               ODU_STRUCT_CONFIG_TARGET_ODU_STRUCT_DEVICE,
                                               &dummy_pool_id);
        }

    }

    PMC_ATOMIC_RETURN(digi_handle,result);
}

#ifndef DOXYGEN_PUBLIC_ONLY
/* private functions */

/*******************************************************************************
* FUNCTION: digi_int_disable_all()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Disable all interrupts
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*
* OUTPUTS:
*
* RETURNS:
*   None
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_int_disable_all(digi_handle_t   *digi_handle)
{
    digi_int_t *int_table_ptr;
    digi_int_otn_t *int_otn_table_ptr;
#ifdef PMC_TESTS 
    PMC_ATOMIC_ENTRY_VOID(digi_handle);
#else 
    PMC_ENTRY();
#endif 

    int_table_ptr = (digi_int_t *) PMC_CALLOC(sizeof(digi_int_t));
    int_otn_table_ptr = (digi_int_otn_t *) PMC_CALLOC(sizeof(digi_int_otn_t));
    PMC_MEMSET(int_table_ptr,0xFF,sizeof(digi_int_t));
    PMC_MEMSET(int_otn_table_ptr,0xFF,sizeof(digi_int_otn_t));

    /* disable interrupts */
    (void) digi_device_int_disable(digi_handle, &int_table_ptr->device);   
    (void) digi_pmon_int_disable(digi_handle,&int_table_ptr->pmon);   

    (void) digi_mapper_int_mapotn_disable(digi_handle,&int_table_ptr->mapper.mapotn); 
    (void) digi_mapper_int_fo2_disable(digi_handle,&int_table_ptr->mapper.fo2); 
    (void) digi_mapper_int_chnl_disable(digi_handle,DIGI_INT_ALL_CHNLS,&int_table_ptr->mapper.mapper_chnl[0].status);
    (void) digi_mapper_int_fo2_chnl_disable(digi_handle,DIGI_INT_ALL_CHNLS,&int_otn_table_ptr->framer_stg4[0]);

    (void) digi_otn_int_coreotn_disable(digi_handle,&int_table_ptr->otn.coreotn);

    (void) digi_otn_odu_int_ohp_chnl_disable(digi_handle, ODU_OHP_1 ,DIGI_INT_ALL_CHNLS,&int_otn_table_ptr->ohp_1[0]);
    (void) digi_otn_odu_int_ohp_chnl_disable(digi_handle, ODU_OHP_2 ,DIGI_INT_ALL_CHNLS,&int_otn_table_ptr->ohp_2[0]);
    (void) digi_otn_odu_int_ohp_chnl_disable(digi_handle, ODU_OHP_3 ,DIGI_INT_ALL_CHNLS,&int_otn_table_ptr->ohp_3[0]);    
    (void) digi_otn_odu_int_ohp_disable(digi_handle, ODU_OHP_1 ,&int_table_ptr->otn.ohp[0]);        
    (void) digi_otn_odu_int_ohp_disable(digi_handle, ODU_OHP_2 ,&int_table_ptr->otn.ohp[1]);
    (void) digi_otn_odu_int_ohp_disable(digi_handle, ODU_OHP_3 ,&int_table_ptr->otn.ohp[2]);
    
    (void) digi_otn_odu_int_ri_rcp_chnl_disable(digi_handle,DIGI_INT_ALL_CHNLS,&int_otn_table_ptr->ri_rcp[0]);
    (void) digi_otn_odu_int_ri_rcp_disable(digi_handle,&int_table_ptr->otn.ri_rcp);
    (void) digi_otn_odu_int_di_rcp_disable(digi_handle,&int_table_ptr->otn.di_rcp);

    (void) digi_otn_server_int_disable(digi_handle,&int_table_ptr->otn.lineotn);
    (void) digi_sysotn_server_int_disable(digi_handle,&int_table_ptr->otn.sysotn);
    (void) digi_otn_server_int_chnl_disable(digi_handle,DIGI_INT_ALL_CHNLS,&int_table_ptr->otn.otn_server_chnl[0]);
    (void) digi_sysotn_server_int_chnl_disable(digi_handle,DIGI_INT_ALL_CHNLS,&int_table_ptr->otn.otn_server_chnl[0]);

    (void) digi_otn_odu_int_framer_chnl_disable(digi_handle,DIGI_INT_ALL_CHNLS,&int_otn_table_ptr->framer_ho[0]);
    (void) digi_otn_odu_int_stg3b_chnl_disable(digi_handle,DIGI_INT_ALL_CHNLS,&int_otn_table_ptr->framer_stg3b[0]);
    
    /* for PRBS and RFRM POOL ID, cleanup is done at SS and block-level */    
    (void) digi_cbr_int_chnl_disable(digi_handle,DIGI_INT_ALL_CHNLS,&int_table_ptr->cbr.cbrc_chnl[0].cbrc);
    (void) digi_enet_line_int_chnl_disable(digi_handle,DIGI_INT_ALL_CHNLS,&int_table_ptr->enet_line.enet_chnl[0].enet);
    (void) digi_enet_sys_int_chnl_disable(digi_handle,DIGI_INT_ALL_CHNLS,&int_table_ptr->enet_sys.enet_chnl[0].enet);
    (void) digi_sifd_int_link_disable(digi_handle,DIGI_INT_ALL_CHNLS,&int_table_ptr->sifd.sifd_link[0]);
    PMC_FREE(&int_table_ptr);
    PMC_FREE(&int_otn_table_ptr);

    PMC_RETURN();
}

/*******************************************************************************
* FUNCTION: digi_device_int_enabled_check_internal()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Searches enabled interrupt bits at the device level.
*
*   The callback associated with the device interrupt type will be called
*   if an active interrupt is found. The callback will be
*   called a minimum of zero times if no active interrupts are found, or
*   a maximum of one time if there is an interrupt in at least one channel.
*
*   A callback must be registered for the interrupt type before this API
*   can be called.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*   
* OUTPUTS:
*   None
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_device_int_enabled_check_internal(digi_handle_t   *digi_handle)
{

    PMC_ERROR                    result = PMC_SUCCESS;
    digi_int_type_t              int_type = DIGI_INT_TYPE_DEVICE;
    BOOL                         int_found = FALSE;
    digi_device_int_t           *int_en_table_ptr;
    UINT32                       i;

    PMC_ENTRY();

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);


    
    if (PMC_SUCCESS == result)
    {
        if(!digi_int_is_cb_registered(digi_handle, int_type))
        {
            result = DIGI_ERR_INT_MUST_REG_CB_BEFORE_ENABLE;
        }
    }

    
    /* Get internal enabled interrupt table to check */
    if (PMC_SUCCESS == result)
    {
        result = digi_int_en_table_get(digi_handle,
                                       int_type,
                                       (void**) &int_en_table_ptr);

    }

    /* Check for active interrupts */

    /* enable interrupt caching, clear cache */
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, TRUE, TRUE);

    /* S16 Line */
    for (i = 0; (result == PMC_SUCCESS) && (FALSE == int_found) && (i < DIGI_SERDES_XFI_LANES_MAX) && FALSE == int_found; i++)
    {
        result = s16_int_chnl_enabled_check(digi_handle->s16_line_handle,
                                            i,
                                            &int_en_table_ptr->s16_line[i],
                                            &int_found);
        
    }
    
    /* S16 System */
    for (i = 0; (result == PMC_SUCCESS) && (FALSE == int_found) && (i < S16_MAX_NUM_SERDES) && FALSE == int_found; i++)
    {
        result = s16_int_chnl_enabled_check(digi_handle->s16_sys_handle,
                                            i,
                                            &int_en_table_ptr->s16_sys[i],
                                            &int_found);
        
    }

    /* disable interrupt caching */
    pmc_sys_int_cache_enable_set(((pmc_handle_t*)digi_handle)->sys_handle, FALSE, FALSE);


    /* check DCSU interrupts status */
    for (i = 0; (result == PMC_SUCCESS) && (i < (UINT32)LAST_DIGI_DCSU_INST) && FALSE == int_found; i++)
    {
        result = digi_dcsu_int_enabled_check(digi_handle,
                                             (digi_dcsu_inst_t)i,
                                             &int_found);
    }

    if (PMC_SUCCESS == result && FALSE == int_found)
    {
        result = mgmt_fege_int_enabled_check(digi_handle->mgmt_fege_handle,
                                             &int_en_table_ptr->mgmt_fege,
                                             &int_found);
    }

#ifdef PMC_SW_SIMULATION
    /* Force found interrupt for simulation so that callback runs */
    int_found = TRUE;
#endif

    if ((PMC_SUCCESS == result) &&
        (TRUE == int_found))
    {
        result = digi_int_callback_run(digi_handle, DIGI_INT_ALL_CHNLS, int_type);
    }

    PMC_RETURN(result);
} /* digi_device_int_enabled_check_internal */


/*******************************************************************************
* digi_read_write_status
* ______________________________________________________________________________
*
* DESCRIPTION:
*       Perform a read/write test to get the status of the firmware.
*       write value (ex 0x5f5ff5f5) to register (SPRAM) then
*       read back that register an make sure the read value equals
*       the written value
*
* INPUTS:
*   *digi_handle    - pointer to the digi handle.
*
* RETURNS:
*   PMC_SUCCESS
*   DIGI_ERR_FW_UNAVAILABLE
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_read_write_status(digi_handle_t *digi_handle)
{
    PMC_ERROR retval       = PMC_SUCCESS;
    UINT32 diag_id         = 0;
    UINT32 app_user0_write = 0x5f5ff5f5;
    UINT32 app_user0_read  = 0;
    hostmsg_handle_t *cpup34k_handle = NULL; 

    PMC_ENTRY();
    cpup34k_handle = (hostmsg_handle_t *)(digi_handle->base.common_info->hostmsg_handle);
    PMC_ASSERT((NULL != cpup34k_handle), HOSTMSG_ERR_INVALID_PARAMETERS, 0, 0); 

    diag_id = cpup34k_field_DIAG_ID_get(NULL,(pmc_handle_t *)cpup34k_handle);
    if (diag_id != 0x12345678)
    {
        retval = DIGI_ERR_FW_UNAVAILABLE;
    }

    if (PMC_SUCCESS == retval)
    {
        cpup34k_field_APP_SCRATCH7_set(NULL,(pmc_handle_t *)cpup34k_handle,app_user0_write);
        app_user0_read = cpup34k_field_APP_SCRATCH7_get(NULL,(pmc_handle_t *)cpup34k_handle);

        if (app_user0_read != app_user0_write)
        {
            retval = DIGI_ERR_FW_UNAVAILABLE;
        }
    }

    PMC_RETURN(retval);
}

/*******************************************************************************
* digi_otn_mapping_mode_validate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to validate OTN mapping type for a given 
*   muxing combination.
*
* INPUTS:
*   *digi_handle        - pointer to DIGI handle instance.
*   *in_chnl_ctxt_ptr   - pointer to higher order channel containing the
*                         low order framer to be provisioned.
*   oduk_type           - Enum, ODUk container type. See digi_oduk_t.
*   mapping_mode        - payload mapping mode. See digi_otn_mapping_type_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_mapping_mode_validate( digi_handle_t *digi_handle,
                                                  digi_otn_odu_chnl_t *in_chnl_ctxt_ptr,
                                                  digi_oduk_t oduk_type,
                                                  digi_otn_mapping_type_t mapping_mode )
{
    PMC_ERROR result = PMC_SUCCESS;
    
    odu_struct_t *in_odu_struct_ptr;
    util_global_odukp_type_t server_type;

    PMC_ENTRY();
    
    in_odu_struct_ptr = (odu_struct_t *)in_chnl_ctxt_ptr;
    odu_chnl_t *local_ho_odu_chnl_ptr = in_odu_struct_ptr->mem_ptr;

    /* HO ODU type */
    server_type = local_ho_odu_chnl_ptr->odu_type;
    
    /* The below checking is based on Table 7-10 in G.709 */
    /* ODU2E/2F/1E/1F cannot be a HO container */
    switch (server_type)
    {
    case UTIL_GLOBAL_ODU4:
        if (mapping_mode != DIGI_OTN_MAP_GMP)           
        {
            result = DIGI_ERR_INVALID_MAPPING_MODE;
        }
        else if (oduk_type == DIGI_ODUK_ODU1E)
        {
            result = DIGI_ERR_INVALID_LO_ODUK_TYPE;
        }
        else {
            result = PMC_SUCCESS;
        }
        break;
    case UTIL_GLOBAL_ODU3E2:
        if (oduk_type == DIGI_ODUK_ODU0 ||
            oduk_type == DIGI_ODUK_ODU1 ||
            oduk_type == DIGI_ODUK_ODU2 ||
            oduk_type == DIGI_ODUK_ODU2E ||
            oduk_type == DIGI_ODUK_ODU1F ||
            oduk_type == DIGI_ODUK_ODU2F ||
            oduk_type == DIGI_ODUK_ODU3 ||
            oduk_type == DIGI_ODUK_ODUFLEX) 
        {
            if ( mapping_mode != DIGI_OTN_MAP_GMP) 
            {
                result = DIGI_ERR_INVALID_MAPPING_MODE;
            }
            else {
                result = PMC_SUCCESS;
            }                    
        }
        else {
            result = DIGI_ERR_INVALID_ARG;
        }
        break;
    case UTIL_GLOBAL_ODU3E1:
        if (oduk_type == DIGI_ODUK_ODU2E) 
        {
            if (mapping_mode != DIGI_OTN_MAP_AMP)
            {
                result = DIGI_ERR_INVALID_MAPPING_MODE;
            }
            else {
                result = PMC_SUCCESS;
            }
        }
        else {
            result = DIGI_ERR_INVALID_ARG;
        } 
        break;       
    case UTIL_GLOBAL_ODU3:
        /* LO client is ODU0, ODU2E or ODUFlex, then it must be GMP */
        if (oduk_type == DIGI_ODUK_ODU0 || 
            oduk_type == DIGI_ODUK_ODU1E || 
            oduk_type == DIGI_ODUK_ODU2E || 
            oduk_type == DIGI_ODUK_ODU1F || 
            oduk_type == DIGI_ODUK_ODU2F || 
            oduk_type == DIGI_ODUK_ODUFLEX)
        {
            if (mapping_mode != DIGI_OTN_MAP_GMP)
            {
                result = DIGI_ERR_INVALID_MAPPING_MODE;
            }
            else {
                result = PMC_SUCCESS;
            }
        }
        else if (oduk_type == DIGI_ODUK_ODU1 ||
                 oduk_type == DIGI_ODUK_ODU2)
        {
            if (mapping_mode != DIGI_OTN_MAP_AMP)
            {
                result = DIGI_ERR_INVALID_MAPPING_MODE;
            }
            else {
                result = PMC_SUCCESS;
            }
        } else {
            result = DIGI_ERR_INVALID_MAPPING_MODE;
        }
        break;  
    case UTIL_GLOBAL_ODU2:
    case UTIL_GLOBAL_ODU2E:
    case UTIL_GLOBAL_ODU2F:
    case UTIL_GLOBAL_ODU1F:   
    case UTIL_GLOBAL_ODU1E:     
        /* LO client is ODU0 or ODUFlex, then GMP */
        if (oduk_type == DIGI_ODUK_ODU0 || oduk_type == DIGI_ODUK_ODUFLEX)
        {
            if (mapping_mode != DIGI_OTN_MAP_GMP)
            {
                result = DIGI_ERR_INVALID_MAPPING_MODE;
            }
            else {
                result = PMC_SUCCESS;
            }
        }
        else {
            if (mapping_mode != DIGI_OTN_MAP_AMP)
            {
                result = DIGI_ERR_INVALID_MAPPING_MODE;
            }
            else {
                result = PMC_SUCCESS;
            }
        } 
        break;
    case UTIL_GLOBAL_ODU1: 
        if (oduk_type == DIGI_ODUK_ODU0 && mapping_mode != DIGI_OTN_MAP_AMP)
        {
            result = DIGI_ERR_INVALID_MAPPING_MODE;
        }
        else {
            result = PMC_SUCCESS;
        } 
        break;
    default:
        result = DIGI_ERR_INVALID_ARG;
        break;
    }
    
    PMC_RETURN(result);                                                       
} /* digi_otn_mapping_mode_validate */

/*******************************************************************************
* digi_is_enhanced_enet_pmon_path
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to determine if the datapath is for enhanced ENET
*   PMON or not.
*
* INPUTS:
*   *input_pc_ptr       - pointer to the input channel handle.
*   *output_pc_ptr      - pointer to the input channel handle.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   BOOL - TRUE if it is determined that these two channel handel endpoints represent
*   an enhanced ENET PMON datapath, FALSE otherwise.
*
* NOTES:
*   It is only possible to determine this if the channels have successfully
*   been mapped through the CPB. If mapping has not occurred yet, this will
*   always return FALSE.
*
*******************************************************************************/
PRIVATE BOOL digi_is_enhanced_enet_pmon_path(util_global_switch_data_t *input_pc_ptr,
                                             util_global_switch_data_t *output_pc_ptr)
{
    BOOL result = FALSE;
    util_global_switch_data_def_t *local_input_sw_ptr = (util_global_switch_data_def_t*)input_pc_ptr;
    digi_mapper_chnl_def_t* mapper_chnl = NULL;
    digi_ilkn_chnl_def_t* ilkn_chnl = NULL;

    PMC_ENTRY();

    if (input_pc_ptr == NULL) {

        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);

    } else if (output_pc_ptr == NULL) {

        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);

    } else if (local_input_sw_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_MAPOTN) {

        /* We now know the type so cast appropriately */
        mapper_chnl = (digi_mapper_chnl_def_t*)input_pc_ptr;
        if ((mapper_chnl->enet_pmon_data != NULL) &&
            (mapper_chnl->enet_pmon_data == output_pc_ptr)) {

            result = TRUE;
        }

    } else if ((local_input_sw_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ILKN1) ||
               (local_input_sw_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ILKN2)) {

        /* We now know the type so cast appropriately */
        ilkn_chnl = (digi_ilkn_chnl_def_t*)input_pc_ptr;

        if ((ilkn_chnl->enet_pmon_data != NULL) &&
            (ilkn_chnl->enet_pmon_data == output_pc_ptr)) {

            result = TRUE;
        }
    }

    PMC_RETURN(result);
} /* digi_is_enhanced_enet_pmon_path */

/*******************************************************************************
* digi_cfp_pins_allocate
* ______________________________________________________________________________
*
* DESCRIPTION:
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.

* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS, DIGI_ERR_INVALID_ARG, or values from sub-functions
*  
* NOTES:
*   None.
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_cfp_pins_allocate(digi_handle_t* digi_handle)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    UINT32 num_lanes_port1_line = 0;
    UINT32 port1_line = DIGI_SERDES_UNASSIGNED;
    UINT32 los_line = DIGI_SERDES_UNASSIGNED;

    UINT32 port1_sys = DIGI_SERDES_UNASSIGNED;
    UINT32 num_lanes_port1_sys = 0;
    UINT32 port2_sys = DIGI_SERDES_UNASSIGNED;
    UINT32 num_lanes_port2_sys = 0;
    UINT32 los1_sys = DIGI_SERDES_UNASSIGNED;
    UINT32 los2_sys = DIGI_SERDES_UNASSIGNED;

    UINT32 line_mask = 0;
    UINT32 sys_mask1 = 0;
    UINT32 sys_mask2 = 0;
    
    digi_serdes_port_def_t *line_port_def_ptr = NULL;
    digi_serdes_port_def_t *sys1_port_def_ptr = NULL;
    digi_serdes_port_def_t *sys2_port_def_ptr = NULL;
    
    UINT32 i;
    BOOL do_line_consecutive_check = FALSE;
    UINT32 first_index = 0xff;
    
    PMC_ENTRY();

    /*digi_debug_dsi_alloc_config_print(digi_handle, "CFP DSI Allocation");*/

    /* Count the lanes and make sure there's only one port */
    for(i=0;i<DIGI_SERDES_XFI_LANES_MAX;i++)
    {
        if(digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid != DIGI_SERDES_UNASSIGNED)
        {
            if(port1_line == DIGI_SERDES_UNASSIGNED)
            {
                port1_line = digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid;
                num_lanes_port1_line++;
                line_mask |= (1<<i);
                los_line = digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].los_pin;
                line_port_def_ptr = digi_port_ctxt_find(digi_handle,
                                                        port1_line,
                                                        DIGI_SERDES_LINE_INTF);
            }
            else if (port1_line == digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].port_uid)
            {
                num_lanes_port1_line++;
                line_mask |= (1<<i);
                los_line = digi_handle->var.pin_bus_ctxt.xfi_line_pin_ctxt[i].los_pin;
            }
            else
                PMC_RETURN(DIGI_ERR_INVALID_ARG);

        }
    }

    /* Count the lanes and make sure there's 1 or 2 ports */
    for(i=0;i<DIGI_SERDES_SYS_LANES_MAX;i++)
    {
        if(digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid != DIGI_SERDES_UNASSIGNED)
        {
            if(port1_sys == DIGI_SERDES_UNASSIGNED)
            {
                port1_sys = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid;
                num_lanes_port1_sys++;
                sys_mask1 |= (1<<i);
                los1_sys = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].los_pin;
                sys1_port_def_ptr = digi_port_ctxt_find(digi_handle,
                                                        port1_sys,
                                                        DIGI_SERDES_SYSTEM_INTF);
            }
            else if (port1_sys == digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid)
            {
                num_lanes_port1_sys++;
                sys_mask1 |= (1<<i);
                los1_sys = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].los_pin;
            }
            else if(port2_sys == DIGI_SERDES_UNASSIGNED)
            {
                port2_sys = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid;
                num_lanes_port2_sys++;
                sys_mask2 |= (1<<i);           
                los2_sys = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].los_pin;
                sys2_port_def_ptr = digi_port_ctxt_find(digi_handle,
                                                        port2_sys,
                                                        DIGI_SERDES_SYSTEM_INTF);

            }            
            else if (port2_sys == digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].port_uid)
            {
                num_lanes_port2_sys++;
                sys_mask2 |= (1<<i);           
                los2_sys = digi_handle->var.pin_bus_ctxt.xfi_sys_pin_ctxt[i].los_pin;
            }
            else
                PMC_RETURN(DIGI_ERR_INVALID_ARG);
        }
    }

    /* Check for a valid CFP config */
    if (num_lanes_port1_line == 10 &&
        num_lanes_port1_sys == 0 &&
        num_lanes_port2_sys == 0) {

        /* valid_config */

    } else if (num_lanes_port1_line == 4 &&
               num_lanes_port1_sys == 4 &&
               num_lanes_port2_sys == 4) {

        /* valid_config */
        do_line_consecutive_check = TRUE;

    } else if (num_lanes_port1_line == 4 &&
               num_lanes_port1_sys == 0 &&
               num_lanes_port2_sys == 0) {

        /* valid_config */
        do_line_consecutive_check = TRUE;

    } else if (num_lanes_port1_line == 4 &&
               num_lanes_port1_sys == 4 &&
               num_lanes_port2_sys == 0) {

        /* valid_config */
        do_line_consecutive_check = TRUE;

    } else if (num_lanes_port1_line == 4 &&
               num_lanes_port1_sys == 0 &&
               num_lanes_port2_sys == 4) {

        /* valid_config */
        do_line_consecutive_check = TRUE;

    } else if (num_lanes_port1_line == 0 &&
               num_lanes_port1_sys == 0 &&
               num_lanes_port2_sys == 4) {

        /* valid_config */
    } else if (num_lanes_port1_line == 0 &&
               num_lanes_port1_sys == 4 &&
               num_lanes_port2_sys == 4) {

        /* valid_config */

    } else if (num_lanes_port1_line == 0 &&
               num_lanes_port1_sys == 4 &&
               num_lanes_port2_sys == 0) {

        /* valid_config */

    } else {

        PMC_RETURN(DIGI_ERR_INVALID_ARG);
    }

    if(do_line_consecutive_check == TRUE)
    {
        for(i=0;i<DIGI_SERDES_XFI_LANES_MAX;i++)
        {
            if(line_mask & (1<<i))
            {
                if(first_index == 0xff)
                    first_index = i;
                else if ( (i - first_index) > 3)
                {
                    /* Line lanes are not consecutive */
                    PMC_RETURN(DIGI_ERR_INVALID_ARG);                   
                }
            }
        }

    }
    for(i=0;i<DIGI_SERDES_SYS_LANES_MAX;i++)
    {
        if( (sys_mask1 & (1<<i)) && i > 7)
        {
            PMC_RETURN(DIGI_ERR_INVALID_ARG);
        }
        if( (sys_mask2 & (1<<i)) && i > 7)
        {
            PMC_RETURN(DIGI_ERR_INVALID_ARG);
        }

    }

    lifd_internal_los_context_clear(digi_handle->lifd_handle);
    lifd_internal_context_clear(digi_handle->lifd_handle);

    /* Choose a valid mapping of serdes to internal lanes for data and loss. The line and system
     * ports must share the 12 internal LIFD lanes */
    for(i=0;i<DIGI_SERDES_DSI_LANES_MAX;i++)
    {
        if((line_mask & (1<<i)) != 0)
        {
            result = lifd_internal_context_set(digi_handle->lifd_handle,i,TRUE);

            if (result != PMC_SUCCESS) {

                PMC_RETURN(result);
            }

            if (line_port_def_ptr->los_pin == DIGI_SERDES_PORT_DLOS_LOS_SOURCE) {

                result = lifd_los_internal_context_set(digi_handle->lifd_handle,i,i,TRUE);
               
            } else if (line_port_def_ptr->los_pin == DIGI_SERDES_PORT_NO_LOS_SOURCE) {

                result = lifd_los_internal_context_set(digi_handle->lifd_handle,i,line_port_def_ptr->los_pin,TRUE);
            }
        }

        if(result != PMC_SUCCESS) {

            PMC_RETURN(result);
        }

        if ((i == los_line) && 
            (line_port_def_ptr->los_pin != DIGI_SERDES_PORT_DLOS_LOS_SOURCE)) {

            result = lifd_los_internal_context_set(digi_handle->lifd_handle,i,i,TRUE);
        }

        if(result != PMC_SUCCESS)
            PMC_RETURN(result);

    }

    for(i=0;i<8;i++)
    {
        if((sys_mask1 & (1<<i)) != 0)
        {
            result = lifd_internal_context_set(digi_handle->lifd_handle,i,FALSE);
            if(result != PMC_SUCCESS)
                PMC_RETURN(result);         
            if(sys1_port_def_ptr->los_pin == DIGI_SERDES_PORT_DLOS_LOS_SOURCE)
                result = lifd_los_internal_context_set(digi_handle->lifd_handle,i,i,FALSE);
        }
        if(result != PMC_SUCCESS)
            PMC_RETURN(result);
 
        if((sys_mask2 & (1<<i)) != 0)
        {
            result = lifd_internal_context_set(digi_handle->lifd_handle,i,FALSE);
            if(result != PMC_SUCCESS)
                PMC_RETURN(result);         
            if(sys2_port_def_ptr->los_pin == DIGI_SERDES_PORT_DLOS_LOS_SOURCE)
                result = lifd_los_internal_context_set(digi_handle->lifd_handle,i,i,FALSE);
        }
        if(result != PMC_SUCCESS)
            PMC_RETURN(result);


        if( (i == los1_sys && sys1_port_def_ptr->los_pin != DIGI_SERDES_PORT_DLOS_LOS_SOURCE) ||
            (i == los2_sys && sys2_port_def_ptr->los_pin != DIGI_SERDES_PORT_DLOS_LOS_SOURCE) )
            result = lifd_los_internal_context_set(digi_handle->lifd_handle,i,i,FALSE);
        if(result != PMC_SUCCESS)
            PMC_RETURN(result);
    }

    PMC_RETURN(result);
} /* digi_cfp_pins_allocate */

/*******************************************************************************
* digi_conditionaly_provision_enet_line_and_chnl_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to conditionally provision the ENET_LINE 
*   datapath if it is in use by MAPOTN either as part of a natural datapath or
*   for an enhanced ENET PMON datapath
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   mapotn_dest        - an enum specifying the MAPOTN destination.
*                        See mapotn_src_dest_t for more information.
*   enet_pmon_type     - an enum specifying the ENET PMON type that
*                        we are attempting to provision. 
*                        See digi_enet_pmon_type_t for more information.
*   post_mld_index     - the post mld index on which to provision enet line
*   mode               - the digi level mapping mode we are attempting to 
*                        realize.
*                        See digi_mapping_mode_t for more information.
*   mapotn_chnl        - the mapotn channel.
*
* OUTPUTS:
*   *chnl               - The channel that should be used by 
*                         digi_mapper_client_chnl_get to obtain the correct
*                         chnl context.
*
* RETURNS:
*   PMC_SUCCESS if the datapath was successfully provisioned or was not 
*   required.
*   Values from sub-functions.
*
* NOTES:
*   None.
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_conditionaly_provision_enet_line_and_chnl_set(digi_handle_t* digi_handle, 
                                                                     mapotn_src_dest_t mapotn_dest,
                                                                     digi_enet_pmon_type_t enet_pmon_type,
                                                                     UINT32 post_mld_index, 
                                                                     digi_mapping_mode_t mode,
                                                                     UINT32 mapotn_chnl, 
                                                                     UINT32* chnl)
{
    PMC_ERROR result = DIGI_ERR_UNKNOWN;
    enet_datapath_t e_mode = LAST_ENET_DATAPATH;

    PMC_ENTRY();

    /* call enet_line provisioning if the MAPOTN atomic uses ENET_LINE as part of the data path. */
    if ((mapotn_dest == MAPOTN_DEST_ENET) || (enet_pmon_type == DIGI_ENET_LINE_PMON)) 
    {
        digi_mapotn_enet_params_convert(mode, &e_mode);
        digi_enet_line_energy_state_set(digi_handle, post_mld_index, e_mode, PMC_ENERGY_STATE_REQUEST_RUNNING);

        result = enet_datapath_cfg(digi_handle->enet_line_handle, post_mld_index, e_mode, mapotn_chnl, FALSE, FALSE);
    }

    if (mapotn_dest == MAPOTN_DEST_ENET) 
    {
        *chnl = post_mld_index;
    } 
    else 
    {
        *chnl = mapotn_chnl;
        result = PMC_SUCCESS;
    }

    PMC_RETURN(result);
} /* digi_conditionaly_provision_enet_line_and_chnl_set */

/*******************************************************************************
* digi_mapper_all_params_convert_and_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to convert and get all the parameters required
*   to successfully provision MAPOTN
*
* INPUTS:
*   *digi_handle       - pointer to DIGI handle instance.
*   odu_data           - Enum, Additional mode context for arbitary ODU
*                        container size.  Applicable to:\n
*                                DIGI_MAP_ODUKP_PACKET_GFP\n
*   mode               - the digi level mapping mode we are attempting to 
*                        realize.
*   enet_pmon          - TRUE: if the user requested PMON.
*                        FALSE: otherwise.
*   *odu_flex_data_ptr - a pointer to the odu_flex_data_ptr.
* OUTPUTS:
*   *oduk_data_ptr     - a pointer to a util_global_odukp_type_t 
*   *group_size_ptr    - a pointer to an digi_group_size_t.
*   *map_mode_ptr      - a pointer to an enum util_global_map_adapt_func_t 
*   *demap_mode_ptr    - a pointer to an enum util_global_map_adapt_func_t 
*   *mapotn_src_ptr    - a pointer to an enum specifying the MAPOTN destination.
*                        See mapotn_src_dest_t for more information.
*   *mapotn_dest_ptr   - a pointer to an enum specifying the MAPOTN destination.
*                        See mapotn_src_dest_t for more information.
*   *oduflex_cbr_rate_ptr - A pointer where to store the calculated CBR rate 
*                           should it be necessary.
*
* RETURNS:
*   None.
*
* NOTES:
*   *odu_flex_data_ptr - May be overwritten depending on the mode.
*
*******************************************************************************/
PRIVATE void digi_mapper_all_params_convert_and_get(digi_handle_t* digi_handle, 
                                                    digi_oduk_t odu_data,
                                                    digi_mapping_mode_t mode, 
                                                    BOOL enet_pmon,
                                                    UINT32* odu_flex_data_ptr, 
                                                    util_global_odukp_type_t* oduk_data_ptr,
                                                    digi_group_size_t* group_size_ptr,
                                                    util_global_map_adapt_func_t* map_mode_ptr,
                                                    util_global_map_adapt_func_t* demap_mode_ptr,
                                                    mapotn_src_dest_t* mapotn_src_ptr,
                                                    mapotn_src_dest_t* mapotn_dest_ptr,
                                                    UINT32* oduflex_cbr_rate_ptr)
{
    PMC_ENTRY();

    digi_oduk_params_convert(odu_data, *odu_flex_data_ptr, oduk_data_ptr, group_size_ptr);
    digi_mapotn_mode_params_convert(mode, map_mode_ptr, demap_mode_ptr);
    digi_mapper_src_dest_get(digi_handle, mode, enet_pmon, mapotn_src_ptr, mapotn_dest_ptr);
    digi_mapper_odu_flex_data_get(mode, odu_flex_data_ptr, oduk_data_ptr, oduflex_cbr_rate_ptr);

    PMC_RETURN();
} /* digi_mapper_all_params_convert_and_get */

/*******************************************************************************
* digi_mapper_odu_flex_data_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function to convert and get some parameters required
*   to successfully provision MAPOTN
*
* INPUTS:
*   mode               - the digi level mapping mode we are attempting to 
*                        realize.
*                        See digi_mapping_mode_t for more information.
*
* OUTPUTS:
*   *oduk_data_ptr     - a pointer to a util_global_odukp_type_t 
*   *odu_flex_data_ptr - a pointer to the odu_flex_data_ptr.
*   *oduflex_cbr_rate_ptr - A pointer where to store the calculated CBR rate 
*                           should it be necessary.
*
* RETURNS:
*   None.
*
* NOTES:
*   *odu_flex_data_ptr - May be overwritten depending on the mode.
*
*******************************************************************************/
PUBLIC void digi_mapper_odu_flex_data_get(digi_mapping_mode_t mode, 
                                          UINT32* odu_flex_data_ptr,
                                          util_global_odukp_type_t* oduk_data_ptr,
                                          UINT32* oduflex_cbr_rate_ptr)
{
    PMC_ENTRY();

    if (mode == DIGI_MAP_ODUFLEX_5G_GDPS_BMP) {
        *odu_flex_data_ptr = 5;
        *oduflex_cbr_rate_ptr = (UINT32)(UTIL_GLOBAL_ODU_FLEX_GDPS_5G_RATE/1000);
        *oduk_data_ptr = UTIL_GLOBAL_ODUFLEX_CBR;
        
    } else if (mode == DIGI_MAP_ODUFLEX_10G_GDPS_BMP) {

        *odu_flex_data_ptr = 9;
        *oduflex_cbr_rate_ptr = (UINT32)(UTIL_GLOBAL_ODU_FLEX_GDPS_10G_RATE/1000);
        *oduk_data_ptr = UTIL_GLOBAL_ODUFLEX_CBR;

    } else if (mode == DIGI_MAP_ODUFLEX_CPRI_5_BMP) {

        *odu_flex_data_ptr = 4;
        *oduflex_cbr_rate_ptr = (UINT32)(UTIL_GLOBAL_ODU_FLEX_CPRI_5_RATE/1000);
        *oduk_data_ptr = UTIL_GLOBAL_ODUFLEX_CBR;

    } else if (mode == DIGI_MAP_ODUFLEX_CPRI_10_BMP) {

        *odu_flex_data_ptr = 8;
        *oduflex_cbr_rate_ptr = (UINT32)(UTIL_GLOBAL_ODU_FLEX_CPRI_7_RATE/1000);
        *oduk_data_ptr = UTIL_GLOBAL_ODUFLEX_CBR;

    } else if (mode == DIGI_MAP_ODUFLEX_CPRI_6_BMP) {

        *oduflex_cbr_rate_ptr =  (UINT32)(UTIL_GLOBAL_ODU_FLEX_CPRI_6_RATE/1000);
        *odu_flex_data_ptr = 5;
        *oduk_data_ptr = UTIL_GLOBAL_ODUFLEX_CBR;

    } else if (mode == DIGI_MAP_ODUFLEX_FC_800_BMP) {

        *odu_flex_data_ptr = 7;
        *oduflex_cbr_rate_ptr = (UINT32)(UTIL_GLOBAL_ODU_FLEX_FC_800_RATE/1000);
        *oduk_data_ptr = UTIL_GLOBAL_ODUFLEX_CBR;

    }

    PMC_RETURN();
} /* digi_mapper_odu_flex_data_get */

/*******************************************************************************
* digi_serdes_ctxt_init
* ___________________________________________________________________________
*
* DESCRIPTION:
*  Initializes serdes adaptation parameters context
*
* INPUTS:
*  *digi_handle   - pointer to DIGI handle instance.
*   serdes_cfg_only - When TRUE only serdes configuration is initialized
*
* OUTPUTS:
*   NONE.
*
* RETURNS:
*   NONE.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_serdes_ctxt_init(digi_handle_t *digi_handle,
                                   BOOL8          serdes_cfg_only)
{
    UINT32 i;
    UINT32 j;
    hostmsg_s16_serdes_rate_t   hostmsg_s16_serdes_rate;
    hostmsg_t8_serdes_rate_t    hostmsg_t8_serdes_rate;
    hostmsg_c8_serdes_rate_t    hostmsg_c8_serdes_rate;
    hostmsg_sfi51_serdes_rate_t hostmsg_sfi51_serdes_rate;
    DOUBLE                    s16_serdes_rate;
    BOOL8                     s16_otu_client;
    s16_port_mode_t           s16_serdes_port_mode;  
    digi_serdes_port_mode_t port_mode;
    PMC_ERROR convert_rc;
    UINT32 s16_rate_idx = 0;
    UINT32 t8_rate_idx = 0;
    UINT32 c8_rate_idx = 0;
    UINT32 sfi51_d8_rate_idx = 0;
    BOOL8 already_proc;
    UINT32 s16_line_adapt_params_num_members_max = 0;
    UINT32 s16_line_tx_swing_levels_num_members_max = 0;


    PMC_ENTRY();

    PMC_MEMSET(digi_handle->var.serdes_ctxt.serdes_cfg, 0, sizeof(digi_serdes_cfg_t));

    s16_line_adapt_params_num_members_max = sizeof(digi_handle->var.serdes_ctxt.serdes_cfg->s16_line_cfg[0].s16_line_adapt_params)/sizeof(digi_handle->var.serdes_ctxt.serdes_cfg->s16_line_cfg[0].s16_line_adapt_params[0]);
    s16_line_tx_swing_levels_num_members_max = sizeof(digi_handle->var.serdes_ctxt.serdes_cfg->s16_line_cfg[0].s16_line_tx_swing_levels)/sizeof(digi_handle->var.serdes_ctxt.serdes_cfg->s16_line_cfg[0].s16_line_tx_swing_levels[0]);

    /* initialize list of serdes rate default value*/
    for (i = 0; i < DIGI_SERDES_XFI_LANES_MAX; i++)
    {
        if (FALSE == serdes_cfg_only)
        {
            digi_handle->var.serdes_ctxt.s16_line_lanes_rate[i] = LAST_DIGI_SERDES_PORT_MODE;
        }
        digi_handle->var.serdes_ctxt.serdes_cfg->s16_line_cfg[i].polarity_inversed = LAST_UTIL_GLOBAL_DIR;
    }
    for (i = 0; i < DIGI_SERDES_MAX_S16_IN_BP; i++)
    {
        if (FALSE == serdes_cfg_only)
        {
            digi_handle->var.serdes_ctxt.s16_sys_lanes_rate[i] = LAST_DIGI_SERDES_PORT_MODE;
        }
        digi_handle->var.serdes_ctxt.serdes_cfg->s16_sys_cfg[i].polarity_inversed = LAST_UTIL_GLOBAL_DIR;
    }
    
    /* Initialize T8 configuration */
    for (i = 0; i < DIGI_SERDES_MAX_T8_E1_IN_BP_LR; i++)
    {
        if (FALSE == serdes_cfg_only)
        {
            digi_handle->var.serdes_ctxt.t8_lanes_rate[i] = LAST_DIGI_SERDES_PORT_MODE;
        }
        digi_handle->var.serdes_ctxt.serdes_cfg->t8_cfg[i].dc_coupling_enabled = FALSE;
        digi_handle->var.serdes_ctxt.serdes_cfg->t8_cfg[i].polarity_inversed = LAST_UTIL_GLOBAL_DIR;
    }
    
    /* Initialize C8 configuration */
    for (i = 0; i < DIGI_SERDES_MAX_C8_IN_BP_SR; i++)
    {
        if (FALSE == serdes_cfg_only)
        {
            digi_handle->var.serdes_ctxt.c8_lanes_rate[i] = LAST_DIGI_SERDES_PORT_MODE;
        }
        digi_handle->var.serdes_ctxt.serdes_cfg->c8_cfg[i].dc_coupling_enabled = FALSE;
        digi_handle->var.serdes_ctxt.serdes_cfg->c8_cfg[i].polarity_inversed = LAST_UTIL_GLOBAL_DIR;
    }
    
    /* initialize SFI51 D8 serdes configuration */
    for (i = 0; i < DIGI_NUM_SFI51_PORTS_MAX; i++)
    {
        if (FALSE == serdes_cfg_only)
        {
            digi_handle->var.serdes_ctxt.sfi51_lanes_rate[i] = LAST_DIGI_SERDES_PORT_MODE;
        }
    }

    /* Initialize S16 LINE and SYS configuration */
    for (port_mode = (digi_serdes_port_mode_t)((UINT32)DIGI_SERDES_PORT_MODE_ANY_LOWPWR+1); port_mode < LAST_DIGI_SERDES_PORT_MODE;
         port_mode = (digi_serdes_port_mode_t)((UINT32)port_mode + 1)) 
    {
        already_proc = FALSE;
        /* validate port mode */
        convert_rc =  digi_serdes_s16_rate_convert(port_mode, 
                                                   &hostmsg_s16_serdes_rate,
                                                   &s16_serdes_rate,
                                                   &s16_otu_client,
                                                   &s16_serdes_port_mode);

        if ((PMC_SUCCESS == convert_rc) &&
            (LAST_S16_PORT_MODE != s16_serdes_port_mode) &&
            (s16_rate_idx < s16_line_adapt_params_num_members_max) &&
            (s16_rate_idx < s16_line_tx_swing_levels_num_members_max))
        {
            /* initializes list of serdes per rate*/
            for (i = 0; i < DIGI_SERDES_XFI_LANES_MAX; i++)
            {
                digi_handle->var.serdes_ctxt.serdes_cfg->s16_line_cfg[i].s16_line_adapt_params[s16_rate_idx].port_mode = port_mode;
                digi_handle->var.serdes_ctxt.serdes_cfg->s16_line_cfg[i].s16_line_adapt_params[s16_rate_idx].valid = FALSE;
                digi_handle->var.serdes_ctxt.serdes_cfg->s16_line_cfg[i].s16_line_tx_swing_levels[s16_rate_idx].valid = FALSE;
                digi_handle->var.serdes_ctxt.serdes_cfg->s16_line_cfg[i].s16_line_tx_swing_levels[s16_rate_idx].port_mode = port_mode;
            }
            for (i = 0; i < DIGI_SERDES_MAX_S16_IN_BP; i++)
            {
                digi_handle->var.serdes_ctxt.serdes_cfg->s16_sys_cfg[i].s16_sys_adapt_params[s16_rate_idx].valid = FALSE;
                digi_handle->var.serdes_ctxt.serdes_cfg->s16_sys_cfg[i].s16_sys_adapt_params[s16_rate_idx].port_mode = port_mode;
                digi_handle->var.serdes_ctxt.serdes_cfg->s16_sys_cfg[i].s16_sys_tx_swing_levels[s16_rate_idx].valid = FALSE;
                digi_handle->var.serdes_ctxt.serdes_cfg->s16_sys_cfg[i].s16_sys_tx_swing_levels[s16_rate_idx].port_mode = port_mode;
            }
            s16_rate_idx += 1;
            already_proc = TRUE;
        }

        /* is T8 serdes rate */
        if ((FALSE == already_proc) &&
            (t8_rate_idx < (sizeof(digi_handle->var.serdes_ctxt.serdes_cfg->t8_cfg[0].t8_adapt_params)/sizeof(digi_handle->var.serdes_ctxt.serdes_cfg->t8_cfg[0].t8_adapt_params[0]))) )
        {
            convert_rc =  digi_serdes_t8_rate_convert(port_mode, 
                                                      &hostmsg_t8_serdes_rate);
            
            if (PMC_SUCCESS == convert_rc && HOSTMSG_T8_SERDES_RATE_MAX_NUM != hostmsg_t8_serdes_rate)
            {
                for (i = 0; i < DIGI_SERDES_MAX_T8_E1_IN_BP_LR; i++)
                {
                    digi_handle->var.serdes_ctxt.serdes_cfg->t8_cfg[i].t8_adapt_params[t8_rate_idx].valid = FALSE;
                    digi_handle->var.serdes_ctxt.serdes_cfg->t8_cfg[i].t8_adapt_params[t8_rate_idx].port_mode = port_mode;
                    digi_handle->var.serdes_ctxt.serdes_cfg->t8_cfg[i].t8_tx_swing_levels[t8_rate_idx].valid = FALSE;
                    digi_handle->var.serdes_ctxt.serdes_cfg->t8_cfg[i].t8_tx_swing_levels[t8_rate_idx].port_mode = port_mode;
                }
                t8_rate_idx += 1;
                already_proc = TRUE;
            }
        }
        
        /* is C8 serdes rate */
        if ( (FALSE == already_proc) &&
             (c8_rate_idx < (sizeof(digi_handle->var.serdes_ctxt.serdes_cfg->c8_cfg[0].c8_adapt_params)/sizeof(digi_handle->var.serdes_ctxt.serdes_cfg->c8_cfg[0].c8_adapt_params[0]))) )
        {
            /* validate port mode */
            convert_rc =  digi_serdes_c8_rate_convert(port_mode, 
                                                      &hostmsg_c8_serdes_rate);
            if (PMC_SUCCESS == convert_rc && HOSTMSG_C8_SERDES_RATE_MAX_NUM != hostmsg_c8_serdes_rate)
            {
                
                for (i = 0; i < DIGI_SERDES_MAX_C8_IN_BP_SR; i++)
                {
                    digi_handle->var.serdes_ctxt.serdes_cfg->c8_cfg[i].c8_adapt_params[c8_rate_idx].valid = FALSE;
                    digi_handle->var.serdes_ctxt.serdes_cfg->c8_cfg[i].c8_adapt_params[c8_rate_idx].port_mode = port_mode;
                    digi_handle->var.serdes_ctxt.serdes_cfg->c8_cfg[i].c8_tx_swing_levels[c8_rate_idx].valid = FALSE;
                    digi_handle->var.serdes_ctxt.serdes_cfg->c8_cfg[i].c8_tx_swing_levels[c8_rate_idx].port_mode = port_mode;
                }
                c8_rate_idx += 1;
                already_proc = TRUE;
            }
        }        
    
        /* is SFI51 D8 serdes rate */
        if (FALSE == already_proc)
        {              
            convert_rc = digi_serdes_sfi51_d8_rate_convert(port_mode, 
                                                           &hostmsg_sfi51_serdes_rate);
            if (PMC_SUCCESS == convert_rc)
            {            
                /* initialize SFI51 D8 serdes configuration */
                for (i = 0; i < DIGI_NUM_SFI51_PORTS_MAX; i++)
                {
                    for (j = 0; j < SFI51_D8_TX_MAX_NUM_SERDES; j++)
                    {
                        digi_handle->var.serdes_ctxt.serdes_cfg->sfi51_cfg[i].sfi51_d8_cfg[j].d8_cfg[sfi51_d8_rate_idx].d8_tx_swing_level.port_mode = port_mode;
                        digi_handle->var.serdes_ctxt.serdes_cfg->sfi51_cfg[i].sfi51_d8_cfg[j].d8_cfg[sfi51_d8_rate_idx].d8_tx_swing_level.tx_swing_level = D8_TX_2X_TX_SWING_LEVEL_DEFAULT_VALUE;
                        digi_handle->var.serdes_ctxt.serdes_cfg->sfi51_cfg[i].sfi51_d8_cfg[j].polarity_inversed = LAST_UTIL_GLOBAL_DIR;
                    }
                }      
                sfi51_d8_rate_idx += 1;
                already_proc = TRUE;  
            }
        }
    }

    /* initialize GE serdes configuration */
    for (i = 0; i < DIGI_NUM_GE_INTF; i++)
    {
        digi_handle->var.serdes_ctxt.serdes_cfg->ge_cfg[i].d8_cfg.d8_tx_swing_level.valid = FALSE;
        digi_handle->var.serdes_ctxt.serdes_cfg->ge_cfg[i].d8_cfg.d8_tx_swing_level.tx_swing_level = D8_TX_2X_TX_SWING_LEVEL_DEFAULT_VALUE;
        digi_handle->var.serdes_ctxt.serdes_cfg->ge_cfg[i].polarity_inversed = LAST_UTIL_GLOBAL_DIR;
    }

    PMC_RETURN();
}/*digi_serdes_ctxt_init*/


/*******************************************************************************
* digi_ilkn_chnl_cfg_lock_internal
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This function puts both interlaken interfaces into a configurable state
*   to allow for the application of per channel level static configuration.\n\n
*
*   It is a device hardware requirement for the user to statically configure 
*   Interlaken channel and header mappings prior to the transfer of any traffic
*   across the Interlaken interface.\n\n
*
*   To achieve this, the following API sequence must be followed:\n
*   1) call digi_ilkn_chnl_cfg_lock() to enable static channel configuration\n
*   2) call digi_ilkn_chnl_cfg() for each channel that will be used for the
*      lifetime of operation of the device instance
*   3) call digi_ilkn_chnl_cfg_unlock() to return the interfaces to an
*      operational state \n\n
*
*   During this configuration, the Interlaken backplane interface state will be
*   down, ICW (idle control words) will not be generated by the device and flow
*   control will not be operational.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*
* OUTPUTS:
*   None
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_ilkn_chnl_cfg_lock_internal(digi_handle_t *digi_handle)
{
    /*PMC_ERROR result = DIGI_ERR_UNKNOWN;*/
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    if (digi_handle == NULL) {

        PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);

    } else {
        if (DIGI_SIFD_PATH_ILKN_1 == digi_handle->var.sifd_1_major_mode)
        {
            result = sifd_ilkn_enable(digi_handle->sifd_handle,
                                      (sifd_ilkn_inst_t)digi_handle->handle_pool.ilkn_link[DIGI_SIFD_ILKN1].ilkn_inst,
                                      SIFD_ILKN_DISABLE);
        }

        if (result == PMC_SUCCESS) {
            if (DIGI_SIFD_PATH_ILKN_2 == digi_handle->var.sifd_2_major_mode)
            {
                result = sifd_ilkn_enable(digi_handle->sifd_handle,
                                          (sifd_ilkn_inst_t)digi_handle->handle_pool.ilkn_link[DIGI_SIFD_ILKN2].ilkn_inst,
                                          SIFD_ILKN_DISABLE);
            }
        }

        if (result == PMC_SUCCESS) {
            digi_handle->var.is_ilkn_enabled = FALSE;
        }
    }

    PMC_RETURN(result);
} /* digi_ilkn_chnl_cfg_lock_internal */

/*******************************************************************************
* digi_m1_pmm_ptp_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The is a helper function that sets the appropriate bits in the DIGI_M1 to\n
*   configure PMM_LITE and muxes associated to PMM and PTP DCSU
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   enable                 - TRUE : enable PMM_LITE\n
*                            TRUE : enable PMM_LITE

* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*
*******************************************************************************/
PRIVATE void digi_m1_pmm_ptp_cfg(digi_handle_t *digi_handle, BOOL8 enable)
{
    digi_m1_buffer_t digi_m1_buffer[1];

    PMC_ENTRY();
    /* keep PMM disabled when we configure it */
    digi_m1_field_PMM_ENABLE_set(NULL, digi_handle,FALSE);
    digi_m1_buffer_init(digi_m1_buffer,digi_handle);

    /* configure DIGI_M1 */    
    digi_m1_field_PMM_PKT_SIZE_set(digi_m1_buffer, digi_handle,digi_handle->var.digi_m1_ctxt.pmm_lite_pkt_size);
    digi_m1_field_PMM_DSM_TYPE_set(digi_m1_buffer, digi_handle,DIGI_M1_PMM_DSM_TYPE);
    digi_m1_field_PMM_PKT_PERIOD_set(digi_m1_buffer, digi_handle,digi_handle->var.digi_m1_ctxt.pmm_lite_pkt_period);
    digi_m1_field_PMM_DSM_DENOM_set(digi_m1_buffer, digi_handle,digi_handle->var.digi_m1_ctxt.pmm_lite_dsm_denom);

    /* PTP or something else */
    digi_m1_field_LINE_TIMING_REF_SEL_set(digi_m1_buffer,digi_handle,
                                          DIGI_M1_PMM_LITE_CLK_REF_PTP == digi_handle->var.digi_m1_ctxt.pmm_lite_ref_clk_src?0x1:0x0);
    digi_m1_field_LINE_REF_CLK_SEL_set(digi_m1_buffer,digi_handle,
                                       (UINT32) digi_handle->var.digi_m1_ctxt.pmm_lite_ref_clk_src);
    
    digi_m1_buffer_flush(digi_m1_buffer);
    
    /* enable PMM lite */
    digi_m1_field_PMM_ENABLE_set(NULL, digi_handle,enable);
    
    PMC_RETURN();
} /*digi_m1_pmm_ptp_cfg */


/*******************************************************************************
* digi_device_reset
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Reset all the subsystems and macros except the MIPS.
*   Since these are register read/write operations there are no
*   error returns for this function.
*
* INPUTS:
*   *digi_handle   - pointer to DIGI handle instance
*
* OUTPUTS:
*   None
*
* RETURNS:
*   None
*
* NOTES:
*   Firmware must be shutdown before resetting the subsystems
*
*******************************************************************************/
PRIVATE void digi_device_reset(digi_handle_t   *digi_handle)
{
    tl_ic_buffer_t buffer[1];

    PMC_ENTRY();
    /* check input */
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);


    /* put block in reset mode */
    /* Shut down each SS. Make sure software waits some time in order not to
       overload power supply. */
    digi_cpb_energy_state_reg_set(digi_handle, PMC_ENERGY_STATE_RESET);
    DIGI_SS_SHUTDOWN_WAIT(digi_handle);
    digi_mcpb_energy_state_reg_set(digi_handle, PMC_ENERGY_STATE_RESET);
    DIGI_SS_SHUTDOWN_WAIT(digi_handle);
    digi_lineotn_energy_state_reg_set(digi_handle, PMC_ENERGY_STATE_RESET);
    DIGI_SS_SHUTDOWN_WAIT(digi_handle);
    digi_lifd_energy_state_reg_set(digi_handle, PMC_ENERGY_STATE_RESET);
    DIGI_SS_SHUTDOWN_WAIT(digi_handle);
    digi_cbrc_energy_state_reg_set(digi_handle, PMC_ENERGY_STATE_RESET);
    DIGI_SS_SHUTDOWN_WAIT(digi_handle);
    digi_enet_sys_energy_state_reg_set(digi_handle, PMC_ENERGY_STATE_RESET);
    DIGI_SS_SHUTDOWN_WAIT(digi_handle);
    digi_enet_line_energy_state_reg_set(digi_handle, PMC_ENERGY_STATE_RESET);
    DIGI_SS_SHUTDOWN_WAIT(digi_handle);
    digi_mapotn_energy_state_reg_set(digi_handle, PMC_ENERGY_STATE_RESET);
    DIGI_SS_SHUTDOWN_WAIT(digi_handle);
    digi_sifd_energy_state_reg_set(digi_handle, PMC_ENERGY_STATE_RESET);
    DIGI_SS_SHUTDOWN_WAIT(digi_handle);
    digi_sysotn_energy_state_reg_set(digi_handle, PMC_ENERGY_STATE_RESET);
    DIGI_SS_SHUTDOWN_WAIT(digi_handle);
    digi_coreotn_energy_state_reg_set(digi_handle, PMC_ENERGY_STATE_RESET);
    DIGI_SS_SHUTDOWN_WAIT(digi_handle);
    digi_m1_energy_state_set(digi_handle, PMC_ENERGY_STATE_REQUEST_RESET);
    DIGI_SS_SHUTDOWN_WAIT(digi_handle);

    /* initialize buffer */
    tl_ic_buffer_init(buffer, digi_handle);

    /* put serdes and DCSU blocks */
    /* tl_ic_reg_RESET_CTRL0_write(NULL, digi_handle,  0xFFFFFFFF & (~PMC_TL_IC_REG_RESET_CTRL0_UNUSED_MASK)); */   
    tl_ic_field_PTP_DCSU_RESET_set(buffer, digi_handle, DIGI_TL_IC_RESET_VALUE);  
    tl_ic_field_ENET2_DCSU_RESET_set(buffer, digi_handle, DIGI_TL_IC_RESET_VALUE);  
    tl_ic_field_ENET1_DCSU_RESET_set(buffer, digi_handle, DIGI_TL_IC_RESET_VALUE);   
    tl_ic_field_OTN2_DCSU_RESET_set(buffer, digi_handle, DIGI_TL_IC_RESET_VALUE);   
    tl_ic_field_OTN1_DCSU_RESET_set(buffer, digi_handle, DIGI_TL_IC_RESET_VALUE);   

    /* tl_ic_reg_RESET_CTRL1_write(NULL, digi_handle,  0xFFFFFFFF & (~PMC_TL_IC_REG_RESET_CTRL1_UNUSED_MASK)); */
    tl_ic_field_S16_SYS_RESET_set(buffer, digi_handle, TL_IC_REG_RESET_CTRL1_BIT_S16_SYS_RESET_MSK >> TL_IC_REG_RESET_CTRL1_BIT_S16_SYS_RESET_OFF);
    tl_ic_field_C8_RESET_set(buffer, digi_handle, TL_IC_REG_RESET_CTRL1_BIT_C8_RESET_MSK >> TL_IC_REG_RESET_CTRL1_BIT_C8_RESET_OFF);
    tl_ic_field_C8_CSU_RESET_set(buffer, digi_handle, DIGI_TL_IC_RESET_VALUE);

    /* tl_ic_reg_RESET_CTRL2_write(NULL, digi_handle,  0xFFFFFFFF & (~PMC_TL_IC_REG_RESET_CTRL2_UNUSED_MASK)); */
    tl_ic_field_TITAN_RESET_set(buffer, digi_handle, TL_IC_REG_RESET_CTRL2_BIT_TITAN_RESET_MSK >> TL_IC_REG_RESET_CTRL2_BIT_TITAN_RESET_OFF);
    tl_ic_field_TITAN_CSU_RESET_set(buffer, digi_handle, TL_IC_REG_RESET_CTRL2_BIT_TITAN_CSU_RESET_MSK >> TL_IC_REG_RESET_CTRL2_BIT_TITAN_CSU_RESET_OFF);

    /* tl_ic_reg_RESET_CTRL3_write(NULL, digi_handle,  0xFFFFFFFF & (~PMC_TL_IC_REG_RESET_CTRL3_UNUSED_MASK) & ~(TL_IC_REG_RESET_CTRL3_BIT_C8_PCIE_CSU_RESET_MSK) & ~(TL_IC_REG_RESET_CTRL3_BIT_C8_PCIE_RESET_MSK)); */
    tl_ic_field_S16_LINE_RESET_set(buffer, digi_handle, TL_IC_REG_RESET_CTRL3_BIT_S16_LINE_RESET_MSK >> TL_IC_REG_RESET_CTRL3_BIT_S16_LINE_RESET_OFF);   
    tl_ic_field_SFI51_RX_RESET_set(buffer, digi_handle, TL_IC_REG_RESET_CTRL3_BIT_SFI51_RX_RESET_MSK >> TL_IC_REG_RESET_CTRL3_BIT_SFI51_RX_RESET_OFF);   
    tl_ic_field_SFI51_TX_RESET_set(buffer, digi_handle, TL_IC_REG_RESET_CTRL3_BIT_SFI51_TX_RESET_MSK >> TL_IC_REG_RESET_CTRL3_BIT_SFI51_TX_RESET_OFF);
    tl_ic_field_OH_SERDES_RX_RESET_set(buffer, digi_handle, TL_IC_REG_RESET_CTRL3_BIT_OH_SERDES_RX_RESET_MSK >> TL_IC_REG_RESET_CTRL3_BIT_OH_SERDES_RX_RESET_OFF);
    tl_ic_field_OH_SERDES_TX_RESET_set(buffer, digi_handle, TL_IC_REG_RESET_CTRL3_BIT_OH_SERDES_TX_RESET_MSK >> TL_IC_REG_RESET_CTRL3_BIT_OH_SERDES_TX_RESET_OFF);
    tl_ic_field_D8_CSU_RESET_set(buffer, digi_handle, TL_IC_REG_RESET_CTRL3_BIT_D8_CSU_RESET_MSK >> TL_IC_REG_RESET_CTRL3_BIT_D8_CSU_RESET_OFF);

    tl_ic_buffer_flush(buffer);

    PMC_RETURN();
} /* digi_device_reset */

/*******************************************************************************
* digi_otn_server_ho_internal_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function digi_otn_server_ho_prov and provisions either
*   SYSOTN or LINEOTN.\n\n
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *otn_server_def_ptr    - pointer to OTU framer to configure ODU HO container
*                            against
*   cfg_mode               - function operation mode:\n
*                            0: Direct Device Configuration\n
*                            1: Pending Configuration
*   payload_mode           - System Side Payload Format\n
*                            0: Unchannelized\n
*                            1: Channelized 1G25 rate tributary slots\n
*                            2: Channelized 2G5 rate tributary slots
*   is_src_sysotn_server   - TRUE if the source is the SYSOTN server,
*                            FALSE otherwise.
*   prov_ho_cfg            - TRUE : deprov HO configuration (LINEOTN, RFRM, TFRM
*                                   and RCP
*                            FALSE : preserve HO configuration (LINEOTN, RFRM, TFRM
*                                    and RCP
*   prov_dummy_schd        - TRUE : Provision dummy schedule at FO1 MPMO
*                            FALSE : do not provision dummy schedule at FO1
*                                    MPMO
*
* OUTPUTS:
*   **out_chnl_ctxt_pptr   - pointer to a pointer to a context for the HO
*                            framer channel
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_ho_internal_prov(digi_handle_t *digi_handle,
                                                   digi_otn_server_chnl_def_t* otn_server_def_ptr,
                                                   digi_otn_cfg_mode_t cfg_mode,
                                                   digi_odu_line_payload_t payload_mode,
                                                   BOOL8 is_src_sysotn_server,
                                                   digi_otn_odu_chnl_t **out_chnl_ctxt_pptr,
                                                   BOOL prov_ho_cfg,
                                                   BOOL prov_dummy_schd)
{
    PMC_ERROR result = PMC_SUCCESS;

    digi_otn_mux_stages_t mux_stage;
    util_global_odukp_type_t odu_container;
    UINT32 ho_cal_entry_ptr[DIGI_SCHD_96_ENTRY];
    UINT32 i, num_cal_entries = 0;

    UINT32 ho_chnl_id;
    odu_struct_t *ho_odu_struct_ptr = NULL;
    BOOL8 is_line_otn_src = FALSE;
    lineotn_handle_t* otn_handle = NULL;

    odu_struct_t *s3b_odu_struct_ptr = NULL;
    coreotn_odu_chnl_prov_mode_t prov_mode = LAST_COREOTN_CHNL_PROV_MODE;

    PMC_ENTRY();

    if (is_src_sysotn_server == FALSE) {

        is_line_otn_src = TRUE;
        otn_handle = digi_handle->lineotn_handle;

    } else {

        is_line_otn_src = FALSE;
        otn_handle = digi_handle->sysotn_handle;
    }

    /* generate odu_struct if operating in direct mode */
    if (cfg_mode == DIGI_OTN_DIRECT_DEVICE_CONFIG)
    {    
        digi_handle->var.otn_cfg_mode = cfg_mode;
        
        if(prov_ho_cfg)
        {
            /* obtain an odu_struct */
            ho_odu_struct_ptr = digi_ho_odu_struct_chnl_get(digi_handle, otn_server_def_ptr->dci_chnl);
            
            *out_chnl_ctxt_pptr = (digi_otn_odu_chnl_t *)ho_odu_struct_ptr;
        }
        else
        {
            ho_odu_struct_ptr = (odu_struct_t *)*out_chnl_ctxt_pptr;
        }
        
        PMC_ASSERT(otn_server_def_ptr->dci_chnl < DIGI_SERDES_XFI_LANES_MAX, DIGI_ERR_INVALID_ARG, otn_server_def_ptr->dci_chnl, 0);
        
        /* indicate that this odu_struct is an active odu_struct */
        ho_odu_struct_ptr->active = TRUE; 
        /*ho_odu_struct_ptr->shared_mem = FALSE;   */
   
    }
    else {
        PMC_RETURN(DIGI_ERR_NO_SW_CONTENT);
        /* retrieve the memory allocated for odu_struct */
        /*            ho_odu_struct_ptr = (odu_struct_t *)out_chnl_ctxt_pptr;

         *out_chnl_ctxt_pptr = (digi_otn_odu_chnl_t *)ho_odu_struct_ptr;

         indicate that this odu_struct is an active odu_struct
         ho_odu_struct_ptr->active = FALSE; */
    } 

    ho_chnl_id = otn_server_def_ptr->dci_chnl;
    odu_container = (util_global_odukp_type_t)otn_server_def_ptr->oduk_type;

    if (payload_mode == DIGI_ODU_UNCHANNELIZED)
    {
        mux_stage = DIGI_OTN_MUX_STAGES_NONE;
    }
    else {
        mux_stage = DIGI_OTN_MUX_STAGES_ONE;
    }
        
    if (cfg_mode == DIGI_OTN_DIRECT_DEVICE_CONFIG)
    {

        if(prov_ho_cfg)
        {
            result = digi_coreotn_dci_mux_xoff_cfg(digi_handle, odu_container, payload_mode);
        }

#ifdef PMC_INTERNAL_COREOTN_POWER
        /* not yet debugged */                
        digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_RUNNING,COREOTN_ODUKP);   
#endif
        if (PMC_SUCCESS == result)
        {
            result = coreotn_ho_chnl_deactivate(digi_handle->coreotn_handle,
                                                ho_chnl_id,
                                                (coreotn_mux_stage_t)mux_stage);
        }                                                
        PMC_ATOMIC_YIELD(digi_handle,0);
        if (PMC_SUCCESS == result)
        {
            result = coreotn_ho_chnl_prov(digi_handle->coreotn_handle,
                                          ho_chnl_id,
                                          (coreotn_mux_stage_t)mux_stage,
                                          odu_container,
                                          (util_global_odu_line_payload_t)payload_mode,
                                          prov_ho_cfg,
                                          prov_dummy_schd);
        }  
        PMC_ATOMIC_YIELD(digi_handle,0);
        if (PMC_SUCCESS == result)
        {          
            /* oduksw_chnl_id_ptr is not defined */
            /* If this is one stage muxing, MO channel ID becomes the input to the ODUKSW
            ** If this is two stage muxing, LO channel ID becomes the input to the ODUKSW 
            */                             
            /* HO channel is channelized and terminated thus activate the HO channel */
            result = coreotn_ho_chnl_activate(digi_handle->coreotn_handle,
                                              ho_chnl_id,
                                              (coreotn_mux_stage_t)mux_stage);
            PMC_ATOMIC_YIELD(digi_handle,0);
              

            if(prov_ho_cfg)
            {
                if (PMC_SUCCESS == result)
                {
                    result = digi_coreotn_ho_chnl_bypass_cfg(digi_handle,
                                                             odu_container,
                                                             payload_mode);     
                    PMC_ATOMIC_YIELD(digi_handle,0);              
                }
            }
                     
            /* oduksw_chnl_id_ptr is not defined */
            ho_odu_struct_ptr->switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
            ho_odu_struct_ptr->switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_COREOTN;
            /*ho_odu_struct_ptr->switch_data.oduk_data.channel = DIGI_DCI_CHANNEL_UNASSIGNED;*/
            /* we need to support an empty HO container */
            ho_odu_struct_ptr->switch_data.oduk_data.channel = ho_chnl_id;
            ho_odu_struct_ptr->switch_data.oduk_data.lineotn_src = is_line_otn_src;
            
            /* this is a channelized pay load - activate lineotn rx/tx */
            if (PMC_SUCCESS == result)
            {

                if(prov_ho_cfg)
                {
                    result = lineotn_stream_act( otn_handle,
                                                 otn_server_def_ptr->dsi_base_chnl,
                                                 (lineotn_dsi_type_t)otn_server_def_ptr->dsi_serdes_type,
                                                 LINE_OTN_TX_DIR );
                    PMC_ATOMIC_YIELD(digi_handle,0);
                    if (PMC_SUCCESS == result)
                    {
                        /* get ODU channel provisioning mode */
                        result = coreotn_odu_chnl_prov_mode_get(digi_handle->coreotn_handle, &prov_mode);
                                               
                        if (PMC_SUCCESS == result && COREOTN_ODU_CHNL_PROV_ALL != prov_mode)
                        {
                            result = lineotn_fec_act(otn_handle,
                                                     otn_server_def_ptr->dsi_base_chnl,
                                                     (lineotn_dsi_type_t)otn_server_def_ptr->dsi_serdes_type);
                        }
                        PMC_ATOMIC_YIELD(digi_handle,0);
                    }
                }
                
                if (payload_mode != DIGI_ODU_UNCHANNELIZED)    
                {                                    
                    /* in multi-lane configuration, we configure the multi-lane aligner */
                    if(PMC_SUCCESS == result && (lineotn_dsi_type_t)otn_server_def_ptr->dsi_serdes_type != LINE_OTN_DSI_TYPE_OTUK )
                    {
                        result = digi_otn_acb_ckctl_cfg(digi_handle, otn_server_def_ptr, DIGI_SERDES_PROV_ALIGNER_ONLY);                          
                    } 
                } 
                                      
            }
    
            if(prov_ho_cfg)
            {
                if (PMC_SUCCESS == result)
                {
                    result = lineotn_stream_act( otn_handle,
                                                 otn_server_def_ptr->dsi_base_chnl,
                                                 (lineotn_dsi_type_t)otn_server_def_ptr->dsi_serdes_type,
                                                 LINE_OTN_RX_DIR );
                    PMC_ATOMIC_YIELD(digi_handle,0);
        
                }
            }

            if (payload_mode == DIGI_ODU_UNCHANNELIZED)
            {                                
                /* HO channel is unchannelized, therefore, activate HO channel 
                ** after ODUKSW is activated. 
                */
                if (PMC_SUCCESS == result)
                {
                    /*  need to set the port_type for util_global_switch_data_t */
                    ho_odu_struct_ptr->switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
                    ho_odu_struct_ptr->switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_COREOTN;
                    ho_odu_struct_ptr->switch_data.oduk_data.channel = ho_chnl_id;
                    ho_odu_struct_ptr->switch_data.oduk_data.lineotn_src = is_line_otn_src;
                }
            } 
        }                                                                              
    }                                    

    /* retreive COREOTN HO calendar entries */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_db_ho_cal_entry_all_get(digi_handle->coreotn_handle,
                                                 ho_chnl_id,
                                                 ho_cal_entry_ptr,
                                                 &num_cal_entries);
    }
    
    for (i = 0; i < num_cal_entries; i++)
    {
        PMC_LOG_TRACE("ho cal entry[%u] = %u\n", i, ho_cal_entry_ptr[i]);
    }
    
    /*
    ** Figure out where the odu struct is defined!!!!!
    */
    /* (test_cal_mask[i/32] |= (1 << cal_entry[i])) */
    /* update the odu_struct with HO framer channel information */
    if (PMC_SUCCESS == result)
    {
        /* update odu_struct in local memory with ODU channel context */
        /*ho_odu_struct_ptr->chnl_id = ho_chnl_id;
          ho_odu_struct_ptr->odu_level = ODU_STRUCT_LEVEL_HO_ODU;*/
        
        /* update odu_chnl_t with ODU channel context */
        ho_odu_struct_ptr->mem_ptr->chnl_id = ho_chnl_id;
        ho_odu_struct_ptr->mem_ptr->odu_type = odu_container;
        ho_odu_struct_ptr->mem_ptr->odu_level = ODU_STRUCT_LEVEL_HO_ODU;
        ho_odu_struct_ptr->mem_ptr->mux_stage = (odu_struct_otn_mux_stages_t)DIGI_OTN_MUX_STAGES_ONE;
        ho_odu_struct_ptr->mem_ptr->payload_format = (util_global_odu_line_payload_t)payload_mode;
        
        /* get the size of ho_cal_entry_ptr */
        for (i = 0; i < num_cal_entries; i++)
        {
            /* For ODU_STRUCT_LEVEL_HO_ODU, RX and TX calendar always the same */
            ho_odu_struct_ptr->mem_ptr->calendar_entry_mask_rx[(ho_cal_entry_ptr[i])/32] = ho_odu_struct_ptr->mem_ptr->calendar_entry_mask_rx[(ho_cal_entry_ptr[i])/32] + (1 << (ho_cal_entry_ptr[i]%32));
            ho_odu_struct_ptr->mem_ptr->calendar_entry_mask_tx[(ho_cal_entry_ptr[i])/32] = ho_odu_struct_ptr->mem_ptr->calendar_entry_mask_tx[(ho_cal_entry_ptr[i])/32] + (1 << (ho_cal_entry_ptr[i]%32));             
        }
        
        for (i = 0; i < 3; i++)
        {
            PMC_LOG_TRACE("ho_odu_struct_ptr->mem_ptr->calendar_entry_mask[%u] = 0x%x\n", i, ho_odu_struct_ptr->mem_ptr->calendar_entry_mask_tx[i]);
        }
            
        if (payload_mode == DIGI_ODU_TS_1G25)
        {
            ho_odu_struct_ptr->mem_ptr->num_tribslots = num_cal_entries;
        }
        else if (payload_mode == DIGI_ODU_TS_2G5)
        {
            ho_odu_struct_ptr->mem_ptr->num_tribslots = num_cal_entries/2;                
        }
        
        if (payload_mode == DIGI_ODU_UNCHANNELIZED) 
        {
            /* initialize odu_struct for stg3B */

            /* We can safely do the cast here, because digi_s3b_odu_struct_chnl_get
               asserts on any error it may encounter. This is assuming that
               we do not need the prt this method gives back. */
            s3b_odu_struct_ptr = digi_s3b_odu_struct_chnl_get(digi_handle, ho_chnl_id);
           
            /* coreotn_stg3b_odu_level_set will assert if there are
               any problems. So, we can safely use 'void' cast here if
               we do not need any return here. */
            ( void )coreotn_stg3b_odu_level_set(digi_handle->coreotn_handle, ho_chnl_id, ODU_STRUCT_LEVEL_HO_ODU);

        } else {

            /* LO channel information */
            ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.num_sub_container_rx = 0;
            ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.num_sub_container_tx = 0;
            
            for (i = 0; i < DIGI_NUM_MAX_TS; i++)
            {
                ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_tx[i] = DIGI_DCI_CHANNEL_UNASSIGNED;
                ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.sub_chnl_ids_rx[i] = DIGI_DCI_CHANNEL_UNASSIGNED;
                ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.tx_trib_port[i] = DIGI_TRIBPORT_UNUSED;
                ho_odu_struct_ptr->mem_ptr->trib_slot_ctxt.rx_trib_port[i] = DIGI_TRIBPORT_UNUSED;
            }  
        }
        
        /* update the odu_struct pointer in the linotn channel handle */
        otn_server_def_ptr->odu_struct_ptr = ho_odu_struct_ptr;       

        /* Update the channel payload context */
        digi_handle->var.odu_chnl_payload[ho_chnl_id] = payload_mode;
    }

    /* update handle state */
    if (PMC_SUCCESS == result)
    {

        ((odu_struct_t *) *out_chnl_ctxt_pptr)->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED;
        if (s3b_odu_struct_ptr != NULL)
        {
            s3b_odu_struct_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED;
        }
    }


    PMC_RETURN(result);
} /* digi_otn_server_ho_internal_prov */

/*******************************************************************************
* digi_otn_server_ho_sysapp_internal_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function for digi_otn_server_ho_prov and provisions the
*   case where we are a SYSOTN card application.\n\n
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *otn_server_def_ptr    - pointer to OTU framer to configure ODU HO container
*                            against
*
* OUTPUTS:
*   **out_chnl_ctxt_pptr   - pointer to a pointer to a context for the HO
*                            framer channel
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_ho_sysapp_internal_prov(digi_handle_t *digi_handle,
                                                          digi_otn_server_chnl_def_t* otn_server_def_ptr,
                                                          digi_otn_odu_chnl_t **out_chnl_ctxt_pptr)
{
    PMC_ERROR result = DIGI_ERR_UNKNOWN;

    UINT32 ho_chnl_id;
    odu_struct_t *ho_odu_struct_ptr = NULL;

    PMC_ENTRY();

    ho_chnl_id = otn_server_def_ptr->dci_chnl;

    ho_odu_struct_ptr = digi_sysapp_line_odu_struct_chnl_get(digi_handle, ho_chnl_id);

    /* update the odu_struct pointer in the linotn channel handle */
    otn_server_def_ptr->odu_struct_ptr = ho_odu_struct_ptr;    

    *out_chnl_ctxt_pptr = (digi_otn_odu_chnl_t *)ho_odu_struct_ptr;
    
#ifdef PMC_INTERNAL_COREOTN_POWER
    /* put coreotn in running mode */
    /* not yet debugged */
    digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_RUNNING,COREOTN_ODUKP);   
#endif

    /* indicate that this odu_struct is an active odu_struct */
    ho_odu_struct_ptr->active = TRUE; 
    /*ho_odu_struct_ptr->shared_mem = FALSE;  */ 

    result = coreotn_sysapp_line_chnl_prov(digi_handle->coreotn_handle,
                                           ho_chnl_id);
    PMC_ATOMIC_YIELD(digi_handle,0);
    if (PMC_SUCCESS == result ) 
    {            
        result = lineotn_stream_act(digi_handle->lineotn_handle,
                                    otn_server_def_ptr->dsi_base_chnl,
                                    (lineotn_dsi_type_t)otn_server_def_ptr->dsi_serdes_type,
                                    LINE_OTN_RX_DIR );
        PMC_ATOMIC_YIELD(digi_handle,0);
    }
        
    if(PMC_SUCCESS == result )
    {
        result = lineotn_stream_act(digi_handle->lineotn_handle,
                                    otn_server_def_ptr->dsi_base_chnl,
                                    (lineotn_dsi_type_t)otn_server_def_ptr->dsi_serdes_type,
                                    LINE_OTN_TX_DIR );
        PMC_ATOMIC_YIELD(digi_handle,0);

        /* NOTE: The lineotn_fec_act is not called for SYSOTN mode as there is nothing to be done
           for this application. */
    }                              



    if(result == PMC_SUCCESS)
    {
        digi_handle->handle_pool.sysotn_line_struct[ho_chnl_id].switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED;
        ho_odu_struct_ptr->switch_data.header.data_key = UTIL_GLOBAL_SWITCH_DATA_MAGIC_ID;
        ho_odu_struct_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_PROVISIONED;
        ho_odu_struct_ptr->switch_data.oduk_data.port_type = UTIL_GLOBAL_ODUK_PORT_ILKN1;
        ho_odu_struct_ptr->switch_data.oduk_data.channel = ho_chnl_id;    
        ho_odu_struct_ptr->switch_data.oduk_data.lineotn_src = TRUE;
        ho_odu_struct_ptr->mem_ptr->odu_type  = (util_global_odukp_type_t)otn_server_def_ptr->oduk_type;
    }

    PMC_RETURN(result);
} /* digi_otn_server_ho_sysapp_internal_prov */

/*******************************************************************************
* digi_otn_server_ho_internal_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function for digi_otn_server_ho_deprov and deprovisions 
*   either SYSOTN or LINEOTN.\n\n
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   **out_chnl_ctxt_pptr   - pointer to a pointer to a context for the HO
*                            framer channel
*   *otn_server_ptr        - pointer to a OTU framer to deprov an ODU HO 
*                            container.
*   is_src_sysotn_server   - TRUE if the source is the SYSOTN server,
*                            FALSE otherwise.
*   deprov_ho_cfg          - TRUE : deprov HO configuration (LINEOTN, RFRM, TFRM
*                                   and RCP
*                            FALSE : preserve HO configuration (LINEOTN, RFRM, TFRM
*                                    and RCP
*   deprov_dummy_schd      - TRUE : deprovision dummy schedule at the MPMO
*                            FALSE : keep the dummy schedule at the MPMO
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_ho_internal_deprov(digi_handle_t *digi_handle,
                                                     digi_otn_odu_chnl_t** out_chnl_ctxt_pptr,
                                                     digi_otn_server_chnl_def_t* otn_server_ptr,
                                                     BOOL8 is_src_sysotn_server,
                                                     BOOL8 deprov_ho_cfg,
                                                     BOOL8 deprov_dummy_schd)
{
    PMC_ERROR result = PMC_SUCCESS;

    odu_struct_t *ho_odu_struct_ptr = NULL;
    odu_struct_t *s3b_odu_struct_ptr = NULL;
    UINT32 ho_chnl_id;
    digi_otn_mux_stages_t mux_stage;
    
    lineotn_handle_t* otn_handle = NULL;

    PMC_ENTRY();

    if (is_src_sysotn_server == FALSE) {

        otn_handle = digi_handle->lineotn_handle;

    } else {

        otn_handle = digi_handle->sysotn_handle;
    }

    /* retrieve ho dci channel id */
    ho_chnl_id = otn_server_ptr->dci_chnl;

    /* retrieve the odu_struct for this ho channel */
    ho_odu_struct_ptr = (odu_struct_t*)(*out_chnl_ctxt_pptr);
        
    /* PROV_STATE SHALL BE UPDATED IN THE FIRST ATOMIC SECTION */
    if(PMC_SUCCESS == result && TRUE == deprov_ho_cfg)
    {
        digi_otn_odu_ri_rcp_dst_cfg_t rcp_cfg;
        /* automatically deprov RI_RCP port 
           don't check error, the RI_RCP may not be enabled */
        digi_otn_odu_ri_rcp_extract_cfg(digi_handle,ho_odu_struct_ptr,&rcp_cfg,0,FALSE);
        digi_otn_odu_bdi_bei_biae_insert_cfg(digi_handle,ho_odu_struct_ptr,0);

        ho_odu_struct_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
        if ((UINT32)ho_odu_struct_ptr->mem_ptr->payload_format == (UINT32)DIGI_ODU_UNCHANNELIZED)
        {
            s3b_odu_struct_ptr = &(digi_handle->handle_pool.s3b_odu_struct[ho_chnl_id]);
            s3b_odu_struct_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
        }
    }

    if(deprov_ho_cfg)
    {
        /* deactivate lineotn rx/tx*/
        result = lineotn_stream_deact(otn_handle,
                                      otn_server_ptr->dsi_base_chnl,
                                      (lineotn_dsi_type_t)otn_server_ptr->dsi_serdes_type,
                                      LINE_OTN_TX_DIR );
    }

    PMC_ATOMIC_YIELD(digi_handle,0);
    /* in multi-lane configuration, we deactivate the multi-lane aligner */  
    if ((UINT32)ho_odu_struct_ptr->mem_ptr->payload_format != (UINT32)DIGI_ODU_UNCHANNELIZED)
    {  
        if (PMC_SUCCESS == result 
            && (lineotn_dsi_type_t)otn_server_ptr->dsi_serdes_type != LINE_OTN_DSI_TYPE_OTUK)
        {
            
            result = digi_otn_acb_ckctl_cfg(digi_handle, otn_server_ptr,DIGI_SERDES_DEACTIVATE);
            PMC_ATOMIC_YIELD(digi_handle,0);
            if(PMC_SUCCESS == result) 
            {            
                result = digi_otn_acb_ckctl_cfg(digi_handle, otn_server_ptr,DIGI_SERDES_DEPROV);
                PMC_ATOMIC_YIELD(digi_handle,0);
            }
        }
    }

    /*clean up maintenance signal context*/
    if(deprov_ho_cfg)
    {
        if(ho_odu_struct_ptr->switch_data.oduk_data.lineotn_src)
        {
            digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_HO_LINE, ho_chnl_id, FALSE);
            
            if(ho_odu_struct_ptr->mem_ptr->payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
            {
                digi_otn_channel_nominal_set(digi_handle, COREOTN_RX_LINE, ho_chnl_id, FALSE);
            }
        }
        else
        {
            digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_HO_SYS, ho_chnl_id, FALSE);
            
            if(ho_odu_struct_ptr->mem_ptr->payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
            {
                digi_otn_channel_nominal_set(digi_handle, COREOTN_RX_SYS, ho_chnl_id, FALSE);
            }       
        }
    }

    if(deprov_ho_cfg)
    {
        if(PMC_SUCCESS == result) {

            result = lineotn_stream_deact(otn_handle,
                                          otn_server_ptr->dsi_base_chnl,
                                          (lineotn_dsi_type_t)otn_server_ptr->dsi_serdes_type,
                                          LINE_OTN_RX_DIR );
            PMC_ATOMIC_YIELD(digi_handle,0);
        }
    }

    if (PMC_SUCCESS == result) 
    {
        /* determine payload format of the channel */
        if ((UINT32)ho_odu_struct_ptr->mem_ptr->payload_format == (UINT32)DIGI_ODU_UNCHANNELIZED) 
        {
            mux_stage = DIGI_OTN_MUX_STAGES_NONE;

        } 
        else {
            mux_stage = DIGI_OTN_MUX_STAGES_ONE;
        }
        
        result = coreotn_ho_chnl_deactivate(digi_handle->coreotn_handle,
                                            ho_chnl_id, 
                                            (coreotn_mux_stage_t)mux_stage);    
        PMC_ATOMIC_YIELD(digi_handle,0);
    } 
      
    if (PMC_SUCCESS == result) { 

        
        result = coreotn_ho_chnl_deprov(digi_handle->coreotn_handle,
                                        ho_chnl_id, 
                                        (coreotn_mux_stage_t)mux_stage,
                                        deprov_ho_cfg,
                                        deprov_dummy_schd);                
        PMC_ATOMIC_YIELD(digi_handle,0);
    }

#ifdef PMC_INTERNAL_COREOTN_POWER
    /* not yet debugged */
    digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_OPTIMAL,COREOTN_ODUKP); 
#endif
    if (PMC_SUCCESS == result) {

        /* set the reference to the odu struct to NULL in the lineotn channel handle */
        otn_server_ptr->odu_struct_ptr = NULL;
   
        /*
        ** Clear DB entries for HO 
        */ 
        result = digi_coreotn_ho_db_clear(digi_handle, ho_chnl_id);
    }        
              
    if (PMC_SUCCESS == result) {
        
        if (digi_handle->var.otn_cfg_mode == DIGI_OTN_DIRECT_DEVICE_CONFIG) {

            if(deprov_ho_cfg)
            {
                digi_chnl_ptr_initialize((util_global_switch_data_def_t*)ho_odu_struct_ptr);
                *out_chnl_ctxt_pptr = NULL;
            }

            if ((UINT32)ho_odu_struct_ptr->mem_ptr->payload_format == (UINT32)DIGI_ODU_UNCHANNELIZED)
            {
                s3b_odu_struct_ptr = &(digi_handle->handle_pool.s3b_odu_struct[ho_chnl_id]);
                
                if (s3b_odu_struct_ptr == NULL) {
                
                    PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                
                } else {
                    digi_chnl_ptr_initialize((util_global_switch_data_def_t*)s3b_odu_struct_ptr);                
                }  
            }

        } else {
                                                                                       
            PMC_RETURN(DIGI_ERR_NO_SW_CONTENT);

            /* destroy odu_struct for ho channel */
            PMC_FREE(&(ho_odu_struct_ptr->mem_ptr));
            PMC_FREE(out_chnl_ctxt_pptr);
        }
        
        /* Update the channel payload context */
        digi_handle->var.odu_chnl_payload[ho_chnl_id] = LAST_DIGI_ODU_PAYLOAD_FORMAT;
    }

    PMC_RETURN(result);
} /* digi_otn_server_ho_internal_deprov */

/*******************************************************************************
* digi_otn_server_ho_sysapp_internal_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function for digi_otn_server_ho_deprov and de-provisions the
*   case where we are a SYSOTN card application.\n\n
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   **out_chnl_ctxt_pptr   - pointer to a pointer to a context for the HO
*                            framer channel
*   *otn_server_ptr        - pointer to OTU framer to configure ODU HO container
*                            against
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_otn_server_ho_sysapp_internal_deprov(digi_handle_t *digi_handle,
                                                            digi_otn_odu_chnl_t** out_chnl_ctxt_pptr,
                                                            digi_otn_server_chnl_def_t* otn_server_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;

    UINT32 ho_chnl_id;
    odu_struct_t *ho_odu_struct_ptr = NULL;
    odu_struct_t* sysline_ctxt_ptr;
    coreotn_odu_chnl_prov_mode_t prov_mode = LAST_COREOTN_CHNL_PROV_MODE;

    PMC_ENTRY();

    ho_chnl_id = otn_server_ptr->dci_chnl;

    /* retrieve the odu_struct for this ho channel */
    ho_odu_struct_ptr = (odu_struct_t*)(*out_chnl_ctxt_pptr);

    result = coreotn_odu_chnl_prov_mode_get(digi_handle->coreotn_handle,
                                            &prov_mode);

    if (result == PMC_SUCCESS)
    {
        if (prov_mode == COREOTN_ODU_CHNL_PROV_ALL)
        {
            util_global_cpb_connect_t *oduk_connect_data_pptr = NULL;
            coreotn_oduksw_connect_data_state_get(digi_handle->coreotn_handle,
                                                  &oduk_connect_data_pptr);
            if (oduk_connect_data_pptr->chnl[UTIL_GLOBAL_ODUK_PORT_ILKN1][ho_chnl_id].mst.state == UTIL_GLOBAL_CHNL_START)
            {
                ho_odu_struct_ptr->switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
            }
        }

        digi_handle->handle_pool.sysotn_line_struct[ho_chnl_id].switch_data.header.prov_state = UTIL_GLOBAL_CHNL_PROV_STATE_CONFIG;
    }

    if (PMC_SUCCESS == result)
    {
        digi_otn_channel_nominal_set(digi_handle, COREOTN_TX_LO_LINE, ho_chnl_id, FALSE);
        digi_otn_channel_nominal_set(digi_handle, COREOTN_RX_LINE, ho_chnl_id, FALSE);

        result = lineotn_stream_deact(digi_handle->lineotn_handle,
                                      otn_server_ptr->dsi_base_chnl,
                                      (lineotn_dsi_type_t)otn_server_ptr->dsi_serdes_type,
                                      LINE_OTN_RX_DIR);
        PMC_ATOMIC_YIELD(digi_handle,0);
    }

    if (PMC_SUCCESS == result)
    {
        result = lineotn_stream_deact(digi_handle->lineotn_handle,
                                      otn_server_ptr->dsi_base_chnl,
                                      (lineotn_dsi_type_t)otn_server_ptr->dsi_serdes_type,
                                      LINE_OTN_TX_DIR );
        PMC_ATOMIC_YIELD(digi_handle,0);
    }
    
    if (PMC_SUCCESS == result)
    {
        result = coreotn_sysapp_line_chnl_deprov(digi_handle->coreotn_handle,
                                                 ho_chnl_id);
        PMC_ATOMIC_YIELD(digi_handle,0);
    }
                                                     
#ifdef PMC_INTERNAL_COREOTN_POWER
    /* not yet debugged */
    digi_coreotn_energy_state_set(digi_handle,PMC_ENERGY_STATE_REQUEST_OPTIMAL,COREOTN_ODUKP); 
#endif
    if (result == PMC_SUCCESS)
    {
        if (prov_mode != COREOTN_ODU_CHNL_PROV_ALL)
        {
            digi_chnl_ptr_initialize((util_global_switch_data_def_t*)ho_odu_struct_ptr);
        }
        else {
            util_global_cpb_connect_t *oduk_connect_data_pptr = NULL;
            coreotn_oduksw_connect_data_state_get(digi_handle->coreotn_handle,
                                                  &oduk_connect_data_pptr);
            if (oduk_connect_data_pptr->chnl[UTIL_GLOBAL_ODUK_PORT_ILKN1][ho_chnl_id].mst.state == UTIL_GLOBAL_CHNL_START)
            {
                digi_chnl_ptr_initialize((util_global_switch_data_def_t*)ho_odu_struct_ptr);
            }
        }

        *out_chnl_ctxt_pptr = NULL;


        sysline_ctxt_ptr = &(digi_handle->handle_pool.sysotn_line_struct[ho_chnl_id]);

        if (sysline_ctxt_ptr == NULL) {

            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);

        } else {

            digi_chnl_ptr_initialize((util_global_switch_data_def_t*)sysline_ctxt_ptr);

        }

        /* set the reference to the odu struct to NULL in the lineotn channel handle */
        otn_server_ptr->odu_struct_ptr = NULL;
    }


    PMC_RETURN(result);
} /* digi_otn_server_ho_sysapp_internal_deprov */

/*******************************************************************************
* digi_coreotn_dci_mux_xoff_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function for digi_otn_server_ho_internal_prov. 
*   It handles the proper configuration of the coreotn_dci_mux_xoff depending
*   on the product application, the odu container type, muxing mode and payload 
*   mode.\n\n
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   odu_container          - the type of odu container.
*   payload_mode           - the payload mode.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_coreotn_dci_mux_xoff_cfg(digi_handle_t *digi_handle,
                                                util_global_odukp_type_t odu_container,
                                                digi_odu_line_payload_t payload_mode)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    if ((digi_handle->var.prod_app != DIGI_PROD_APP_SYSOTN_CARD) &&
        (odu_container == UTIL_GLOBAL_ODU4)) {

        /* if Unchannliezed ODU4, then check max number of mux stages
        ** and route the traffic to bypass stages 
        */
        if (payload_mode == DIGI_ODU_UNCHANNELIZED)
        {
            /* call an API to configure MUX_CTRL and XOFF_CTRL */ 
            if (digi_handle->var.mux_stages != DIGI_OTN_MUX_STAGES_NONE)
            {
                /* if one or two stage muxing then bypass FMF1 */
                result = coreotn_dci_mux4_xoff_cfg(digi_handle->coreotn_handle,
                                                   COREOTN_FMF_INST_1, 
                                                   COREOTN_DCI_MUX4_LO_DCI_INTF, 
                                                   COREOTN_XOFF_SEL_ZERO);
                if (PMC_SUCCESS == result) 
                {                    
                    result = coreotn_dci_mux3_pub_cfg(digi_handle->coreotn_handle,
                                                      COREOTN_FMF_INST_1, 
                                                      COREOTN_DCI_MUX3_MUX1_CTRL);
                }
            }
            
            if (PMC_SUCCESS == result && digi_handle->var.mux_stages == DIGI_OTN_MUX_STAGES_TWO)
            {
                /* if MUX_STAGES_TWO then byapss FMF2 */
                result = coreotn_dci_mux4_xoff_cfg(digi_handle->coreotn_handle,
                                                   COREOTN_FMF_INST_2, 
                                                   COREOTN_DCI_MUX4_LO_DCI_INTF, 
                                                   COREOTN_XOFF_SEL_ZERO);

                if (result == PMC_SUCCESS) {

                    result = coreotn_dci_mux3_pub_cfg(digi_handle->coreotn_handle,
                                                      COREOTN_FMF_INST_2, 
                                                      COREOTN_DCI_MUX3_MUX1_CTRL);
                }
            }

        } else {
            /* enable stages based on the max mux stages */
            if (digi_handle->var.mux_stages == DIGI_OTN_MUX_STAGES_ONE)
            {
                /* if one or two stage muxing then enable FMF1 */
                result = coreotn_dci_mux4_xoff_cfg(digi_handle->coreotn_handle,
                                                   COREOTN_FMF_INST_1, 
                                                   COREOTN_DCI_MUX4_ODTU_MUX, 
                                                   COREOTN_XOFF_SEL_ONE);
                
                if (result == PMC_SUCCESS) {

                    result = coreotn_dci_mux3_pub_cfg(digi_handle->coreotn_handle,
                                                      COREOTN_FMF_INST_1, 
                                                      COREOTN_DCI_MUX3_ODU_RFRM_96);
                }

                /* FMF2 */                                  
                if (PMC_SUCCESS == result)
                {
                    result = coreotn_dci_mux4_xoff_cfg(digi_handle->coreotn_handle,
                                                       COREOTN_FMF_INST_2, 
                                                       COREOTN_DCI_MUX4_LO_DCI_INTF, 
                                                       COREOTN_XOFF_SEL_ZERO);      
                }                                                                                                                  
                if (result == PMC_SUCCESS) {

                    result = coreotn_dci_mux3_pub_cfg(digi_handle->coreotn_handle,
                                                      COREOTN_FMF_INST_2, 
                                                      COREOTN_DCI_MUX3_MUX1_CTRL);
                }
            }
            else if (digi_handle->var.mux_stages == DIGI_OTN_MUX_STAGES_TWO)
            {
                /* if MUX_STAGES_TWO then enable FMF1 */
                result = coreotn_dci_mux4_xoff_cfg(digi_handle->coreotn_handle,
                                                   COREOTN_FMF_INST_1, 
                                                   COREOTN_DCI_MUX4_ODTU_MUX, 
                                                   COREOTN_XOFF_SEL_ONE);
                
                if (result == PMC_SUCCESS) {

                    result = coreotn_dci_mux3_pub_cfg(digi_handle->coreotn_handle,
                                                      COREOTN_FMF_INST_1, 
                                                      COREOTN_DCI_MUX3_ODU_RFRM_96);
                }
                /* FMF2 */                                  
                if (PMC_SUCCESS == result)
                {
                    result = coreotn_dci_mux4_xoff_cfg(digi_handle->coreotn_handle,
                                                       COREOTN_FMF_INST_2, 
                                                       COREOTN_DCI_MUX4_ODTU_MUX, 
                                                       COREOTN_XOFF_SEL_ONE);      
                }

                if (result == PMC_SUCCESS) {

                    result = coreotn_dci_mux3_pub_cfg(digi_handle->coreotn_handle,
                                                      COREOTN_FMF_INST_2, 
                                                      COREOTN_DCI_MUX3_ODU_RFRM_96);
                }
            }
        } 
    }

    PMC_RETURN(result);

} /* digi_coreotn_dci_mux_xoff_cfg */

/*******************************************************************************
* digi_coreotn_ho_chnl_bypass_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a helper function for digi_otn_server_ho_internal_prov. 
*   It handles the proper configuration of the coreotn_dci_mux_xoff depending
*   on the product application, the odu container type, muxing mode and payload 
*   mode.\n\n
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   odu_container          - the type of odu container.
*   payload_mode           - the payload mode.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_coreotn_ho_chnl_bypass_cfg(digi_handle_t *digi_handle,
                                                  util_global_odukp_type_t odu_container,
                                                  digi_odu_line_payload_t payload_mode)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    if ((digi_handle->var.prod_app != DIGI_PROD_APP_SYSOTN_CARD) &&
        (odu_container == UTIL_GLOBAL_ODU4)) 
    {

        /* if Unchannliezed ODU4, then check max number of mux stages
        ** and put the channel in reset. For unchannelized ODU4, channel ID is
        ** always 0.
        */
        if (payload_mode == DIGI_ODU_UNCHANNELIZED)
        {
            /* call an API to configure MUX_CTRL and XOFF_CTRL */ 
            if (digi_handle->var.mux_stages != DIGI_OTN_MUX_STAGES_NONE)
            {
                /* if one or two stage muxing then bypass FMF1 */
                result = coreotn_mux_dmx_ho_rst_cfg(digi_handle->coreotn_handle,
                                                    COREOTN_FMF_INST_1,
                                                    0, FALSE);
            }
            
            if (PMC_SUCCESS == result && digi_handle->var.mux_stages == DIGI_OTN_MUX_STAGES_TWO)
            {
                /* if MUX_STAGES_TWO then byapss FMF2 */
                result = coreotn_mux_dmx_ho_rst_cfg(digi_handle->coreotn_handle,
                                                    COREOTN_FMF_INST_2,
                                                    0, FALSE);
            }
        } 
    }

    PMC_RETURN(result);

} /* digi_coreotn_ho_chnl_bypass_cfg */

/*******************************************************************************
* digi_serdes_is_otn_dp_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns TRUE when datapath path is between ENET(serdes line or sys) -> L
*   INEOTN/SYSOTN (serdes line or sys). It also sets OTN serdes maximum PMM.
*
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.  
*    output_port_type      - DCPB output port type
*    input_chnl_ptr        - pointer to DCPB input channel 
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   BOOL8 - TRUE when enet -> otn datapath is detected, otherwise FALSE.
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL8 digi_serdes_is_otn_dp_get(digi_handle_t                *digi_handle,
                                        UINT32                        output_port_type,
                                        util_global_cpb_port_data_t  *input_chnl_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    BOOL8 is_otn_dp = FALSE;
    UINT32 mapotn_ingress_mux_input_port;
    UINT32 mapotn_ingress_mux_input_port_chnl;
    util_global_switch_data_def_t *mapotn_input_pc_ptr;
    BOOL dummy;

    PMC_ENTRY();   

    PMC_ASSERT(NULL != digi_handle,  DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != input_chnl_ptr,  DIGI_ERR_INVALID_ARG, 0, 0);
    
    /* detect serdes -> enet -> dcpb -> mapotn -> coreotn -> lineotn -> serdes datapath*/
    if (UTIL_GLOBAL_CPB_PORT_MAPOTN == input_chnl_ptr->port_type)
    {            
        if (UTIL_GLOBAL_CPB_PORT_ENET_LINE == output_port_type ||
            UTIL_GLOBAL_CPB_PORT_ENET_SYS == output_port_type)
        {
            result = coreotn_oduksw_chnl_source_and_type_test(digi_handle->coreotn_handle,
                                                              digi_handle->handle_pool.mapper_chnl[input_chnl_ptr->channel].switch_data.oduk_data.port_type,
                                                              digi_handle->handle_pool.mapper_chnl[input_chnl_ptr->channel].switch_data.oduk_data.channel,
                                                              &mapotn_ingress_mux_input_port,
                                                              &mapotn_ingress_mux_input_port_chnl,
                                                              &dummy,
                                                              &dummy);
            if (PMC_SUCCESS == result)
            {
                mapotn_input_pc_ptr = (util_global_switch_data_def_t*) digi_oduksw_input_port_get(digi_handle, 
                                                                                                  mapotn_ingress_mux_input_port,
                                                                                                  mapotn_ingress_mux_input_port_chnl,
                                                                                                  DIGI_ILKN_CHNL_TARGET_ODUK);
                if (NULL != mapotn_input_pc_ptr)
                {
                    is_otn_dp = TRUE;
                }          
           
            }
        }
    }
    
    PMC_RETURN(is_otn_dp);
}/*digi_serdes_is_otn_dp_get*/

/*******************************************************************************
* digi_serdes_is_valid_100G_3_X_40G_card_config()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This function determines if the current configuration is valid for the
*   100G/3x40G card application.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*
* OUTPUTS:
*   None
*
* RETURNS:
*   BOOL - TRUE, if the cfp pins require reallocation. FALSE otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL digi_serdes_is_valid_100G_3_X_40G_card_config(digi_handle_t* digi_handle)
{
    BOOL is_valid = FALSE;

    PMC_ENTRY();

    /* CFP pin allocation is only required in this card mode */
    if (digi_handle->var.prod_app == DIGI_PROD_APP_100G_3_X_40G_CFP_CARD) {

        /* LINE: 100G, SYS: 0G */
        if ((digi_handle->var.line_port_bw.total_port_bw_cfgd == DIGI_PORT_BANDWIDTH_100G) &&
            (digi_handle->var.sys_port_bw.total_port_bw_cfgd == DIGI_PORT_BANDWIDTH_NONE)) { 

            is_valid = TRUE;

            /* LINE: 40G, SYS: 0G */
        } else if ((digi_handle->var.line_port_bw.total_port_bw_cfgd == DIGI_PORT_BANDWIDTH_40G) &&
                   (digi_handle->var.sys_port_bw.total_port_bw_cfgd == DIGI_PORT_BANDWIDTH_NONE)) {

            is_valid = TRUE;

            /* LINE: 40G, SYS: 40G */
        } else if ((digi_handle->var.line_port_bw.total_port_bw_cfgd == DIGI_PORT_BANDWIDTH_40G) &&
                   (digi_handle->var.sys_port_bw.total_port_bw_cfgd == DIGI_PORT_BANDWIDTH_40G)) {

            is_valid = TRUE;

            /* LINE: 40G, SYS: 80G */
        } else if ((digi_handle->var.line_port_bw.total_port_bw_cfgd == DIGI_PORT_BANDWIDTH_40G) &&
                   (digi_handle->var.sys_port_bw.total_port_bw_cfgd == DIGI_PORT_BANDWIDTH_40G + DIGI_PORT_BANDWIDTH_40G)) {

            is_valid = TRUE;

            /* LINE: 0G, SYS: 40G */
        } else if ((digi_handle->var.line_port_bw.total_port_bw_cfgd == DIGI_PORT_BANDWIDTH_NONE) &&
                   (digi_handle->var.sys_port_bw.total_port_bw_cfgd == DIGI_PORT_BANDWIDTH_40G)) {

            is_valid = TRUE;

            /* LINE: 0G, SYS: 80G */
        } else if ((digi_handle->var.line_port_bw.total_port_bw_cfgd == DIGI_PORT_BANDWIDTH_NONE) &&
                   (digi_handle->var.sys_port_bw.total_port_bw_cfgd == DIGI_PORT_BANDWIDTH_40G + DIGI_PORT_BANDWIDTH_40G)) {
            
            is_valid = TRUE;

        } else {

            /* No other combinations should be possible. Assert. */
            PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
        }
    }

    PMC_RETURN(is_valid);

} /* digi_serdes_is_valid_100G_3_X_40G_card_config */


/*******************************************************************************
* digi_software_status_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Internal status retrieval function that initializes the software status
*   structure values that do not change during runtime.  Those that do change
*   are updated as part of digi_software_status_get()
*
* INPUTS:
*   *digi_handle   - pointer to DIGI handle instance
*
* OUTPUTS:
*
* RETURNS:
*   None
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_software_status_init(digi_handle_t *digi_handle)
{
    UINT32 dev_id   = 0;
    hostmsg_handle_t *cpup34k_handle = NULL;

    PMC_ENTRY();

    /* check for legal parameters */
    PMC_ASSERT(NULL != digi_handle,DIGI_ERR_NULL_HANDLE,0,0);

    /*
     * All updates and setting of device_revision_code is done in 
     * digi_ctxt_create and should not be updated here.
     */
    digi_handle->digi_sw_status.last_reset_reason        = NOT_DETERMINED;

    /* initially set the read/write status to FALSE, this gets checked/set each
       time digi_software_status_get() is called */
    digi_handle->digi_sw_status.read_write_status &= ~(1 << 0);


    /* set the SW version (in hex) */
    /* bits 31:29 -> not used
     * bits 27:20 -> major version
     * bits 19:12 -> minor version
     * bits 11:0  -> build number
     */
    digi_handle->digi_sw_status.sw_version = DIGI_SW_VERSION;

    digi_handle->digi_sw_status.build_device_id = 0x5440;
#ifdef PM5441
    digi_handle->digi_sw_status.build_device_id = 0x5441;
#endif

    /* get the device id value from the register */
    cpup34k_handle = (hostmsg_handle_t *)(digi_handle->base.common_info->hostmsg_handle);
    PMC_ASSERT((NULL != cpup34k_handle),HOSTMSG_ERR_INVALID_PARAMETERS,0,0);
    dev_id = cpup34k_field_DEVICE_ID_get(NULL,(pmc_handle_t *)cpup34k_handle);
    digi_handle->digi_sw_status.device_id = (UINT16) dev_id;

    /* Update the information in the pmc_handle->common_info */
    digi_handle->base.common_info->sw_version = digi_handle->digi_sw_status.sw_version;
    digi_handle->base.common_info->build_device_id = digi_handle->digi_sw_status.build_device_id;
    digi_handle->base.common_info->device_id = digi_handle->digi_sw_status.device_id;

#ifdef USE_PMC_CTXT_CALLOC
    pmc_ctxt_set_sw_version(digi_handle->base.ctxt, digi_handle->digi_sw_status.sw_version);
#endif

    /*
     * In verification and simulation mode no FW is used so set the name
     * to be the NULL value. Otherwise set the value based on the board
     * revision, A or B.
     */
#if  defined(PMC_SW_SIMULATION)
    /*don't download*/
    digi_fw_filename_set(digi_handle, DIGI_FW_DOWNLOAD_NULL);
#else
    if (NULL == digi_handle->var.fw_filename) {
        /* fw_filename has not been set by digi_fw_filename_set() previously yet, so use the default name */
        if (TRUE == pmc_is_digi_rev_a_revision(&digi_handle->base))
        {
            /* Set the default filename for the REV_A case */
            digi_fw_filename_set(digi_handle, DIGI_FW_DOWNLOAD_DEFAULT_FILE_NAME);
            PMC_LOG_TRACE("REV A being set. FileName=%s\n", digi_handle->var.fw_filename);
        }
        else
        {
            /*
             * If this is not REV_A then use the REV_B FW file name
             */
            digi_fw_filename_set(digi_handle, DIGI_FW_DOWNLOAD_REVB_FILE_NAME);
            PMC_LOG_TRACE("REV B being set. FileName=%s\n", digi_handle->var.fw_filename);
        }
    }
#endif

    PMC_RETURN();
} /* digi_software_status_init() */

/*******************************************************************************
* digi_cpb_prov_and_map_state_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This function determines if the channels have been provisioned, and checks
*   to see if they are already mapped.
*   Additionally, conflict against PMON usage is checked.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *input_pc_ptr          - input mapping channel.
*   *output_pc_ptr         - output mapping channel.
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_cpb_prov_and_map_state_check(digi_handle_t *digi_handle,
                                                    util_global_switch_data_def_t *input_pc_ptr,
                                                    util_global_switch_data_def_t *output_pc_ptr)
{
    util_global_switch_data_def_t *output_pc_data_ptr = (util_global_switch_data_def_t *)output_pc_ptr;
    util_global_cpb_port_data_t *local_output_pc_ptr = &(output_pc_data_ptr->cpb_data);

    PMC_ERROR result = DIGI_ERR_UNKNOWN;

    PMC_ENTRY();

    if (TRUE != util_global_chnl_prov_status_get(input_pc_ptr->header.prov_state, UTIL_GLOBAL_DIR_RX)) {
        
        result = DIGI_ERR_CPB_CHNL_NOT_PROV;
        
    } 
    else if (TRUE != util_global_rx_or_tx_chnl_prov_status_get(output_pc_ptr->header.prov_state)) {
 
        if (local_output_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE) {

            if ((digi_handle->var.digi_enet_pmon_line_usage & (1 << local_output_pc_ptr->channel)) == 0) {

                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);

            } else {

                result = PMC_SUCCESS;
            }

        } else if (local_output_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ENET_SYS) {

            if ((digi_handle->var.digi_enet_pmon_sys_usage & (1 << local_output_pc_ptr->channel)) == 0) {

                PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);

            } else {

                result = PMC_SUCCESS;
            }

        } else {

            result = DIGI_ERR_CPB_CHNL_NOT_PROV;
        }

    } else if (local_output_pc_ptr->op_state.map_state.is_output_mapped == TRUE) {

        result = DIGI_ERR_CPB_ALREADY_MAPPED;

    } else {

        result = PMC_SUCCESS;
    }

    PMC_RETURN(result);

} /* digi_cpb_prov_and_map_state_check */

/*******************************************************************************
* digi_cpb_test_unsupported_mappings()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This function determines if the channels being mapped are allowed to be
*   mapped.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance.
*   *local_input_pc_ptr    - input cpb mapping channel.
*   *local_output_pc_ptr   - output cpb mapping channel.
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_cpb_test_unsupported_mappings(digi_handle_t *digi_handle,
                                                     util_global_cpb_port_data_t *local_input_pc_ptr,
                                                     util_global_cpb_port_data_t *local_output_pc_ptr)
{

    digi_enet_client_chnl_def_t* enet_chnl_ptr;
    UINT32 fcs_mode;
    PMC_ERROR result = DIGI_ERR_UNKNOWN;
    UINT32 itr;

    PMC_ENTRY();

    /* if interlaken input port set hdr_en fields of cpb_chnl_prov*/ 
    if ((local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN1) || 
        (local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN2)) {

        if(local_output_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE) {

            enet_chnl_ptr = &digi_handle->handle_pool.enet_line_chnl[local_output_pc_ptr->channel];

        } else if(local_output_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ENET_SYS) {

            enet_chnl_ptr = &digi_handle->handle_pool.enet_sys_chnl[local_output_pc_ptr->channel];

        } else {

            enet_chnl_ptr = NULL;
        }

    } else if ((local_output_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN1) || 
               (local_output_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ILKN2)) {

        if (local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE) {

            enet_chnl_ptr = &digi_handle->handle_pool.enet_line_chnl[local_input_pc_ptr->channel];

        } else if (local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_ENET_SYS) {

            enet_chnl_ptr = &digi_handle->handle_pool.enet_sys_chnl[local_input_pc_ptr->channel];

        } else {

            enet_chnl_ptr = NULL;
        }

    } else { 

        enet_chnl_ptr = NULL;
    }

    if (enet_chnl_ptr != NULL) {

        if (digi_enet_channel_is_GSUP43_7_3_TRANSPARENT_mode(enet_chnl_ptr) == TRUE) {

            result = DIGI_ERR_MAPPING_NOT_SUPPORTED;

        } else {

            result = PMC_SUCCESS;
        }
    } 
    /* for DIGI_MAP_(ODU*)_ENET, verify that ENET SS is the endpoint of the datapath */
    else if ((local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_MAPOTN) &&
             (DIGI_MAP_ODU4P_100_GE_GFP_ENET == digi_handle->handle_pool.mapper_chnl[local_input_pc_ptr->channel].mode ||
              DIGI_MAP_ODU3P_40_GE_GFP_ENET == digi_handle->handle_pool.mapper_chnl[local_input_pc_ptr->channel].mode ||
              DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP_ENET == digi_handle->handle_pool.mapper_chnl[local_input_pc_ptr->channel].mode ||
              DIGI_MAP_ODU2P_10_GE_6_2_GFP_ENET == digi_handle->handle_pool.mapper_chnl[local_input_pc_ptr->channel].mode) &&
             (UTIL_GLOBAL_CPB_PORT_ENET_LINE != local_output_pc_ptr->port_type &&
              UTIL_GLOBAL_CPB_PORT_ENET_SYS != local_output_pc_ptr->port_type))
    {
        result = DIGI_ERR_MAPPING_NOT_SUPPORTED; 
    }
    else {
        
        result = PMC_SUCCESS;
    }

    /* Check that MAPPER is not mapped to 10GE GSUP73 ENET  */
    if (PMC_SUCCESS == result)
    {
        if ((local_input_pc_ptr->port_type == UTIL_GLOBAL_CPB_PORT_MAPOTN) &&
            ((UTIL_GLOBAL_CPB_PORT_ENET_LINE == local_output_pc_ptr->port_type ||
              UTIL_GLOBAL_CPB_PORT_ENET_SYS == local_output_pc_ptr->port_type)) &&
            ((DIGI_MAP_ODU2P_PKT_10_GE_7_3_GFP == digi_handle->handle_pool.mapper_chnl[local_input_pc_ptr->channel].mode) ||
             (DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP == digi_handle->handle_pool.mapper_chnl[local_input_pc_ptr->channel].mode) ||
             (DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP_ENET == digi_handle->handle_pool.mapper_chnl[local_input_pc_ptr->channel].mode)))
        {            
            for (itr = 0; itr < DIGI_MAPOTN_CHNL_MAX; itr++)
            {
                if ((void *)local_input_pc_ptr == (void *)&digi_handle->handle_pool.mapper_chnl[itr].switch_data.cpb_data)
                {
                    result = digi_mapper_gfp_rx_fcs_mode_internal_get(digi_handle, 
                                                                      (digi_mapper_chnl_t*)&digi_handle->handle_pool.mapper_chnl[itr], 
                                                                      &fcs_mode);
                    if (PMC_SUCCESS ==  result && 
                        (MAPOTN_RX_FCS_CHK_MODE_SKIP_N_PREAMBLE == fcs_mode || 
                         MAPOTN_RX_FCS_CHK_MODE_NO_PREAMBLE_SKIP == fcs_mode))
                    {
                        result = DIGI_ERR_RGFP_EFCS_TO_COPI_ILLEGAL; 
                    }
                    break;
                }
            }
        }
    }
    PMC_RETURN(result);

} /* digi_cpb_test_unsupported_mappings */

/*******************************************************************************
* digi_oduksw_test_rate_compatibility()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function determines if the source and destination are compatible with 
*   requested rate 
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *input_pc_ptr   - util_global_switch_data_t pointer defining inbound port
*   *output_pc_ptr  - util_global_switch_data_t pointer defining outbound port
*   rate_data       - enum, client stream types of signal passing through ODUKSW.
*                     For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, client_num_odu0 must
*                     be provided
*   client_num_odu0 - For DIGI_ODUKSW_STREAM_PKT_GFPF_ODUFLEX, number of ODU0 container
*                     associated with ODUFLEX signal.
*   client_bitrate  - For DIGI_ODUKSW_STREAM_CBR_ODUFLEX, this argument specifies
*                     client bitrate in bps. Set to 0 for all other ODU rates.    
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_oduksw_test_rate_compatibility(digi_handle_t *digi_handle,
                                                      util_global_switch_data_t *input_pc_ptr,
                                                      util_global_switch_data_t *output_pc_ptr,
                                                      digi_oduksw_stream_t rate_data,
                                                      UINT32 client_num_odu0,
                                                      DOUBLE client_bitrate)
{
    PMC_ERROR rc = PMC_SUCCESS;
    
    util_global_odukp_type_t requested_odu_type, input_odu_type, output_odu_type;
    util_global_switch_data_def_t *switch_data_def_ptr;
    UINT32 input_num_slot, output_num_slot, requested_num_slot;

    PMC_ENTRY();
    
    rc = digi_oduksw_rate_get(rate_data,&requested_odu_type);

    if (PMC_SUCCESS == rc) 
    {
        switch_data_def_ptr = (util_global_switch_data_def_t *) input_pc_ptr;
        rc = digi_oduksw_switch_data_rate_get(digi_handle,switch_data_def_ptr,&input_odu_type,&input_num_slot);

    }
    if (PMC_SUCCESS == rc) 
    {
        switch_data_def_ptr = (util_global_switch_data_def_t *) output_pc_ptr;
        rc = digi_oduksw_switch_data_rate_get(digi_handle,switch_data_def_ptr,&output_odu_type,&output_num_slot);
    }

    if (PMC_SUCCESS == rc)
    {
        if (input_odu_type == UTIL_GLOBAL_ODUK_DONT_CARE || output_odu_type == UTIL_GLOBAL_ODUK_DONT_CARE ||
            input_odu_type == UTIL_GLOBAL_ODUFLEX_CBR    || output_odu_type == UTIL_GLOBAL_ODUFLEX_CBR   ||
            input_odu_type == UTIL_GLOBAL_ODUFLEX_GFP    || output_odu_type == UTIL_GLOBAL_ODUFLEX_GFP   ||
            requested_odu_type == UTIL_GLOBAL_ODUK_DONT_CARE || 
            requested_odu_type == UTIL_GLOBAL_ODUFLEX_CBR    || 
            requested_odu_type == UTIL_GLOBAL_ODUFLEX_GFP   )
        {
            if (requested_odu_type == UTIL_GLOBAL_ODUK_DONT_CARE || 
                requested_odu_type == UTIL_GLOBAL_ODUFLEX_CBR || 
                requested_odu_type == UTIL_GLOBAL_ODUFLEX_GFP )
            {
                requested_num_slot = client_num_odu0;
            } else 
            {
                rc  = util_global_max_server_num_ts_get(UTIL_GLOBAL_MUX_DEMUX, requested_odu_type, UTIL_GLOBAL_ODU_UNCHANNELIZED, &requested_num_slot);
                if (requested_num_slot == 31)
                {
                    requested_num_slot += 1;
                }
            }
            if (PMC_SUCCESS == rc)
            {
                if  ( ( (input_num_slot > output_num_slot)  && (requested_num_slot  < output_num_slot)) ||
                      (  (input_num_slot <= output_num_slot) && (requested_num_slot  < input_num_slot)))
                {
                    rc = DIGI_ERR_ODUKSW_INCOMPATIBLE_RATE;
                }                        
            }
        } else 
        {
            if  ( input_odu_type != output_odu_type ||
                  requested_odu_type != output_odu_type)
            {
                rc = DIGI_ERR_ODUKSW_INCOMPATIBLE_RATE;
            }
        }            
    }
        
    PMC_RETURN(rc);
} /* digi_oduksw_test_rate_compatibility */

/*******************************************************************************
* digi_oduksw_switch_data_rate_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function determines the rate provisionned for a port
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *switch_data_ptr    - util_global_switch_data_t pointer defining a port
*
* OUTPUTS:
*   *odu_type        - ODU type associated to the port
*   *num_slot        - number of slot associated to the port
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_oduksw_switch_data_rate_get(digi_handle_t *digi_handle,
                                                   util_global_switch_data_def_t *switch_data_ptr,
                                                   util_global_odukp_type_t *odu_type, 
                                                   UINT32 *num_slot)
{
    PMC_ERROR rc = PMC_SUCCESS;
    digi_group_size_t group_size;
    digi_mapper_chnl_def_t* mapper_chnl_def_ptr;
    digi_ilkn_chnl_def_t *ilkn_chnl_def_ptr;
    odu_struct_t *odu_struct_ptr;
    PMC_ENTRY();

    switch(switch_data_ptr->oduk_data.port_type)
    {
    case UTIL_GLOBAL_ODUK_PORT_ILKN1:
        if (DIGI_PROD_APP_IS_SYSOTN_CARD(digi_handle) == TRUE) 
        { 
            odu_struct_ptr = (odu_struct_t *) switch_data_ptr;
            *odu_type = odu_struct_ptr->mem_ptr->odu_type;
            if (*odu_type == UTIL_GLOBAL_ODUFLEX_CBR ||
                *odu_type == UTIL_GLOBAL_ODUFLEX_GFP) 
            {
                *num_slot = odu_struct_ptr->mem_ptr->num_tribslots;
            } else 
            {
                rc  = util_global_max_server_num_ts_get(UTIL_GLOBAL_MUX_DEMUX, *odu_type, UTIL_GLOBAL_ODU_UNCHANNELIZED, num_slot);
            }
            break;
        }
        else
        {
            ilkn_chnl_def_ptr = (digi_ilkn_chnl_def_t *) switch_data_ptr;
            *num_slot = (UINT32) ilkn_chnl_def_ptr->rate;
            *odu_type = UTIL_GLOBAL_ODUK_DONT_CARE;
        }
    case UTIL_GLOBAL_ODUK_PORT_ILKN2:            
        ilkn_chnl_def_ptr = (digi_ilkn_chnl_def_t *) switch_data_ptr;
        *num_slot = (UINT32) ilkn_chnl_def_ptr->rate;
        *odu_type = UTIL_GLOBAL_ODUK_DONT_CARE;
        break;
    case UTIL_GLOBAL_ODUK_PORT_MAPOTN:
        mapper_chnl_def_ptr = (digi_mapper_chnl_def_t*) switch_data_ptr;
        digi_oduk_params_convert(mapper_chnl_def_ptr->odu_data,
                                 mapper_chnl_def_ptr->odu_flex_data,
                                 odu_type,
                                 &group_size);
        if (*odu_type == UTIL_GLOBAL_ODUFLEX_CBR ||
            *odu_type == UTIL_GLOBAL_ODUFLEX_GFP) 
        {
            *num_slot = mapper_chnl_def_ptr->odu_flex_data;
        } else 
        {
            rc  = util_global_max_server_num_ts_get(UTIL_GLOBAL_MUX_DEMUX, *odu_type, UTIL_GLOBAL_ODU_UNCHANNELIZED, num_slot);
        }
        break;
    case UTIL_GLOBAL_ODUK_PORT_COREOTN:
        odu_struct_ptr = (odu_struct_t *) switch_data_ptr;
        *odu_type = odu_struct_ptr->mem_ptr->odu_type;        
        if (*odu_type == UTIL_GLOBAL_ODUFLEX_CBR ||
            *odu_type == UTIL_GLOBAL_ODUFLEX_GFP) 
        {
            *num_slot = odu_struct_ptr->mem_ptr->num_tribslots;
        } else 
        {
            rc  = util_global_max_server_num_ts_get(UTIL_GLOBAL_MUX_DEMUX, *odu_type, UTIL_GLOBAL_ODU_UNCHANNELIZED, num_slot);
        }
        
        break;
    default:
        rc = DIGI_ERR_INVALID_ARG;
    }
    
    PMC_RETURN(rc);
} /*digi_oduksw_switch_data_rate_get */

/*******************************************************************************
* digi_cbr_mapotn_mapping_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function checks that a given CBR mode works with a mapping mode
*   requested rate 
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   cbr_client_mode  - CBR major processing modes
*   mapping_mode     - Enum, OPU payload mapping modes.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   BOOL8 - TRUE if CBR mode works with mapping mode, otherwise FALSE
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL8 digi_cbr_mapotn_mapping_check(digi_handle_t *digi_handle,
                                            digi_cbr_client_mode_t cbr_client_mode,
                                            digi_mapping_mode_t mapping_mode)
{
    BOOL8 result = FALSE;

    PMC_ENTRY();
    
    switch(cbr_client_mode)
    {
    case DIGI_CBR_CLIENT_40G_STS768:
    case DIGI_CBR_CLIENT_40G_STM256:
    {
        result = (mapping_mode == DIGI_MAP_ODU3P_OC_768_CBR_BMP || 
                  mapping_mode == DIGI_MAP_ODU3P_OC_768_CBR_AMP);
        break;
    }
    case DIGI_CBR_CLIENT_10G_STS192:
    case DIGI_CBR_CLIENT_10G_STM64:
    case DIGI_CBR_CLIENT_10G_STS192_PRBS:
    case DIGI_CBR_CLIENT_10G_STM64_PRBS:        
        result = (mapping_mode == DIGI_MAP_ODU2P_OC_192_CBR_BMP ||
                  mapping_mode == DIGI_MAP_ODU2P_OC_192_CBR_AMP);
        break;
    case DIGI_CBR_CLIENT_10G_FC1200_ODU1F:
        result = (DIGI_MAP_ODU1FP_FC_1200_BMP  == mapping_mode);
        break;
    case DIGI_CBR_CLIENT_10G_FC1200_ODU2F:
        result = (DIGI_MAP_ODU2FP_FC_1200_BMP  == mapping_mode);
        break;

    case DIGI_CBR_CLIENT_10G_FC1200_GFP_ODU2E:
        result = (DIGI_MAP_ODU2EP_FC_1200_GFP  == mapping_mode);
        break;
    case DIGI_CBR_CLIENT_10G_FC800:
        result = (DIGI_MAP_ODUFLEX_FC_800_BMP  == mapping_mode ||
                  DIGI_MAP_ODU2P_FC_800_GMP == mapping_mode);
        break;
    case DIGI_CBR_CLIENT_10G_CPRI_5G:
        result = (DIGI_MAP_ODUFLEX_CPRI_5_BMP == mapping_mode ||
                  DIGI_MAP_ODU2P_CPRI_5_GMP == mapping_mode);
        break;
    case DIGI_CBR_CLIENT_10G_CPRI_6G:
        result = (DIGI_MAP_ODUFLEX_CPRI_6_BMP == mapping_mode ||
                  DIGI_MAP_ODU2P_CPRI_6_GMP == mapping_mode);
        break;
    case DIGI_CBR_CLIENT_10G_CPRI_10G:
        result = (DIGI_MAP_ODUFLEX_CPRI_10_BMP == mapping_mode ||
                  DIGI_MAP_ODU2P_CPRI_10_GMP == mapping_mode);
        break;
    case DIGI_CBR_CLIENT_10G_GDPS_5G:
        result = (DIGI_MAP_ODUFLEX_5G_GDPS_BMP == mapping_mode ||
                  DIGI_MAP_ODU2P_5G_GDPS_GMP == mapping_mode);
        break;
    case DIGI_CBR_CLIENT_10G_GDPS_10G:
        result = (DIGI_MAP_ODUFLEX_10G_GDPS_BMP == mapping_mode ||
                  DIGI_MAP_ODU2EP_10G_GDPS_GMP == mapping_mode);
        break;        
    default:
        break;
    }
    PMC_RETURN(result);
} /* digi_cbr_mapotn_mapping_check */

/*******************************************************************************
* digi_enet_mapping_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function checks that 2 ENET modes are compatible
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   in_enet_mode     - ENET major processing modes
*   out_enet_mode     - ENET major processing modes
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   BOOL8 - TRUE if ENET modes are compatible, otherwise FALSE
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL8 digi_enet_mapping_check(digi_handle_t *digi_handle,
                                      digi_enet_mode_t in_enet_mode,
                                      digi_enet_mode_t out_enet_mode)
{
    BOOL8 result = FALSE;

    PMC_ENTRY();
    
    switch(in_enet_mode)        
    {
    case DIGI_ENET_SERDES_100GE_TRANSPARENT:
    case DIGI_ENET_SERDES_100GE_TRANSPARENT_RX_PMON:
        result = (DIGI_ENET_SERDES_100GE_TRANSPARENT == out_enet_mode ||
                  DIGI_ENET_SERDES_100GE_TRANSPARENT_RX_PMON == out_enet_mode );
        break;
    case DIGI_ENET_SERDES_40GE_TRANSPARENT:
    case DIGI_ENET_SERDES_40GE_TRANSPARENT_RX_PMON:
        result = (DIGI_ENET_SERDES_40GE_TRANSPARENT == out_enet_mode ||
                  DIGI_ENET_SERDES_40GE_TRANSPARENT_RX_PMON == out_enet_mode );
        break;
    case DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT:
    case DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT_RX_PMON:
        result = (DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT == out_enet_mode ||
                  DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT_RX_PMON == out_enet_mode );
        break;
    case DIGI_ENET_SERDES_10GE_TRANSPARENT:
    case DIGI_ENET_SERDES_10GE_TRANSPARENT_RX_PMON:
        result = (DIGI_ENET_SERDES_10GE_TRANSPARENT == out_enet_mode ||
                  DIGI_ENET_SERDES_10GE_TRANSPARENT_RX_PMON == out_enet_mode );
        break;
    default:
        if (in_enet_mode == out_enet_mode)
        {
            result = TRUE;
        }
        break;
    }
    PMC_RETURN(result);
} /* digi_enet_mapping_check */

/*******************************************************************************
* digi_cbr_mapping_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function checks that 2 CBR modes are compatible
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   in_cbr_client_mode   - CBR major processing modes
*   out_cbr_client_mode  - CBR major processing modes
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   BOOL8 - TRUE if CBR modes are compatible, otherwise FALSE
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL8 digi_cbr_mapping_check(digi_handle_t *digi_handle,
                                     digi_cbr_client_mode_t in_cbr_client_mode,
                                     digi_cbr_client_mode_t out_cbr_client_mode)
{
    BOOL8 result = FALSE;

    PMC_ENTRY();
    
    switch(in_cbr_client_mode)
    {
    case DIGI_CBR_CLIENT_40G_STS768:
    case DIGI_CBR_CLIENT_40G_STM256:
        result = (DIGI_CBR_CLIENT_40G_STS768 == out_cbr_client_mode ||
                  DIGI_CBR_CLIENT_40G_STM256 == out_cbr_client_mode );
        break;
    case DIGI_CBR_CLIENT_10G_STS192:
    case DIGI_CBR_CLIENT_10G_STM64:
    case DIGI_CBR_CLIENT_10G_STS192_PRBS:
    case DIGI_CBR_CLIENT_10G_STM64_PRBS:
        result = ( DIGI_CBR_CLIENT_10G_STS192 == out_cbr_client_mode ||
                   DIGI_CBR_CLIENT_10G_STM64  == out_cbr_client_mode ||
                   DIGI_CBR_CLIENT_10G_STS192_PRBS == out_cbr_client_mode ||
                   DIGI_CBR_CLIENT_10G_STM64_PRBS == out_cbr_client_mode);
        break;
    default:
        if (in_cbr_client_mode == out_cbr_client_mode)
        {
            result = TRUE;
        }
        break;
    }
    PMC_RETURN(result);
} /* digi_cbr_mapping_check */

/*******************************************************************************
* digi_mapotn_enet_etrans_mode_convert()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function return TRUE when the input description is connected from 
*   ENETLINE on DCPB and the ETRANS path is used. It is also providing the 
*   equivalent enet configuration  mode.
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *input_pc_ptr    - util_global_switch_data_t pointer defining inbound port
*   
*
* OUTPUTS:
*   *out_enet_mode       - ENET major processing modes
*
* RETURNS:
*   BOOL8 - TRUE when it is an MAPPER segment connected from ETRANS.
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL8 digi_mapotn_enet_etrans_mode_convert(digi_handle_t *digi_handle,
                                                   util_global_switch_data_t *input_pc_ptr,
                                                   digi_enet_mode_t *out_enet_mode)
{
    BOOL8 result = FALSE;
    util_global_switch_data_def_t *input_switch_data_def_ptr;  
    UINT32 mapotn_channel;

    PMC_ENTRY();
    *out_enet_mode = LAST_DIGI_ENET;
    input_switch_data_def_ptr = (util_global_switch_data_def_t *)input_pc_ptr;

    if (input_switch_data_def_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE)
    {
        if ( enet_is_link_mapotn_test(digi_handle->enet_line_handle, input_switch_data_def_ptr->cpb_data.channel, &mapotn_channel) == TRUE)
        {
            digi_mapper_chnl_def_t *in_mapper_chnl_def_ptr = (digi_mapper_chnl_def_t *) input_pc_ptr;
            switch(in_mapper_chnl_def_ptr->mode)        
            {
            case DIGI_MAP_ODU4P_100_GE_GFP_ENET:
            case DIGI_MAP_ODU4P_100_GE_GFP:
            case DIGI_MAP_ODU4P_PKT_100_GE_GMP:
                *out_enet_mode = DIGI_ENET_SERDES_100GE_MAC;
                break;
            case DIGI_MAP_ODU3P_40_GE_GFP:
            case DIGI_MAP_ODU3P_40_GE_GFP_ENET:
            case DIGI_MAP_ODU3P_PKT_40_GE_GMP:
                *out_enet_mode = DIGI_ENET_SERDES_40GE_MAC;
                break;                        
            case DIGI_MAP_ODU2P_PKT_10_GE_7_3_GFP:
            case DIGI_MAP_ODU2P_10_GE_6_2_GFP:
            case DIGI_MAP_ODU2P_10_GE_6_2_GFP_ENET:
            case DIGI_MAP_ODU1EP_PKT_10G3_7_2_BMP:
            case DIGI_MAP_ODU2EP_PKT_10G3_7_1_BMP:
                *out_enet_mode = DIGI_ENET_SERDES_10GE_MAC;
                break;
            default:
                break;
            }
            result = TRUE;
        }
    }
    
    PMC_RETURN(result);
} /* digi_mapotn_enet_etrans_mode_convert */

/*******************************************************************************
* digi_enet_mapotn_mapping_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function checks that a given ENET mode works with a mapping mode
*   requested rate 
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   enet_mode        - ENET major processing modes
*   mapping_mode     - Enum, OPU payload mapping modes.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   BOOL8 - TRUE if ENET mode works with mapping mode, otherwise FALSE
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL8 digi_enet_mapotn_mapping_check(digi_handle_t *digi_handle,
                                             digi_enet_mode_t enet_mode,
                                             digi_mapping_mode_t mapping_mode)
{
    BOOL8 result = FALSE;

    PMC_ENTRY();
    
    switch(enet_mode)        
    {
    case DIGI_ENET_SERDES_100GE_MAC:
        result = (DIGI_MAP_ODUKP_PACKET_GFP == mapping_mode ||
                  DIGI_MAP_ODU4P_100_GE_GFP_ENET == mapping_mode ||
                  DIGI_MAP_ODU4P_100_GE_GFP == mapping_mode ||
                  DIGI_MAP_ODU4P_PKT_100_GE_GMP == mapping_mode);
        break;
    case DIGI_ENET_SERDES_100GE_TRANSPARENT:
    case DIGI_ENET_SERDES_100GE_TRANSPARENT_RX_PMON:
        result = (DIGI_MAP_ODU4P_CBR_100_GE_GMP== mapping_mode);
        break;
    case DIGI_ENET_SERDES_40GE_MAC:
        result = (DIGI_MAP_ODUKP_PACKET_GFP == mapping_mode ||
                  DIGI_MAP_ODU3P_40_GE_GFP == mapping_mode ||
                  DIGI_MAP_ODU3P_40_GE_GFP_ENET == mapping_mode ||
                  DIGI_MAP_ODU3P_PKT_40_GE_GMP == mapping_mode);
        break;
    case DIGI_ENET_SERDES_40GE_TRANSPARENT:
    case DIGI_ENET_SERDES_40GE_TRANSPARENT_RX_PMON:
        result = ( DIGI_MAP_ODU3P_CBR_40_GE_GMP== mapping_mode);
        break;
    case DIGI_ENET_SERDES_10GE_MAC:
        result = (DIGI_MAP_ODUKP_PACKET_GFP == mapping_mode ||
                  DIGI_MAP_ODU2P_PKT_10_GE_7_3_GFP == mapping_mode ||
                  DIGI_MAP_ODU2P_10_GE_6_2_GFP == mapping_mode ||
                  DIGI_MAP_ODU2P_10_GE_6_2_GFP_ENET == mapping_mode ||
                  DIGI_MAP_ODU1EP_PKT_10G3_7_2_BMP ==  mapping_mode ||
                  DIGI_MAP_ODU2EP_PKT_10G3_7_1_BMP ==  mapping_mode);

        break;
    case DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT:
    case DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT_RX_PMON:
        result = (DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP      == mapping_mode ||
                  DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP_ENET == mapping_mode);
        break;
    case DIGI_ENET_SERDES_10GE_TRANSPARENT:
    case DIGI_ENET_SERDES_10GE_TRANSPARENT_RX_PMON:
        result = (DIGI_MAP_ODU1EP_CBR_10G3_7_2_BMP == mapping_mode ||
                  DIGI_MAP_ODU2EP_CBR_10G3_7_1_BMP == mapping_mode);
        break;
    default:
        break;
    }
    PMC_RETURN(result);
} /* digi_enet_mapotn_mapping_check */

/*******************************************************************************
* digi_mapotn_mapping_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function checks that 2 MAPOTN mapping modes are compatibible
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   in_mapping_mode  - Enum, OPU payload mapping modes.
*   out_mapping_mode - Enum, OPU payload mapping modes.
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   BOOL8 - TRUE if Mapping modes are compatible, FALSE otherwise
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL8 digi_mapotn_mapping_check(digi_handle_t *digi_handle,
                                        digi_mapping_mode_t in_mapping_mode,
                                        digi_mapping_mode_t out_mapping_mode)
{
    BOOL8 result = FALSE;

    PMC_ENTRY();
    
    switch(in_mapping_mode)
    {
    case DIGI_MAP_ODUKP_PACKET_GFP:
    case DIGI_MAP_ODU4P_100_GE_GFP_ENET:
    case DIGI_MAP_ODU3P_40_GE_GFP_ENET:
    case DIGI_MAP_ODU2P_10_GE_6_2_GFP_ENET:
    case DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP_ENET:
        result = (out_mapping_mode == DIGI_MAP_ODUKP_PACKET_GFP ||
                  out_mapping_mode == DIGI_MAP_ODU4P_100_GE_GFP_ENET ||
                  out_mapping_mode == DIGI_MAP_ODU3P_40_GE_GFP_ENET ||
                  out_mapping_mode == DIGI_MAP_ODU2P_10_GE_6_2_GFP_ENET ||
                  out_mapping_mode == DIGI_MAP_ODU2P_CBR_10_GE_7_3_GFP_ENET);
        break;
    default:
        if (in_mapping_mode == out_mapping_mode)
        {
            result = TRUE;
        }
        break;
    }
    
    PMC_RETURN(result);
} /* digi_mapotn_mapping_check */

/*******************************************************************************
* digi_cpb_mapping_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function determines if source and destination are compatible with 
*   requested mapping
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *input_pc_ptr    - util_global_switch_data_t pointer defining inbound port
*   *output_pc_ptr   - util_global_switch_data_t pointer defining outbound port
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   BOOL8 - TRUE if source and destination are compatible with mapping, otherwise
*           FALSE
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL8 digi_cpb_mapping_check(digi_handle_t *digi_handle,
                                     util_global_switch_data_t *input_pc_ptr,
                                     util_global_switch_data_t *output_pc_ptr) 
{   
    util_global_switch_data_def_t *input_switch_data_def_ptr;  
    util_global_switch_data_def_t *output_switch_data_def_ptr;     
    BOOL8 result = FALSE;
    BOOL8 in_use_etrans_path = FALSE;
    BOOL8 out_use_etrans_path = FALSE;
    digi_enet_mode_t in_enet_mode;
    digi_enet_mode_t out_enet_mode;
    
    PMC_ENTRY();

    input_switch_data_def_ptr = (util_global_switch_data_def_t *)input_pc_ptr;
    output_switch_data_def_ptr = (util_global_switch_data_def_t *)output_pc_ptr;

    if (input_switch_data_def_ptr->cpb_data.port_type  == UTIL_GLOBAL_CPB_PORT_ILKN1 ||
        input_switch_data_def_ptr->cpb_data.port_type  == UTIL_GLOBAL_CPB_PORT_ILKN2 ||
        output_switch_data_def_ptr->cpb_data.port_type  == UTIL_GLOBAL_CPB_PORT_ILKN1 ||
        output_switch_data_def_ptr->cpb_data.port_type  == UTIL_GLOBAL_CPB_PORT_ILKN2)
    {
        /* we accept everything from ILKN interfaces */
        result  = TRUE;
    } else if (output_switch_data_def_ptr->header.prov_state == UTIL_GLOBAL_CHNL_PROV_STATE_UNCONFIG)
    {
        /* an unconfig destination is an enhanced PMON connection, these connnections are correct per design */
        result = TRUE;
        
    } else   
    {
        digi_cbr_client_chnl_def_t *in_cbr_client_chnl_def_ptr, *out_cbr_client_chnl_def_ptr;
        digi_mapper_chnl_def_t *in_mapper_chnl_def_ptr, *out_mapper_chnl_def_ptr;
        digi_enet_client_chnl_def_t *in_enet_client_chnl_def_ptr,  *out_enet_client_chnl_def_ptr;
        switch(input_switch_data_def_ptr->cpb_data.port_type)
        {
        case UTIL_GLOBAL_CPB_PORT_CBRC: 
            in_cbr_client_chnl_def_ptr= (digi_cbr_client_chnl_def_t *) input_switch_data_def_ptr;
            if (output_switch_data_def_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_CBRC)
            {
                out_cbr_client_chnl_def_ptr = (digi_cbr_client_chnl_def_t *) output_switch_data_def_ptr;
                result = digi_cbr_mapping_check(digi_handle,in_cbr_client_chnl_def_ptr->mode,out_cbr_client_chnl_def_ptr->mode);
            } else if (output_switch_data_def_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_MAPOTN)
            {
                out_mapper_chnl_def_ptr = (digi_mapper_chnl_def_t *) output_switch_data_def_ptr;
                result = digi_cbr_mapotn_mapping_check(digi_handle,in_cbr_client_chnl_def_ptr->mode,out_mapper_chnl_def_ptr->mode);
            }
            /* mapping to ENET is not supported */
            break;
        case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
        case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
            if (UTIL_GLOBAL_CPB_PORT_ENET_LINE == input_switch_data_def_ptr->cpb_data.port_type)
            {
                in_use_etrans_path = digi_mapotn_enet_etrans_mode_convert(digi_handle,input_pc_ptr, &in_enet_mode);            
            }
            in_enet_client_chnl_def_ptr = (digi_enet_client_chnl_def_t *) input_switch_data_def_ptr;
             
            /* the ENET_LINE output may be actually a MAPPER segment */
            if (output_switch_data_def_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE)
            {
                out_use_etrans_path = digi_mapotn_enet_etrans_mode_convert(digi_handle,output_pc_ptr, &out_enet_mode);            
            }
                 
            if (output_switch_data_def_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE ||
                output_switch_data_def_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ENET_SYS)
            {
                out_enet_client_chnl_def_ptr = (digi_enet_client_chnl_def_t *) output_switch_data_def_ptr;
                result = digi_enet_mapping_check(digi_handle,
                                                 (in_use_etrans_path==TRUE)?in_enet_mode:in_enet_client_chnl_def_ptr->mode,
                                                 (out_use_etrans_path==TRUE)?out_enet_mode:out_enet_client_chnl_def_ptr->mode);
            } else if (output_switch_data_def_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_MAPOTN )
            {
                out_mapper_chnl_def_ptr = (digi_mapper_chnl_def_t *) output_switch_data_def_ptr;
                result = digi_enet_mapotn_mapping_check(digi_handle,
                                                        (in_use_etrans_path==TRUE)?in_enet_mode:in_enet_client_chnl_def_ptr->mode,
                                                        out_mapper_chnl_def_ptr->mode);
            }
            /* CBRC is not supported */
            break;             
        case UTIL_GLOBAL_CPB_PORT_MAPOTN:
            in_mapper_chnl_def_ptr = (digi_mapper_chnl_def_t *) input_switch_data_def_ptr;
            /* the ENET_LINE output may be actually a MAPPER segment */
            if (output_switch_data_def_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE)
            {
                out_use_etrans_path = digi_mapotn_enet_etrans_mode_convert(digi_handle,output_pc_ptr, &out_enet_mode);            
            }

            if (output_switch_data_def_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_MAPOTN)
            {
                out_mapper_chnl_def_ptr = (digi_mapper_chnl_def_t *) output_switch_data_def_ptr;
                result = digi_mapotn_mapping_check(digi_handle,in_mapper_chnl_def_ptr->mode,out_mapper_chnl_def_ptr->mode);                 
            } else if (output_switch_data_def_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_CBRC)
            {
                out_cbr_client_chnl_def_ptr = (digi_cbr_client_chnl_def_t *) output_switch_data_def_ptr;
                result = digi_cbr_mapotn_mapping_check(digi_handle,out_cbr_client_chnl_def_ptr->mode,in_mapper_chnl_def_ptr->mode);
            } else if (output_switch_data_def_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE || 
                       output_switch_data_def_ptr->cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ENET_SYS)
            {
                out_enet_client_chnl_def_ptr = (digi_enet_client_chnl_def_t *) output_switch_data_def_ptr;
                result = digi_enet_mapotn_mapping_check(digi_handle,
                                                        out_use_etrans_path==TRUE?out_enet_mode:out_enet_client_chnl_def_ptr->mode,
                                                        in_mapper_chnl_def_ptr->mode);
            }
            break;
        default:
            break;
        }        
    }
    PMC_RETURN(result);
} /*digi_cpb_mapping_check */

/*******************************************************************************
* digi_cpb_test_rate_compatibility()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function determines if the source and destination are compatible with 
*   requested rate 
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *input_pc_ptr    - util_global_switch_data_t pointer defining inbound port
*   *output_pc_ptr   - util_global_switch_data_t pointer defining outbound port
*   rate_data        - enum, client stream types of signal passing through CPB.
*                      For DIGI_CPB_STREAM_PKT_GFPF_ODUFLEX, client_num_odu0 
*                      must be provided
*   client_num_odu0  - For DIGI_CPB_STREAM_PKT_GFPF_ODUFLEX, number of ODU0 
*                      container associated with ODUFLEX signal.
*   halt_buffer      - CPB FIFO buffer room to capture in flight data in
*                      the event that CPB FIFO generates an upstream flow
*                      control signal.  Used in cases where ENET utilizes
*                      pause flow control and where a channel is fed from
*                      SIFD and asserts XOFF flow control.  halt_buffer is
*                      specified in units of blocks.  The block size in bytes 
*                      per unit is: 12288 bytes.
*                      Applicable to client_data containing:
*                      "DIGI_CPB_STREAM_PKT_"
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_cpb_test_rate_compatibility(digi_handle_t *digi_handle,
                                                   util_global_switch_data_t *input_pc_ptr,
                                                   util_global_switch_data_t *output_pc_ptr,
                                                   digi_cpb_stream_t rate_data,
                                                   UINT32 client_num_odu0,
                                                   UINT32 halt_buffer)
{
    PMC_ERROR rc = PMC_SUCCESS;
    UINT32 input_num_slot, output_num_slot, requested_num_slot;

    PMC_ENTRY();

    /* convert requested in number of slot */
    switch(rate_data)
    {
    case DIGI_CPB_STREAM_1G25:
        requested_num_slot = 1;
        break;
    case DIGI_CPB_STREAM_2G5:
        requested_num_slot = 2;
        break;
    case DIGI_CPB_STREAM_FLEX:
        requested_num_slot = client_num_odu0;
        break;
    case DIGI_CPB_STREAM_10G:
        requested_num_slot =8;
        break;
    case DIGI_CPB_STREAM_40G:
        requested_num_slot =32;
        break;
    case DIGI_CPB_STREAM_100G:
        requested_num_slot =80;
        break;
    default:
        rc = DIGI_ERR_INVALID_ARG;
    }
        
    if (PMC_SUCCESS == rc)
    {
        rc = digi_cpb_switch_data_slot_get(digi_handle,(util_global_switch_data_def_t *)input_pc_ptr, &input_num_slot);
    }
    if (PMC_SUCCESS == rc)
    {
        rc = digi_cpb_switch_data_slot_get(digi_handle,(util_global_switch_data_def_t *)output_pc_ptr, &output_num_slot);
    }
    if (PMC_SUCCESS == rc)
    {
        if  ( ( (input_num_slot > output_num_slot)  && (requested_num_slot < output_num_slot)) ||
              (  (input_num_slot <= output_num_slot) && (requested_num_slot < input_num_slot)))
        {
            rc = DIGI_ERR_CPB_INCOMPATIBLE_RATE;
        }
    }
    
    if (PMC_SUCCESS == rc)
    {
        /* check if the mapping is compatible */
        if (digi_cpb_mapping_check(digi_handle, input_pc_ptr,output_pc_ptr) == FALSE)
        {
            rc = DIGI_ERR_CPB_INCOMPATIBLE_MAPPING;
        }
    }

    PMC_RETURN(rc);
} /* digi_cpb_test_rate_compatibility */

/*******************************************************************************
* digi_cpb_switch_data_slot_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function determines the number of slots provisionned for a port
*
* INPUTS:
*   *digi_handle     - pointer to DIGI handle instance.
*   *switch_data_ptr    - util_global_switch_data_t pointer defining a port
*
* OUTPUTS:
*   *num_slot        - number of slot associated to the port
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_switch_data_slot_get(digi_handle_t *digi_handle,
                                               util_global_switch_data_def_t *switch_data_ptr,
                                               UINT32 *num_slot)
{
    PMC_ERROR rc = PMC_SUCCESS;
    digi_ilkn_chnl_def_t *ilkn_chnl_def_ptr;
    digi_cbr_client_chnl_def_t *cbr_client_chnl_def_ptr;
    digi_group_size_t group_size;

    PMC_ENTRY();

    switch(switch_data_ptr->cpb_data.port_type)
    {
    case UTIL_GLOBAL_CPB_PORT_ILKN1:
    case UTIL_GLOBAL_CPB_PORT_ILKN2:            
        ilkn_chnl_def_ptr = (digi_ilkn_chnl_def_t *) switch_data_ptr;
        *num_slot = (UINT32) ilkn_chnl_def_ptr->rate;
        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
        if (switch_data_ptr->oduk_data.port_type == UTIL_GLOBAL_ODUK_PORT_MAPOTN)
        {
            mapotn_db_link_num_entries_get(digi_handle->mapotn_handle,switch_data_ptr->oduk_data.channel,num_slot);
        } else 
        {
            rc  = enet_db_link_num_entries_get(digi_handle->enet_line_handle,switch_data_ptr->cpb_data.channel,num_slot);                                         
        }        
        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
        rc  = enet_db_link_num_entries_get(digi_handle->enet_sys_handle,switch_data_ptr->cpb_data.channel,num_slot);                                         
        break;
    case UTIL_GLOBAL_CPB_PORT_CBRC:
        cbr_client_chnl_def_ptr = (digi_cbr_client_chnl_def_t *) switch_data_ptr;            
        digi_cbrc_prov_params_convert(cbr_client_chnl_def_ptr->mode, &group_size);
        *num_slot = (group_size == DIGI_GRP_SIZE_10G)?8:32;
        break;
    case UTIL_GLOBAL_CPB_PORT_MAPOTN:
        mapotn_db_link_num_entries_get(digi_handle->mapotn_handle,switch_data_ptr->cpb_data.channel,num_slot);            
        break;
    default:
        rc = DIGI_ERR_INVALID_ARG;
    }
    
    PMC_RETURN(rc);
} /*digi_cpb_switch_data_slot_get */

/*******************************************************************************
* digi_enet_channel_is_GSUP43_7_3_TRANSPARENT_mode()
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   This function determines if the enet_chnl_ptr is in
*   a GSUP43_7_3_TRANSPARENT mode.
*
* INPUTS:
*   *enet_chnl_ptr         - input mapping channel.
*
* OUTPUTS:
*   None
*
* RETURNS:
*   BOOL - TRUE if enet_chnl_ptr is in a GSUP43_7_3_TRANSPARENT mode, FALSE otherwise.
*  
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL digi_enet_channel_is_GSUP43_7_3_TRANSPARENT_mode(digi_enet_client_chnl_def_t* enet_chnl_ptr)
{

    BOOL result = FALSE;

    PMC_ENTRY();

    if ((enet_chnl_ptr->mode == DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT) ||
        (enet_chnl_ptr->mode == DIGI_ENET_SERDES_10GE_GSUP43_7_3_TRANSPARENT_RX_PMON)) {

        result = TRUE;
    }

    PMC_RETURN(result);

} /* digi_enet_channel_is_GSUP43_7_3_TRANSPARENT_mode */

/*******************************************************************************
* digi_mcpb_halt_buffer_size_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function sets MCPB halt buffer size based on the rate, ingress and egress ports.
*
* INPUTS:
*    egr_port           - type of the egress port
*    ingr_port          - type of the ingress port
*    rate               - channel rate
*
* OUTPUTS:
*   None.
*    *halt_buffer_size  - halt buffer size
*
* RETURNS:
*   PMC_SUCCESS when operation is successful otherwise a descriptive error code is returned.
*
* NOTES: This function is called from the digi_mcpb_chnl_prov and
*        it is not expected to provision MCPB channels for the sub 10G rates.
*
*******************************************************************************/
PRIVATE void digi_mcpb_halt_buffer_size_set (cpb_mcpb_egr_output_port_type_t egr_port,
                                             cpb_mcpb_ingr_input_port_type_t ingr_port,
                                             UINT32                          rate,
                                             UINT32                          *halt_buffer_size)
{
    PMC_ENTRY();
    /* adjust rate to Gbit/sec units */ 
    rate /= 1000;

    switch(rate)
    {           
    case 10:
        if(egr_port==CPB_MCPB_EGR_CPU&&ingr_port!=CPB_MCPB_ING_FEGE_INS)
        {
            *halt_buffer_size = 8;
        }   
        else if(egr_port==CPB_MCPB_EGR_CPU&&ingr_port==CPB_MCPB_ING_FEGE_INS)
        {
            *halt_buffer_size = 1;
        }
        else if(egr_port==CPB_MCPB_EGR_FEGE&&ingr_port==CPB_MCPB_ING_CPU_INS)
        {
            *halt_buffer_size = 8;
        }
        else
        {
            *halt_buffer_size = 1;
        }
        break;
    case 40:
        if(egr_port==CPB_MCPB_EGR_CPU&&ingr_port!=CPB_MCPB_ING_FEGE_INS)
        {
            *halt_buffer_size = 12*3+8;
        }   
        else if(egr_port==CPB_MCPB_EGR_CPU&&ingr_port==CPB_MCPB_ING_FEGE_INS)
        {
            *halt_buffer_size = 1;
        }
        else if(egr_port==CPB_MCPB_EGR_FEGE&&ingr_port==CPB_MCPB_ING_CPU_INS)
        {
            *halt_buffer_size = 8;
        }
        else
        {
            *halt_buffer_size = 12*3+1;
        }
        break;
    case 100:
        if(egr_port==CPB_MCPB_EGR_CPU&&ingr_port!=CPB_MCPB_ING_FEGE_INS)
        {
            *halt_buffer_size = 12*11+8;
        }   
        else if(egr_port==CPB_MCPB_EGR_CPU&&ingr_port==CPB_MCPB_ING_FEGE_INS)
        {
            *halt_buffer_size = 1;
        }
        else if(egr_port==CPB_MCPB_EGR_FEGE&&ingr_port==CPB_MCPB_ING_CPU_INS)
        {
            *halt_buffer_size = 8;
        }
        else
        {
            *halt_buffer_size = 12*11+1;
        }
        break;
    default:
        *halt_buffer_size = 1;
        break;
    }
    PMC_RETURN();
}

/*******************************************************************************
* digi_otn_mpmo_ckctl_port_offset_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Function calculated the CKCTL port offset associated to a serdes port.
*
* INPUTS:
*   digi_handle           - pointer to digi handle instance.
*   intf                  - serdes interface belonging to datapath.
*  
* OUTPUTS:
*  *ckctl_port_offset_ptr - CKCTL port offset.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_mpmo_ckctl_port_offset_get(digi_handle_t             *digi_handle, 
                                                     digi_serdes_intf_t         intf,
                                                     UINT32                    *ckctl_port_offset_ptr)
{ 
    PMC_ERROR rc = PMC_SUCCESS;

    PMC_ENTRY();
    
    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != ckctl_port_offset_ptr, DIGI_ERR_INVALID_ARG, 0, 0);

    
    /* Configure appropriate serdes based on interface type */
    switch (intf)
    {
    case DIGI_SERDES_SYSTEM_INTF:
    {
        *ckctl_port_offset_ptr = DIGI_SERDES_XFI_LANES_MAX + DIGI_NUM_SFI51_PORTS_MAX;
        break;
    }
    case DIGI_SERDES_LINE_INTF:
    { 
        *ckctl_port_offset_ptr = 0;
        break;
    }
    case DIGI_SERDES_SFI_51_INTF:
    {
        *ckctl_port_offset_ptr = DIGI_SERDES_XFI_LANES_MAX;
        break;
    }
    default:
        rc = DIGI_ERR_INVALID_ARG;
        break;
    }

    PMC_RETURN(rc);
}/*  digi_otn_mpmo_ckctl_port_offset_get */

#endif /* DOXYGEN_PUBLIC_ONLY */
/*******************************************************************************
* digi_debug_oduksw_page_block_alloc_print
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function prints information about the ODUkSW page and block
*   talbe.
*
* INPUTS:
*   *digi_handle           - pointer to digi handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_debug_oduksw_page_block_alloc_print(digi_handle_t* digi_handle)
{
    cpb_handle_t * ocpb_handle;
#ifdef PMC_TESTS 
    PMC_ATOMIC_ENTRY_VOID(digi_handle);
#else 
    PMC_ATOMIC_ENTRY(digi_handle);
#endif
    
    ocpb_handle = coreotn_oduksw_handle_get(digi_handle->coreotn_handle);

    cpb_debug_page_block_alloc_print(ocpb_handle);

    PMC_ATOMIC_RETURN(digi_handle);
} /* digi_debug_oduksw_page_block_alloc_print */

#ifndef DOXYGEN_PUBLIC_ONLY
/*******************************************************************************
* FUNCTION: digi_ilkn_link_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_link_handle_validate(digi_handle_t   *digi_handle,
                                                void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    
    if (handle_ptr >= (void*)&digi_handle->handle_pool.ilkn_link[0] &&
        handle_ptr <= (void*)&digi_handle->handle_pool.ilkn_link[DIGI_SIFD_ILKN_NUM - 1] &&
        0 == (((PMC_UINTPTR)handle_ptr - (PMC_UINTPTR)&digi_handle->handle_pool.ilkn_link[0]) % sizeof(digi_ilkn_link_def_t)))
    {
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
}/* digi_ilkn_link_handle_validate */

/*******************************************************************************
* FUNCTION: digi_ilkn_chnl_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ilkn_chnl_handle_validate(digi_handle_t   * digi_handle,
                                                void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    
    if (handle_ptr >= (void*)&digi_handle->handle_pool.ilkn_1_chnl[0] &&
        handle_ptr <= (void*)&digi_handle->handle_pool.ilkn_1_chnl[DIGI_SIFD_ILKN_ARB_DPI_CHANS_MAX - 1] &&
        0 == (((PMC_UINTPTR)handle_ptr - (PMC_UINTPTR)&digi_handle->handle_pool.ilkn_1_chnl[0]) % sizeof(digi_ilkn_chnl_def_t)))
    {
        rc = PMC_SUCCESS;
    }

    if (PMC_SUCCESS != rc)
    {
        if (handle_ptr >= (void*)&digi_handle->handle_pool.ilkn_2_chnl[0] &&
            handle_ptr <= (void*)&digi_handle->handle_pool.ilkn_2_chnl[DIGI_SIFD_ILKN_ARB_DPI_CHANS_MAX - 1] &&
            0 == (((PMC_UINTPTR)handle_ptr - (PMC_UINTPTR)&digi_handle->handle_pool.ilkn_2_chnl[0]) % sizeof(digi_ilkn_chnl_def_t)))
        {
            rc = PMC_SUCCESS;
        }
    }

    PMC_RETURN(rc);
}/* digi_ilkn_chnl_handle_validate */

/*******************************************************************************
* FUNCTION: digi_enet_line_chnl_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_enet_line_chnl_handle_validate(digi_handle_t   * digi_handle,
                                                     void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    
    if (handle_ptr >= (void*)&digi_handle->handle_pool.enet_line_chnl[0] &&
        handle_ptr <= (void*)&digi_handle->handle_pool.enet_line_chnl[DIGI_ENET_LINE_CHNL_MAX - 1] &&
        0 == (((PMC_UINTPTR)handle_ptr - (PMC_UINTPTR)&digi_handle->handle_pool.enet_line_chnl[0]) % sizeof(digi_enet_client_chnl_def_t)))
    {
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
}/* digi_enet_line_chnl_handle_validate */

/*******************************************************************************
* FUNCTION: digi_enet_sys_chnl_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_enet_sys_chnl_handle_validate(digi_handle_t   * digi_handle,
                                                    void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    
    if (handle_ptr >= (void*)&digi_handle->handle_pool.enet_sys_chnl[0] &&
        handle_ptr <= (void*)&digi_handle->handle_pool.enet_sys_chnl[DIGI_ENET_SYS_CHNL_MAX - 1] &&
        0 == (((PMC_UINTPTR)handle_ptr - (PMC_UINTPTR)&digi_handle->handle_pool.enet_sys_chnl[0]) % sizeof(digi_enet_client_chnl_def_t)))
    {
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
}/* digi_enet_sys_chnl_handle_validate */

/*******************************************************************************
* FUNCTION: digi_enet_chnl_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_enet_chnl_handle_validate(digi_handle_t   * digi_handle,
                                                    void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();

    rc = digi_enet_line_chnl_handle_validate(digi_handle, handle_ptr);

    if (PMC_SUCCESS != rc)
    {
        rc = digi_enet_sys_chnl_handle_validate(digi_handle, handle_ptr);
    }

    PMC_RETURN(rc);
}/* digi_enet_chnl_handle_validate */

/*******************************************************************************
* FUNCTION: digi_cbr_chnl_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cbr_chnl_handle_validate(digi_handle_t   *digi_handle,
                                               void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    
    if (handle_ptr >= (void*)&digi_handle->handle_pool.cbr_chnl[0] &&
        handle_ptr <= (void*)&digi_handle->handle_pool.cbr_chnl[DIGI_CBRC_CHNL_MAX - 1] &&
        0 == (((PMC_UINTPTR)handle_ptr - (PMC_UINTPTR)&digi_handle->handle_pool.cbr_chnl[0]) % sizeof(digi_cbr_client_chnl_def_t)))
    {
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
}/* digi_cbr_chnl_handle_validate */

/*******************************************************************************
* FUNCTION: digi_mapper_chnl_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_mapper_chnl_handle_validate(digi_handle_t   * digi_handle,
                                                  void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    
    if (handle_ptr >= (void*)&digi_handle->handle_pool.mapper_chnl[0] &&
        handle_ptr <= (void*)&digi_handle->handle_pool.mapper_chnl[DIGI_MAPOTN_CHNL_MAX - 1] &&
        0 == (((PMC_UINTPTR)handle_ptr - (PMC_UINTPTR)&digi_handle->handle_pool.mapper_chnl[0]) % sizeof(digi_mapper_chnl_def_t)))
    {
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
}/* digi_mapper_chnl_handle_validate */

/*******************************************************************************
* FUNCTION: digi_otn_server_chnl_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_server_chnl_handle_validate(digi_handle_t   * digi_handle,
                                                      void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    if (handle_ptr == (void*)&digi_handle->handle_pool.sysotn_server_chnl ||
        (handle_ptr >= (void*)&digi_handle->handle_pool.otn_server_chnl[0] &&
         handle_ptr <= (void*)&digi_handle->handle_pool.otn_server_chnl[DIGI_OTN_SERVER_CHNL_MAX - 1] &&
         0 == (((PMC_UINTPTR)handle_ptr - (PMC_UINTPTR)&digi_handle->handle_pool.otn_server_chnl[0]) % sizeof(digi_otn_server_chnl_def_t))))
    {
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
}/* digi_otn_server_chnl_handle_validate */

/*******************************************************************************
* FUNCTION: digi_sysotn_server_chnl_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_sysotn_server_chnl_handle_validate(digi_handle_t   * digi_handle,
                                                         void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    
    if (handle_ptr == (void*)&digi_handle->handle_pool.sysotn_server_chnl)
    {
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
}/* digi_sysotn_server_chnl_handle_validate */

/*******************************************************************************
* FUNCTION: digi_ho_odu_struct_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_ho_odu_struct_handle_validate(digi_handle_t   * digi_handle,
                                                    void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    
    if (handle_ptr >= (void*)&digi_handle->handle_pool.ho_odu_struct[0] &&
        handle_ptr <= (void*)&digi_handle->handle_pool.ho_odu_struct[DIGI_OTN_SERVER_HO_CHNL_MAX - 1] &&
        0 == (((PMC_UINTPTR)handle_ptr - (PMC_UINTPTR)&digi_handle->handle_pool.ho_odu_struct[0]) % sizeof(odu_struct_t)))
    {
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
}/* digi_ho_odu_struct_handle_validate */

/*******************************************************************************
* FUNCTION: digi_mo_odu_struct_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_mo_odu_struct_handle_validate(digi_handle_t   * digi_handle,
                                                    void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    
    if (handle_ptr >= (void*)&digi_handle->handle_pool.mo_odu_struct[0] &&
        handle_ptr <= (void*)&digi_handle->handle_pool.mo_odu_struct[DIGI_OTN_SERVER_MO_CHNL_MAX - 1] &&
        0 == (((PMC_UINTPTR)handle_ptr - (PMC_UINTPTR)&digi_handle->handle_pool.mo_odu_struct[0]) % sizeof(odu_struct_t)))
    {
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
}/* digi_mo_odu_struct_handle_validate */

/*******************************************************************************
* FUNCTION: digi_lo_odu_struct_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_lo_odu_struct_handle_validate(digi_handle_t   * digi_handle,
                                                    void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    
    if (handle_ptr >= (void*)&digi_handle->handle_pool.lo_odu_struct[0] &&
        handle_ptr <= (void*)&digi_handle->handle_pool.lo_odu_struct[DIGI_OTN_SERVER_LO_CHNL_MAX - 1] &&
        0 == (((PMC_UINTPTR)handle_ptr - (PMC_UINTPTR)&digi_handle->handle_pool.lo_odu_struct[0]) % sizeof(odu_struct_t)))
    {
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
}/* digi_lo_odu_struct_handle_validate */

/*******************************************************************************
* FUNCTION: digi_s3b_odu_struct_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_s3b_odu_struct_handle_validate(digi_handle_t   * digi_handle,
                                                     void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    
    if (handle_ptr >= (void*)&digi_handle->handle_pool.s3b_odu_struct[0] &&
        handle_ptr <= (void*)&digi_handle->handle_pool.s3b_odu_struct[DIGI_OTN_SERVER_LO_CHNL_MAX - 1] &&
        0 == (((PMC_UINTPTR)handle_ptr - (PMC_UINTPTR)&digi_handle->handle_pool.s3b_odu_struct[0]) % sizeof(odu_struct_t)))
    {
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
}/* digi_s3b_odu_struct_handle_validate */

/*******************************************************************************
* FUNCTION: digi_s4_odu_struct_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_s4_odu_struct_handle_validate(digi_handle_t   * digi_handle,
                                                    void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    
    if (handle_ptr >= (void*)&digi_handle->handle_pool.s4_odu_struct[0] &&
        handle_ptr <= (void*)&digi_handle->handle_pool.s4_odu_struct[DIGI_OTN_SERVER_LO_CHNL_MAX - 1] &&
        0 == (((PMC_UINTPTR)handle_ptr - (PMC_UINTPTR)&digi_handle->handle_pool.s4_odu_struct[0]) % sizeof(odu_struct_t)))
    {
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
}/* digi_s4_odu_struct_handle_validate */

/*******************************************************************************
* FUNCTION: digi_sysotn_line_struct_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_sysotn_line_struct_handle_validate(digi_handle_t   * digi_handle,
                                                         void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    
    if (handle_ptr >= (void*)&digi_handle->handle_pool.sysotn_line_struct[0] &&
        handle_ptr <= (void*)&digi_handle->handle_pool.sysotn_line_struct[DIGI_OTN_SERVER_HO_CHNL_MAX - 1] &&
        0 == (((PMC_UINTPTR)handle_ptr - (PMC_UINTPTR)&digi_handle->handle_pool.sysotn_line_struct[0]) % sizeof(odu_struct_t)))
    {
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
}/* digi_sysotn_line_struct_handle_validate */


/*******************************************************************************
* FUNCTION: digi_otn_odu_chnl_handle_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_otn_odu_chnl_handle_validate(digi_handle_t   * digi_handle,
                                                   void            *handle_ptr)
{
    PMC_ERROR rc;

    PMC_ENTRY();
    
    rc = digi_ho_odu_struct_handle_validate(digi_handle, handle_ptr);

    if (PMC_SUCCESS != rc)
    {
        rc = digi_mo_odu_struct_handle_validate(digi_handle, handle_ptr);
    }

    if (PMC_SUCCESS != rc)
    {
        rc = digi_lo_odu_struct_handle_validate(digi_handle, handle_ptr);
    }
    if (PMC_SUCCESS != rc)
    {
        rc = digi_s3b_odu_struct_handle_validate(digi_handle, handle_ptr);
    }
    if (PMC_SUCCESS != rc)
    {
        rc = digi_s4_odu_struct_handle_validate(digi_handle, handle_ptr);
    }
    if (PMC_SUCCESS != rc)
    {
        rc = digi_sysotn_line_struct_handle_validate(digi_handle, handle_ptr);
    }

    PMC_RETURN(rc);
}/* digi_otn_odu_chnl_handle_validate */

/*******************************************************************************
* FUNCTION: digi_serdes_port_ctxt_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *port_ctxt_ptr   - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_serdes_port_ctxt_validate(digi_handle_t      *digi_handle,
                                                digi_serdes_port_t *port_ctxt_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    
    if (port_ctxt_ptr >= (void*)&digi_handle->var.port_ctxt.line_port_ctxt[0] &&
        port_ctxt_ptr <= (void*)&digi_handle->var.port_ctxt.sys_port_ctxt[DIGI_NUM_SYS_PORTS_MAX - 1] &&
        0 == (((PMC_UINTPTR)port_ctxt_ptr - (PMC_UINTPTR)&digi_handle->var.port_ctxt.line_port_ctxt[0]) % sizeof(digi_serdes_port_def_t)))
    {
        rc = PMC_SUCCESS;
    }

    PMC_RETURN(rc);
}/* digi_serdes_port_ctxt_validate */

/*******************************************************************************
* FUNCTION: digi_oduksw_chnl_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_oduksw_chnl_validate(digi_handle_t   * digi_handle,
                                           void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();
    
    rc = digi_ilkn_chnl_handle_validate(digi_handle, handle_ptr);

    if (PMC_SUCCESS != rc)
    {
        rc = digi_ho_odu_struct_handle_validate(digi_handle, handle_ptr);
    }

    if (PMC_SUCCESS != rc)
    {
        rc = digi_mo_odu_struct_handle_validate(digi_handle, handle_ptr);
    }

    if (PMC_SUCCESS != rc)
    {
        rc = digi_lo_odu_struct_handle_validate(digi_handle, handle_ptr);
    }

    if (PMC_SUCCESS != rc)
    {
        rc = digi_s3b_odu_struct_handle_validate(digi_handle, handle_ptr);
    }

    if (PMC_SUCCESS != rc)
    {
        rc = digi_s4_odu_struct_handle_validate(digi_handle, handle_ptr);
    }

    if (PMC_SUCCESS != rc)
    {
        rc = digi_sysotn_line_struct_handle_validate(digi_handle, handle_ptr);
    }

    if (PMC_SUCCESS != rc)
    {
        rc = digi_mapper_chnl_handle_validate(digi_handle, handle_ptr);
    }

    PMC_RETURN(rc);
}/* digi_oduksw_chnl_validate */

/*******************************************************************************
* FUNCTION: digi_cpb_chnl_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Helper function that verifies that the given handle belongs to DIGI handle pool.
*
* INPUTS:
*   digi_handle     - pointer to DIGI handle instance.
*  *handle_ptr      - pointer to handle to validate
*
*   
* OUTPUTS:
*   None. 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cpb_chnl_validate(digi_handle_t   *digi_handle,
                                        void            *handle_ptr)
{
    PMC_ERROR rc = DIGI_ERR_INVALID_ARG;

    PMC_ENTRY();

    rc = digi_ilkn_chnl_handle_validate(digi_handle, handle_ptr);

    if (PMC_SUCCESS != rc)
    {
        rc = digi_mapper_chnl_handle_validate(digi_handle, handle_ptr);
    }

    if (PMC_SUCCESS != rc)
    {
        rc = digi_cbr_chnl_handle_validate(digi_handle, handle_ptr);
    }

    if (PMC_SUCCESS != rc)
    {
        rc = digi_enet_chnl_handle_validate(digi_handle, handle_ptr);
    }

    if (PMC_SUCCESS == rc && handle_ptr == NULL)
    {
        rc = DIGI_ERR_INVALID_ARG;
    }

    PMC_RETURN(rc);
}/* digi_cpb_chnl_validate */


/*******************************************************************************
* FUNCTION: digi_cbr_validate_params()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Validates the digi_handl and cbr channel handle, returning the cbrc handle
*   and link number.
*
* INPUTS:
*   *digi_handle           - pointer to DIGI handle instance
*   *chnl_handle           - pointer to CBR channel handle instance
*
* OUTPUTS:
*  **cbrc_handle_pptr      - pointer to a pointer to CBRC handle
*   *link_ptr              - pointer to link number
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR digi_cbr_validate_params(digi_handle_t             *digi_handle,
                                          digi_cbr_client_chnl_t    *chnl_handle,
                                          cbrc_handle_t            **cbrc_handle_pptr,
                                          UINT32                    *link_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;    
    digi_cbr_client_chnl_def_t  *cbr_chnl_handle; 
    UINT32                       link;

    PMC_ENTRY();

    PMC_ASSERT(NULL != digi_handle, DIGI_ERR_NULL_HANDLE, 0, 0);
    if (NULL == chnl_handle)
    {
        PMC_ASSERT(FALSE, DIGI_ERR_NULL_HANDLE, 0, 0);
    }

    DIGI_CBR_CHNL_HANDLE_CHECK(digi_handle, chnl_handle, result);

    if (PMC_SUCCESS == result)
    {
        cbr_chnl_handle = (digi_cbr_client_chnl_def_t *) chnl_handle;
        link = cbr_chnl_handle->switch_data.cpb_data.channel;
    
        /* Check for swtich data magic number */
        DIGI_CHNL_HANDLE_MAGIC_CHECK(chnl_handle);
    
        /* Check for max link */
        PMC_ASSERT(link < CBRC_MAX_LINK, DIGI_ERR_INVALID_ARG, link, CBRC_MAX_LINK);
    }
    
    if (PMC_SUCCESS == result)
    {

        /* CPB port type should be for CBRC */
        switch (cbr_chnl_handle->switch_data.cpb_data.port_type) 
        {
          case UTIL_GLOBAL_CPB_PORT_CBRC:
            *cbrc_handle_pptr = digi_handle->cbrc_handle;
            break;
          default:
            PMC_ASSERT(FALSE, DIGI_ERR_INVALID_ARG, 0, 0);
            break;
        }
    }

    if (PMC_SUCCESS == result)
    {
        *link_ptr = link;
    }
    PMC_RETURN(result);
} /* digi_cbr_validate_params */


/*******************************************************************************
* digi_cpb_enet_mirror_chk
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function determines if the output_pc_data_ptr channel handle is an 
*   enet mirror channel handle. An enet mirror channnel handle is provisioned
*   using digi_enet_line_mirror_prov. 
*   
*
*
* INPUTS:
*   *digi_handle            - the pointer to the digi handle instance
*   output_pc_data_ptr      - channel handle to check.
*
*
* OUTPUTS:
*   None
* 
* RETURNS:
*   BOOL                    - True if the output_pc_data_ptr represents a enet mirror \n
*                             channel handle. FALSE otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL digi_cpb_enet_mirror_chk(digi_handle_t *digi_handle,
                                     util_global_switch_data_t *output_pc_data_ptr)
{
    PMC_ERROR result;
    UINT32 rd_channel_id[DIGI_SCHD_96_ENTRY];
    UINT32 ch_id,i;
    digi_enet_client_chnl_def_t* enet_chnl_ptr = (digi_enet_client_chnl_def_t *)output_pc_data_ptr;

    PMC_ENTRY();

    if (enet_chnl_ptr->switch_data.cpb_data.port_type != UTIL_GLOBAL_CPB_PORT_ENET_LINE)
    {
        PMC_RETURN(FALSE);
    }

    /* if the data_source == TRUE then the channel is associated with ETRANS path.  This is invalid for 
       mirror port and would not be a mirror port */
    if (enet_chnl_ptr->switch_data.cpb_data.port_type == UTIL_GLOBAL_CPB_PORT_ENET_LINE &&
        enet_chnl_ptr->switch_data.cpb_data.data_source == TRUE)
        PMC_RETURN(FALSE);

    ch_id = enet_chnl_ptr->switch_data.cpb_data.channel;

    result = cpb_dcs_db_entry_all_get(digi_handle->dcpb_handle, DIGI_SCHD_ENET_LINE_DCS_INSTANCE,rd_channel_id);

    /* If there's an entry in the enet line cpb dcs db for the channel then it's not a mirror port */
    if (result == PMC_SUCCESS)
    { 
        for (i=0;i < DIGI_SCHD_96_ENTRY;i++)
        {
            if(rd_channel_id[i] == ch_id)
            {
                PMC_RETURN(FALSE);
            }
        } 
    }

    /* The channel was not found in the enet line db. It's a mirror port if the channel is in the mapper dcs db */
    result = cpb_dcs_db_entry_all_get(digi_handle->dcpb_handle, DIGI_SCHD_MAPPER_DCS_INSTANCE,rd_channel_id);

    /* If there's no entries - return false */
    if (result != PMC_SUCCESS)
    {
        PMC_RETURN(FALSE);
    }
   
    for (i=0;i < DIGI_SCHD_96_ENTRY;i++)
    {
        if(rd_channel_id[i] == ch_id)
        {
            PMC_RETURN(TRUE);
        }
    } 
    PMC_RETURN(FALSE);
} /* digi_cpb_enet_mirror_chk */

/*******************************************************************************
* digi_cpb_retrieve_input_port
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Function sets the input pointer from the digi channel handle based on
*  the ingress port and channel value.
*   
*
*
* INPUTS:
*  *digi_handle            - the pointer to the digi handle instance
*  input_port              - Input port type
*  input_chnl              - Input channel value
*
* OUTPUTS:
*   None
* 
* RETURNS:
*  util_global_switch_data_t - Reference to the input channel handle. NULL if
*                              not found.
*
* NOTES:
*
*******************************************************************************/
PUBLIC util_global_switch_data_t* digi_cpb_retrieve_input_port(digi_handle_t* digi_handle,
                                                               UINT32 input_port,
                                                               UINT32 input_chnl)
{
    util_global_switch_data_t* input_pc_ptr = NULL;
    PMC_ENTRY();

    switch(input_port) 
    {
    case UTIL_GLOBAL_CPB_PORT_ILKN1:
        input_pc_ptr = (util_global_switch_data_t*)&(digi_handle->handle_pool.ilkn_1_chnl[input_chnl]);
        break;
    case UTIL_GLOBAL_CPB_PORT_ILKN2:
        input_pc_ptr = (util_global_switch_data_t*)&(digi_handle->handle_pool.ilkn_2_chnl[input_chnl]);
        break;
    case UTIL_GLOBAL_CPB_PORT_CBRC:
        input_pc_ptr = (util_global_switch_data_t*)&(digi_handle->handle_pool.cbr_chnl[input_chnl]);
        break;
    case UTIL_GLOBAL_CPB_PORT_MAPOTN:
        input_pc_ptr = (util_global_switch_data_t*)&(digi_handle->handle_pool.mapper_chnl[input_chnl]);
        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_LINE:
        input_pc_ptr = (util_global_switch_data_t*)&(digi_handle->handle_pool.enet_line_chnl[input_chnl]);
        break;
    case UTIL_GLOBAL_CPB_PORT_ENET_SYS:
        input_pc_ptr = (util_global_switch_data_t*)&(digi_handle->handle_pool.enet_sys_chnl[input_chnl]);
        
        break;
    default:
        /* We can't determine our state. Assert. */
        PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
    }
    
    if (UTIL_GLOBAL_CPB_PORT_ENET_LINE == input_port )
    {
        util_global_switch_data_def_t* input_switch_data_ptr = (util_global_switch_data_def_t*)input_pc_ptr;
        util_global_cpb_port_data_t *local_input_pc_ptr = &(input_switch_data_ptr->cpb_data);
        
        if (NULL == local_input_pc_ptr || 
            UTIL_GLOBAL_CPB_PORT_NOT_USED == local_input_pc_ptr->port_type)
        {
            /*
             * This is an enet line port that is not actually being used. The alternative is
             * that this is actually a mapper channeel that is using enet_line and the data
             * has been assigned to the digi_handle->handle_pool.mapper_chnl. Iterate through
             * it to determine what channel it is.
             */
            UINT32 i = 0;
            input_pc_ptr = NULL;

            for (i=0; i < DIGI_MAPOTN_CHNL_MAX; i++)
            {
                digi_mapper_chnl_def_t *switch_mapper_ptr = &(digi_handle->handle_pool.mapper_chnl[i]);

                if (UTIL_GLOBAL_CPB_PORT_ENET_LINE == switch_mapper_ptr->switch_data.cpb_data.port_type &&
                    switch_mapper_ptr->switch_data.cpb_data.channel == input_chnl &&
                    switch_mapper_ptr->switch_data.cpb_data.op_state.map_state.is_input_mapped)
                {
                    input_pc_ptr = (util_global_switch_data_t*)&(digi_handle->handle_pool.mapper_chnl[i]);
                    break;
                }
            }
        }
    }

    PMC_RETURN(input_pc_ptr);
} /* digi_cpb_retrieve_input_port */

/*******************************************************************************
* digi_otn_server_oduksw_prov_deprov_end
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs ODUkSW bulk provision/deprovision for every ODUkSW port
*   that's in use, it swaps and updates its DCS.
*
* INPUTS:
*   *digi_handle      - pointer to DIGI slice handle instance.
*   is_prov                 - TRUE if the operation is bulk provisioning.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_otn_server_oduksw_prov_deprov_end(digi_handle_t *digi_handle,
                                                   BOOL8 is_prov)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT8 oduksw_port_num = 0;
    BOOL8 update_output_port = FALSE;
    BOOL8 update_input_port = FALSE;
    coreotn_mpma_inst_t mpma_inst = LAST_COREOTN_MPMA_INST;

    UINT8 oduksw_input_port_num = 0;
    UINT32 output_ch_idx;
    BOOL8 is_dcs_updated = FALSE;
    BOOL8 is_channel_idx_updated_arr[UTIL_GLOBAL_ODUK_PORT_NOT_USED][DIGI_SCHD_96_ENTRY];
    util_global_switch_data_t* input_dcs_chnls_per_port[UTIL_GLOBAL_ODUK_PORT_NOT_USED][DIGI_SCHD_96_ENTRY];
    util_global_switch_data_t* output_dcs_chnls_per_port[UTIL_GLOBAL_ODUK_PORT_NOT_USED][DIGI_SCHD_96_ENTRY];
    UINT32 dcs_chnls_counter[UTIL_GLOBAL_ODUK_PORT_NOT_USED];
    UINT32* dcs_chnls_counter_ptr = NULL;

    util_global_switch_data_t* input_dcs_chnls[DIGI_SCHD_96_ENTRY];
    util_global_switch_data_t* output_dcs_chnls[DIGI_SCHD_96_ENTRY];

    util_global_oduk_port_t input_port_type = LAST_UTIL_GLOBAL_ODUK_PORT;

    PMC_ENTRY();

    /* Initialize local counter and channel arrays to default values */
    for (oduksw_input_port_num = 0; oduksw_input_port_num < UTIL_GLOBAL_ODUK_PORT_NOT_USED; oduksw_input_port_num++)
    {
        dcs_chnls_counter[oduksw_input_port_num] = 0;
        for (output_ch_idx = 0; output_ch_idx < DIGI_SCHD_96_ENTRY; output_ch_idx++)
        {
            input_dcs_chnls_per_port[oduksw_input_port_num][output_ch_idx] = NULL;
            output_dcs_chnls_per_port[oduksw_input_port_num][output_ch_idx] = NULL;
            is_channel_idx_updated_arr[oduksw_input_port_num][output_ch_idx] = FALSE;
        }
    }

    for (oduksw_port_num = 0; oduksw_port_num < UTIL_GLOBAL_ODUK_PORT_NOT_USED; oduksw_port_num++)
    {
        update_output_port = coreotn_oduksw_port_bulk_update_req_get(digi_handle->coreotn_handle,
                                                                     (util_global_oduk_port_t)oduksw_port_num,
                                                                     UTIL_GLOBAL_DATAPATH_DIR_EGRESS);
        if (TRUE == update_output_port)
        {
            result = coreotn_oduksw_dcs_swap_and_update_all(digi_handle->coreotn_handle,
                                                            oduksw_port_num,
                                                            &is_dcs_updated,
                                                            is_channel_idx_updated_arr[oduksw_port_num]);
            PMC_ASSERT(PMC_SUCCESS == result, result, 0, 0);
        }
    }

    for (oduksw_port_num = 0; oduksw_port_num < UTIL_GLOBAL_ODUK_PORT_NOT_USED; oduksw_port_num++)
    {
        update_input_port = coreotn_oduksw_port_bulk_update_req_get(digi_handle->coreotn_handle,
                                                                    (util_global_oduk_port_t)oduksw_port_num,
                                                                    UTIL_GLOBAL_DATAPATH_DIR_INGRESS);

        if (TRUE == update_input_port)
        {
            /* swap and update MPMA calendar. Note, coreotn_mpma_scbs3_all_chnls_activate
             * and coreotn_mpma_scbs3_all_chnls_deactivate are functionally the same*/
            switch (oduksw_port_num)
            {
                case UTIL_GLOBAL_ODUK_PORT_MAPOTN:
                    mpma_inst = COREOTN_MPMA_FROM_MAPOTN;
                    break;
                case UTIL_GLOBAL_ODUK_PORT_COREOTN:
                    mpma_inst = COREOTN_MPMA_TO_COREOTN;
                    break;
                case UTIL_GLOBAL_ODUK_PORT_ILKN1:
                    if (digi_handle->var.prod_app == DIGI_PROD_APP_SYSOTN_CARD)
                    {
                        mpma_inst = COREOTN_MPMA_CORECTL;
                    }
                    else
                    {
                        mpma_inst = LAST_COREOTN_MPMA_INST;
                    }
                    break;
                case UTIL_GLOBAL_ODUK_PORT_ILKN2:
                    mpma_inst = LAST_COREOTN_MPMA_INST;
                    break;
                default:
                    PMC_ASSERT(FALSE, DIGI_ERR_CODE_ASSERT, 0, 0);
                    break;
            }

            if (LAST_COREOTN_MPMA_INST != mpma_inst)
            {
                /* need to call coreotn_mpma_scbs3_all_chnls_activate or
                 * coreotn_mpma_scbs3_all_chnls_deactivate */

                if (TRUE == is_prov)
                {
                    /* ODUkSW bulk provision sequence */
                    result = coreotn_mpma_scbs3_all_chnls_activate(digi_handle->coreotn_handle,
                                                                   mpma_inst);
                    PMC_ASSERT(PMC_SUCCESS == result, result, 0, 0);
                }
                else
                {
                    /*do nothing... */
                }
            }
        } /* if (TRUE == update_input_port) */
    }

    /*required to add mpma FW procedure if provisioning*/
    if(is_prov == TRUE)
    {

        for (oduksw_port_num = 0; oduksw_port_num < UTIL_GLOBAL_ODUK_PORT_NOT_USED; oduksw_port_num++)
        {

            for (output_ch_idx = 0; output_ch_idx < DIGI_SCHD_96_ENTRY; output_ch_idx++)
            {

                /* Get the channel's handle from ODUkSW port and channel ID */

                /*digi_oduksw_input_port_get provides input port from output port.
                The API is completely different than the API that's used here for G4*/

                if (TRUE == is_channel_idx_updated_arr[oduksw_port_num][output_ch_idx])
                {
                    output_dcs_chnls[output_ch_idx] = digi_oduksw_input_port_get(digi_handle,
                                                                                 oduksw_port_num,
                                                                                 output_ch_idx,
                                                                                 DIGI_ILKN_CHNL_TARGET_ODUK);

                    /* Only proceed if the ODUKSW has been activate at the output port*/
                    PMC_ASSERT(NULL != output_dcs_chnls[output_ch_idx], DIGI_ERR_NULL_HANDLE, 0, 0);

                    digi_opsa_src_chnl_hndl_for_dest_get(digi_handle,
                                                         output_dcs_chnls[output_ch_idx],
                                                         TRUE,
                                                         &input_dcs_chnls[output_ch_idx]);
                    PMC_ASSERT(NULL != input_dcs_chnls[output_ch_idx], DIGI_ERR_NULL_HANDLE, 0, 0);
                    
                    input_port_type = DIGI_ODUK_PORT_TYPE_GET(input_dcs_chnls[output_ch_idx]);

                    dcs_chnls_counter_ptr = &dcs_chnls_counter[input_port_type];
                    input_dcs_chnls_per_port[input_port_type][*dcs_chnls_counter_ptr] = input_dcs_chnls[output_ch_idx];
                    output_dcs_chnls_per_port[input_port_type][*dcs_chnls_counter_ptr] = output_dcs_chnls[output_ch_idx];
                    (*dcs_chnls_counter_ptr)++;
                }
            }
        }


        for (oduksw_input_port_num = 0; oduksw_input_port_num < UTIL_GLOBAL_ODUK_PORT_NOT_USED; oduksw_input_port_num++)
        {
            if (dcs_chnls_counter[oduksw_input_port_num] > 0)
            {
                /* channel counter for oduksw_input_port_num is positive which
                 * means there are channels in input/output lists.
                 * If counter is zero, no need to perform OPSA update for the path:
                 * oduksw_input_port_num <-> oduksw_output_port. */

                digi_oduksw_bulk_prov_opsa_activate(digi_handle,
                                                    input_dcs_chnls_per_port[oduksw_input_port_num],
                                                    output_dcs_chnls_per_port[oduksw_input_port_num]);
            }
        }

    }

    PMC_RETURN();
} /*digi_otn_server_oduksw_prov_deprov_end*/


/*******************************************************************************
* digi_otn_fc_calendar_bulk_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs an update to the SIFD flow control calendar during
*   a bulk provision/deprovision scenario.
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void digi_otn_fc_calendar_bulk_update(digi_handle_t *digi_handle)
{
    util_global_datapath_dir_t port_dir = LAST_UTIL_GLOBAL_DATAPATH_DIR;
    UINT8 oduksw_port_num = 0;
    BOOL8 update_tx_port = FALSE;
    BOOL8 update_rx_port = FALSE;


    PMC_ENTRY();

    for (oduksw_port_num = UTIL_GLOBAL_ODUK_PORT_ILKN1; oduksw_port_num <= UTIL_GLOBAL_ODUK_PORT_ILKN2; oduksw_port_num++)
    {
        if (TRUE == digi_coreotn_oduksw_is_ilkn_port(digi_handle, (util_global_oduk_port_t)oduksw_port_num))
        {
            port_dir = UTIL_GLOBAL_DATAPATH_DIR_EGRESS;
            update_tx_port = coreotn_oduksw_port_bulk_update_req_get(digi_handle->coreotn_handle,
                                                                     (util_global_oduk_port_t)oduksw_port_num,
                                                                     port_dir);
            if (TRUE == update_tx_port)
            {
                digi_sifd_fc_calendar_bulk_update(digi_handle,
                                                  (util_global_oduk_port_t)oduksw_port_num,
                                                  port_dir);
            }

            port_dir = UTIL_GLOBAL_DATAPATH_DIR_INGRESS;
            update_rx_port = coreotn_oduksw_port_bulk_update_req_get(digi_handle->coreotn_handle,
                                                                     (util_global_oduk_port_t)oduksw_port_num,
                                                                     port_dir);
            if (TRUE == update_rx_port)
            {
                digi_sifd_fc_calendar_bulk_update(digi_handle,
                                                  (util_global_oduk_port_t)oduksw_port_num,
                                                  port_dir);
            }
        }
    }

    PMC_RETURN();
}/*digi_otn_fc_calendar_bulk_update*/

/*******************************************************************************
* digi_oduksw_bulk_prov_opsa_activate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs OPSA activation for a list of inputs and outputs ODUkSW
*   channels. All inputs channels must be on the same input port and the same
*   applies for all output channels. The input/output channels are provided to
*   function using arrays so that input_dcs_chnls_per_port[i] points to
*   output_dcs_chnls_per_port[i].
*   This function iterates over the arrays. When we've reached a NULL entry,
*   we've finished the scanning. In each iteration, we get booleans for
*   is_other_reader_primary and is_other_slave_zone_primary which are later
*   provided, along with input/output channels to the function that performs the
*   actual OPSA activation, digi_opsa_oduksw_activate_cfg_all().
*
* INPUTS:
*   *digi_handle          - pointer to DIGI slice handle instance.
*   *input_dcs_chnls_per_port   - array of input channels that are all on the same
*                                 ODUkSW port, each points to the respective output
*                                 channel in the output channels array.
*                                 All valid (non-NULL) channels are at the beginning
*                                 of the array and NULLs are following them till array's end.
*   *output_dcs_chnls_per_port  - array of output channels that are all on the same
*                                 ODUkSW port whose inputs channels are in
*                                 input_dcs_chnls_per_port[] array.
*                                 All valid (non-NULL) channels are at the beginning
*                                 of the array and NULLs are following them till array's end.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void digi_oduksw_bulk_prov_opsa_activate(digi_handle_t* digi_handle,
                                                 util_global_switch_data_t* input_dcs_chnls_per_port[],
                                                 util_global_switch_data_t* output_dcs_chnls_per_port[])
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 ch_idx = 0;
    BOOL is_other_reader_primary_arr[DIGI_SCHD_96_ENTRY];
    BOOL is_other_slave_zone_primary_arr[DIGI_SCHD_96_ENTRY];
    BOOL is_broadcast = FALSE;
    BOOL is_multicast = FALSE;


    PMC_ENTRY();

    for (ch_idx = 0; ch_idx < DIGI_SCHD_96_ENTRY; ch_idx++)
    {
        if (NULL == output_dcs_chnls_per_port[ch_idx])
        {
            /* When array entry is NULL, we've reached the end of the list */
            break;
        }

        PMC_ASSERT(input_dcs_chnls_per_port[ch_idx] != NULL, DIGI_ERR_INVALID_ARG, 0, 0);

        result = coreotn_oduksw_chnl_type_get(digi_handle->coreotn_handle,
                                              DIGI_ODUK_PORT_TYPE_GET(output_dcs_chnls_per_port[ch_idx]),
                                              DIGI_ODUK_CHANNEL_GET(output_dcs_chnls_per_port[ch_idx]),
                                              &is_other_reader_primary_arr[ch_idx],
                                              &is_other_slave_zone_primary_arr[ch_idx],
                                              &is_broadcast,
                                              &is_multicast);
        PMC_ASSERT(PMC_SUCCESS == result, DIGI_ERR_INVALID_ARG, 0, 0);
    }

    if (ch_idx != 0)
    {
        /* When ch_idx isn't zero, it means that we have at least one non-NULL entry in the channel lists */

        digi_opsa_oduksw_activate_cfg_all(digi_handle,
                                          input_dcs_chnls_per_port,
                                          output_dcs_chnls_per_port,
                                          is_other_reader_primary_arr,
                                          is_other_slave_zone_primary_arr,
                                          DIGI_OPSA_CFG_ACTION_ACTIVATE);
    }

    PMC_RETURN();
} /*digi_oduksw_bulk_prov_opsa_activate*/


/*******************************************************************************
* digi_coreotn_null_sig_recover
* ______________________________________________________________________________
*
* DESCRIPTION:
*   In restart, the prbs_null_frame and the null_frame contexts aren't recovered.
*   Thus we need to recover that context manually from register values.
*
* INPUTS:
*   *digi_handle      - pointer to DIGI handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*
*******************************************************************************/
PRIVATE PMC_ERROR digi_coreotn_null_sig_recover(digi_handle_t *digi_handle)
{
    PMC_ERROR result = PMC_SUCCESS;

    UINT32  chnl_itr                    = 0;
    UINT32  null_arr_itr                = 0;
    BOOL8   insert_null_en              = 0;
    BOOL8   remove_null_en              = 0;
    BOOL8   fo2_prbs_gen_en             = 0;
    UINT32  *null_en_ptr                = NULL;
    UINT32  *prbs_null_en_ptr           = NULL;
    UINT32  recovered_null_en[3]        = {0, 0, 0};
    UINT32  recovered_prbs_null_en[3]   = {0, 0, 0};
    PMC_ENTRY();

    /* RECOVER */
    for (chnl_itr = 0; chnl_itr < DIGI_OTN_SERVER_LO_CHNL_MAX; chnl_itr++)
    {

        /* getting info from registers */
        result =  mapotn_null_frame_get(digi_handle->mapotn_handle,
                                        chnl_itr,
                                        &insert_null_en,
                                        &remove_null_en);
        PMC_ASSERT(PMC_SUCCESS == result, result, 0, 0);

        /* Restoring NULL channel enable */
           if (TRUE == insert_null_en && TRUE == remove_null_en)
        {
               /* This array indicates that channel is in NULL client mode.
                * In this case, mapotn_null_frame_cfg() is called with
                * direction=BOTH which sets both OHFS_INSERT:NULL_CHAN_EN and
                * OHFS_REMOVE:NULL_CHAN_EN fields.
                * So in order to recover the value of the array channel bit,
                * we read both of those fields and only if both are set,
                * we set the relevant channel array bit. */
            recovered_null_en[chnl_itr/32] |= (1UL << (chnl_itr%32));
        }

        /* getting info from registers */
        result = coreotn_prbs_chnl_prov_get(digi_handle->coreotn_handle,
                                            COREOTN_FO2_PRBS,
                                            chnl_itr,
                                            &fo2_prbs_gen_en);
        PMC_ASSERT(PMC_SUCCESS == result, result, 0, 0);

        /* Restoring PRBS NULL channel enable */
        if (TRUE == insert_null_en && TRUE == fo2_prbs_gen_en)
        {
            /* This array indicates that prbs generator is active and this
             * channel. In this case, digi_otn_prbs_chnl_init() is called
             * which sets both OHFS_INSERT:NULL_CHAN_EN and
             * PRBS_GEN_EN fields.
             * So in order to recover the value of the array channel bit,
             * we read both of those fields and only if both are set,
             * we set the relevant channel array bit. */
            recovered_prbs_null_en[chnl_itr/32] |= (1UL << (chnl_itr%32));
        }
    }

    /* RECOVER */
    coreotn_mapotn_null_frame_mode_ptr_get(digi_handle->coreotn_handle,
                                           &null_en_ptr,
                                           &prbs_null_en_ptr);

    for (null_arr_itr = 0; null_arr_itr < 3; null_arr_itr++)
    {
        null_en_ptr[null_arr_itr]      = recovered_null_en[null_arr_itr];
        prbs_null_en_ptr[null_arr_itr] = recovered_prbs_null_en[null_arr_itr];
    }

    PMC_RETURN(result);
} /*digi_coreotn_null_sig_recover*/

#endif /* DOXYGEN_PUBLIC_ONLY */

/*******************************************************************************
* digi_coreotn_oduksw_is_ilkn_port
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs OPSA activation for a list of inputs and outputs ODUkSW
*
* INPUTS:
*   *digi_handle      - pointer to DIGI slice handle instance.
*   oduksw_port_num         - The number of the ODUKSW port that the ILKN is connected to.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL8 digi_coreotn_oduksw_is_ilkn_port(digi_handle_t *digi_handle,
                                               util_global_oduk_port_t oduksw_port_num)
{
    BOOL8 is_ilkn_port = FALSE;

    PMC_ENTRY();

    if (UTIL_GLOBAL_ODUK_PORT_ILKN1 == oduksw_port_num)
    {
        is_ilkn_port = TRUE;
    }
    else if (UTIL_GLOBAL_ODUK_PORT_ILKN2 == oduksw_port_num)
    {
        is_ilkn_port = TRUE;
    }
    else
    {
        is_ilkn_port = FALSE;
    }

    PMC_RETURN(is_ilkn_port);
}/*digi_coreotn_oduksw_is_ilkn_port*/

/*
** End of file
*/

