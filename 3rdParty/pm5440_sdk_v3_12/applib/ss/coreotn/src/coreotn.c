/*******************************************************************************
*   COPYRIGHT (C) 2011 PMC-SIERRA, INC. ALL RIGHTS RESERVED.
* --------------------------------------------------------------------------
*  This software embodies materials and concepts which are proprietary and
*  confidential to PMC-Sierra, Inc.
*  PMC-Sierra distributes this software to its customers pursuant to the
*  terms and conditions of the Software License Agreement
*  contained in the text file software.lic that is distributed along with
*  the software. This software can only be utilized if all
*  terms and conditions of the Software License Agreement are
*  accepted. If there are any questions, concerns, or if the
*  Software License Agreement text file, software.lic, is missing please
*  contact PMC-Sierra for assistance.
* --------------------------------------------------------------------------
*   DESCRIPTION : This file contains C functions for COREOTN subsystem for
*   handle creation, datapath provisioning and activation.
*
*   NOTES:
*
*******************************************************************************/
/*
** Include Files 
*/

#include "coreotn_loc.h"

/*
** Local Enumerated Types
*/

/*
** Local Constants 
*/
#define COREOTN_12_FRM_CHNL   (12)
#define COREOTN_96_FRM_CHNL   (96)
#define COREOTN_PRBS_EXTRA_CTXT_START 13
#define COREOTN_PRBS_EXTRA_CTXT_END 20

/*
** Local Macro Definitions
*/ 

/*
** Local Structures and Unions
*/

/*
** Local Variables
*/

/*
** Log Messaging
*/
/* Only include the strings if logging with text*/
#ifdef PMC_LOG_STRINGS

/*
* The following creates the LOG/ERR strings from above by pulling out the text
* portion of the LOG_ERR_TABLE above
*/
#define PMC_LOG_ERR_PAIR_ENTRY_CREATE( enum, str ) str,
const char COREOTN_LOG_ERR_STRINGS[][PMC_LOG_STRING_SIZEOF] =
{
    "Start of log string list",
    COREOTN_LOG_ERR_TABLE
};
#undef PMC_LOG_ERR_PAIR_ENTRY_CREATE

#else /* no strings */

const char COREOTN_LOG_ERR_STRINGS[1][1] = {};

#endif /* PMC_SW_SIMULATION */


/*
** Forward References
*/
PRIVATE PMC_ERROR coreotn_int_transfer_enable(coreotn_handle_t    *coreotn_handle, 
                                              coreotn_latch_defect_t latch_defect,
                                              BOOL8 enable);
PRIVATE PMC_ERROR coreotn_mpma_mpmo_handle_get(coreotn_handle_t           *coreotn_handle,
                                               coreotn_int_chnl_info_t    *chnl_info,
                                               mpma_handle_t              **mpma_handle,
                                               mpmo_handle_t              **mpmo_handle);
PRIVATE PMC_ERROR coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle_t *coreotn_handle,
                                                      odtu_dmx_handle_t *lo_dmx_handle_ptr,
                                                      UINT32 ho_chnl_id);
PRIVATE PMC_ERROR coreotn_tx_lo_chnl_add_ho_page_swap(coreotn_handle_t *coreotn_handle,
                                                      odtu_mux_handle_t *lo_mux_handle_ptr,
                                                      UINT32 ho_chnl_id);
PRIVATE PMC_ERROR coreotn_rev_a_somf_sync_patch(coreotn_handle_t  *coreotn_handle,
                                                odtu_mux_handle_t *lo_mux_handle_ptr,
                                                util_global_odukp_type_t ho_odu_container,
                                                UINT32 ho_chnl_id,
                                                BOOL8 enable);
PRIVATE void coreotn_keep2clean_list_get(UINT32 keep_chnl_list[],
                                         UINT32 num_keep,
                                         UINT32 max_num_chnl,
                                         UINT32 clean_chnl_list[],
                                         UINT32 *num_clean);
PRIVATE void coreotn_odu_rcp_ohp_cleanup(coreotn_handle_t *coreotn_handle,
                                         BOOL is_rx,
                                         odu_struct_frm_id_t frm_id,
                                         UINT32 clean_chnl_list[],
                                         UINT32 num_clean);
PRIVATE PMC_ERROR coreotn_db_ho_entry_activate(coreotn_handle_t *coreotn_handle,
                                               util_gen_db_id_t db_id, UINT32 chnl_id);
PRIVATE PMC_ERROR coreotn_energy_coherency_check(coreotn_handle_t *coreotn_handle,
                                                 coreotn_recover_var_t *coreotn_var_reg);
PRIVATE PMC_ERROR coreotn_ctxt_audit(coreotn_handle_t *coreotn_handle,
                                     util_global_restart_init_cfg_t *restart_init_cfg_ptr,
                                     coreotn_recover_var_t *coreotn_var_reg,
                                     coreotn_var_t *coreotn_var_clean);
PRIVATE PMC_ERROR coreotn_ctxt_cleanup(coreotn_handle_t *coreotn_handle,
                                       util_global_restart_init_cfg_t *restart_init_cfg_ptr,
                                       coreotn_recover_var_t *coreotn_var_reg,
                                       coreotn_var_t *coreotn_var_clean);
PRIVATE PMC_ERROR coreotn_ctxt_reg_recover(coreotn_handle_t *coreotn_handle,
                                           pmc_energy_state_t top_energy_state_reg,                                         
                                           util_global_restart_init_cfg_t *restart_init_cfg_ptr,
                                           coreotn_recover_var_t *coreotn_var_reg);
PRIVATE void coreotn_odukp_init(coreotn_handle_t *coreotn_handle,
                                pmc_energy_state_t energy_state);
PRIVATE void coreotn_oduksw_init(coreotn_handle_t *coreotn_handle,
                                 pmc_energy_state_t energy_state);
PRIVATE void coreotn_stg4_init(coreotn_handle_t *coreotn_handle,
                               pmc_energy_state_t energy_state);
PRIVATE void coreotn_dci_mux1_cfg(coreotn_handle_t *coreotn_handle,
                                  coreotn_fmf_inst_t fmf_instance,
                                  coreotn_dci_mux1_src_t mux_src);
PRIVATE void coreotn_dci_mux2_cfg(coreotn_handle_t *coreotn_handle,
                                  coreotn_fmf_inst_t fmf_instance,
                                  coreotn_dci_mux2_src_t mux_src);
PRIVATE void coreotn_dci_mux3_cfg(coreotn_handle_t *coreotn_handle,
                                  coreotn_fmf_inst_t fmf_instance,
                                  coreotn_dci_mux3_src_t mux_src);
PRIVATE void coreotn_dci_mux4_cfg(coreotn_handle_t *coreotn_handle,
                                  coreotn_fmf_inst_t fmf_instance,
                                  coreotn_dci_mux4_src_t mux_src);
PRIVATE void coreotn_dci_mux5_cfg(coreotn_handle_t *coreotn_handle,
                                  coreotn_fmf_inst_t fmf_instance,
                                  coreotn_dci_mux5_src_t mux_src);
PRIVATE PMC_ERROR coreotn_dci_mux_ctrl_cfg(coreotn_handle_t *coreotn_handle,
                                           coreotn_init_operation_t init_operation);
/* SS level access control */
PRIVATE void coreotn_var_default_init(coreotn_handle_t *coreotn_handle,coreotn_var_t *coreotn_var);

/* block level reset control */
/* MPMA block reset and lowpwr control */
PRIVATE void coreotn_odu_ohp_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                  coreotn_odu_ohp_inst_t ohp_instance,
                                                  pmc_energy_state_t *energy_state);
PRIVATE void coreotn_odu_ohp_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                  coreotn_odu_ohp_inst_t ohp_instance,
                                                  pmc_energy_state_t energy_state);

/* MPMA block reset and lowpwr control */
PRIVATE void coreotn_mpma_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                               coreotn_mpma_inst_t mpma_instance,
                                               pmc_energy_state_t *energy_state);
PRIVATE void coreotn_mpma_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                               coreotn_mpma_inst_t mpma_instance,
                                               pmc_energy_state_t energy_state);
/* MPMO block reset and lowpwr control */
PRIVATE void coreotn_mpmo_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                               coreotn_mpmo_inst_t mpmo_instance,
                                               pmc_energy_state_t *mpmo_energy_state);
PRIVATE void coreotn_mpmo_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                               coreotn_mpmo_inst_t mpmo_instance,
                                               pmc_energy_state_t energy_state);
/* ODU_RFRM block reset and lowpwr control */
PRIVATE void coreotn_odu_rfrm_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odu_rfrm_inst_t rfrm_stg,
                                                   pmc_energy_state_t *odu_rfrm_energy_state);
PRIVATE void coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odu_rfrm_inst_t rfrm_stg,
                                                   pmc_energy_state_t energy_state);
/* ODU_TFRM block reset and lowpwr control */
PRIVATE void coreotn_odu_tfrm_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odu_tfrm_inst_t tfrm_stg,
                                                   pmc_energy_state_t *odu_tfrm_energy_state);
PRIVATE void coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odu_tfrm_inst_t tfrm_stg,
                                                   pmc_energy_state_t energy_state);
/* ODTU_DMX block reset and lowpwr control */
PRIVATE void coreotn_odtu_dmx_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odtu_dmx_inst_t dmx_stg,
                                                   pmc_energy_state_t *dmx_energy_state);
PRIVATE void coreotn_odtu_dmx_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odtu_dmx_inst_t dmx_stg,
                                                   pmc_energy_state_t energy_state);
/* ODTU_MUX block reset and lowpwr control */
PRIVATE void coreotn_odtu_mux_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odtu_mux_inst_t mux_stg,
                                                   pmc_energy_state_t *mux_energy_state);
PRIVATE void coreotn_odtu_mux_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odtu_mux_inst_t mux_stg,
                                                   pmc_energy_state_t energy_state);
/* ODUKSC block reset and lowpwr control */
PRIVATE void coreotn_oduksc_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                 coreotn_oduksc_inst_t oduksc_inst,
                                                 pmc_energy_state_t *oduksc_energy_state);
PRIVATE void coreotn_oduksc_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                 coreotn_oduksc_inst_t oduksc_inst,
                                                 pmc_energy_state_t energy_state);
/* ODUJAT block reset and lowpwr control */
PRIVATE void coreotn_odujat_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                 coreotn_odujat_inst_t odujat_inst,
                                                 pmc_energy_state_t *odujat_energy_state);
PRIVATE void coreotn_odujat_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                 coreotn_odujat_inst_t odujat_inst,
                                                 pmc_energy_state_t energy_state);

/* OTN_PRBS block rset and lowpwr control */
PRIVATE void coreotn_prbs_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                               coreotn_prbs_inst_t prbs_instance,
                                               pmc_energy_state_t *prbs_energy_state);
PRIVATE void coreotn_prbs_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                               coreotn_prbs_inst_t prbs_instance,
                                               pmc_energy_state_t energy_state);
                                                      
/* FRM_RCP block rst and lowpwr control */
PRIVATE void coreotn_frm_rcp_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                  coreotn_frm_rcp_inst_t frm_rcp_instance,
                                                  pmc_energy_state_t *frm_rcp_energy_state);
PRIVATE void coreotn_frm_rcp_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                  coreotn_frm_rcp_inst_t frm_rcp_instance,
                                                  pmc_energy_state_t energy_state);   
                                                         
/* OHFS_REMOVE block rst and lowpwr control */
PRIVATE void coreotn_ohfs_remove_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                      coreotn_ohfs_remove_inst_t ohfs_remove_blk,
                                                      pmc_energy_state_t *ohfs_remove_energy_state);
                                                      
PRIVATE void coreotn_ohfs_remove_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                      coreotn_ohfs_remove_inst_t ohfs_remove_blk,
                                                      pmc_energy_state_t energy_state);                                                      

                                                                                                                           
PUBLIC void coreotn_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                         coreotn_energy_state_t *energy_state);
PRIVATE void coreotn_odukp_frm_rcp_cfc_fifo_activate(coreotn_handle_t *coreotn_handle,
                                                     coreotn_init_operation_t init_op);  
PRIVATE void coreotn_stg4_frm_rcp_cfc_fifo_activate(coreotn_handle_t *coreotn_handle);                                                                                             

/* OPSA helper function */
PRIVATE PMC_ERROR coreotn_mpmo_cn_frame_period_set(util_global_odukp_type_t oduk_type,
                                                   util_global_odukp_type_t client_oduk_type, 
                                                   util_global_odu_line_payload_t payload_format,
                                                   util_opsa_cn_frame_period_t *per);

PRIVATE PMC_ERROR coreotn_frm_rcp_fifo_cfg(coreotn_handle_t* coreotn_handle,
                                           coreotn_frm_rcp_inst_t frm_rcp_instance,
                                           UINT32 chnl_id, UINT32 enbl); 

PRIVATE PMC_ERROR coreotn_odu_tfrm_chnl_init(coreotn_handle_t* coreotn_handle,
                                             odu_tfrm_inst_t odu_tfrm_inst,
                                             UINT32 chnl_id, UINT32 enbl);                                                                                          
PRIVATE PMC_ERROR coreotn_ohp_port_framer_cfg(coreotn_handle_t *coreotn_handle, 
                                              odu_ohp_inst_t ohp, 
                                              odu_ohp_port_t port,
                                              odu_ohp_port_framer_t port_framer);

PRIVATE PMC_ERROR coreotn_int_init(coreotn_handle_t    *coreotn_handle,
                                   BOOL                 enable);

/* General helper functions */
PRIVATE PMC_ERROR coreotn_sysapp_line_chnl_state_set(coreotn_handle_t *coreotn_handle,
                                                     UINT32 chnl_id,
                                                     coreotn_chnl_state_t mode);

PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_none_prov(coreotn_handle_t *coreotn_handle,
                                                   UINT32 chnl_id,
                                                   coreotn_mux_stage_t mux_stage,
                                                   util_global_odukp_type_t odu_container,
                                                   util_global_odu_line_payload_t payload_format,
                                                   BOOL prov_rfrm_tfrm_cfg);

PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_one_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t odu_container,
                                                  util_global_odu_line_payload_t payload_format,
                                                  BOOL prov_rfrm_tfrm_cfg);

PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_two_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t odu_container,
                                                  util_global_odu_line_payload_t payload_format);

PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_none_prov(coreotn_handle_t *coreotn_handle,
                                                   UINT32 chnl_id,
                                                   coreotn_mux_stage_t mux_stage,
                                                   util_global_odukp_type_t odu_container,
                                                   util_global_odu_line_payload_t payload_format,
                                                   BOOL prov_rfrm_tfrm_cfg);

PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_one_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t odu_container,
                                                  util_global_odu_line_payload_t payload_format,
                                                  BOOL prov_rfrm_tfrm_cfg);

PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_two_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t odu_container,
                                                  util_global_odu_line_payload_t payload_format);

PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_one_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t lo_odu_type,
                                                  UINT32 odu_flex_rate,
                                                  DOUBLE client_rate,
                                                  coreotn_mapping_type_t mapping_mode,
                                                  UINT32 tribslot_mask[COREOTN_TRIB_WRD_CNT],
                                                  UINT32 trib_port,
                                                  util_global_odu_line_payload_t payload_format,
                                                  util_global_odukp_type_t ho_odu_type,
                                                  UINT32 ho_chnl_id,
                                                  UINT32 client_bitrate,
                                                  BOOL prov_rfrm);

PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_two_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t lo_odu_type,
                                                  UINT32 odu_flex_rate,
                                                  DOUBLE client_rate,
                                                  coreotn_mapping_type_t mapping_mode,
                                                  UINT32 tribslot_mask[COREOTN_TRIB_WRD_CNT],
                                                  UINT32 trib_port,
                                                  util_global_odu_line_payload_t payload_format,
                                                  util_global_odukp_type_t ho_odu_type,
                                                  UINT32 ho_chnl_id,
                                                  UINT32 client_bitrate);

PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_one_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t lo_odu_type,
                                                  UINT32 odu_flex_rate,
                                                  coreotn_mapping_type_t mapping_mode,
                                                  UINT32 tribslot_mask[COREOTN_TRIB_WRD_CNT],
                                                  UINT32 trib_port,
                                                  util_global_odu_line_payload_t payload_format,
                                                  util_global_odukp_type_t ho_odu_type,
                                                  UINT32 ho_chnl_id,
                                                  DOUBLE client_rate,
                                                  BOOL prov_rfrm_tfrm_cfg);

PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_two_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t lo_odu_type,
                                                  UINT32 odu_flex_rate,
                                                  coreotn_mapping_type_t mapping_mode,
                                                  UINT32 tribslot_mask[COREOTN_TRIB_WRD_CNT],
                                                  UINT32 trib_port,
                                                  util_global_odu_line_payload_t payload_format,
                                                  util_global_odukp_type_t ho_odu_type,
                                                  UINT32 ho_chnl_id,
                                                  DOUBLE client_rate);

PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_none_activate(coreotn_handle_t *coreotn_handle,
                                                       UINT32 chnl_id,
                                                       coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_one_activate(coreotn_handle_t *coreotn_handle,
                                                      UINT32 chnl_id,
                                                      coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_two_activate(coreotn_handle_t *coreotn_handle,
                                                      UINT32 chnl_id,
                                                      coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_none_activate(coreotn_handle_t *coreotn_handle,
                                                       UINT32 chnl_id,
                                                       coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_one_activate(coreotn_handle_t *coreotn_handle,
                                                      UINT32 chnl_id,
                                                      coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_two_activate(coreotn_handle_t *coreotn_handle,
                                                      UINT32 chnl_id,
                                                      coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_none_activate(coreotn_handle_t *coreotn_handle,
                                                       UINT32 chnl_id, 
                                                       UINT32 ho_chnl_id);

PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_one_activate(coreotn_handle_t *coreotn_handle,
                                                      UINT32 chnl_id, 
                                                      UINT32 ho_chnl_id,
                                                      coreotn_mux_stage_t mux_stage,
                                                      odtu_dmx_handle_t *lo_dmx_handle_ptr,
                                                      odujat_handle_t *lo_odujat_handle_ptr,
                                                      oduksc_handle_t *lo_oduksc_handle_ptr,
                                                      BOOL activate_rfrm);

PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_two_activate(coreotn_handle_t *coreotn_handle,
                                                      UINT32 chnl_id, 
                                                      UINT32 ho_chnl_id,
                                                      coreotn_mux_stage_t mux_stage,
                                                      odtu_dmx_handle_t *lo_dmx_handle_ptr,
                                                      odujat_handle_t *lo_odujat_handle_ptr,
                                                      oduksc_handle_t *lo_oduksc_handle_ptr);

PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_none_or_one_activate(coreotn_handle_t *coreotn_handle,
                                                              UINT32 chnl_id,
                                                              UINT32 ho_chnl_id,
                                                              odtu_mux_handle_t *lo_mux_handle_ptr,
                                                              util_global_odukp_type_t* lo_odu_rate,
                                                              UINT32* odu_flex_rate,
                                                              coreotn_mapping_type_t* mapping_mode,
                                                              UINT32 tribslot_mask[COREOTN_TRIB_WRD_CNT],
                                                              UINT32* trib_port,
                                                              util_global_odu_line_payload_t* ho_payload_format,
                                                              util_global_odukp_type_t* ho_odu_rate,
                                                              UINT32* cbr_flex_rate);

PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_none_or_two_activate(coreotn_handle_t *coreotn_handle,
                                                              UINT32 chnl_id,
                                                              UINT32 ho_chnl_id,
                                                              util_global_odukp_type_t* lo_odu_rate,
                                                              UINT32* odu_flex_rate,
                                                              coreotn_mapping_type_t* mapping_mode,
                                                              UINT32 tribslot_mask[COREOTN_TRIB_WRD_CNT],
                                                              UINT32* trib_port,
                                                              util_global_odu_line_payload_t* ho_payload_format,
                                                              util_global_odukp_type_t* ho_odu_rate,
                                                              UINT32* cbr_flex_rate);

PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_none_deactivate(coreotn_handle_t *coreotn_handle,
                                                         UINT32 chnl_id,
                                                         coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_one_deactivate(coreotn_handle_t *coreotn_handle,
                                                        UINT32 chnl_id,
                                                        coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_two_deactivate(coreotn_handle_t *coreotn_handle,
                                                        UINT32 chnl_id,
                                                        coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_none_deactivate(coreotn_handle_t *coreotn_handle,
                                                         UINT32 chnl_id,
                                                         coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_one_deactivate(coreotn_handle_t *coreotn_handle,
                                                        UINT32 chnl_id,
                                                        coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_two_deactivate(coreotn_handle_t *coreotn_handle,
                                                        UINT32 chnl_id,
                                                        coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_none_or_one_deactivate(coreotn_handle_t *coreotn_handle,
                                                                UINT32 chnl_id,
                                                                UINT32 ho_chnl_id,
                                                                odtu_dmx_handle_t *lo_dmx_handle_ptr,
                                                                odujat_handle_t *lo_odujat_handle_ptr,
                                                                oduksc_handle_t *lo_oduksc_handle_ptr);

PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_none_or_two_deactivate(coreotn_handle_t *coreotn_handle,
                                                                UINT32 chnl_id,
                                                                UINT32 ho_chnl_id,
                                                                odtu_dmx_handle_t *lo_dmx_handle_ptr,
                                                                odujat_handle_t *lo_odujat_handle_ptr,
                                                                oduksc_handle_t *lo_oduksc_handle_ptr);

PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_none_or_one_deactivate(coreotn_handle_t *coreotn_handle,
                                                                UINT32 chnl_id,
                                                                UINT32 ho_chnl_id,
                                                                odtu_mux_handle_t *lo_mux_handle_ptr);

PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_none_or_two_deactivate(coreotn_handle_t *coreotn_handle,
                                                                UINT32 chnl_id,
                                                                UINT32 ho_chnl_id);

PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_none_deprov(coreotn_handle_t *coreotn_handle,
                                                     UINT32 chnl_id,
                                                     coreotn_mux_stage_t mux_stage,
                                                     BOOL deprov_rfrm_tfrm_cfg);

PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_one_deprov(coreotn_handle_t *coreotn_handle,
                                                    UINT32 chnl_id,
                                                    coreotn_mux_stage_t mux_stage,
                                                    BOOL deprov_rfrm_tfrm_cfg);

PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_two_deprov(coreotn_handle_t *coreotn_handle,
                                                    UINT32 chnl_id,
                                                    coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_none_deprov(coreotn_handle_t *coreotn_handle,
                                                     UINT32 chnl_id,
                                                     coreotn_mux_stage_t mux_stage,
                                                     BOOL deprov_ho_cfg);

PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_one_deprov(coreotn_handle_t *coreotn_handle,
                                                    UINT32 chnl_id,
                                                    coreotn_mux_stage_t mux_stage,
                                                    BOOL deprov_rfrm_tfrm_cfg);

PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_two_deprov(coreotn_handle_t *coreotn_handle,
                                                    UINT32 chnl_id,
                                                    coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_two_deprov(coreotn_handle_t *coreotn_handle,
                                                    coreotn_mux_stage_t mux_stage,
                                                    UINT32 chnl_id,
                                                    UINT32 ho_chnl_id);

PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_one_deprov(coreotn_handle_t *coreotn_handle,
                                                    coreotn_mux_stage_t mux_stage,
                                                    UINT32 chnl_id,
                                                    UINT32 ho_chnl_id,
                                                    BOOL deprov_tfrm);

PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_one_deprov_helper(coreotn_handle_t *coreotn_handle,
                                                           coreotn_mux_stage_t mux_stage,
                                                           UINT32 chnl_id,
                                                           UINT32 ho_chnl_id,
                                                           odtu_mux_handle_t *lo_mux_handle_ptr);

PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_two_deprov(coreotn_handle_t *coreotn_handle,
                                                    UINT32 chnl_id,
                                                    coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_two_deprov(coreotn_handle_t *coreotn_handle,
                                                    UINT32 chnl_id,
                                                    coreotn_mux_stage_t mux_stage);

PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_one_deprov(coreotn_handle_t *coreotn_handle,
                                                    coreotn_mux_stage_t mux_stage,
                                                    UINT32 chnl_id,
                                                    UINT32 ho_chnl_id,
                                                    BOOL deprov_rfrm);

PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_one_deprov_helper(coreotn_handle_t *coreotn_handle,
                                                           coreotn_mux_stage_t mux_stage,
                                                           UINT32 chnl_id,
                                                           UINT32 ho_chnl_id,
                                                           odtu_dmx_handle_t *lo_dmx_handle_ptr,
                                                           odujat_handle_t *lo_odujat_handle_ptr,
                                                           oduksc_handle_t *lo_oduksc_handle_ptr,
                                                           odu_rfrm_handle_t *lo_rfrm_handle_ptr,
                                                           BOOL deprov_rfrm);

PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_two_deprov(coreotn_handle_t *coreotn_handle,
                                                    coreotn_mux_stage_t mux_stage,
                                                    UINT32 chnl_id,
                                                    UINT32 ho_chnl_id);

PRIVATE PMC_ERROR coreotn_int_prbs_chnl_retrieve(coreotn_handle_t           *coreotn_handle,
                                                 UINT32                      prbs_chnl,
                                                 coreotn_prbs_inst_t         prbs_inst, 
                                                 coreotn_int_prbs_chnl_t    *int_table_ptr);

PRIVATE PMC_ERROR coreotn_int_prbs_chnl_clear(coreotn_handle_t           *coreotn_handle,
                                              UINT32                      prbs_chnl,
                                              coreotn_prbs_inst_t         prbs_inst, 
                                              coreotn_int_prbs_chnl_t    *int_table_ptr);

PRIVATE PMC_ERROR coreotn_int_prbs_chnl_enabled_check(coreotn_handle_t           *coreotn_handle,
                                                      UINT32                      prbs_chnl,
                                                      coreotn_prbs_inst_t         prbs_inst, 
                                                      coreotn_int_prbs_chnl_t    *int_en_table_ptr,
                                                      BOOL                       *int_found_ptr);


PRIVATE odu_ohp_port_framer_t coreotn_odu_ohp_port_framer_get(coreotn_handle_t  *coreotn_handle,
                                                              coreotn_int_chnl_info_t    *chnl_info);

PRIVATE PMC_ERROR coreotn_oduksc_handle_get(coreotn_handle_t           *coreotn_handle,
                                            coreotn_int_chnl_info_t    *chnl_info,
                                            oduksc_handle_t           **oduksc_ho_handle,
                                            oduksc_handle_t           **oduksc_lo_handle);

PRIVATE PMC_ERROR coreotn_odujat_handle_get(coreotn_handle_t           *coreotn_handle,
                                            coreotn_int_chnl_info_t    *chnl_info,
                                            odujat_handle_t           **odujat_ho_handle,
                                            odujat_handle_t           **odujat_lo_handle);

PRIVATE PMC_ERROR coreotn_odtu_mux_handle_get(coreotn_handle_t           *coreotn_handle,
                                              coreotn_int_chnl_info_t    *chnl_info,
                                              odtu_mux_handle_t         **oduksc_ho_handle,
                                              odtu_mux_handle_t         **oduksc_lo_handle);

PRIVATE PMC_ERROR coreotn_int_params_get(coreotn_handle_t *coreotn_handle,
                                         BOOL8            *stg1_tfrm_en,
                                         BOOL8            *stg2_tfrm_en,
                                         BOOL8            *stg3a_tfrm_en,
                                         BOOL8            *stg3b_tfrm_en,
                                         BOOL8            *stgN_tfrm_en,
                                         BOOL8            *stg1_rfrm_en,
                                         BOOL8            *stg2_rfrm_en,
                                         BOOL8            *stg3a_rfrm_en,
                                         BOOL8            *stg3b_rfrm_en,
                                         BOOL8            *stgN_rfrm_en,
                                         BOOL8            *fo1_dmx_en,
                                         BOOL8            *fo2_dmx_en,
                                         BOOL8            *fo1_oduksc_en,
                                         BOOL8            *fo2_oduksc_en,
                                         BOOL8            *fo1_odujat_en,
                                         BOOL8            *fo2_odujat_en);

PRIVATE void coreotn_lo_chnl_get_tx(coreotn_handle_t *coreotn_handle,
                                         BOOL8  line_side,
                                         coreotn_chnl_order_t ho_odu_level,
                                         UINT32 ho_chnl_id,
                                         UINT32 *ch_ptr,
                                         UINT32 *num_ch);

PRIVATE PMC_ERROR coreotn_prbs_null_chan_en_get(coreotn_handle_t *coreotn_handle,
                                                coreotn_mux_stage_t mux_stage,
                                                UINT32 dci_chnl,
                                                BOOL *prbs_null_chan_en);

PRIVATE PMC_ERROR coreotn_prbs_null_chan_en_set(coreotn_handle_t *coreotn_handle,
                                                coreotn_mux_stage_t mux_stage,
                                                UINT32 dci_chnl,
                                                BOOL prbs_null_chan_en,
                                                UINT32 ho_chnl_id);

/*
** Public Functions
*/

/*
**  Exported Interface Functions - Start
*/

/*******************************************************************************
* coreotn_ctxt_create
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Creates and initializes a handle for a COREOTN subsystem instance.
*
*
* INPUTS:
*   *parent               - pointer to parent handle.  If no parent pass in
*                           NULL
*   base_address          - base address of the COREOTN subsystem relative to the
*                           device memory space
*   *sys_handle           - pointer to user system handle
*   *tsb_name             - unique string identifier of the block 
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   coreotn_handle_t      - pointer to created handle
*
* NOTES:
*
*******************************************************************************/
PUBLIC coreotn_handle_t *coreotn_ctxt_create(pmc_handle_t *parent, UINT32 base_address, pmc_sys_handle_t *sys_handle, const char *tsb_name )
{
    coreotn_handle_t *coreotn_handle;

    PMC_ENTRY();

    coreotn_handle = (coreotn_handle_t*)PMC_CTXT_CALLOC(sizeof(coreotn_handle_t), parent);

    pmc_handle_init( parent, coreotn_handle, sys_handle, PMC_MID_DIGI_COREOTN, tsb_name, base_address );

    /* Register log strings. */
    pmc_log_block_strings_register(COREOTN_LOG_ERR_STRINGS[0], COREOTN_LOG_ERR_TABLE_BASE, COREOTN_LOG_ERR_COUNT);

    PMC_LOG_TRACE("base addreess of COREOTN = 0x%x\n", base_address);
    /* ODU_RFRM */
    coreotn_handle->odu_rfrm_stg1_handle    = odu_rfrm_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODU_RFRM12_ODU_RFRM, sys_handle, "ODU_RFRM_STG1");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_rfrm_stg1_handle, parent);
    PMC_LOG_TRACE("base addreess of odu_rfrm_stg1 = 0x%x\n", base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODU_RFRM12_ODU_RFRM);
    coreotn_handle->odu_rfrm_stg2_handle    = odu_rfrm_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODU_RFRM96_ODU_RFRM, sys_handle, "ODU_RFRM_STG2");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_rfrm_stg2_handle, parent);
    PMC_LOG_TRACE("base addreess of odu_rfrm_stg2 = 0x%x\n", base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODU_RFRM96_ODU_RFRM);
    coreotn_handle->odu_rfrm_stgN_handle    = odu_rfrm_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODU_RFRM12_ODU_RFRM+COREOTN_FMF_OFFSET, sys_handle, "ODU_RFRM_STGN");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_rfrm_stgN_handle, parent);
    PMC_LOG_TRACE("base addreess of odu_rfrm_stgN = 0x%x\n", base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODU_RFRM12_ODU_RFRM+COREOTN_FMF_OFFSET);
    coreotn_handle->odu_rfrm_stg3a_handle   = odu_rfrm_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODU_RFRM96_ODU_RFRM+COREOTN_FMF_OFFSET, sys_handle, "ODU_RFRM_STG3A");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_rfrm_stg3a_handle, parent);
    PMC_LOG_TRACE("base addreess of odu_rfrm_stg3a = 0x%x\n", base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODU_RFRM96_ODU_RFRM+COREOTN_FMF_OFFSET);
    coreotn_handle->odu_rfrm_stg3b_handle   = odu_rfrm_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FO1_COREOTN_FO_ODU_RFRM, sys_handle, "ODU_RFRM_STG3B");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_rfrm_stg3b_handle, parent);
    PMC_LOG_TRACE("base addreess of odu_rfrm_stg3b = 0x%x\n", base_address+BASE_ADDR_COREOTN120_COREOTN_FO1_COREOTN_FO_ODU_RFRM);
    coreotn_handle->odu_rfrm_stg4_handle    = odu_rfrm_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FO1_COREOTN_FO_ODU_RFRM+COREOTN_FO_OFFSET, sys_handle, "ODU_RFRM_STG4");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_rfrm_stg4_handle, parent);
    PMC_LOG_TRACE("base addreess of odu_rfrm_stg4 = 0x%x\n", base_address+BASE_ADDR_COREOTN120_COREOTN_FO1_COREOTN_FO_ODU_RFRM+COREOTN_FO_OFFSET);

    /* ODU_TFRM */
    coreotn_handle->odu_tfrm_stg1_handle    = odu_tfrm_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODU_TFRM12_ODU_TFRM, sys_handle, "ODU_TFRM_STG1");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_tfrm_stg1_handle, parent);
    coreotn_handle->odu_tfrm_stg2_handle    = odu_tfrm_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODU_TFRM96_ODU_TFRM, sys_handle, "ODU_TFRM_STG2");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_tfrm_stg2_handle, parent);
    coreotn_handle->odu_tfrm_stgN_handle    = odu_tfrm_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODU_TFRM12_ODU_TFRM+COREOTN_FMF_OFFSET, sys_handle, "ODU_TFRM_STGN");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_tfrm_stgN_handle, parent);
    coreotn_handle->odu_tfrm_stg3a_handle   = odu_tfrm_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODU_TFRM96_ODU_TFRM+COREOTN_FMF_OFFSET, sys_handle, "ODU_TFRM_STG3A");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_tfrm_stg3a_handle, parent);
    coreotn_handle->odu_tfrm_stg3b_handle   = odu_tfrm_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FO1_COREOTN_FO_ODU_TFRM, sys_handle, "ODU_TFRM_STG3B");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_tfrm_stg3b_handle, parent);
    coreotn_handle->odu_tfrm_stg4_handle    = odu_tfrm_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FO1_COREOTN_FO_ODU_TFRM+COREOTN_FO_OFFSET, sys_handle, "ODU_TFRM_STG4");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_tfrm_stg4_handle, parent);

    /* ODTU_DMX */
    coreotn_handle->odtu_dmx1_handle = odtu_dmx_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODTU_DMX, sys_handle, "ODTU_DMX1");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odtu_dmx1_handle, parent);
    coreotn_handle->odtu_dmx2_handle = odtu_dmx_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODTU_DMX+COREOTN_FMF_OFFSET, sys_handle, "ODTU_DMX2");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odtu_dmx2_handle, parent);

    /* ODTU_MUX */
    coreotn_handle->odtu_mux1_handle = odtu_mux_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODTU_MUX_MUX_ODTU_MUX, sys_handle, "ODTU_MUX1");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odtu_mux1_handle, parent);
    coreotn_handle->odtu_mux2_handle = odtu_mux_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODTU_MUX_MUX_ODTU_MUX+COREOTN_FMF_OFFSET, sys_handle, "ODTU_MUX2");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odtu_mux2_handle, parent);

    /* ODUKSC */
    coreotn_handle->oduksc1_handle = oduksc_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODUKSC2_ODUKSC_MTSB, sys_handle, "ODUKSC1");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->oduksc1_handle, parent);
    coreotn_handle->oduksc2_handle = oduksc_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODUKSC2_ODUKSC_MTSB+COREOTN_FMF_OFFSET, sys_handle, "ODUKSC2");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->oduksc2_handle, parent);

    /* ODUJAT */
    coreotn_handle->odujat1_handle = odujat_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODUJAT_MTSB, sys_handle, "ODUJAT1");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odujat1_handle, parent);
    coreotn_handle->odujat2_handle = odujat_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FMF1_COREOTN_FMF_ODUJAT_MTSB+COREOTN_FMF_OFFSET, sys_handle, "ODUJAT2");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odujat2_handle, parent);

    /* MPMO */
    coreotn_handle->mpmo_fo1_handle     = mpmo_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FO1_COREOTN_FO_MPMO_MTSB, sys_handle, "MPMO1");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->mpmo_fo1_handle, parent);
    coreotn_handle->mpmo_fo2_handle     = mpmo_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FO1_COREOTN_FO_MPMO_MTSB+COREOTN_FO_OFFSET, sys_handle, "MPMO2");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->mpmo_fo2_handle, parent);
    coreotn_handle->mpmo_core_ctl_handle = mpmo_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_CTL_MPMO_MTSB, sys_handle, "MPMO_CORETOP");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->mpmo_core_ctl_handle, parent);

    /* MPMA */
    coreotn_handle->mpma_fo1_handle     = mpma_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FO1_COREOTN_FO_MPMA_MTSB, sys_handle, "MPMA1");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->mpma_fo1_handle, parent);
    coreotn_handle->mpma_fo2_handle     = mpma_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_FO1_COREOTN_FO_MPMA_MTSB+COREOTN_FO_OFFSET, sys_handle, "MPMA2");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->mpma_fo2_handle, parent);
    coreotn_handle->mpma_core_ctl_handle = mpma_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+BASE_ADDR_COREOTN120_COREOTN_CTL_MPMA_MTSB, sys_handle, "MPMA_CORETOP");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->mpma_core_ctl_handle, parent);

    /* ODUK_SW */
    coreotn_handle->oduksw_handle = cpb_ctxt_create((pmc_handle_t *)coreotn_handle, base_address+0x300000, sys_handle, "ODUKSW");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->oduksw_handle, parent);

    /* ODU RCP */
    coreotn_handle->odu_rcp_handle = odu_rcp_ctxt_create((pmc_handle_t *)coreotn_handle, base_address + BASE_ADDR_COREOTN120_ODU_RCP_MTSB, sys_handle, "ODU_RCP");
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_rcp_handle, parent);

    /* ODU OHP */
    coreotn_handle->odu_ohp_handle[COREOTN_ODU_OHP_1] = odu_ohp_ctxt_create((pmc_handle_t *)coreotn_handle, 
                                                                            base_address + BASE_ADDR_COREOTN120_COREOTN_CTL_OHP1_OHP_12CH_MTSB, sys_handle, "ODU_OHP_1", ODU_OHP_1);
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_ohp_handle[COREOTN_ODU_OHP_1], parent);

    coreotn_handle->odu_ohp_handle[COREOTN_ODU_OHP_2] = odu_ohp_ctxt_create((pmc_handle_t *)coreotn_handle, 
                                                                            base_address + BASE_ADDR_COREOTN120_COREOTN_CTL_OHP2_OHP_96CH_MTSB, sys_handle, "ODU_OHP_2", ODU_OHP_2);
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_ohp_handle[COREOTN_ODU_OHP_2], parent);

    coreotn_handle->odu_ohp_handle[COREOTN_ODU_OHP_3] = odu_ohp_ctxt_create((pmc_handle_t *)coreotn_handle, 
                                                                            base_address + BASE_ADDR_COREOTN120_COREOTN_CTL_OHP3_OHP_96CH_MTSB, sys_handle, "ODU_OHP_3", ODU_OHP_3);
    PMC_CTXT_REGISTER_PTR(&coreotn_handle->odu_ohp_handle[COREOTN_ODU_OHP_3], parent);
    
    
    PMC_RETURN(coreotn_handle);

} /* coreotn_ctxt_create */


/*******************************************************************************
* coreotn_ctxt_destroy
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Destroys a handle for a COREOTN subsystem instance.
*
*
* INPUTS:
*   *coreotn_handle      - pointer to COREOTN handle instance to be operated on
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_ctxt_destroy(coreotn_handle_t *coreotn_handle)
{
    UINT32 i;

    PMC_ENTRY();

    PMC_LOG_TRACE("coreotn_handle->cfg.db_id = %u\n", coreotn_handle->cfg.rx_db_id);
    PMC_LOG_TRACE("coreotn_handle->db_handle = %u\n", coreotn_handle->cfg.rx_db_handle);
    PMC_LOG_TRACE("coreotn_handle->cfg.db_id = %u\n", coreotn_handle->cfg.tx_db_id);
    PMC_LOG_TRACE("coreotn_handle->db_handle = %u\n", coreotn_handle->cfg.tx_db_handle);

    if (coreotn_handle->cfg.rx_db_id > 0)
    {
        gen_db_detach(&(coreotn_handle->base),
                      coreotn_handle->cfg.rx_db_id,
                      coreotn_handle->cfg.rx_db_handle);
    }
    if (coreotn_handle->cfg.tx_db_id > 0)
    {
        gen_db_detach(&(coreotn_handle->base),
                      coreotn_handle->cfg.tx_db_id,
                      coreotn_handle->cfg.tx_db_handle);
    }
    if (coreotn_handle->cfg.rx_mapotn_db_id > 0)
    {
        gen_db_detach(&(coreotn_handle->base),
                      coreotn_handle->cfg.rx_mapotn_db_id,
                      coreotn_handle->cfg.rx_mapotn_db_handle);
    }
    if (coreotn_handle->cfg.tx_mapotn_db_id > 0)
    {
        gen_db_detach(&(coreotn_handle->base),
                      coreotn_handle->cfg.tx_mapotn_db_id,
                      coreotn_handle->cfg.tx_mapotn_db_handle);
    }
    if (coreotn_handle->cfg.lineotn_sysotn_card_db_id > 0)
    {
        gen_db_detach(&(coreotn_handle->base), 
                      coreotn_handle->cfg.lineotn_sysotn_card_db_id,
                      coreotn_handle->cfg.lineotn_sysotn_card_db_handle);
    }

    /* ODU_RFRM */
    odu_rfrm_ctxt_destroy(coreotn_handle->odu_rfrm_stg1_handle);
    odu_rfrm_ctxt_destroy(coreotn_handle->odu_rfrm_stg2_handle);
    odu_rfrm_ctxt_destroy(coreotn_handle->odu_rfrm_stgN_handle);
    odu_rfrm_ctxt_destroy(coreotn_handle->odu_rfrm_stg3a_handle);
    odu_rfrm_ctxt_destroy(coreotn_handle->odu_rfrm_stg3b_handle);
    odu_rfrm_ctxt_destroy(coreotn_handle->odu_rfrm_stg4_handle);

    /* ODU_TFRM */
    odu_tfrm_ctxt_destroy(coreotn_handle->odu_tfrm_stg1_handle);
    odu_tfrm_ctxt_destroy(coreotn_handle->odu_tfrm_stg2_handle);
    odu_tfrm_ctxt_destroy(coreotn_handle->odu_tfrm_stgN_handle);
    odu_tfrm_ctxt_destroy(coreotn_handle->odu_tfrm_stg3a_handle);
    odu_tfrm_ctxt_destroy(coreotn_handle->odu_tfrm_stg3b_handle);
    odu_tfrm_ctxt_destroy(coreotn_handle->odu_tfrm_stg4_handle);

    /* ODTU_DMX */
    odtu_dmx_ctxt_destroy(coreotn_handle->odtu_dmx1_handle);
    odtu_dmx_ctxt_destroy(coreotn_handle->odtu_dmx2_handle);

    /* ODTU_MUX */
    odtu_mux_ctxt_destroy(coreotn_handle->odtu_mux1_handle);
    odtu_mux_ctxt_destroy(coreotn_handle->odtu_mux2_handle);

    /* MPMO */
    mpmo_ctxt_destroy(coreotn_handle->mpmo_fo1_handle);
    mpmo_ctxt_destroy(coreotn_handle->mpmo_fo2_handle);
    mpmo_ctxt_destroy(coreotn_handle->mpmo_core_ctl_handle);

    /* MPMA */
    mpma_ctxt_destroy(coreotn_handle->mpma_fo1_handle);
    mpma_ctxt_destroy(coreotn_handle->mpma_fo2_handle);
    mpma_ctxt_destroy(coreotn_handle->mpma_core_ctl_handle);


    /* ODUKSC */
    oduksc_ctxt_destroy(coreotn_handle->oduksc1_handle);
    oduksc_ctxt_destroy(coreotn_handle->oduksc2_handle);

    /* ODUJAT */
    odujat_ctxt_destroy(coreotn_handle->odujat1_handle);
    odujat_ctxt_destroy(coreotn_handle->odujat2_handle);

    /* ODUK_SW */
    cpb_ctxt_destroy(coreotn_handle->oduksw_handle);


    /* ODU RCP */
    odu_rcp_ctxt_destroy(coreotn_handle->odu_rcp_handle);

    
    /* ODU OHP */
    for (i = 0; i < COREOTN_NUM_ODU_OHP_MAX; i++)
    {
        odu_ohp_ctxt_destroy(coreotn_handle->odu_ohp_handle[i]);
    }
    
    PMC_CTXT_FREE(&coreotn_handle, coreotn_handle);
    
    PMC_RETURN();

} /* coreotn_ctxt_destroy */

/*******************************************************************************
* coreotn_handle_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Initializes a COREOTN subsystem handle instance.
*
*
* INPUTS:
*   *coreotn_handle      - pointer to COREOTN handle instance to be operated on
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_handle_init(coreotn_handle_t *coreotn_handle)
{
    /* Variable declaration */
    void *p_var_t_ram_data = NULL;
    UINT32 i, j;
    UINT32 *null_chan_en = NULL;
    UINT32 *prbs_null_chan_en = NULL;

    cpb_schd_populate_t schdpopulate_mode[4] = {CPB_SCHD_POPULATE_DB,
                                                CPB_SCHD_POPULATE_DB,
                                                CPB_SCHD_POPULATE_DB,
                                                CPB_SCHD_POPULATE_DB};
    PMC_ENTRY();
     
    for (i = 0; i < COREOTN_ODUKSW_NUM_OF_DCS; i++)
    {
        coreotn_handle->cfg.schdpopulate_mode[i] = schdpopulate_mode[i];
    }
  
    p_var_t_ram_data = NULL;

    /* Update static configurations */
    coreotn_handle->cfg.num_coreotn_chnl      = COREOTN_NUM_CHNL;

    /* initialize parent_energy_state */
    coreotn_handle->var.coreotn_start_state = TRUE;

    /* Initialize var_t parameters */
    coreotn_var_default_init(coreotn_handle,&coreotn_handle->var);

    coreotn_handle->cfg.rx_db_id = UTIL_GEN_DB_LINE_CORE_OTN_RX_DB;
    coreotn_handle->cfg.tx_db_id = UTIL_GEN_DB_LINE_CORE_OTN_TX_DB;
    coreotn_handle->cfg.rx_mapotn_db_id = UTIL_GEN_DB_MPMA_DB;
    coreotn_handle->cfg.tx_mapotn_db_id = UTIL_GEN_DB_ODUKSC_DB;
    coreotn_handle->cfg.lineotn_sysotn_card_db_id = UTIL_GEN_DB_LINEOTN_SYSOTN_MODE;

    coreotn_handle->cfg.rx_db_handle = gen_db_attach(&(coreotn_handle->base), coreotn_handle->cfg.rx_db_id);
    coreotn_handle->cfg.tx_db_handle = gen_db_attach(&(coreotn_handle->base), coreotn_handle->cfg.tx_db_id);
    coreotn_handle->cfg.rx_mapotn_db_handle = gen_db_attach(&(coreotn_handle->base), coreotn_handle->cfg.rx_mapotn_db_id);
    coreotn_handle->cfg.tx_mapotn_db_handle = gen_db_attach(&(coreotn_handle->base), coreotn_handle->cfg.tx_mapotn_db_id);
    coreotn_handle->cfg.lineotn_sysotn_card_db_handle = gen_db_attach(&(coreotn_handle->base), coreotn_handle->cfg.lineotn_sysotn_card_db_id);

    /* Initialize ODU_RFRM */
    odu_rfrm_handle_init(coreotn_handle->odu_rfrm_stg1_handle, (odu_rfrm_inst_t)COREOTN_ODU_RFRM_STG1);
    odu_rfrm_handle_init(coreotn_handle->odu_rfrm_stg2_handle, (odu_rfrm_inst_t)COREOTN_ODU_RFRM_STG2);
    odu_rfrm_handle_init(coreotn_handle->odu_rfrm_stgN_handle, (odu_rfrm_inst_t)COREOTN_ODU_RFRM_STGN);
    odu_rfrm_handle_init(coreotn_handle->odu_rfrm_stg3a_handle, (odu_rfrm_inst_t)COREOTN_ODU_RFRM_STG3A);
    odu_rfrm_handle_init(coreotn_handle->odu_rfrm_stg3b_handle, (odu_rfrm_inst_t)COREOTN_ODU_RFRM_STG3B);
    odu_rfrm_handle_init(coreotn_handle->odu_rfrm_stg4_handle, (odu_rfrm_inst_t)COREOTN_ODU_RFRM_STG4);
    PMC_LOG_TRACE("ODU_RFRM handles initialized\n");

    /* Initialize ODU_TFRM */
    odu_tfrm_handle_init(coreotn_handle->odu_tfrm_stg1_handle, (odu_tfrm_inst_t)COREOTN_ODU_TFRM_STG1);
    odu_tfrm_handle_init(coreotn_handle->odu_tfrm_stg2_handle, (odu_tfrm_inst_t)COREOTN_ODU_TFRM_STG2);
    odu_tfrm_handle_init(coreotn_handle->odu_tfrm_stgN_handle, (odu_tfrm_inst_t)COREOTN_ODU_TFRM_STGN);
    odu_tfrm_handle_init(coreotn_handle->odu_tfrm_stg3a_handle, (odu_tfrm_inst_t)COREOTN_ODU_TFRM_STG3A);
    odu_tfrm_handle_init(coreotn_handle->odu_tfrm_stg3b_handle, (odu_tfrm_inst_t)COREOTN_ODU_TFRM_STG3B);
    odu_tfrm_handle_init(coreotn_handle->odu_tfrm_stg4_handle, (odu_tfrm_inst_t)COREOTN_ODU_TFRM_STG4);
    PMC_LOG_TRACE("ODU_TFRM handles initialized\n");

    /* Initialize ODTU_DMX */
    odtu_dmx_handle_init(coreotn_handle->odtu_dmx1_handle);
    odtu_dmx_handle_init(coreotn_handle->odtu_dmx2_handle);
    PMC_LOG_TRACE("ODTU_DMX handles initialized\n");

    /* Initialize ODTU_MUX */
    odtu_mux_handle_init(coreotn_handle->odtu_mux1_handle);
    odtu_mux_handle_init(coreotn_handle->odtu_mux2_handle);
    PMC_LOG_TRACE("ODTU_MUX handles initialized\n");
    
    /* Initialize MPMA */
    mpma_handle_init(coreotn_handle->mpma_fo1_handle, MPMA_COREOTN, 0);
    mpma_handle_init(coreotn_handle->mpma_fo2_handle, MPMA_COREOTN_FROM_MAPOTN, 0);
    mpma_handle_init(coreotn_handle->mpma_core_ctl_handle, MPMA_COREOTN_CTL, 0);
    
    PMC_LOG_TRACE("MPMA handles initialized\n");

    /* Initialize MPMO */
    mpmo_handle_init(coreotn_handle->mpmo_fo1_handle, MPMO_COREOTN_MUX_FRAMER, 0);
    mpmo_handle_init(coreotn_handle->mpmo_fo2_handle, MPMO_COREOTN_TO_MAPOTN, 0);
    mpmo_handle_init(coreotn_handle->mpmo_core_ctl_handle, MPMO_COREOTN_CTL, 0);
    PMC_LOG_TRACE("MPMO handles initialized\n");

    /* Initialize ODUKSC */
    oduksc_handle_init(coreotn_handle->oduksc1_handle, ODUKSC_COREOTN_ODUKSC1, COREOTN_ODUKSC_USERBITS_DEL);
    oduksc_handle_init(coreotn_handle->oduksc2_handle, ODUKSC_COREOTN_ODUKSC2, COREOTN_ODUKSC_USERBITS_DEL);

    PMC_LOG_TRACE("coreotn_handle->oduksc1_handle->cfg.cal_entries_alloc_method = %u\n", coreotn_handle->oduksc1_handle->cfg.cal_entries_alloc_method);

    /* needs to move out of handle_init */
    PMC_LOG_TRACE("ODUKSC initialized\n");

    /* Initialize ODUJAT */
    odujat_handle_init(coreotn_handle->odujat1_handle, (odujat_type_id_t)COREOTN_ODUJAT1);
    odujat_handle_init(coreotn_handle->odujat2_handle, (odujat_type_id_t)COREOTN_ODUJAT2);
    
    /* OHFS_REMOVE */

    /* Initialize ODUKSW */
    cpb_handle_init(coreotn_handle->oduksw_handle, CPB_INSTANCE_OCPB,
                    schdpopulate_mode, (pmc_block_energy_state_enum)1,
                    p_var_t_ram_data, 0);
    PMC_LOG_TRACE("OCPB handle created...\n");

    /* Initialize ODU_RCP */
    odu_rcp_handle_init(coreotn_handle->odu_rcp_handle);
    PMC_LOG_TRACE("ODU_RCP initialized\n");

    /* Initialize ODU OHP */
    for (i = 0; i < COREOTN_NUM_ODU_OHP_MAX; i++)
    {
        odu_ohp_handle_init(coreotn_handle->odu_ohp_handle[i], coreotn_handle->cfg.rx_db_handle);
    }
    PMC_LOG_TRACE("ODUKSW handles initialized\n");

    /* Initialize TCM PID Valid Bit array */
    for (i = 0; i < LAST_ODU_STRUCT_LEVEL; i++)
    {
        pmc_bitarray_zero(coreotn_handle->var.tcm_pid_valid[i], COREOTN_TCM_PID_VALID_BITARRAY_SIZE);
    }


    /* Initialize PRBS chnl array */
    for (i = 0; i < LAST_COREOTN_PRBS_INST; i++)
    {
        for (j = 0; j < COREOTN_PRBS_NUM_CHNL; j++)
        {
            COREOTN_PRBS_MON_ENABLE(coreotn_handle, i, j, 0, 0);
        }
    }
   
    for(i=0;i<COREOTN_MAX_NUM_LO_CHNL;i++)
    {
        coreotn_handle->var.prev_fo1_rfrm_maint_sig[i] = 0;
        coreotn_handle->var.dummy_fo1_maint_sig[i] = FALSE;

        coreotn_handle->var.dcs_to_mapotn_pinch_entry[i] = FALSE;
    }

    for(i=0;i<COREOTN_MAX_NUM_HO_CHNL;i++)
    {
        coreotn_handle->var.prev_fmf1_sysotn_rfrm_maint_sig[i] = 0;
        coreotn_handle->var.dummy_fmf1_sysotn_maint_sig[i] = FALSE;
    }


    for(i=0;i<COREOTN_MAX_NUM_LO_CHNL;i++)
    {
        (void) coreotn_prbs_null_chan_en_set(coreotn_handle,
                                             COREOTN_MUX_STAGE_ONE,
                                             i,
                                             FALSE,
                                             i);
    }
                                         
    for(i=0;i<COREOTN_MAX_NUM_LO_CHNL;i++)
    {
        (void) coreotn_prbs_null_chan_en_set(coreotn_handle,
                                             COREOTN_MUX_STAGE_TWO,
                                             i,
                                             FALSE,
                                             i);
    }

    
    coreotn_mapotn_null_frame_mode_ptr_get(coreotn_handle,
                                           &null_chan_en,
                                           &prbs_null_chan_en);
    for(i=0;i<3;i++)
    {
        null_chan_en[i] = 0;
        prbs_null_chan_en[i] = 0;
    }


    
    PMC_RETURN();

} /* coreotn_handle_init */

/*******************************************************************************
* coreotn_alloc_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Allocates local memory freed in ctxt_destroy
*
* INPUTS:
*   *coreotn_handle             - pointer to coreotn handle instance
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None
*
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_alloc_init(coreotn_handle_t *coreotn_handle)
{
    UINT32 i;

    PMC_ENTRY();

    cpb_alloc_init(coreotn_handle->oduksw_handle);
    mpma_alloc_init(coreotn_handle->mpma_fo1_handle);
    mpma_alloc_init(coreotn_handle->mpma_fo2_handle);
    mpma_alloc_init(coreotn_handle->mpma_core_ctl_handle);
    mpmo_alloc_init(coreotn_handle->mpmo_fo1_handle);
    mpmo_alloc_init(coreotn_handle->mpmo_fo2_handle);
    mpmo_alloc_init(coreotn_handle->mpmo_core_ctl_handle);
    oduksc_alloc_init(coreotn_handle->oduksc1_handle);
    oduksc_alloc_init(coreotn_handle->oduksc2_handle);
    odu_rcp_alloc_init(coreotn_handle->odu_rcp_handle);

    for (i = 0; i < COREOTN_NUM_ODU_OHP_MAX; i++)
    {
        odu_ohp_alloc_init(coreotn_handle->odu_ohp_handle[i]);
    }
    odujat_alloc_init(coreotn_handle->odujat1_handle);
    odujat_alloc_init(coreotn_handle->odujat2_handle);

    PMC_RETURN();
} /* coreotn_alloc_init */


/*******************************************************************************
* coreotn_handle_restart_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Performs warm or crash restart processing on mapton ss handle instance.
*
* INPUTS:
*   *coreotn_handle             - pointer to coreotn handle instance
*   *restart_init_cfg_ptr       - pointer to restart init config
*   top_energy_state_reg        - The expected energy state 
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS : 
*     WARM : register/context are coherent
*     CRASH: everything is coherent (a cleanup may has been executed)
*   COREOTN_ERR_CONTEXT_COMMUN_RES_ENERGY_INCOHERENT:
*     incoherences have been detected on communal energy configuration
*     that is incoherent with top energy state
*      WARM : ERROR
*      CRASH: TOP shall put COREOTN in RESET mode
*   
subsystem shall be put in reset mode 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_handle_restart_init(coreotn_handle_t *coreotn_handle,
                                             util_global_restart_init_cfg_t *restart_init_cfg_ptr, 
                                             pmc_energy_state_t top_energy_state_reg)
{
    coreotn_recover_var_t  *coreotn_var_reg   = NULL;
    coreotn_var_t          *coreotn_var_clean = NULL;
    BOOL8  mismatch_channels;
    UINT32 i;
    
    PMC_ERROR rc = PMC_SUCCESS;
    
    PMC_ENTRY();

    if (restart_init_cfg_ptr->phase == UTIL_GLOBAL_RESTART_INIT_PHASE_FIRST)
    {
        pmc_log_block_strings_register(COREOTN_LOG_ERR_STRINGS[0], COREOTN_LOG_ERR_TABLE_BASE, COREOTN_LOG_ERR_COUNT);
    }

    /* 
       restart OCPB, this part is fully handled by the CPB driver 
    */
    if (PMC_SUCCESS == rc)
    {
        rc = cpb_handle_restart_init(coreotn_handle->oduksw_handle, restart_init_cfg_ptr, top_energy_state_reg);
    }
   
    /* Reinitialize ODU_RFRM */
    if (PMC_SUCCESS == rc)
    {
        odu_rfrm_handle_restart_init(coreotn_handle->odu_rfrm_stg1_handle, restart_init_cfg_ptr, top_energy_state_reg);
    }

    if (PMC_SUCCESS == rc)
    {
        odu_rfrm_handle_restart_init(coreotn_handle->odu_rfrm_stg2_handle, restart_init_cfg_ptr, top_energy_state_reg);
    }

    if (PMC_SUCCESS == rc)
    {
        odu_rfrm_handle_restart_init(coreotn_handle->odu_rfrm_stgN_handle, restart_init_cfg_ptr, top_energy_state_reg);
    }

    if (PMC_SUCCESS == rc)
    {
        odu_rfrm_handle_restart_init(coreotn_handle->odu_rfrm_stg3a_handle, restart_init_cfg_ptr, top_energy_state_reg);
    }

    if (PMC_SUCCESS == rc)
    {
        odu_rfrm_handle_restart_init(coreotn_handle->odu_rfrm_stg3b_handle, restart_init_cfg_ptr, top_energy_state_reg);
    }

    if (PMC_SUCCESS == rc)
    {
        odu_rfrm_handle_restart_init(coreotn_handle->odu_rfrm_stg4_handle, restart_init_cfg_ptr, top_energy_state_reg);
    }


    /* Reinitialize ODU_TFRM */
    if (PMC_SUCCESS == rc)
    {
        odu_tfrm_handle_restart_init(coreotn_handle->odu_tfrm_stg1_handle, restart_init_cfg_ptr, top_energy_state_reg);
    }

    if (PMC_SUCCESS == rc)
    {
        odu_tfrm_handle_restart_init(coreotn_handle->odu_tfrm_stg2_handle, restart_init_cfg_ptr, top_energy_state_reg);
    }

    if (PMC_SUCCESS == rc)
    {
        odu_tfrm_handle_restart_init(coreotn_handle->odu_tfrm_stgN_handle, restart_init_cfg_ptr, top_energy_state_reg);
    }

    if (PMC_SUCCESS == rc)
    {
        odu_tfrm_handle_restart_init(coreotn_handle->odu_tfrm_stg3a_handle, restart_init_cfg_ptr, top_energy_state_reg);
    }

    if (PMC_SUCCESS == rc)
    {
        odu_tfrm_handle_restart_init(coreotn_handle->odu_tfrm_stg3b_handle, restart_init_cfg_ptr, top_energy_state_reg);
    }

    if (PMC_SUCCESS == rc)
    {
        odu_tfrm_handle_restart_init(coreotn_handle->odu_tfrm_stg4_handle, restart_init_cfg_ptr, top_energy_state_reg);
    }

    /* Reinitialize MPMA */
    if (PMC_SUCCESS == rc)
    {
        rc = mpma_handle_restart_init(coreotn_handle->mpma_fo1_handle, restart_init_cfg_ptr, top_energy_state_reg, TRUE, &mismatch_channels);
    }
    if (PMC_SUCCESS == rc)
    {
        rc = mpma_handle_restart_init(coreotn_handle->mpma_fo2_handle, restart_init_cfg_ptr, top_energy_state_reg, TRUE, &mismatch_channels);
    }
    if (PMC_SUCCESS == rc)
    {
        rc = mpma_handle_restart_init(coreotn_handle->mpma_core_ctl_handle, restart_init_cfg_ptr, top_energy_state_reg, TRUE, &mismatch_channels);
    }

    /* Reinitialize MPMO */
    if (PMC_SUCCESS == rc)
    {
        rc = mpmo_handle_restart_init(coreotn_handle->mpmo_fo1_handle, restart_init_cfg_ptr, top_energy_state_reg, TRUE, &mismatch_channels);
    }
    if (PMC_SUCCESS == rc)
    {
        rc = mpmo_handle_restart_init(coreotn_handle->mpmo_fo2_handle, restart_init_cfg_ptr, top_energy_state_reg, TRUE, &mismatch_channels);
    }
    if (PMC_SUCCESS == rc)
    {
        rc = mpmo_handle_restart_init(coreotn_handle->mpmo_core_ctl_handle, restart_init_cfg_ptr, top_energy_state_reg, TRUE, &mismatch_channels);
    }
    /* Reinitialize ODUKSC */
    if (PMC_SUCCESS == rc)
    {
        rc = oduksc_handle_restart_init(coreotn_handle->oduksc1_handle, restart_init_cfg_ptr);
    }
    if (PMC_SUCCESS == rc)
    {
        rc = oduksc_handle_restart_init(coreotn_handle->oduksc2_handle, restart_init_cfg_ptr);
    }
    if (PMC_SUCCESS == rc)
    {
        /* 
           restart ODU_RCP
        */
        odu_rcp_handle_restart_init(coreotn_handle->odu_rcp_handle, restart_init_cfg_ptr, top_energy_state_reg);
        /* reinitialize ODU OHP */
        for (i = 0; i < COREOTN_NUM_ODU_OHP_MAX; i++)
        {
            odu_ohp_handle_restart_init(coreotn_handle->odu_ohp_handle[i], coreotn_handle->cfg.rx_db_handle, restart_init_cfg_ptr, top_energy_state_reg);
        }
        /* Reinitialize ODUJAT */
        odujat_handle_restart_init(coreotn_handle->odujat1_handle, restart_init_cfg_ptr, top_energy_state_reg);
        odujat_handle_restart_init(coreotn_handle->odujat2_handle, restart_init_cfg_ptr, top_energy_state_reg);

        coreotn_var_reg = (coreotn_recover_var_t*) PMC_CALLOC(sizeof(coreotn_recover_var_t));
          
        /* 
           Recover context from register space        
           - var context is partially recovered from register space (good enough to have a valid audit)
           - only OPERATIONAL channel configruation are recovered
           - anyway a partial channel config is an error in warm restart and will be cleanup in crash-restarted
           - detailed energy states are recovered
           - incoherency in register context means that the subsystem shall be shutdown
        */
        if (PMC_SUCCESS == rc)
        {
            rc = coreotn_ctxt_reg_recover(coreotn_handle,                                      
                                          top_energy_state_reg,
                                          restart_init_cfg_ptr,
                                          coreotn_var_reg);
        }
        if (PMC_SUCCESS == rc)
        {
            coreotn_var_clean = (coreotn_var_t*) PMC_CALLOC(sizeof(coreotn_var_t));
            
            /* 
             * Audit register context and memory context 
             *   - Audit power and decide if we should just shut down the subsystem 
             *   - Create a new context that represents the intersection between memory and register space (coreotn_var_clean)
             */
            rc = coreotn_ctxt_audit(coreotn_handle, 
                                    restart_init_cfg_ptr,
                                    coreotn_var_reg,
                                    coreotn_var_clean); 

            if (restart_init_cfg_ptr->is_warm_restart == FALSE)
            {
                /* 
                 * Cleanup 
                 *   - At the end, coreotn_var_clean is the new context
                 *    - We keep OPERATIONAL channel defined in coreotn_var_clean
                 *    - We clean (deactivate/deprov) all channels that are not OPERATIONAL
                 *       - they may have be partially provisionned
                 *    - We ajust power setting based on coreotn_var_clean
                 */            
                rc = coreotn_ctxt_cleanup(coreotn_handle, 
                                          restart_init_cfg_ptr,
                                          coreotn_var_reg,
                                          coreotn_var_clean); 

                
            }
            PMC_FREE(&coreotn_var_clean);
        }
        
        PMC_FREE(&coreotn_var_reg);
    }

    if (PMC_SUCCESS == rc)
    {
        UINT32 enable;
        UINT32 dci_chnl;
        /*
         * Retrieve the PRBS GEN EN setting and set that value in the 
         * internal context used in coreotn_prbs_null_chan_en_set
         * The context setting is not compared for coherency. The SW value
         * is updated based on the PRBS register value.
         * MEMESET the ho_chnl_cfg used to ensure that there are no
         * artifacts being left behind.  As a result only the enable values
         * need to be set for the various PRBS instances.
         */
        for (i = COREOTN_PRBS_EXTRA_CTXT_START; 
             i < COREOTN_PRBS_EXTRA_CTXT_END; i++)
        {
            PMC_MEMSET(&coreotn_handle->odtu_mux1_handle->var.ho_chnl_cfg[i], 0, sizeof(util_global_odu_ho_chnl_cfg_t));
        }

        for(i=0; i < COREOTN_PRBS_NUM_CHNL;i++)
        {
            if (coreotn_handle->var.init_operation  == COREOTN_SS_SYSOTN_MODE ||
                coreotn_handle->var.init_operation  == COREOTN_SS_SYSOTN_BYPASS_MODE)
            {
                enable = coreotn_fmf_field_PRBS_MON_EN_get(NULL, 
                                                           coreotn_handle,
                                                           COREOTN_FMF2_PRBS, i);
                
                if (enable != 0)
                {
                    dci_chnl = coreotn_fmf_field_PRBS_CHID_get(NULL, coreotn_handle, COREOTN_FMF2_PRBS, i);
                    (void)coreotn_prbs_null_chan_en_set(coreotn_handle,
                                                        COREOTN_MUX_STAGE_ONE,
                                                        dci_chnl,
                                                        TRUE,
                                                        i);
                }
            }
            else
            {
                enable = coreotn_fmf_field_PRBS_MON_EN_get(NULL, 
                                                           coreotn_handle,
                                                           COREOTN_FMF1_PRBS, i);

                if (enable != 0)
                {
                    dci_chnl = coreotn_fmf_field_PRBS_CHID_get(NULL, 
                                                               coreotn_handle, COREOTN_FMF1_PRBS, i);
                    (void)coreotn_prbs_null_chan_en_set(coreotn_handle,
                                                        COREOTN_MUX_STAGE_ONE,
                                                        dci_chnl,
                                                        TRUE,
                                                        i);
                }
                enable = coreotn_fmf_field_PRBS_MON_EN_get(NULL, 
                                                           coreotn_handle,
                                                           COREOTN_FMF2_PRBS, i);

                if (enable != 0)
                {
                    dci_chnl = coreotn_fmf_field_PRBS_CHID_get(NULL, coreotn_handle, COREOTN_FMF2_PRBS, i);
                    (void)coreotn_prbs_null_chan_en_set(coreotn_handle,
                                                        COREOTN_MUX_STAGE_TWO,
                                                        dci_chnl,
                                                        TRUE,
                                                        i);
                }
            }
        }      
    }

    PMC_RETURN(rc);
} /* coreotn_handle_restart_init */


/*******************************************************************************
* coreotn_ilkn_interface_enable
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function indicates to the COREOTN subsystem that ILKN interface is 
*   enabled. This information is mainly use to determine if it is required to 
*   keep ODUKSW in power up.
*
* INPUTS:
*   *coreotn_handle   - pointer to COREOTN handle instance
*   enable            - TRUE: enable ILKN interface 
*                       FALSE: disable ILKN interface 
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_ilkn_interface_enable(coreotn_handle_t *coreotn_handle, BOOL8 enable)
{
    PMC_ENTRY();

    coreotn_handle->var.ilkn_if_enable = enable;

    PMC_RETURN();
} /* coreotn_ilkn_interface_enable */



/*******************************************************************************
* coreotn_odu_rcp_di_enable_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns whether ODU RCP DI interface is enabled 
*
* INPUTS:
*   *coreotn_handle   - pointer to COREOTN handle instance
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 coreotn_odu_rcp_di_enable_get(coreotn_handle_t *coreotn_handle)
{
    BOOL8 result  = FALSE;
    PMC_ENTRY();
    
    result =  (odu_rcp_start_state_test(coreotn_handle->odu_rcp_handle,ODU_RCP_DI_INST) == FALSE)?TRUE:FALSE;

   /*PMC_RETURN(coreotn_handle->base.base_address);*/
    PMC_RETURN(result);
} /* coreotn_odu_rcp_di_enable_get */


/*******************************************************************************
*  coreotn_operation_init_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Perform any initialization sequences in sub-blocks of COREOTN subsystem
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   init_operation      - Operational mode\n
*
* OUTPUTS:
*
* RETURNS:
*  None
*
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_operation_init_set(coreotn_handle_t *coreotn_handle,
                                       coreotn_init_operation_t init_operation)
{
    /* variable declaration */   
    PMC_ENTRY();
    PMC_ASSERT(coreotn_handle->var.coreotn_start_state == TRUE,
               COREOTN_ERR_CODE_ASSERT,
               init_operation,
               0);

    PMC_LOG_TRACE("init_operation = %u\n",init_operation);    
    coreotn_handle->var.init_operation = init_operation;

    PMC_RETURN();
} /* coreotn_operation_init_set */

/*******************************************************************************
*  coreotn_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Perform any initialization sequences in sub-blocks of COREOTN subsystem
*
* INPUTS:
*   *coreotn_handle         - pointer to COREOTN handle instance to be operated on
*   energy_state_request    - requested energy state
*   power                   - The power area that needs to be initialized
*                             That is only used in for RUNNING request
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_init(coreotn_handle_t *coreotn_handle, 
                         pmc_energy_state_request_t energy_state_request,
                         coreotn_power_t power)
{
    PMC_ENTRY();

    PMC_LOG_TRACE("coreotn_power::coreotn init (%d,%d)\n", energy_state_request,(UINT32)power);

    if (PMC_ENERGY_STATE_REQUEST_RUNNING != energy_state_request)
    {
        /* the RESET/OPTIMAL case */
        BOOL8 is_reset = (PMC_ENERGY_STATE_REQUEST_RESET == energy_state_request);

        /* STG4 -> Do we have something provisioned toward COREOTN*/
        if (is_reset == TRUE || COREOTN_STG4 == power)
        {
            if (coreotn_stg4_start_state_test(coreotn_handle) == TRUE)
            {
                coreotn_stg4_init(coreotn_handle,PMC_ENERGY_STATE_RESET);
            }
        }
        
        /* ODUKP datapath */
        if (is_reset == TRUE || COREOTN_ODUKP == power)
        {
            if (coreotn_odukp_start_state_test(coreotn_handle) == TRUE)
            {
                coreotn_odukp_init(coreotn_handle,PMC_ENERGY_STATE_RESET);
            }
        }
        

        if (is_reset == TRUE ||COREOTN_ODUKSW == power)
        {
            if (coreotn_oduksw_start_state_test(coreotn_handle) == TRUE)
            {
                coreotn_oduksw_init(coreotn_handle,PMC_ENERGY_STATE_RESET);
            }
        }
        
        /* 
           RCP/OHP supporting interface are handled by their own API 
           - coreotn_ohp_uninit
           - coreotn_rcp_uninit
           These interface are not put in power on optimal request since that
           gonna will destroy their the FEGE configuration.
           However, on RESET request, we disabled them and we assume that associated 
           SERDES have been appropriatly cleaned           
        */
        if (TRUE == is_reset)
        {
            /* whenever the port is initialized, these functions returns that are ignored*/
            (void) coreotn_ohp_uninit(coreotn_handle, ODU_OHP_1);
            (void) coreotn_ohp_uninit(coreotn_handle, ODU_OHP_2);
            (void) coreotn_ohp_uninit(coreotn_handle, ODU_OHP_3);
            (void) coreotn_odu_rcp_uninit(coreotn_handle, ODU_RCP_RI_INST);
            (void) coreotn_odu_rcp_uninit(coreotn_handle, ODU_RCP_DI_INST);            
        }    

        if (coreotn_start_state_test(coreotn_handle) == TRUE)
        {
            coreotn_handle->var.coreotn_start_state = TRUE;

            /* Initialize var_t parameters */
            coreotn_var_default_init(coreotn_handle,&coreotn_handle->var);
        }
    } 
    else 
    {
        if (COREOTN_STG4 == power)
        {
            if (coreotn_stg4_start_state_test(coreotn_handle) == TRUE)
            {
                coreotn_stg4_init(coreotn_handle,PMC_ENERGY_STATE_RUNNING);
            }
        } 
        else if (COREOTN_ODUKP == power)
        {
            if (coreotn_odukp_start_state_test(coreotn_handle) == TRUE)
            {
                coreotn_odukp_init(coreotn_handle,PMC_ENERGY_STATE_RUNNING);
#ifdef PMC_INTERNAL_COREOTN_POWER
                /* COREOTN power mode  */
#else 
                if (coreotn_oduksw_start_state_test(coreotn_handle) == TRUE)
                {
                    coreotn_oduksw_init(coreotn_handle,PMC_ENERGY_STATE_RUNNING);                   
                }  

#endif
                coreotn_handle->var.coreotn_start_state = FALSE;

            }
        } 
        else if (COREOTN_ODUKSW == power)
        {
            if (coreotn_oduksw_start_state_test(coreotn_handle) == TRUE)
            {
                coreotn_oduksw_init(coreotn_handle,PMC_ENERGY_STATE_RUNNING);
            }            
        }        
    }
     
    PMC_RETURN();
} /* coreotn_init */

/*******************************************************************************
*  coreotn_ho_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Provisions a HO ODU channel at Stage 1 framer. This function sets up the
*   HO ODU channel such that COREOTN can perform further de-multiplexing based
*   on the payload format of the HO ODU channel. This function will configure
*   data to flow to ODUk Switch.
*
*   If the HO ODU channel is channelized and requires 1-stage de-multiplexing,
*   call coreotn_lo_chnl_prov() API to provision lower order ODU
*   channels.
*
*   If the ODU traffic is channelized and requires 2-stage de-multiplexing,
*   call coreotn_lo_chnl_prov() twice once for each required stage of
*   de-multiplexing.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   odu_container       - ODUk type. See odukp_type_enum.
*                         Valid range: ODU2 to ODU4
*   payload_format      - payload format of the ODUk traffic carried by this HO
*                         channel. See odu_line_payload_t.
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   prov_rfrm_tfrm_cfg  - TRUE : provision HO RFRM/TFRM configuation
*                         FALSE : preserve current RFRM/TFRM configuration
*   prov_dummy_schd     - TRUE : Provision dummy schedule at FO1 MPMO
*                         FALSE : do not provision dummy schedule at FO1
*                                 MPMO
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ho_chnl_prov(coreotn_handle_t *coreotn_handle,
                                      UINT32 chnl_id,
                                      coreotn_mux_stage_t mux_stage,
                                      util_global_odukp_type_t odu_container,
                                      util_global_odu_line_payload_t payload_format,
                                      BOOL prov_rfrm_tfrm_cfg,
                                      BOOL prov_dummy_schd)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;

    PMC_ENTRY();
    
    /* argument checking */
    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    /* argument checking */
    if (mux_stage > LAST_COREOTN_MUX_STAGE
        || odu_container > UTIL_GLOBAL_LAST_ODUK
        || payload_format > LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD
        || (mux_stage == COREOTN_MUX_STAGE_ONE && chnl_id > 11))
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }
    
    ret_val = coreotn_rx_ho_chnl_prov(coreotn_handle, chnl_id, mux_stage,
                                      odu_container, payload_format,
                                      prov_rfrm_tfrm_cfg);
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = coreotn_tx_ho_chnl_prov(coreotn_handle, chnl_id, mux_stage,
                                          odu_container, payload_format,
                                          prov_rfrm_tfrm_cfg,
                                          prov_dummy_schd);
    }
    
    if (PMC_SUCCESS == ret_val)
    {
        if (mux_stage == COREOTN_MUX_STAGE_ONE)
        {
            /* store the server rate and payload format to be used in MPMO */
            coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].odu_container = odu_container;
            coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].odu_container = odu_container;
            
            /* store the server rate and payload format to be used in MPMO */
            coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].odu_container = UTIL_GLOBAL_LAST_ODUK;
            coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].odu_container = UTIL_GLOBAL_LAST_ODUK;
            coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
            coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
        }
        else if (mux_stage == COREOTN_MUX_STAGE_TWO)
        {
            /* store the server rate and payload format to be used in MPMO */
            coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].odu_container = odu_container;
            coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].odu_container = odu_container;
        }            
    }
    
    PMC_RETURN(ret_val);
} /* coreotn_ho_chnl_prov */

/*******************************************************************************
*  coreotn_ho_chnl_prov_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns TRUE when the specifed RX or TX  HO/MO ODU container 
*   is in the provided state
* 
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11 (for HO stage) 0 - 95 (for MO stage)
*   is_rx_side          - RX and TX side\n
*                           TRUE:  RX \n
*                           FALSE: TX
*   payload_format      - payload format of the ODUk traffic carried by this HO
*                         channel. See odu_line_payload_t.
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   state               - The state that checked by this function 
*
* OUTPUTS:
*   NONE
*
* RETURNS:
*   TRUE whe  the data path is in the provided state, otherwise FALSE
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 coreotn_ho_chnl_prov_get(coreotn_handle_t *coreotn_handle,
                                      UINT32 chnl_id,
                                      BOOL8  is_rx_side,
                                      coreotn_mux_stage_t mux_stage,
                                      util_global_odu_line_payload_t payload_format,
                                      util_global_chnl_state_t state)
{
    BOOL8 result = FALSE;

    /*    util_global_odukp_type_t act_odu_container = UTIL_GLOBAL_LAST_ODUK;*/
    util_global_odu_line_payload_t act_payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
    util_global_chnl_state_t act_state = UTIL_GLOBAL_CHNL_START;

    PMC_ENTRY();
    
    /* argument checking */
    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(!(mux_stage > LAST_COREOTN_MUX_STAGE ||
                 payload_format > LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD ||
                 (mux_stage == COREOTN_MUX_STAGE_ONE && chnl_id > 11)),COREOTN_ERR_INVALID_ARG,0,0);
    
    /* get actual values */

    if (mux_stage == COREOTN_MUX_STAGE_ONE||
        mux_stage == COREOTN_MUX_STAGE_NONE)
    {     
        coreotn_chnl_ho_ctxt_t *ho_ctxt = (TRUE == is_rx_side)?
            &coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id]:&coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id];
            
        /*        act_odu_container  = ho_ctxt->odu_container;*/
        act_payload_format = ho_ctxt->payload_format;
        act_state          = (util_global_chnl_state_t) ho_ctxt->chnl_state;
    }
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {     
        coreotn_chnl_molo_ctxt_t *mo_ctxt = (TRUE == is_rx_side)?
            &coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id]:&coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id];
        /*        act_odu_container  = mo_ctxt->odu_container;*/
        act_payload_format = mo_ctxt->payload_format;
        act_state          = (util_global_chnl_state_t) mo_ctxt->chnl_state;
    }        
    if (payload_format == act_payload_format &&
        act_state      == state)
    {
        result = TRUE;
    }

    PMC_RETURN(result);
} /* coreotn_ho_chnl_prov_get */


/*******************************************************************************
*  coreotn_lo_chnl_prov_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns TRUE when the specifed RX or TX  MO/LO ODU container 
*   is in the provided state
* 
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11 (for HO stage) 0 - 95 (for MO stage)
*   is_rx_side          - RX and TX side\n
*                           TRUE:  RX \n
*                           FALSE: TX
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   payload_format      - payload format of the ODUk traffic carried by this HO
*                         channel. See odu_line_payload_t.
*   tx_trib_slot_mask   - 3 x 32 bit mask to represent the tributary slot
*                         assignment for this LO channel.\n
*                         Valid range: 0 - 0x4F\n
*                         Bit 0 -- Tributary slot 1\n
*                         Bit 1 -- Tributary slot 2\n
*                         Bit 2 -- Tributary slot 3\n
*                                ...\n
*                         Bit 79 -- Tributary slot 80\n
*                         NOTE : This is a "normalized" view of the server (so, if
*                                adding a client to an ODU2 server, only bits 0-7
*                                of tribslot_mask[0] can get set).
*                                In the event of 2.5G TS ODU2, only bits 0-3 can
*                                get set.
*   rx_trib_slot_mask   - 3 x 32 bit mask to represent the tributary slot
*                         assignment for this LO channel.\n
*                         Valid range: 0 - 0x4F\n
*                         Bit 0 -- Tributary slot 1\n
*                         Bit 1 -- Tributary slot 2\n
*                         Bit 2 -- Tributary slot 3\n
*                                ...\n
*                         Bit 79 -- Tributary slot 80\n
*                         NOTE : This is a "normalized" view of the server (so, if
*                                adding a client to an ODU2 server, only bits 0-7
*                                of tribslot_mask[0] can get set).
*                                In the event of 2.5G TS ODU2, only bits 0-3 can
*                                get set.
*   state               - The state that checked by this function 
*
* OUTPUTS:
*   NONE
*
* RETURNS:
*   TRUE whe  the data path is in the provided state, otherwise FALSE
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 coreotn_lo_chnl_prov_get(coreotn_handle_t *coreotn_handle,
                                      UINT32 chnl_id,
                                      BOOL8  is_rx_side,
                                      coreotn_mux_stage_t mux_stage,
                                      util_global_odu_line_payload_t payload_format,
                                      UINT32 tx_trib_slot_mask[3],
                                      UINT32 rx_trib_slot_mask[3],
                                      util_global_chnl_state_t state)
{
    BOOL8 result = FALSE;
    UINT32 itr;
    coreotn_chnl_molo_ctxt_t *molo_ctxt = NULL;

    PMC_ENTRY();
    
    /* argument checking */
    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(!( (mux_stage > LAST_COREOTN_MUX_STAGE&& mux_stage == COREOTN_MUX_STAGE_NONE) ||
                  payload_format > LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD ),COREOTN_ERR_INVALID_ARG,0,0);
    
    /* get actual values */

    
    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {     
        molo_ctxt = (TRUE == is_rx_side)?
            &coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id]:&coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id];            
    }
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {     
        molo_ctxt = (TRUE == is_rx_side)?
            &coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id]:&coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id];
    }
    else
    {
        PMC_ASSERT(FALSE,COREOTN_ERR_INVALID_ARG,0,0);
    }

    /* check it */
    if (payload_format == molo_ctxt->payload_format &&
        state      == (util_global_chnl_state_t) molo_ctxt->chnl_state)
    {        
        result = TRUE;
        if (is_rx_side == FALSE)
        {
            for (itr=0;itr<3 && result == TRUE;itr++)
            {
                if (tx_trib_slot_mask[itr] != molo_ctxt->tribslot_mask[itr])
                {
                    result = FALSE;
                }
            }
        } else 
        {        
            for (itr=0;itr<3 && result == TRUE;itr++)
            {
                if (rx_trib_slot_mask[itr] != molo_ctxt->tribslot_mask[itr])
                {
                    result = FALSE;
                }
            }
        }
    }

    PMC_RETURN(result);
} /* coreotn_lo_chnl_prov_get */

/*******************************************************************************
*  coreotn_ho_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Provisions a HO ODU channel at Stage 1 framer. This function sets up the
*   HO ODU channel such that COREOTN can perform further de-multiplexing based
*   on the payload format of the HO ODU channel. This function will configure
*   data to flow to ODUk Switch.
*
*   If the HO ODU channel is channelized and requires 1-stage de-multiplexing,
*   call coreotn_lo_chnl_prov() API to provision lower order ODU
*   channels.
*
*   If the ODU traffic is channelized and requires 2-stage de-multiplexing,
*   call coreotn_lo_chnl_prov() twice once for each required stage of
*   de-multiplexing.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   deprov_rfrm_tfrm_cfg - TRUE : deprov RFRM configuration
*                          FALSE : do no deprov RFRM configuration
*   deprov_dummy_schd    - TRUE : deprovision dummy schedule at the MPMO
*                          FALSE : keep the dummy schedule at the MPMO
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ho_chnl_deprov(coreotn_handle_t *coreotn_handle,
                                        UINT32 chnl_id,
                                        coreotn_mux_stage_t mux_stage,
                                        BOOL deprov_rfrm_tfrm_cfg,
                                        BOOL deprov_dummy_schd)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;

    PMC_ENTRY();
    
    /* argument checking */
    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    
    if (mux_stage > LAST_COREOTN_MUX_STAGE
        || (mux_stage == COREOTN_MUX_STAGE_ONE && chnl_id > 11))
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    ret_val = coreotn_rx_ho_chnl_deprov(coreotn_handle,
                                        chnl_id,
                                        mux_stage,
                                        deprov_rfrm_tfrm_cfg);
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = coreotn_tx_ho_chnl_deprov(coreotn_handle,
                                            chnl_id,
                                            mux_stage,
                                            deprov_rfrm_tfrm_cfg,
                                            deprov_dummy_schd);
    }


    PMC_RETURN(ret_val);
} /* coreotn_ho_chnl_deprov */

/*******************************************************************************
*  coreotn_stg4_rx_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API is used when the ODU channel is to be mapped to a specific client
*   in COREOTN.
*
*   This API configures the STAGE 4 RX framer.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 95
*   mode                - operating mode of the framer channel
*                         0 -- disabled
*                         1 -- enabled; out of passthru
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_stg4_rx_chnl_prov(coreotn_handle_t *coreotn_handle,
                                           UINT32 chnl_id,
                                           UINT32 mode)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 *null_chan_en = NULL;
    UINT32 *prbs_null_chan_en = NULL;

    PMC_ENTRY();

    if (TRUE == coreotn_handle->var.rx_stg4_chnl_prov[chnl_id] && mode == 1)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_START);
    } else if (FALSE == coreotn_handle->var.rx_stg4_chnl_prov[chnl_id] && mode == 0)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_OPERATIONAL);
    }

    /* configure FAU and channel PASSTHRU 
    ** provision PM 
    */

    if(mode == 0)
    {
        /* Prov/deprov is performed 
        in coreotn_oduksw_chnl_activate/coreotn_oduksw_chnl_deactivate().
        This call is just to clear configuration*/
        odu_rfrm_chnl_clean(coreotn_handle->odu_rfrm_stg4_handle,
                            &chnl_id,
                            1);
    }
    else
    {
        /* Provision stage 4 RFRM to terminate PM.
        Do not activate (activation occurs in oduksw_chnl_activate()*/
        ret_val = odu_rfrm_chnl_prov(coreotn_handle->odu_rfrm_stg4_handle,
                                     chnl_id,
                                     TRUE, 
                                     TRUE, 
                                     TRUE,
                                     TRUE);

    }
                                               
    coreotn_handle->var.rx_stg4_chnl_prov[chnl_id] = (mode == 1)?TRUE:FALSE;


    if(mode==0)
    {
        coreotn_mapotn_null_frame_mode_ptr_get(coreotn_handle,
                                               &null_chan_en,
                                               &prbs_null_chan_en);
        

        null_chan_en[chnl_id/32] = null_chan_en[chnl_id/32] & ~(1 << (chnl_id % 32));
        prbs_null_chan_en[chnl_id/32] = prbs_null_chan_en[chnl_id/32] & ~(1 << (chnl_id % 32));
    }


    PMC_RETURN(ret_val);
} /* coreotn_stg4_rx_chnl_prov */

/*******************************************************************************
*  coreotn_stg4_tx_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API is used when the ODU channel is to be mapped to a specific client
*   in COREOTN.
*
*   This API configures the STAGE 4 TX framer.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 95
*   mode                - operating mode of the framer channel
*                         0 -- disabled
*                         1 -- enabled; out of passthru
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_stg4_tx_chnl_prov(coreotn_handle_t *coreotn_handle,
                                           UINT32 chnl_id, UINT32 mode)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;

    PMC_ENTRY();

    if (TRUE == coreotn_handle->var.tx_stg4_chnl_prov[chnl_id] && mode == 1)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_START);
    } else if (FALSE == coreotn_handle->var.tx_stg4_chnl_prov[chnl_id] && mode == 0)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_OPERATIONAL);
    }
    if (TRUE == mode)
    {

        if (PMC_SUCCESS == ret_val)
        {
            /* STG4 TFRM needs to have PM provisioned (note, activation is done in
            oduksw_chnl_activate())*/                                     
            ret_val = coreotn_odu_tfrm_chnl_init(coreotn_handle,
                                                 (odu_tfrm_inst_t)ODU_TFRM_STG4,
                                                 chnl_id, mode);        


        }
        
        /*activation must occur here for compatibility with restart*/
        if(PMC_SUCCESS == ret_val)
        {
            ret_val = odu_tfrm_chnl_init(coreotn_handle->odu_tfrm_stg4_handle, chnl_id, 1);               
        }

    } else 
    {
        ret_val = odu_tfrm_chnl_prov(coreotn_handle->odu_tfrm_stg4_handle, chnl_id, 
                                     ODU_TFRM_MESSAGE_DONT_CARE,ODU_TFRM_MESSAGE_DONT_CARE,ODU_TFRM_PM_TCM_START,
                                     FALSE);
    }
    coreotn_handle->var.tx_stg4_chnl_prov[chnl_id] = (mode == 1)?TRUE:FALSE;
    PMC_RETURN(ret_val);
} /* coreotn_stg4_tx_chnl_prov */

/*******************************************************************************
*  coreotn_stg4_rx_chnl_prov_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This API return if the STAGE 4 RX framer is provisioned
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 95
*
* OUTPUTS:
*
* RETURNS:
*   TRUE: when the specifed channel is provisioned
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 coreotn_stg4_rx_chnl_prov_get(coreotn_handle_t *coreotn_handle,
                                           UINT32 chnl_id)
{
    PMC_ENTRY();                                              
    PMC_RETURN(coreotn_handle->var.rx_stg4_chnl_prov[chnl_id]);
} /* coreotn_stg4_rx_chnl_prov_get */


/*******************************************************************************
*  coreotn_stg4_tx_chnl_prov_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This API return if the STAGE 4 TX framer is provisioned
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 95
*
* OUTPUTS:
*
* RETURNS:
*   TRUE: when the specifed channel is provisioned
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 coreotn_stg4_tx_chnl_prov_get(coreotn_handle_t *coreotn_handle,
                                           UINT32 chnl_id)
{
    PMC_ENTRY();                                              
    PMC_RETURN(coreotn_handle->var.tx_stg4_chnl_prov[chnl_id]);
} /* coreotn_stg4_tx_chnl_prov_get */

/*******************************************************************************
*  coreotn_odtu_mux_empty_ho_unlock
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This API performs toggling of HO channel to get it out of possible locked 
*   state when the first lower order channel is added to an empty higher order
*   channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_level          - see odu_struct_odu_level_t. Only HO and MO are valid.
*   lo_chnl_id          - LO channel ID being added to the empty HO.
*                         Valid range: 0 -- 95
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   TRUE: when the specifed channel is provisioned
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_odtu_mux_empty_ho_unlock(coreotn_handle_t *coreotn_handle,
                                                  util_global_odu_level_t chnl_level,
                                                  UINT32 lo_chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 ho_chnl_id;
    
    PMC_ENTRY();                   


    if (FALSE == pmc_coreotn_mux_empty_ho_order_revision(&coreotn_handle->base))
    {
        PMC_RETURN(result);
    }
    /* get HO channel ID from TX database */
    result = coreotn_db_ho_chnl_id_get(coreotn_handle, 0, chnl_level,
                                       lo_chnl_id, &ho_chnl_id);
    
    if ((chnl_level == UTIL_GLOBAL_LEVEL_LO_ODU && ho_chnl_id > 95)
        || (chnl_level == UTIL_GLOBAL_LEVEL_MO_ODU && ho_chnl_id > 11))
    {
        result = COREOTN_ERR_INVALID_ARG;
    }
                                      
    if (PMC_SUCCESS == result)
    {                                       
        if (chnl_level == UTIL_GLOBAL_LEVEL_LO_ODU
            && (coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 1))
        {
    
            /* only do this for the first LO */
            /* set OHFS_INSERT CFC_FIFO_CLRB = '0' */
            result = odtu_mux_ohfs_insert_cfc_fifo_deactivate(coreotn_handle->odtu_mux2_handle, ho_chnl_id);
            
            /* set associated HO_CH_RSTB = '0' */
            if (PMC_SUCCESS == result)
            {
                result = odtu_mux_ho_chnl_reset_set(coreotn_handle->odtu_mux2_handle, 
                                                    ho_chnl_id, 0);
            }
            
            /* set OHFS_INSERT CFC_FIFO_CLRB = '1' */
            if (PMC_SUCCESS == result)
            {                                                      
                result = odtu_mux_ohfs_insert_cfc_fifo_activate(coreotn_handle->odtu_mux2_handle, ho_chnl_id);
            }
            
            /* set HO_CH_RSTB = '1' */
            if (PMC_SUCCESS == result)
            {
                result = odtu_mux_ho_chnl_reset_set(coreotn_handle->odtu_mux2_handle, 
                                                    ho_chnl_id, 1);
            } 
        }
        
        else if (chnl_level == UTIL_GLOBAL_LEVEL_MO_ODU
                 && (coreotn_handle->var.tx_mo_chnl_ctxt[lo_chnl_id].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
                 && (coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].odu_container == UTIL_GLOBAL_ODU2 
                     || coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].odu_container == UTIL_GLOBAL_ODU3
                     || coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].odu_container == UTIL_GLOBAL_ODU3E1
                     || coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].odu_container == UTIL_GLOBAL_ODU3E2
                     || coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].odu_container == UTIL_GLOBAL_ODU4
                     ))
        {
            if (coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 1)
            {
                /* set OHFS_INSERT CFC_FIFO_CLRB = '0' */
                result = odtu_mux_ohfs_insert_cfc_fifo_deactivate(coreotn_handle->odtu_mux1_handle, ho_chnl_id);
                
                /* set associated HO_CH_RSTB = '0' */
                if (PMC_SUCCESS == result)
                {
                    result = odtu_mux_ho_chnl_reset_set(coreotn_handle->odtu_mux1_handle, 
                                                        ho_chnl_id, 0);
                }
                
                /* set OHFS_INSERT CFC_FIFO_CLRB = '1' */
                if (PMC_SUCCESS == result)
                {                                                      
                    result = odtu_mux_ohfs_insert_cfc_fifo_activate(coreotn_handle->odtu_mux1_handle, ho_chnl_id);
                }
                
                /* set HO_CH_RSTB = '1' */
                if (PMC_SUCCESS == result)
                {
                    result = odtu_mux_ho_chnl_reset_set(coreotn_handle->odtu_mux1_handle, 
                                                        ho_chnl_id, 1);
                }
            }  
        }
    } 
                                 
    PMC_RETURN(result);
} /* coreotn_odtu_mux_empty_ho_unlock */

/*******************************************************************************
* coreotn_odu_chnl_prov_mode_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function sets the COREOTN LO ODU channel provisioning mode. 
*   This function is used to determine if LO ODU channel will be provisioned 
*   one at a time or all LO ODU channels will be provisioned into the HO
*   container at once. 
*      
*   
* INPUTS:
*   *coreotn_handle - pointer to COREOTN handle.
*   prov_mode       - Enum for LO ODU channel provisioning mode. 
*                     See coreotn_odu_chnl_prov_mode_t. \n
*                            
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_odu_chnl_prov_mode_set(coreotn_handle_t *coreotn_handle,
                                                coreotn_odu_chnl_prov_mode_t prov_mode)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();
   
    if (prov_mode > LAST_COREOTN_CHNL_PROV_MODE)
    {
        result = COREOTN_ERR_INVALID_ARG;
    }
     
    coreotn_handle->var.prov_mode = prov_mode;
    
    odtu_dmx_prov_mode_set(coreotn_handle->odtu_dmx1_handle,
                           (BOOL8)prov_mode);
    
    odtu_dmx_prov_mode_set(coreotn_handle->odtu_dmx2_handle,
                           (BOOL8)prov_mode); 
                           
    odtu_mux_prov_mode_set(coreotn_handle->odtu_mux1_handle,
                           (BOOL8)prov_mode);
                                   
    odtu_mux_prov_mode_set(coreotn_handle->odtu_mux2_handle,
                           (BOOL8)prov_mode);                                                                                        
                                                         
    
    PMC_RETURN(result);
} /* coreotn_odu_chnl_prov_mode_set */

/*******************************************************************************
* coreotn_odu_chnl_prov_mode_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns the COREOTN LO ODU channel provisioning mode. 
*   This function is used to test if COREOTN is using super prov mode or 
*   incremental prov mode.
*   
*   
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle.                            
*
* OUTPUTS:
*   *prov_mode          - Enum for LO ODU channel provisioning mode. 
*                         See coreotn_odu_chnl_prov_mode_t. \n
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_odu_chnl_prov_mode_get(coreotn_handle_t *coreotn_handle,
                                                coreotn_odu_chnl_prov_mode_t *prov_mode)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();
     
    *prov_mode = coreotn_handle->var.prov_mode;
                                                         
    
    PMC_RETURN(result);
} /* coreotn_odu_chnl_prov_mode_get */

/*******************************************************************************
* coreotn_lo_odu_chnl_cfg_state_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function sets the channel state of LO ODU channel.
*   
*   
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle.     
*   odu_level           - ODU level of the channel
*   chnl_id             - channel ID
*   cfg_state           - Enum for channel config state. See coreotn_lo_odu_chnl_cfg_state_t.
*   coreotn_rx_prov     - TRUE : change state for RX segment
*                         FALSE : Do no change state for RX segment
*   coreotn_tx_prov     - TRUE : change state for TX segment
*                         FALSE : Do no change state for TX segment
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_lo_odu_chnl_cfg_state_set(coreotn_handle_t *coreotn_handle,
                                                   util_global_odu_level_t odu_level,
                                                   UINT32 chnl_id,
                                                   coreotn_lo_odu_chnl_cfg_state_t cfg_state,
                                                   BOOL coreotn_rx_prov,
                                                   BOOL coreotn_tx_prov)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();
     
    if (odu_level == UTIL_GLOBAL_LEVEL_MO_ODU)
    {
        /* sub channel is MO */

        if(coreotn_rx_prov)
        {
            coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_cfg_state = cfg_state;
        }

        if(coreotn_tx_prov)
        {
            coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_cfg_state = cfg_state;
        }
    }
    else if (odu_level == UTIL_GLOBAL_LEVEL_LO_ODU)
    {
        /* sub channel is MO */

        if(coreotn_rx_prov)
        {
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_cfg_state = cfg_state;
        }

        if(coreotn_tx_prov)
        {
            coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_cfg_state = cfg_state;
        }
    }
    else {
        result = COREOTN_ERR_INVALID_ARG;
    }
      
    PMC_RETURN(result);
} /* coreotn_lo_odu_chnl_cfg_state_set */

/*******************************************************************************
* coreotn_super_prov_lo_prov_num_chnl_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function is used to set the total number of LO channels that will be
*   added to the HO ODU channel. This function must be called for each HO ODU
*   channel that is channelized. \n\n
*
*   This function must be called if digi_otn_odu_chnl_prov_mode_set() is called 
*   with 'DIGI_OTN_ODU_CHNL_RPOV_ALL'. \n\n
*
*   In 1 stage muxing, 'num_mo_chnls' should be set to the total number of
*   LO channels that will be provisioned in the HO. \n\n
*
*   In 2 stage muxing, 'num_mo_chnls' should be set to the total number of 
*   MO channels being provisioned into the HO channel and 'num_lo_chnls' should 
*   be set to the total number of LO channels that will be provisioned in one MO channel.\n\n
*
*   For example: 
*   1) In one stage muxing datapath such as 1xOTU4 <-> 80xODU0, 
*      this function needs to be called only once with 'num_mo_chnls' set to 80 
*      and 'num_lo_chnls' set to 0. \n\n
*   
*   2) In one stage muxing datapath such as 10xOTU2 <-> 40xODU1,
*      this function should be called once per HO OTU2. 
*      In each call, 'num_mo_chnls' should be set to 4.\n\n
*
*   3) In two stage muxing datapath such as 1xOTU4 <-> 40xODU1 <-> 80xODU0,
*      this function should be called only once with 'num_mo_chnls' set to 40
*      and 'num_lo_chnls' set to 2. \n\n
*    
*   
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   ho_chnl_id          - HO channel ID to define its muxing profile.
*                         Valid range: 0 - 11
*   num_mo_chnls        - total number of MO ODU channels that will be added to
*                         the HO ODU channel.
*   num_lo_chnls        - total number of LO ODU channels that will be added to
*                         the HO ODU channel.
*                            
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_super_prov_lo_prov_num_chnl_set(coreotn_handle_t *coreotn_handle,
                                                         UINT8 ho_chnl_id,
                                                         UINT8 num_mo_chnls,
                                                         UINT8 num_lo_chnls)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();
    
    /* check if num_mo_chnls and num_chnls are valid for the HO container 
    ** cannot check for stringent limit as MO/LO container sizes are unknown
    ** at this point
    */
    
    /* set mux profile for this HO channel */
    coreotn_handle->var.mux_profile[ho_chnl_id].num_mo_chnls = num_mo_chnls;
    coreotn_handle->var.mux_profile[ho_chnl_id].num_lo_chnls = num_lo_chnls;
       
    PMC_RETURN(result);
} /* coreotn_super_prov_lo_prov_num_chnl_set */

/*******************************************************************************
* coreotn_super_prov_lo_prov_num_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function is used to retrieve the total number of LO channels that will 
*   be added to the HO ODU channel.  \n\n
*    
*   
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   odu_level           - ODU level. See util_global_odu_level_t.
*   ho_chnl_id          - HO channel ID to define its muxing profile.
*                         Valid range: 0 - 11
*                            
*
* OUTPUTS:
*   *num_mo_chnls       - total number of MO ODU channels that will be added to
*                         the HO ODU channel.
*   *num_lo_chnls       - total number of LO ODU channels that will be added to
*                         the HO ODU channel.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_super_prov_lo_prov_num_chnl_get(coreotn_handle_t *coreotn_handle,
                                                         util_global_odu_level_t odu_level,
                                                         UINT8 ho_chnl_id,
                                                         UINT8 *num_mo_chnls,
                                                         UINT8 *num_lo_chnls)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 ultimate_ho_id = 0x7F;
    
    PMC_ENTRY();
    
    /* check if num_mo_chnls and num_chnls are valid for the HO container 
    ** cannot check for stringent limit as MO/LO container sizes are unknown
    ** at this point
    */
    
    /* set mux profile for this HO channel */
    if (odu_level == UTIL_GLOBAL_LEVEL_HO_ODU)
    {
        *num_mo_chnls = coreotn_handle->var.mux_profile[ho_chnl_id].num_mo_chnls;
        *num_lo_chnls = coreotn_handle->var.mux_profile[ho_chnl_id].num_lo_chnls;
    }
    else if (odu_level == UTIL_GLOBAL_LEVEL_MO_ODU)
    {
        /* get the ultimate parent channel ID 
        ** ho_chnl_id here is MO channel ID
        */
        odtu_dmx_ho_ch_id_get(coreotn_handle->odtu_dmx1_handle,
                              ho_chnl_id,
                              &ultimate_ho_id);
        
        if (ultimate_ho_id < COREOTN_MAX_NUM_HO_CHNL)
        {                    
            *num_mo_chnls = coreotn_handle->var.mux_profile[ultimate_ho_id].num_mo_chnls;
            *num_lo_chnls = coreotn_handle->var.mux_profile[ultimate_ho_id].num_lo_chnls;
        }
        else {
            result = COREOTN_ERR_INVALID_ARG;
        }            
    }
            
    PMC_RETURN(result);
} /* coreotn_super_prov_lo_prov_num_chnl_get */


/*******************************************************************************
*  coreotn_rx_lo_chnl_offline_update_all
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API configures the offline page of all LO channels that are to be
*   provisioned in bulk. This API is only used when coreotn_odu_chnl_prov_mode_set()
*   is called with COREOTN_ODU_CHNL_PROV_ALL.
* 
*   This API retrieves all LO channels in the given HO and identifies the ones
*   that have currently been provisioned on the online page. Once these channels
*   have been activated, the channel state gets updated to COREOTN_CHNL_PROV_PENDING
*   such that the offline update function only updates the new channels
*   being added. 
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   ho_chnl_id          - HO channel ID that this LO belongs to.
*                         Valid range: 0 - 95
*   *new_lo_chnl_ids    - pointer to storage for array of LO channel IDs to be
*                         added to the offline page
*   num_new_lo          - number of new LO channels
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_lo_chnl_offline_update_all(coreotn_handle_t *coreotn_handle,
                                                       coreotn_mux_stage_t mux_stage,
                                                       UINT32 ho_chnl_id,
                                                       UINT32 *new_lo_chnl_ids,
                                                       UINT32 num_new_lo)
{
    PMC_ENTRY();
    
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 i;
    odtu_dmx_handle_t *odtu_dmx_handle_ptr = NULL;
    
    /* find all LO channel IDs that need to be configured for the offline update */
    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE
            || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
        {
            odtu_dmx_handle_ptr = coreotn_handle->odtu_dmx2_handle;
        }
        else {
            odtu_dmx_handle_ptr = coreotn_handle->odtu_dmx1_handle;
        }
 
        if (PMC_SUCCESS == result)   
        {
            for (i = 0; i < num_new_lo; i++)
            {                                  
                /* 1) activate LO channel - rev A only */               
                if (TRUE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base))
                {
                    if ((coreotn_handle->var.rx_mo_chnl_ctxt[new_lo_chnl_ids[i]].chnl_cfg_state != COREOTN_LO_ODU_CHNL_CFG_START)
                        && (coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt != 1))
                    {
                        result = odtu_dmx_lo_chnl_activate(odtu_dmx_handle_ptr,
                                                           new_lo_chnl_ids[i], ho_chnl_id,
                                                           (odtu_dmx_stage_instance_t)mux_stage);
                                                           
                        if (PMC_SUCCESS == result)
                        {
                            /* update the channel state */
                            coreotn_handle->var.rx_mo_chnl_ctxt[new_lo_chnl_ids[i]].chnl_state = COREOTN_CHNL_OPERATIONAL;
                        }                                                       
                    }
                }
                                              
                /* 2) configure offline page */
                if (PMC_SUCCESS == result)
                {
                    /* update the channel state */
                    coreotn_handle->var.rx_mo_chnl_ctxt[new_lo_chnl_ids[i]].chnl_state = COREOTN_CHNL_PROV_PENDING;
                    
                    if (PMC_SUCCESS == result)
                    {    
                        result = coreotn_rx_lo_chnl_offline_update(coreotn_handle,
                                                                   new_lo_chnl_ids[i],
                                                                   mux_stage,
                                                                   coreotn_handle->var.rx_mo_chnl_ctxt[new_lo_chnl_ids[i]].lo_odu_rate,
                                                                   coreotn_handle->var.rx_mo_chnl_ctxt[new_lo_chnl_ids[i]].odu_flex_rate,
                                                                   coreotn_handle->var.rx_mo_chnl_ctxt[new_lo_chnl_ids[i]].cbr_flex_rate,
                                                                   coreotn_handle->var.rx_mo_chnl_ctxt[new_lo_chnl_ids[i]].mapping_mode,
                                                                   coreotn_handle->var.rx_mo_chnl_ctxt[new_lo_chnl_ids[i]].tribslot_mask,
                                                                   coreotn_handle->var.rx_mo_chnl_ctxt[new_lo_chnl_ids[i]].trib_port,
                                                                   coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].payload_format,
                                                                   coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].odu_container,
                                                                   ho_chnl_id);
                    }
               }
                                                                             
            }                                                           
        }
    } 
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        
        if (PMC_SUCCESS == result)   
        {
            for (i = 0; i < num_new_lo; i++)
            {     
                /* 1) activate LO channel */  
                if (TRUE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base))
                {
                    if ((coreotn_handle->var.rx_lo_chnl_ctxt[new_lo_chnl_ids[i]].chnl_cfg_state != COREOTN_LO_ODU_CHNL_CFG_START)
                        && (coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt != 1))
                    {                           
                        result = odtu_dmx_lo_chnl_activate(coreotn_handle->odtu_dmx2_handle,
                                                           new_lo_chnl_ids[i], ho_chnl_id,
                                                           (odtu_dmx_stage_instance_t)mux_stage);
                                                           
                        if (PMC_SUCCESS == result)
                        {
                            /* update the channel state */
                            coreotn_handle->var.rx_lo_chnl_ctxt[new_lo_chnl_ids[i]].chnl_state = COREOTN_CHNL_OPERATIONAL;
                        }                                                       
                    }                                                       
                }
                
                /* 2) configure offline page */
                if (PMC_SUCCESS == result)
                {          
                    /* update the channel state */
                    coreotn_handle->var.rx_lo_chnl_ctxt[new_lo_chnl_ids[i]].chnl_state = COREOTN_CHNL_PROV_PENDING;
                                            
                    result = coreotn_rx_lo_chnl_offline_update(coreotn_handle,
                                                               new_lo_chnl_ids[i],
                                                               mux_stage,
                                                               coreotn_handle->var.rx_lo_chnl_ctxt[new_lo_chnl_ids[i]].lo_odu_rate,
                                                               coreotn_handle->var.rx_lo_chnl_ctxt[new_lo_chnl_ids[i]].odu_flex_rate,
                                                               coreotn_handle->var.rx_lo_chnl_ctxt[new_lo_chnl_ids[i]].cbr_flex_rate,
                                                               coreotn_handle->var.rx_lo_chnl_ctxt[new_lo_chnl_ids[i]].mapping_mode,
                                                               coreotn_handle->var.rx_lo_chnl_ctxt[new_lo_chnl_ids[i]].tribslot_mask,
                                                               coreotn_handle->var.rx_lo_chnl_ctxt[new_lo_chnl_ids[i]].trib_port,
                                                               coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].payload_format,
                                                               coreotn_handle->var.rx_lo_chnl_ctxt[new_lo_chnl_ids[i]].odu_container,
                                                               ho_chnl_id);
                }                                                               
            }                                                           
        }
    }                                                   
    
    PMC_RETURN(result);                                                   
    
} /* coreotn_rx_lo_chnl_offline_update_all */  
    
    
/*******************************************************************************
*  coreotn_rx_lo_chnl_offline_deprov_all
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Deprovision the specified set of LO channels from the offline page in ODTU_DMX.
*   This API performs a page swap on the HO channel of the LO channels being 
*   deprovisioned and runs scheduling on both offline and online pages of ODTU_DMX 
*   after the specified LO channels have been removed.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   ho_chnl_id          - HO channel ID that this LO belongs to.
*                         Valid range: 0 - 95
*   *local_lo_chnl_ids  - array of LO channel IDs to be deprovisioned
*   num_lo_deprov       - number of LO channels to be deprovisioned
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_lo_chnl_offline_deprov_all(coreotn_handle_t *coreotn_handle,
                                                       coreotn_mux_stage_t mux_stage,
                                                       UINT32 ho_chnl_id,
                                                       UINT32 *local_lo_chnl_ids,
                                                       UINT32 num_lo_deprov)
{
    PMC_ENTRY();
    
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 i;
    odtu_dmx_handle_t *odtu_dmx_handle_ptr = NULL;
    odujat_handle_t *odujat_handle_ptr = NULL;
    oduksc_handle_t *oduksc_handle_ptr = NULL;
    BOOL8 mo_odu3e2_odu3e1 = FALSE;
    UINT32 extra_cycle = 0x7F;
    
    /* find all LO channel IDs that need to be configured for the offline update */
    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE
            || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
        {
            odtu_dmx_handle_ptr = coreotn_handle->odtu_dmx2_handle;
            odujat_handle_ptr = coreotn_handle->odujat2_handle;
            oduksc_handle_ptr = coreotn_handle->oduksc2_handle;
        }
        else {
            odtu_dmx_handle_ptr = coreotn_handle->odtu_dmx1_handle;
            odujat_handle_ptr = coreotn_handle->odujat1_handle;
            oduksc_handle_ptr = coreotn_handle->oduksc1_handle;
        }

        for (i = 0; i < num_lo_deprov && PMC_SUCCESS == result; i++)
        {                      
            if ((coreotn_handle->var.rx_mo_chnl_ctxt[local_lo_chnl_ids[i]].lo_odu_rate == UTIL_GLOBAL_ODU3E1
                 || coreotn_handle->var.rx_mo_chnl_ctxt[local_lo_chnl_ids[i]].lo_odu_rate == UTIL_GLOBAL_ODU3E2)
                && coreotn_handle->var.rx_mo_chnl_ctxt[local_lo_chnl_ids[i]].payload_format != UTIL_GLOBAL_ODU_UNCHANNELIZED)
            {
                mo_odu3e2_odu3e1 = TRUE;  
                
                if (coreotn_handle->var.extra_entry_ctxt[0].chnl_id == local_lo_chnl_ids[i])
                {
                    extra_cycle = coreotn_handle->var.extra_entry_ctxt[0].cycle;
                }
                else if (coreotn_handle->var.extra_entry_ctxt[1].chnl_id == local_lo_chnl_ids[i])
                {
                    extra_cycle = coreotn_handle->var.extra_entry_ctxt[1].cycle;
                } 
                 
            }
                            
            result = odtu_dmx_lo_chnl_offline_deprov(odtu_dmx_handle_ptr,
                                                     (odtu_dmx_stage_instance_t)mux_stage, 
                                                     local_lo_chnl_ids[i], 
                                                     ho_chnl_id,
                                                     mo_odu3e2_odu3e1, 
                                                     extra_cycle);
        }                                                            
        
        /* configure the offline page and swap the page in ODUJAT::ODUKSC
        ** only one offline page is configured
        */
        if (PMC_SUCCESS == result)
        {
            result = odujat_oduksc_page_swap(odujat_handle_ptr,
                                             local_lo_chnl_ids,
                                             num_lo_deprov,
                                             FALSE);
        }
            
        /* configure the offline page and swap the page in ODUJAT::ODUKSC
        ** only one offline page is configured** 
        */ 
        if (PMC_SUCCESS == result)
        {
            result = oduksc_all_chnls_update(oduksc_handle_ptr,
                                             local_lo_chnl_ids,
                                             num_lo_deprov,
                                             TRUE);
        }
              
        for (i = 0; i < num_lo_deprov && PMC_SUCCESS == result; i++)
        {
            result = coreotn_db_mo_entry_update(coreotn_handle,  
                                                UTIL_GEN_DB_LINE_CORE_OTN_RX_DB,  
                                                local_lo_chnl_ids[i]);
                                                 
            if (PMC_SUCCESS == result)
            {
                coreotn_handle->var.rx_mo_chnl_ctxt[local_lo_chnl_ids[i]].payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
            }                                                             
        
            /* remove extra entry context */
            if (coreotn_handle->var.tx_mo_chnl_ctxt[local_lo_chnl_ids[i]].odu_container == UTIL_GLOBAL_ODU3E1
                || coreotn_handle->var.tx_mo_chnl_ctxt[local_lo_chnl_ids[i]].odu_container == UTIL_GLOBAL_ODU3E2)
            {
                if (coreotn_handle->var.extra_entry_ctxt[0].chnl_id == local_lo_chnl_ids[i])
                {
                    coreotn_handle->var.extra_entry_ctxt[0].cycle = 0x7F;
                    coreotn_handle->var.extra_entry_ctxt[0].chnl_id = 0x7F;
                    coreotn_handle->var.extra_entry_ctxt[0].entry_state = FALSE;
                }
                else if (coreotn_handle->var.extra_entry_ctxt[1].chnl_id == local_lo_chnl_ids[i])
                {
                    coreotn_handle->var.extra_entry_ctxt[1].cycle = 0x7F;
                    coreotn_handle->var.extra_entry_ctxt[1].chnl_id = 0x7F;
                    coreotn_handle->var.extra_entry_ctxt[1].entry_state = FALSE;
                }
            }  
        }
    } 
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        for (i = 0; i < num_lo_deprov && PMC_SUCCESS == result; i++)
        {        
            result = odtu_dmx_lo_chnl_offline_deprov(coreotn_handle->odtu_dmx2_handle,
                                                     (odtu_dmx_stage_instance_t)mux_stage, 
                                                     local_lo_chnl_ids[i], 
                                                     ho_chnl_id,
                                                     mo_odu3e2_odu3e1, 
                                                     extra_cycle);                                            
        }
            
        /* configure the offline page and swap the page in ODUJAT::ODUKSC
        ** only one offline page is configured
        */ 
        if (PMC_SUCCESS == result)
        {
            result = odujat_oduksc_page_swap(coreotn_handle->odujat2_handle,
                                             local_lo_chnl_ids,
                                             num_lo_deprov,
                                             FALSE);
        }  

        /* configure the offline page and swap the page in ODUJAT::ODUKSC
        ** only one offline page is configured** 
        */ 
        if (PMC_SUCCESS == result)
        {
            result = oduksc_all_chnls_update(coreotn_handle->oduksc2_handle,
                                             local_lo_chnl_ids,
                                             num_lo_deprov,
                                             TRUE);
        }
           
        for (i = 0; i < num_lo_deprov && PMC_SUCCESS == result; i++)
        {
            result = coreotn_db_lo_entry_update(coreotn_handle,  
                                                UTIL_GEN_DB_LINE_CORE_OTN_RX_DB,  
                                                local_lo_chnl_ids[i]);                                                        
        }
    }                                                   
    
    PMC_RETURN(result);                                                   
    
} /* coreotn_rx_lo_chnl_offline_deprov_all */  

/*******************************************************************************
*  coreotn_tx_lo_chnl_offline_deprov_all
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Deprovision the speicifed set of LO channels from the offline page in ODTU_MUX.
*   This API performs a page swap on the HO channel of the LO channels being
*   deprovisioned and runs scheduling on both offline and online pages of 
*   ODTU_MUX after the specified LO channels have been removed.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   ho_chnl_id          - HO channel ID that this LO belongs to.
*                         Valid range: 0 - 95
*   *local_lo_chnl_ids  - array of LO channel IDs to be deprovisioned
*   num_lo_deprov       - number of LO channels to be deprovisioned
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_lo_chnl_offline_deprov_all(coreotn_handle_t *coreotn_handle,
                                                       coreotn_mux_stage_t mux_stage,
                                                       UINT32 ho_chnl_id,
                                                       UINT32 *local_lo_chnl_ids,
                                                       UINT32 num_lo_deprov)
{
    PMC_ENTRY();
    
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 i;
    odtu_mux_handle_t *odtu_mux_handle_ptr = NULL;
    BOOL8 mo_odu3e2_odu3e1 = FALSE;
    UINT32 extra_cycle = 0x7F;
    
    /* find all LO channel IDs that need to be configured for the offline update */
    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE
            || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
        {
            odtu_mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
        }
        else {
            odtu_mux_handle_ptr = coreotn_handle->odtu_mux1_handle;
        }

        for (i = 0; i < num_lo_deprov && PMC_SUCCESS == result; i++)
        {                           
            if ((coreotn_handle->var.tx_mo_chnl_ctxt[local_lo_chnl_ids[i]].lo_odu_rate == UTIL_GLOBAL_ODU3E1
                 || coreotn_handle->var.tx_mo_chnl_ctxt[local_lo_chnl_ids[i]].lo_odu_rate == UTIL_GLOBAL_ODU3E2)
                && coreotn_handle->var.rx_mo_chnl_ctxt[local_lo_chnl_ids[i]].payload_format != UTIL_GLOBAL_ODU_UNCHANNELIZED) 
            {
                mo_odu3e2_odu3e1 = TRUE;  
                
                if (coreotn_handle->var.extra_entry_ctxt[0].chnl_id == local_lo_chnl_ids[i])
                {
                    extra_cycle = coreotn_handle->var.extra_entry_ctxt[0].cycle;
                }
                else if (coreotn_handle->var.extra_entry_ctxt[1].chnl_id == local_lo_chnl_ids[i])
                {
                    extra_cycle = coreotn_handle->var.extra_entry_ctxt[1].cycle;
                } 
                 
            }   
                    
            result = odtu_mux_lo_chnl_offline_deprov(odtu_mux_handle_ptr,
                                                     (odtu_mux_stage_instance_t)mux_stage,
                                                     local_lo_chnl_ids[i], ho_chnl_id,
                                                     mo_odu3e2_odu3e1, extra_cycle);               
        } 
            
        for (i = 0; i < num_lo_deprov && PMC_SUCCESS == result; i++)
        {                                  
            result = coreotn_db_mo_entry_update(coreotn_handle,
                                                UTIL_GEN_DB_LINE_CORE_OTN_TX_DB,  
                                                local_lo_chnl_ids[i]);                                                 
        }
        
        /* check to see if TX side has been deprovisioned */
        for (i = 0; i < num_lo_deprov && PMC_SUCCESS == result; i++)
        { 
            coreotn_handle->var.tx_mo_chnl_ctxt[local_lo_chnl_ids[i]].payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
        }
    } 
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        for (i = 0; i < num_lo_deprov && PMC_SUCCESS == result; i++)
        { 
            result = odtu_mux_lo_chnl_offline_deprov(coreotn_handle->odtu_mux2_handle,
                                                     (odtu_mux_stage_instance_t)mux_stage,
                                                     local_lo_chnl_ids[i], 
                                                     ho_chnl_id,
                                                     mo_odu3e2_odu3e1, 
                                                     extra_cycle);                                               
        } 
            
        for (i = 0; i < num_lo_deprov && PMC_SUCCESS == result; i++)
        {
            result = coreotn_db_lo_entry_update(coreotn_handle,
                                                UTIL_GEN_DB_LINE_CORE_OTN_TX_DB,  
                                                local_lo_chnl_ids[i]);                                                                                                      
        }
    }                                                   
    
    PMC_RETURN(result);                                                   
    
} /* coreotn_tx_lo_chnl_offline_deprov_all */ 
    
        
/*******************************************************************************
*  coreotn_sysapp_line_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API is used when the ODU channel is provision for the ODUKSW <-> LINEOTN
*   segment for SYSOTN applications.  This API is a wrapper for 
*   coreotn_sysapp_line_chnl_state_set()
*
*   This function also configures COREOTN_CTL:MPMO to provide valid calendar
*   towards the lineside in an application where a maintenace signal is applied
*   on a LO ODU channel without ODUKSW connection. 
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_sysapp_line_chnl_prov(coreotn_handle_t *coreotn_handle,
                                               UINT32 chnl_id)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;

    PMC_ENTRY();

    
    /* provision MPMO CTRL here before enabling ODU_TFRM STG2 
    ** client_bitrate is a DON'T CARE sine CFC is not required in this case
    */
    ret_val = mpmo_ch_prov_for_maint_sig_insertion(coreotn_handle->mpmo_core_ctl_handle, 
                                                   chnl_id,
                                                   0, 128, 0, 0, 0, 
                                                   UTIL_OPSA_T_FRAME_UNUSED,
                                                   FALSE);
                                                       
    /* activate MPMO CTRL */                                                       
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = mpmo_ch_activate_for_maint_sig_insertion(coreotn_handle->mpmo_core_ctl_handle, 
                                                           chnl_id);
    }           

    if(PMC_SUCCESS == ret_val)
    {
          ret_val = odu_struct_tx_maint_sig_dummy_rfrm_cfg(coreotn_handle,
                                                           ODU_STRUCT_LEVEL_LO_ODU,
                                                           chnl_id,
                                                           TRUE);
    }

                                                           
    if (PMC_SUCCESS == ret_val)
    {                                                           
        ret_val = coreotn_sysapp_line_chnl_state_set(coreotn_handle,
                                                     chnl_id,
                                                     COREOTN_CHNL_OPERATIONAL);
    }
    
    PMC_RETURN(ret_val);
} /* coreotn_sysapp_line_chnl_prov */

/*******************************************************************************
*  coreotn_sysapp_line_chnl_prov_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns TRUE when the specified LINE HO container (SYSOTN) is
*    in the provided state 
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   state               - requested state
*
* OUTPUTS:
*
* RETURNS:
*   TRUE: when the specifed channel is provisioned
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 coreotn_sysapp_line_chnl_prov_get(coreotn_handle_t *coreotn_handle,
                                               UINT32 chnl_id,
                                               util_global_chnl_state_t state)
{
    BOOL8 result = FALSE;
    util_global_chnl_state_t act_state = UTIL_GLOBAL_CHNL_START;
    PMC_ENTRY();

    act_state =  (coreotn_handle->var.sysapp_line_state[chnl_id] == COREOTN_CHNL_OPERATIONAL)?
        UTIL_GLOBAL_CHNL_OPERATIONAL:UTIL_GLOBAL_CHNL_START;
    result = (act_state == state);           

    PMC_RETURN(result);
} /* coreotn_sysapp_line_chnl_prov_get */

/*******************************************************************************
*  coreotn_sysapp_line_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API is used when the ODU channel is deprovisioned for the 
*   segment for SYSOTN applications.  This API is a wrapper for 
*   coreotn_sysapp_line_chnl_state_set()
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_sysapp_line_chnl_deprov(coreotn_handle_t *coreotn_handle,
                                                 UINT32 chnl_id)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;

    PMC_ENTRY();

    ret_val = coreotn_sysapp_line_chnl_state_set(coreotn_handle,
                                                 chnl_id,
                                                 COREOTN_CHNL_START);
                                                 
    /* deactivate MPMO channel from COREOTN CTL */                                                 
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = mpmo_ch_deactivate_for_maint_sig_insertion(coreotn_handle->mpmo_core_ctl_handle,
                                                             chnl_id);
    }
                                                
    /* deprovision MPMO channel from COREOTN_CTL */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = mpmo_ch_deprov_for_maint_sig_insertion(coreotn_handle->mpmo_core_ctl_handle,
                                                         chnl_id);
    }
                                                

    PMC_RETURN(ret_val);
} /* coreotn_sysapp_line_chnl_deprov */

/*******************************************************************************
*  coreotn_oduksw_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures LO ODU channel through ODUk Switch to the desired destination.
*
*   This function will configure packet maker and packet monitor blocks in
*   the datapath depending on the source and destination of the data.
*
*   Call coreotn_oif_pkt_period_calc() to calculate packet size and packet
*   period to be used for pkt_size, pkt_period, pkt_per_n, and pkt_per_d in
*   this API.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   input_port          - source of the data. See coreotn_oduk_sw_input_port_t.\n
*   input_chnl_id       - ingress channel ID into ODUk Switch.
*                         Valid range: 0 - 95
*   output_port         - destination of the data.
*                         See coreotn_oduk_sw_output_port_t.\n
*   output_chnl_id      - output channel ID from ODUk Switch
*                         Valid range: 0 - 95
*   odu_type            - LO ODU type. See util_global_odukp_type_t. Use only if
*                         data is to be transmitted to line-side OTN.
*   num_odu0            - if lo_odu_type is ODUFLEX_GFP. Otherwise set to 0.
*                         When used in MPMA, this refers to the ingress data rate.\n
*                         When used in MPMO, this refers to the egress data rate.
*   client_bitrate      - client bit rate in bps if lo_odu_type is ODUFLEX_CBR.
*                         For other LO ODU types, set to 0.
*   pkt_size            - desired packet size to be made by packet maker (= B)
*   pkt_per_int         - integer portion of desired packet period.
*   pkt_per_n           - numerator of desired packet period.
*   pkt_per_d           - denominator of desired packet period.
*   xfer_mode           - Enum, defining the output interface type.  Only
*                         valid for SIFD ports.  Otherwise transfer modes
*                         internally set. See coreotn_oduksw_xfer_mode_t.
*   hys_buffer_en       - custom hysteresis buffer size mode:\n
*                         TRUE : custom hysteresis buffer size mode is enable 
*                         FALSE : custom hysteresis buffer size mode is disabled
*   hys_buffer          - hysteresis buffer size in refclk cycles
*   halt_buffer         - ODUk Switch FIFO buffer room to capture in flight data
*                         in the event that ODUk Switch FIFO generates an
*                         upstream flow control signal.  Used in cases where a
*                         channel is fed from SIFD and asserts XOFF flow control.
*                         halt_buffer is specified in units of blocks.
*                         The block size is 768 bytes
*   hdr_removal_size    - header size for header removal config
*                         supported values : 0-6 bytes
*                         Only valid if input port is SIFD1 or SIFD2.
*                         set to 0 for the port not supporting header removal
*   latency_s           - latency to control data flow from ODUKSW to paket
*                         monitor towards COREOTN.  In units of 3.125 usecond
*                         ticks.
*   bmp_map_mode        - indication if MPMA as input port is used for BMP mapping,
*                         applicable to FO2 only.
*                         TRUE:  FO2 is associated with BMP mapped data stream
*                         FALSE: FO2 is not associated with BMP mapped data stream
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_chnl_prov(coreotn_handle_t *coreotn_handle,
                                          coreotn_oduksw_input_port_type_t input_port,
                                          UINT32 input_chnl_id,
                                          coreotn_oduksw_output_port_type_t output_port,
                                          UINT32 output_chnl_id,
                                          util_global_odukp_type_t odu_type,
                                          UINT32 num_odu0,
                                          DOUBLE client_bitrate,
                                          UINT32 pkt_size,
                                          UINT32 pkt_per_int, UINT32 pkt_per_n,
                                          UINT32 pkt_per_d,
                                          coreotn_oduksw_xfer_mode_t xfer_mode,
                                          BOOL   hys_buffer_en,
                                          UINT32 hys_buffer,
                                          UINT32 halt_buffer,
                                          UINT32 hdr_removal_size,
                                          UINT32 latency_s,
                                          BOOL8 bmp_map_mode)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
 
    util_schd_chnl_rate_exp_t rate_units = UTIL_SCHD_1_BIT_SEC;
    UINT32 p_egress_mux_input_port;
    UINT32 p_rd_channel_id;
    UINT32 p_rd_queue_id;
    DOUBLE loc_client_rate;   
    DOUBLE odu_rate;
    DOUBLE ppm_rate;
    UINT32 scbs3_user_bits = 1;
    UINT32 num_current_blocks = 0;
    DOUBLE epsilon = 0;
    UINT32 out_odu_rate;
    UINT32 hdr_en;
    UINT32 fifo_depth;
    BOOL odu_flex_client = FALSE;
        
    UINT32 ho_chnl_id;
    util_global_odukp_type_t server_odu_type;
    util_opsa_cn_frame_period_t opsa_frame_per = UTIL_OPSA_T_FRAME_UNUSED;
    util_global_odu_line_payload_t payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
    coreotn_chnl_order_t order_type = LAST_COREOTN_CHNL_ORDER;
    odujat_handle_t *odujat_handle_ptr = NULL;
    BOOL8 use_float32_mode = digi_use_float32_get();
  
    PMC_ENTRY();  
    
    PMC_LOG_TRACE("input_port = %u\n, output_port = %u\n", input_port, output_port);

    /* Check arguments */
    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != coreotn_handle->oduksw_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    /* Check only the output since the input can be used multiple time in a multicast */
    if ( coreotn_handle->var.tx_oduksw_chnl_ctxt[output_port][output_chnl_id].state != COREOTN_CHNL_START)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_START);
    }

    /* get rate for ODUKSW */
    if (odu_type != UTIL_GLOBAL_ODUFLEX_CBR && odu_type != UTIL_GLOBAL_ODUFLEX_GFP)
    {
        ret_val = util_global_client_rate_get(odu_type, &odu_rate, &ppm_rate);
        loc_client_rate = odu_rate;

        odu_flex_client = FALSE;
    }
    else {
        if (odu_type == UTIL_GLOBAL_ODUFLEX_GFP)
        {

            odu_flex_client = TRUE;

            if (num_odu0 <= 8)
            {
                if (!use_float32_mode) {
                    odu_rate = (num_odu0 * UTIL_GLOBAL_ODU2_TS_RATE);
                } else {
                    odu_rate = (DOUBLE)(num_odu0 * (FLOAT)UTIL_GLOBAL_ODU2_TS_RATE);
                }
            } 
            else if (num_odu0 <= 32)
            {
                if (!use_float32_mode) {
                    odu_rate = (num_odu0 * UTIL_GLOBAL_ODU3_TS_RATE);
                } else {
                    odu_rate = (DOUBLE)(num_odu0 * (FLOAT)UTIL_GLOBAL_ODU3_TS_RATE);
                }
            } 
            else 
            {
                if (!use_float32_mode) {
                    odu_rate = (num_odu0 * UTIL_GLOBAL_ODU4_TS_RATE);
                } else {
                    odu_rate = (DOUBLE)(num_odu0 * (FLOAT)UTIL_GLOBAL_ODU4_TS_RATE);
                }
            }
        }
        else if (odu_type == UTIL_GLOBAL_ODUFLEX_CBR)
        {
            odu_rate = client_bitrate;
            odu_flex_client = FALSE;
        }
        
        loc_client_rate = odu_rate;
    }
    
    /* convert odu_rate to fit in UINT32 */
    while (odu_rate > COREOTN_UINT32_LIMIT)
    {
        /* increase rate unit */
        if (!use_float32_mode) {
            odu_rate /= 10;
        } else {
            odu_rate = (DOUBLE)((FLOAT)odu_rate/10);
        }
        rate_units = (util_schd_chnl_rate_exp_t)((UINT32)rate_units + 1) ;
    }
    
    /* only use for CPB */
    out_odu_rate = (UINT32)odu_rate;      
    
    PMC_LOG_TRACE("odu_rate = %u\n", out_odu_rate);
    hdr_en = (hdr_removal_size == 0)? 0:1;

    /* read from DB to retrieve the calendar usage in COREOTN 
    ** retrieve the database for the current scheduler state 
    ** query the record to update
    */
    if (PMC_SUCCESS == ret_val)
    {

        ret_val = coreotn_db_ret_sched_populate(coreotn_handle,
                                                output_port,
                                                output_chnl_id,
                                                &ho_chnl_id,
                                                &order_type);
    }
    
    if  (ret_val == PMC_SUCCESS && 
         coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].input_map_count == 0)
    { 

        /* MPMA configuration */    
        switch (input_port)
        {
        case COREOTN_ODUKSW_INPUT_SIFD1:
            if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE 
                || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
            {
                /* configure MPMA in CORE_CTL for SYSOTN mode */                              
                ret_val = mpma_ch_prov(coreotn_handle->mpma_core_ctl_handle, 
                                       input_chnl_id, loc_client_rate, pkt_size, 
                                       UTIL_OPSA_T_FRAME_UNUSED,
                                       UTIL_OPSA_EPS_MIN, scbs3_user_bits, FALSE,
                                       pkt_per_int, pkt_per_n, pkt_per_d, epsilon);                                                        
                    

            }
            break;
        case COREOTN_ODUKSW_INPUT_SIFD2:
            /* no OPSA */
            break;
        case COREOTN_ODUKSW_INPUT_COREOTN: /* from FO1: COREOTN to ODUKSW */
            PMC_LOG_TRACE("loc_client_rate = %f\n",  loc_client_rate);              

            if (TRUE == pmc_coreotn_odujat_enable_for_128B_pkt(&coreotn_handle->base))
            {
                if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
                {
                    /* one stage demuxing or unchannelized HO */
                    odujat_handle_ptr = coreotn_handle->odujat2_handle;
                }
                else {
                    if (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)
                    {
                        /*  two stage demuxing */
                        if (order_type == COREOTN_CHNL_ORDER_LO)
                        {
                            odujat_handle_ptr = coreotn_handle->odujat2_handle;
                        }
                        else {
                            /* one stage demuxing or unchannelized HO */
                            odujat_handle_ptr = coreotn_handle->odujat1_handle;
                        }
                    }
                    else if (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE)
                    {
                        /* one stage demuxing or unchannelized HO */
                        odujat_handle_ptr = coreotn_handle->odujat1_handle;
                    }
                }

                /* filter out unchanneliezd channels */
                if (pkt_size >= 112 && pkt_size <= 124 && (odu_type == UTIL_GLOBAL_ODUFLEX_GFP || odu_type == UTIL_GLOBAL_ODUFLEX_CBR))
                {
                    ret_val = odujat_chnl_enable(odujat_handle_ptr, 
                                                 input_chnl_id, TRUE);
                }
            }

            ret_val = mpma_ch_prov(coreotn_handle->mpma_fo1_handle,
                                   input_chnl_id, loc_client_rate, pkt_size,
                                   UTIL_OPSA_T_FRAME_UNUSED,
                                   UTIL_OPSA_EPS_MIN, scbs3_user_bits,
                                   FALSE, pkt_per_int,
                                   pkt_per_n, pkt_per_d, epsilon);

            break;
        case  COREOTN_ODUKSW_INPUT_MAPOTN: /* from FO2: MAPOTN to ODUKSW */
            /* configure MPMA in FO #2 */
            PMC_LOG_TRACE("loc_client_rate = %f\n",  loc_client_rate);

            ret_val = mpma_fo2_ch_prov(coreotn_handle->mpma_fo2_handle,
                                       input_chnl_id, loc_client_rate, pkt_size,
                                       UTIL_OPSA_T_FRAME_UNUSED,
                                       UTIL_OPSA_EPS_MIN, scbs3_user_bits,
                                       FALSE, pkt_per_int,
                                       pkt_per_n, pkt_per_d, epsilon, bmp_map_mode);
            break; 
        default:
            PMC_RETURN(COREOTN_ERR_INVALID_ARG);
        }  
    }  
  
    /* read from DB to retrieve the calendar usage in COREOTN 
    ** retrieve the database for the current scheduler state 
    ** query the record to update
    
    if (PMC_SUCCESS == ret_val)
    {

        ret_val = coreotn_db_ret_sched_populate(coreotn_handle,
                                                output_port,
                                                output_chnl_id,
                                                &ho_chnl_id,
                                                &order_type);
    }*/
    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
    if (PMC_SUCCESS == ret_val)
    {
        PMC_LOG_TRACE("odu_rate = %f\n", odu_rate);
        
        PMC_LOG_TRACE("odu_rate = %u\n", (UINT32)odu_rate);
        /* need to understand valid range of input_port/output_port here */
        ret_val = cpb_ocpb_chnl_prov(coreotn_handle->oduksw_handle, input_port, 
                                     input_chnl_id, output_port, output_chnl_id,
                                     out_odu_rate, rate_units, halt_buffer, hdr_en);
    }                          
                            
    /* get channel source */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = cpb_dcs_egress_dpi_chnl_source_get(coreotn_handle->oduksw_handle, 
                                                     output_port, output_chnl_id,
                                                     &p_egress_mux_input_port, 
                                                     &p_rd_channel_id, 
                                                     &p_rd_queue_id);
    }

    /* get number of blocks in ODUKSW */
    if (PMC_SUCCESS == ret_val)
    {
        /* p_egress_mux_input_port -> pop_port_id
        ** p_rd_queue_id -> read_qid 
        */   
        ret_val = cpb_queue_num_block_get(coreotn_handle->oduksw_handle,
                                          p_egress_mux_input_port, p_rd_queue_id,
                                          &num_current_blocks);

        /* only retrieve the number of blocks used for internal use, do not
           include any blocks assigned for halt_buffer */
        num_current_blocks -= halt_buffer;

    }  



    /* convert number of blocks in number of bytes */
    fifo_depth = num_current_blocks * 16;
    
    if(PMC_SUCCESS == ret_val)
    {
        if(hys_buffer_en)
        {    
            /*check that the specified latency is less than the default hysteresis buffer latency. */
            ret_val = coreotn_hys_latency_range_chk(coreotn_handle,output_port,
                                                    output_chnl_id, loc_client_rate, 
                                                    pkt_size, hys_buffer);
        }
    }

    
    if (PMC_SUCCESS == ret_val)
    {                                               
        /* MPMO configuration */                                 
        switch (output_port)
        {
        case COREOTN_ODUKSW_OUTPUT_SIFD1: /* to SIFD1 */
      
            if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE ||
                coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
            {
                if (coreotn_handle->var.prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
                {
                    ret_val = mpmo_ch_prov(coreotn_handle->mpmo_core_ctl_handle,
                                           output_chnl_id, loc_client_rate, pkt_size,
                                           pkt_per_int, pkt_per_n, pkt_per_d,
                                           UTIL_OPSA_T_FRAME_UNUSED, FALSE);
                }

                if (PMC_SUCCESS == ret_val) 
                {
                    ret_val = mpmo_ch_latency_cfg(coreotn_handle->mpmo_core_ctl_handle, 
                                                  output_chnl_id, loc_client_rate, pkt_size, 
                                                  fifo_depth, hys_buffer_en, hys_buffer, latency_s, 
                                                  S_OLD_RATIO,
                                                  odu_flex_client,
                                                  num_odu0);
                }
            }          
            break;
        case COREOTN_ODUKSW_OUTPUT_SIFD2: /* to SIFD2 */
            /* no OPSA */
            break;
        case COREOTN_ODUKSW_OUTPUT_COREOTN: /* to COREOTN */
            if (order_type == COREOTN_CHNL_ORDER_LO)
            {
                server_odu_type = coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].odu_container; 
                payload_format = coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].payload_format;
            }
            else {
                server_odu_type = coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].odu_container; 
                payload_format = coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].payload_format;
            }  
                    
            /* MPMO in FO1 */
            if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL || coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
            {
                ret_val = coreotn_mpmo_cn_frame_period_set(server_odu_type, 
                                                           odu_type,
                                                           payload_format,
                                                           &opsa_frame_per);
            }
            else if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
            {
                /* do nothing */
            }

            PMC_LOG_TRACE("loc_client_rate = %f\n",  loc_client_rate);    
                                                                   
            if (PMC_SUCCESS == ret_val)
            {   
                if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL)
                {
                    ret_val = mpmo_ch_super_prov(coreotn_handle->mpmo_fo1_handle, 
                                                 output_chnl_id, loc_client_rate, pkt_size, 
                                                 pkt_per_int, pkt_per_n, pkt_per_d, 
                                                 opsa_frame_per, FALSE, odu_type);
                }
                else if(coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
                {
                    ret_val = mpmo_ch_prov(coreotn_handle->mpmo_fo1_handle, 
                                           output_chnl_id, loc_client_rate, pkt_size, 
                                           pkt_per_int, pkt_per_n, pkt_per_d, 
                                           opsa_frame_per, FALSE);
                }
                else if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
                {
                    /* do nothing */
                }
            }      
                                                 
            if (PMC_SUCCESS == ret_val)
            {
                /* COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK mode needs to do latency cfg as well */

                ret_val = mpmo_ch_latency_cfg(coreotn_handle->mpmo_fo1_handle, 
                                              output_chnl_id, loc_client_rate, pkt_size, 
                                              fifo_depth, hys_buffer_en, hys_buffer, latency_s, 
                                              S_OLD_RATIO,
                                              odu_flex_client,
                                              num_odu0);
            }
            break;            
        case COREOTN_ODUKSW_OUTPUT_MAPOTN: /* to MAPOTN */ 
            /* MPMO in FO2 */
            PMC_LOG_TRACE("loc_client_rate = %f\n",  loc_client_rate);
            PMC_LOG_TRACE("pkt_size:%d, pkt_per_int:%d, pkt_per_n:%d, pkt_per_d:%d\n", pkt_size, 
                          pkt_per_int, pkt_per_n, pkt_per_d);
            if (coreotn_handle->var.prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
            {
                ret_val = mpmo_ch_prov(coreotn_handle->mpmo_fo2_handle, 
                                       output_chnl_id, loc_client_rate, pkt_size, 
                                       pkt_per_int, pkt_per_n, pkt_per_d, 
                                       UTIL_OPSA_T_FRAME_UNUSED, FALSE);
            }
            
            if (PMC_SUCCESS == ret_val)
            {   
                ret_val = mpmo_ch_latency_cfg(coreotn_handle->mpmo_fo2_handle, 
                                              output_chnl_id, loc_client_rate, pkt_size, 
                                              fifo_depth, hys_buffer_en, hys_buffer, latency_s, 
                                              S_OLD_RATIO,
                                              odu_flex_client,
                                              num_odu0);
            }               
            break; 
        default:
            PMC_RETURN(COREOTN_ERR_INVALID_ARG);
        }
    }

    /* update ODUKSW context */
    if (PMC_SUCCESS == ret_val)
    {             
        coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].input_map_count++;
        coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].state = COREOTN_CHNL_EQUIPPED;
        coreotn_handle->var.tx_oduksw_chnl_ctxt[output_port][output_chnl_id].state = COREOTN_CHNL_EQUIPPED;
    }

    PMC_RETURN(ret_val);
} /* coreotn_oduksw_chnl_prov */

/*******************************************************************************
*  coreotn_oduksw_chnl_prov_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns if the specified data path (based on the source and 
*   destination) is in the provided state
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   input_port          - source of the data. See coreotn_oduk_sw_input_port_t.\n
*   input_chnl_id       - ingress channel ID into ODUk Switch.
*                         Valid range: 0 - 95
*   output_port         - destination of the data.
*                         See coreotn_oduk_sw_output_port_t.\n
*   output_chnl_id      - output channel ID from ODUk Switch
*                         Valid range: 0 - 95
*   state               - The state that checked by this function 
*
* OUTPUTS:
*   NONE
*
* RETURNS:
*   TRUE whe  the data path is in the provided state, otherwise FALSE
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 coreotn_oduksw_chnl_prov_get(coreotn_handle_t *coreotn_handle,
                                          coreotn_oduksw_input_port_type_t input_port,
                                          UINT32 input_chnl_id,
                                          coreotn_oduksw_output_port_type_t output_port,
                                          UINT32 output_chnl_id,
                                          util_global_chnl_state_t state)
{
    BOOL8 result = FALSE;

    PMC_ENTRY();

    /* Check arguments */
    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != coreotn_handle->oduksw_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(state <= UTIL_GLOBAL_CHNL_OPERATIONAL, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(!(input_port >= COREOTN_OCPB_NUM_PORT || output_port >= COREOTN_OCPB_NUM_PORT || 
                 input_chnl_id >= COREOTN_MAX_NUM_LO_CHNL || output_chnl_id >= COREOTN_MAX_NUM_LO_CHNL),COREOTN_ERR_INVALID_ARG, 0, 0);

    if (coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].state == (coreotn_chnl_state_t) state &&
        coreotn_handle->var.tx_oduksw_chnl_ctxt[output_port][output_chnl_id].state == (coreotn_chnl_state_t) state)
    {
        result = TRUE;
    }
    PMC_RETURN(result);        
} /*coreotn_oduksw_chnl_prov_get */

/*******************************************************************************
*  coreotn_oduksw_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures LO ODU channel through ODUk Switch to the desired destination.
*
*   This function will configure packet maker and packet monitor blocks in
*   the datapath depending on the source and destination of the data.
*
*   Call coreotn_oif_pkt_period_calc() to calculate packet size and packet
*   period to be used for pkt_size, pkt_period, pkt_per_n, and pkt_per_d in
*   this API.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   input_port          - source of the data. See coreotn_oduk_sw_input_port_t.\n
*   input_chnl_id       - ingress channel ID into ODUk Switch.
*                         Valid range: 0 - 95
*   output_port         - destination of the data.
*                         See coreotn_oduk_sw_output_port_t.\n
*   output_chnl_id      - output channel ID from ODUk Switch
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_chnl_deprov(coreotn_handle_t *coreotn_handle,
                                            coreotn_oduksw_input_port_type_t input_port,
                                            UINT32 input_chnl_id,
                                            coreotn_oduksw_output_port_type_t output_port,
                                            UINT32 output_chnl_id)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;

    PMC_ENTRY();
    
    PMC_LOG_TRACE("input_port = %u, output_port = %u\n", input_port, output_port);
    
    /* Check arguments */
    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != coreotn_handle->oduksw_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    /* argument checking */
    if (input_port >= COREOTN_OCPB_NUM_PORT || output_port >= COREOTN_OCPB_NUM_PORT
        || input_chnl_id > 95 || output_chnl_id > 95)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }
   
    if ( coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].state != COREOTN_CHNL_EQUIPPED
         && coreotn_handle->var.tx_oduksw_chnl_ctxt[output_port][output_chnl_id].state != COREOTN_CHNL_EQUIPPED)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED);
    }

    /* check if this is a broadcast or a multicast channel 
    ** if this is the primary broadcast channel or a primary multicast channel 
    ** then deprov last 
    */
    if (coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].input_map_count == 1)
    {
        /* MPMA configuration */
        if (PMC_SUCCESS == ret_val)
        {
            switch (input_port)
            {
            case COREOTN_ODUKSW_INPUT_SIFD1:
                if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE 
                    || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
                {
                    ret_val = mpma_ch_deprov(coreotn_handle->mpma_core_ctl_handle,
                                             input_chnl_id);
                }
                break;
            case COREOTN_ODUKSW_INPUT_SIFD2:
                /* no OPSA */
                break;
            case COREOTN_ODUKSW_INPUT_COREOTN:
                /* from COREOTN to ODUKSW */

                ret_val = mpma_ch_deprov(coreotn_handle->mpma_fo1_handle,
                                         input_chnl_id);
                break;
            case  COREOTN_ODUKSW_INPUT_MAPOTN:
                /* from MAPOTN to ODUKSW */

                /* configure MPMA in FO #2 */
                ret_val = mpma_ch_deprov(coreotn_handle->mpma_fo2_handle,
                                         input_chnl_id);
                break;
            default:
                PMC_RETURN(COREOTN_ERR_INVALID_ARG);
            }
        }
    }
    
    if (PMC_SUCCESS == ret_val)
    {
        /* MPMO configuration */
        switch (output_port)
        {
        case COREOTN_ODUKSW_OUTPUT_SIFD1: /* to SIFD1 */
            if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE 
                || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
            {
                if (coreotn_handle->var.prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
                {
                    ret_val = mpmo_ch_deprov(coreotn_handle->mpmo_core_ctl_handle,
                                             output_chnl_id);
                }
            }
            break;
        case COREOTN_ODUKSW_OUTPUT_SIFD2: /* to SIFD2 */
            /* no OPSA */
            break;
        case COREOTN_ODUKSW_OUTPUT_COREOTN: /* to COREOTN */
            /* MPMO in FO1 */  
            if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL)
            {
                ret_val = mpmo_ch_deprov_super_deprov(coreotn_handle->mpmo_fo1_handle, 
                                                      output_chnl_id);
            }
            else if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
            {
                ret_val = mpmo_ch_deprov(coreotn_handle->mpmo_fo1_handle,
                                         output_chnl_id);                                 
            }
            else if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
            {
                /* do nothing */
            }
            break;
        case COREOTN_ODUKSW_OUTPUT_MAPOTN: /* to MAPOTN */
            /* MPMO in FO2 */

            if (coreotn_handle->var.prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
            {
                ret_val = mpmo_ch_deprov(coreotn_handle->mpmo_fo2_handle,
                                         output_chnl_id);
            }
           break;
        default:
            PMC_RETURN(COREOTN_ERR_INVALID_ARG);
        }
    }
    
    if (PMC_SUCCESS == ret_val && coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL)
    {
        
        ret_val = cpb_chnl_deprov_super_deprov(coreotn_handle->oduksw_handle,
                                               output_port, output_chnl_id );        
    }   
    else {
        /* deprovision an ODUKSW channel */
        ret_val = cpb_chnl_deprov(coreotn_handle->oduksw_handle,
                                  output_port, output_chnl_id, FALSE);
    }                                                                          

    /* update ODUKSW context */
    if (PMC_SUCCESS == ret_val)
    {     
        coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].input_map_count--;

        if (0 == coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].input_map_count)
        {
            coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].state = COREOTN_CHNL_START;
        }
        coreotn_handle->var.tx_oduksw_chnl_ctxt[output_port][output_chnl_id].state = COREOTN_CHNL_START; 
    }

    PMC_RETURN(ret_val);
} /* coreotn_oduksw_chnl_deprov */

/*******************************************************************************
* coreotn_ho_chnl_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function is used to activate the HO or MO channel depending on the
*   multiplexing stage. Activation of the HO or MO channel swaps the configuration
*   page within MUX and DMX blocks.
* 
*   This function configures the offline page for HO or MO after the channel
*   has been activated.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - Enum, see coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ho_chnl_activate(coreotn_handle_t *coreotn_handle,
                                          UINT32 chnl_id,
                                          coreotn_mux_stage_t mux_stage)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();

    result = coreotn_tx_ho_chnl_activate(coreotn_handle, chnl_id, mux_stage);
                                              
    if (PMC_SUCCESS == result)
    {
        result = coreotn_rx_ho_chnl_activate(coreotn_handle, chnl_id, mux_stage);
    }

    PMC_RETURN(result);
} /* coreotn_ho_chnl_activate */

/*******************************************************************************
* coreotn_ho_chnl_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function deactivates the HO or MO channel depending on the multiplexing
*   stage.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - Enum, see coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ho_chnl_deactivate(coreotn_handle_t *coreotn_handle,
                                            UINT32 chnl_id,
                                            coreotn_mux_stage_t mux_stage)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    result = coreotn_tx_ho_chnl_deactivate(coreotn_handle, chnl_id, mux_stage);
                                              
    if (PMC_SUCCESS == result)
    {
        result = coreotn_rx_ho_chnl_deactivate(coreotn_handle, chnl_id, mux_stage);
    }

    PMC_RETURN(result);
} /* coreotn_ho_chnl_deactivate */

/*******************************************************************************
*  coreotn_oduksw_chnl_activate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API is used to activate the ODUk channel that has been mapped across
*   ODUKSW interface.
* 
*   This API activates the MPMA channel in the source direction, activates
*   ODUKSW channel, and then activates the corresponding MPMO channel in the
*   destination direction.
* 
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   input_port          - Enum for ODUKSW input port. See coreotn_oduksw_input_port_type_t.
*   input_chnl_id       - channel ID to be configured.
*                         Valid range: 0 - 95
*   output_port         - Enum for ODUKSW output port. See coreotn_oduksw_output_port_type_t.
*   output_chnl_id      - channel ID to be configured.
*                         Valid range: 0 - 95  
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_chnl_activate(coreotn_handle_t *coreotn_handle,
                                              coreotn_oduksw_input_port_type_t input_port,
                                              UINT32 input_chnl_id,
                                              coreotn_oduksw_output_port_type_t output_port,
                                              UINT32 output_chnl_id)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    BOOL is_reader_primary;
    BOOL is_slave_zone_primary;
    BOOL is_broadcast;
    BOOL is_multicast;
    
    /* this is used to extract the ODU level of the channel so we can pick the proper TFRM channel to enable */
    coreotn_chnl_order_t order_type;
    line_core_otn_db_query_res *q_result = NULL;
    odtu_mux_handle_t *lo_mux_handle_ptr = NULL;
    util_global_odukp_type_t odu_container = UTIL_GLOBAL_LAST_ODUK;
    UINT32 sub_chnls_prov_cnt= 0;
    UINT32 chnl_id = 0;
    UINT32 ho_chnl_id = 0;
    UINT32 num_of_recs = 0;
    UINT32 test_chnl_id = 0;
    UINT32 db_inst = 0;

    PMC_ENTRY();

    /* check to see if the channel is provisioned */
    if ( coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].state != COREOTN_CHNL_EQUIPPED
         && coreotn_handle->var.tx_oduksw_chnl_ctxt[output_port][output_chnl_id].state != COREOTN_CHNL_EQUIPPED)

    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED);
    }            

    ret_val = coreotn_oduksw_chnl_type_get(coreotn_handle, output_port,
                                           output_chnl_id,
                                           &is_reader_primary,
                                           &is_slave_zone_primary,
                                           &is_broadcast,
                                           &is_multicast);
    
    /* in the event of multicasting at ODUKSW, it's not allowed to activate 
    ** the MPMA (source) more than once. */


    if (PMC_SUCCESS == ret_val 
        && (coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].dest_active_count == 0))       
    { 
        switch (input_port)
        {
        case COREOTN_ODUKSW_INPUT_SIFD1:
            /* no OPSA */
            if(coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE ||
               coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
            {

                if(coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
                {
                    /* MPMA "bulk" operator @ CTL is only supported for ODUKSW ONLY */
                    ret_val = mpma_ch_activate_super_prov(coreotn_handle->mpma_core_ctl_handle,
                                                          input_chnl_id, TRUE);
                }
                else
                {
                    /* configure MPMA in CORE_CTL */
                    ret_val = mpma_ch_activate(coreotn_handle->mpma_core_ctl_handle,
                                               input_chnl_id, TRUE);
                }
            }
            break;
        case COREOTN_ODUKSW_INPUT_SIFD2:
            /* no OPSA */
            break;
        case COREOTN_ODUKSW_INPUT_COREOTN: /* from COREOTN to ODUKSW */
            if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL ||
                coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
            {
                ret_val = mpma_ch_activate_super_prov(coreotn_handle->mpma_fo1_handle,
                                                      input_chnl_id, TRUE);   
            }
            else
            {
                ret_val = mpma_ch_activate(coreotn_handle->mpma_fo1_handle,
                                           input_chnl_id, TRUE); 
            }
            break;
        case  COREOTN_ODUKSW_INPUT_MAPOTN: /* from MAPOTN to ODUKSW */
            
            if(coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
            {
                /*MPMA "bulk" operator @ MAPOTN is only supported for ODUKSW ONLY */
                ret_val = mpma_ch_activate_super_prov(coreotn_handle->mpma_fo2_handle,
                                                      input_chnl_id, TRUE); 
            }
            else
            {
                /* configure MPMA in FO #2 */
                ret_val = mpma_ch_activate(coreotn_handle->mpma_fo2_handle,
                                           input_chnl_id, TRUE);              
            }
            break;
        default:
            PMC_RETURN(COREOTN_ERR_INVALID_ARG);
        }
    }
    
    if (PMC_SUCCESS == ret_val)
    {
        if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL || coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
        {
            ret_val = cpb_chnl_activate_super_prov(coreotn_handle->oduksw_handle,
                                                   output_port, output_chnl_id);
        }
        else
        {
            ret_val = cpb_chnl_activate(coreotn_handle->oduksw_handle,
                                        output_port, output_chnl_id);
        }
    }
    

    if (PMC_SUCCESS == ret_val)
    {
        /* MPMO configuration */
        switch (output_port)
        {
        case COREOTN_ODUKSW_OUTPUT_SIFD1: /* to SIFD1 */
            if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE 
                || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
            {
                if (coreotn_handle->var.prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
                {
                    ret_val = mpmo_ch_activate(coreotn_handle->mpmo_core_ctl_handle,
                                               output_chnl_id);
                }
            }
            break;
        case COREOTN_ODUKSW_OUTPUT_SIFD2: /* to SIFD2 */
            /* no OPSA */
            break;
        case COREOTN_ODUKSW_OUTPUT_COREOTN: /* to COREOTN */
            /* MPMO in FO1 */
            if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL)
            {
                ret_val = mpmo_ch_activate_super_prov(coreotn_handle->mpmo_fo1_handle, 
                                                      output_chnl_id);  
            }
            else if(coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
            {
                ret_val = mpmo_ch_activate(coreotn_handle->mpmo_fo1_handle,
                                           output_chnl_id);
            }
            else if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
            {
                /* do nothing here */
            }
            break;
        case COREOTN_ODUKSW_OUTPUT_MAPOTN: /* to MAPOTN */
            /* Do nothing here because FO2 MPMO is activated in digi_cpb_chnl_activate() 
            ** after mapotn_demapper_activate() 
            */
            /* MPMO in FO2 */

            break;
                
        default:
            PMC_RETURN(COREOTN_ERR_INVALID_ARG);
        }
    }

  
    if (output_port == COREOTN_ODUKSW_OUTPUT_COREOTN || input_port == COREOTN_ODUKSW_INPUT_COREOTN)
    {
        if (output_port == COREOTN_ODUKSW_OUTPUT_COREOTN)
        {
            test_chnl_id = output_chnl_id;
            db_inst = 0; /*TX DB*/
        }
        else if (input_port == COREOTN_ODUKSW_INPUT_COREOTN)
        {
            test_chnl_id = input_chnl_id;
            db_inst = 1; /*RX DB*/
        }
        
        /* find the channel level */
        num_of_recs = 0; /* set to 0 to flag whether to free later */
        if (PMC_SUCCESS == ret_val)
        {
            /* determine the ODU level of the channel */
            ret_val = coreotn_chnl_id_and_order_get(coreotn_handle,
                                                    test_chnl_id,
                                                    db_inst,
                                                    &chnl_id,
                                                    &ho_chnl_id,
                                                    &order_type,
                                                    &num_of_recs,
                                                    &q_result);
        }
        
        if (PMC_SUCCESS == ret_val)
        {
            switch(order_type) 
            {
            case COREOTN_CHNL_ORDER_HO:
                lo_mux_handle_ptr = NULL;
                /* this is no muxing case where HO is being activated at ODUKSW 
                ** activate TFRM STG1 channel 
                */
                break;
            case COREOTN_CHNL_ORDER_MO:

                sub_chnls_prov_cnt = coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt;
                odu_container = coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].odu_container;
                /* this is one stage muxing case where MO is unchannelized 
                ** and activated at ODUKSW. Activate TFRM STG2 channel
                */

                break;
            case COREOTN_CHNL_ORDER_LO:

                sub_chnls_prov_cnt = coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt;
                lo_mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
                odu_container = coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].odu_container;

                break;
            default:
                ret_val = COREOTN_ERR_INVALID_ARG;
            }
        }

    }
   

    if (output_port == COREOTN_ODUKSW_OUTPUT_COREOTN)
    {
        /* step 1) enable ODU3B RFRM after MPMO has been activated */
        if (PMC_SUCCESS == ret_val)
        {
            if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL || coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
            {
                ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stg3b_handle, output_chnl_id, 1, 1);
            }
            else if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
            {
                /* do nothing here */
            }
        }

        /* step 3) Apply patch if required. */

        if (PMC_SUCCESS == ret_val) 
        {
            if ((lo_mux_handle_ptr != NULL) && (sub_chnls_prov_cnt == 1)) 
            {                   
                /* disable somf_sync after enabling the channel in MPMO, otherwise 
                 * a de-sync in the HO channel will be caused
                 */
                ret_val = coreotn_rev_a_somf_sync_patch(coreotn_handle,
                                                        lo_mux_handle_ptr,
                                                        odu_container, 
                                                        ho_chnl_id,
                                                        FALSE); 
            }
        }
    }
    else if(output_port == COREOTN_ODUKSW_OUTPUT_MAPOTN)
    {
        if (PMC_SUCCESS == ret_val)  
        {
            ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stg4_handle, output_chnl_id, 1, 1);
        }                              
    }
    else if(output_port == COREOTN_ODUKSW_OUTPUT_SIFD1 &&
            (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE ||
             coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE))
    {
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stg2_handle, output_chnl_id, 1, 1);
        }
    }


    if (input_port == COREOTN_ODUKSW_INPUT_COREOTN)
    {
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odu_tfrm_chnl_init(coreotn_handle->odu_tfrm_stg3b_handle, input_chnl_id, 1);
        }
    }
    else if(input_port == COREOTN_ODUKSW_INPUT_SIFD1 &&
            (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE ||
            coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE))
    {
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odu_tfrm_chnl_init(coreotn_handle->odu_tfrm_stg2_handle, input_chnl_id, 1);
        }
    }

    
    if (PMC_SUCCESS == ret_val)
    {       
        coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].dest_active_count++;  
        coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].state = COREOTN_CHNL_OPERATIONAL;
        coreotn_handle->var.tx_oduksw_chnl_ctxt[output_port][output_chnl_id].state = COREOTN_CHNL_OPERATIONAL;
    }
 
    PMC_RETURN(ret_val);
} /* coreotn_oduksw_chnl_activate */

/*******************************************************************************
*  coreotn_oduksw_chnl_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API is used to deactivate an ODUKSW channel.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   input_port          - Enum for ODUKSW input port. See coreotn_oduksw_input_port_type_t.
*   input_chnl_id       - channel ID to be configured.
*                         Valid range: 0 - 95
*   output_port         - Enum for ODUKSW output port. See coreotn_oduksw_output_port_type_t.
*   output_chnl_id      - channel ID to be configured.
*                         Valid range: 0 - 95
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_chnl_deactivate(coreotn_handle_t *coreotn_handle,
                                                coreotn_oduksw_input_port_type_t input_port,
                                                UINT32 input_chnl_id,
                                                coreotn_oduksw_output_port_type_t output_port,
                                                UINT32 output_chnl_id)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    BOOL is_reader_primary;
    BOOL is_slave_zone_primary;
    BOOL is_broadcast;
    BOOL is_multicast;

    /* this is used to extract the ODU level of the channel so we can pick the proper TFRM channel to enable */
    coreotn_chnl_order_t order_type;
    line_core_otn_db_query_res *q_result = NULL;
    odtu_mux_handle_t *lo_mux_handle_ptr = NULL;
    util_global_odukp_type_t odu_container  = UTIL_GLOBAL_LAST_ODUK;    
    UINT32 sub_chnls_prov_cnt = 0;
    UINT32 chnl_id = 0;
    UINT32 ho_chnl_id = 0;
    UINT32 num_of_recs = 0;
    UINT32 test_chnl_id = 0;
    UINT32 db_inst = 0;  
    coreotn_odu_chnl_prov_mode_t prov_mode; 
    
    PMC_ENTRY();

    /* check the channel state to see if it is operational */
    if ( coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].state != COREOTN_CHNL_OPERATIONAL
         && coreotn_handle->var.tx_oduksw_chnl_ctxt[output_port][output_chnl_id].state != COREOTN_CHNL_OPERATIONAL)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_OPERATIONAL);
    }

    /* get coreotn prov_mode */
    ret_val = coreotn_odu_chnl_prov_mode_get(coreotn_handle, &prov_mode);
    
    ret_val = coreotn_oduksw_chnl_type_get(coreotn_handle, output_port,
                                           output_chnl_id,
                                           &is_reader_primary,
                                           &is_slave_zone_primary,
                                           &is_broadcast,
                                           &is_multicast);
  
    if (PMC_SUCCESS == ret_val)
    {
        /* If it's a broadcast or multicast primary channel, then only deactivate 
        ** if there are no secondary readers active 
        */
        if (is_multicast == TRUE && is_reader_primary == TRUE && 
            coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].dest_active_count > 1) 
        {            
            ret_val = COREOTN_ERR_PRIMARY_UNABLE_TO_DEACTIVATE;
        }
           
        if (is_broadcast == TRUE && is_slave_zone_primary == TRUE &&
            coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].dest_active_count > 1) 
        {            
            ret_val = COREOTN_ERR_PRIMARY_UNABLE_TO_DEACTIVATE;
        }            
    }

    
    if (output_port == COREOTN_ODUKSW_OUTPUT_COREOTN || input_port == COREOTN_ODUKSW_INPUT_COREOTN)
    {
        if (output_port == COREOTN_ODUKSW_OUTPUT_COREOTN)
        {
            test_chnl_id = output_chnl_id;
            db_inst = 0; /*TX DB*/
        }
        else if (input_port == COREOTN_ODUKSW_INPUT_COREOTN)
        {
            test_chnl_id = input_chnl_id;
            db_inst = 1; /*RX DB*/
        }
        
        /* find the channel level */
        num_of_recs = 0; /* set to 0 to flag whether to free later */
        if (PMC_SUCCESS == ret_val)
        {
            /* determine the ODU level of the channel */
            ret_val = coreotn_chnl_id_and_order_get(coreotn_handle,
                                                    test_chnl_id,
                                                    db_inst,
                                                    &chnl_id,
                                                    &ho_chnl_id,
                                                    &order_type,
                                                    &num_of_recs,
                                                    &q_result);
        }
        

        if (PMC_SUCCESS == ret_val)
        {
            switch(order_type) 
            {
            case COREOTN_CHNL_ORDER_HO:
                lo_mux_handle_ptr = NULL;

                break;
            case COREOTN_CHNL_ORDER_MO:
                sub_chnls_prov_cnt = coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt;
                odu_container = coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].odu_container;
                break;
            case COREOTN_CHNL_ORDER_LO:
                sub_chnls_prov_cnt = coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt;
                lo_mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
                odu_container = coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].odu_container;
                break;
            default:
                ret_val = COREOTN_ERR_INVALID_ARG;
            }
        }
        
    }

    if (output_port == COREOTN_ODUKSW_OUTPUT_COREOTN)
    {
        /* step 2) disable ODU3B RFRM before MPMO gets deactivated.
        Do not clear RFRM configuration. */
        if (PMC_SUCCESS == ret_val)
        {
            if (prov_mode == COREOTN_ODU_CHNL_PROV_ALL || prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT) {
                ret_val = odu_rfrm_chnl_prov(coreotn_handle->odu_rfrm_stg3b_handle,
                                             output_chnl_id, FALSE, 0, 0, FALSE);
            } else if (prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK) {
                /* do nothing here */
            }
        }
        
        if (PMC_SUCCESS == ret_val && 
            lo_mux_handle_ptr != NULL && 
            output_port == COREOTN_ODUKSW_OUTPUT_COREOTN && 
            sub_chnls_prov_cnt == 1)
        {
            /* enable somf_sync before disabling the channel in MPMO, otherwise that will cause a 
               de-sync in the HO channel
            */
            ret_val = coreotn_rev_a_somf_sync_patch(coreotn_handle,
                                                    lo_mux_handle_ptr,
                                                    odu_container, 
                                                    ho_chnl_id,
                                                    TRUE); 
        }
    }
    else if(output_port == COREOTN_ODUKSW_OUTPUT_MAPOTN)
    {
        /*disable channel at stage 4, but keep configuration*/
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odu_rfrm_chnl_prov(coreotn_handle->odu_rfrm_stg4_handle,
                                         output_chnl_id, FALSE, 0, 0, FALSE);
        }
    }
    else if(output_port == COREOTN_ODUKSW_OUTPUT_SIFD1 &&
            (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE ||
            coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE))
    {
        /*disable channel at stage 2, but keep configuration*/
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odu_rfrm_chnl_prov(coreotn_handle->odu_rfrm_stg2_handle,
                                         output_chnl_id, FALSE, 0, 0, FALSE);
        }
    }
    
    /* Disable data source if it is not used by other downstream data paths */
  /* If it's a broadcast or multicast, it needs to be the primary */
    if  (ret_val == PMC_SUCCESS &&
         ((is_broadcast == FALSE && is_multicast == FALSE) 
          || (is_broadcast == TRUE && is_slave_zone_primary == TRUE) 
          || (is_multicast == TRUE && is_reader_primary == TRUE)))
    {

        switch (input_port)
        {
        case COREOTN_ODUKSW_INPUT_SIFD1:
            if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE 
                || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
            {
                if (prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
                {
                    /* bulk operator for CTL MPMA only supported in ODUKSW ONLY */
                    ret_val = mpma_ch_deactivate_super_prov(coreotn_handle->mpma_core_ctl_handle,
                                                            input_chnl_id);
                }
                else
                {
                    /* configure MPMA in CORE_CTL */
                    ret_val = mpma_ch_deactivate(coreotn_handle->mpma_core_ctl_handle,
                                                 input_chnl_id);
                }
            }
            break;
        case COREOTN_ODUKSW_INPUT_SIFD2:
            /* no OPSA */
            break;
        case COREOTN_ODUKSW_INPUT_COREOTN:
        {
            /* from COREOTN to ODUKSW */
            if (prov_mode == COREOTN_ODU_CHNL_PROV_ALL ||
                prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
            {
                ret_val = mpma_ch_deactivate_super_prov(coreotn_handle->mpma_fo1_handle, 
                                                        input_chnl_id);
            }
            else
            {
                ret_val = mpma_ch_deactivate(coreotn_handle->mpma_fo1_handle,
                                             input_chnl_id);
            }
        }
        break;

        case  COREOTN_ODUKSW_INPUT_MAPOTN:
        {
            /* from MAPOTN to ODUKSW */
            if (prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
            {
                /* bulk operator for FO2 MPMA only supported in ODUKSW ONLY */
                ret_val = mpma_ch_deactivate_super_prov(coreotn_handle->mpma_fo2_handle,
                                                        input_chnl_id);
            }
            else
            {
                /* configure MPMA in FO #2 */
                ret_val = mpma_ch_deactivate(coreotn_handle->mpma_fo2_handle,
                                             input_chnl_id);
            }
        }
        break;

        default:
            PMC_RETURN(COREOTN_ERR_INVALID_ARG);
        }           
    }
               
    if (PMC_SUCCESS == ret_val)
    {
        /* MPMO configuration */
        switch (output_port)
        {
        case COREOTN_ODUKSW_OUTPUT_SIFD1:
            /* to SIFD1 */
            if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE ||
                coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
            {
                if (prov_mode != COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
                {
                    /* MPMO in COREOTN_CTRL  */
                    ret_val = mpmo_ch_deactivate(coreotn_handle->mpmo_core_ctl_handle,
                                                 output_chnl_id);
                }
            }
            break;
        case COREOTN_ODUKSW_OUTPUT_SIFD2:
            /* to SIFD2 */
            /* no OPSA */
            break;
        case COREOTN_ODUKSW_OUTPUT_COREOTN:
            /* to COREOTN */

            /* MPMO in FO1 */       
            if (prov_mode == COREOTN_ODU_CHNL_PROV_ALL)
            {
                ret_val = mpmo_ch_deactivate_super_prov(coreotn_handle->mpmo_fo1_handle,
                                                        output_chnl_id);
            }
            else if (prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
            {
                ret_val = mpmo_ch_deactivate(coreotn_handle->mpmo_fo1_handle,
                                             output_chnl_id);                                 
            }
            else if (prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
            {
                /* do nothing here */
            }
            break;
        case COREOTN_ODUKSW_OUTPUT_MAPOTN:
            /* to MAPOTN */
            /* MPMO in FO2 */

            /* FO2 MPMO is handled in cpb_chnl_deactivate */

            break;
        default:
            PMC_RETURN(COREOTN_ERR_INVALID_ARG);
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL ||
            coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ODUKSW_ONLY_BULK)
        {
            ret_val =  cpb_chnl_deactivate_super_prov(coreotn_handle->oduksw_handle,
                                                      output_port, output_chnl_id);  
        }
        else
        {
            ret_val = cpb_chnl_deactivate(coreotn_handle->oduksw_handle,
                                          output_port, output_chnl_id);
        }                                          
    }
    
    /* Update var context for the activated channel */
    if (PMC_SUCCESS == ret_val)
    {             
        coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].dest_active_count--;

        if (0 == coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].dest_active_count)
        {
            coreotn_handle->var.rx_oduksw_chnl_ctxt[input_port][input_chnl_id].state = COREOTN_CHNL_EQUIPPED;
        }
        coreotn_handle->var.tx_oduksw_chnl_ctxt[output_port][output_chnl_id].state = COREOTN_CHNL_EQUIPPED;
    }

    PMC_RETURN(ret_val);
} /* coreotn_oduksw_chnl_deactivate */

/*******************************************************************************
*  coreotn_oduksw_chnl_switch
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API is used to switch an ODUKSW primary/secondary channel.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   output_port         - Enum for ODUKSW output port. See coreotn_oduksw_output_port_type_t.
*   output_chnl_id      - channel ID to be configured.
*                         Valid range: 0 - 95
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_chnl_switch(coreotn_handle_t *coreotn_handle,
                                            coreotn_oduksw_output_port_type_t output_port,
                                            UINT32 output_chnl_id)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;

    PMC_ENTRY();

    /* check the channel state to see if it is operational */
    if ( coreotn_handle->var.tx_oduksw_chnl_ctxt[output_port][output_chnl_id].state != COREOTN_CHNL_OPERATIONAL)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_OPERATIONAL);
    }

    ret_val = cpb_chnl_switch(coreotn_handle->oduksw_handle,
                              output_port, output_chnl_id);

    PMC_RETURN(ret_val);
} /* coreotn_oduksw_chnl_switch */

/*******************************************************************************
*  coreotn_oif_pkt_period_calc
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This is a helper function for mpma_ch_prov and sets up the cfc_num_pages
*   and sets the xoff_thres
*
* INPUTS:
*   *coreotn_handle   - handle to the COREOTN instance to be operated on
*   odu_bitrate       - ODU bit rate (in bps)
*   pkt_size          - desired packet size defined in OIF recommendations.
*                       Valid values are:
*                       -- 128B
*                       -- 256B
*                       -- 512B
*   header_size       - size of header appended to the packet. This value is
*                       subtracted from the 'pkt_size' to get the payload bytes.
*                       This includes 0-12 bytes of user header and 4 bytes of
*                       OPF header.
*                       Valid range: 4 - 16 bytes*
*
*                       *Note, DIGI only supports insertion of up to 6 bytes.
*                       Fabrics external to DIGI may require additional header bytes.
*                       A maximum of 16 header bytes is allowed as defined by OIF
*                       (4 bytes for OFP + 12 user defined bytes)
*
* OUTPUTS:
*   *pkt_size_ptr     - configured packet size
*   *pkt_per_int_ptr  - configured integer portion of packet period
*   *pkt_per_n_ptr    - configured numerator of packet period fraction
*   *pkt_per_d_ptr    - configured denominator of packet period fraction
*   *eps_ptr          - Epsilon
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oif_pkt_period_calc(coreotn_handle_t *coreotn_handle,
                                             DOUBLE odu_bitrate,
                                             UINT32 pkt_size,
                                             UINT32 header_size,
                                             UINT32 *pkt_size_ptr,
                                             UINT32 *pkt_per_int_ptr,
                                             UINT32 *pkt_per_n_ptr,
                                             UINT32 *pkt_per_d_ptr,
                                             DOUBLE *eps_ptr)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    util_opsa_pkt_period_calc_t pkt_period_calc;
    UINT32 max_pkt_size;
    UINT32 pkt_per_int;
    UINT32 pkt_per_n;
    UINT32 pkt_per_d;
    UINT32 pkt_size_output;
    DOUBLE eps;

    PMC_ENTRY();

    if (pkt_size == 128)
    {
        pkt_period_calc = UTIL_OPSA_USE_OIF_128_BYTE;
    }
    else if (pkt_size == 256)
    {
        pkt_period_calc = UTIL_OPSA_USE_OIF_256_BYTE;
    }
    else if (pkt_size == 512)
    {
        pkt_period_calc = UTIL_OPSA_USE_OIF_512_BYTE;
    }
    else {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    /* find the max packet size */
    max_pkt_size = pkt_size - header_size;

    /* OIF recommendations for packet period. */

    ret_val = mpma_oif_pkt_period_calc(NULL, odu_bitrate, pkt_size, header_size,
                                       pkt_period_calc, &pkt_size_output,
                                       &pkt_per_int, &pkt_per_n, &pkt_per_d,
                                       &eps);
    if (PMC_SUCCESS == ret_val)
    {
        /* Return configured parameters. */
        *pkt_size_ptr = pkt_size_output;
        *pkt_per_int_ptr = pkt_per_int;
        *pkt_per_n_ptr = pkt_per_n;
        *pkt_per_d_ptr = pkt_per_d;
        *eps_ptr = eps;
    }

    PMC_RETURN(ret_val);
} /*  coreotn_oif_pkt_period_calc */

/*******************************************************************************
*  coreotn_pkt_period_calc
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API calculates packet size and packet period that result in minimum
*   epsilon or integer packet period.
*
* INPUTS:
*   *coreotn_handle   - handle to the COREOTN instance to be operated on
*   odu_bitrate       - ODU bit rate (in bps)
*   pkt_size          - desired packet size
*   pkt_size_range    - desired range of packet size.
*                       Packet sizes from pkt_size to pkt_size + pkt_size_range
*                       will be considered.
*   cn_frame_period   - parent Cn frame period that the client is demapped
*                       from. Only required for cn_mode = 0 (source node
*                       reference clock timing (B + C mode)).
*                       Set to UTIL_OPSA_T_FRAME_UNUSED if unused.
*   pkt_period_calc   - method for calculating packet period and size.
*                       When using UTIL_OPSA_USE_OIF_xxx_BYTE,
*                       pkt_size should be set within the valid OIF range,
*                       and pkt_size_range is ignored.
*
* OUTPUTS:
*   *pkt_size_ptr     - configured packet size
*   *pkt_per_int_ptr  - configured integer portion of packet period
*   *pkt_per_n_ptr    - configured numerator of packet period fraction
*   *pkt_per_d_ptr    - configured denominator of packet period fraction
*   *epsilon_ptr      - Epsilon
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_pkt_period_calc(coreotn_handle_t *coreotn_handle,
                                         DOUBLE odu_bitrate,
                                         UINT32 pkt_size,
                                         UINT32 pkt_size_range,
                                         util_opsa_cn_frame_period_t cn_frame_period,
                                         util_opsa_pkt_period_calc_t pkt_period_calc,
                                         UINT32 *pkt_per_int_ptr,
                                         UINT32 *pkt_per_n_ptr,
                                         UINT32 *pkt_per_d_ptr,
                                         UINT32 *pkt_size_ptr,
                                         DOUBLE *epsilon_ptr)

{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 ps;
    UINT32 pkt_per_int;
    UINT32 pkt_per_n;
    UINT32 pkt_per_d;
    DOUBLE epsilon;

    PMC_ENTRY();

    ret_val = mpma_pkt_period_calc(NULL, odu_bitrate, pkt_size,
                                   pkt_size_range, cn_frame_period,
                                   pkt_period_calc, &ps, &pkt_per_int,
                                   &pkt_per_n, &pkt_per_d, &epsilon);

    if (PMC_SUCCESS == ret_val)
    {
        *pkt_per_int_ptr = pkt_per_int;
        *pkt_per_n_ptr = pkt_per_n;
        *pkt_per_d_ptr = pkt_per_d;
        *pkt_size_ptr = ps;
        *epsilon_ptr = epsilon;
    }

    PMC_RETURN(ret_val);

} /* coreotn_pkt_period_calc */




/*******************************************************************************
*  coreotn_min_eps_pkt_period_calc
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API calculates packet size and packet period that result in minimum
*   epsilon or integer packet period.
*
* INPUTS:
*   *coreotn_handle   - handle to the COREOTN instance to be operated on
*   odu_bitrate       - ODU bit rate (in bps)
*
* OUTPUTS:
*   *pkt_size_ptr     - configured packet size
*   *pkt_per_int_ptr  - configured integer portion of packet period
*   *pkt_per_n_ptr    - configured numerator of packet period fraction
*   *pkt_per_d_ptr    - configured denominator of packet period fraction
*   *epsilon_ptr      - Epsilon
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_min_eps_pkt_period_calc(coreotn_handle_t *coreotn_handle,
                                                 DOUBLE odu_bitrate,
                                                 UINT32 *pkt_per_int_ptr,
                                                 UINT32 *pkt_per_n_ptr,
                                                 UINT32 *pkt_per_d_ptr,
                                                 UINT32 *pkt_size_ptr,
                                                 DOUBLE *epsilon_ptr)

{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();


#ifndef PMC_DIGI_REV_B_ONLY 
    ret_val = coreotn_pkt_period_calc(coreotn_handle,
                                      odu_bitrate,
                                      240,
                                      15,
                                      UTIL_OPSA_T_FRAME_UNUSED,
                                      UTIL_OPSA_EPS_MIN,
                                      pkt_per_int_ptr,
                                      pkt_per_n_ptr,
                                      pkt_per_d_ptr,
                                      pkt_size_ptr,
                                      epsilon_ptr);
#else
    ret_val = coreotn_pkt_period_calc(coreotn_handle,
                                      odu_bitrate,
                                      144,
                                      96,
                                      UTIL_OPSA_T_FRAME_UNUSED,
                                      UTIL_OPSA_EPS_MIN,
                                      pkt_per_int_ptr,
                                      pkt_per_n_ptr,
                                      pkt_per_d_ptr,
                                      pkt_size_ptr,
                                      epsilon_ptr);
#endif



    PMC_RETURN(ret_val);

} /* coreotn_min_eps_pkt_period_calc */

/*******************************************************************************
* coreotn_oduksw_chnl_hole_inst_head_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function configures the hole insertion head fields of the master port chnl
*   To be called immediately after the chnl prov function
*   The hole insertion feature only applies on SIFD ports and MAPOTN port, for
*   other port, this function just returns PMC_SUCCESS
*
* INPUTS:
*
*   coreotn_handle               -  pointer to the cpb handle instance
*                                   destination subsystem.
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*   hole_inst_sop_size           -  size of the hole at the start of the packet
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_chnl_hole_inst_head_cfg(coreotn_handle_t *coreotn_handle,
                                                        UINT32 egress_mux_output_port,
                                                        UINT32 egress_mux_output_port_chnl,
                                                        UINT32 hole_inst_sop_size)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();
    
    result = cpb_chnl_hole_inst_head_cfg(coreotn_handle->oduksw_handle,
                                         egress_mux_output_port,
                                         egress_mux_output_port_chnl,
                                         hole_inst_sop_size);
                                              
    PMC_RETURN(result);                                                  
} /* coreotn_oduksw_chnl_hole_inst_head_cfg */                                                            



/*
** COREOTN var_t accessor functions
*/
/*******************************************************************************
*  coreotn_lo_chnl_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current state of the LO channel
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl                - LO channel ID
*   direction           - direction of the channel
*                         0: TX
*                         1: RX
*   chnl_state          - current state of the LO channel.
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_lo_chnl_state_set(coreotn_handle_t *coreotn_handle,
                                           UINT32 chnl, UINT32 direction,
                                           coreotn_chnl_state_t chnl_state)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();
    
    if (direction == 0)
    {
        /* set TX direction */
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl].chnl_state = chnl_state;
    }
    else {
        /* read from RX direction */
        coreotn_handle->var.rx_lo_chnl_ctxt[chnl].chnl_state = chnl_state;
    }        
        
    PMC_RETURN(result);

} /* coreotn_lo_chnl_state_set */

/*******************************************************************************
*  coreotn_mo_chnl_state_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current state of the LO channel
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl                - LO channel ID
*   direction           - direction of the channel
*                         0: TX
*                         1: RX
*   chnl_state          - current state of the LO channel.
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_mo_chnl_state_set(coreotn_handle_t *coreotn_handle,
                                           UINT32 chnl, UINT32 direction,
                                           coreotn_chnl_state_t chnl_state)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();
    
    if (direction == 0)
    {
        /* set TX direction */
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl].chnl_state = chnl_state;
    }
    else {
        /* read from RX direction */
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl].chnl_state = chnl_state;
    }        
        
    PMC_RETURN(result);

} /* coreotn_mo_chnl_state_set */


/*******************************************************************************
* coreotn_odtu_chnl_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method to retrieve the list of MO or LO 
*   channels asscoaited to their respective HO or MO channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   ho_odu_level        - ODU level of the container
*   chnl_id             - MO or LO Channel ID
*   rx_dir              - Whether to check RX or TX directions
*
* OUTPUTS:
*
* RETURNS:
*   UTIL_GLOBAL_CHNL_START      - Unprovisioned
*   UTIL_GLOBAL_CHNL_OPERATIONAL - In use
*
* NOTES:
*
*******************************************************************************/
PUBLIC util_global_chnl_state_t coreotn_odtu_chnl_state_get(coreotn_handle_t *coreotn_handle,
                                                            coreotn_chnl_order_t ho_odu_level,
                                                            UINT32 chnl_id,
                                                            BOOL8 rx_dir)
{
    util_global_chnl_state_t lo_chnl_state = LAST_UTIL_GLOBAL_CHNL_STATE;
    BOOL8 is_sysotn_mode = FALSE;

    PMC_ENTRY();

    if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE || 
        coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
    {
        is_sysotn_mode = TRUE;
    }

    PMC_ASSERT(chnl_id < ODTU_MUX_NUM_CHANL && chnl_id < ODTU_DMX_NUM_CHANL, COREOTN_ERR_INVALID_ARG,0,0);

    if (COREOTN_CHNL_ORDER_HO == ho_odu_level && FALSE == is_sysotn_mode)
    {
        if (TRUE == rx_dir && COREOTN_CHNL_OPERATIONAL == coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state)
        {
            lo_chnl_state = coreotn_handle->odtu_dmx1_handle->var.lo_chnl_cfg[chnl_id].state;
        }
        else if (FALSE == rx_dir && COREOTN_CHNL_OPERATIONAL == coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state)
        {
            lo_chnl_state = coreotn_handle->odtu_mux1_handle->var.lo_chnl_cfg[chnl_id].state;
        }
        else
        {
            lo_chnl_state = UTIL_GLOBAL_CHNL_START;
        }
    }
    else if (COREOTN_CHNL_ORDER_HO == ho_odu_level && TRUE == is_sysotn_mode)
    {
        if (TRUE == rx_dir && COREOTN_CHNL_OPERATIONAL == coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state)
        {
            lo_chnl_state = coreotn_handle->odtu_dmx2_handle->var.lo_chnl_cfg[chnl_id].state;
        }
        else if (FALSE == rx_dir && COREOTN_CHNL_OPERATIONAL == coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state)
        {
            lo_chnl_state = coreotn_handle->odtu_mux2_handle->var.lo_chnl_cfg[chnl_id].state;
        }
        else
        {
            lo_chnl_state = UTIL_GLOBAL_CHNL_START;
        }
    }
    else if (COREOTN_CHNL_ORDER_MO == ho_odu_level)
    {
        if (TRUE == rx_dir && COREOTN_CHNL_OPERATIONAL == coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state)
        {
            lo_chnl_state = coreotn_handle->odtu_dmx2_handle->var.lo_chnl_cfg[chnl_id].state;
        }
        else if (FALSE == rx_dir && COREOTN_CHNL_OPERATIONAL == coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state)
        {
            lo_chnl_state = coreotn_handle->odtu_mux2_handle->var.lo_chnl_cfg[chnl_id].state;
        }
        else
        {
            lo_chnl_state = UTIL_GLOBAL_CHNL_START;
        }
    }
    else
    {
        PMC_ASSERT(FALSE, COREOTN_ERR_INVALID_ARG, 0, 0);
    }

    PMC_RETURN(lo_chnl_state);
} /* coreotn_odtu_chnl_state_get */


/*******************************************************************************
*  coreotn_lo_chnl_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current state of the LO channel
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl                - LO channel ID
*   direction           - direction of the channel
*                         0: TX
*                         1: RX
*
* OUTPUTS:
*   *chnl_state         - current state of the LO channel.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_lo_chnl_state_get(coreotn_handle_t *coreotn_handle,
                                           UINT32 chnl, UINT32 direction,
                                           coreotn_chnl_state_t *chnl_state)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

     if (direction == 0)
    {
        /* read from TX direction */
        *chnl_state = coreotn_handle->var.tx_lo_chnl_ctxt[chnl].chnl_state;
    }
    else {
        /* read from RX direction */
        *chnl_state = coreotn_handle->var.rx_lo_chnl_ctxt[chnl].chnl_state;
    }        
        
    PMC_RETURN(result);

} /* coreotn_lo_chnl_state_get */

/*******************************************************************************
*  coreotn_msi_cfg_mode_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Sets MSI configuration mode
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   msi_mode            - Enum for MSI configuration mode. See util_global_otn_msi_cfg_mode_t.
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_msi_cfg_mode_set(coreotn_handle_t *coreotn_handle,
                                          util_global_otn_msi_cfg_mode_t msi_mode)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* if init_operation is two, then set for both blocks
    ** one, set for FMF1
    ** none, don't set
    ** SYSOTN set FMF2
    ** SYSOTN bypass set none 
    */
    
    if (coreotn_handle->var.init_operation == COREOTN_SS_BYPASS_MODE
        || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
    {
        PMC_RETURN(result);
    }
    else if (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)
    {
        ohfs_insert_msi_mode_set(coreotn_handle->odtu_mux1_handle->tgmp_handle->ohfs_insert_handle,
                                 msi_mode);
        
        ohfs_remove_msi_mode_set(coreotn_handle->odtu_dmx1_handle->rgmp_handle->ohfs_remove_handle,
                                 msi_mode);
        
        ohfs_insert_msi_mode_set(coreotn_handle->odtu_mux2_handle->tgmp_handle->ohfs_insert_handle,
                                 msi_mode);   
        
        ohfs_remove_msi_mode_set(coreotn_handle->odtu_dmx2_handle->rgmp_handle->ohfs_remove_handle,
                                 msi_mode);                                                                                                                       
    }
    else if (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE)
    {
        ohfs_insert_msi_mode_set(coreotn_handle->odtu_mux1_handle->tgmp_handle->ohfs_insert_handle,
                                 msi_mode);
        
        ohfs_remove_msi_mode_set(coreotn_handle->odtu_dmx1_handle->rgmp_handle->ohfs_remove_handle,
                                 msi_mode);
    } 
    else if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
    {
        ohfs_insert_msi_mode_set(coreotn_handle->odtu_mux2_handle->tgmp_handle->ohfs_insert_handle,
                                 msi_mode);   
             
        ohfs_remove_msi_mode_set(coreotn_handle->odtu_dmx2_handle->rgmp_handle->ohfs_remove_handle,
                                 msi_mode);    
    }
        
    PMC_RETURN(result);

} /* coreotn_msi_cfg_mode_set */


/*******************************************************************************
*  coreotn_msi_cfg_mode_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Sets MSI configuration mode
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*
*
* OUTPUTS:
*   *msi_mode            - Enum for MSI configuration mode. See util_global_otn_msi_cfg_mode_t.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_msi_cfg_mode_get(coreotn_handle_t *coreotn_handle,
                                          util_global_otn_msi_cfg_mode_t *msi_mode)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* if init_operation is two, then set for both blocks
    ** one, set for FMF1
    ** none, don't set
    ** SYSOTN set FMF2
    ** SYSOTN bypass set none 
    */
    
    if (coreotn_handle->var.init_operation == COREOTN_SS_BYPASS_MODE
        || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
    {
        PMC_RETURN(result);
    }
    else if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
    {
        ohfs_insert_msi_mode_get(coreotn_handle->odtu_mux2_handle->tgmp_handle->ohfs_insert_handle,
                                 msi_mode);   
    }    
    else 
    {
        ohfs_insert_msi_mode_get(coreotn_handle->odtu_mux1_handle->tgmp_handle->ohfs_insert_handle,
                                 msi_mode);
                                                                                                                             
    }
        
    PMC_RETURN(result);

} /* coreotn_msi_cfg_mode_get */


/*******************************************************************************
*  coreotn_ts_port_ctxt_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Sets MSI configuration mode
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - Enum for MSI configuration mode. See util_global_otn_msi_cfg_mode_t.
*   tx_trib_port        - tributary port number in transmit direction
*                         Valid range: 0 - 79
*   rx_trib_port        - tributary port number in receive direction
*                         Valid range: 0 - 79
*   mux_stage           - Enum for mux stage. See coreotn_mux_stage_t.
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ts_port_ctxt_update(coreotn_handle_t *coreotn_handle,
                                             UINT32 chnl_id,
                                             UINT32 tx_trib_port,
                                             UINT32 rx_trib_port,
                                             coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;
    util_global_otn_msi_cfg_mode_t msi_mode;

    PMC_ENTRY();

    /* confirm that this is being called only when COREOTN is in MANUAL
    ** MSI configuration mode. Otherwise return 
    */
    result = coreotn_msi_cfg_mode_get(coreotn_handle, &msi_mode);
                                      
                                          
    if (PMC_SUCCESS == result)
    {
        if (msi_mode != UTIL_GLOBAL_OTN_MSI_CFG_MAN)
        {
            PMC_RETURN(PMC_SUCCESS);
        }
        else {
            if (mux_stage == COREOTN_MUX_STAGE_ONE)
            { 
                /* update the MO context */
                if (tx_trib_port != 0xFF)
                {
                    coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].trib_port = tx_trib_port;
                }
                
                if (rx_trib_port != 0xFF)
                {
                    coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].trib_port = rx_trib_port;
                }
            }
            else if (mux_stage == COREOTN_MUX_STAGE_TWO)
            { 
                /* update the MO context */
                if (tx_trib_port != 0xFF)
                {
                    coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].trib_port = tx_trib_port;
                }
                
                if (rx_trib_port != 0xFF)
                {
                    coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].trib_port = rx_trib_port;
                }
            }
            else {
                result = COREOTN_ERR_INVALID_ARG;
            }
        }
    }
    
    PMC_RETURN(result);
           
} /* coreotn_ts_port_ctxt_update */

/*******************************************************************************
*  coreotn_oduksw_fifo_var_data_and_chnl_state_reset
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Resets the fifo queue context data and the DCS channel channel context.
*   This API is used only in super_deprov mode in digi_otn_server_lo_deprov_end
*   after all channel resources in a given DSC instance have been deprovisioned.
*
* INPUTS:
*   *coreotn_handle             - pointer to COREOTN handle instance to be operated on
*   ingress_mux_input_port      - input port
*   ingress_mux_input_port_chnl - input channel number
*   egress_mux_output_port      - output port.
*   egress_mux_output_port_chnl - output channel number
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_fifo_var_data_and_chnl_state_reset( coreotn_handle_t *coreotn_handle,
                                                                    UINT32 ingress_mux_input_port,
                                                                    UINT32 ingress_mux_input_port_chnl,
                                                                    UINT32 egress_mux_output_port,
                                                                    UINT32 egress_mux_output_port_chnl )
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();
 
    if (PMC_SUCCESS == result)
    {
        result = cpb_connect_data_delete_super_deprov( coreotn_handle->oduksw_handle,
                                                       ingress_mux_input_port,
                                                       ingress_mux_input_port_chnl,
                                                       egress_mux_output_port,
                                                       egress_mux_output_port_chnl,
                                                       TRUE );
    }                                                 

    PMC_RETURN(result);
} /* coreotn_oduksw_fifo_var_data_and_chnl_state_reset */                                                         


/*
** PRIVATE Data path configuration functions
*/
/*******************************************************************************
*  coreotn_rx_ho_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Provisions a HO ODU channel at Stage 1 framer. This function sets up the
*   HO ODU channel such that COREOTN can perform further de-multiplexing based
*   on the payload format of the HO ODU channel. This function will configure
*   data to flow to ODUk Switch.
*
*   If the HO ODU channel is channelized and no de-multiplexing is required,
*   thie API will create a HO ODU container with NULL payload.
*   
*   If the HO ODU channel is channelized and requires 1-stage de-multiplexing,
*   call coreotn_rx_lo_chnl_prov() API to provision lower order ODU
*   channels.
*
*   If the ODU traffic is channelized and requires 2-stage de-multiplexing,
*   call coreotn_rx_lo_chnl_prov() twice once for each required stage of
*   de-multiplexing.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   odu_container       - ODUk type. See odukp_type_enum.
*                         Valid range: ODU2 to ODU4
*   payload_format      - payload format of the ODUk traffic carried by this HO
*                         channel. See odu_line_payload_t.
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   prov_rfrm_tfrm_cfg  - TRUE : Provision RFRM configs
*                         FALSE : Do not provision RFRM configs 
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_ho_chnl_prov(coreotn_handle_t *coreotn_handle,
                                         UINT32 chnl_id,
                                         coreotn_mux_stage_t mux_stage,
                                         util_global_odukp_type_t odu_container,
                                         util_global_odu_line_payload_t payload_format,
                                         BOOL prov_rfrm_tfrm_cfg)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    
    PMC_ENTRY();

    /* argument print */
    PMC_LOG_TRACE("chnl_id = %u, odu_container = %u, payload_format = %u, mux_stage = %u\n", chnl_id, odu_container, payload_format, mux_stage);

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    /* argument checking */
    if ((odu_container < UTIL_GLOBAL_ODU1 && payload_format != UTIL_GLOBAL_ODU_NULL)
        || odu_container > UTIL_GLOBAL_LAST_ODUK
        || payload_format > LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD
        || mux_stage > LAST_COREOTN_MUX_STAGE
        || (mux_stage == COREOTN_MUX_STAGE_ONE && chnl_id > 11)
        || (mux_stage == COREOTN_MUX_STAGE_ONE && coreotn_handle->var.init_operation == COREOTN_SS_BYPASS_MODE )
        || (mux_stage == COREOTN_MUX_STAGE_TWO && coreotn_handle->var.init_operation == COREOTN_SS_BYPASS_MODE )
        || (mux_stage == COREOTN_MUX_STAGE_ONE && coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE )
        || (mux_stage == COREOTN_MUX_STAGE_TWO && coreotn_handle->var.init_operation != COREOTN_SS_OPERATIONAL_MODE )  )
    {
        ret_val = COREOTN_ERR_INVALID_ARG;
    
    } else {
            

        if (mux_stage == COREOTN_MUX_STAGE_NONE) {

            ret_val = coreotn_rx_ho_chnl_mux_none_prov(coreotn_handle,
                                                       chnl_id,
                                                       mux_stage,
                                                       odu_container,
                                                       payload_format,
                                                       prov_rfrm_tfrm_cfg);

        } else if (mux_stage == COREOTN_MUX_STAGE_ONE) {
            
            ret_val = coreotn_rx_ho_chnl_mux_one_prov(coreotn_handle,
                                                      chnl_id,
                                                      mux_stage,
                                                      odu_container,
                                                      payload_format,
                                                      prov_rfrm_tfrm_cfg);

        } else if (mux_stage == COREOTN_MUX_STAGE_TWO) {

            ret_val = coreotn_rx_ho_chnl_mux_two_prov(coreotn_handle,
                                                      chnl_id,
                                                      mux_stage,
                                                      odu_container,
                                                      payload_format);
        } else {

            ret_val = COREOTN_ERR_INVALID_ARG;

        } 
    }

    PMC_RETURN(ret_val);
} /* coreotn_rx_ho_chnl_prov */

/*******************************************************************************
*  coreotn_rx_ho_chnl_offline_update
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API configures the offline page of the HO or MO channel to match
*   the configuration data on both online and offline pages of the channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   odu_container       - ODUk type. See odukp_type_enum.
*                         Valid range: ODU2 to ODU4
*   payload_format      - payload format of the ODUk traffic carried by this HO
*                         channel. See odu_line_payload_t.
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_ho_chnl_offline_update(coreotn_handle_t *coreotn_handle,
                                                   UINT32 chnl_id,
                                                   coreotn_mux_stage_t mux_stage,
                                                   util_global_odukp_type_t odu_container,
                                                   util_global_odu_line_payload_t payload_format)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();
    
    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {

        
        if(coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
        {
            result = odtu_dmx_ho_chnl_offline_update(coreotn_handle->odtu_dmx2_handle,
                                                     (odtu_dmx_stage_instance_t)mux_stage, chnl_id, odu_container, payload_format);
        }
        else
        {
            result = odtu_dmx_ho_chnl_offline_update(coreotn_handle->odtu_dmx1_handle,
                                                     (odtu_dmx_stage_instance_t)mux_stage, chnl_id, odu_container, payload_format);
        }

    }
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        result = odtu_dmx_ho_chnl_offline_update(coreotn_handle->odtu_dmx2_handle,
                                                 (odtu_dmx_stage_instance_t)mux_stage, chnl_id, odu_container, payload_format);
    }
                                                                                                                                                             
    PMC_RETURN(result);
} /* coreotn_rx_ho_chnl_offline_update */

/*******************************************************************************
*  coreotn_rx_lo_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Provisions a LO ODU channel in COREOTN.  This function is used to provision
*   a LO ODU channel as a result of de-multiplexing a MO or HO ODU channel from
*   LINEOTN.
*
*   If the ODU channel is channelized, prior to calling this API,
*   coreotn_rx_ho_odu_chnl_prov() must be called such that the MO or HO ODU
*   channel is active for the LO ODU to be provisioned.
*
*   If one stage de-multiplexing is used, call this API with 'stage_inst' set to 0
*   for HO-LO de-multiplexing. Call this API multiple times for all LO channels.
*
*   If two stage de-multiplexing is used, call this API with 'stage_inst' set to 1
*   for HO-MO de-multiplexing. This needs to called multiples times to
*   provision all MO channels.
*   Then call this API with 'stage_inst' set to 0 for MO-LO de-multiplexing.
*   This API needs to be called multiple times for all MO and LO channels.
*
*   This function configures MSI data of all tributary slots occupied by the LO
*   ODU channel with 'tribslot_mask[COREOTN_TRIB_WRD_CNT]' and 'trib_port' 
*   arguments. If ODUFlex type is used, set 'odu_flex_rate' argument to specify 
*   its rate. 'tribslot_mask[COREOTN_TRIB_WRD_CNT]' is used to identify the 
*   number of tributary slots occupied by the ODUflex channel. For all other 
*   LO ODU types, 'odu_flex_rate' is ignored. The number of bits set in 
*   'tribslot_mask[COREOTN_TRIB_WRD_CNT]' must equal to the number of tributary 
*   slots occupied by the LO ODU channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   lo_odu_type         - LO ODUj type. See odukp_type_enum.
*                         Valid range: all available oduk types.
*   odu_flex_rate       - number of ODU0's in ODUFlex client if lo_odu_type is 
*                         ODUFLEX_GFP. For all other lo_odu_type, set to 0.
*   client_rate         - ODUFlex client bitrate in kbps if lo_odu_type is set 
*                         to ODUFLEX_CBR. For all other lo_odu_type, set to 0.
*   mapping_mode        - mapping type used. See coreotn_mapping_type_t.
*   tribslot_mask       - 3 x 32 bit mask to represent the tributary slot
*                         assignment for this LO channel.\n
*                         Valid range: 0 - 0x4F\n
*                         Bit 0 -- Tributary slot 1\n
*                         Bit 1 -- Tributary slot 2\n
*                         Bit 2 -- Tributary slot 3\n
*                                ...\n
*                         Bit 79 -- Tributary slot 80\n
*                         NOTE : This is a "normalized" view of the server (so, if
*                                adding a client to an ODU2 server, only bits 0-7
*                                of tribslot_mask[0] can get set.
*                                In the event of 2.5G TS ODU2, only bits 0-3 can
*                                get set.
*        
*   trib_port           - a tributary port number for all tributary slot
*                         locations for the LO channel. This data is used for
*                         MSI coding.\n
*                         For the following payload types with fixed MSI
*                         assignment, this argument is ignored and MSI data is
*                         assigned internally as per G.709 standards:\n
*                         -- ODTU01\n
*                         -- ODTU12 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU2)\n
*                         -- ODTU13 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU3)
*   payload_format      - tributary slot size. See util_global_odu_line_payload_t.
*   ho_odu_type         - HO ODU container type that the LO ODU belongs to
*   ho_chnl_id          - HO channel ID that this LO belongs to.
*                         Valid range: 0 - 95
*   prov_rfrm           - TRUE : provision RFRM
*                         FALSE : preserve current RFRM configuration
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_lo_chnl_prov(coreotn_handle_t *coreotn_handle,
                                         UINT32 chnl_id,
                                         coreotn_mux_stage_t mux_stage,
                                         util_global_odukp_type_t lo_odu_type,
                                         UINT32 odu_flex_rate,
                                         DOUBLE client_rate,
                                         coreotn_mapping_type_t mapping_mode,
                                         UINT32 tribslot_mask[3],
                                         UINT32 trib_port,
                                         util_global_odu_line_payload_t payload_format,
                                         util_global_odukp_type_t ho_odu_type,
                                         UINT32 ho_chnl_id,
                                         BOOL prov_rfrm)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    line_core_otn_db_key    key;
    UINT32 client_bitrate = 0;
    BOOL8 use_float32_mode = digi_use_float32_get();
    
    PMC_ENTRY();

    PMC_LOG_TRACE("COREOTN_MUX_STAGE_ONE = %u\n", mux_stage);

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    
    /* argument checking */
    if (chnl_id > 95 || mux_stage > LAST_COREOTN_MUX_STAGE || lo_odu_type > UTIL_GLOBAL_LAST_ODUK
        || (UINT32)mapping_mode > (UINT32)UTIL_GLOBAL_NO_MAP || (UINT32)trib_port > (UINT32)COREOTN_MAX_NUM_TS
        || payload_format > LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD 
        || ho_odu_type > UTIL_GLOBAL_LAST_ODUK || (ho_chnl_id > 11 && mux_stage != COREOTN_MUX_STAGE_TWO)
        || (ho_chnl_id > 95 && mux_stage == COREOTN_MUX_STAGE_TWO)
        || (coreotn_handle->var.init_operation == COREOTN_SS_BYPASS_MODE || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE )
        || (mux_stage == COREOTN_MUX_STAGE_TWO && coreotn_handle->var.init_operation != COREOTN_SS_OPERATIONAL_MODE) )
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    } 

    if (lo_odu_type == UTIL_GLOBAL_ODUFLEX_CBR && client_rate != 0)
    {
        if (!use_float32_mode) {
            client_bitrate = (UINT32)(client_rate / 1000);
        } else {
            client_bitrate = (UINT32)((FLOAT)client_rate / 1000);
        }
    }
    else if (lo_odu_type == UTIL_GLOBAL_ODUFLEX_GFP)
    {
        /* client bitrate to be used in ODUKSC and ODUJAT */
        if (odu_flex_rate <= 8)
        {
            client_bitrate = (UINT32)((odu_flex_rate * UTIL_GLOBAL_ODU2_TS_RATE)/1000);
        } else if (odu_flex_rate <= 32) {
            client_bitrate = (UINT32)((odu_flex_rate * UTIL_GLOBAL_ODU3_TS_RATE)/1000);
        } else {
            client_bitrate = (UINT32)((odu_flex_rate * UTIL_GLOBAL_ODU4_TS_RATE)/1000);
        }         
    }
    
    /* retrieve the database for the current scheduler state */
    if (mux_stage != 2)
    {
        /* query the record to update */
        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = ho_chnl_id;
        key.mo_channel = DO_NOT_USE_KEY;
        key.lo_channel = DO_NOT_USE_KEY;
        key.trib_slot = DO_NOT_USE_KEY;
    }
    else {
        /* query the record to update */
        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = DO_NOT_USE_KEY;
        key.mo_channel = ho_chnl_id;
        key.lo_channel = DO_NOT_USE_KEY;
        key.trib_slot = DO_NOT_USE_KEY;
    }
    PMC_LOG_TRACE("&(coreotn_handle->base) = %p, coreotn_handle->cfg.rx_db_id = %u, coreotn_handle->cfg.rx_db_handle = %u\n", 
                  &(coreotn_handle->base),
                  coreotn_handle->cfg.rx_db_id,
                  coreotn_handle->cfg.rx_db_handle);
               
               
    if(ret_val == PMC_SUCCESS)
    {
        ret_val = coreotn_validate_tribslot_mask(coreotn_handle,
                                                 lo_odu_type,
                                                 ho_odu_type,
                                                 tribslot_mask,
                                                 ho_chnl_id,
                                                 mux_stage,
                                                 TRUE);
    }

    /* one stage muxing: ODTU_DMX_1 -> ODUKSC -> ODU_RFRM_STG2 */
    if (mux_stage == COREOTN_MUX_STAGE_ONE) {


        if(ret_val == PMC_SUCCESS)
        {
            ret_val = coreotn_rx_lo_chnl_mux_one_prov(coreotn_handle,
                                                      chnl_id,
                                                      mux_stage,
                                                      lo_odu_type,
                                                      odu_flex_rate,
                                                      client_rate,
                                                      mapping_mode,
                                                      tribslot_mask,
                                                      trib_port,
                                                      payload_format,
                                                      ho_odu_type,
                                                      ho_chnl_id,
                                                      client_bitrate,
                                                      prov_rfrm);
        }

    } else if (mux_stage == COREOTN_MUX_STAGE_TWO) {

        if(ret_val == PMC_SUCCESS)
        {
            ret_val = coreotn_rx_lo_chnl_mux_two_prov(coreotn_handle,
                                                      chnl_id,
                                                      mux_stage,
                                                      lo_odu_type,
                                                      odu_flex_rate,
                                                      client_rate,
                                                      mapping_mode,
                                                      tribslot_mask,
                                                      trib_port,
                                                      payload_format,
                                                      ho_odu_type,
                                                      ho_chnl_id,
                                                      client_bitrate);
        }

    } else {

        ret_val = COREOTN_ERR_INVALID_ARG;
    }

    PMC_RETURN(ret_val);
} /* coreotn_rx_lo_chnl_prov */

/*******************************************************************************
*  coreotn_rx_lo_chnl_offline_update
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API configures the offline page of MO or LO in ODTU_DMX block.
* 
*   This API uses the same configuration data from SW context that is used to 
*   configure the activate page. 
* 
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   lo_odu_type         - LO ODUj type. See odukp_type_enum.
*                         Valid range: all available oduk types.
*   odu_flex_rate       - number of ODU0s if lo_odu_type is set to ODUFLEX_GFP. 
*                         For all other lo_odu_type, set to 0.
*   client_rate         - client bit rate in bps if lo_odu_type is set to 
*                         ODUFLEX_CBR. For all other lo_odu_types, set to 0.
*   mapping_mode        - mapping type used. See coreotn_mapping_type_t.
*   tribslot_mask       - 3 x 32 bit mask to represent the tributary slot
*                         assignment for this LO channel.\n
*                         Valid range: 0 - 0x4F\n
*                         Bit 0 -- Tributary slot 1\n
*                         Bit 1 -- Tributary slot 2\n
*                         Bit 2 -- Tributary slot 3\n
*                                ...\n
*                         Bit 79 -- Tributary slot 80\n
*   trib_port           - a tributary port number for all tributary slot
*                         locations for the LO channel. This data is used for
*                         MSI coding.\n
*                         For the following payload types with fixed MSI
*                         assignment, this argument is ignored and MSI data is
*                         assigned internally as per G.709 standards:\n
*                         -- ODTU01\n
*                         -- ODTU12 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU2)\n
*                         -- ODTU13 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU3)
*   payload_format      - tributary slot size. See util_global_odu_line_payload_t.
*   ho_odu_type         - HO ODU container type that the LO ODU belongs to
*   ho_chnl_id          - HO channel ID that this LO belongs to.
*                         Valid range: 0 - 95
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_lo_chnl_offline_update(coreotn_handle_t *coreotn_handle,
                                                   UINT32 chnl_id,
                                                   coreotn_mux_stage_t mux_stage,
                                                   util_global_odukp_type_t lo_odu_type,
                                                   UINT32 odu_flex_rate,
                                                   DOUBLE client_rate,
                                                   coreotn_mapping_type_t mapping_mode,
                                                   UINT32 tribslot_mask[3],
                                                   UINT32 trib_port,
                                                   util_global_odu_line_payload_t payload_format,
                                                   util_global_odukp_type_t ho_odu_type,
                                                   UINT32 ho_chnl_id)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 cbr_client_bitrate = 0; 
    BOOL8 chnl_active = FALSE;
    BOOL8 use_float32_mode = digi_use_float32_get();

    PMC_ENTRY();
    
    if (client_rate != 0)
    {
        if (!use_float32_mode) {
            cbr_client_bitrate = (UINT32)(client_rate / 1000);
        } else {
            cbr_client_bitrate = (UINT32)((FLOAT)client_rate / 1000);
        }
    }
    
    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if ((coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT
             && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_EQUIPPED
             && coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 1) || 
            (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL
             && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_EQUIPPED
             && (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_cfg_state == COREOTN_LO_ODU_CHNL_CFG_START
                 || (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_cfg_state == COREOTN_LO_ODU_CHNL_CFG_END
                     && coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 1))))
        {
            if (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE  
                || coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)
            {
                if (TRUE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base))
                {
                    /* this is the first LO channel */
                    /* Channel reset is released by configuring HO_CH_RSTB to '1' */
                    ret_val = odtu_dmx_ho_chnl_reset_cfg(coreotn_handle->odtu_dmx1_handle, ho_chnl_id, TRUE);
                    
                    /*PMC_Q_USLEEP(coreotn_handle,COREOTN_2CAL_CYCLES_SLEEP_TIME);*/
                    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle, COREOTN_2CAL_CYCLES_SLEEP_TIME);
                
                  
                    /* wait for 2 calendar cycles */
                    if (PMC_SUCCESS == ret_val)
                    {
                        /* take the first LO channel out of reset */
                        ret_val = odtu_dmx_lo_chnl_activate(coreotn_handle->odtu_dmx1_handle,
                                                            chnl_id, ho_chnl_id,
                                                            (odtu_dmx_stage_instance_t)mux_stage); 
                                                            
                        if (PMC_SUCCESS == ret_val)
                        {
                            chnl_active = TRUE;
                        }                                                        
                    }
                
                    if (PMC_SUCCESS == ret_val)
                    {  
                        /* wait for 2 calendar cycles before programming the offline page */
                        /*PMC_Q_USLEEP(coreotn_handle,COREOTN_2CAL_CYCLES_SLEEP_TIME);*/
                        PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle, COREOTN_2CAL_CYCLES_SLEEP_TIME);  
                    
                    
                        /* This is adding the first MO into the HO. MO will become NON empty.
                        ** here set OHFS_REMOVE NULL_FRAME_MODE = '0'. Start sending data to the switch
                        */
                        ret_val = odtu_dmx_ho_null_frame_cfg(coreotn_handle->odtu_dmx1_handle,
                                                             ho_chnl_id, 0);   
                    }  
                }
            } /*end of coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE || 
                coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) */
            else if(coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
            {
                  
                /* this is the first LO channel */
                if (TRUE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base))
                {
                    /* Channel reset is released by configuring HO_CH_RSTB to '1' */
                    ret_val = odtu_dmx_ho_chnl_reset_cfg(coreotn_handle->odtu_dmx2_handle, ho_chnl_id, TRUE);
                    
                    /*PMC_Q_USLEEP(coreotn_handle,COREOTN_2CAL_CYCLES_SLEEP_TIME);*/
                    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle, COREOTN_2CAL_CYCLES_SLEEP_TIME); 
                
                  
                    /* wait for 2 calendar cycles */
                    if (PMC_SUCCESS == ret_val)
                    {
                        /* take the first LO channel out of reset */
                        ret_val = odtu_dmx_lo_chnl_activate(coreotn_handle->odtu_dmx2_handle,
                                                            chnl_id, ho_chnl_id,
                                                            (odtu_dmx_stage_instance_t)mux_stage); 
                                                            
                        if (PMC_SUCCESS == ret_val)
                        {
                            chnl_active = TRUE;
                        }                                                        
                    }
                                  
                    if (PMC_SUCCESS == ret_val)
                    {
                        /* wait for 2 calendar cycles before programming the offline page */
                        /*PMC_Q_USLEEP(coreotn_handle,COREOTN_2CAL_CYCLES_SLEEP_TIME);*/
                        PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle, COREOTN_2CAL_CYCLES_SLEEP_TIME);
                    
                        /* This is adding the first MO into the HO. MO will become NON empty.
                        ** here set OHFS_REMOVE NULL_FRAME_MODE = '0'. Start sending data to the switch
                        */                    
                        ret_val = odtu_dmx_ho_null_frame_cfg(coreotn_handle->odtu_dmx2_handle,
                                                             ho_chnl_id, 0);
                    }   
                }
            } /*end of if SYSOTN MODE */
        
        } /*end of coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_EQUIPPED
            && coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 1) */

        if (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE  
            || coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)
        {   
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odtu_dmx_lo_chnl_offline_update(coreotn_handle->odtu_dmx1_handle,
                                                          chnl_id, (odtu_dmx_stage_instance_t)mux_stage, lo_odu_type,
                                                          odu_flex_rate,
                                                          cbr_client_bitrate,
                                                          ho_odu_type, (util_global_mapping_mode_t)mapping_mode,
                                                          tribslot_mask, trib_port,
                                                          payload_format, ho_chnl_id);
            } 

            if (PMC_SUCCESS == ret_val && (FALSE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base)))
            {
                if (chnl_active == FALSE)
                {
                    /* lo channel out of reset */
                    ret_val = odtu_dmx_lo_chnl_activate(coreotn_handle->odtu_dmx1_handle,
                                                        chnl_id, ho_chnl_id,
                                                        (odtu_dmx_stage_instance_t)mux_stage);
                }            
            } 
        }
        else if(coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
        {
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odtu_dmx_lo_chnl_offline_update(coreotn_handle->odtu_dmx2_handle,
                                                          chnl_id, (odtu_dmx_stage_instance_t)mux_stage, lo_odu_type,
                                                          odu_flex_rate,
                                                          cbr_client_bitrate,
                                                          ho_odu_type, (util_global_mapping_mode_t)mapping_mode,
                                                          tribslot_mask, trib_port,
                                                          payload_format, ho_chnl_id);
            } 
            
            if (PMC_SUCCESS == ret_val)
            {
                if (chnl_active == FALSE && (FALSE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base)))
                {
                    /* lo channel out of reset */
                    ret_val = odtu_dmx_lo_chnl_activate(coreotn_handle->odtu_dmx2_handle,
                                                        chnl_id, ho_chnl_id,
                                                        (odtu_dmx_stage_instance_t)mux_stage);
                }                                                   
            }             
        }    
    }
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        if ((coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT
             && coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_EQUIPPED
             && coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 1) || 
            (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL
             && coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_EQUIPPED
             && (coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_cfg_state == COREOTN_LO_ODU_CHNL_CFG_START
                 || (coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_cfg_state == COREOTN_LO_ODU_CHNL_CFG_END
                     && coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 1))))
        {
            if (TRUE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base))
            {
                /* this is the first LO channel */
                /* Channel reset is released by configuring HO_CH_RSTB to '1' */
                ret_val = odtu_dmx_ho_chnl_reset_cfg(coreotn_handle->odtu_dmx2_handle, ho_chnl_id, TRUE);
                
                /*PMC_Q_USLEEP(coreotn_handle,COREOTN_2CAL_CYCLES_SLEEP_TIME);*/ 
                PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle, COREOTN_2CAL_CYCLES_SLEEP_TIME);
                     
                /* wait for 2 calendar cycles */
                if (PMC_SUCCESS == ret_val)
                {
                    /* take the first LO channel out of reset */
                    ret_val = odtu_dmx_lo_chnl_activate(coreotn_handle->odtu_dmx2_handle,
                                                        chnl_id, ho_chnl_id,
                                                        (odtu_dmx_stage_instance_t)mux_stage); 
                                                        
                    if (PMC_SUCCESS == ret_val)
                    {
                        chnl_active = TRUE;                                                      
                    }
                }             
            
                if (PMC_SUCCESS == ret_val)
                {
                    /* wait for 2 calendar cycles before programming the offline page */
                    /*PMC_Q_USLEEP(coreotn_handle,COREOTN_2CAL_CYCLES_SLEEP_TIME);*/ 
                    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle, COREOTN_2CAL_CYCLES_SLEEP_TIME); 
                    
                    /* This is adding the first LO into the MO. MO will become NON empty.
                    ** here set OHFS_REMOVE NULL_FRAME_MODE = '0'. Start sending data to the switch
                    */
                    
                        ret_val = odtu_dmx_ho_null_frame_cfg(coreotn_handle->odtu_dmx2_handle,
                                                             ho_chnl_id, 0);
                } 
            }
        }
                    
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_lo_chnl_offline_update(coreotn_handle->odtu_dmx2_handle,
                                                      chnl_id, (odtu_dmx_stage_instance_t)mux_stage, lo_odu_type,
                                                      odu_flex_rate,
                                                      cbr_client_bitrate,
                                                      ho_odu_type, (util_global_mapping_mode_t)mapping_mode,
                                                      tribslot_mask, trib_port,
                                                      payload_format, ho_chnl_id);
        }  

        
        if (PMC_SUCCESS == ret_val)
        {
            if (chnl_active == FALSE && (FALSE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base)))
            {
                /* take the first LO channel out of reset */
                ret_val = odtu_dmx_lo_chnl_activate(coreotn_handle->odtu_dmx2_handle,
                                                    chnl_id, ho_chnl_id,
                                                    (odtu_dmx_stage_instance_t)mux_stage); 
                                                    
                if (PMC_SUCCESS == ret_val)
                {
                    chnl_active = TRUE;                                                      
                }  
            }
        } 
        
        if (PMC_SUCCESS == ret_val)
        {
            if (TRUE == pmc_coreotn_dmx_two_stage_proxy_mo_chnl_prov_revision(&coreotn_handle->base)
                && coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 1)
            {
                ret_val = odtu_dmx_ho_null_frame_cfg(coreotn_handle->odtu_dmx2_handle,       
                                                     ho_chnl_id, 0);   
            
            }   
            else if (TRUE == pmc_coreotn_dmx_two_stage_proxy_mo_chnl_prov_revision(&coreotn_handle->base)
                     && coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt >= 1
                     && coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL)
            {
                ret_val = odtu_dmx_ho_null_frame_cfg(coreotn_handle->odtu_dmx2_handle,       
                                                     ho_chnl_id, 0);  
            }
        }        
                                                                   
    }                                                                                                        
    
    PMC_RETURN(ret_val);
} /* coreotn_rx_lo_chnl_offline_update */

/*******************************************************************************
*  coreotn_tx_ho_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Provisions a HO ODU channel at Stage 1 framer. MO or LO channels from
*   client side are multiplexed into a HO channel towards LINEOTN
*   interface.
*
*   If the ODU traffic is unchannelized, this API will configure the ODU channel
*   to reach first stage framer directly.
*
*   If the ODU traffic is channelized and requires 1-stage multiplexing,
*   after calling this API, call coreotn_tx_lo_chnl_prov() APIs to provision
*   lower order ODU channels to be multiplexed into the HO ODU channel.
*
*   If the ODU traffic is channelized and requires 2-stage multiplexing,
*   after calling this API, call coreotn_tx_lo_chnl_prov() twice once for
*   each required stage of multiplexing.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   odu_container       - ODUk type. See util_global_odukp_type_t.
*   payload_format      - payload format of the ODUk traffic carried by this HO
*                         channel. See util_global_odu_line_payload_t.
*   prov_rfrm_tfrm_cfg  - TRUE : Provision RFRM configs
*                         FALSE : Do not provision RFRM configs
*   prov_dummy_schd     - TRUE : Provision dummy schedule at FO1 MPMO
*                         FALSE : do not provision dummy schedule at FO1
*                                 MPMO
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_ho_chnl_prov(coreotn_handle_t *coreotn_handle,
                                         UINT32 chnl_id,
                                         coreotn_mux_stage_t mux_stage,
                                         util_global_odukp_type_t odu_container,
                                         util_global_odu_line_payload_t payload_format,
                                         BOOL prov_rfrm_tfrm_cfg,
                                         BOOL prov_dummy_schd)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;

    PMC_ENTRY();

    /* argument print */
    PMC_LOG_TRACE("chnl_id = %u, odu_container = %u, payload_format = %u, mux_stage = %u\n", chnl_id, odu_container, payload_format, mux_stage);

    /* argument checking */
    if ((mux_stage != COREOTN_MUX_STAGE_TWO && chnl_id > 11)
        || (mux_stage == COREOTN_MUX_STAGE_TWO && chnl_id > 95) 
        || (odu_container < UTIL_GLOBAL_ODU1 && payload_format != UTIL_GLOBAL_ODU_NULL)
        || odu_container > UTIL_GLOBAL_LAST_ODUK
        || payload_format > LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD
        || mux_stage > LAST_COREOTN_MUX_STAGE)
    {
        ret_val = COREOTN_ERR_INVALID_ARG;

    } else {

        /* if unchannelized, connect traffic to Stage 3B framer */
        if (mux_stage == COREOTN_MUX_STAGE_NONE) {

            ret_val = coreotn_tx_ho_chnl_mux_none_prov(coreotn_handle,
                                                       chnl_id,
                                                       mux_stage,
                                                       odu_container,
                                                       payload_format,
                                                       prov_rfrm_tfrm_cfg);

        } else if (mux_stage == COREOTN_MUX_STAGE_ONE) {
        
            ret_val = coreotn_tx_ho_chnl_mux_one_prov(coreotn_handle,
                                                      chnl_id,
                                                      mux_stage,
                                                      odu_container,
                                                      payload_format,
                                                      prov_rfrm_tfrm_cfg);

        } else if (mux_stage ==  COREOTN_MUX_STAGE_TWO) {

            ret_val = coreotn_tx_ho_chnl_mux_two_prov(coreotn_handle,
                                                      chnl_id,
                                                      mux_stage,
                                                      odu_container,
                                                      payload_format);

        } else {

            ret_val = COREOTN_ERR_INVALID_ARG;
        }
    }


    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if (payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
        {
        
            if(ret_val == PMC_SUCCESS)
            {
                /* provision MPMO FO1.  This is required in the event that 
                   a maintenance signal needs to be inserted without an ODUKSW connection*/
                ret_val = mpmo_ch_prov_for_maint_sig_insertion(coreotn_handle->mpmo_fo1_handle, 
                                                               chnl_id,
                                                               0, 128, 0, 0, 0, 
                                                               UTIL_OPSA_T_FRAME_UNUSED,
                                                               FALSE);
            }
                                                               
            /* activate MPMO CTRL */                                                       
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = mpmo_ch_activate_for_maint_sig_insertion(coreotn_handle->mpmo_fo1_handle, 
                                                                   chnl_id);
            }

            if(PMC_SUCCESS == ret_val)
            {
                ret_val = odu_struct_tx_maint_sig_dummy_rfrm_cfg(coreotn_handle,
                                                                 ODU_STRUCT_LEVEL_HO_ODU,
                                                                 chnl_id,
                                                                 TRUE);
            }
        }
    }

    PMC_RETURN(ret_val);

} /* coreotn_tx_ho_chnl_prov */



/*******************************************************************************
*  coreotn_tx_dummy_schd_prov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Provisions a dummy schedule at FO1 MPMO for CHANNELIZED->UNCHANNELIZED
*   transition.
*
*   This API is only designed to work on a HO transition.  More work
*   is required to extend this to a MO transition.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_dummy_schd_prov(coreotn_handle_t *coreotn_handle,
                                            UINT32 chnl_id)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;

    PMC_ENTRY();

    /* argument checking */
    if (chnl_id > 11) 
    {
        ret_val = COREOTN_ERR_INVALID_ARG;

    }


    /* Activate HO channel DB entries in order to make them visible for FO1:MPMO */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = coreotn_db_ho_entry_activate(coreotn_handle,UTIL_GEN_DB_LINE_CORE_OTN_TX_DB,chnl_id);
    }


    if(ret_val == PMC_SUCCESS)
    {
        /* provision MPMO FO1.  This is required in the event that 
          a maintenance signal needs to be inserted without an ODUKSW connection*/
        ret_val = mpmo_ch_prov_for_maint_sig_insertion(coreotn_handle->mpmo_fo1_handle, 
                                                       chnl_id,
                                                       0, 128, 0, 0, 0, 
                                                       UTIL_OPSA_T_FRAME_UNUSED,
                                                       FALSE);
    }
                                                           
    /* activate MPMO CTRL */                                                       
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = mpmo_ch_activate_for_maint_sig_insertion(coreotn_handle->mpmo_fo1_handle, 
                                                           chnl_id);
    }

    if(PMC_SUCCESS == ret_val)
    {
        ret_val = odu_struct_tx_maint_sig_dummy_rfrm_cfg(coreotn_handle,
                                                         ODU_STRUCT_LEVEL_HO_ODU,
                                                         chnl_id,
                                                         TRUE);
    }

    PMC_RETURN(ret_val);

} /* coreotn_tx_dummy_schd_prov */



/*******************************************************************************
*  coreotn_tx_lo_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Provisions a LO ODU channel in COREOTN.  This function is used to provision
*   a LO ODU channel as a source data to be multiplexed into a MO or HO ODU
*   channel.
*
*   coreotn_tx_ho_odu_chnl_prov() must be called such that HO ODU channel that
*   this LO ODU channel is to be added is active.
*
*   If one stage multiplexing is used, call this API with 'stage_inst' set to 1
*   for LO-HO multiplexing.
*   If two stage multiplexing is used, call this API twice for each stage of
*   multiplexing. Call this API with 'stage_inst' set to 1 for LO-MO multiplexing.
*   Then call this API with 'stage_inst' set to 1 for MO-HO multiplexing.
*
*   This function configures MSI data of all tributary slots occupied by the LO
*   ODU channel with 'tribslot_mask[COREOTN_TRIB_WRD_CNT]' and 'trib_port' 
*   arguments. If ODUFlex type is used, set 'odu_flex_rate' argument to specify 
*   its rate. 'tribslot_mask[COREOTN_TRIB_WRD_CNT]' is used to identify the 
*   number of tributary slots occupied by the ODUflex channel. For all other 
*   LO ODU types, 'odu_flex_rate' is ignored. The number of bits set in 
*   'tribslot_mask[COREOTN_TRIB_WRD_CNT]' must equal to the number of tributary 
*   slots occupied by the LO ODU channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - instance of multiplexing stage\n
*                         - 0 -- MO to HO multiplexing (LO to HO multiplexing for
*                                1 stage multiplexing)\n
*                         - 1 -- LO to MO multiplexing\n
*   lo_odu_type         - LO ODUj type. See util_global_odukp_type_t.
*   odu_flex_rate       - HO ODUk type. See util_global_odukp_type_t. 
*                         If two stage is used, this argument refers to MO odu type. 
*                         If one stage is used, this argument refers to HO odu type.
*   mapping_mode        - mapping type used. See coreotn_mapping_type_t.
*   tribslot_mask       - 3 x 32 bit mask to represent the tributary slot
*                         assignment for this LO channel.
*                         Valid range: 0 - 0x4F\n
*                          - Bit 0 - Tributary slot 1\n
*                          - Bit 1 - Tributary slot 2\n
*                          - Bit 2 - Tributary slot 3\n
*                               ...\n
*                          - Bit 79 - Tributary slot 80\n
*   trib_port           - a tributary port number for all tributary slot
*                         locations for the LO channel. This data is used for
*                         MSI coding.
*                         For the following payload types with fixed MSI
*                         assignment, this argument is ignored and MSI data is
*                         assigned internally as per G.709 standards:\n
*                         -- ODTU01\n
*                         -- ODTU12 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU2)\n
*                         -- ODTU13 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU3)
*   payload_format      - tributary slot size. See util_global_odu_line_payload_t.
*                         Valid values:\n
*                          -- For 1.25G TS, set to ODU_TS_1G25\n
*                          -- For 2.5G TS, set to ODU_TS_2G5\n
*   ho_odu_type         - HO ODU container type that the LO ODU channel belongs
*                         to. See util_global_odukp_type_t.
*   ho_chnl_id          - HO channel ID that this LO belongs to.
*                         Valid range: 0 - 95
*   client_rate         - Client rate in kb/sec (only used for CBR flex clients)
*   prov_tfrm           - TRUE : provision TFRM configs
*                         FALSE : preserve current configuration
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_lo_chnl_prov(coreotn_handle_t *coreotn_handle,
                                         UINT32 chnl_id,
                                         coreotn_mux_stage_t mux_stage,
                                         util_global_odukp_type_t lo_odu_type,
                                         UINT32 odu_flex_rate,
                                         coreotn_mapping_type_t mapping_mode,
                                         UINT32 tribslot_mask[3],
                                         UINT32 trib_port,
                                         util_global_odu_line_payload_t payload_format,
                                         util_global_odukp_type_t ho_odu_type,
                                         UINT32 ho_chnl_id,
                                         DOUBLE client_rate,
                                         BOOL prov_tfrm)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    line_core_otn_db_key    key;

    PMC_ENTRY();

    PMC_LOG_TRACE("mux_stage = %u\n", mux_stage);

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != tribslot_mask, COREOTN_ERR_INVALID_PTR, 0, 0);
    
    /* argument checking */
    if (chnl_id > 95 || mux_stage > LAST_COREOTN_MUX_STAGE 
        || lo_odu_type > UTIL_GLOBAL_LAST_ODUK
        || (UINT32)mapping_mode > (UINT32)UTIL_GLOBAL_NO_MAP 
        || trib_port > COREOTN_MAX_NUM_TS
        || payload_format > LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD 
        || ho_odu_type > UTIL_GLOBAL_LAST_ODUK 
        || (mux_stage != COREOTN_MUX_STAGE_TWO && ho_chnl_id > 11)
        || (mux_stage == COREOTN_MUX_STAGE_TWO && ho_chnl_id > 95))
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }
    
    if (PMC_SUCCESS == ret_val)
    {
        /* retrieve the database for the current scheduler state */
        if (mux_stage != COREOTN_MUX_STAGE_TWO)
        {
            /* get calendar entries for this HO channel */
            /* query the record to update */
            key.calendar_entry = DO_NOT_USE_KEY;
            key.ho_channel = ho_chnl_id;
            key.mo_channel = DO_NOT_USE_KEY;
            key.lo_channel = DO_NOT_USE_KEY;
            key.trib_slot = DO_NOT_USE_KEY;

        } else {

            /* get calendar entries for this HO channel */
            /* query the record to update */
            key.calendar_entry = DO_NOT_USE_KEY;
            key.ho_channel = DO_NOT_USE_KEY;
            key.mo_channel = ho_chnl_id;
            key.lo_channel = DO_NOT_USE_KEY;
            key.trib_slot = DO_NOT_USE_KEY;;
        }

    }

    if(ret_val == PMC_SUCCESS)
    {
        ret_val = coreotn_validate_tribslot_mask(coreotn_handle,
                                                 lo_odu_type,
                                                 ho_odu_type,
                                                 tribslot_mask,
                                                 ho_chnl_id,
                                                 mux_stage,
                                                 FALSE);
    }


    /* one stage muxing: ODU_TFRM_STG2 -> ODTU_MUX_1 */
    if (mux_stage == COREOTN_MUX_STAGE_ONE) 
    {       
        if (ret_val == PMC_SUCCESS)
        {
            ret_val = coreotn_tx_lo_chnl_mux_one_prov(coreotn_handle,
                                                      chnl_id,
                                                      mux_stage,
                                                      lo_odu_type,
                                                      odu_flex_rate,
                                                      mapping_mode,
                                                      tribslot_mask,
                                                      trib_port,
                                                      payload_format,
                                                      ho_odu_type,
                                                      ho_chnl_id,
                                                      client_rate,
                                                      prov_tfrm);
        }

    } 
    else if (mux_stage == COREOTN_MUX_STAGE_TWO) 
    {        
        if (ret_val == PMC_SUCCESS)
        {
            ret_val = coreotn_tx_lo_chnl_mux_two_prov(coreotn_handle,
                                                      chnl_id,
                                                      mux_stage,
                                                      lo_odu_type,
                                                      odu_flex_rate,
                                                      mapping_mode,
                                                      tribslot_mask,
                                                      trib_port,
                                                      payload_format,
                                                      ho_odu_type,
                                                      ho_chnl_id,
                                                      client_rate);
        }

    } 
    else {
        ret_val = COREOTN_ERR_INVALID_ARG;
    }


    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if (payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
        {           
            if (ret_val == PMC_SUCCESS)
            {
                /* provision MPMO FO1.  This is required in the event that 
                   a maintenance signal needs to be inserted without an ODUKSW connection*/
                ret_val = mpmo_ch_prov_for_maint_sig_insertion(coreotn_handle->mpmo_fo1_handle, 
                                                               chnl_id,
                                                               0, 128, 0, 0, 0, 
                                                               UTIL_OPSA_T_FRAME_UNUSED,
                                                               FALSE);
            }
                                                                   
            /* activate MPMO CTRL */                                                       
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = mpmo_ch_activate_for_maint_sig_insertion(coreotn_handle->mpmo_fo1_handle, 
                                                                       chnl_id);
            }

            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odu_struct_tx_maint_sig_dummy_rfrm_cfg(coreotn_handle,
                                                                 ODU_STRUCT_LEVEL_HO_ODU,
                                                                 chnl_id,
                                                                 TRUE);
            }
        }
    }        

    PMC_RETURN(ret_val);
} /* coreotn_tx_lo_chnl_prov */

/*******************************************************************************
*  coreotn_tx_lo_chnl_offline_update
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API configures the offline page of the MO or LO channel in
*   ODTU_MUX block.
* 
*   This API uses the same configuration data from SW context that was used
*   to configure the active page of the channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - instance of multiplexing stage\n
*                         - 0 -- MO to HO multiplexing (LO to HO multiplexing for
*                                1 stage multiplexing)\n
*                         - 1 -- LO to MO multiplexing\n
*   lo_odu_type         - LO ODUj type. See util_global_odukp_type_t.
*   odu_flex_rate       - HO ODUk type. See util_global_odukp_type_t. 
*                         If two stage is used, this argument refers to MO odu type. 
*                         If one stage is used, this argument refers to HO odu type.
*   mapping_mode        - mapping type used. See coreotn_mapping_type_t.
*   tribslot_mask       - 3 x 32 bit mask to represent the tributary slot
*                         assignment for this LO channel.
*                         Valid range: 0 - 0x4F\n
*                          - Bit 0 - Tributary slot 1\n
*                          - Bit 1 - Tributary slot 2\n
*                          - Bit 2 - Tributary slot 3\n
*                               ...\n
*                          - Bit 79 - Tributary slot 80\n
*   trib_port           - a tributary port number for all tributary slot
*                         locations for the LO channel. This data is used for
*                         MSI coding.
*                         For the following payload types with fixed MSI
*                         assignment, this argument is ignored and MSI data is
*                         assigned internally as per G.709 standards:\n
*                         -- ODTU01\n
*                         -- ODTU12 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU2)\n
*                         -- ODTU13 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU3)
*   payload_format      - tributary slot size. See util_global_odu_line_payload_t.
*                         Valid values:\n
*                          -- For 1.25G TS, set to ODU_TS_1G25\n
*                          -- For 2.5G TS, set to ODU_TS_2G5\n
*   ho_odu_type         - HO ODU container type that the LO ODU channel belongs
*                         to. See util_global_odukp_type_t.
*   ho_chnl_id          - HO channel ID that this LO belongs to.
*                         Valid range: 0 - 95
*   client_rate         - The client rate in kb/sec
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_lo_chnl_offline_update(coreotn_handle_t *coreotn_handle,
                                                   UINT32 chnl_id,
                                                   coreotn_mux_stage_t mux_stage,
                                                   util_global_odukp_type_t lo_odu_type,
                                                   UINT32 odu_flex_rate,
                                                   coreotn_mapping_type_t mapping_mode,
                                                   UINT32 tribslot_mask[3],
                                                   UINT32 trib_port,
                                                   util_global_odu_line_payload_t payload_format,
                                                   util_global_odukp_type_t ho_odu_type,
                                                   UINT32 ho_chnl_id,
                                                   UINT32 client_rate)
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();
    
    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {

        if (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE ||
            coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)
        {
            PMC_LOG_TRACE("Updating MUX1 offline...\n");
            result = odtu_mux_lo_chnl_offline_update(coreotn_handle->odtu_mux1_handle,
                                                     chnl_id, (odtu_mux_stage_instance_t)mux_stage, lo_odu_type,
                                                     odu_flex_rate, (util_global_mapping_mode_t)mapping_mode,
                                                     tribslot_mask, trib_port, payload_format,
                                                     ho_odu_type, ho_chnl_id, client_rate);
        }
        else if(coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
        {
            PMC_LOG_TRACE("Updating MUX1 offline...\n");
            result = odtu_mux_lo_chnl_offline_update(coreotn_handle->odtu_mux2_handle,
                                                     chnl_id, (odtu_mux_stage_instance_t)mux_stage, lo_odu_type,
                                                     odu_flex_rate, (util_global_mapping_mode_t)mapping_mode,
                                                     tribslot_mask, trib_port, payload_format,
                                                     ho_odu_type, ho_chnl_id, client_rate);
        }

    }
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        PMC_LOG_TRACE("Updating MUX2 offline...\n");
        result = odtu_mux_lo_chnl_offline_update(coreotn_handle->odtu_mux2_handle,
                                                 chnl_id, (odtu_mux_stage_instance_t)mux_stage, lo_odu_type,
                                                 odu_flex_rate, (util_global_mapping_mode_t)mapping_mode,
                                                 tribslot_mask, trib_port, payload_format,
                                                 ho_odu_type, ho_chnl_id, client_rate);
    }
    
    PMC_RETURN(result);
} /* coreotn_tx_lo_chnl_offline_update */

/*******************************************************************************
*  coreotn_tx_lo_chnl_offline_update_all
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API configures the offline page of all LO channels that have recently
*   been provisioned on the active page.
* 
*   This API is only used when coreotn_odu_chnl_prov_mode_set() is called with
*   COREOTN_ODU_CHNL_PROV_ALL. When this API is called, only the new channels
*   being added are reconfigured on the offline page without disruption
*   to the neighboring LO channels within the same HO or MO channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   mux_stage           - instance of multiplexing stage\n
*                         - 0 -- MO to HO multiplexing (LO to HO multiplexing for
*                                1 stage multiplexing)\n
*                         - 1 -- LO to MO multiplexing\n
*   ho_chnl_id          - HO channel ID that this LO belongs to.
*                         Valid range: 0 - 95
*   *new_lo_chnl_ids    - pointer to storage for array of LO channel IDs to be
*                         added to the offline page
*   num_new_lo          - number of new LO channels 
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_lo_chnl_offline_update_all(coreotn_handle_t *coreotn_handle,
                                                       coreotn_mux_stage_t mux_stage,
                                                       UINT32 ho_chnl_id,
                                                       UINT32 *new_lo_chnl_ids,
                                                       UINT32 num_new_lo)
{
    PMC_ENTRY();
    
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 i;
    odtu_mux_handle_t *odtu_mux_handle_ptr = NULL;
    
    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE
            || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
        {
            odtu_mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
        }
        else {
            odtu_mux_handle_ptr = coreotn_handle->odtu_mux1_handle;
        }

        if (PMC_SUCCESS == result)   
        {
            /* check to see if the LO channel hasn't been configured */
            for (i = 0; i < num_new_lo; i++)
            {             
                /* filter through all LO channel list and apply the offline update 
                ** to only the channels that are in EQUIPPED state
                */                              
                /* 1) activate LO channel */
                result = odtu_mux_lo_chnl_activate(odtu_mux_handle_ptr,
                                                   new_lo_chnl_ids[i], ho_chnl_id);
                
                if (PMC_SUCCESS == result)
                {
                    /* update the channel state */
                    coreotn_handle->var.tx_mo_chnl_ctxt[new_lo_chnl_ids[i]].chnl_state = COREOTN_CHNL_PROV_PENDING;
                }

                /* 2) configure offline page */ 
                if (PMC_SUCCESS == result)
                {                                           
                    result = coreotn_tx_lo_chnl_offline_update(coreotn_handle,
                                                               new_lo_chnl_ids[i],
                                                               mux_stage,
                                                               coreotn_handle->var.tx_mo_chnl_ctxt[new_lo_chnl_ids[i]].lo_odu_rate,
                                                               coreotn_handle->var.tx_mo_chnl_ctxt[new_lo_chnl_ids[i]].odu_flex_rate,
                                                               coreotn_handle->var.tx_mo_chnl_ctxt[new_lo_chnl_ids[i]].mapping_mode,
                                                               coreotn_handle->var.tx_mo_chnl_ctxt[new_lo_chnl_ids[i]].tribslot_mask,
                                                               coreotn_handle->var.tx_mo_chnl_ctxt[new_lo_chnl_ids[i]].trib_port,
                                                               coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].payload_format,
                                                               coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].odu_container,
                                                               ho_chnl_id,
                                                               coreotn_handle->var.tx_mo_chnl_ctxt[new_lo_chnl_ids[i]].cbr_flex_rate);
                }  

                if (PMC_SUCCESS == result)
                {
                    coreotn_handle->var.tx_mo_chnl_ctxt[new_lo_chnl_ids[i]].chnl_state = COREOTN_CHNL_OPERATIONAL; 
                }                                                                                                            
            }                                                           
        }
    }
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        if (PMC_SUCCESS == result)   
        {
            for (i = 0; i < num_new_lo; i++)
            {         
                /* filter through all LO channel list and apply the offline update 
                ** to only the channels that are in EQUIPPED state
                */  
                /* 1) activate LO channel */
                result = odtu_mux_lo_chnl_activate(coreotn_handle->odtu_mux2_handle,
                                                   new_lo_chnl_ids[i], ho_chnl_id);
                
                if (PMC_SUCCESS == result)
                {
                    /* update the channel state */
                    /*coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_ids[i]].chnl_state = COREOTN_CHNL_OPERATIONAL;*/
                    coreotn_handle->var.tx_lo_chnl_ctxt[new_lo_chnl_ids[i]].chnl_state = COREOTN_CHNL_PROV_PENDING;
                }
                                            
                /* 2) configure offline page */ 
                if (PMC_SUCCESS == result)
                {         
                    result = coreotn_tx_lo_chnl_offline_update(coreotn_handle,
                                                               new_lo_chnl_ids[i],
                                                               mux_stage,
                                                               coreotn_handle->var.tx_lo_chnl_ctxt[new_lo_chnl_ids[i]].lo_odu_rate,
                                                               coreotn_handle->var.tx_lo_chnl_ctxt[new_lo_chnl_ids[i]].odu_flex_rate,
                                                               coreotn_handle->var.tx_lo_chnl_ctxt[new_lo_chnl_ids[i]].mapping_mode,
                                                               coreotn_handle->var.tx_lo_chnl_ctxt[new_lo_chnl_ids[i]].tribslot_mask,
                                                               coreotn_handle->var.tx_lo_chnl_ctxt[new_lo_chnl_ids[i]].trib_port,
                                                               coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].payload_format,
                                                               coreotn_handle->var.tx_lo_chnl_ctxt[new_lo_chnl_ids[i]].odu_container,
                                                               ho_chnl_id,
                                                               coreotn_handle->var.tx_lo_chnl_ctxt[new_lo_chnl_ids[i]].cbr_flex_rate);
                } 
                
                if (PMC_SUCCESS == result)
                {
                    coreotn_handle->var.tx_lo_chnl_ctxt[new_lo_chnl_ids[i]].chnl_state = COREOTN_CHNL_OPERATIONAL; 
                }                                                            
            }                                                           
        }
    }                                                        
    
    PMC_RETURN(result);
} /* coreotn_tx_lo_chnl_offline_update_all */
                                                   

/*******************************************************************************
*  coreotn_tx_ho_chnl_offline_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API configures the offline page of the HO or MO depending on the
*   multiplexing stage.
* 
*   This API uses the same configuration data stored in SW context that was
*   used to configure the activae page of the channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   odu_container       - ODUk type. See util_global_odukp_type_t.
*   payload_format      - payload format of the ODUk traffic carried by this HO
*                         channel. See util_global_odu_line_payload_t.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_ho_chnl_offline_update(coreotn_handle_t *coreotn_handle,
                                                   UINT32 chnl_id,
                                                   coreotn_mux_stage_t mux_stage,
                                                   util_global_odukp_type_t odu_container,
                                                   util_global_odu_line_payload_t payload_format)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    odtu_mux_handle_t *mux_handle_ptr = NULL;
    UINT32 mux_stage_id = 0;
    BOOL prbs_null_chan;

    PMC_ENTRY();
    
    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if(coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
        {
            mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
            mux_stage_id = 1;
        }
        else {
            mux_handle_ptr = coreotn_handle->odtu_mux1_handle;
            mux_stage_id = 1;
        }
    }
    else {
        mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
        mux_stage_id = 2;
    }
               

    if (ret_val == PMC_SUCCESS)
    {
        ret_val = coreotn_prbs_null_chan_en_get(coreotn_handle,
                                                mux_stage,
                                                chnl_id,
                                                &prbs_null_chan);
    }

    if (ret_val == PMC_SUCCESS)
    {
        if (payload_format == UTIL_GLOBAL_ODU_NULL || prbs_null_chan)
        {
            /* write to NULL_CHAN_EN in the offline page */
            ret_val = odtu_mux_null_chnl_cfg(mux_handle_ptr, chnl_id, 1);
                                            
            payload_format = UTIL_GLOBAL_ODU_TS_1G25;
        }
        else {
            /* write to NULL_CHAN_EN in the offline page */
            ret_val = odtu_mux_null_chnl_cfg(mux_handle_ptr, chnl_id, 0);
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        ret_val = odtu_mux_ho_chnl_offline_update(mux_handle_ptr, mux_stage_id, 
                                                  chnl_id, odu_container, 
                                                  payload_format);
        
    }


    
    PMC_RETURN(ret_val);
} /* coreotn_tx_ho_chnl_offline_update */
  
/*******************************************************************************
*  coreotn_rx_ho_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Deprovisions HO channel in RX direction
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   deprov_rfrm_tfrm_cfg - TRUE : deprovision RFRM/TFRM confiuration
*                          FALSE : preserve current RFRM/TFRM configuration
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_ho_chnl_deprov(coreotn_handle_t *coreotn_handle,
                                           UINT32 chnl_id,
                                           coreotn_mux_stage_t mux_stage,
                                           BOOL deprov_rfrm_tfrm_cfg)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    BOOL8 super_prov = FALSE;
 
    PMC_ENTRY();

    /* argument print */
    PMC_LOG_TRACE("chnl_id = %u, \n", chnl_id);

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    /* argument checking */
    if (mux_stage > LAST_COREOTN_MUX_STAGE
        || (mux_stage == COREOTN_MUX_STAGE_ONE && chnl_id > 11))
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }       


    if(mux_stage == COREOTN_MUX_STAGE_NONE &&
       coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED &&
       coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)
    {
        /*deprov TFRM at 3B before traffic stops*/
        ret_val = odu_tfrm_chnl_prov(coreotn_handle->odu_tfrm_stg3b_handle,chnl_id,
                                     ODU_TFRM_MESSAGE_DONT_CARE,ODU_TFRM_MESSAGE_DONT_CARE,ODU_TFRM_PM_TCM_START,
                                     FALSE);   
  
    }

    /* retrieve the prov mode */
    super_prov = (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL)?TRUE:FALSE;

    /* check the current channel state */
    /* The last checking is for deprovisioning a MO channel in 2 stage muxing */
    if ((mux_stage == COREOTN_MUX_STAGE_ONE && coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
        || ((mux_stage == COREOTN_MUX_STAGE_TWO && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
            && (mux_stage == COREOTN_MUX_STAGE_TWO && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)
            && (mux_stage == COREOTN_MUX_STAGE_TWO && super_prov
                && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_DEPROV_PENDING)))
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED);
    }
    
    if ((mux_stage == COREOTN_MUX_STAGE_ONE && coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].sub_chnls_prov_cnt != 0)
        || (mux_stage == COREOTN_MUX_STAGE_TWO && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].sub_chnls_prov_cnt != 0))
    {
        PMC_RETURN(COREOTN_ERR_CHNL_DEPROV);
    }
    
    if (PMC_SUCCESS == ret_val) 
    {
        if (mux_stage == COREOTN_MUX_STAGE_NONE) 
        {

            ret_val = coreotn_rx_ho_chnl_mux_none_deprov(coreotn_handle,
                                                         chnl_id,
                                                         mux_stage,
                                                         deprov_rfrm_tfrm_cfg);
        } 
        else if (mux_stage == COREOTN_MUX_STAGE_ONE) 
        {
            ret_val = coreotn_rx_ho_chnl_mux_one_deprov(coreotn_handle,
                                                        chnl_id,
                                                        mux_stage,
                                                        deprov_rfrm_tfrm_cfg);

        } 
        else if (mux_stage == COREOTN_MUX_STAGE_TWO) 
        {
            ret_val = coreotn_rx_ho_chnl_mux_two_deprov(coreotn_handle,
                                                        chnl_id,
                                                        mux_stage);

        } 
        else {

            ret_val = COREOTN_ERR_INVALID_ARG;
        }
    }
            
    if (PMC_SUCCESS == ret_val)
    {                                          
        /* update the channel state */
        /* Update var context for a provisioned channel */
        if (mux_stage != COREOTN_MUX_STAGE_TWO)
        {
            coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_START;
            if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_IN_PASSTHRU ||
                coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_EQUIPPED)
            {
                coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_START;
            }
            if (coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_IN_PASSTHRU ||
                coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_EQUIPPED)
            {
                coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_START;
            }

            /* update the number of provisioned ho channels */
            coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnls_prov_cnt--;
        }
    }        

    PMC_RETURN(ret_val);
} /* coreotn_rx_ho_chnl_deprov */

/*******************************************************************************
*  coreotn_tx_ho_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Deprovisions a HO channel in TX direction. 
*
*   Prior to calling this API, coreotn_tx_ho_chnl_deactivate() must have been
*   called to deactivate the channel. All LO channel that were provisioned in
*   this HO must have been deprovisioned prior to calling this API.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   deprov_rfrm_tfrm_cfg - TRUE : deprovision TFRM configuration
*                          FALSE : preserve current RFRM configuration
*   deprov_dummy_schd    - TRUE : deprovision dummy schedule at the MPMO
*                          FALSE : keep the dummy schedule at the MPMO
*                          
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_ho_chnl_deprov( coreotn_handle_t *coreotn_handle,
                                            UINT32 chnl_id,
                                            coreotn_mux_stage_t mux_stage,
                                            BOOL deprov_rfrm_tfrm_cfg,
                                            BOOL deprov_dummy_schd)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    BOOL8 deprov_deactivate_mpmo;
    UINT32 chnl_id_ptr[1] = {0xFF};

    PMC_ENTRY();

    /* argument print */
    PMC_LOG_TRACE("chnl_id = %u,  mux_stage = %u\n", chnl_id, mux_stage);

    /* argument checking */
    if ((mux_stage != COREOTN_MUX_STAGE_TWO && chnl_id > 11) || (mux_stage == COREOTN_MUX_STAGE_TWO && chnl_id > 95) || mux_stage > LAST_COREOTN_MUX_STAGE)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }
 
    if (mux_stage == COREOTN_MUX_STAGE_NONE &&
        coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED &&
        coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)
    {
        deprov_deactivate_mpmo = TRUE;

        /* to send in one element in an array format */
        chnl_id_ptr[0] = chnl_id; 

        /* in addition to not deprovisioning the dummy schedule at the MPMO, it's
        ** also required to not clean the RFRM channel because it's required to
        ** keep the dummy maintenance signal with an open ODUKSW connection
        */ 
        odu_rfrm_chnl_clean(coreotn_handle->odu_rfrm_stg3b_handle,
                            chnl_id_ptr,
                            (UINT32)deprov_dummy_schd);

        /*clear dummy maintenance signal context at same time as clearing RFRM
        configuration*/
        coreotn_handle->var.prev_fo1_rfrm_maint_sig[chnl_id] = 0;
        coreotn_handle->var.dummy_fo1_maint_sig[chnl_id] = 0;
    }
    else
    {
        deprov_deactivate_mpmo = FALSE;
    }


    
    /* check the current channel state */
    /* The last checking is for deprovisioning a MO channel in 2 stage muxing */
    
    if ((mux_stage == COREOTN_MUX_STAGE_ONE && coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
        || ((mux_stage == COREOTN_MUX_STAGE_TWO && coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
            && (mux_stage == COREOTN_MUX_STAGE_TWO && coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)
            && (mux_stage == COREOTN_MUX_STAGE_TWO && coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL
                && coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_DEPROV_PENDING)))
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED);
    }
    
    if ((mux_stage == COREOTN_MUX_STAGE_ONE && coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].sub_chnls_prov_cnt != 0)
        || (mux_stage == COREOTN_MUX_STAGE_TWO && coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].sub_chnls_prov_cnt != 0))
    {
        PMC_RETURN(COREOTN_ERR_CHNL_DEPROV);
    }

    if (PMC_SUCCESS == ret_val) 
    {
        if (mux_stage == COREOTN_MUX_STAGE_NONE) 
        {
            ret_val = coreotn_tx_ho_chnl_mux_none_deprov(coreotn_handle,
                                                         chnl_id,
                                                         mux_stage,
                                                         deprov_rfrm_tfrm_cfg);

        } 
        else if (mux_stage == COREOTN_MUX_STAGE_ONE) 
        {
            ret_val = coreotn_tx_ho_chnl_mux_one_deprov(coreotn_handle,
                                                        chnl_id,
                                                        mux_stage,
                                                        deprov_rfrm_tfrm_cfg);

            /*clean up prbs_null_chan_en context*/
            if(ret_val == PMC_SUCCESS)
            {
                ret_val = coreotn_prbs_null_chan_en_set(coreotn_handle,
                                                        mux_stage,
                                                        chnl_id,
                                                        FALSE,
                                                        chnl_id);
            }
        } 
        else if (mux_stage == COREOTN_MUX_STAGE_TWO) 
        {
            ret_val = coreotn_tx_ho_chnl_mux_two_deprov(coreotn_handle,
                                                        chnl_id,
                                                        mux_stage);

            if(ret_val == PMC_SUCCESS)
            {
                ret_val = coreotn_prbs_null_chan_en_set(coreotn_handle,
                                                        mux_stage,
                                                        chnl_id,
                                                        FALSE,
                                                        chnl_id);
            }
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        /* update the channel state */
        /* Update var context for a provisioned channel */
        if (mux_stage != COREOTN_MUX_STAGE_TWO) 
        {      
            coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_START;
            
            if (coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_IN_PASSTHRU 
                || coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_EQUIPPED)
            {
                coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_START;
            }
            
            if (coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_IN_PASSTHRU 
                || coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_EQUIPPED)
            {
                coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_START;
            }
            coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnls_prov_cnt--;

        }
    }


    if (deprov_deactivate_mpmo && deprov_dummy_schd)
    {
        /* deactivate MPMO channel from COREOTN FO1 */                                                 
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = mpmo_ch_deactivate_for_maint_sig_insertion(coreotn_handle->mpmo_fo1_handle, 
                                                                 chnl_id);
        }
                                                        
        /* deprovision MPMO channel from COREOTN FO1 */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = mpmo_ch_deprov_for_maint_sig_insertion(coreotn_handle->mpmo_fo1_handle,
                                                             chnl_id);
        }
    } 




                    
    PMC_RETURN(ret_val);
} /* coreotn_tx_ho_chnl_deprov */

/*******************************************************************************
*  coreotn_tx_dummy_schd_deprov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Used to deprovision a dummy schedule when transitioning from
*   UNCHANNELIZED->CHANNELIZED payload type.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 96                          
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_dummy_schd_deprov(coreotn_handle_t *coreotn_handle,
                                              UINT32 chnl_id)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;

    PMC_ENTRY();
    /* argument checking */
    if(chnl_id > 95)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }
 



    /*need to clean up RFRM configs here*/
    odu_rfrm_chnl_clean(coreotn_handle->odu_rfrm_stg3b_handle,
                        &chnl_id,
                        1);

    /*clear dummy maintenance signal context at same time as clearing RFRM
    configuration*/
    coreotn_handle->var.prev_fo1_rfrm_maint_sig[chnl_id] = 0;
    coreotn_handle->var.dummy_fo1_maint_sig[chnl_id] = 0;


    /* deactivate MPMO channel from COREOTN FO1 */                                                 
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = mpmo_ch_deactivate_for_maint_sig_insertion(coreotn_handle->mpmo_fo1_handle, 
                                                             chnl_id);
    }
                                                        
    /* deprovision MPMO channel from COREOTN FO1 */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = mpmo_ch_deprov_for_maint_sig_insertion(coreotn_handle->mpmo_fo1_handle,
                                                         chnl_id);
    }

                    
    PMC_RETURN(ret_val);
} /* coreotn_tx_dummy_schd_deprov */


/*******************************************************************************
*  coreotn_rx_lo_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Deprovisions a LO ODU channel in COREOTN.  This function is used to deprovision
*   a LO ODU channel within an active HO channel. 
*
*   Prior to calling this API, call coreotn_rx_lo_chnl_deactivate().
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   ho_chnl_id          - HO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   deprov_rfrm         - TRUE : deprovision the RFRM
*                         FALSE : do not deprovision the RFRM
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_lo_chnl_deprov(coreotn_handle_t *coreotn_handle,
                                           coreotn_mux_stage_t mux_stage,
                                           UINT32 chnl_id,
                                           UINT32 ho_chnl_id,
                                           BOOL deprov_rfrm)
{
    PMC_ERROR ret_val = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_LOG_TRACE("COREOTN_MUX_STAGE_ONE = %u\n", mux_stage);

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    /* argument checking */
    if (mux_stage > LAST_COREOTN_MUX_STAGE 
        || (mux_stage == COREOTN_MUX_STAGE_ONE && ho_chnl_id > 11)
        || (mux_stage == COREOTN_MUX_STAGE_TWO && ho_chnl_id > 95))
    {
        ret_val = COREOTN_ERR_INVALID_ARG;

    } 

    if (PMC_SUCCESS == ret_val)
    {
        if ((mux_stage == COREOTN_MUX_STAGE_ONE 
             && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED) 
            || (mux_stage == COREOTN_MUX_STAGE_ONE 
                && (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE 
                    || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)) 
            || mux_stage == COREOTN_MUX_STAGE_TWO)
        {

            /*deprov TFRM at 3B before traffic stops*/
            ret_val = odu_tfrm_chnl_prov(coreotn_handle->odu_tfrm_stg3b_handle,chnl_id,
                                         ODU_TFRM_MESSAGE_DONT_CARE,ODU_TFRM_MESSAGE_DONT_CARE,ODU_TFRM_PM_TCM_START,
                                         FALSE);
        }
    }
    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
    if (PMC_SUCCESS == ret_val)
    {
        if (mux_stage == COREOTN_MUX_STAGE_ONE) 
        {

            /* one stage muxing: ODTU_DMX_1 -> ODUKSC -> ODU_RFRM_STG2 */
            ret_val = coreotn_rx_lo_chnl_mux_one_deprov(coreotn_handle,
                                                        mux_stage,
                                                        chnl_id,
                                                        ho_chnl_id,
                                                        deprov_rfrm);

        } 
        else if (mux_stage == COREOTN_MUX_STAGE_TWO) 
        {

            ret_val = coreotn_rx_lo_chnl_mux_two_deprov(coreotn_handle,
                                                        mux_stage,
                                                        chnl_id,
                                                        ho_chnl_id);

        } 
        else 
        {
            ret_val = COREOTN_ERR_INVALID_ARG;
        }
    }

    PMC_RETURN(ret_val);
} /* coreotn_rx_lo_chnl_deprov */

/*******************************************************************************
*  coreotn_tx_lo_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Deprovisions a LO ODU channel in COREOTN. This function is used to deprovision
*   a LO ODU channel within an active HO channel. 
*
*   Prior to calling this API, call coreotn_tx_lo_chnl_deactivate().
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   ho_chnl_id          - HO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   deprov_tfrm         - TRUE : deprovision HO TFRM configuration
*                         FALSE : preserve current TFRM configuration
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_lo_chnl_deprov(coreotn_handle_t *coreotn_handle,
                                           coreotn_mux_stage_t mux_stage,
                                           UINT32 chnl_id,
                                           UINT32 ho_chnl_id,
                                           BOOL deprov_tfrm)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    BOOL deprov_deactivate_mpmo;

    PMC_ENTRY();

    PMC_LOG_TRACE("COREOTN_MUX_STAGE_ONE = %u\n", mux_stage);

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    /* argument checking */
    if (mux_stage > LAST_COREOTN_MUX_STAGE  
        || (mux_stage == COREOTN_MUX_STAGE_ONE && ho_chnl_id > 11)
        || (mux_stage == COREOTN_MUX_STAGE_TWO && ho_chnl_id > 95))
    {
        ret_val = COREOTN_ERR_INVALID_ARG;
    }

    if ((mux_stage == COREOTN_MUX_STAGE_ONE 
         && coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED) 
       || (mux_stage == COREOTN_MUX_STAGE_ONE 
           && (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE 
               || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)) 
       || mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        deprov_deactivate_mpmo = TRUE;

        odu_rfrm_chnl_clean(coreotn_handle->odu_rfrm_stg3b_handle,
                            &chnl_id,
                            1);

        /*clear dummy maintenance signal context at same time as clearing RFRM
        configuration*/
        coreotn_handle->var.prev_fo1_rfrm_maint_sig[chnl_id] = 0;
        coreotn_handle->var.dummy_fo1_maint_sig[chnl_id] = 0;
    }
    else
    {
        deprov_deactivate_mpmo = FALSE;
    }

    if (PMC_SUCCESS == ret_val) 
    {
        if (mux_stage == COREOTN_MUX_STAGE_ONE)
        {
            ret_val = coreotn_tx_lo_chnl_mux_one_deprov(coreotn_handle,
                                                        mux_stage,
                                                        chnl_id,
                                                        ho_chnl_id,
                                                        deprov_tfrm);

        } 
        else if (mux_stage == COREOTN_MUX_STAGE_TWO) 
        {
            ret_val = coreotn_tx_lo_chnl_mux_two_deprov(coreotn_handle,
                                                        mux_stage,
                                                        chnl_id,
                                                        ho_chnl_id);

        } 
        else {

            ret_val = COREOTN_ERR_INVALID_ARG;
        }
    }

    


    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if (deprov_deactivate_mpmo)
        {
            
            /* deactivate MPMO channel from COREOTN FO1 */                                                 
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = mpmo_ch_deactivate_for_maint_sig_insertion(coreotn_handle->mpmo_fo1_handle,
                                                                         chnl_id);
            }
                                                                
            /* deprovision MPMO channel from COREOTN FO1 */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = mpmo_ch_deprov_for_maint_sig_insertion(coreotn_handle->mpmo_fo1_handle,
                                                                     chnl_id);
            }
        }
    }


    PMC_RETURN(ret_val);
} /* coreotn_tx_lo_chnl_deprov */

/*******************************************************************************
* coreotn_tx_ho_chnl_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function is used to configure switch data for each multiplexing stage.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - tributary slot number
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_ho_chnl_activate(coreotn_handle_t *coreotn_handle,
                                             UINT32 chnl_id,
                                             coreotn_mux_stage_t mux_stage)
{
    PMC_ERROR ret_val = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    /* argument checking */
    if ((mux_stage == COREOTN_MUX_STAGE_TWO && chnl_id > 95) || 
        (mux_stage != COREOTN_MUX_STAGE_TWO && chnl_id > 11) || mux_stage > LAST_COREOTN_MUX_STAGE)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }


    if (mux_stage == COREOTN_MUX_STAGE_NONE) 
    {
        ret_val = coreotn_tx_ho_chnl_mux_none_activate(coreotn_handle,
                                                       chnl_id,
                                                       mux_stage);

    } 
    else if (mux_stage == COREOTN_MUX_STAGE_ONE) 
    {
        ret_val = coreotn_tx_ho_chnl_mux_one_activate(coreotn_handle,
                                                      chnl_id,
                                                      mux_stage);

    } 
    else if (mux_stage == COREOTN_MUX_STAGE_TWO) 
    {
        ret_val = coreotn_tx_ho_chnl_mux_two_activate(coreotn_handle,
                                                      chnl_id,
                                                      mux_stage);
            

        if (TRUE == pmc_coreotn_mux_empty_ho_order_revision(&coreotn_handle->base))
        {
            UINT32 num_elem_max = sizeof(coreotn_handle->var.tx_ho_chnl_ctxt)/sizeof(coreotn_handle->var.tx_ho_chnl_ctxt[0]);
            if ((PMC_SUCCESS == ret_val) && (chnl_id < num_elem_max))
            {
                if (coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].odu_container == UTIL_GLOBAL_ODU2 
                    || coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].odu_container == UTIL_GLOBAL_ODU3
                    || coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].odu_container == UTIL_GLOBAL_ODU3E1
                    || coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].odu_container == UTIL_GLOBAL_ODU3E2
                    || coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].odu_container == UTIL_GLOBAL_ODU4
                    )
                {
                    if (coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].sub_chnls_prov_cnt == 1)
                    {
                        /* set OHFS_INSERT CFC_FIFO_CLRB = '0' */
                        ret_val = odtu_mux_ohfs_insert_cfc_fifo_deactivate(coreotn_handle->odtu_mux1_handle, chnl_id);
                        
                        /* set associated HO_CH_RSTB = '0' */
                        if (PMC_SUCCESS == ret_val)
                        {
                            ret_val = odtu_mux_ho_chnl_reset_set(coreotn_handle->odtu_mux1_handle, 
                                                                 chnl_id, 0);
                        }
                        
                        /* set OHFS_INSERT CFC_FIFO_CLRB = '1' */
                        if (PMC_SUCCESS == ret_val)
                        {                                                      
                            ret_val = odtu_mux_ohfs_insert_cfc_fifo_activate(coreotn_handle->odtu_mux1_handle, chnl_id);
                        }
                        
                        /* set HO_CH_RSTB = '1' */
                        if (PMC_SUCCESS == ret_val)
                        {
                            ret_val = odtu_mux_ho_chnl_reset_set(coreotn_handle->odtu_mux1_handle, 
                                                                 chnl_id, 1);
                        }
                    } 
                }
            } 
        }
    } else {

        ret_val = COREOTN_ERR_INVALID_ARG;
    }

    PMC_RETURN(ret_val);
} /* coreotn_tx_ho_chnl_activate */

/*******************************************************************************
* coreotn_tx_ho_chnl_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function deactivates the HO or MO in ODTU_MUX depending on the multiplexing
*   stage.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - tributary slot number
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_ho_chnl_deactivate(coreotn_handle_t *coreotn_handle,
                                               UINT32 chnl_id,
                                               coreotn_mux_stage_t mux_stage)
{
    UINT32 i;
    PMC_ERROR ret_val = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    /* argument checking */
    if (mux_stage > LAST_COREOTN_MUX_STAGE
        || (mux_stage == COREOTN_MUX_STAGE_ONE && chnl_id > 11))
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        /* check the lo_chnl_id ptr */
        for (i = 0; i < 96; i++)
        {
            PMC_LOG_TRACE("coreotn_handle->odtu_mux1_handle->sts_sw_handle->var.ho_chnl_cfg[%u].lo_chnl_ids_ptr[%u] = %u\n",
                          chnl_id, i,
                          coreotn_handle->odtu_mux1_handle->sts_sw_handle->var.ho_chnl_cfg[chnl_id].lo_chnl_ids_ptr[i]);
        }
    }
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        /* check the lo_chnl_id ptr */
        for (i = 0; i < 96; i++)
        {
            PMC_LOG_TRACE("coreotn_handle->odtu_mux2_handle->sts_sw_handle->var.ho_chnl_cfg[%u].lo_chnl_ids_ptr[%u] = %u\n",
                          chnl_id, i,
                          coreotn_handle->odtu_mux2_handle->sts_sw_handle->var.ho_chnl_cfg[chnl_id].lo_chnl_ids_ptr[i]);
        }
    }

    if (mux_stage == COREOTN_MUX_STAGE_NONE) 
    {
        ret_val = coreotn_tx_ho_chnl_mux_none_deactivate(coreotn_handle,
                                                         chnl_id,
                                                         mux_stage);
    } 
    else if (mux_stage == COREOTN_MUX_STAGE_ONE) 
    {
        ret_val = coreotn_tx_ho_chnl_mux_one_deactivate(coreotn_handle,
                                                        chnl_id,
                                                        mux_stage);
    } 
    else if (mux_stage == COREOTN_MUX_STAGE_TWO) 
    {
        ret_val = coreotn_tx_ho_chnl_mux_two_deactivate(coreotn_handle,
                                                        chnl_id,
                                                        mux_stage);
    }

    PMC_RETURN(ret_val);
} /* coreotn_tx_ho_chnl_deactivate */

/*******************************************************************************
* coreotn_tx_lo_chnl_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function deactivates the MO or LO channel depending on the multiplexing
*   stage. 
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   ho_chnl_id          - HO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - Enum for mux_stage. See coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_lo_chnl_deactivate(coreotn_handle_t *coreotn_handle,
                                               UINT32 chnl_id, UINT32 ho_chnl_id,
                                               coreotn_mux_stage_t mux_stage)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    odtu_mux_handle_t *lo_mux_handle_ptr = NULL;

    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    
    /* argument checking */
    if (chnl_id > 95 || mux_stage > LAST_COREOTN_MUX_STAGE
        || ho_chnl_id > 95)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    if (PMC_SUCCESS == ret_val)
    {  
        if(coreotn_handle->var.init_operation != COREOTN_SS_SYSOTN_MODE)
        {
            if (mux_stage == COREOTN_MUX_STAGE_ONE)
            {
                /* switch configuration */
                lo_mux_handle_ptr = coreotn_handle->odtu_mux1_handle;
            }
            else if (mux_stage == COREOTN_MUX_STAGE_TWO)
            {
                /* switch configuration */
                lo_mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
            }
            else {
                PMC_RETURN(COREOTN_ERR_NULL_HANDLE);
            }
        }
        else
        {
            if (mux_stage == COREOTN_MUX_STAGE_ONE)
            {
                /* switch configuration */
                lo_mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
            }
            else {
                PMC_RETURN(COREOTN_ERR_NULL_HANDLE);
            }
        }
    } 

    
    if (mux_stage == COREOTN_MUX_STAGE_ONE) 
    {

        ret_val = coreotn_tx_lo_chnl_mux_none_or_one_deactivate(coreotn_handle,
                                                                chnl_id,
                                                                ho_chnl_id,
                                                                lo_mux_handle_ptr);

    } 
    
    if (mux_stage == COREOTN_MUX_STAGE_TWO) 
    {

        ret_val = coreotn_tx_lo_chnl_mux_none_or_two_deactivate(coreotn_handle,
                                                                chnl_id,
                                                                ho_chnl_id);

    }

    PMC_RETURN(ret_val);
} /* coreotn_tx_lo_chnl_deactivate */

/*******************************************************************************
* coreotn_tx_lo_chnl_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function activates the MO or LO channel depending on the multiplexing
*   stage.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   ho_chnl_id          - HO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - Enum for mux stage. See coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_lo_chnl_activate(coreotn_handle_t *coreotn_handle,
                                             UINT32 chnl_id,
                                             UINT32 ho_chnl_id,
                                             coreotn_mux_stage_t mux_stage)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    util_global_odukp_type_t ho_odu_rate = UTIL_GLOBAL_LAST_ODUK;
    util_global_odukp_type_t lo_odu_rate = UTIL_GLOBAL_LAST_ODUK;
    UINT32 odu_flex_rate = 0;
    UINT32 cbr_flex_rate = 0;
    util_global_odu_line_payload_t ho_payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
    coreotn_mapping_type_t mapping_mode = (coreotn_mapping_type_t)UTIL_GLOBAL_NO_MAP;
    UINT32 tribslot_mask[COREOTN_TRIB_WRD_CNT];
    UINT32 trib_port = 0;
    UINT32 ultimate_ho_id = 0;
    UINT32 new_lo_chnl_ids[96];
    UINT32 num_new_lo = 0;
    UINT32 i;
    odtu_mux_handle_t *lo_mux_handle_ptr = NULL;

    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    /* argument checking */
    if (mux_stage > LAST_COREOTN_MUX_STAGE
        || (mux_stage == COREOTN_MUX_STAGE_ONE && ho_chnl_id > 11))
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    /* write to the switch for active page */
    if (PMC_SUCCESS == ret_val)
    {  
        if(coreotn_handle->var.init_operation != COREOTN_SS_SYSOTN_MODE)
        {
            if (mux_stage == COREOTN_MUX_STAGE_ONE)
            {
                /* switch configuration */
                lo_mux_handle_ptr = coreotn_handle->odtu_mux1_handle;
            }
            else if (mux_stage == COREOTN_MUX_STAGE_TWO)
            {
                /* switch configuration */
                lo_mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
            }
        }
        else
        {
            if (mux_stage == COREOTN_MUX_STAGE_ONE)
            {
                /* switch configuration */
                lo_mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
            }
        }
    } 

    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if(PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_ho_chnl_switch_cfg(lo_mux_handle_ptr,
                                                  ho_chnl_id, FALSE);
        }
            
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_tx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                          lo_mux_handle_ptr,
                                                          ho_chnl_id);
        } 
    }
    

    if (PMC_SUCCESS == ret_val)
    {
        if (mux_stage == COREOTN_MUX_STAGE_ONE) 
        {      
            ret_val = coreotn_tx_lo_chnl_mux_none_or_one_activate(coreotn_handle,
                                                                  chnl_id,
                                                                  ho_chnl_id,
                                                                  lo_mux_handle_ptr,
                                                                  &lo_odu_rate,
                                                                  &odu_flex_rate,
                                                                  &mapping_mode,
                                                                  tribslot_mask,
                                                                  &trib_port,
                                                                  &ho_payload_format,
                                                                  &ho_odu_rate,
                                                                  &cbr_flex_rate);
        
        } 
    
        if (mux_stage == COREOTN_MUX_STAGE_TWO) 
        {
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = coreotn_tx_lo_chnl_mux_none_or_two_activate(coreotn_handle,
                                                                      chnl_id,
                                                                      ho_chnl_id,
                                                                      &lo_odu_rate,
                                                                      &odu_flex_rate,
                                                                      &mapping_mode,
                                                                      tribslot_mask,
                                                                      &trib_port,
                                                                      &ho_payload_format,
                                                                      &ho_odu_rate,
                                                                      &cbr_flex_rate);
            }        
        }

    
        /* update offline memory to maintain synchronization between both pages */
        if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT) 
        {
            if (mux_stage != COREOTN_MUX_STAGE_NONE) 
            {              
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = coreotn_tx_lo_chnl_offline_update(coreotn_handle,
                                                                chnl_id, 
                                                                mux_stage,
                                                                lo_odu_rate,
                                                                odu_flex_rate,
                                                                mapping_mode,
                                                                tribslot_mask,
                                                                trib_port,
                                                                ho_payload_format,
                                                                ho_odu_rate,
                                                                ho_chnl_id,
                                                                cbr_flex_rate);
                  
                    if (PMC_SUCCESS == ret_val)
                    {
                        /* switch configuration */
                        ret_val = odtu_mux_ho_chnl_switch_cfg(lo_mux_handle_ptr,
                                                              ho_chnl_id,
                                                              FALSE);
                    }
                }                
            }
        }
        else {      
            /* if this is the last LO channel being added in super prov 
            ** then swap the page and configure all LO in the offline page
            */ 
            if (mux_stage == COREOTN_MUX_STAGE_ONE)
            {
                if (coreotn_handle->var.mux_profile[ho_chnl_id].num_mo_chnls != 0xFF
                    && coreotn_handle->var.mux_profile[ho_chnl_id].num_lo_chnls != 0xFF)
                {
                    for (i = 0; i < 96; i++)
                    {
                        new_lo_chnl_ids[i] = 0x7F;
                    }

                    /* get all LO channel IDs */
                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = coreotn_tx_lo_chnl_ids_get(coreotn_handle, 
                                                             mux_stage, 
                                                             ho_chnl_id, 
                                                             new_lo_chnl_ids, 
                                                             &num_new_lo);
                    }

                    if (coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_cfg_state == COREOTN_LO_ODU_CHNL_CFG_END)
                    {
                        /* 1) configure STS_SW */
                        if (PMC_SUCCESS == ret_val)
                        {
                            ret_val = odtu_mux_ho_chnl_switch_cfg(lo_mux_handle_ptr,
                                                                  ho_chnl_id,
                                                                  FALSE);
                        }                                                                  
                        
                        /* 2) swap the page */
                        if (PMC_SUCCESS == ret_val)
                        {
                            ret_val = coreotn_tx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                                          lo_mux_handle_ptr,
                                                                          ho_chnl_id);
                        }

                        /* 3) configure offline page */
                        if (PMC_SUCCESS == ret_val)
                        {
                            ret_val = coreotn_tx_lo_chnl_offline_update_all(coreotn_handle,
                                                                            mux_stage,
                                                                            ho_chnl_id,
                                                                            new_lo_chnl_ids, 
                                                                            num_new_lo);
                        }
                        
                        /* 4) configure STS_SW */
                        if (PMC_SUCCESS == ret_val)
                        {
                            ret_val = odtu_mux_ho_chnl_switch_cfg(lo_mux_handle_ptr,
                                                                  ho_chnl_id,
                                                                  FALSE);
                        } 
                    }
                }  
            }
            
                
            if (mux_stage == COREOTN_MUX_STAGE_TWO)
            {
                odtu_mux_ho_ch_id_get(coreotn_handle->odtu_mux1_handle, ho_chnl_id, &ultimate_ho_id);
                                      
                if( ultimate_ho_id < (sizeof(coreotn_handle->var.mux_profile)/sizeof(coreotn_handle->var.mux_profile[0])) )
                {
                    if (coreotn_handle->var.mux_profile[ultimate_ho_id].num_mo_chnls != 0xFF
                        && coreotn_handle->var.mux_profile[ultimate_ho_id].num_lo_chnls != 0xFF)
                    {
                        for (i = 0; i < 96; i++)
                        {
                            new_lo_chnl_ids[i] = 0x7F;
                        }

                        /* get all LO channel IDs */
                        if (PMC_SUCCESS == ret_val)
                        {
                            ret_val = coreotn_tx_lo_chnl_ids_get(coreotn_handle, 
                                                                 mux_stage, 
                                                                 ho_chnl_id, 
                                                                 new_lo_chnl_ids, 
                                                                 &num_new_lo);
                        }

                        if (coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_cfg_state == COREOTN_LO_ODU_CHNL_CFG_END)
                        {
                            /* 1) configure STS_SW */
                            if (PMC_SUCCESS == ret_val)
                            {
                                ret_val = odtu_mux_ho_chnl_switch_cfg(lo_mux_handle_ptr,
                                                                      ho_chnl_id,
                                                                      FALSE);
                            }                                                                  
                            
                            /* 2) swap the page */
                            if (PMC_SUCCESS == ret_val)
                            {
                                ret_val = coreotn_tx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                                              lo_mux_handle_ptr,
                                                                              ho_chnl_id);
                            }
                            
                            /* 3) configure offline page */
                            if (PMC_SUCCESS == ret_val)
                            {
                                ret_val = coreotn_tx_lo_chnl_offline_update_all(coreotn_handle,
                                                                                mux_stage,
                                                                                ho_chnl_id,
                                                                                new_lo_chnl_ids, 
                                                                                num_new_lo);
                            }
                            
                            /* 4) configure STS_SW */
                            if (PMC_SUCCESS == ret_val)
                            {
                                ret_val = odtu_mux_ho_chnl_switch_cfg(lo_mux_handle_ptr,
                                                                      ho_chnl_id,
                                                                      FALSE);
                            } 
                        }  
                    }
                }
                else
                {
                    ret_val = COREOTN_ERR_INVALID_ARG;
                }
            }    
        }

    }
    
    PMC_RETURN(ret_val);
} /* coreotn_tx_lo_chnl_activate */


/*******************************************************************************
* coreotn_tx_lo_chnl_offline_deactivate_all
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API deactivates and deprovisions all LO channels that have recently
*   been removed from the active page.
* 
*   This API is only used when bulk deprovisioning is used by calling
*   coreotn_odu_chnl_prov_mode_set() with COREOTN_ODU_CHNL_PROV_ALL.
*   When this API is called, only currently being deprovisioned LO channels
*   are removed from the offline page without affecting the remaining LO channels
*   within the same HO or MO channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   ho_chnl_id          - HO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - Enum for mux stage. See coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_lo_chnl_offline_deactivate_all(coreotn_handle_t *coreotn_handle,
                                                           UINT32 ho_chnl_id,
                                                           coreotn_mux_stage_t mux_stage)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 lo_chnl_ids[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    UINT32 local_lo_chnl_ids[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    UINT32 num_lo_deprov = 0;
    UINT32 i;
    odtu_mux_handle_t *odtu_mux_handle_ptr = NULL;
    
    PMC_ENTRY();

    for (i = 0; i < UTIL_GLOBAL_MAX_NUM_ODU_CHNL; i++)
    {
        lo_chnl_ids[i] = 0x7F;
        local_lo_chnl_ids[i] = 0x7F;
    }
       
    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE
            || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
        {
            odtu_mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
        }
        else {
            odtu_mux_handle_ptr = coreotn_handle->odtu_mux1_handle;
        }
        
        /* get the LO channel ids from STS_SW to push the list down to deprov_all()*/
        ret_val = sts_sw_lo_chnl_ids_get(odtu_mux_handle_ptr->sts_sw_handle,
                                         ho_chnl_id, lo_chnl_ids);

        if (PMC_SUCCESS == ret_val)   
        {
            for (i = 0; i < UTIL_GLOBAL_MAX_NUM_ODU_CHNL; i++)
            {    
                /* gather only the LO channel IDs to be provisioned in this run */
                if (lo_chnl_ids[i] != 0x7F 
                    && coreotn_handle->var.tx_mo_chnl_ctxt[lo_chnl_ids[i]].chnl_state == COREOTN_CHNL_DEPROV_PENDING)
                {
                    local_lo_chnl_ids[num_lo_deprov] = lo_chnl_ids[i];
                    num_lo_deprov++;
                }     
            }
        }

        /* update the channel ID list in STS_SW */
        for (i = 0; i < num_lo_deprov && PMC_SUCCESS == ret_val; i++)
        {
            ret_val = sts_sw_lo_chnl_ids_ptr_ctxt_reset(odtu_mux_handle_ptr->sts_sw_handle, 
                                                        ho_chnl_id, local_lo_chnl_ids[i]);
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* 1) configure STS_SW */
            ret_val = odtu_mux_ho_chnl_switch_cfg(odtu_mux_handle_ptr,
                                                  ho_chnl_id,
                                                  TRUE);                                                 
        }

        /* 2) swap the page */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_tx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                          odtu_mux_handle_ptr,
                                                          ho_chnl_id);
        }
        PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_tx_lo_chnl_offline_deprov_all(coreotn_handle,
                                                            mux_stage,
                                                            ho_chnl_id,
                                                            local_lo_chnl_ids,
                                                            num_lo_deprov);
        }
        PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
    }    
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        ret_val = sts_sw_lo_chnl_ids_get(coreotn_handle->odtu_mux2_handle->sts_sw_handle, 
                                         ho_chnl_id, lo_chnl_ids);
 
        if (PMC_SUCCESS == ret_val)   
        {
            for (i = 0; i < UTIL_GLOBAL_MAX_NUM_ODU_CHNL; i++)
            {    
                /* gather only the LO channel IDs to be provisioned in this run */
                if (lo_chnl_ids[i] != 0x7F 
                    && coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_ids[i]].chnl_state == COREOTN_CHNL_DEPROV_PENDING)
                {
                    local_lo_chnl_ids[num_lo_deprov] = lo_chnl_ids[i];
                    num_lo_deprov++;
                }     
            }
        } 

        /* update the channel ID list in STS_SW */
        for (i = 0; i < num_lo_deprov && PMC_SUCCESS == ret_val; i++)
        {
            ret_val = sts_sw_lo_chnl_ids_ptr_ctxt_reset(coreotn_handle->odtu_mux2_handle->sts_sw_handle, 
                                                        ho_chnl_id, local_lo_chnl_ids[i]);
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* 1) configure STS_SW */
            ret_val = odtu_mux_ho_chnl_switch_cfg(coreotn_handle->odtu_mux2_handle,
                                                  ho_chnl_id, TRUE);
        }
        
        /* 2) swap the page */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_tx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                          coreotn_handle->odtu_mux2_handle,
                                                          ho_chnl_id);
        }
        PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
        /* 3) configure offline page */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_tx_lo_chnl_offline_deprov_all(coreotn_handle,
                                                            mux_stage,
                                                            ho_chnl_id,
                                                            local_lo_chnl_ids,
                                                            num_lo_deprov);
        }
        PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);


    } 
    
    PMC_RETURN(ret_val);
} /* coreotn_tx_lo_chnl_offline_deactivate_all */ 


/*******************************************************************************
* coreotn_tx_lo_chnl_offline_activate_all
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API is used to perform a page swap and configure all currently pending
*   LO channels into the offline page upon the issuance of the last channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   ho_chnl_id          - HO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - Enum for mux stage. See coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_lo_chnl_offline_activate_all(coreotn_handle_t *coreotn_handle,
                                                         UINT32 ho_chnl_id,
                                                         coreotn_mux_stage_t mux_stage)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    odtu_mux_handle_t *odtu_mux_handle_ptr = NULL;
    UINT32 new_lo_chnl_ids[96];
    UINT32 num_new_lo = 0;
    UINT32 i;
    
    PMC_ENTRY();

    /* initialize the output array */
    for (i = 0; i < 96; i++)
    {
        new_lo_chnl_ids[i] = 0x7F;
    }
    
    if (mux_stage == COREOTN_MUX_STAGE_NONE || mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE
            || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
        {
            odtu_mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
        }
        else {
            odtu_mux_handle_ptr = coreotn_handle->odtu_mux1_handle;
        }

        /* 1) configure STS_SW */
        ret_val = odtu_mux_ho_chnl_switch_cfg(odtu_mux_handle_ptr,
                                              ho_chnl_id, TRUE);
        
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_tx_lo_chnl_ids_get(coreotn_handle,
                                                 mux_stage,
                                                 ho_chnl_id,
                                                 new_lo_chnl_ids,
                                                 &num_new_lo);                                                
        }

        /* using HO_CH_RSTB instead of the page swap can be done only when the
        ** HO is empty. Once the HO is active, page_swap must be used.
        */
        if (PMC_SUCCESS == ret_val)
        {
            if (coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == num_new_lo)
            {
                ret_val = odtu_mux_ho_chnl_activate(odtu_mux_handle_ptr, ho_chnl_id);

                if (ret_val == (UINT32)ODTU_MUX_CHNL_OPERATIONAL)
                {
                    ret_val = coreotn_tx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                                  odtu_mux_handle_ptr,
                                                                  ho_chnl_id);
                }
                else {
                    PMC_Q_USLEEP(coreotn_handle, 1);

                    /* configure the offline page of the HO */
                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = coreotn_tx_ho_chnl_offline_update(coreotn_handle, 
                                                                    ho_chnl_id, 
                                                                    mux_stage,
                                                                    coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].odu_container,
                                                                    coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].payload_format);
                    }
                }
            }
            else {
                ret_val = coreotn_tx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                              odtu_mux_handle_ptr,
                                                              ho_chnl_id);
            }
        }
     
        /* 3) configure offline page */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_tx_lo_chnl_offline_update_all(coreotn_handle,
                                                            mux_stage,
                                                            ho_chnl_id,
                                                            new_lo_chnl_ids,
                                                            num_new_lo);                                                            
        }
       
    }  
    
    if (mux_stage == COREOTN_MUX_STAGE_NONE || mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        /* 1) configure STS_SW */
        ret_val = odtu_mux_ho_chnl_switch_cfg(coreotn_handle->odtu_mux2_handle,
                                              ho_chnl_id, TRUE);

        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_tx_lo_chnl_ids_get(coreotn_handle,
                                                 mux_stage,
                                                 ho_chnl_id,
                                                 new_lo_chnl_ids,
                                                 &num_new_lo);                                                
        }


        if (PMC_SUCCESS == ret_val)
        {
            if (coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == num_new_lo)
            {
                ret_val = odtu_mux_ho_chnl_activate(coreotn_handle->odtu_mux2_handle, ho_chnl_id);
                if (ret_val == (UINT32)ODTU_MUX_CHNL_OPERATIONAL)
                {
                    ret_val = coreotn_tx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                                  coreotn_handle->odtu_mux2_handle,
                                                                  ho_chnl_id);
                }
                else {
                    PMC_Q_USLEEP(coreotn_handle, 1);

                    /* configure the offline page of the HO */
                    /* when mux_statge == 2, need to configure MO in FMF2 on the offline page */
                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = coreotn_tx_ho_chnl_offline_update(coreotn_handle, 
                                                                    ho_chnl_id, 
                                                                    mux_stage,
                                                                    coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].odu_container,
                                                                    coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].payload_format);
                    }
                }
            }
            else {
                ret_val = coreotn_tx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                              coreotn_handle->odtu_mux2_handle,
                                                              ho_chnl_id);
            }
        }
    
        /* 3) configure offline page */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_tx_lo_chnl_offline_update_all(coreotn_handle,
                                                            mux_stage,
                                                            ho_chnl_id,
                                                            new_lo_chnl_ids,
                                                            num_new_lo);
        }
        

    } 
    
    PMC_RETURN(ret_val);
} /* coreotn_tx_lo_chnl_offline_activate_all */ 

/*******************************************************************************
* coreotn_tx_lo_chnl_add_ho_page_swap
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function performs a page swap in ODTU_MUX block when a new LO channel 
*   gets added to an existing MO or HO or when an existing LO channel is removed
*   from the existing MO or HO channel.
*
* INPUTS:
*   *coreotn_handle         - pointer to COREOTN handle instance
*   *lo_mux_handle_ptr      - LO ODU channel ID to be configured
*                             Valid range: 0 - 95
*   ho_chnl_id              - HO channel ID
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_lo_chnl_add_ho_page_swap(coreotn_handle_t *coreotn_handle,
                                                      odtu_mux_handle_t *lo_mux_handle_ptr,
                                                      UINT32 ho_chnl_id)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    
    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != lo_mux_handle_ptr, COREOTN_ERR_NULL_HANDLE, 0, 0);
        
    /* config update */
    if (PMC_SUCCESS == ret_val)
    {
    
        ret_val = odtu_mux_config_update(lo_mux_handle_ptr,
                                         ho_chnl_id, 0, 0, 1);
    }
    
    PMC_LOG_TRACE("before polling...\n");
    
    /* poll config_update */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = odtu_mux_config_update_poll(lo_mux_handle_ptr,
                                              ho_chnl_id, 
                                              COREOTN_POLL_COUNT_MAX);
    }
    
    PMC_RETURN(ret_val);
    
} /* coreotn_tx_lo_chnl_add_ho_page_swap */

/*******************************************************************************
* coreotn_rx_ho_chnl_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API activates the HO or MO in ODTU_DMX block depending on the
*   multiplexing stage.
* 
*   When the HO or MO channel is activated, this also swaps the configuration
*   page. Once the configuration page is swapped, the offline page of the channel
*   gets configured with the same data used to configure the active page.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - tributary slot number
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_ho_chnl_activate(coreotn_handle_t *coreotn_handle,
                                             UINT32 chnl_id,
                                             coreotn_mux_stage_t mux_stage)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    coreotn_odu_chnl_prov_mode_t prov_mode = LAST_COREOTN_CHNL_PROV_MODE;

    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    /* argument checking */
    if (mux_stage > LAST_COREOTN_MUX_STAGE
        || (mux_stage == COREOTN_MUX_STAGE_ONE && chnl_id > 11))
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    ret_val = coreotn_odu_chnl_prov_mode_get(coreotn_handle, &prov_mode);

    if (PMC_SUCCESS == ret_val)
    {
        /* check the lo_chnl_id ptr */
#ifndef LOGGING_DISABLED
        UINT32 i;
        for (i = 0; i < 96; i++)
        {
            PMC_LOG_TRACE("coreotn_handle->odtu_dmx1_handle->sts_sw_handle->var.ho_chnl_cfg[%u].lo_chnl_ids_ptr[%u] = %u\n",
                          chnl_id, i,
                          coreotn_handle->odtu_dmx1_handle->sts_sw_handle->var.ho_chnl_cfg[chnl_id].lo_chnl_ids_ptr[i]);
        }
#endif

        if (mux_stage == COREOTN_MUX_STAGE_NONE) {

            ret_val = coreotn_rx_ho_chnl_mux_none_activate(coreotn_handle,
                                                           chnl_id,
                                                           mux_stage);

        } else if (mux_stage == COREOTN_MUX_STAGE_ONE) {

            ret_val = coreotn_rx_ho_chnl_mux_one_activate(coreotn_handle,
                                                          chnl_id,
                                                          mux_stage);

        } else if (mux_stage == COREOTN_MUX_STAGE_TWO) {

            ret_val = coreotn_rx_ho_chnl_mux_two_activate(coreotn_handle,
                                                          chnl_id,
                                                          mux_stage);

        } else {

            ret_val = COREOTN_ERR_INVALID_ARG;
        }
    }

    if (PMC_SUCCESS == ret_val && prov_mode != COREOTN_ODU_CHNL_PROV_ALL)
    {
        ret_val = coreotn_rx_ho_chnl_offline_update(coreotn_handle, chnl_id,
                                                    mux_stage,
                                                    coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].odu_container,
                                                    coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].payload_format);
    }

    PMC_RETURN(ret_val);
} /* coreotn_rx_ho_chnl_activate */

/*******************************************************************************
* coreotn_rx_ho_chnl_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function deacitvates the HO or MO channel depending on the multiplexing
*   stage.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - Enum, see coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_ho_chnl_deactivate(coreotn_handle_t *coreotn_handle,
                                               UINT32 chnl_id,
                                               coreotn_mux_stage_t mux_stage)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 i;

    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    /* argument checking */
    if (mux_stage > LAST_COREOTN_MUX_STAGE
        || (mux_stage == COREOTN_MUX_STAGE_ONE && chnl_id > 11))
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }
    
    /* check the lo_chnl_id ptr */
    for (i = 0; i < 96; i++)
    {
        PMC_LOG_TRACE("coreotn_handle->odtu_dmx1_handle->sts_sw_handle->var.ho_chnl_cfg[%u].lo_chnl_ids_ptr[%u] = %u\n",
                      chnl_id, i,
                      coreotn_handle->odtu_dmx1_handle->sts_sw_handle->var.ho_chnl_cfg[chnl_id].lo_chnl_ids_ptr[i]);
    }

    if (mux_stage == COREOTN_MUX_STAGE_NONE) {

        ret_val = coreotn_rx_ho_chnl_mux_none_deactivate(coreotn_handle,
                                                         chnl_id,
                                                         mux_stage);

    } else if (mux_stage == COREOTN_MUX_STAGE_ONE) {

        ret_val = coreotn_rx_ho_chnl_mux_one_deactivate(coreotn_handle,
                                                        chnl_id,
                                                        mux_stage);

    } else if (mux_stage == COREOTN_MUX_STAGE_TWO) {

        ret_val = coreotn_rx_ho_chnl_mux_two_deactivate(coreotn_handle,
                                                        chnl_id,
                                                        mux_stage);
    }

    PMC_RETURN(ret_val);
} /* coreotn_rx_ho_chnl_deactivate */

/*******************************************************************************
* coreotn_rx_lo_chnl_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API deactivates the MO or LO channel in ODTU_DMX block depending on the
*   multiplexing stage.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   ho_chnl_id          - HO ODU channel that the current LO belongs to.
*                         Valid range: 0 - 95
*   mux_stage           - Enum for mux stage. See coreotn_mux_stage_t
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_lo_chnl_deactivate(coreotn_handle_t *coreotn_handle,
                                               UINT32 chnl_id, 
                                               UINT32 ho_chnl_id,
                                               coreotn_mux_stage_t mux_stage)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    odtu_dmx_handle_t *lo_dmx_handle_ptr = NULL;
    odujat_handle_t *lo_odujat_handle_ptr = NULL;
    oduksc_handle_t *lo_oduksc_handle_ptr = NULL;
    
    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    /* argument checking */
    if (chnl_id > 95 || mux_stage > LAST_COREOTN_MUX_STAGE 
        || (mux_stage != COREOTN_MUX_STAGE_TWO && ho_chnl_id > 11)
        || (mux_stage == COREOTN_MUX_STAGE_TWO && ho_chnl_id > 95))
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }


    if (mux_stage != COREOTN_MUX_STAGE_TWO)
    {
        if(coreotn_handle->var.init_operation != COREOTN_SS_SYSOTN_MODE)
        {
            lo_dmx_handle_ptr = coreotn_handle->odtu_dmx1_handle;
            lo_odujat_handle_ptr = coreotn_handle->odujat1_handle;
            lo_oduksc_handle_ptr = coreotn_handle->oduksc1_handle;
        }
        else
        {
            lo_dmx_handle_ptr = coreotn_handle->odtu_dmx2_handle;
            lo_odujat_handle_ptr = coreotn_handle->odujat2_handle;
            lo_oduksc_handle_ptr = coreotn_handle->oduksc2_handle;
        }
    }
    else 
    {
        lo_dmx_handle_ptr = coreotn_handle->odtu_dmx2_handle;
        lo_odujat_handle_ptr = coreotn_handle->odujat2_handle;
        lo_oduksc_handle_ptr = coreotn_handle->oduksc2_handle;
    }

    if (mux_stage == COREOTN_MUX_STAGE_NONE || mux_stage == COREOTN_MUX_STAGE_ONE) {

        ret_val = coreotn_rx_lo_chnl_mux_none_or_one_deactivate(coreotn_handle,
                                                                chnl_id,
                                                                ho_chnl_id,
                                                                lo_dmx_handle_ptr,
                                                                lo_odujat_handle_ptr,
                                                                lo_oduksc_handle_ptr);

        /* variable declaration */
    } 
    
    if (mux_stage == COREOTN_MUX_STAGE_NONE || mux_stage == COREOTN_MUX_STAGE_TWO) {

        ret_val = coreotn_rx_lo_chnl_mux_none_or_two_deactivate(coreotn_handle,
                                                                chnl_id,
                                                                ho_chnl_id,
                                                                lo_dmx_handle_ptr,
                                                                lo_odujat_handle_ptr,
                                                                lo_oduksc_handle_ptr);

    }

    PMC_RETURN(ret_val);
} /* coreotn_rx_lo_chnl_deactivate */

/*******************************************************************************
* coreotn_rx_lo_chnl_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API activates the MO or LO channel in ODTU_DMX depending on the
*   de-multiplexing stage provided in 'mux_stage' input argument.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   ho_chnl_id          - HO ODU channel ID that the current LO belongs to.
*                         Valid range: 0 - 95
*   mux_stage           - Enum for mux stage. See coreotn_mux_stage_t.
*   activate_rfrm        - TRUE : activate RFRM
*                          FALSE : do no activate RFRM 
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_lo_chnl_activate(coreotn_handle_t *coreotn_handle,
                                             UINT32 chnl_id, UINT32 ho_chnl_id,
                                             coreotn_mux_stage_t mux_stage,
                                             BOOL activate_rfrm)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    odtu_dmx_handle_t *lo_dmx_handle_ptr = NULL;
    odujat_handle_t *lo_odujat_handle_ptr = NULL;
    oduksc_handle_t *lo_oduksc_handle_ptr = NULL; 
    UINT32 ho_sub_prov_cnt = 0;
    UINT32 mo_sub_prov_cnt = 0;
    BOOL8 page_swap = FALSE;
    

    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    /* argument checking */
    if (chnl_id > 95 || mux_stage > LAST_COREOTN_MUX_STAGE 
        || (mux_stage == COREOTN_MUX_STAGE_ONE && ho_chnl_id > 11))
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if(coreotn_handle->var.init_operation != COREOTN_SS_SYSOTN_MODE)
        {
            lo_dmx_handle_ptr = coreotn_handle->odtu_dmx1_handle;
            lo_odujat_handle_ptr = coreotn_handle->odujat1_handle;
            lo_oduksc_handle_ptr = coreotn_handle->oduksc1_handle;
        }
        else
        {
            lo_dmx_handle_ptr = coreotn_handle->odtu_dmx2_handle;
            lo_odujat_handle_ptr = coreotn_handle->odujat2_handle;
            lo_oduksc_handle_ptr = coreotn_handle->oduksc2_handle;
        }
    }
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        lo_dmx_handle_ptr = coreotn_handle->odtu_dmx2_handle;
        lo_odujat_handle_ptr = coreotn_handle->odujat2_handle;
        lo_oduksc_handle_ptr = coreotn_handle->oduksc2_handle;
    }
    
    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);

    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if ((mux_stage == COREOTN_MUX_STAGE_ONE) || (mux_stage == COREOTN_MUX_STAGE_TWO)) 
        {
            ret_val = odtu_dmx_ho_chnl_switch_cfg(lo_dmx_handle_ptr,
                                                  ho_chnl_id, FALSE);
        }
    }
    
    
    if (PMC_SUCCESS == ret_val)
    {
        ho_sub_prov_cnt = coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt;
        mo_sub_prov_cnt = coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt;
    
        if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
        {  
            if (pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base) == TRUE)
            {
                if (mux_stage == COREOTN_MUX_STAGE_ONE) 
                {
                    page_swap = (ho_sub_prov_cnt == 1)? FALSE:TRUE;
                }
                else if (mux_stage == COREOTN_MUX_STAGE_TWO) 
                {
                    page_swap = (mo_sub_prov_cnt == 1)? FALSE:TRUE;
                }
            }
            else {
                page_swap = TRUE;
            }
            
            if (mux_stage == COREOTN_MUX_STAGE_ONE && page_swap == TRUE)    
            {                                                
            
                if (PMC_SUCCESS == ret_val)
                {
                    if (TRUE == pmc_coreotn_dmx_two_stage_proxy_mo_chnl_prov_revision(&coreotn_handle->base)
                        && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format != UTIL_GLOBAL_ODU_UNCHANNELIZED
                        && coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
                    {
                        ret_val = odtu_dmx_temp_mo_chnl_prov(coreotn_handle->odtu_dmx2_handle,
                                                             (odtu_dmx_stage_instance_t)COREOTN_MUX_STAGE_TWO,
                                                             chnl_id,
                                                             coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].lo_odu_rate,
                                                             coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format);
                    }                                                         
                }
            
                if (PMC_SUCCESS == ret_val)
                {
                    /* read once to see what the value is  */
                    ret_val = coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                                  lo_dmx_handle_ptr,
                                                                  ho_chnl_id);               
                }
            }
            /*else if (mux_stage == COREOTN_MUX_STAGE_TWO && coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt != 1)*/
            else if (mux_stage == COREOTN_MUX_STAGE_TWO && page_swap == TRUE)
            {            
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                                  lo_dmx_handle_ptr,
                                                                  ho_chnl_id);        
                }
            }                                                              
        }
        else {

            if (mux_stage == COREOTN_MUX_STAGE_ONE)    
            {                                                
            
                if (TRUE == pmc_coreotn_dmx_two_stage_proxy_mo_chnl_prov_revision(&coreotn_handle->base)
                    && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format != UTIL_GLOBAL_ODU_UNCHANNELIZED)
                {
                    ret_val = odtu_dmx_temp_mo_chnl_prov(coreotn_handle->odtu_dmx2_handle,
                                                         (odtu_dmx_stage_instance_t)COREOTN_MUX_STAGE_TWO,
                                                         chnl_id,
                                                         coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].lo_odu_rate,
                                                         coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format);
                }                                                         
            }
        }
    }
     
    if (PMC_SUCCESS == ret_val) 
    {

        if (mux_stage == COREOTN_MUX_STAGE_NONE) {

            ret_val = coreotn_rx_lo_chnl_mux_none_activate(coreotn_handle,
                                                           chnl_id,
                                                           ho_chnl_id);

        } else if (mux_stage == COREOTN_MUX_STAGE_ONE) {

            ret_val = coreotn_rx_lo_chnl_mux_one_activate(coreotn_handle,
                                                          chnl_id,
                                                          ho_chnl_id,
                                                          mux_stage,
                                                          lo_dmx_handle_ptr,
                                                          lo_odujat_handle_ptr,
                                                          lo_oduksc_handle_ptr,
                                                          activate_rfrm);

        } else if (mux_stage == COREOTN_MUX_STAGE_TWO) {

            ret_val = coreotn_rx_lo_chnl_mux_two_activate(coreotn_handle,
                                                          chnl_id,
                                                          ho_chnl_id,
                                                          mux_stage,
                                                          lo_dmx_handle_ptr,
                                                          lo_odujat_handle_ptr,
                                                          lo_oduksc_handle_ptr);
        }
    }

    PMC_RETURN(ret_val);
} /* coreotn_rx_lo_chnl_activate */

/*******************************************************************************
* coreotn_rx_lo_chnl_add_ho_page_swap
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function swaps the configuration page of the given HO or MO in ODTU_DMX  
*   when a new MO or LO channel gets added to the HO/MO or an existing MO/LO 
*   channel gets removed  from the HO/MO channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   *lo_dmx_handle_ptr  - pointer to DMX handle
*   ho_chnl_id          - Channel ID
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*

* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle_t *coreotn_handle,
                                                      odtu_dmx_handle_t *lo_dmx_handle_ptr,
                                                      UINT32 ho_chnl_id)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 cm_status = 0;
    UINT8 stg2_maint_sig = 0;

    PMC_ENTRY();

    if (lo_dmx_handle_ptr == coreotn_handle->odtu_dmx2_handle
        && coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].mapping_mode == COREOTN_MAP_GMP)
    {
        odtu_dmx_cm_status_get(coreotn_handle->odtu_dmx1_handle,
                               ho_chnl_id,
                               &cm_status);
        if(cm_status == 0)
        {
            odu_rfrm_chnl_maint_sig_get(coreotn_handle->odu_rfrm_stg2_handle,
                                        ho_chnl_id,
                                        &stg2_maint_sig);
            if(stg2_maint_sig == 0)
            {
                ret_val = odu_rfrm_chnl_maint_sig_cfg(coreotn_handle->odu_rfrm_stg2_handle,
                                                      ho_chnl_id,
                                                      1);
            }
        }
    }
                                                  
    /* Set CONFIG_UPDATE to 1 and CONFIG_MODE to 0 */
    odtu_dmx_page_config_update(lo_dmx_handle_ptr, ho_chnl_id, 0, 0, 1);
                                            
    /* poll config_update */
    ret_val = odtu_dmx_config_update_poll(lo_dmx_handle_ptr,
                                          ho_chnl_id, COREOTN_POLL_COUNT_MAX);
 
    if (PMC_SUCCESS != ret_val)
    {
#ifndef PMC_SW_SIMULATION    
        PMC_RETURN(ret_val);
#endif 
    }

    if(PMC_SUCCESS == ret_val &&
       lo_dmx_handle_ptr == coreotn_handle->odtu_dmx2_handle &&
       cm_status == 0 &&
       stg2_maint_sig == 0 &&
       coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].mapping_mode == COREOTN_MAP_GMP)
    {
            ret_val = odu_rfrm_chnl_maint_sig_cfg(coreotn_handle->odu_rfrm_stg2_handle,
                                                  ho_chnl_id,
                                                  0);
    }

    PMC_RETURN(ret_val);
    
} /* coreotn_rx_lo_chnl_add_ho_page_swap */

/*******************************************************************************
* coreotn_fo1_mpmo_scbs3_dummy_cycle_remove
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function is used to clear the dummy calendar cycle in FO1:MPMO:SCBS3
*   for the MO channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - Channel ID
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*

* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_fo1_mpmo_scbs3_dummy_cycle_remove(coreotn_handle_t *coreotn_handle,
                                                           UINT32 chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();
    
    result = mpmo_coreotn_fo1_scbs3_chnl_deactivate(coreotn_handle->mpmo_fo1_handle, chnl_id);
    
    PMC_RETURN(result);

} /* coreotn_fo1_mpmo_scbs3_dummy_cycle_remove */
 
/*******************************************************************************
* coreotn_oduksw_local_db_entry_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for an ODUKSW channel that is operating in 
*   data base content generation mode to have the database content populated
*   with the content from COREOTN database.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   input_chnl_id       - input port Channel ID
*                         Valid range: 0 - 95
*   output_port         - Enum for ODUKSW output port. See coreotn_oduksw_output_port_type_t.
*   output_chnl_id      - output port channel ID
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_local_db_entry_set(coreotn_handle_t *coreotn_handle,
                                                   UINT32 input_chnl_id,
                                                   coreotn_oduksw_output_port_type_t output_port,
                                                   UINT32 output_chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 i;

    line_core_otn_db_key    key;
    line_core_otn_db_key    mo_key;
    line_core_otn_db_key    ho_key;

    UINT32          num_of_recs = 0;
    line_core_otn_db_query_res *q_result = NULL;
    line_core_otn_db_query_res *mo_q_result = NULL;
    line_core_otn_db_query_res *ho_q_result = NULL;

    PMC_ENTRY();

    /* argument checking */
    if (coreotn_handle->cfg.schdpopulate_mode[output_port] != CPB_SCHD_POPULATE_DB)
    {
        result = COREOTN_ODUKSW_UNSUPPORTED_SCHD_MODE;
    }
    
    if (input_chnl_id > 95)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }
    
    /* start with LO channel */
    key.calendar_entry = DO_NOT_USE_KEY;
    key.ho_channel = DO_NOT_USE_KEY;
    key.mo_channel = DO_NOT_USE_KEY;
    key.lo_channel = input_chnl_id;

    /* find the total number of records that matches the LO channel ID */
    num_of_recs = gen_db_query(&(coreotn_handle->base),
                               coreotn_handle->cfg.tx_db_id,
                               coreotn_handle->cfg.tx_db_handle, (void *)&key,
                               (void **)&q_result);
   
    if (num_of_recs == 0)
    {
        mo_key.calendar_entry = DO_NOT_USE_KEY;
        mo_key.ho_channel = DO_NOT_USE_KEY;
        mo_key.mo_channel = input_chnl_id;
        mo_key.lo_channel = DO_NOT_USE_KEY;

        /* find the total number of records that matches the MO channel ID */
        num_of_recs = gen_db_query(&(coreotn_handle->base),
                                   coreotn_handle->cfg.tx_db_id,
                                   coreotn_handle->cfg.tx_db_handle, 
                                   (void *)&mo_key,
                                   (void **)&mo_q_result);
                                                
        if (num_of_recs == 0)
        {
            ho_key.calendar_entry = DO_NOT_USE_KEY;
            ho_key.ho_channel = input_chnl_id;
            ho_key.mo_channel = DO_NOT_USE_KEY;
            ho_key.lo_channel = DO_NOT_USE_KEY;

            /* find the total number of records that matches the HO channel ID */
            num_of_recs = gen_db_query(&(coreotn_handle->base),
                                       coreotn_handle->cfg.tx_db_id,
                                       coreotn_handle->cfg.tx_db_handle,
                                       (void *)&ho_key, 
                                       (void **)&ho_q_result);
            
            if (num_of_recs == 0)
            {
                PMC_RETURN(COREOTN_ERR_DB_ENTRY_NOT_FOUND);
            }
            
            if (num_of_recs > 0)
            {
                /* check the scheduler populate method in ODUKSW  */ 
                for (i = 0; i < num_of_recs; i++)
                {
                    result = cpb_dcs_db_entry_set(coreotn_handle->oduksw_handle,
                                                  output_port,
                                                  ho_q_result->p_recs[i]->calendar_entry,
                                                  output_port,
                                                  output_chnl_id);
                } 
            }                                                             
        }
        else {
            /* check the scheduler populate method in ODUKSW  */ 
            for (i = 0; i < num_of_recs; i++)
            {
                result = cpb_dcs_db_entry_set(coreotn_handle->oduksw_handle,
                                              output_port,
                                              mo_q_result->p_recs[i]->calendar_entry,
                                              output_port,
                                              output_chnl_id);
            } 
        }                                           
    }
    else {
        /* check the scheduler populate method in ODUKSW  */ 
        for (i = 0; i < num_of_recs; i++)
        {
            result = cpb_dcs_db_entry_set(coreotn_handle->oduksw_handle,
                                          output_port,
                                          q_result->p_recs[i]->calendar_entry,
                                          output_port,
                                          output_chnl_id);
        }
    }
  
    PMC_RETURN(result);
    
} /* coreotn_oduksw_local_db_entry_set */



/*******************************************************************************
* coreotn_oduksw_db_entry_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that are
*   operating in data base content generation mode to have the database content
*   retrieved.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   output_port         - Enum for ODUKSW output port. See coreotn_oduksw_output_port_type_t
*   schd_addr           - calendar entry
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   *egress_mux_output_port_ptr - Egress Mux Output Port.  Defines the subsystem
*                                 that is to receive the data stream from CPB. In
*                                 most cases this is 1:1 mapping with the egress
*                                 mux input port.  The exception is DCPB in
*                                 which case there are various mappings supported.
*   *egress_mux_output_chnl_ptr - Egress Mux Output Port Channel.  Defines the
*                                 DPI channel that will be used to transfer the
*                                 channel data to downstream subsystem.
*   rd_channel_id_ptr           - rd_channel_id / C_RAM_CHANNEL_ID data for the
*                                 specified DCS instance.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_db_entry_get(coreotn_handle_t *coreotn_handle,
                                             coreotn_oduksw_output_port_type_t output_port,
                                             UINT32 schd_addr,
                                             UINT32 *egress_mux_output_port_ptr,
                                             UINT32 *egress_mux_output_chnl_ptr,
                                             UINT32 *rd_channel_id_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();
    
    result = cpb_dcs_db_entry_get(coreotn_handle->oduksw_handle,
                                  output_port,
                                  schd_addr,
                                  egress_mux_output_port_ptr,
                                  egress_mux_output_chnl_ptr,
                                  rd_channel_id_ptr );
    
    PMC_RETURN(result);

} /* coreotn_oduksw_db_entry_get */

/*******************************************************************************
* coreotn_oduksw_db_entry_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that are
*   operating in data base content generation mode to have the database content
*   driven.
*
*   When operating in scheduler generation database mode, this API must be called
*   before coreotn_ho_odu_chnl_prov() or coreotn_oduksw_chnl_prov API so that
*   resource allocation checking can be performed.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   output_port         - Enum for ODUKSW output port. See coreotn_oduksw_output_port_type_t
*   schd_addr           - calendar entry
*                         Valid range: 0 - 95
*   output_chnl_id      - Channel ID
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_db_entry_set(coreotn_handle_t *coreotn_handle,
                                             coreotn_oduksw_output_port_type_t output_port,
                                             UINT32 schd_addr,
                                             UINT32 output_chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();
   
    if(output_port ==  COREOTN_ODUKSW_OUTPUT_MAPOTN)
    {
        if(coreotn_handle->var.dcs_to_mapotn_pinch_entry[schd_addr] == TRUE)
        {
              PMC_RETURN(PMC_SUCCESS);
        }
    }

    result = cpb_dcs_db_entry_set(coreotn_handle->oduksw_handle,
                                  output_port,
                                  schd_addr,
                                  output_port,
                                  output_chnl_id);  
    PMC_RETURN(result);

} /* coreotn_oduksw_db_entry_set */

/*******************************************************************************
* coreotn_oduksw_dcs_db_num_entry_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for DCS instances that are
*   operating in data base content generation mode to have the database content
*   retrieved.
*
*
* INPUTS:
*   *coreotn_handle         - pointer to COREOTN handle instance
*   output_port             - DCS block instance 1:1 mapped with egress_mux_input_port
*                             Valid values dcs_instances/egress_mux_input_port: 0 to 3
*   egress_mux_output_chnl  - Egress Mux Output Port Channel.  Defines the
*                             DPI channel that will be used to transfer the
*                             channel data to downstream subsystem.
*
* OUTPUTS:
*   *num_entries            - number of dcs entries provisioned for the channel
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_dcs_db_num_entry_get(coreotn_handle_t *coreotn_handle,
                                                     coreotn_oduksw_output_port_type_t output_port,
                                                     UINT32 egress_mux_output_chnl,
                                                     UINT32 *num_entries)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();
    
    result = cpb_dcs_db_num_entry_get(coreotn_handle->oduksw_handle,
                                      output_port,
                                      output_port,
                                      egress_mux_output_chnl,
                                      num_entries);
    
    PMC_RETURN(result);

} /* coreotn_oduksw_dcs_db_num_entry_get */

/*******************************************************************************
* coreotn_oduksw_db_entry_clear
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function clears database entry for the specified DCS instance in 
*   ODUKSW of COREOTN.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   output_port         - Enum for ODUKSW output port. See coreotn_oduksw_output_port_type_t
*   output_chnl_id      - Channel ID
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_db_entry_clear(coreotn_handle_t *coreotn_handle,
                                               coreotn_oduksw_output_port_type_t output_port,
                                               UINT32 output_chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();
    
    result = cpb_dcs_db_entry_clear(coreotn_handle->oduksw_handle,
                                    output_port,
                                    output_port,
                                    output_chnl_id);
    
    PMC_RETURN(result);
} /*  coreotn_oduksw_db_entry_clear */                                  

#if defined PMC_EMULATION | defined PMC_SW_SIMULATION | defined PMC_VERIFICATION
/*******************************************************************************
* coreotn_db_entry_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that are
*   operating in data base content generation mode to have the database content
*   driven.
*
*   When operating in scheduler generation database mode, this API must be called
*   before coreotn_ho_odu_chnl_prov() or coreotn_oduksw_chnl_prov API so that
*   resource allocation checking can be performed.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - Channel ID
*                         Valid range: 0 - 95
*   cal_slot            - calendar entry
*                         Valid range: 0 - 95
*   trib_slot           - tributary slot number
*                         Valid range: 0 - 79
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_entry_set(coreotn_handle_t *coreotn_handle,
                                      UINT32 chnl_id,
                                      UINT32 cal_slot, UINT32 trib_slot)
{
    PMC_ERROR result = PMC_SUCCESS;
    line_core_otn_db_rec    rec;

    PMC_ENTRY();

    /* add record to the DB */
    rec.calendar_entry = cal_slot;
    rec.ho_channel = chnl_id;
    rec.mo_channel = COREOTN_DB_ENTRY_UNKNOWN;
    rec.lo_channel = COREOTN_DB_ENTRY_UNKNOWN;
    /*rec.cal_entry_status = 0;*/
    /*rec.trib_slot = trib_slot;*/
    rec.cal_entry_status = COREOTN_DB_ENTRY_UNKNOWN;
    rec.trib_slot = COREOTN_DB_ENTRY_UNKNOWN;
    rec.ts_port_ho_mo = COREOTN_DB_ENTRY_UNKNOWN;
    rec.ts_port_mo_lo = COREOTN_DB_ENTRY_UNKNOWN;

    result = gen_db_add_record(&(coreotn_handle->base),
                               UTIL_GEN_DB_LINE_CORE_OTN_RX_DB,
                               coreotn_handle->cfg.rx_db_handle, (void *)&rec);
    if (PMC_SUCCESS == result)
    {
        result = gen_db_add_record(&(coreotn_handle->base),
                                   UTIL_GEN_DB_LINE_CORE_OTN_TX_DB,
                                   coreotn_handle->cfg.tx_db_handle, (void *)&rec);
    }

    PMC_RETURN(result);

} /* coreotn_db_entry_set */

/*******************************************************************************
* coreotn_db_ho_chnl_entry_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that are
*   operating in data base content generation mode to have the database content
*   driven.
*
*   When operating in scheduler generation database mode, this API must be called
*   before coreotn_ho_odu_chnl_prov() or coreotn_oduksw_chnl_prov API so that
*   resource allocation checking can be performed.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   cal_slot            - calendar entry
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   *chnl_id            - HO channel ID that uses the current calendar slot.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_ho_chnl_entry_get(coreotn_handle_t *coreotn_handle,
                                              UINT32 cal_slot,
                                              UINT32 *chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;
    line_core_otn_db_key       key;
    UINT32                     num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;

    PMC_ENTRY();

    key.calendar_entry = cal_slot;
    key.ho_channel = DO_NOT_USE_KEY;
    key.mo_channel = DO_NOT_USE_KEY;
    key.lo_channel = DO_NOT_USE_KEY;
    key.trib_slot = DO_NOT_USE_KEY;

    num_of_recs = gen_db_query(&(coreotn_handle->base),
                               UTIL_GEN_DB_LINE_CORE_OTN_RX_DB,
                               coreotn_handle->cfg.rx_db_handle,
                               (void *)&key,
                               (void **)&q_result);

    if (num_of_recs == 0)
    {
        PMC_RETURN(COREOTN_ERR_DB_ENTRY_NOT_FOUND);
    }

    *chnl_id = q_result->p_recs[0]->ho_channel;


    PMC_RETURN(result);

} /* coreotn_db_ho_chnl_entry_get */
#endif /* PMC_EMULATION | SW_SIMUALTION | VERIFICATION */

/*******************************************************************************
* coreotn_db_ho_chnl_id_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that are
*   operating in data base content generation mode to have the database content
*   driven.
*
*   When operating in scheduler generation database mode, this API must be called
*   before coreotn_ho_odu_chnl_prov() or coreotn_oduksw_chnl_prov API so that
*   resource allocation checking can be performed.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   direction           - direction of the traffic
*                         0 -- TX
*                         1 -- RX
*   chnl_level          - Enum for channel level. See util_global_odu_level_t.
*   lo_chnl_id          - channel ID of lower order ODU channel
*
* OUTPUTS:
*   *ho_chnl_id         - HO channel ID of the lower ordr ODU channel.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_ho_chnl_id_get(coreotn_handle_t *coreotn_handle,
                                           UINT32 direction,
                                           util_global_odu_level_t chnl_level,
                                           UINT32 lo_chnl_id,
                                           UINT32 *ho_chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;
    line_core_otn_db_key       key;
    UINT32                     num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;
    util_gen_db_id_t db_id;
    UINT32 db_handle;

    PMC_ENTRY();
    
    if (direction == 0)
    {
        /* TX */
        db_id = UTIL_GEN_DB_LINE_CORE_OTN_TX_DB;
        db_handle = coreotn_handle->cfg.tx_db_handle; 
    }
    else {
        /* RX */
        db_id = UTIL_GEN_DB_LINE_CORE_OTN_RX_DB;
        db_handle = coreotn_handle->cfg.rx_db_handle; 
    }         

    if (chnl_level == UTIL_GLOBAL_LEVEL_MO_ODU)
    {
        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = DO_NOT_USE_KEY;
        key.mo_channel = lo_chnl_id;
        key.lo_channel = DO_NOT_USE_KEY;
        key.trib_slot = DO_NOT_USE_KEY;
    }
    else if (chnl_level == UTIL_GLOBAL_LEVEL_LO_ODU)
    {
        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = DO_NOT_USE_KEY;
        key.mo_channel = DO_NOT_USE_KEY;
        key.lo_channel = lo_chnl_id;
        key.trib_slot = DO_NOT_USE_KEY;
    }            
        
        
    num_of_recs = gen_db_query(&(coreotn_handle->base),
                               db_id,
                               db_handle,
                               (void *)&key,
                               (void **)&q_result);

    if (num_of_recs == 0)
    {
        PMC_RETURN(COREOTN_ERR_DB_ENTRY_NOT_FOUND);
    }

    if (chnl_level == UTIL_GLOBAL_LEVEL_MO_ODU)
    {
        *ho_chnl_id = q_result->p_recs[0]->ho_channel;
    }
    else if (chnl_level == UTIL_GLOBAL_LEVEL_LO_ODU)
    {
        *ho_chnl_id = q_result->p_recs[0]->mo_channel;
    }
               

    PMC_RETURN(result);

} /* coreotn_db_ho_chnl_id_get */

/*******************************************************************************
* coreotn_db_first_cal_entry_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that is operating in
*   database content generation mode to have the database content retrieved.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_level          - ODU channel level. See coreotn_chnl_order_t.
*   direction           - direction of the traffic. This argument determines 
*                         which database to access.
*                         0 -- TX
*                         1 -- RX
*   chnl_id             - Channel ID. Valid range: 0 - 95
*
* OUTPUTS:
*   *cal_entry          - calendar entry. Valid range: 0 - 95
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_first_cal_entry_get(coreotn_handle_t *coreotn_handle,
                                                coreotn_chnl_order_t chnl_level,
                                                UINT32 direction,
                                                UINT32 chnl_id,
                                                UINT32 *cal_entry)
{
    PMC_ERROR result = PMC_SUCCESS;
    line_core_otn_db_key       key;
    UINT32                     num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;
    util_gen_db_id_t db_id;
    UINT32 db_handle;

    PMC_ENTRY();
    
    if (direction == 0)
    {
        /* TX */
        db_id = UTIL_GEN_DB_LINE_CORE_OTN_TX_DB;
        db_handle = coreotn_handle->cfg.tx_db_handle; 
    }
    else {
        /* RX */
        db_id = UTIL_GEN_DB_LINE_CORE_OTN_RX_DB;
        db_handle = coreotn_handle->cfg.rx_db_handle; 
    }         

    switch (chnl_level)
    {
    case COREOTN_CHNL_ORDER_LO:
        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = DO_NOT_USE_KEY;
        key.mo_channel = DO_NOT_USE_KEY;
        key.lo_channel = chnl_id;
        key.trib_slot = DO_NOT_USE_KEY;
        break; 
    case COREOTN_CHNL_ORDER_MO:               
        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = DO_NOT_USE_KEY;
        key.mo_channel = chnl_id;
        key.lo_channel = DO_NOT_USE_KEY;
        key.trib_slot = DO_NOT_USE_KEY;
        break;
    case COREOTN_CHNL_ORDER_HO:        
        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = chnl_id;
        key.mo_channel = DO_NOT_USE_KEY;
        key.lo_channel = DO_NOT_USE_KEY;
        key.trib_slot = DO_NOT_USE_KEY;    
        break;
    default:
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }
    
    num_of_recs = gen_db_query(&(coreotn_handle->base), 
                               db_id, 
                               db_handle,
                               (void *)&key,
                               (void **)&q_result);

    if (num_of_recs == 0)
    {
        PMC_RETURN(COREOTN_ERR_DB_ENTRY_NOT_FOUND);
    }

    *cal_entry = q_result->p_recs[0]->calendar_entry;


    PMC_RETURN(result);

} /* coreotn_db_first_cal_entry_get */

/*******************************************************************************
* coreotn_db_ho_cal_entry_all_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that is operating in
*   database content generation mode to have its scheduling database content
*   retrieved.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - Channel ID
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   *cal_entry_ptr      - storage for an array of calendar entries occupied by
*                         the HO channel.
*   *num_cal_entries    - number of calendar entries in the current HO 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_ho_cal_entry_all_get(coreotn_handle_t *coreotn_handle,
                                                 UINT32 chnl_id,
                                                 UINT32 *cal_entry_ptr,
                                                 UINT32 *num_cal_entries)
{
    PMC_ERROR result = PMC_SUCCESS;
    line_core_otn_db_key       key;
    UINT32                     num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;
    UINT32 i ;

    PMC_ENTRY();
    
    key.calendar_entry = DO_NOT_USE_KEY;
    key.ho_channel = chnl_id;
    key.mo_channel = DO_NOT_USE_KEY;
    key.lo_channel = DO_NOT_USE_KEY;
    key.trib_slot = DO_NOT_USE_KEY;

    num_of_recs = gen_db_query(&(coreotn_handle->base),
                               UTIL_GEN_DB_LINE_CORE_OTN_RX_DB,
                               coreotn_handle->cfg.rx_db_handle,
                               (void *)&key,
                               (void **)&q_result);

    if (num_of_recs == 0)
    {
        PMC_RETURN(COREOTN_ERR_DB_ENTRY_NOT_FOUND);
    }

    for (i = 0; i < num_of_recs; i++)
    {
        cal_entry_ptr[i] = q_result->p_recs[i]->calendar_entry;
        PMC_LOG_TRACE("cal_entry[%u] = %u\n", i, cal_entry_ptr[i]);
    }

    *num_cal_entries = num_of_recs;
    
    PMC_RETURN(result);

} /* coreotn_db_ho_cal_entry_all_get */

/*******************************************************************************
* coreotn_db_ho_cal_entry_ts_port_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that is operating in
*   database content generation mode to have its scheduling database content
*   retrieved.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   db_inst             - DB instance
*                         0 -- TX DB
*                         1 -- RX DB
*   odu_level           - see odu_struct_odu_level_t.
*   chnl_id             - Channel ID
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   *cal_entry_ptr      - storage for an array of calendar entries of an ODU channel
*   *ts_port_ptr        - storage for an array of tributary port of HO channel.
*   *num_cal_entries    - number of calendar entries
*   *num_active_ts_port - number of active tributary ports in the current HO 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_cal_entry_to_ts_port_get(coreotn_handle_t *coreotn_handle,
                                                     UINT8 db_inst,
                                                     odu_struct_odu_level_t odu_level,
                                                     UINT32 chnl_id,
                                                     UINT32 *cal_entry_ptr,
                                                     UINT32 *ts_port_ptr,
                                                     UINT32 *num_cal_entries,
                                                     UINT32 *num_active_ts_port)
{
    PMC_ERROR result = PMC_SUCCESS;
    line_core_otn_db_key       key;
    UINT32                     num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;
    UINT32 i ;
    UINT32 num_active_ts = 0;
    UINT32 db_handle = 0; 
    util_gen_db_id_t db_id; 

    PMC_ENTRY();
    
    db_id = (db_inst == 0)? UTIL_GEN_DB_LINE_CORE_OTN_TX_DB:UTIL_GEN_DB_LINE_CORE_OTN_RX_DB;     
    db_handle = (db_inst == 0)? coreotn_handle->cfg.tx_db_handle:coreotn_handle->cfg.rx_db_handle;
    
    if (odu_level == ODU_STRUCT_LEVEL_HO_ODU)
    {
        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = chnl_id;
        key.mo_channel = DO_NOT_USE_KEY;
        key.lo_channel = DO_NOT_USE_KEY;
        key.trib_slot = DO_NOT_USE_KEY;
    }
    else if (odu_level == ODU_STRUCT_LEVEL_MO_ODU)
    {        
        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = DO_NOT_USE_KEY;
        key.mo_channel = chnl_id;
        key.lo_channel = DO_NOT_USE_KEY;
        key.trib_slot = DO_NOT_USE_KEY;
    }
    else {
        result = COREOTN_ERR_INVALID_ARG;
    }

    num_of_recs = gen_db_query(&(coreotn_handle->base),
                               db_id,
                               db_handle,
                               (void *)&key,
                               (void **)&q_result);

    if (num_of_recs == 0)
    {
        PMC_RETURN(COREOTN_ERR_DB_ENTRY_NOT_FOUND);
    }

    if (odu_level == ODU_STRUCT_LEVEL_HO_ODU)
    {
        for (i = 0; i < num_of_recs; i++)
        {
            cal_entry_ptr[i] = q_result->p_recs[i]->calendar_entry;
            
            if (q_result->p_recs[i]->trib_slot != 0xFFFFFFFF)
            {    
                ts_port_ptr[i] = q_result->p_recs[i]->trib_slot;
                PMC_LOG_TRACE("ts_port_ptr[%u] = %u\n", i, ts_port_ptr[i]);
                num_active_ts++;
            }
            else {
                ts_port_ptr[i] = 0xFF;
            }
        }
    }
    else if (odu_level == ODU_STRUCT_LEVEL_MO_ODU)
    {
        for (i = 0; i < num_of_recs; i++)
        {
            cal_entry_ptr[i] = q_result->p_recs[i]->calendar_entry;
            
            if (q_result->p_recs[i]->ts_port_mo_lo != 0xFFFFFFFF)
            {    
                ts_port_ptr[i] = q_result->p_recs[i]->ts_port_mo_lo;
                PMC_LOG_TRACE("ts_port_ptr[%u] = %u\n", i, ts_port_ptr[i]);
                num_active_ts++;
            }
            else {
                ts_port_ptr[i] = 0xFF;
            }
        }
    }

    *num_active_ts_port = num_active_ts;
    *num_cal_entries = num_of_recs;
    
    PMC_RETURN(result);

} /* coreotn_db_cal_entry_to_ts_port_get */

/*******************************************************************************
* coreotn_db_mo_cal_entry_all_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that is operating in
*   database content generation mode to have its scheduling database content
*   retrieved.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - Channel ID
*                         Valid range: 0 - 95
*   db_inst             - 0 : UTIL_GEN_DB_LINE_CORE_OTN_TX_DB
*                         1 : UTIL_GEN_DB_LINE_CORE_OTN_RX_DB
*
* OUTPUTS:
*   *cal_entry_ptr      - storage for an array of calendar entries occupied by
*                         the HO channel.
*   *num_cal_entries    - number of calendar entries in the current HO 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_mo_cal_entry_all_get(coreotn_handle_t *coreotn_handle,
                                                 UINT32 chnl_id,
                                                 UINT8 db_inst,
                                                 UINT32 *cal_entry_ptr,
                                                 UINT32 *num_cal_entries)
{
    PMC_ERROR result = PMC_SUCCESS;
    line_core_otn_db_key       key;
    UINT32                     num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;
    UINT32 i;
    UINT32 db_handle = 0; 
    util_gen_db_id_t db_id; 

    PMC_ENTRY();
    
    db_id = (db_inst == 0)? UTIL_GEN_DB_LINE_CORE_OTN_TX_DB:UTIL_GEN_DB_LINE_CORE_OTN_RX_DB;     
    db_handle = (db_inst == 0)? coreotn_handle->cfg.tx_db_handle:coreotn_handle->cfg.rx_db_handle;
         
    key.calendar_entry = DO_NOT_USE_KEY;
    key.ho_channel = DO_NOT_USE_KEY;
    key.mo_channel = chnl_id;
    key.lo_channel = DO_NOT_USE_KEY;
    key.trib_slot = DO_NOT_USE_KEY;

    num_of_recs = gen_db_query(&(coreotn_handle->base),
                               db_id,
                               db_handle,
                               (void *)&key,
                               (void **)&q_result);

    if (num_of_recs > 0)
    {
        for (i = 0; i < num_of_recs; i++)
        {
            cal_entry_ptr[i] = q_result->p_recs[i]->calendar_entry;
            PMC_LOG_TRACE("cal_entry[%u] = %u\n", i, cal_entry_ptr[i]);
        }
        *num_cal_entries = num_of_recs;
    
    }
    
    PMC_RETURN(result);

} /* coreotn_db_mo_cal_entry_all_get */



/*******************************************************************************
* coreotn_db_ts_port_cal_entry_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a tributary port of HO or MO channel 
*   that is operating in database content generation mode to have its scheduling 
*   database content retrieved.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   db_inst             - DB instance
*                         0 -- TX DB
*                         1 -- RX DB
*   odu_level           - see odu_struct_odu_level_t.
*   chnl_id             - channel id to get scheduling content for
*   ts_port             - tributary port
*                         Valid range: 0 - 79
*
* OUTPUTS:
*   *cal_entry_ptr      - storage for an array of calendar entries occupied by
*                         the tributary port.
*   *num_cal_entries    - number of calendar entries used for the ts_port 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_ts_port_cal_entry_get(coreotn_handle_t *coreotn_handle,
                                                  UINT8 db_inst,
                                                  odu_struct_odu_level_t odu_level,
                                                  UINT32 chnl_id,
                                                  UINT32 ts_port,
                                                  UINT32 *cal_entry_ptr,
                                                  UINT32 *num_cal_entries)
{
    PMC_ERROR result = PMC_SUCCESS;
    line_core_otn_db_key       key;
    UINT32                     num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;
    UINT32 i;
    UINT32 db_handle = 0; 
    util_gen_db_id_t db_id; 
    UINT32 idx = 0;
    
    ohfs_insert_handle_t *local_ohfs_insert_ptr = NULL; 
    ohfs_remove_handle_t *local_ohfs_remove_ptr = NULL;
    util_global_otn_msi_cfg_mode_t msi_mode;
    util_global_odu_line_payload_t ts_type = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
    
    PMC_ENTRY();
    
    db_id = (db_inst == 0)? UTIL_GEN_DB_LINE_CORE_OTN_TX_DB:UTIL_GEN_DB_LINE_CORE_OTN_RX_DB;     
    db_handle = (db_inst == 0)? coreotn_handle->cfg.tx_db_handle:coreotn_handle->cfg.rx_db_handle;
 
    if (odu_level == ODU_STRUCT_LEVEL_HO_ODU)
    {
        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = chnl_id;
        key.mo_channel = DO_NOT_USE_KEY;
        key.lo_channel = DO_NOT_USE_KEY;
        key.trib_slot = DO_NOT_USE_KEY;
        
        if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
        {
            local_ohfs_insert_ptr = coreotn_handle->odtu_mux2_handle->tgmp_handle->ohfs_insert_handle;
            local_ohfs_remove_ptr = coreotn_handle->odtu_dmx2_handle->rgmp_handle->ohfs_remove_handle;
        }
        else {
            local_ohfs_insert_ptr = coreotn_handle->odtu_mux1_handle->tgmp_handle->ohfs_insert_handle;
            local_ohfs_remove_ptr = coreotn_handle->odtu_dmx1_handle->rgmp_handle->ohfs_remove_handle;
        }
        
        ts_type = coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].payload_format;
    }
    else if (odu_level == ODU_STRUCT_LEVEL_MO_ODU)
    {        
        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = DO_NOT_USE_KEY;
        key.mo_channel = chnl_id;
        key.lo_channel = DO_NOT_USE_KEY;
        key.trib_slot = DO_NOT_USE_KEY;
        
        local_ohfs_insert_ptr = coreotn_handle->odtu_mux2_handle->tgmp_handle->ohfs_insert_handle;
        local_ohfs_remove_ptr = coreotn_handle->odtu_dmx2_handle->rgmp_handle->ohfs_remove_handle;
        
        ts_type = coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].payload_format;
    }
    else {
        result = COREOTN_ERR_INVALID_ARG;
    }
    
    if (PMC_SUCCESS == result && db_id == UTIL_GEN_DB_LINE_CORE_OTN_TX_DB)
    {
        ohfs_insert_msi_mode_get(local_ohfs_insert_ptr, &msi_mode);
    }
    else if (PMC_SUCCESS == result)
    {
        ohfs_remove_msi_mode_get(local_ohfs_remove_ptr, &msi_mode); 
    } 
        
    if (PMC_SUCCESS == result)
    {
        num_of_recs = gen_db_query(&(coreotn_handle->base),
                                   db_id,
                                   db_handle,
                                   (void *)&key,
                                   (void **)&q_result);

        if (num_of_recs > 0)
        {
            for (i = 0; i < num_of_recs; i++)
            {
                if (odu_level == ODU_STRUCT_LEVEL_HO_ODU)
                {
                    if (msi_mode == UTIL_GLOBAL_OTN_MSI_CFG_AUTO)
                    {
                        if (q_result->p_recs[i]->trib_slot == ts_port && idx < 2)
                        {
                            cal_entry_ptr[idx] = q_result->p_recs[i]->calendar_entry;
                            PMC_LOG_TRACE("cal_entry[%u] = %u\n", i, cal_entry_ptr[idx]);
                            idx++;
                        }
                    }
                    else {
                        if (idx < 2)
                        {
                            if (ts_type != UTIL_GLOBAL_ODU_TS_2G5)
                            {
                                cal_entry_ptr[idx] = q_result->p_recs[ts_port]->calendar_entry;
                                PMC_LOG_TRACE("cal_entry[%u] = %u\n", i, cal_entry_ptr[idx]);
                                idx++;
                                
                                break;
                            }
                            else {
                                cal_entry_ptr[idx] = q_result->p_recs[ts_port]->calendar_entry;
                                PMC_LOG_TRACE("cal_entry[%u] = %u\n", i, cal_entry_ptr[idx]);
                                idx++;
                            }
                        }
                        else {
                            break;
                        }
                    }
                }   
                else if (odu_level == ODU_STRUCT_LEVEL_MO_ODU)
                {   
                    if (msi_mode == UTIL_GLOBAL_OTN_MSI_CFG_AUTO)
                    {
                        if (q_result->p_recs[i]->ts_port_mo_lo == ts_port && idx < 2)
                        {
                            cal_entry_ptr[idx] = q_result->p_recs[i]->calendar_entry;
                            PMC_LOG_TRACE("cal_entry[%u] = %u\n", i, cal_entry_ptr[idx]);
                            idx++;
                        }
                    }
                    else {
                        if (idx < 2)
                        {
                            if (ts_type != UTIL_GLOBAL_ODU_TS_2G5)
                            {
                                cal_entry_ptr[idx] = q_result->p_recs[ts_port]->calendar_entry;
                                PMC_LOG_TRACE("cal_entry[%u] = %u\n", i, cal_entry_ptr[idx]);
                                idx++;
                                
                                break;
                            }
                            else {
                                cal_entry_ptr[idx] = q_result->p_recs[ts_port]->calendar_entry;
                                PMC_LOG_TRACE("cal_entry[%u] = %u\n", i, cal_entry_ptr[idx]);
                                idx++;
                            }
                        }
                        else {
                            break;
                        }
                    }
                }
            }
            
            *num_cal_entries = idx;
            /**num_cal_entries = num_of_recs;*/
        
        }            
    }                
                     
    PMC_RETURN(result);
                     
} /* coreotn_db_ts_port_cal_entry_get */


/*******************************************************************************
* coreotn_db_ts_port_to_lo_id_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a tributary port of HO or MO channel 
*   that is operating in database content generation mode to have its scheduling 
*   database content retrieved.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   db_inst             - DB instance
*                         0 -- TX DB
*                         1 -- RX DB
*   odu_level           - see odu_struct_odu_level_t.
*   chnl_id             - channel id to get scheduling content for
*   ts_port             - tributary port
*                         Valid range: 0 - 79
*
* OUTPUTS:
*   *cal_entry_ptr      - storage for an array of calendar entries occupied by
*                         the tributary port.
*   *num_cal_entries    - number of calendar entries used for the ts_port 
*   *lo_chnl_id         - Channel ID that the LO occupies 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_ts_port_to_lo_id_get(coreotn_handle_t *coreotn_handle,
                                                 UINT8 db_inst,
                                                 odu_struct_odu_level_t odu_level,
                                                 UINT32 chnl_id,
                                                 UINT32 ts_port,
                                                 UINT32 *cal_entry_ptr,
                                                 UINT32 *num_cal_entries,
                                                 UINT32 *lo_chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;
    line_core_otn_db_key       key;
    UINT32                     num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;
    UINT32 i;
    UINT32 db_handle = 0; 
    util_gen_db_id_t db_id; 
    UINT32 idx = 0;
   
    PMC_ENTRY();
    
    db_id = (db_inst == 0)? UTIL_GEN_DB_LINE_CORE_OTN_TX_DB:UTIL_GEN_DB_LINE_CORE_OTN_RX_DB;     
    db_handle = (db_inst == 0)? coreotn_handle->cfg.tx_db_handle:coreotn_handle->cfg.rx_db_handle;
 
    if (odu_level == ODU_STRUCT_LEVEL_HO_ODU)
    {
        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = chnl_id;
        key.mo_channel = DO_NOT_USE_KEY;
        key.lo_channel = DO_NOT_USE_KEY;
        key.trib_slot = DO_NOT_USE_KEY;
    }
    else if (odu_level == ODU_STRUCT_LEVEL_MO_ODU)
    {        
        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = DO_NOT_USE_KEY;
        key.mo_channel = chnl_id;
        key.lo_channel = DO_NOT_USE_KEY;
        key.trib_slot = DO_NOT_USE_KEY;
    }
    else {
        result = COREOTN_ERR_INVALID_ARG;
    }
        
    if (PMC_SUCCESS == result)
    {
        num_of_recs = gen_db_query(&(coreotn_handle->base),
                                   db_id,
                                   db_handle,
                                   (void *)&key,
                                   (void **)&q_result);

        if (num_of_recs > 0)
        {
            for (i = 0; i < num_of_recs; i++)
            {
                if (odu_level == ODU_STRUCT_LEVEL_HO_ODU)
                {
                    if (q_result->p_recs[i]->trib_slot == ts_port && idx < 2)
                    {
                        cal_entry_ptr[idx] = q_result->p_recs[i]->calendar_entry;
                        *lo_chnl_id = q_result->p_recs[i]->mo_channel;
                        PMC_LOG_TRACE("cal_entry[%u] = %u\n", i, cal_entry_ptr[idx]);
                        idx++;
                    }                    
                }   
                else if (odu_level == ODU_STRUCT_LEVEL_MO_ODU)
                {   
                    if (q_result->p_recs[i]->ts_port_mo_lo == ts_port && idx < 2)
                    {
                        cal_entry_ptr[idx] = q_result->p_recs[i]->calendar_entry;
                        *lo_chnl_id = q_result->p_recs[i]->lo_channel;
                        PMC_LOG_TRACE("cal_entry[%u] = %u\n", i, cal_entry_ptr[idx]);
                        idx++;
                    }
                }
            }
            
            *num_cal_entries = idx;
            /**num_cal_entries = num_of_recs;*/
        
        }            
    }                
                     
    PMC_RETURN(result);
                     
} /* coreotn_db_ts_port_to_lo_id_get */
                     

/*******************************************************************************
* coreotn_db_lo_cal_entry_all_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that is operating in
*   database content generation mode to have its scheduling database content
*   retrieved.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - Channel ID
*                         Valid range: 0 - 95
*   db_inst             - 0 : UTIL_GEN_DB_LINE_CORE_OTN_TX_DB
*                         1 : UTIL_GEN_DB_LINE_CORE_OTN_RX_DB
*
* OUTPUTS:            
*   *cal_entry_ptr      - storage for an array of calendar entries occupied by
*                         the HO channel.
*   *num_cal_entries    - number of calendar entries in the current HO 
*                     
* RETURNS:            
*   None.             
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_lo_cal_entry_all_get(coreotn_handle_t *coreotn_handle,
                                                 UINT32 chnl_id,
                                                 UINT8  db_inst,
                                                 UINT32 *cal_entry_ptr,
                                                 UINT32 *num_cal_entries)
{
    PMC_ERROR result = PMC_SUCCESS;
    line_core_otn_db_key       key;
    UINT32                     num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;
    UINT32 i;
    UINT32 db_handle = 0; 
    util_gen_db_id_t db_id; 
                       
    PMC_ENTRY();       
                       
    db_id = (db_inst == 0)? UTIL_GEN_DB_LINE_CORE_OTN_TX_DB:UTIL_GEN_DB_LINE_CORE_OTN_RX_DB;     
    db_handle = (db_inst == 0)? coreotn_handle->cfg.tx_db_handle:coreotn_handle->cfg.rx_db_handle;
                       
    key.calendar_entry = DO_NOT_USE_KEY;
    key.ho_channel = DO_NOT_USE_KEY;
    key.mo_channel = DO_NOT_USE_KEY;
    key.lo_channel = chnl_id;
    key.trib_slot = DO_NOT_USE_KEY;

    num_of_recs = gen_db_query(&(coreotn_handle->base),
                               db_id,
                               db_handle,
                               (void *)&key,
                               (void **)&q_result);

    if (num_of_recs > 0)
    {
        for (i = 0; i < num_of_recs; i++)
        {
            cal_entry_ptr[i] = q_result->p_recs[i]->calendar_entry;
            PMC_LOG_TRACE("cal_entry[%u] = %u\n", i, cal_entry_ptr[i]);
        }
        *num_cal_entries = num_of_recs;
    
    }
    
    PMC_RETURN(result);

} /* coreotn_db_lo_cal_entry_all_get */

/*******************************************************************************
* coreotn_db_ho_entry_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that are
*   operating in data base content generation mode to have the database content
*   driven to a value representing unused.
*
*   When operating in scheduler generation database mode, this API must be
*   called after coreotn_ho_odu_chnl_deprov().
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   db_id               - Enum for DB instance. See util_gen_db_id_t.
*   chnl_id             - HO Channel ID
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_ho_entry_update(coreotn_handle_t *coreotn_handle,
                                            util_gen_db_id_t db_id, UINT32 chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;    
    UINT32 db_handle = 0;
    
    line_core_otn_db_key       key;
    line_core_otn_db_rec       new_rec;
    UINT32                     num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;
    line_core_otn_db_query_res temp_result;
    UINT32 i ;

    PMC_ENTRY();
    
    if (db_id == UTIL_GEN_DB_LINE_CORE_OTN_RX_DB)
    {
        db_handle = coreotn_handle->cfg.rx_db_handle;
    }
    else if (db_id == UTIL_GEN_DB_LINE_CORE_OTN_TX_DB)
    {
        db_handle = coreotn_handle->cfg.tx_db_handle;
    }        

    key.calendar_entry = DO_NOT_USE_KEY;
    key.ho_channel = chnl_id;
    key.mo_channel = DO_NOT_USE_KEY;
    key.lo_channel = DO_NOT_USE_KEY;
    key.trib_slot = DO_NOT_USE_KEY;

    num_of_recs = gen_db_query(&(coreotn_handle->base),
                               db_id, db_handle, (void *)&key, (void **)&q_result);
    
    if (num_of_recs == 0)
    {
        PMC_RETURN(COREOTN_ERR_DB_ENTRY_NOT_FOUND);
    }
    temp_result = *q_result;
                                                
    /* update record to free tributary slots for the HO channel */
    for (i = 0; i < num_of_recs; i++)
    {
        new_rec = *temp_result.p_recs[i];
        new_rec.calendar_entry = temp_result.p_recs[i]->calendar_entry;
        new_rec.mo_channel = COREOTN_DB_ENTRY_UNKNOWN;
        new_rec.lo_channel = COREOTN_DB_ENTRY_UNKNOWN;
        new_rec.cal_entry_status = COREOTN_DB_ENTRY_UNKNOWN;
        new_rec.trib_slot = COREOTN_DB_ENTRY_UNKNOWN;
        new_rec.ts_port_ho_mo = COREOTN_DB_ENTRY_UNKNOWN;
        new_rec.ts_port_mo_lo = COREOTN_DB_ENTRY_UNKNOWN;

        /* send back the result to the DB */ 
        result = gen_db_update_record(&(coreotn_handle->base),
                                      db_id, db_handle, &new_rec);
    }  
    

    PMC_RETURN(result);

} /* coreotn_db_ho_entry_update */

/*******************************************************************************
* coreotn_db_mo_entry_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that are
*   operating in data base content generation mode to have the database content
*   driven to a value representing unused.
*
*   When operating in scheduler generation database mode, this API must be
*   called after coreotn_ho_odu_chnl_deprov().
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   db_id               - Enum for DB instance. See util_gen_db_id_t.
*   chnl_id             - HO Channel ID
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_mo_entry_update(coreotn_handle_t *coreotn_handle,
                                            util_gen_db_id_t db_id, UINT32 chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;    
    UINT32 db_handle = 0;
    
    line_core_otn_db_key       key;
    line_core_otn_db_rec       new_rec;
    UINT32                     num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;
    line_core_otn_db_query_res temp_result;
    UINT32 i;

    PMC_ENTRY();
    
    if (db_id == UTIL_GEN_DB_LINE_CORE_OTN_RX_DB)
    {
        db_handle = coreotn_handle->cfg.rx_db_handle;
    }
    else if (db_id == UTIL_GEN_DB_LINE_CORE_OTN_TX_DB)
    {
        db_handle = coreotn_handle->cfg.tx_db_handle;
    }        

    key.calendar_entry = DO_NOT_USE_KEY;
    key.ho_channel = DO_NOT_USE_KEY;
    key.mo_channel = chnl_id;
    key.lo_channel = DO_NOT_USE_KEY;
    key.trib_slot = DO_NOT_USE_KEY;

    num_of_recs = gen_db_query(&(coreotn_handle->base),
                               db_id, db_handle, (void *)&key, (void **)&q_result);
    
    if (num_of_recs == 0)
    {
        PMC_RETURN(COREOTN_ERR_DB_ENTRY_NOT_FOUND);
    }
    temp_result = *q_result;
                                                
    /* update record to free tributary slots for the HO channel */
    for (i = 0; i < num_of_recs; i++)
    {
        new_rec = *temp_result.p_recs[i];
        /* calendar_entry is the key of the record */
        new_rec.calendar_entry = temp_result.p_recs[i]->calendar_entry;
        new_rec.mo_channel = COREOTN_DB_ENTRY_UNKNOWN;
        new_rec.cal_entry_status = COREOTN_DB_ENTRY_UNKNOWN;
        new_rec.trib_slot = COREOTN_DB_ENTRY_UNKNOWN;

        /* send back the result to the DB */ 
        result = gen_db_update_record(&(coreotn_handle->base),
                                      db_id, db_handle, &new_rec);
    }  
    

    PMC_RETURN(result);

} /* coreotn_db_mo_entry_update */

/*******************************************************************************
* coreotn_db_lo_entry_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that are
*   operating in data base content generation mode to have the database content
*   driven to a value representing unused.
*
*   When operating in scheduler generation database mode, this API must be
*   called after coreotn_ho_odu_chnl_deprov().
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   db_id               - Enum for DB instance. See util_gen_db_id_t.
*   chnl_id             - HO Channel ID
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_lo_entry_update(coreotn_handle_t *coreotn_handle,
                                            util_gen_db_id_t db_id, UINT32 chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;    
    UINT32 db_handle = 0;
    
    line_core_otn_db_key       key;
    line_core_otn_db_rec       new_rec;
    UINT32                     num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;
    line_core_otn_db_query_res temp_result;
    UINT32 i ;
    
    PMC_ENTRY();
    
    if (db_id == UTIL_GEN_DB_LINE_CORE_OTN_RX_DB)
    {
        db_handle = coreotn_handle->cfg.rx_db_handle;
    }
    else if (db_id == UTIL_GEN_DB_LINE_CORE_OTN_TX_DB)
    {
        db_handle = coreotn_handle->cfg.tx_db_handle;
    }        

    key.calendar_entry = DO_NOT_USE_KEY;
    key.ho_channel = DO_NOT_USE_KEY;
    key.mo_channel = DO_NOT_USE_KEY;
    key.lo_channel = chnl_id;
    key.trib_slot = DO_NOT_USE_KEY;

    num_of_recs = gen_db_query(&(coreotn_handle->base),
                               db_id, db_handle, (void *)&key, (void **)&q_result);
    
    if (num_of_recs == 0)
    {
        PMC_RETURN(COREOTN_ERR_DB_ENTRY_NOT_FOUND);
    }
    temp_result = *q_result;
                                                
    /* update record to free tributary slots for the HO channel */
    for (i = 0; i < num_of_recs; i++)
    {
        new_rec = *temp_result.p_recs[i];
        new_rec.calendar_entry = temp_result.p_recs[i]->calendar_entry ;
        new_rec.lo_channel = COREOTN_DB_ENTRY_UNKNOWN;
        new_rec.ts_port_mo_lo = COREOTN_DB_ENTRY_UNKNOWN;

        /* send back the result to the DB */ 
        result = gen_db_update_record(&(coreotn_handle->base),
                                      db_id, db_handle, &new_rec);
    }  
    

    PMC_RETURN(result);

} /* coreotn_db_lo_entry_update */

/*******************************************************************************
* coreotn_db_ho_entry_clear
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that are
*   operating in data base content generation mode to have the database content
*   driven to a value representing unused.
*
*   When operating in scheduler generation database mode, this API must be
*   called after coreotn_ho_odu_chnl_deprov().
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   db_id               - Enum for DB instance. See util_gen_db_id_t.
*   chnl_id             - HO Channel ID
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_ho_entry_clear(coreotn_handle_t *coreotn_handle,
                                           util_gen_db_id_t db_id, UINT32 chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 db_handle = 0;
    
    PMC_ENTRY();
    
    if (db_id == UTIL_GEN_DB_LINEOTN_SYSOTN_MODE)
    {
        mapotn_db_key   key;
        
        db_handle = coreotn_handle->cfg.lineotn_sysotn_card_db_handle;

        key.calendar_entry = DO_NOT_USE_KEY;
        key.channel_num = chnl_id;
        result = gen_db_rem_record(&(coreotn_handle->base),
                                   db_id,
                                   db_handle,
                                   (void *)&key);        
    } 
    else 
    {
        line_core_otn_db_key    key;
        if (db_id == UTIL_GEN_DB_LINE_CORE_OTN_RX_DB)
        {
            db_handle = coreotn_handle->cfg.rx_db_handle;
        }
        else if (db_id == UTIL_GEN_DB_LINE_CORE_OTN_TX_DB)
        {
            db_handle = coreotn_handle->cfg.tx_db_handle;
        } 
        /* add record to the DB */
        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = chnl_id;
        key.mo_channel = DO_NOT_USE_KEY;
        key.lo_channel = DO_NOT_USE_KEY;
        key.trib_slot = DO_NOT_USE_KEY;
        
        result = gen_db_rem_record(&(coreotn_handle->base),
                                   db_id, db_handle, (void *)&key);
    }
    
    PMC_RETURN(result);

} /* coreotn_db_ho_entry_clear */

#if defined PMC_EMULATION | defined PMC_SW_SIMULATION | defined PMC_VERIFICATION
/*******************************************************************************
* coreotn_db_mo_entry_clear
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that are
*   operating in data base content generation mode to have the database content
*   driven to a value representing unused.
*
*   When operating in scheduler generation database mode, this API must be
*   called after coreotn_ho_odu_chnl_deprov().
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   db_id               - Enum for DB instance. See util_gen_db_id_t.
*   chnl_id             - MO Channel ID
*                         Valid range: 0 - 95
*   ho_chnl_id          - HO Channel ID
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_mo_entry_clear(coreotn_handle_t *coreotn_handle,
                                           util_gen_db_id_t db_id, UINT32 chnl_id,
                                           UINT32 ho_chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;    
    UINT32 db_handle = 0;
    
    line_core_otn_db_key       key;
    line_core_otn_db_rec       new_rec;
    UINT32                     num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;
    line_core_otn_db_query_res temp_result;
    UINT32 i;

    PMC_ENTRY();
    
    if (db_id == UTIL_GEN_DB_LINE_CORE_OTN_RX_DB)
    {
        db_handle = coreotn_handle->cfg.rx_db_handle;
    }
    else if (db_id == UTIL_GEN_DB_LINE_CORE_OTN_TX_DB)
    {
        db_handle = coreotn_handle->cfg.tx_db_handle;
    }        

    key.calendar_entry = DO_NOT_USE_KEY;
    key.ho_channel = ho_chnl_id;
    key.mo_channel = DO_NOT_USE_KEY;
    key.lo_channel = DO_NOT_USE_KEY;
    key.trib_slot = DO_NOT_USE_KEY;

    num_of_recs = gen_db_query(&(coreotn_handle->base),
                               db_id, db_handle, (void *)&key, (void **)&q_result);
    
    if (num_of_recs == 0)
    {
        PMC_RETURN(COREOTN_ERR_DB_ENTRY_NOT_FOUND);
    }
    temp_result = *q_result;
                                                
    /* update record to free tributary slots for the HO channel */
    for (i = 0; i < num_of_recs; i++)
    {
        if (temp_result.p_recs[i]->mo_channel == chnl_id)
        {
            new_rec = *temp_result.p_recs[i];
            /* calendar_entry is the key of the record */                        
            new_rec.mo_channel = COREOTN_DB_ENTRY_UNKNOWN;
            new_rec.cal_entry_status = COREOTN_DB_ENTRY_UNKNOWN;
            new_rec.trib_slot = COREOTN_DB_ENTRY_UNKNOWN;
            
            /* send back the result to the DB */ 
            result = gen_db_update_record(&(coreotn_handle->base),
                                          db_id, db_handle, &new_rec);
        }  
    }
    

    PMC_RETURN(result);
} /* coreotn_db_mo_entry_clear */


/*******************************************************************************
* coreotn_db_lo_entry_clear
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a LO channel that are
*   operating in data base content generation mode to have the database content
*   driven to a value representing unused.
*
*   When operating in scheduler generation database mode, this API must be
*   called after coreotn_ho_odu_chnl_deprov().
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   db_id               - Enum for DB instance. See util_gen_db_id_t.
*   chnl_id             - LO Channel ID
*                         Valid range: 0 - 95
*   ho_chnl_id          - HO Channel ID
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_lo_entry_clear(coreotn_handle_t *coreotn_handle,
                                           util_gen_db_id_t db_id, UINT32 chnl_id,
                                           UINT32 ho_chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;    
    UINT32 db_handle = 0;
    
    line_core_otn_db_key       key;
    line_core_otn_db_rec       new_rec;
    UINT32                     num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;
    line_core_otn_db_query_res temp_result;
    UINT32 i;

    PMC_ENTRY();
    
    if (db_id == UTIL_GEN_DB_LINE_CORE_OTN_RX_DB)
    {
        db_handle = coreotn_handle->cfg.rx_db_handle;
    }
    else if (db_id == UTIL_GEN_DB_LINE_CORE_OTN_TX_DB)
    {
        db_handle = coreotn_handle->cfg.tx_db_handle;
    }        

    key.calendar_entry = DO_NOT_USE_KEY;
    key.ho_channel = DO_NOT_USE_KEY;
    key.mo_channel = ho_chnl_id;
    key.lo_channel = DO_NOT_USE_KEY;
    key.trib_slot = DO_NOT_USE_KEY;

    num_of_recs = gen_db_query(&(coreotn_handle->base),
                               db_id, db_handle, (void *)&key, (void **)&q_result);
    
    if (num_of_recs == 0)
    {
        PMC_RETURN(COREOTN_ERR_DB_ENTRY_NOT_FOUND);
    }
    temp_result = *q_result;
                                                
    /* update record to free tributary slots for the HO channel */
    for (i = 0; i < num_of_recs; i++)
    {
        if (temp_result.p_recs[i]->lo_channel == chnl_id)
        {
            new_rec = *temp_result.p_recs[i];
            /* calendar_entry is the key of the record */            
            new_rec.lo_channel = COREOTN_DB_ENTRY_UNKNOWN;
            new_rec.cal_entry_status = COREOTN_DB_ENTRY_UNKNOWN;
            new_rec.ts_port_mo_lo = COREOTN_DB_ENTRY_UNKNOWN;
            
            /* send back the result to the DB */ 
            result = gen_db_update_record(&(coreotn_handle->base),
                                          db_id, db_handle, &new_rec);
        }  
    }
    

    PMC_RETURN(result); 
} /* coreotn_db_lo_entry_clear */


/*******************************************************************************
*  coreotn_db_ho_chnl_cal_schd_add
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function is created to locally generate calendar scheduling for COREOTN.
*   
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - channel ID to be configured
*                         Valid range: 0 - 95
*   cal_slot_mask       - 32bit x 3 mask to represent the calendar slot
*                         assignment of the HO channel.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_ho_chnl_cal_schd_add(coreotn_handle_t *coreotn_handle,
                                                 UINT32 chnl_id,
                                                 UINT32 cal_slot_mask[3])
{
    PMC_ERROR result = PMC_SUCCESS;

    UINT32 cal_entry_idx = 0;
    UINT32 cal_slot;

    PMC_ENTRY();

    /* store calendar slot assignment to HO context fot the chnl_id */
    for (cal_slot = 0; cal_slot < 96; cal_slot++)
    {
        if ((cal_slot_mask[cal_slot/32] >> (cal_slot%32)) & 1)
        {
            result = coreotn_db_entry_set(coreotn_handle, chnl_id, cal_slot,
                                          cal_entry_idx);

            if (PMC_SUCCESS == result)
            {
                /* found occupied tribslot */
                cal_entry_idx++;
                PMC_LOG_TRACE("added Rx/Tx DB rec: %d, cal_slot=%d, chnl_id=%d\n", cal_entry_idx, cal_slot, chnl_id);
            }
        }
    }
    
    PMC_RETURN(result);
} /* coreotn_db_ho_chnl_cal_schd_add */
#endif /* PMC_EMULATION | PMC_SW_SIMULATION */

/*******************************************************************************
* coreotn_lo_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method to retrieve the list of MO or LO 
*   channels asscoaited to their respective HO or MO channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   line_side           - TRUE means line side, FALSE means system side
*   ho_odu_level        - ODU level of the container
*   ho_chnl_id          - HO or MO Channel ID
*
* OUTPUTS:
*   *ch_ptr             - storage for an array of channel provisionned under 
*                         specied HO channel (shall be at least sizeof(UINT3232)*80
*                         the HO channel.
*   *num_ch             - number of channel in the current HO 
*
* RETURNS:
*
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_lo_chnl_get(coreotn_handle_t *coreotn_handle,
                                     BOOL8  line_side,
                                     coreotn_chnl_order_t ho_odu_level,
                                     UINT32 ho_chnl_id,
                                     UINT32 *ch_ptr,
                                     UINT32 *num_ch)
{
    BOOL8 is_sysotn_mode =  (coreotn_handle->var.init_operation  == COREOTN_SS_SYSOTN_MODE || 
                             coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE) ?TRUE:FALSE;
    util_global_odu_line_payload_t ho_payload_format  = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
    odtu_dmx_handle_t *odtu_dmx_handle = NULL;
    PMC_ENTRY();
    
    *num_ch = 0;            
    
    if (is_sysotn_mode == TRUE)
    {
        if (TRUE == line_side)
        {
            PMC_ASSERT(ho_chnl_id<COREOTN_MAX_NUM_HO_CHNL,COREOTN_ERR_INVALID_ARG,0,0);
            PMC_ASSERT(ho_odu_level == COREOTN_CHNL_ORDER_HO,COREOTN_ERR_INVALID_ARG,0,0);            
            *num_ch = 0;            
        } else 
        {
            PMC_ASSERT((ho_odu_level == COREOTN_CHNL_ORDER_HO && ho_chnl_id == 0) ||
                       (ho_odu_level == COREOTN_CHNL_ORDER_MO && ho_chnl_id<COREOTN_MAX_NUM_MO_CHNL),
                       COREOTN_ERR_INVALID_ARG,0,0);
            if (ho_odu_level == COREOTN_CHNL_ORDER_MO)
            {
                *num_ch = 0;            
            } else if (coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
            {
                ho_payload_format = coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].payload_format;
                odtu_dmx_handle   = coreotn_handle->odtu_dmx2_handle;
            }
        }        
    } else 
    {
        PMC_ASSERT((ho_odu_level == COREOTN_CHNL_ORDER_HO && ho_chnl_id<COREOTN_MAX_NUM_HO_CHNL) ||
                   (ho_odu_level == COREOTN_CHNL_ORDER_MO && ho_chnl_id<COREOTN_MAX_NUM_MO_CHNL) ||
                   (ho_odu_level == COREOTN_CHNL_ORDER_LO && ho_chnl_id<COREOTN_MAX_NUM_LO_CHNL),
                   COREOTN_ERR_INVALID_ARG,0,0);
        if (ho_odu_level == COREOTN_CHNL_ORDER_LO)
        {
            *num_ch = 0;            
        } else if (ho_odu_level == COREOTN_CHNL_ORDER_HO && 
                   coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
        {
            ho_payload_format = coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].payload_format;
            odtu_dmx_handle   = coreotn_handle->odtu_dmx1_handle;
        } else if (ho_odu_level == COREOTN_CHNL_ORDER_MO  &&
                   coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
        {
            ho_payload_format = coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].payload_format;
            odtu_dmx_handle   = coreotn_handle->odtu_dmx2_handle;
        }        
    }

    if (ho_payload_format == UTIL_GLOBAL_ODU_TS_1G25 || ho_payload_format == UTIL_GLOBAL_ODU_TS_2G5)
    {
        UINT32 ch_arr_tx[96];
        UINT32 num_ch_tx = 0;

        /* get LOW channel from odtu_dmx context */
        odtu_dmx_lo_chnl_get(odtu_dmx_handle,
                                      ho_chnl_id,
                                      ch_ptr,
                                      num_ch);

        coreotn_lo_chnl_get_tx(coreotn_handle,
                               line_side,
                               ho_odu_level,
                               ho_chnl_id,
                               ch_arr_tx,
                               &num_ch_tx);
        UINT32 i = 0;

        if (0 == *num_ch)
        {
            for (i = 0; i < num_ch_tx; i++)
            {
                ch_ptr[i] = ch_arr_tx[i];
            }
            *num_ch = num_ch_tx;
        }
        else if (num_ch_tx > 0)
        {
            UINT32 tx_index = 0;

            while (tx_index < num_ch_tx)
            {
                BOOL8 bFound = FALSE;

                for (i = 0; i < *num_ch; i++)
                {
                    if (ch_ptr[i] == ch_arr_tx[tx_index])
                    {
                        bFound = TRUE;
                        break;
                    }
                }

                if (FALSE == bFound)
                {
                    ch_ptr[*num_ch] = ch_arr_tx[tx_index];
                    *num_ch += 1;
                }
                tx_index++;
            }
        }
    }

    PMC_RETURN();

} /* coreotn_lo_chnl_get */


/*
** COREOTN ODUKSW port initialization
*/
/*******************************************************************************
* coreotn_oduksw_input_port_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function initializes an input port of the ODUKSW instance in the DIGI
*   instance.  This function will perform ODUKSW instantiation specific
*   configuration of the respective port.
*
*
* INPUTS:
*   *coreotn_handle       - pointer to COREOTN handle instance.
*   input_port            - Ingress Mux Input Port, identifies the subsystem
*                           associated port to be enabled
*   oduksw_xfer_mode      - Enum, defining the output interface type.  Only
*                           valid for SIFD ports.  Otherwise transfer modes
*                           internally set.
*                           Only valid OCPB instantiation for input_port
*                           0 and 1.
*   hdr_removal_size      - header size for header removal config
*                           supported values : 0-6 bytes
*                           set to 0 for the port not supporting header removal
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_input_port_init(coreotn_handle_t *coreotn_handle,
                                                util_global_oduk_port_t input_port,
                                                coreotn_oduksw_xfer_mode_t oduksw_xfer_mode,
                                                UINT32 hdr_removal_size)
{
    BOOL rc;
    
    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != coreotn_handle->oduksw_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    
    rc = cpb_ingress_mux_input_init(coreotn_handle->oduksw_handle,
                                    input_port, (cpb_xfer_mode_t)oduksw_xfer_mode, 
                                    hdr_removal_size);
                                    
    PMC_RETURN(rc);
} /* coreotn_oduksw_input_port_init */

/*******************************************************************************
* coreotn_oduksw_output_port_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function initializes an output port of the ODUKSW instance in the DIGI
*   instance.  This function will perform ODUKSW instantiation specific
*   configuration of the respective port.
*
*
* INPUTS:
*   *coreotn_handle       - pointer to COREOTN handle instance.
*   output_port           - Output port
*   oduksw_xfer_mode      - Enum, defining the output interface type.  Only
*                           valid for SIFD ports.  Otherwise transfer modes
*                           internally set. \n
*                           Only valid OCPB instantiation for input_port
*                           0 and 1.
*   mode                  - State of Egress Mux Output Port \n
*                           0 : Disabled \n
*                           1 : Enabled
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_output_port_init(coreotn_handle_t *coreotn_handle,
                                                 util_global_oduk_port_t output_port,
                                                 UINT32 oduksw_xfer_mode,
                                                 UINT32 mode)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();

    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE,0,0);
    PMC_ASSERT(coreotn_handle->oduksw_handle != NULL, COREOTN_ERR_NULL_HANDLE,0,0);

    result = cpb_egress_mux_output_init(coreotn_handle->oduksw_handle,
                                        output_port, (cpb_xfer_mode_t)oduksw_xfer_mode, mode);

    /*if (PMC_SUCCESS == result)
      {
      result = cpb_egress_mux_input_init(coreotn_handle->oduksw_handle,
      output_port, oduksw_xfer_mode, mode);
      }*/

    PMC_RETURN(result);
} /* coreotn_oduksw_output_port_init */


/*******************************************************************************
* coreotn_oduksw_egress_mux_input_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function initializes an output port of the ODUKSW instance in the DIGI
*   instance.  This function will perform ODUKSW instantiation specific
*   configuration of the respective port.
*
*
* INPUTS:
*   *coreotn_handle       - pointer to COREOTN handle instance.
*   output_port           - Output port
*   oduksw_xfer_mode      - Enum, defining the output interface type.  Only
*                           valid for SIFD ports.  Otherwise transfer modes
*                           internally set. \n
*                           Only valid OCPB instantiation for input_port
*                           0 and 1.
*   mode                  - State of Egress Mux Output Port \n
*                           0 : Disabled \n
*                           1 : Enabled
*                           2 : Enabled (SIFD mode)
*                           mode set to 2 only valid for input_port set to 0 or 1
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_egress_mux_input_init(coreotn_handle_t *coreotn_handle,
                                                      util_global_oduk_port_t output_port,
                                                      UINT32 oduksw_xfer_mode,
                                                      UINT32 mode)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();

    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE,0,0);
    PMC_ASSERT(coreotn_handle->oduksw_handle != NULL, COREOTN_ERR_NULL_HANDLE,0,0);

    result = cpb_egress_mux_input_init(coreotn_handle->oduksw_handle,
                                       output_port, (cpb_xfer_mode_t)oduksw_xfer_mode, (cpb_dcs_instance_mode_t)mode);

    PMC_RETURN(result);
} /* coreotn_oduksw_egress_mux_input_init */

/*******************************************************************************
* coreotn_oduksw_port_init_state_get
* ______________________________________________________________________________
* DESCRIPTION:
*   This function gets the initialization state of the slave DPI port, master
*   DPI port or the DCS instance.
* INPUTS:
*   *coreotn_handle       - pointer to COREOTN handle instance.
*   port_type             - 0 ; input port/ 1: output port/2: DCS inst
*   port_id               - port id that needs to be tested
*
* OUTPUTS:
*   None.
* RETURNS:
*   TRUE                  - the port has been initialized
*   FALSE                 - the port has not been initialized
* NOTES:
*******************************************************************************/
PUBLIC BOOL coreotn_oduksw_port_init_state_get(coreotn_handle_t *coreotn_handle,
                                               UINT32 port_type,
                                               UINT32 port_id)
{
    BOOL rc;
    
    PMC_ENTRY();
    
    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE,0,0);
        
    rc = cpb_port_init_state_get(coreotn_handle->oduksw_handle, (cpb_port_type_t)port_type, port_id);
    
    PMC_RETURN(rc);
} /* coreotn_oduksw_port_init_state_get */

/*******************************************************************************
* coreotn_oduksw_chnl_source_and_type_test
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function provides an interface to get the source port and channel id for
*   a given destination port and chnl id , also  tests if the given chnl is a
*   broadcast channel or a multicast channel.  \n\n
*
*   This function retrieves channel configuration information that is stored
*   in SW driver memory.  Device accesses are not performed by this function.
*   \n\n
*
*   In emulation mode this function retrieves the user assigned port ID and
*   not the emulation CPB port ID.
*
* INPUTS:
*   *coreotn_handle              -  The pointer to the COREOTN instance.
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
* OUTPUTS:
*   *ingress_mux_input_port       -  pointer to the source port
*   *ingress_mux_input_port_chnl  -  pointer to the source channel id
*   *is_broadcast                 -  Broadcast is defined as: DPI slave port 
*                                    channel is processed by more than one queue 
*                                    system (ie target more than one 
*                                    egress_mux_output_port)
*                                    FALSE : is not a broadcast channel
*                                    TRUE  : is a broadcast channel
*   *is_multicast                   - Multicast is defined as: There are more than 
*                                    one reader for the DPI Slave Port Channel 
*                                    within the queue system associated with 
*                                    egress_mux_output_port
*                                    FALSE : is not a multicast channel
*                                    TRUE  : is a multicast channel
*
* RETURNS:
*   PMC_SUCCESS - Operation was successful
*   PMC_ERROR   - Otherwise
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_chnl_source_and_type_test(coreotn_handle_t *coreotn_handle,
                                                          UINT32 egress_mux_output_port,
                                                          UINT32 egress_mux_output_port_chnl,
                                                          UINT32 *ingress_mux_input_port,
                                                          UINT32 *ingress_mux_input_port_chnl,
                                                          BOOL *is_broadcast,
                                                          BOOL *is_multicast)
{
    PMC_ERROR result;
    BOOL8 int_is_broadcast;
    BOOL8 int_is_multicast;
    
    
    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != coreotn_handle->oduksw_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    result = cpb_chnl_source_and_type_test (coreotn_handle->oduksw_handle,
                                            egress_mux_output_port,
                                            egress_mux_output_port_chnl,
                                            ingress_mux_input_port,
                                            ingress_mux_input_port_chnl,
                                            &int_is_broadcast,
                                            &int_is_multicast); 

    *is_broadcast = UTIL_GLOBAL_BOOL8_TO_BOOL_CONVERT(int_is_broadcast);
    *is_multicast = UTIL_GLOBAL_BOOL8_TO_BOOL_CONVERT(int_is_multicast);

    PMC_RETURN(result);                                        
} /* coreotn_oduksw_chnl_source_and_type_test */


/*******************************************************************************
* coreotn_oduksw_connect_data_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a wrapper function to the cpb_connect_data_state_get function.
*
* INPUTS:
*   *coreotn_handle          -  The pointer to the COREOTN instance.
*   
* OUTPUTS:
*   **connect_data_pptr      - Reference to the connect array pointer to be
*                              populated with the ODUK switch connectivity
*                              data.
*
* RETURNS:
*   None
*
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_oduksw_connect_data_state_get(coreotn_handle_t *coreotn_handle,
                                                  util_global_cpb_connect_t **connect_data_pptr)
{
    PMC_ENTRY();

    cpb_connect_data_state_get(coreotn_handle->oduksw_handle,
                               connect_data_pptr);

    PMC_RETURN();
} /* coreotn_oduksw_connect_data_state_get */

/*******************************************************************************
* coreotn_oduksw_chnl_type_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function returns the given channel's type with enum type cpb_dcpb_rd_chnl_t,
*   it also returns the number of readers within the same QS and reading from the
*   same source channel.
*
* INPUTS:
*   *coreotn_handle              -  pointer to the COREOTN handle instance
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*
* OUTPUTS:
*   is_reader_primary            -  The egress mux output port channel is the 
*                                   primary reader for the queue system in which
*                                   it is configured.
*   is_slave_zone_primary        -  The egress mux output port channel is the DPI 
*                                   slave port channel zone source for all channels 
*                                   associated with the DPI slave port channel.

*   *is_broadcast                -  Broadcast is defined as: DPI slave port 
*                                   channel is processed by more than one queue 
*                                   system (ie target more than one 
*                                   egress_mux_output_port)
*                                   FALSE : is not a broadcast channel
*                                   TRUE  : is a broadcast channel
*   *is_multicast                -  Multicast is defined as: There are more than 
*                                   one reader for the DPI Slave Port Channel 
*                                   within the queue system associated with 
*                                   egress_mux_output_port
*                                   FALSE : is not a multicast channel
*                                   TRUE  : is a multicast channel
* RETURNS: 
*   PMC_SUCCESS - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_chnl_type_get(coreotn_handle_t *coreotn_handle,
                                              UINT32 egress_mux_output_port,
                                              UINT32 egress_mux_output_port_chnl,
                                              BOOL*   is_reader_primary,
                                              BOOL*   is_slave_zone_primary,
                                              BOOL*   is_broadcast,
                                              BOOL*   is_multicast )
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 input_port = CPB_INDEX_LAST;

    UINT32 input_channel = CPB_INDEX_LAST;
    BOOL8 int_is_broadcast;
    BOOL8 int_is_multicast;
    BOOL8 int_is_reader_primary;
    BOOL8 int_is_slave_zone_primary;

    PMC_ENTRY();

    result = cpb_chnl_source_type_and_primary_test(coreotn_handle->oduksw_handle,
                                                   egress_mux_output_port,
                                                   egress_mux_output_port_chnl,
                                                   &input_port,
                                                   &input_channel,
                                                   &int_is_broadcast,
                                                   &int_is_multicast,
                                                   &int_is_reader_primary,
                                                   &int_is_slave_zone_primary);

    if (CPB_ERR_ZONE_SOURCE_NOT_FOUND == result && 
        CPB_INDEX_LAST == input_port && CPB_INDEX_LAST == input_channel)
    {
        /*
         * The function cpb_chnl_source_type_and_primary_test returns
         * CPB_ERR_ZONE_SOURCE_NOT_FOUND if the source is not set
         * indicating ther is not input for this handle. This is not
         * really an error so reset the return code to success.
         */
        result = PMC_SUCCESS;
    }
    else if (PMC_SUCCESS == result)
    {
        *is_broadcast = UTIL_GLOBAL_BOOL8_TO_BOOL_CONVERT(int_is_broadcast);
        *is_multicast = UTIL_GLOBAL_BOOL8_TO_BOOL_CONVERT(int_is_multicast);
        *is_reader_primary = UTIL_GLOBAL_BOOL8_TO_BOOL_CONVERT(int_is_reader_primary);
        *is_slave_zone_primary = UTIL_GLOBAL_BOOL8_TO_BOOL_CONVERT(int_is_slave_zone_primary);
    }
    PMC_RETURN(result);
} /* coreotn_oduksw_chnl_type_get */

/*******************************************************************************
* coreotn_oduksw_queue_resize_wrapper
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function resizes an ODUKSW channel FIFO.
*
* INPUTS:
*   *coreotn_handle              -  pointer to the COREOTN handle instance
*   port                         -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   chnl                         -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*   num_blocks                   - number of blocks to make the FIFO
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_queue_resize_wrapper(coreotn_handle_t *coreotn_handle,
                                                     UINT32 port,
                                                     UINT32 chnl,
                                                     UINT32 num_blocks)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* varialbe declaration */
    result = cpb_queue_resize_wrapper (coreotn_handle->oduksw_handle, 
                                       port,
                                       chnl,
                                       num_blocks);

    PMC_RETURN(result);
} /* coreotn_oduksw_queue_resize_wrapper */

/*******************************************************************************
* coreotn_fo2_mpmo_ch_activate
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function activates FO2 MPMO channel.
*
* INPUTS:
*   *coreotn_handle              -  pointer to the COREOTN handle instance
*   output_chnl_id               -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*
* OUTPUTS:
*   None.
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_fo2_mpmo_ch_activate(coreotn_handle_t *coreotn_handle,
                                              UINT32 output_chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* MPMO in FO2 */
    result = mpmo_ch_activate(coreotn_handle->mpmo_fo2_handle, output_chnl_id);

    PMC_RETURN(result);
} /* coreotn_fo2_mpmo_ch_activate */

/*******************************************************************************
* coreotn_fo2_mpmo_ch_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deactivates FO2 MPMO channel.
*
* INPUTS:
*   *coreotn_handle              -  pointer to the COREOTN handle instance
*   output_chnl_id               -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_fo2_mpmo_ch_deactivate(coreotn_handle_t *coreotn_handle,
                                                UINT32 output_chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* MPMO in FO2 */
    result = mpmo_ch_deactivate(coreotn_handle->mpmo_fo2_handle, output_chnl_id);
    
    PMC_RETURN(result);
} /* coreotn_fo2_mpmo_ch_deactivate */


/*
** OTN_PRBS 
*/ 


/*******************************************************************************
*  coreotn_prbs_chnl_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Initialize PRBS block to generate or monitor the pattern on the channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   prbs_inst           - Enum for PRBS block instace. See coreotn_prbs_inst_t
*   chnl                - PRBS channel ID to be provisioned 
*                         Valid range: 0 - 11
*   dci_chnl            - DCI channel ID associated with the PRBS channel
*   prbs_operation      - mode of operation \n
*                         0 -- PRBS monitor \n
*                         1 -- PRBS generator
*   mode                - operational mode \n
*                         0 -- disable \n
*                         1 -- enable
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_prbs_chnl_init(coreotn_handle_t *coreotn_handle,
                                        coreotn_prbs_inst_t prbs_inst, 
                                        UINT32 chnl, 
                                        UINT32 dci_chnl,                                        
                                        UINT32 prbs_operation,
                                        UINT32 mode)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 mon_gen_en = 0;

    PMC_ENTRY();

    /* FO1 PRBS is internal only */
    if (COREOTN_FO1_PRBS == prbs_inst)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_PRBS_CFG_STG3A3B);   
    }

    if (prbs_inst < COREOTN_FO1_PRBS)
    {
        if (prbs_operation == 1)
        {
            coreotn_fmf_field_PRBS_GEN_EN_set(NULL, coreotn_handle, prbs_inst, chnl, mode);

            if (mode == 0)
            {
                mon_gen_en = coreotn_fmf_field_PRBS_MON_EN_get(NULL, coreotn_handle, prbs_inst, chnl);
            }

            if(coreotn_handle->var.init_operation  == COREOTN_SS_SYSOTN_MODE ||
               coreotn_handle->var.init_operation  == COREOTN_SS_SYSOTN_BYPASS_MODE)
            {
                if(prbs_inst == COREOTN_FMF2_PRBS)
                {
                    if(ret_val == PMC_SUCCESS)
                    {
                        ret_val = coreotn_prbs_null_chan_en_set(coreotn_handle,
                                                                COREOTN_MUX_STAGE_ONE,
                                                                dci_chnl,
                                                                mode,
                                                                chnl);
                    }
                }
            }
            else
            {
                if(prbs_inst == COREOTN_FMF1_PRBS)
                {
                    if(ret_val == PMC_SUCCESS)
                    {
                        ret_val = coreotn_prbs_null_chan_en_set(coreotn_handle,
                                                                COREOTN_MUX_STAGE_ONE,
                                                                dci_chnl,
                                                                mode,
                                                                chnl);
                    }
                }
                else
                {
                    if(ret_val == PMC_SUCCESS)
                    {
                        ret_val = coreotn_prbs_null_chan_en_set(coreotn_handle,
                                                                COREOTN_MUX_STAGE_TWO,
                                                                dci_chnl,
                                                                mode,
                                                                chnl);
                    }
                }

            }


        }
        else 
        {
            coreotn_fmf_field_PRBS_MON_EN_set(NULL, coreotn_handle, prbs_inst, chnl, mode);

            if (mode == 0)
            {
                mon_gen_en = coreotn_fmf_field_PRBS_GEN_EN_get(NULL, coreotn_handle, prbs_inst, chnl);
            }
        }
    }
    else 
    {
        if (prbs_operation == 1)
        {
            coreotn_fo_field_PRBS_GEN_EN_set(NULL, coreotn_handle, prbs_inst-2, chnl, mode);

            if (mode == 0)
            {
                mon_gen_en = coreotn_fo_field_PRBS_MON_EN_get(NULL, coreotn_handle, prbs_inst-2, chnl);
            }
        }
        else 
        {
            coreotn_fo_field_PRBS_MON_EN_set(NULL, coreotn_handle, prbs_inst-2, chnl, mode);
            
            if (mode == 0)
            {
                mon_gen_en = coreotn_fo_field_PRBS_GEN_EN_get(NULL, coreotn_handle, prbs_inst-2, chnl);
            }
        }
    }   

    if (mode == 0 && mon_gen_en == 0)
    {
        /* If both the monitor and generator have been disabled, set PRBS_CHID to 0x7F*/
        if (prbs_inst < COREOTN_FO1_PRBS)
        {
            coreotn_fmf_field_PRBS_CHID_set(NULL, coreotn_handle, prbs_inst, chnl, COREOTN_PRBS_MON_DISABLED);
        }
        else 
        {
            coreotn_fo_field_PRBS_CHID_set(NULL, coreotn_handle, prbs_inst-2, chnl, COREOTN_PRBS_MON_DISABLED);  
        }    
    }
	else
    {
        if (prbs_inst < COREOTN_FO1_PRBS)
        {
            coreotn_fmf_field_PRBS_CHID_set(NULL, coreotn_handle, prbs_inst, chnl, dci_chnl);
        }
        else 
        {
            coreotn_fo_field_PRBS_CHID_set(NULL, coreotn_handle, prbs_inst-2, chnl, dci_chnl);  
        }  
	}

    /* Mark monitor mode as enabled or disabled */
    if (prbs_operation == 0)
    {
        COREOTN_PRBS_MON_ENABLE(coreotn_handle, prbs_inst, chnl, dci_chnl, mode);
    }
       
    PMC_RETURN(ret_val);
} /* coreotn_prbs_chnl_init */

/*******************************************************************************
*  coreotn_prbs_pattern_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Provisions a channel with the specified PRBS pattern.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   prbs_inst           - Enum for PRBS instance. See coreotn_prbs_inst_t.
*   chnl                - channel ID that carries PRBS pattern
*                         Valid range: 0 - 11
*   dci_chnl            - DCI channel that is to be mapped to the PRBS channel
*                         Valid range: 0 - 95
*   prbs_pattern        - PRBS pattern to transmit. See coreotn_prbs_pattern_t. \n
*                         0 -- OTN_INVERTED_PRBS_11 \n
*                         1 -- OTN_INVERTED_PRBS_31 \n
*                         2 -- OTN_PRBS_11 \n 
*                         3 -- OTN_PRBS_31
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_prbs_pattern_cfg(coreotn_handle_t *coreotn_handle,
                                          coreotn_prbs_inst_t prbs_inst,
                                          UINT32 chnl, UINT32 dci_chnl, 
                                          coreotn_prbs_pattern_t prbs_pattern)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 inverted_patt;
    UINT32 prbs_sel;
    
    PMC_ENTRY();
    
    /* argument checking */
    if (chnl > 11 || dci_chnl > 95 || prbs_pattern > COREOTN_PRBS_31)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    /* FO1 PRBS is internal only */
    if (COREOTN_FO1_PRBS == prbs_inst)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_PRBS_CFG_STG3A3B);   
    }
    
    /* program the PRBS pattern to transmit */
    switch (prbs_pattern)
    {
    case COREOTN_INVERTED_PRBS_11:
        inverted_patt = 1;
        prbs_sel = 0;
        break;
    case COREOTN_INVERTED_PRBS_31:
        inverted_patt = 1;
        prbs_sel = 1;
        break;
    case COREOTN_PRBS_11:
        inverted_patt = 0;
        prbs_sel = 0;
        break;
    case COREOTN_PRBS_31:
        inverted_patt = 0;
        prbs_sel = 1;
        break;
    default:
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
        break;
    }
    
    if (prbs_inst < COREOTN_FO1_PRBS)
    {
        coreotn_fmf_field_PRBS_CHID_set(NULL, coreotn_handle, prbs_inst, chnl, dci_chnl);
        coreotn_fmf_field_PRBS_SEL_INV_NONINV_set( NULL, coreotn_handle, prbs_inst, chnl, inverted_patt);
        coreotn_fmf_field_PRBS_SEL_31_11_set(NULL, coreotn_handle, prbs_inst, chnl, prbs_sel);
    }
    else {
        coreotn_fo_field_PRBS_CHID_set(NULL, coreotn_handle, prbs_inst-2, chnl, dci_chnl);
        coreotn_fo_field_PRBS_SEL_INV_NONINV_set( NULL, coreotn_handle, prbs_inst-2, chnl, inverted_patt);
        coreotn_fo_field_PRBS_SEL_31_11_set(NULL, coreotn_handle, prbs_inst-2, chnl, prbs_sel);        
    }    


    /* Store the channel that PRBS is provisioned on in local context */
    if (COREOTN_PRBS_MON_IS_ENABLED(coreotn_handle, prbs_inst, chnl))
    {
        COREOTN_PRBS_MON_CHNL_SET(coreotn_handle, prbs_inst, chnl, dci_chnl);
    }
    
    PMC_RETURN(ret_val);
    
} /* coreotn_prbs_pattern_cfg */

/*******************************************************************************
*  coreotn_prbs_pattern_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retreives the current PRBS pattern on a channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   prbs_inst           - Enum for PRBS instance. See coreotn_prbs_inst_t.
*   chnl                - channel ID that carries PRBS pattern
*                         Valid range: 0 - 11
*   dci_chnl            - DCI channel that is to be mapped to the PRBS channel
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   *prbs_pattern       - PRBS pattern being inserted. See coreotn_prbs_pattern_t. \n
*                         0 -- OTN_INVERTED_PRBS_11 \n
*                         1 -- OTN_INVERTED_PRBS_31 \n
*                         2 -- OTN_PRBS_11 \n 
*                         3 -- OTN_PRBS_31
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_prbs_pattern_get(coreotn_handle_t *coreotn_handle,
                                          coreotn_prbs_inst_t prbs_inst,
                                          UINT32 chnl, UINT32 dci_chnl, 
                                          coreotn_prbs_pattern_t *prbs_pattern)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 inverted_patt;
    UINT32 prbs_sel;
    
    PMC_ENTRY();
    
    /* argument checking */
    if (chnl > 11 || dci_chnl > 95)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    /* FO1 PRBS is internal only */
    if (COREOTN_FO1_PRBS == prbs_inst)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_PRBS_CFG_STG3A3B);   
    }
    
    if (prbs_inst < COREOTN_FO1_PRBS)
    {
        inverted_patt = coreotn_fmf_field_PRBS_SEL_INV_NONINV_get( NULL, coreotn_handle, prbs_inst, chnl);
        prbs_sel = coreotn_fmf_field_PRBS_SEL_31_11_get(NULL, coreotn_handle, prbs_inst, chnl);
    }
    else {
        inverted_patt = coreotn_fo_field_PRBS_SEL_INV_NONINV_get( NULL, coreotn_handle, prbs_inst-2, chnl);
        prbs_sel = coreotn_fo_field_PRBS_SEL_31_11_get(NULL, coreotn_handle, prbs_inst-2, chnl);        
    }    
    
    /* program the PRBS pattern to transmit */
    if (inverted_patt)
    {
        if (prbs_sel == 0)
        {
            *prbs_pattern = COREOTN_INVERTED_PRBS_11;
        }
        else 
        {
            *prbs_pattern = COREOTN_INVERTED_PRBS_31;
        }
    }
    else {
        if (prbs_sel == 0)
        {
            *prbs_pattern = COREOTN_PRBS_11;
        }
        else {
            *prbs_pattern = COREOTN_PRBS_31;
        }
    }
    
    PMC_RETURN(ret_val);
    
} /* coreotn_prbs_pattern_get */

/*******************************************************************************
*  coreotn_prbs_ber_thres_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures the defect threshold count for the given PRBS channel. 
*   If the bit error rate goes over the programmed threshold in a gvien LCLK 
*   one second interval, the PRBS monitor will enter out of lock state.
*
* INPUTS:
*   *coreotn_handle        - pointer to COREOTN handle instance
*   prbs_inst              - Enum for PRBS instance. See coreotn_prbs_inst_t.
*   prbs_ber_lo_thres      - lower 32 bits of the defect threshold count for the 
*                            given PRBS channel. 
*   prbs_ber_hi_thres      - upper 3 bits of the defect threshold count for the 
*                            given PRBS channel. 
*   prbs_reseed_thres      - number of bit errors detected before PRBS monitor reseed
*   prbs_reseed_interval   - number of cycles between re-seed attempts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_prbs_ber_thres_cfg(coreotn_handle_t *coreotn_handle,
                                            coreotn_prbs_inst_t prbs_inst,
                                            UINT32 prbs_ber_lo_thres, 
                                            UINT32 prbs_ber_hi_thres,
                                            UINT16 prbs_reseed_thres,
                                            UINT16 prbs_reseed_interval)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    
    PMC_ENTRY();

    /* FO1 PRBS is internal only */
    if (COREOTN_FO1_PRBS == prbs_inst)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_PRBS_CFG_STG3A3B);   
    }
    
    if (prbs_inst < COREOTN_FO1_PRBS)
    {
        coreotn_fmf_lfield_range_PRBS_BER_THRES_set(NULL, coreotn_handle, prbs_inst, 0, 31, prbs_ber_lo_thres);
        coreotn_fmf_lfield_range_PRBS_BER_THRES_set(NULL, coreotn_handle, prbs_inst, 32, 34, prbs_ber_hi_thres);
        coreotn_fmf_field_PRBS_RESEED_THR_set(NULL, coreotn_handle, prbs_inst, prbs_reseed_thres);
        coreotn_fmf_field_PRBS_RESEED_INTERVAL_set(NULL, coreotn_handle, prbs_inst, prbs_reseed_interval);
    }
    else                                    
    {
        coreotn_fo_lfield_range_PRBS_BER_THRES_set(NULL, coreotn_handle, prbs_inst-2, 0, 31, prbs_ber_lo_thres);
        coreotn_fo_lfield_range_PRBS_BER_THRES_set(NULL, coreotn_handle, prbs_inst-2, 32, 34, prbs_ber_hi_thres);
        coreotn_fo_field_PRBS_RESEED_THR_set(NULL, coreotn_handle, prbs_inst-2, prbs_reseed_thres);
        coreotn_fo_field_PRBS_RESEED_INTERVAL_set(NULL, coreotn_handle, prbs_inst-2, prbs_reseed_interval);
    }                                    
    
    PMC_RETURN(ret_val);    
} /* coreotn_prbs_ber_thres_cfg */

/*******************************************************************************
*  coreotn_prbs_chnl_bit_err_inject
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Injecst a single bit error into the PRBS pattern for the channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   prbs_inst           - Enum for PRBS instance. See coreotn_prbs_inst_t.
*   chnl                - PRBS channel ID to be configured.
*                         Valid range: 0 -- 12 
*   insert_err          - control whether or not a single bit error will be 
*                         inserted in the PRBS pattern. \n
*                         1 -- a single bit error is inserted once into the PRBS
*                              pattern for the channel \n
*                         0 -- defect insertion is disabled.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_prbs_chnl_bit_err_inject(coreotn_handle_t *coreotn_handle,
                                                  coreotn_prbs_inst_t prbs_inst,
                                                  UINT32 chnl, UINT32 insert_err)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    
    PMC_ENTRY();
    
    /* argument checking */
    if (chnl > 11 || insert_err > 1)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    /* FO1 PRBS is internal only */
    if (COREOTN_FO1_PRBS == prbs_inst)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_PRBS_CFG_STG3A3B);   
    }
    
    /* inject a single bit error */
    if (prbs_inst < COREOTN_FO1_PRBS)
    {
        coreotn_fmf_field_PRBS_INS_DEFECT_set(NULL, coreotn_handle, prbs_inst, chnl, insert_err);

        

        
        if (insert_err == 1)
        {
            coreotn_fmf_field_PRBS_INS_DEFECT_set(NULL, coreotn_handle, prbs_inst, chnl, 0);
        }    

        /*coreotn_fmf_lfield_range_PRBS_INS_DEFECT_set(NULL, coreotn_handle, prbs_inst, chnl, chnl, insert_err);*/
    }
    else {
        coreotn_fo_field_PRBS_INS_DEFECT_set(NULL, coreotn_handle, prbs_inst-2, chnl, insert_err);
        
        if (insert_err == 1)
        {
            coreotn_fo_field_PRBS_INS_DEFECT_set(NULL, coreotn_handle, prbs_inst-2, chnl, 0);  
        }              
        /*coreotn_fo_lfield_range_PRBS_INS_DEFECT_set(NULL, coreotn_handle, prbs_inst-2, chnl, chnl, insert_err);*/
    }
   
    PMC_RETURN(ret_val);    
} /* coreotn_prbs_chnl_bit_err_inject */

/*******************************************************************************
*  coreotn_prbs_chnl_defect_cnt_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retreives defect count for the PRBS channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   prbs_inst           - Enum for PRBS instance. See coreotn_prbs_inst_t.
*   chnl                - channel ID to be configured. 
*
* OUTPUTS:
*   defect_cnt          - defect count for the given PRBS channel.
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_prbs_chnl_defect_cnt_get(coreotn_handle_t *coreotn_handle,
                                                  coreotn_prbs_inst_t prbs_inst, 
                                                  UINT32 chnl, UINT32 *defect_cnt)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    
    PMC_ENTRY();
    
    /* argument checking */
    if (chnl > 11)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }
    
    if (prbs_inst < COREOTN_FO1_PRBS)
    {
        *defect_cnt = coreotn_fmf_field_PRBS_TSE_CHAN_REG_get(NULL, coreotn_handle, prbs_inst, chnl);
        /*coreotn_fmf_lfield_range_PRBS_TSE_CHAN_REG_get(NULL, coreotn_handle, prbs_inst, chnl, chnl);*/
    }
    else {
        *defect_cnt = coreotn_fo_field_PRBS_TSE_CHAN_REG_get(NULL, coreotn_handle, prbs_inst-2, chnl);
        /*coreotn_fo_lfield_range_PRBS_TSE_CHAN_REG_get(NULL, coreotn_handle, , chnl, chnl);*/
    }                                       
                                               
    PMC_RETURN(ret_val);    
} /* coreotn_prbs_chnl_defect_cnt_get */


/*******************************************************************************
* FUNCTION: coreotn_prbs_chnl_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the PRBS channel that is configured on a DCI channel.
*
*   Note. This only retrieves the PRBS monitor channel ID for the 
*   purpose of interrupt retrieval.  Use coreotn_prbs_mon_or_gen_chnl_get()
*   to get the channel id accociated with the generator/monitor.
*
* INPUTS:
*   coreotn_handle     - Pointer to coreotn handle
*   prbs_inst          - Enum for PRBS instance. See coreotn_prbs_inst_t.
*   dci_chnl           - DCI channel to check for PRBS
*
* OUTPUTS:
*   prbs_chnl          - PRBS channel that is assigned to DCI channel
*   prbs_chnl_valid    - Boolean to indicate if PRBS channel is valid
*
* RETURNS:
*   PMC_SUCCESS     - 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_prbs_chnl_get(coreotn_handle_t    *coreotn_handle,
                                       coreotn_prbs_inst_t  prbs_inst,
                                       UINT32               dci_chnl,
                                       UINT32              *prbs_chnl,
                                       BOOL                *prbs_chnl_valid)
{
    PMC_ERROR       result = PMC_SUCCESS;
    UINT32          i;

    PMC_ENTRY();

    *prbs_chnl_valid = FALSE;

    /* Range Checking */
    /* FO1 PRBS is internal only */
    if ((COREOTN_FO1_PRBS == prbs_inst) || (prbs_inst >= LAST_COREOTN_PRBS_INST))
    {
        /* Returns prbs_chnl_valid = FALSE */
        PMC_RETURN(result);   
    }
    

    for (i = 0; i < COREOTN_PRBS_NUM_CHNL; i++)
    {
        if (COREOTN_PRBS_MON_CHNL_GET(coreotn_handle, prbs_inst, i) == dci_chnl)
        {
            *prbs_chnl_valid = TRUE;
            *prbs_chnl = i;
            PMC_RETURN(result);
        }
    } /* end for */

    PMC_RETURN(result);
} /* coreotn_prbs_chnl_get */


/*******************************************************************************
* FUNCTION: coreotn_prbs_mon_or_gen_chnl_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the PRBS channel that is configured on a DCI channel.
*
*   Note. This only retrieves the PRBS monitor channel ID (used for
*   interrupts).
*
* INPUTS:
*   coreotn_handle     - Pointer to coreotn handle
*   prbs_inst          - Enum for PRBS instance. See coreotn_prbs_inst_t.
*   dci_chnl           - DCI channel to check for PRBS
*
* OUTPUTS:
*   prbs_chnl          - PRBS channel that is assigned to DCI channel
*   prbs_chnl_valid    - Boolean to indicate if PRBS channel is valid
*
* RETURNS:
*   PMC_SUCCESS     - 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_prbs_mon_or_gen_chnl_get(coreotn_handle_t    *coreotn_handle,
                                                  coreotn_prbs_inst_t  prbs_inst,
                                                  UINT32               dci_chnl,
                                                  UINT32              *prbs_chnl,
                                                  BOOL                *prbs_chnl_valid)
{
    PMC_ERROR       result = PMC_SUCCESS;
    UINT32          i;
    UINT32 prbs_dci_chnl;

    PMC_ENTRY();

    *prbs_chnl_valid = FALSE;

    /* Range Checking */
    /* FO1 PRBS is internal only */
    if ((COREOTN_FO1_PRBS == prbs_inst) || (prbs_inst >= LAST_COREOTN_PRBS_INST))
    {
        /* Returns prbs_chnl_valid = FALSE */
        PMC_RETURN(result);   
    }
    

    for (i = 0; i < COREOTN_PRBS_NUM_CHNL; i++)
    {
        if (prbs_inst < COREOTN_FO1_PRBS)
        {
              prbs_dci_chnl = coreotn_fmf_field_PRBS_CHID_get(NULL, coreotn_handle, prbs_inst, i); 
        } 
        else 
        {
              prbs_dci_chnl = coreotn_fo_field_PRBS_CHID_get(NULL, coreotn_handle, prbs_inst-2, i); 
        }

        if (prbs_dci_chnl == dci_chnl)
        {
            *prbs_chnl_valid = TRUE;
            *prbs_chnl = i;
            PMC_RETURN(result);
        }
    } /* end for */

    PMC_RETURN(result);
} /* coreotn_prbs_mon_or_gen_chnl_get */


/*******************************************************************************
* FUNCTION: coreotn_prbs_chnl_prov_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the provision state of PRBS generator.  
*
* INPUTS:
*   coreotn_handle     - Pointer to coreotn handle
*   prbs_inst          - Enum for PRBS instance. See coreotn_prbs_inst_t.
*   prbs_chnl          - PRBS channel ID
*
* OUTPUTS:
*   prbs_gen_enbl      - Boolean to indicate if PRBS generator is enabled
*
* RETURNS:
*   PMC_SUCCESS     - 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_prbs_chnl_prov_get(coreotn_handle_t    *coreotn_handle,
                                            coreotn_prbs_inst_t  prbs_inst,
                                            UINT32               prbs_chnl,
                                            BOOL8                *prbs_gen_enbl)
{
    PMC_ERROR       result = PMC_SUCCESS;
    UINT32          prbs_gen_en;

    PMC_ENTRY();

    if (prbs_inst < COREOTN_FO1_PRBS)
    {
        prbs_gen_en = coreotn_fmf_field_PRBS_GEN_EN_get(NULL, coreotn_handle, prbs_inst, prbs_chnl);            
    } else 
    {
        prbs_gen_en = coreotn_fo_field_PRBS_GEN_EN_get(NULL, coreotn_handle, prbs_inst-2, prbs_chnl);            
    }  
    
    *prbs_gen_enbl = (prbs_gen_en == 1)? TRUE:FALSE;

    PMC_RETURN(result);
} /* coreotn_prbs_chnl_prov_get */


/*******************************************************************************
*  coreotn_mo_chnl_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retreives defect count for the PRBS channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   mo_channel          - MO channel ID
*                         Valid range: 0 - 95
*   direction           - direction of the channel
*                         0: TX
*                         1: RX
*
* OUTPUTS:
*   chnl_state          - MO channel state.
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_mo_chnl_state_get(coreotn_handle_t *coreotn_handle,
                                           UINT32 mo_channel,
                                           UINT32 direction, 
                                           coreotn_chnl_state_t *chnl_state)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;

    PMC_ENTRY();    
    
    *chnl_state = (direction == 0)?
                  coreotn_handle->var.tx_mo_chnl_ctxt[mo_channel].chnl_state
                  :coreotn_handle->var.rx_mo_chnl_ctxt[mo_channel].chnl_state;             
    
    PMC_RETURN(ret_val);
} /* coreotn_mo_chnl_state_get */ 

/*******************************************************************************
*  coreotn_oduksw_sifd_path_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retreives defect count for the PRBS channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   init_operation      - Enum for COREOTN initialization operation.  
*                         See coreotn_init_operation_t.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_sifd_path_cfg(coreotn_handle_t *coreotn_handle,
                                              coreotn_init_operation_t init_operation)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();
   
    /* if SYSOTN is used */ 
    if (init_operation  == COREOTN_SS_SYSOTN_MODE || init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE) 
    {

        /* This is not in the best spot.  Need to program RFRM96 to listen to
           XOFF for generating nominal AIS replacement */
        coreotn_fmf_field_NORM_RATE_SELECT_set(NULL, coreotn_handle, 0, 1);

        /* line interface needs to select CKCTL from the MPMO in COREOTN_CTL */
        coreotn_ctl_field_CKCTL_CTRL_set(NULL, coreotn_handle, 1);
        
        coreotn_ctl_field_SIFD1_MUX_CTRL_set(NULL, coreotn_handle, 1);
        coreotn_ctl_field_SIFD1_SEL_CTRL_set(NULL, coreotn_handle, 1);
    }
    /* directs DPI to SIFD if SYSOTN not in use */
    else {
        coreotn_ctl_field_SIFD1_MUX_CTRL_set(NULL, coreotn_handle, 0);
        coreotn_ctl_field_SIFD1_SEL_CTRL_set(NULL, coreotn_handle, 0);
    }
    
    PMC_RETURN(result);
    
} /* coreotn_oduksw_sifd_path_cfg */
  
/*******************************************************************************
*  coreotn_oduksw_num_blocks_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Retrieves the number of memory blocks used by the ODUk switch for a given output port and channel
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   output_port         - output port of the oduk switch
*   output_chnl_id      - output port of the oduk switch
*
* OUTPUTS:
*   *num_current_blocks - number of PMPM blocks used by the oduk switch
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_num_blocks_get(coreotn_handle_t *coreotn_handle,
                                               UINT32 output_port,
                                               UINT32 output_chnl_id,
                                               UINT32 *num_current_blocks)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 p_egress_mux_input_port;
    UINT32 p_rd_channel_id;
    UINT32 p_rd_queue_id;

    PMC_ENTRY();
    
    result = cpb_dcs_egress_dpi_chnl_source_get(coreotn_handle->oduksw_handle, 
                                                output_port, output_chnl_id,
                                                &p_egress_mux_input_port, 
                                                &p_rd_channel_id, 
                                                &p_rd_queue_id);
    
    /* get number of blocks in ODUKSW */
    if (PMC_SUCCESS == result)
    {
        /* p_egress_mux_input_port -> pop_port_id
        ** p_rd_queue_id -> read_qid 
        */   
        result = cpb_queue_num_block_get(coreotn_handle->oduksw_handle,
                                         p_egress_mux_input_port, p_rd_queue_id,
                                         num_current_blocks);
    }  
   
    PMC_RETURN(result);
    
} /* coreotn_oduksw_num_blocks_get */
 
/*******************************************************************************
*  coreotn_mpmo_ckctl_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configure MPMO clock control ports for specified MPMO instance in COREOTN.
*
* INPUTS:
*   *coreotn_handle   - pointer to COREOTN handle instance
*   mpmo_instance     - MPMO instance in COREOTN. See coreotn_mpmo_inst_t
*   ckctl_port        - clock control port number (0-25): \n
*                       Ports 0--11 are line side 10G SERDES. \n
*                       Ports 12--13 are line side 2.5G SERDES. \n
*                       Ports 14--25 are system side 10G SERDES. \n
*   chnl              - channel to map to the port specified by ckctl_port.
*   enable            - enables/disables CKCTL output
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_mpmo_ckctl_cfg(coreotn_handle_t *coreotn_handle,
                                        coreotn_mpmo_inst_t mpmo_instance,
                                        UINT32 ckctl_port, 
                                        UINT32 chnl,
                                        BOOL enable)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    
    PMC_ENTRY();
    
    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(mpmo_instance <= COREOTN_MPMO_CORECTL, COREOTN_ERR_INVALID_ARG, 0, 0);
    
    switch(mpmo_instance)
    {
    case COREOTN_MPMO_TO_COREOTN:
        ret_val = mpmo_ckctl_cfg(coreotn_handle->mpmo_fo1_handle, ckctl_port, chnl, enable);
        break;
    case COREOTN_MPMO_TO_MAPOTN:
        ret_val = mpmo_ckctl_cfg(coreotn_handle->mpmo_fo2_handle, ckctl_port, chnl, enable);
        break;
    case COREOTN_MPMO_CORECTL:
        ret_val = mpmo_ckctl_cfg(coreotn_handle->mpmo_core_ctl_handle, ckctl_port, chnl, enable);
        break;
    default:
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }


    PMC_RETURN(ret_val);

} /* coreotn_mpmo_ckctl_cfg */

/*******************************************************************************
*  coreotn_mpmo_data_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Gets MPMO packet size and packet period information for a channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   mpmo_instance       - MPMO instance in COREOTN. See coreotn_mpmo_inst_t
*   chnl                - channel ID to be configured Valid range: 0 to 95
*   pkt_size_ptr        - pointer to configured packet size
*   pkt_per_int_ptr     - pointer to configured integer portion of packet period
*   pkt_per_n_ptr       - pointer to configured numerator of packet period 
*                         fraction
*   pkt_per_d_ptr       - pointer to configured denominator of packet period 
*                         fraction
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_mpmo_data_get(coreotn_handle_t *coreotn_handle,
                                       coreotn_mpmo_inst_t mpmo_instance,
                                       UINT32 chnl,
                                       UINT32 *pkt_size_ptr,
                                       UINT32 *pkt_per_int_ptr,
                                       UINT32 *pkt_per_n_ptr,
                                       UINT32 *pkt_per_d_ptr)
{   
    /* Variable declaration */
    UINT32 ps_ptr; 
    UINT32 pp_int_ptr;  
    UINT32 pp_n_ptr;    
    UINT32 pp_d_ptr;  
    PMC_ERROR ret_val = PMC_SUCCESS;
        
    PMC_ENTRY();
    
    switch(mpmo_instance)
    {
    case COREOTN_MPMO_TO_COREOTN:
        ret_val = mpmo_pkt_period_var_get(coreotn_handle->mpmo_fo1_handle,chnl,
                                          &ps_ptr,&pp_int_ptr,&pp_n_ptr,&pp_d_ptr);
        break;
    case COREOTN_MPMO_TO_MAPOTN:
        ret_val = mpmo_pkt_period_var_get(coreotn_handle->mpmo_fo2_handle,chnl,
                                          &ps_ptr,&pp_int_ptr,&pp_n_ptr,&pp_d_ptr);
        break;
    case COREOTN_MPMO_CORECTL:
        ret_val = mpmo_pkt_period_var_get(coreotn_handle->mpmo_core_ctl_handle,chnl,
                                          &ps_ptr,&pp_int_ptr,&pp_n_ptr,&pp_d_ptr);
        break;
    default:
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }
        
    *pkt_size_ptr = ps_ptr; 
    *pkt_per_int_ptr = pp_int_ptr;                         
    *pkt_per_n_ptr = pp_n_ptr;
    *pkt_per_d_ptr = pp_d_ptr;
    
    PMC_RETURN(ret_val);
    
} /* coreotn_mpmo_data_get */


/*******************************************************************************
* coreotn_start_state_test
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function identifies if any resources are provisioned against the 
*   COREOTN 
*
* INPUTS:
*   *coreotn_handle      - pointer to COROTN handle instance to be operated on
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL coreotn_start_state_test(coreotn_handle_t *coreotn_handle)
{
    UINT32 itr;
    
    PMC_ENTRY();
        
    if (coreotn_odukp_start_state_test(coreotn_handle) == FALSE)
    {
        PMC_RETURN(FALSE);
    }
    if (coreotn_stg4_start_state_test(coreotn_handle) == FALSE)
    {
        PMC_RETURN(FALSE);
    }
    if (coreotn_oduksw_start_state_test(coreotn_handle) == FALSE)
    {
        PMC_RETURN(FALSE);
    }
    /* RCP blocks */
    if (odu_rcp_start_state_test(coreotn_handle->odu_rcp_handle,ODU_RCP_DI_INST) == FALSE)
    {
        PMC_RETURN(FALSE);
    }
    if (odu_rcp_start_state_test(coreotn_handle->odu_rcp_handle,ODU_RCP_RI_INST) == FALSE)
    {
        PMC_RETURN(FALSE);
    }    
    /* OHP ports */
    for (itr = 0; itr < 3; itr++)
    {
        if (odu_ohp_start_state_test(coreotn_handle->odu_ohp_handle[itr]) == FALSE)
        {
            PMC_RETURN(FALSE);
        } 
    }    

    PMC_RETURN(TRUE);    
} /* coreotn_start_state_test */

/*******************************************************************************
* coreotn_oduksw_port_chnl_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function identifies if any resources are provisioned against the 
*   COREOTN 
*
* INPUTS:
*   *coreotn_handle     - pointer to COROTN handle instance to be operated on
*   chnl_id             - channel ID
*                         Valid range: 0 -- 95
*   direction           - direction of the channel
*                         0 -- TX
*                         1 -- RX
*   port_type           - ODUKSW port type that the channel is destined to.
*                         See util_global_oduk_port_t.
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC coreotn_chnl_state_t coreotn_oduksw_port_chnl_state_get(coreotn_handle_t *coreotn_handle,
                                                               UINT32 chnl_id,
                                                               UINT32 direction,
                                                               util_global_oduk_port_t port_type)
{
    coreotn_chnl_state_t chnl_state; 
    
    PMC_ENTRY();
    
    if (port_type != UTIL_GLOBAL_ODUK_PORT_MAPOTN)
    {
        if (direction == 0)
        {
            chnl_state = coreotn_handle->var.tx_oduksw_chnl_ctxt[port_type][chnl_id].state;
        }
        else {
            chnl_state = coreotn_handle->var.rx_oduksw_chnl_ctxt[port_type][chnl_id].state;
        }
    }
    else {
        if (direction == 0)
        {
            chnl_state = (coreotn_handle->var.tx_stg4_chnl_prov[chnl_id] == TRUE)? COREOTN_CHNL_OPERATIONAL:COREOTN_CHNL_START;
        }
        else {
            chnl_state = (coreotn_handle->var.rx_stg4_chnl_prov[chnl_id] == TRUE)? COREOTN_CHNL_OPERATIONAL:COREOTN_CHNL_START; 
        }
    }
            
    
    PMC_RETURN(chnl_state);
} /* coreotn_oduksw_port_chnl_state_get */


/*******************************************************************************
* coreotn_rx_mo_chnl_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function deactivates the channelized MO from FMF2.
*
* INPUTS:
*   *coreotn_handle     - pointer to COROTN handle instance to be operated on
*   chnl_id             - channel ID
*                         Valid range: 0 -- 95
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_mo_chnl_deactivate(coreotn_handle_t *coreotn_handle,
                                               UINT32 chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* condition for this function:
    ** 1. LO channel with the same ID does not exist in the system
    ** 2. MO channel is in START state
    */
    if ((coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_START ||
         coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_DEPROV_PENDING)
        && (coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_START
         || coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_DEPROV_PENDING))
    {
        /* set PASSTHRU = 1 */
        result = odtu_dmx_chnl_init(coreotn_handle->odtu_dmx2_handle, chnl_id, (odtu_dmx_chnl_mode_t)0);

        if (PMC_SUCCESS == result)
        {
            result = odtu_dmx_ho_chnl_deactivate(coreotn_handle->odtu_dmx2_handle,
                                                 chnl_id);
        }
    }

    PMC_RETURN(result);

} /* coreotn_rx_mo_chnl_deactivate */


/*******************************************************************************
*  coreotn_tx_lo_chnl_ids_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API configures the offline page of all LO channels that have recently
*   been provisioned on the active page.
* 
*   This API is only used when coreotn_odu_chnl_prov_mode_set() is called with
*   COREOTN_ODU_CHNL_PROV_ALL. When this API is called, only the new channels
*   being added are reconfigured on the offline page without disruption
*   to the neighboring LO channels within the same HO or MO channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   mux_stage           - instance of multiplexing stage\n
*                         - 0 -- MO to HO multiplexing (LO to HO multiplexing for
*                                1 stage multiplexing)\n
*                         - 1 -- LO to MO multiplexing\n
*   ho_chnl_id          - HO channel ID that this LO belongs to.
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   *new_lo_chnl_ids    - pointer to storage for an array of newly added
*                         LO channel IDs
*   *num_new_lo         - number of new LO channels being added
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tx_lo_chnl_ids_get(coreotn_handle_t *coreotn_handle,
                                            coreotn_mux_stage_t mux_stage,
                                            UINT32 ho_chnl_id,
                                            UINT32 *new_lo_chnl_ids,
                                            UINT32 *num_new_lo)
{
    PMC_ENTRY();
    
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 lo_chnl_ids[96];
    UINT8 local_num_lo_chnls;
    UINT8 user_num_lo_chnls;
    UINT32 i;
    UINT32 ultimate_ho_chnl_id = 0x7F;
    odtu_mux_handle_t *odtu_mux_handle_ptr = NULL;
    UINT32 num_new_chnls = 0;
        
    /* initialize the output array */
    for (i = 0; i < 96; i++)
    {
        lo_chnl_ids[i] = 0x7F;
    }
    
    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE
            || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
        {
            odtu_mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
        }
        else {
            odtu_mux_handle_ptr = coreotn_handle->odtu_mux1_handle;
        }
        /* HO-MO */
        result = sts_sw_lo_chnl_ids_get(odtu_mux_handle_ptr->sts_sw_handle, 
                                        ho_chnl_id, lo_chnl_ids);
 
        /* retrieve information to configure offline page */
        local_num_lo_chnls = coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt;
        user_num_lo_chnls = coreotn_handle->var.mux_profile[ho_chnl_id].num_mo_chnls;  
        
        if (coreotn_handle->var.mux_profile[ho_chnl_id].num_lo_chnls == 0
            || user_num_lo_chnls != 0xFF)
        {
            if (local_num_lo_chnls != user_num_lo_chnls)
            {
                PMC_RETURN(COREOTN_ERR_INCORRECT_NUM_LO_CHNL);
            }
        }

        for (i = 0; i < local_num_lo_chnls; i++)
        {             
            /* filter through all LO channel list and apply the offline update 
            ** to only the channels that are in EQUIPPED state
            */  
            if (coreotn_handle->var.tx_mo_chnl_ctxt[lo_chnl_ids[i]].chnl_state == COREOTN_CHNL_EQUIPPED)
            {     
                new_lo_chnl_ids[num_new_chnls] = lo_chnl_ids[i];
                num_new_chnls++;
            }
        }

        *num_new_lo = num_new_chnls;
    }
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        /* HO-MO */
        result = sts_sw_lo_chnl_ids_get(coreotn_handle->odtu_mux2_handle->sts_sw_handle, 
                                        ho_chnl_id, lo_chnl_ids);
 
        /* retrieve information to configure offline page */
        local_num_lo_chnls = coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt;
        
        odtu_mux_ho_ch_id_get(coreotn_handle->odtu_mux1_handle,
                              ho_chnl_id, &ultimate_ho_chnl_id);
                              
        if (ultimate_ho_chnl_id >= COREOTN_MAX_NUM_HO_CHNL)
        {
            result = COREOTN_ERR_INVALID_ARG;
        }
        
        if (PMC_SUCCESS == result)
        {                                  
            user_num_lo_chnls = coreotn_handle->var.mux_profile[ultimate_ho_chnl_id].num_lo_chnls;  
        
            if (user_num_lo_chnls != 0xFF)
            {
                if (local_num_lo_chnls != user_num_lo_chnls)
                {
                    PMC_RETURN(COREOTN_ERR_INCORRECT_NUM_LO_CHNL);
                }
            }
        }

        for (i = 0; i < local_num_lo_chnls; i++)
        {         
            /* filter through all LO channel list and apply the offline update 
            ** to only the channels that are in EQUIPPED state
            */  
            if (coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_ids[i]].chnl_state == COREOTN_CHNL_EQUIPPED)
            { 
                new_lo_chnl_ids[num_new_chnls] = lo_chnl_ids[i];
                num_new_chnls++;
            }
        }

        *num_new_lo = num_new_chnls;
    }


    PMC_RETURN(result);
} /* coreotn_tx_lo_chnl_ids_get */


/*******************************************************************************
*  coreotn_rx_lo_chnl_ids_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API configures the offline page of all LO channels that have recently
*   been provisioned on the active page.
* 
*   This API is only used when coreotn_odu_chnl_prov_mode_set() is called with
*   COREOTN_ODU_CHNL_PROV_ALL. When this API is called, only the new channels
*   being added are reconfigured on the offline page without disruption
*   to the neighboring LO channels within the same HO or MO channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   mux_stage           - instance of multiplexing stage\n
*                         - 0 -- MO to HO multiplexing (LO to HO multiplexing for
*                                1 stage multiplexing)\n
*                         - 1 -- LO to MO multiplexing\n
*   ho_chnl_id          - HO channel ID that this LO belongs to.
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   *new_lo_chnl_ids    - pointer to storage for an array of newly added
*                         LO channel IDs
*   *num_new_lo         - number of new LO channels being added
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_lo_chnl_ids_get(coreotn_handle_t *coreotn_handle,
                                            coreotn_mux_stage_t mux_stage,
                                            UINT32 ho_chnl_id,
                                            UINT32 *new_lo_chnl_ids,
                                            UINT32 *num_new_lo)
{
    PMC_ENTRY();
    
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 lo_chnl_ids[96];
    UINT8 local_num_lo_chnls;
    UINT8 user_num_lo_chnls;
    UINT32 i;
    UINT32 ultimate_ho_chnl_id = 0x7F;
    odtu_dmx_handle_t *odtu_dmx_handle_ptr = NULL;
    UINT32 num_new_chnls = 0;
        
    /* initialize the output array */
    for (i = 0; i < 96; i++)
    {
        lo_chnl_ids[i] = 0x7F;
    }
    
    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE
            || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
        {
            odtu_dmx_handle_ptr = coreotn_handle->odtu_dmx2_handle;
        }
        else {
            odtu_dmx_handle_ptr = coreotn_handle->odtu_dmx1_handle;
        }

        /* HO-MO */
        result = sts_sw_lo_chnl_ids_get(odtu_dmx_handle_ptr->sts_sw_handle, 
                                        ho_chnl_id, lo_chnl_ids);
 
        /* retrieve information to configure offline page */
        local_num_lo_chnls = coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt;
        user_num_lo_chnls = coreotn_handle->var.mux_profile[ho_chnl_id].num_mo_chnls;  
        
        if (coreotn_handle->var.mux_profile[ho_chnl_id].num_lo_chnls == 0
            || user_num_lo_chnls != 0xFF)
        {
            if (local_num_lo_chnls != user_num_lo_chnls)
            {
                PMC_RETURN(COREOTN_ERR_INCORRECT_NUM_LO_CHNL);
            }
        }

        for (i = 0; i < local_num_lo_chnls; i++)
        {             
            /* filter through all LO channel list and apply the offline update 
            ** to only the channels that are in EQUIPPED state
            */  
            if (coreotn_handle->var.rx_mo_chnl_ctxt[lo_chnl_ids[i]].chnl_state == COREOTN_CHNL_EQUIPPED)
            {     
                new_lo_chnl_ids[num_new_chnls] = lo_chnl_ids[i];
                num_new_chnls++;
            }
        }

        *num_new_lo = num_new_chnls;
    }
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        /* HO-MO */
        result = sts_sw_lo_chnl_ids_get(coreotn_handle->odtu_dmx2_handle->sts_sw_handle, 
                                        ho_chnl_id, lo_chnl_ids);
 
        /* retrieve information to configure offline page */
        local_num_lo_chnls = coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt;
        
        odtu_dmx_ho_ch_id_get(coreotn_handle->odtu_dmx1_handle,
                              ho_chnl_id, &ultimate_ho_chnl_id);
        
        if (ultimate_ho_chnl_id >= COREOTN_MAX_NUM_HO_CHNL)
        {
            result = COREOTN_ERR_INVALID_ARG;
        }
         
        if (PMC_SUCCESS == result)
        {                        
            user_num_lo_chnls = coreotn_handle->var.mux_profile[ultimate_ho_chnl_id].num_lo_chnls;  
        
            if (user_num_lo_chnls != 0xFF)
            {
                if (local_num_lo_chnls != user_num_lo_chnls)
                {
                    PMC_RETURN(COREOTN_ERR_INCORRECT_NUM_LO_CHNL);
                }
            }
        }

        for (i = 0; i < local_num_lo_chnls; i++)
        {         
            /* filter through all LO channel list and apply the offline update 
            ** to only the channels that are in EQUIPPED state
            */  
            if (coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_ids[i]].chnl_state == COREOTN_CHNL_EQUIPPED)
            { 
                new_lo_chnl_ids[num_new_chnls] = lo_chnl_ids[i];
                num_new_chnls++;
            }
        }

        *num_new_lo = num_new_chnls;
    }


    PMC_RETURN(result);
} /* coreotn_rx_lo_chnl_ids_get */

    
/*
** PRIVATE APIs
*/

/*******************************************************************************
* coreotn_db_ho_entry_activate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method to activated db entries associated to an HO
*   channel without any muxing stage.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   db_id               - Enum for DB instance. See util_gen_db_id_t.
*   chnl_id             - HO Channel ID
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_db_ho_entry_activate(coreotn_handle_t *coreotn_handle,
                                               util_gen_db_id_t db_id, UINT32 chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;    
    UINT32 db_handle = 0;
    
    line_core_otn_db_key       key;
    line_core_otn_db_rec       new_rec;
    UINT32                     num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;
    line_core_otn_db_query_res temp_result;
    UINT32 i ;
    
    PMC_ENTRY();
    
    if (db_id == UTIL_GEN_DB_LINE_CORE_OTN_RX_DB)
    {
        db_handle = coreotn_handle->cfg.rx_db_handle;
    }
    else if (db_id == UTIL_GEN_DB_LINE_CORE_OTN_TX_DB)
    {
        db_handle = coreotn_handle->cfg.tx_db_handle;
    }        

    key.calendar_entry = DO_NOT_USE_KEY;
    key.ho_channel = chnl_id;
    key.mo_channel = DO_NOT_USE_KEY;
    key.lo_channel = DO_NOT_USE_KEY;
    key.trib_slot = DO_NOT_USE_KEY;

    num_of_recs = gen_db_query(&(coreotn_handle->base),
                               db_id, db_handle, (void *)&key, (void **)&q_result);
    
    if (num_of_recs == 0)
    {
        PMC_RETURN(COREOTN_ERR_DB_ENTRY_NOT_FOUND);
    }
    temp_result = *q_result;
                                                
    /* update record to free tributary slots for the HO channel */
    for (i = 0; i < num_of_recs; i++)
    {
        new_rec = *temp_result.p_recs[i];
        new_rec.calendar_entry = temp_result.p_recs[i]->calendar_entry;
        new_rec.ts_port_ho_mo    = 0;
        new_rec.cal_entry_status = 0;

        /* send back the result to the DB */ 
        result = gen_db_update_record(&(coreotn_handle->base),
                                      db_id, db_handle, &new_rec);
    }      

    PMC_RETURN(result);

} /* coreotn_db_ho_entry_activate */

/*******************************************************************************
* coreotn_ctxt_reg_recover
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Recover a coreotn_recover_var_t context and energy state from register space.
*
*  This function is used by coreotn_handle_restart_init. It also recovers 
*  volatile information from coreotn_var_t context.
*  
*  This function return an error when something is incoherent in the register 
*  space. In such case, the only solution for crash restart is to reset the 
*  subsystem
* 
* INPUTS:
*   *coreotn_handle        - pointer to MAPOTN handle instance to be operated on
*   top_energy_state_reg  - energy state from top-level
*   *restart_init_cfg_ptr       - pointer to restart init config
*
* OUTPUTS:
*   *coreotn_var_reg          - A partial coreotn_var_t context + additional
*                              information to facilitate audit phase
*
* RETURNS:
*  PMC_SUCCESS: 
*   recovery is a success 
*  COREOTN_ERR_CONTEXT_COMMUN_RES_ENERGY_INCOHERENT: 
*   Communal ressource energy states are incoherent. top will have
*    to shutdown the subsystem
*  COREOTN_ERR_CONTEXT_REG_INCOHERENT:
*   Register conetxt is incoherent. top will have
*    to shutdown the subsystem
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_ctxt_reg_recover(coreotn_handle_t *coreotn_handle,
                                           pmc_energy_state_t top_energy_state_reg,     
                                           util_global_restart_init_cfg_t *restart_init_cfg_ptr,
                                           coreotn_recover_var_t *coreotn_var_reg)
{
    UINT32 cal_entry[96];
    UINT32 num_cal_entries;
    PMC_ERROR rc = PMC_SUCCESS;
    UINT32 dci_chnl = 0;
    PMC_ENTRY();

    /* /\* GET SCBS3 handle *\/ */
    /* fo2_mpma_scbs3_handle   = mpma_scbs3_handle_get(coreotn_handle->mpma_handle);   */
    /* fo2_mpmo_scbs3_handle   = mpmo_scbs3_handle_get(coreotn_handle->mpmo_handle); */
    /* fo1_mpma_scbs3_handle   = mpma_scbs3_handle_get(coreotn_handle->mpma_handle);   */
    /* fo1_mpmo_scbs3_handle   = mpmo_scbs3_handle_get(coreotn_handle->mpmo_handle); */
    /* ctl_mpma_scbs3_handle   = mpma_scbs3_handle_get(coreotn_handle->mpma_handle);   */
    /* ctl_mpmo_scbs3_handle   = mpmo_scbs3_handle_get(coreotn_handle->mpmo_handle); */
    
    /* 
       create a register context 
    */
    /* start from a clean context */
    coreotn_var_default_init(coreotn_handle,&coreotn_var_reg->var); 
    
    /* this information is coming from top-level register */
    coreotn_var_reg->var.coreotn_start_state = (top_energy_state_reg == PMC_ENERGY_STATE_RESET);
    /* the init_operation field is correct since it is set during static configuration phase
       and it cannot be modified afterward */
    coreotn_var_reg->var.init_operation      = coreotn_handle->var.init_operation;
    coreotn_var_reg->var.ilkn_if_enable      = coreotn_handle->var.ilkn_if_enable;

    /* 
       IF start_state is TRUE, the susbystem is completly in power down
       coreotn_register_var is completed (anyway, digi-layer should not call use with PMC_ENERGY_STATE_RESET)
    */
    if (FALSE == coreotn_var_reg->var.coreotn_start_state)
    {
        /* At this point OCPB is a clean state, get its state*/
        cpb_connect_state_get(coreotn_handle->oduksw_handle, &coreotn_var_reg->ocpb_connect);

        /* REGISTER:: MAPOTN SS is not in power down */
        
        /* get energy state from mapotn-top register */
        coreotn_energy_state_reg_get(coreotn_handle, 
                                     &coreotn_var_reg->energy_state_reg);
               
        /* check power coherency */
        rc = coreotn_energy_coherency_check(coreotn_handle, coreotn_var_reg);

        if (PMC_SUCCESS == rc)
        {
            /* restart MUX/DEMUX stages */

            PMC_ERROR rc_dmx1, rc_dmx2;
            odtu_dmx_var_t  *dmx1_var_clean = NULL;
            odtu_dmx_var_t  *dmx2_var_clean = NULL;
            odtu_dmx_recover_var_t *intermediate_recov_var_ptr = (odtu_dmx_recover_var_t *) PMC_CALLOC(sizeof(odtu_dmx_recover_var_t));
            dmx1_var_clean = (odtu_dmx_var_t*) PMC_CALLOC(sizeof(odtu_dmx_var_t));
            dmx2_var_clean = (odtu_dmx_var_t*) PMC_CALLOC(sizeof(odtu_dmx_var_t));
            
            rc_dmx1 = odtu_dmx_handle_restart_init(coreotn_handle->odtu_dmx1_handle,restart_init_cfg_ptr,ODTU_DMX_STG_ONE,
                                                   coreotn_var_reg->energy_state_reg.fmf1.odtu_dmx,
                                                   NULL,
                                                   dmx1_var_clean,
                                                   &coreotn_var_reg->dmx1);
            if(coreotn_var_reg->var.init_operation == COREOTN_SS_SYSOTN_MODE ||
               coreotn_var_reg->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
            {
                rc_dmx2 = odtu_dmx_handle_restart_init(coreotn_handle->odtu_dmx2_handle,restart_init_cfg_ptr, ODTU_DMX_STG_ONE,
                                                       coreotn_var_reg->energy_state_reg.fmf2.odtu_dmx,
                                                       NULL,
                                                       dmx2_var_clean,
                                                       &coreotn_var_reg->dmx2);                                
            } else 
            {                
                PMC_MEMCPY(intermediate_recov_var_ptr,&coreotn_var_reg->dmx1, sizeof(odtu_dmx_recover_var_t));
                PMC_MEMCPY(&intermediate_recov_var_ptr->var,dmx1_var_clean,sizeof(odtu_dmx_var_t));

                rc_dmx2 = odtu_dmx_handle_restart_init(coreotn_handle->odtu_dmx2_handle,restart_init_cfg_ptr, ODTU_DMX_STG_TWO,
                                                       coreotn_var_reg->energy_state_reg.fmf2.odtu_dmx,
                                                       intermediate_recov_var_ptr,
                                                       dmx2_var_clean,
                                                       &coreotn_var_reg->dmx2);
            }
            /* clean stage 2 first */
            if (rc_dmx2 != ODTU_DMX_ERR_CONTEXT_CLEANUP || restart_init_cfg_ptr->is_warm_restart == TRUE)
            {
                rc = rc_dmx2;
            }
            if (restart_init_cfg_ptr->is_warm_restart == FALSE &&
                coreotn_var_reg->energy_state_reg.fmf2.odtu_dmx == PMC_ENERGY_STATE_RUNNING)
            {
                /* 
                 * Cleanup 
                 *   - At the end, odtu_dmx_var_clean is the new context
                 *    - We keep OPERATIONAL channel defined in odtu_dmx_var_clean
                 *    - We clean (deactivate/deprov) all channels that are not OPERATIONAL
                 *       - they may have be partially provisionned
                 *    - We ajust power setting based on odtu_dmx_var_clean
                 */     
                rc = odtu_dmx_ctxt_cleanup(coreotn_handle->odtu_dmx2_handle,  
                                           &coreotn_var_reg->dmx2, 
                                           dmx2_var_clean);  
            }
            if (PMC_SUCCESS == rc && (rc_dmx1 != ODTU_DMX_ERR_CONTEXT_CLEANUP || restart_init_cfg_ptr->is_warm_restart == TRUE))
            {
                rc = rc_dmx1;
            }
            if ( restart_init_cfg_ptr->is_warm_restart == FALSE && 
                coreotn_var_reg->energy_state_reg.fmf1.odtu_dmx == PMC_ENERGY_STATE_RUNNING)
            {
                /* 
                 * Cleanup 
                 *   - At the end, odtu_dmx_var_clean is the new context
                 *    - We keep OPERATIONAL channel defined in odtu_dmx_var_clean
                 *    - We clean (deactivate/deprov) all channels that are not OPERATIONAL
                 *       - they may have be partially provisionned
                 *    - We ajust power setting based on odtu_dmx_var_clean
                 */     
                rc = odtu_dmx_ctxt_cleanup(coreotn_handle->odtu_dmx1_handle,  
                                           &coreotn_var_reg->dmx1, 
                                           dmx1_var_clean);               
            }
            
            /* 
               resync odtu_dmx_var_reg->var for the use at upper level 
            */
            PMC_MEMCPY(&coreotn_var_reg->dmx1.var,dmx1_var_clean,sizeof(odtu_dmx_var_t));
            PMC_MEMCPY(&coreotn_var_reg->dmx2.var,dmx2_var_clean,sizeof(odtu_dmx_var_t));
            PMC_FREE(&dmx1_var_clean);
            PMC_FREE(&dmx2_var_clean);
            PMC_FREE(&intermediate_recov_var_ptr);
        }
        
        if (PMC_SUCCESS == rc)
        {    
            odtu_mux_recover_var_t *intermediate_recov_var_ptr = (odtu_mux_recover_var_t *) PMC_CALLOC(sizeof(odtu_mux_recover_var_t ));

            rc = odtu_mux_handle_restart_init(coreotn_handle->odtu_mux1_handle,restart_init_cfg_ptr,ODTU_MUX_STG_ONE,
                                              coreotn_var_reg->energy_state_reg.fmf1.odtu_mux,
                                              NULL,
                                              &coreotn_var_reg->mux1);

            if (PMC_SUCCESS == rc)
            {    
                if(coreotn_var_reg->var.init_operation == COREOTN_SS_SYSOTN_MODE ||
                   coreotn_var_reg->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
                {
                    rc = odtu_mux_handle_restart_init(coreotn_handle->odtu_mux2_handle,restart_init_cfg_ptr, ODTU_MUX_STG_ONE,
                                                      coreotn_var_reg->energy_state_reg.fmf2.odtu_mux,
                                                      NULL,
                                                      &coreotn_var_reg->mux2);
                } else 
                {                
                    PMC_MEMCPY(intermediate_recov_var_ptr,&coreotn_var_reg->mux1, sizeof(odtu_mux_recover_var_t));
                    rc = odtu_mux_handle_restart_init(coreotn_handle->odtu_mux2_handle,restart_init_cfg_ptr, ODTU_MUX_STG_TWO,
                                                      coreotn_var_reg->energy_state_reg.fmf2.odtu_mux,
                                                      intermediate_recov_var_ptr,
                                                      &coreotn_var_reg->mux2);
                }
            }
            PMC_FREE(&intermediate_recov_var_ptr);
        }    
        
        
        /* recover ODUKSW*/
        if (PMC_SUCCESS == rc)
        {
            UINT32 port_itr, chnl_itr;
            UINT32 source_port, source_chnl;
            mpma_handle_t *mpma_handle;
            mpmo_handle_t *mpmo_handle;
            
            /* iterate over ports 
               RECOVER INPUT
            */
            for (port_itr = 0;port_itr < COREOTN_OCPB_NUM_PORT;port_itr++)
            {
                /* get proper handles */
                switch (port_itr)
                {
                case 0:
                    mpma_handle = NULL;    
                    if(coreotn_var_reg->var.init_operation == COREOTN_SS_SYSOTN_MODE ||
                       coreotn_var_reg->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
                    {
                        mpma_handle = coreotn_handle->mpma_core_ctl_handle;
                    } 
                    break;
                case 1:
                    mpma_handle = NULL;    
                    break;                    
                case 2:
                    mpma_handle = coreotn_handle->mpma_fo1_handle;                    
                    break;
                case 3:                    
                    mpma_handle = coreotn_handle->mpma_fo2_handle;
                    break;              
                default:
                    mpma_handle = NULL;
                    break;
                }
                for(chnl_itr = 0; chnl_itr < COREOTN_MAX_NUM_LO_CHNL;chnl_itr++)
                {
                    if (UTIL_GLOBAL_CHNL_OPERATIONAL == coreotn_var_reg->ocpb_connect.chnl[port_itr][chnl_itr].slv.state)
                    {                       
                        coreotn_var_reg->var.rx_oduksw_chnl_ctxt[port_itr][chnl_itr].state = COREOTN_CHNL_OPERATIONAL;                                                   
                    }
                }
            }

            /* 
               RECOVER OUTPUT
            */
            for (port_itr = 0;port_itr < COREOTN_OCPB_NUM_PORT;port_itr++)
            {
                /* get proper handles */
                switch (port_itr)
                {
                case 0:
                    mpmo_handle = NULL;
                    
                    if(coreotn_var_reg->var.init_operation == COREOTN_SS_SYSOTN_MODE ||
                       coreotn_var_reg->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
                    {
                        mpmo_handle = coreotn_handle->mpmo_core_ctl_handle;
                    }
                    break;
                case 1:
                    mpmo_handle = NULL;    
                    break;                    
                case 2:
                    mpmo_handle = coreotn_handle->mpmo_fo1_handle;                    
                    break;
                case 3:                    
                    mpmo_handle = coreotn_handle->mpmo_fo2_handle;
                    break;              
                default:
                    mpmo_handle = NULL;
                    break;
                }
                /* we do RX first, to set all OPERATIONAL state, the TX loop updated active counts */
                for(chnl_itr = 0; chnl_itr < COREOTN_MAX_NUM_LO_CHNL;chnl_itr++)
                {
                    if (UTIL_GLOBAL_CHNL_OPERATIONAL == coreotn_var_reg->ocpb_connect.chnl[port_itr][chnl_itr].mst.state)
                    {                                  
                        coreotn_var_reg->var.tx_oduksw_chnl_ctxt[port_itr][chnl_itr].state = COREOTN_CHNL_OPERATIONAL;  
                        source_port = coreotn_var_reg->ocpb_connect.chnl[port_itr][chnl_itr].mst.source_slv_port;
                        source_chnl = coreotn_var_reg->ocpb_connect.chnl[port_itr][chnl_itr].mst.source_slv_chnl;
                        if (COREOTN_CHNL_OPERATIONAL == coreotn_var_reg->var.rx_oduksw_chnl_ctxt[source_port][source_chnl].state)
                        {
                            coreotn_var_reg->var.rx_oduksw_chnl_ctxt[source_port][source_chnl].input_map_count   += 1;
                            coreotn_var_reg->var.rx_oduksw_chnl_ctxt[source_port][source_chnl].dest_active_count += 1;
                        }
                        
                    }
                }
            }            
        }

        /* recover STG4 */
        if (PMC_SUCCESS == rc && PMC_ENERGY_STATE_RUNNING == coreotn_var_reg->stg4_energy)
        {
            UINT32 tfrm_passthru[3],rfrm_passthru[3],rfrm_fau_passthru[3];
            UINT32 chnl_itr;
            /* get information from register space */
            odu_tfrm_passthru_get(coreotn_handle->odu_tfrm_stg4_handle,tfrm_passthru);
            odu_rfrm_passthru_get(coreotn_handle->odu_rfrm_stg4_handle,rfrm_passthru,rfrm_fau_passthru);
            for (chnl_itr = 0; chnl_itr < COREOTN_MAX_NUM_LO_CHNL;chnl_itr++)
            {
                if ( ((tfrm_passthru[chnl_itr/32] >> (chnl_itr %32)) & 0x1) == 0x0)
                {
                    /* check ODUKSC database */
                    (void) coreotn_db_cal_entries_get(coreotn_handle,FALSE,FALSE,chnl_itr,ODU_STRUCT_FRM_STG4,&cal_entry[0],&num_cal_entries);
                    if (num_cal_entries != 0)
                    {                       
                        coreotn_var_reg->var.tx_stg4_chnl_prov[chnl_itr] = TRUE;
                    }
                }
                /* check MPMA database */
                (void) coreotn_db_cal_entries_get(coreotn_handle,FALSE,TRUE,chnl_itr,ODU_STRUCT_FRM_STG4,&cal_entry[0],&num_cal_entries);
                if (num_cal_entries != 0)
                {
                    coreotn_var_reg->var.rx_stg4_chnl_prov[chnl_itr] = TRUE;
                }
                
            }     
        }
        
        /* recover data paths from MUX/DEMUX stages */
        if (PMC_SUCCESS == rc && PMC_ENERGY_STATE_RUNNING == coreotn_var_reg->odukp_energy)
        {
            UINT32 ho_chnl_itr, mo_chnl_itr, lo_chnl_itr;

            /* SYSOTN case */
            if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE ||
                coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
            {
                /* From LINEOTN */
                if (coreotn_var_reg->energy_state_reg.fmf1.rfrm96 == PMC_ENERGY_STATE_RUNNING &&
                    coreotn_var_reg->energy_state_reg.fmf1.tfrm96 == PMC_ENERGY_STATE_RUNNING && 
                    coreotn_var_reg->energy_state_reg.fmf1.rfrm12 == PMC_ENERGY_STATE_RUNNING &&
                    coreotn_var_reg->energy_state_reg.fmf1.tfrm12 == PMC_ENERGY_STATE_RUNNING)
                {
                    UINT32 rfrm_passthru[3],rfrm_fau_passthru[3];
                    UINT32 tfrm_passthru[3];
                    /* get information from register space */
                    odu_rfrm_passthru_get(coreotn_handle->odu_rfrm_stg1_handle,rfrm_passthru,rfrm_fau_passthru);
                    odu_tfrm_passthru_get(coreotn_handle->odu_tfrm_stg1_handle,tfrm_passthru);
                 

                    for (ho_chnl_itr = 0; ho_chnl_itr<COREOTN_MAX_NUM_HO_CHNL; ho_chnl_itr++)
                    {
                        if ( ((rfrm_passthru[ho_chnl_itr/32] >> (ho_chnl_itr %32)) & 0x1) == 0x0  && 
                             ((tfrm_passthru[ho_chnl_itr/32] >> (ho_chnl_itr %32)) & 0x1) == 0x0)
                        {
                            /* check MPMA database */
                            (void) coreotn_db_cal_entries_get(coreotn_handle,TRUE,TRUE,ho_chnl_itr,ODU_STRUCT_FRM_STG1,&cal_entry[0],&num_cal_entries);

                            if (num_cal_entries != 0)
                            {
                                coreotn_var_reg->var.sysapp_line_state[ho_chnl_itr] =  COREOTN_CHNL_OPERATIONAL;
                            }
                        }
                    }         
                }

                /* FROM SYSOTN */
                /* RX Side */
                if (coreotn_var_reg->energy_state_reg.fmf2.odtu_dmx == PMC_ENERGY_STATE_RESET && 
                    coreotn_var_reg->energy_state_reg.fmf2.rfrm12 == PMC_ENERGY_STATE_RUNNING)
                {
                    /* stage 2 is in power down, we use RFRM stage N to detect what is activated */
                    UINT32 rfrm_passthru[3],rfrm_fau_passthru[3];
                    /* get information from register space */
                    odu_rfrm_passthru_get(coreotn_handle->odu_rfrm_stgN_handle,rfrm_passthru,rfrm_fau_passthru);
                    for (ho_chnl_itr = 0; ho_chnl_itr<1; ho_chnl_itr++)
                    {
                        
                        if ( ((rfrm_passthru[ho_chnl_itr/32] >> (ho_chnl_itr %32)) & 0x1) == 0x0 )
                        {
                            /* check MPMA database */
                            (void) coreotn_db_cal_entries_get(coreotn_handle,FALSE,TRUE,ho_chnl_itr,ODU_STRUCT_FRM_STGN,&cal_entry[0],&num_cal_entries);
                            if (num_cal_entries != 0)
                            {
                                coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                                coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].payload_format = UTIL_GLOBAL_ODU_UNCHANNELIZED;
                                coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].chnls_prov_cnt     = 1;
                                coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt = 0;
                                coreotn_var_reg->var.rx_mo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;
                                coreotn_var_reg->var.rx_lo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;                        
                            }
                        }
                    }         
                } else 
                {
                    /* SYSOTN use STAGE_2 as HO stage */
                    for (ho_chnl_itr = 0; ho_chnl_itr<1; ho_chnl_itr++)
                    {
                        if (coreotn_var_reg->dmx2.var.ho_chnl_cfg[ho_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL)
                        {
                            coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                            coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].odu_container  = coreotn_var_reg->dmx2.var.ho_chnl_cfg[ho_chnl_itr].oduk_type;
                            coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].payload_format = coreotn_var_reg->dmx2.var.ho_chnl_cfg[ho_chnl_itr].ts_type;
                            coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].chnls_prov_cnt     = 1;
                            coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt = 0;
                            if (coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
                            {
                                coreotn_var_reg->var.rx_mo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;
                                coreotn_var_reg->var.rx_lo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;                        
                            } else 
                            {
                                coreotn_var_reg->var.rx_mo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_IN_PASSTHRU;
                                coreotn_var_reg->var.rx_lo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_IN_PASSTHRU;                        
                            }
                        }                   
                    }
                    /* MO channels */
                    for (mo_chnl_itr = 0; mo_chnl_itr<COREOTN_MAX_NUM_MO_CHNL; mo_chnl_itr++)
                    {
                        if (coreotn_var_reg->dmx2.var.lo_chnl_cfg[mo_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL)
                        {
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].odu_container  = coreotn_var_reg->dmx2.var.lo_chnl_cfg[mo_chnl_itr].ho_oduk_type;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].lo_odu_rate    = coreotn_var_reg->dmx2.var.lo_chnl_cfg[mo_chnl_itr].lo_oduk_type;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].odu_flex_rate    = coreotn_var_reg->dmx2.var.lo_chnl_cfg[mo_chnl_itr].num_ts;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].cbr_flex_rate    = 0;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].payload_format   = UTIL_GLOBAL_ODU_UNCHANNELIZED;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].mapping_mode     = (coreotn_mapping_type_t) coreotn_var_reg->dmx2.var.lo_chnl_cfg[mo_chnl_itr].mapping_mode;
                            PMC_MEMCPY(&coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].tribslot_mask[0],
                                       &coreotn_var_reg->dmx2.lo_chnl_extra[mo_chnl_itr].rx_tribslot_mask[0],sizeof(UINT32)*3) ;                                       
                        
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnls_prov_cnt      = 1;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].sub_chnls_prov_cnt  = 0;
                        
                            /* update associated HO chnanels */
                            ho_chnl_itr = coreotn_var_reg->dmx2.var.lo_chnl_cfg[mo_chnl_itr].ho_chnl_id;
                            coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt += 1;
                        
                            /* trib port is not recovered, it can be modified by runtime APIs
                               therefore, we can realies on this value to perform the audit */
                            /* coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].trib_port; */                              
                        }      
                    }
                }

                /* TX side */
                if (coreotn_var_reg->energy_state_reg.fmf2.odtu_mux == PMC_ENERGY_STATE_RESET && 
                    coreotn_var_reg->energy_state_reg.fmf2.tfrm12 == PMC_ENERGY_STATE_RUNNING)
                {
                    UINT32 tfrm_passthru[3];
                    /* get information from register space */
                    odu_tfrm_passthru_get(coreotn_handle->odu_tfrm_stgN_handle,tfrm_passthru);
                 
                    for (ho_chnl_itr = 0; ho_chnl_itr<1; ho_chnl_itr++)
                    {                
                        if ( ((tfrm_passthru[ho_chnl_itr/32] >> (ho_chnl_itr %32)) & 0x1) == 0x0)
                        {
                            /* check database */
                            (void) coreotn_db_cal_entries_get(coreotn_handle,FALSE,FALSE,ho_chnl_itr,ODU_STRUCT_FRM_STGN,&cal_entry[0],&num_cal_entries);
                            if (num_cal_entries != 0)
                            {
                                coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                                coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].payload_format = UTIL_GLOBAL_ODU_UNCHANNELIZED;
                                coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].chnls_prov_cnt     = 1;
                                coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt = 0;
                                if (coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
                                {
                                    coreotn_var_reg->var.tx_mo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;
                                    coreotn_var_reg->var.tx_lo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;                        
                                }
                            }
                        }
                    }      
                } else 
                {
                    for (ho_chnl_itr = 0; ho_chnl_itr<1; ho_chnl_itr++)
                    {
                        if (coreotn_var_reg->mux2.var.ho_chnl_cfg[ho_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL ||
                            coreotn_var_reg->mux2.var.ho_chnl_cfg[ho_chnl_itr].state == (UINT32)ODTU_MUX_CHNL_PASSTHRU)
                        {
                            coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                            coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].odu_container  = coreotn_var_reg->mux2.var.ho_chnl_cfg[ho_chnl_itr].oduk_type;
                            coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].payload_format = coreotn_var_reg->mux2.var.ho_chnl_cfg[ho_chnl_itr].ts_type;
                            coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].chnls_prov_cnt     = 1;
                            coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt = 0;
                            if (coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
                            {
                                coreotn_var_reg->var.tx_mo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;
                                coreotn_var_reg->var.tx_lo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;                        
                            } else 
                            {
                                coreotn_var_reg->var.tx_mo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_IN_PASSTHRU;
                                coreotn_var_reg->var.tx_lo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_IN_PASSTHRU;                        
                            }                         
                        }
                    }
                    /* MO channels */
                    for (mo_chnl_itr = 0; mo_chnl_itr<COREOTN_MAX_NUM_MO_CHNL; mo_chnl_itr++)
                    {
                        if (coreotn_var_reg->mux2.var.lo_chnl_cfg[mo_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL)
                        {
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].odu_container  = coreotn_var_reg->mux2.var.lo_chnl_cfg[mo_chnl_itr].ho_oduk_type;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].lo_odu_rate    = coreotn_var_reg->mux2.var.lo_chnl_cfg[mo_chnl_itr].lo_oduk_type;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].odu_flex_rate    = coreotn_var_reg->mux2.var.lo_chnl_cfg[mo_chnl_itr].num_ts;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].cbr_flex_rate    = 0;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].payload_format   = UTIL_GLOBAL_ODU_UNCHANNELIZED;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].mapping_mode     = (coreotn_mapping_type_t) coreotn_var_reg->mux2.var.lo_chnl_cfg[mo_chnl_itr].mapping_mode;
                            PMC_MEMCPY(&coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].tribslot_mask[0],
                                       &coreotn_var_reg->mux2.lo_chnl_extra[mo_chnl_itr].tx_tribslot_mask[0],sizeof(UINT32)*3) ;
                         
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnls_prov_cnt      = 1;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].sub_chnls_prov_cnt  = 0;
                         
                            /* update associated HO chnanels */
                            ho_chnl_itr = coreotn_var_reg->mux2.var.lo_chnl_cfg[mo_chnl_itr].ho_chnl_id;
                            coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt += 1;
                         
                            coreotn_var_reg->var.tx_lo_chnl_ctxt[mo_chnl_itr].chnl_state = COREOTN_CHNL_IN_PASSTHRU;
                         
                            /* trib port is not recovered, it can be modified by runtime APIs
                               therefore, we can realies on this value to perform the audit */
                            /* coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].trib_port; */                    
                        }  
                    }
                }
                /* end recovery for SYSOTN */



            } else 
            {
                /* RX side */
                /* Handle the case where both muxing stages are in power down */
                if (coreotn_var_reg->energy_state_reg.fmf1.odtu_dmx == PMC_ENERGY_STATE_RESET && 
                    coreotn_var_reg->energy_state_reg.fmf2.odtu_dmx == PMC_ENERGY_STATE_RESET && 
                    coreotn_var_reg->energy_state_reg.fmf1.rfrm12 == PMC_ENERGY_STATE_RUNNING)
                {
                    UINT32 rfrm_passthru[3],rfrm_fau_passthru[3];
                    /* get information from register space */
                    odu_rfrm_passthru_get(coreotn_handle->odu_rfrm_stg1_handle,rfrm_passthru,rfrm_fau_passthru);
                    for (ho_chnl_itr = 0; ho_chnl_itr<COREOTN_MAX_NUM_HO_CHNL; ho_chnl_itr++)
                    {
                
                        if ( ((rfrm_passthru[ho_chnl_itr/32] >> (ho_chnl_itr %32)) & 0x1) == 0x0 )
                        {
                            /* check MPMA database */
                            (void) coreotn_db_cal_entries_get(coreotn_handle,FALSE,TRUE,ho_chnl_itr,ODU_STRUCT_FRM_STG1,&cal_entry[0],&num_cal_entries);
                            if (num_cal_entries != 0)
                            {
                                coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                                coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].payload_format = UTIL_GLOBAL_ODU_UNCHANNELIZED;
                                coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].chnls_prov_cnt     = 1;
                                coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt = 0;
                                coreotn_var_reg->var.rx_mo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;
                                coreotn_var_reg->var.rx_lo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;                        
                            }
                        }
                    }                                        
                } else 
                {
                    for (ho_chnl_itr = 0; ho_chnl_itr<COREOTN_MAX_NUM_HO_CHNL; ho_chnl_itr++)
                    {
                        if (coreotn_var_reg->dmx1.var.ho_chnl_cfg[ho_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL)
                        {
                            coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                            coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].odu_container  = coreotn_var_reg->dmx1.var.ho_chnl_cfg[ho_chnl_itr].oduk_type;
                            coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].payload_format = coreotn_var_reg->dmx1.var.ho_chnl_cfg[ho_chnl_itr].ts_type;
                            coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].chnls_prov_cnt     = 1;
                            coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt = 0;
                            if (coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
                            {
                                coreotn_var_reg->var.rx_mo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;
                                coreotn_var_reg->var.rx_lo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;                        
                            } else 
                            {
                                coreotn_var_reg->var.rx_mo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_IN_PASSTHRU;
                                coreotn_var_reg->var.rx_lo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_IN_PASSTHRU;                        
                            }
                        }                   
                    }
                    /* MO channels */
                    for (mo_chnl_itr = 0; mo_chnl_itr<COREOTN_MAX_NUM_MO_CHNL; mo_chnl_itr++)
                    {
                        if (coreotn_var_reg->dmx1.var.lo_chnl_cfg[mo_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL)
                        {
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].odu_container  = coreotn_var_reg->dmx1.var.lo_chnl_cfg[mo_chnl_itr].ho_oduk_type;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].lo_odu_rate    = coreotn_var_reg->dmx1.var.lo_chnl_cfg[mo_chnl_itr].lo_oduk_type;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].odu_flex_rate    = coreotn_var_reg->dmx1.var.lo_chnl_cfg[mo_chnl_itr].num_ts;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].cbr_flex_rate    = 0;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].payload_format   = UTIL_GLOBAL_ODU_UNCHANNELIZED;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].mapping_mode     = (coreotn_mapping_type_t) coreotn_var_reg->dmx1.var.lo_chnl_cfg[mo_chnl_itr].mapping_mode;
                            PMC_MEMCPY(&coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].tribslot_mask[0],
                                       &coreotn_var_reg->dmx1.lo_chnl_extra[mo_chnl_itr].rx_tribslot_mask[0],sizeof(UINT32)*3) ;
                        
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnls_prov_cnt      = 1;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].sub_chnls_prov_cnt  = 0;
                        
                            /* update associated HO chnanels */
                            ho_chnl_itr = coreotn_var_reg->dmx1.var.lo_chnl_cfg[mo_chnl_itr].ho_chnl_id;
                            coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt += 1;
                        
                            /* trib port is not recovered, it can be modified by runtime APIs
                               therefore, we can realies on this value to perform the audit */
                            /* coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].trib_port; */      

                            /* coreotn_var_reg->var.rx_lo_chnl_ctxt[mo_chnl_itr].chnl_state = COREOTN_CHNL_IN_PASSTHRU;   */

                        
                        }   else if (coreotn_var_reg->dmx2.var.ho_chnl_cfg[mo_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL)
                        {
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].odu_container  = coreotn_var_reg->dmx2.var.ho_chnl_cfg[mo_chnl_itr].oduk_type;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].payload_format = coreotn_var_reg->dmx2.var.ho_chnl_cfg[mo_chnl_itr].ts_type;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnls_prov_cnt     = 1;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].sub_chnls_prov_cnt = 0;
                            if (coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
                            {
                                coreotn_var_reg->var.rx_lo_chnl_ctxt[mo_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;                        
                            }
                        }           
                    }
                    for (lo_chnl_itr = 0; lo_chnl_itr<COREOTN_MAX_NUM_LO_CHNL; lo_chnl_itr++)
                    {
                        if (coreotn_var_reg->dmx2.var.lo_chnl_cfg[lo_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL)
                        {
                            coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                            coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].odu_container  = coreotn_var_reg->dmx2.var.lo_chnl_cfg[lo_chnl_itr].ho_oduk_type;
                            coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].lo_odu_rate    = coreotn_var_reg->dmx2.var.lo_chnl_cfg[lo_chnl_itr].lo_oduk_type;
                            coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].odu_flex_rate    = coreotn_var_reg->dmx2.var.lo_chnl_cfg[lo_chnl_itr].num_ts;
                            coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].cbr_flex_rate    = 0;
                            coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].payload_format   = coreotn_var_reg->dmx2.var.lo_chnl_cfg[lo_chnl_itr].ts_type;
                            coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].mapping_mode     = (coreotn_mapping_type_t) coreotn_var_reg->dmx2.var.lo_chnl_cfg[lo_chnl_itr].mapping_mode;
                            PMC_MEMCPY(&coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].tribslot_mask[0],
                                       &coreotn_var_reg->dmx2.lo_chnl_extra[lo_chnl_itr].rx_tribslot_mask[0],sizeof(UINT32)*3) ;
                        
                            coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].chnls_prov_cnt      = 1;
                            coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].sub_chnls_prov_cnt  = 0;
                        
                            /* update associated HO chnanels */
                            mo_chnl_itr = coreotn_var_reg->dmx2.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id;
                            coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].sub_chnls_prov_cnt += 1;
                        
                            /* trib port is not recovered, it can be modified by runtime APIs
                               therefore, we can realies on this value to perform the audit */
                            /* coreotn_var_reg->var.rx_mo_chnl_ctxt[lo_chnl_itr].trib_port; */                    
                        }                   
                    }
                }


                /* TX side */
                if (coreotn_var_reg->energy_state_reg.fmf1.odtu_mux == PMC_ENERGY_STATE_RESET && 
                    coreotn_var_reg->energy_state_reg.fmf2.odtu_mux == PMC_ENERGY_STATE_RESET && 
                    coreotn_var_reg->energy_state_reg.fmf1.tfrm12 == PMC_ENERGY_STATE_RUNNING)
                {
                    UINT32 tfrm_passthru[3];
                    /* get information from register space */
                    odu_tfrm_passthru_get(coreotn_handle->odu_tfrm_stg1_handle,tfrm_passthru);
                 
                    for (ho_chnl_itr = 0; ho_chnl_itr<COREOTN_MAX_NUM_HO_CHNL; ho_chnl_itr++)
                    {                
                        if ( ((tfrm_passthru[ho_chnl_itr/32] >> (ho_chnl_itr %32)) & 0x1) == 0x0)
                        {
                            /* check database */
                            (void) coreotn_db_cal_entries_get(coreotn_handle,FALSE,FALSE,ho_chnl_itr,ODU_STRUCT_FRM_STG1,&cal_entry[0],&num_cal_entries);
                            if (num_cal_entries != 0)
                            {
                                coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                                coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].payload_format = UTIL_GLOBAL_ODU_UNCHANNELIZED;
                                coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].chnls_prov_cnt     = 1;
                                coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt = 0;
                                if (coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
                                {
                                    coreotn_var_reg->var.tx_mo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;
                                    coreotn_var_reg->var.tx_lo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;                        
                                }
                            }
                        }
                    }      
                } else 
                {                                  
                    for (ho_chnl_itr = 0; ho_chnl_itr<COREOTN_MAX_NUM_HO_CHNL; ho_chnl_itr++)
                    {
                        if (coreotn_var_reg->mux1.var.ho_chnl_cfg[ho_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL ||
                            coreotn_var_reg->mux1.var.ho_chnl_cfg[ho_chnl_itr].state == (UINT32)ODTU_MUX_CHNL_PASSTHRU)
                        {
                            coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                            coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].odu_container  = coreotn_var_reg->mux1.var.ho_chnl_cfg[ho_chnl_itr].oduk_type;
                            coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].payload_format = coreotn_var_reg->mux1.var.ho_chnl_cfg[ho_chnl_itr].ts_type;
                            coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].chnls_prov_cnt     = 1;
                            coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt = 0;
                            if (coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
                            {
                                coreotn_var_reg->var.tx_mo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;
                                coreotn_var_reg->var.tx_lo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;                        
                            } else 
                            {
                                coreotn_var_reg->var.tx_mo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_IN_PASSTHRU;
                                coreotn_var_reg->var.tx_lo_chnl_ctxt[ho_chnl_itr].chnl_state = COREOTN_CHNL_IN_PASSTHRU;                        
                            }                         
                        }
                    }
                    /* MO channels */
                    for (mo_chnl_itr = 0; mo_chnl_itr<COREOTN_MAX_NUM_MO_CHNL; mo_chnl_itr++)
                    {
                        if (coreotn_var_reg->mux1.var.lo_chnl_cfg[mo_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL)
                        {
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].odu_container  = coreotn_var_reg->mux1.var.lo_chnl_cfg[mo_chnl_itr].ho_oduk_type;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].lo_odu_rate    = coreotn_var_reg->mux1.var.lo_chnl_cfg[mo_chnl_itr].lo_oduk_type;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].odu_flex_rate    = coreotn_var_reg->mux1.var.lo_chnl_cfg[mo_chnl_itr].num_ts;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].cbr_flex_rate    = 0;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].payload_format   = UTIL_GLOBAL_ODU_UNCHANNELIZED;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].mapping_mode     = (coreotn_mapping_type_t) coreotn_var_reg->mux1.var.lo_chnl_cfg[mo_chnl_itr].mapping_mode;
                            PMC_MEMCPY(&coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].tribslot_mask[0],
                                       &coreotn_var_reg->mux1.lo_chnl_extra[mo_chnl_itr].tx_tribslot_mask[0],sizeof(UINT32)*3) ;
                         
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnls_prov_cnt      = 1;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].sub_chnls_prov_cnt  = 0;
                         
                            /* update associated HO chnanels */
                            ho_chnl_itr = coreotn_var_reg->mux1.var.lo_chnl_cfg[mo_chnl_itr].ho_chnl_id;
                            coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt += 1;
                         
                            coreotn_var_reg->var.tx_lo_chnl_ctxt[mo_chnl_itr].chnl_state = COREOTN_CHNL_IN_PASSTHRU;
                         
                            /* trib port is not recovered, it can be modified by runtime APIs
                               therefore, we can realies on this value to perform the audit */
                            /* coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].trib_port; */                    
                        }  else if (coreotn_var_reg->mux2.var.ho_chnl_cfg[mo_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL||
                                    coreotn_var_reg->mux2.var.ho_chnl_cfg[mo_chnl_itr].state == (UINT32)ODTU_MUX_CHNL_PASSTHRU)
                        {
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].odu_container  = coreotn_var_reg->mux2.var.ho_chnl_cfg[mo_chnl_itr].oduk_type;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].payload_format = coreotn_var_reg->mux2.var.ho_chnl_cfg[mo_chnl_itr].ts_type;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnls_prov_cnt     = 1;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].sub_chnls_prov_cnt = 0;
                            if (coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
                            {
                                coreotn_var_reg->var.tx_lo_chnl_ctxt[mo_chnl_itr].chnl_state = COREOTN_CHNL_OPERATIONAL;                        
                            }
                        } 
                    }
                    for (lo_chnl_itr = 0; lo_chnl_itr<COREOTN_MAX_NUM_LO_CHNL; lo_chnl_itr++)
                    {
                        if (coreotn_var_reg->mux2.var.lo_chnl_cfg[lo_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL)
                        {
                            coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnl_state     = COREOTN_CHNL_OPERATIONAL;
                            coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].odu_container  = coreotn_var_reg->mux2.var.lo_chnl_cfg[lo_chnl_itr].ho_oduk_type;
                            coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].lo_odu_rate    = coreotn_var_reg->mux2.var.lo_chnl_cfg[lo_chnl_itr].lo_oduk_type;
                            coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].odu_flex_rate    = coreotn_var_reg->mux2.var.lo_chnl_cfg[lo_chnl_itr].num_ts;
                            coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].cbr_flex_rate    = 0;
                            coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].payload_format   = coreotn_var_reg->mux2.var.lo_chnl_cfg[lo_chnl_itr].ts_type;
                            coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].mapping_mode     = (coreotn_mapping_type_t) coreotn_var_reg->mux2.var.lo_chnl_cfg[lo_chnl_itr].mapping_mode;
                            PMC_MEMCPY(&coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].tribslot_mask[0],
                                       &coreotn_var_reg->mux2.lo_chnl_extra[lo_chnl_itr].tx_tribslot_mask[0],sizeof(UINT32)*3) ;
                         
                            coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnls_prov_cnt      = 1;
                            coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].sub_chnls_prov_cnt  = 0;
                         
                            /* update associated HO chnanels */
                            mo_chnl_itr = coreotn_var_reg->mux2.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id;
                            coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].sub_chnls_prov_cnt += 1;
                         
                            /* trib port is not recovered, it can be modified by runtime APIs
                               therefore, we can realies on this value to perform the audit */
                            /* coreotn_var_reg->var.rx_mo_chnl_ctxt[lo_chnl_itr].trib_port; */                    
                        }    
                    }
                }                
            }                
        }
    }

    /* recover PRBS status */
    {
        UINT32 prbs_itr, chnl_itr, prbs_mon_en, prbs_gen_en;
        for (prbs_itr = 0; prbs_itr <  LAST_COREOTN_PRBS_INST;prbs_itr++)
        {
            if ( (prbs_itr == (UINT32) COREOTN_FMF1_PRBS && coreotn_var_reg->energy_state_reg.fmf1.prbs == PMC_ENERGY_STATE_RUNNING) ||
                 (prbs_itr == (UINT32) COREOTN_FMF2_PRBS && coreotn_var_reg->energy_state_reg.fmf2.prbs == PMC_ENERGY_STATE_RUNNING) ||
                 (prbs_itr == (UINT32) COREOTN_FO1_PRBS && coreotn_var_reg->energy_state_reg.fo1.prbs == PMC_ENERGY_STATE_RUNNING) ||
                 (prbs_itr == (UINT32) COREOTN_FO2_PRBS && coreotn_var_reg->energy_state_reg.fo2.prbs == PMC_ENERGY_STATE_RUNNING) )
            {
                for (chnl_itr = 0;chnl_itr < COREOTN_PRBS_NUM_CHNL;chnl_itr++)
                {
                    if (prbs_itr < (UINT32) COREOTN_FO1_PRBS)
                    {
                        prbs_mon_en = coreotn_fmf_field_PRBS_MON_EN_get(NULL, coreotn_handle, prbs_itr, chnl_itr);
                        prbs_gen_en = coreotn_fmf_field_PRBS_GEN_EN_get(NULL, coreotn_handle, prbs_itr, chnl_itr);
                        
                        if(prbs_mon_en == 1 || prbs_gen_en == 1)
                        {
                            dci_chnl = coreotn_fmf_field_PRBS_CHID_get(NULL, coreotn_handle, prbs_itr, chnl_itr); 
                        }
                    } 
                    else 
                    {
                        prbs_mon_en = coreotn_fo_field_PRBS_MON_EN_get(NULL, coreotn_handle, prbs_itr-2, chnl_itr);   
                        prbs_gen_en = coreotn_fo_field_PRBS_GEN_EN_get(NULL, coreotn_handle, prbs_itr-2, chnl_itr);

                        if(prbs_mon_en == 1 || prbs_gen_en == 1)
                        {
                            dci_chnl = coreotn_fo_field_PRBS_CHID_get(NULL, coreotn_handle, prbs_itr-2, chnl_itr); 
                        }
                    }

                    if(prbs_mon_en == 1)
                    {
                        coreotn_var_reg->var.prbs_chnl_prov[prbs_itr][chnl_itr] = dci_chnl;
                    }
                    else
                    {
                        coreotn_var_reg->var.prbs_chnl_prov[prbs_itr][chnl_itr] = COREOTN_PRBS_MON_DISABLED;
                    }
                    if(prbs_gen_en == 1)
                    {
                        coreotn_var_reg->var.prev_pm_mode[prbs_itr][dci_chnl] = coreotn_handle->var.prev_pm_mode[prbs_itr][dci_chnl];
                    }
                }
            }
        }
    }   

    PMC_RETURN(rc);
} /* coreotn_ctxt_reg_recover */

/*******************************************************************************
* coreotn_ctxt_audit
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Audit memory context with recovered register context. This function 
*   determines if a cleanup is required
*   
*   A clean context which represents the intersection between both context is also 
*   generated.
*
* INPUTS:
*   *coreotn_handle        - pointer to MAPOTN handle instance to be operated on
*   *restart_init_cfg_ptr       - pointer to restart init config
*   *coreotn_var_reg       - A partial coreotn_var_t context + additional
*                           information to facilite audit phase
*
* OUTPUTS:
*   *coreotn_var_clean     - A clean context which represents the intersection
*                           between both context is also generated.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS:
*    Memory & register context matches
*   COREOTN_ERR_CONTEXT_CLEANUP:
*    A cleanup is required.
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_ctxt_audit(coreotn_handle_t *coreotn_handle,
                                     util_global_restart_init_cfg_t *restart_init_cfg_ptr,
                                     coreotn_recover_var_t *coreotn_var_reg,                                         
                                     coreotn_var_t *coreotn_var_clean)
{
    PMC_ERROR rc = PMC_SUCCESS;   
    UINT32 ho_chnl_itr, mo_chnl_itr, lo_chnl_itr;
    PMC_ENTRY();
    
    /* init the new context  */
    coreotn_var_default_init(coreotn_handle,coreotn_var_clean);
    

    /* this information is coming from top-level register */
    coreotn_var_clean->coreotn_start_state = coreotn_var_reg->var.coreotn_start_state;
    coreotn_var_clean->init_operation = coreotn_var_reg->var.init_operation;
    coreotn_var_clean->ilkn_if_enable = coreotn_var_reg->var.ilkn_if_enable;    
    /* copy those variables, they will be updated if required */
    PMC_MEMCPY(&coreotn_var_clean->mux_profile,coreotn_handle->var.mux_profile, sizeof(coreotn_mux_profile_t)*(UINT32) COREOTN_MAX_NUM_HO_CHNL);
    coreotn_var_clean->prov_mode = coreotn_handle->var.prov_mode;
    coreotn_var_clean->ddeg_mon_seg = coreotn_handle->var.ddeg_mon_seg;    
    PMC_MEMCPY(&coreotn_var_clean->ddeg_mon,&coreotn_handle->var.ddeg_mon, sizeof(coreotn_ddeg_mon_t)  * (UINT32) COREOTN_NUM_DDEG_MOD);


    /* AUDIT POWER */
    
    /* 
       first, if we are here, it means that top-level register says that we are out-of-reset 
    */
    if (coreotn_var_reg->var.coreotn_start_state != coreotn_start_state_test(coreotn_handle))
    {       
        coreotn_var_clean->coreotn_start_state = TRUE;
        rc = COREOTN_ERR_CONTEXT_CLEANUP;
    } else if (coreotn_var_reg->var.coreotn_start_state == FALSE) 
    {

        /* this information is coming from top-level register */
        coreotn_var_clean->coreotn_start_state = coreotn_var_reg->var.coreotn_start_state;
        coreotn_var_clean->init_operation = coreotn_var_reg->var.init_operation;
        coreotn_var_clean->ilkn_if_enable = coreotn_var_reg->var.ilkn_if_enable;    


        /* AUDIT STG4 */
        if (coreotn_stg4_start_state_test(coreotn_handle) == FALSE)
        {
            if (PMC_ENERGY_STATE_RUNNING != coreotn_var_reg->stg4_energy)
            {
                rc = COREOTN_ERR_CONTEXT_CLEANUP;
            } else 
            {
                for (lo_chnl_itr = 0; lo_chnl_itr<COREOTN_MAX_NUM_LO_CHNL; lo_chnl_itr++)
                {
                    if (coreotn_var_reg->var.rx_stg4_chnl_prov[lo_chnl_itr] == coreotn_handle->var.rx_stg4_chnl_prov[lo_chnl_itr])
                    {
                        coreotn_var_clean->rx_stg4_chnl_prov[lo_chnl_itr] = coreotn_handle->var.rx_stg4_chnl_prov[lo_chnl_itr];
                    }                   
                    if (coreotn_var_reg->var.tx_stg4_chnl_prov[lo_chnl_itr] == coreotn_handle->var.tx_stg4_chnl_prov[lo_chnl_itr])
                    {
                        coreotn_var_clean->tx_stg4_chnl_prov[lo_chnl_itr] = coreotn_handle->var.tx_stg4_chnl_prov[lo_chnl_itr];
                    }                   
                }
            }
        }

        /* AUDIT ODUKSW */
        if (coreotn_oduksw_start_state_test(coreotn_handle) == FALSE)
        {
            UINT32 port_itr;
            BOOL8 rx_equipped, tx_equipped;

            for (port_itr = 0;port_itr < COREOTN_OCPB_NUM_PORT;port_itr++)
            {                     
                for (lo_chnl_itr = 0; lo_chnl_itr<COREOTN_MAX_NUM_LO_CHNL; lo_chnl_itr++)
                {
                    rx_equipped = FALSE;
                    tx_equipped = FALSE;
                    if (coreotn_var_reg->var.rx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].state != 
                        coreotn_handle->var.rx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].state)
                    {
                        if (coreotn_var_reg->var.rx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].state == COREOTN_CHNL_START && 
                            coreotn_handle->var.rx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].state == COREOTN_CHNL_EQUIPPED)
                        {
                            rx_equipped = TRUE;
                        } else 
                        {                            
                            rc = COREOTN_ERR_CONTEXT_CLEANUP;
                        }
                    } else 
                    {
                        if (coreotn_var_reg->var.rx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].state == COREOTN_CHNL_OPERATIONAL)
                        {
                            if (coreotn_var_reg->var.rx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].input_map_count    == coreotn_handle->var.rx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].input_map_count &&  
                                coreotn_var_reg->var.rx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].dest_active_count  == coreotn_handle->var.rx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].dest_active_count ) 
                            {  
                                PMC_MEMCPY(&coreotn_var_clean->rx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr],
                                           &coreotn_handle->var.rx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr],
                                           sizeof(coreotn_oduksw_chnl_ctxt_t));
                            } else  
                            { 
                                rc = COREOTN_ERR_CONTEXT_CLEANUP; 
                            }
                        }

                    }
                    if (coreotn_var_reg->var.tx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].state != 
                        coreotn_handle->var.tx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].state)
                    {
                        if (coreotn_var_reg->var.tx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].state == COREOTN_CHNL_START && 
                            coreotn_handle->var.tx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].state == COREOTN_CHNL_EQUIPPED)
                        {
                            tx_equipped = TRUE;
                        } else 
                        {                            
                            rc = COREOTN_ERR_CONTEXT_CLEANUP;
                        }
                    } else 
                    {
                        if (coreotn_var_reg->var.tx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].state == COREOTN_CHNL_OPERATIONAL)
                        {
                            if (coreotn_var_reg->var.tx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].input_map_count    == coreotn_handle->var.tx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].input_map_count && 
                                coreotn_var_reg->var.tx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].dest_active_count  == coreotn_handle->var.tx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr].dest_active_count )
                            {                                                                
                                PMC_MEMCPY(&coreotn_var_clean->tx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr],
                                           &coreotn_handle->var.tx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr],
                                           sizeof(coreotn_oduksw_chnl_ctxt_t));
                            } else 
                            {
                                rc = COREOTN_ERR_CONTEXT_CLEANUP;
                            }
                        }

                    }                           
                    

                    /* resolve equipped case, we accept 1 side in EQUIPPED state if the other one is in OPERATIONAL state
                       that is done to support working-protect scheme */
                    if (rx_equipped == TRUE && tx_equipped == TRUE)
                    {
                        if (restart_init_cfg_ptr->is_warm_restart == TRUE)
                        {
                            PMC_MEMCPY(&coreotn_var_clean->rx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr],
                                       &coreotn_handle->var.rx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr],
                                       sizeof(coreotn_oduksw_chnl_ctxt_t));
                            PMC_MEMCPY(&coreotn_var_clean->tx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr],
                                       &coreotn_handle->var.tx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr],
                                       sizeof(coreotn_oduksw_chnl_ctxt_t));
                        } else 
                        {
                            rc = COREOTN_ERR_CONTEXT_CLEANUP;
                        }
                    } else if (rx_equipped == TRUE)
                    {
                        if (restart_init_cfg_ptr->is_warm_restart == TRUE)
                        {
                            PMC_MEMCPY(&coreotn_var_clean->rx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr],
                                       &coreotn_handle->var.rx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr],
                                       sizeof(coreotn_oduksw_chnl_ctxt_t));
                        } else 
                        {
                            rc = COREOTN_ERR_CONTEXT_CLEANUP;
                        }
                    } else if (tx_equipped == TRUE)
                    {
                        if (restart_init_cfg_ptr->is_warm_restart == TRUE)
                        {
                            PMC_MEMCPY(&coreotn_var_clean->tx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr],
                                       &coreotn_handle->var.tx_oduksw_chnl_ctxt[port_itr][lo_chnl_itr],
                                       sizeof(coreotn_oduksw_chnl_ctxt_t));
                        } else 
                        {
                            rc = COREOTN_ERR_CONTEXT_CLEANUP;
                        }
                    }
                }
            }
        }

        /* AUDIT ODUKP */        
        if (coreotn_odukp_start_state_test(coreotn_handle) == FALSE)
        {            
            /* resolve implementation specific case, when ODU_NULL, we accept any recovered payload format */
            for (ho_chnl_itr = 0; ho_chnl_itr<COREOTN_MAX_NUM_HO_CHNL; ho_chnl_itr++)
            {
                if (coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_itr].chnl_state == COREOTN_CHNL_OPERATIONAL && 
                    coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_itr].payload_format == UTIL_GLOBAL_ODU_NULL)
                {
                    coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].payload_format = UTIL_GLOBAL_ODU_NULL;
                }
                if (coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_itr].chnl_state == COREOTN_CHNL_OPERATIONAL && 
                    coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_itr].payload_format == UTIL_GLOBAL_ODU_NULL)
                {
                    coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].payload_format = UTIL_GLOBAL_ODU_NULL;
                }                    
            }
            for (mo_chnl_itr = 0; mo_chnl_itr<COREOTN_MAX_NUM_MO_CHNL; mo_chnl_itr++)
            {
                if (coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnl_state == COREOTN_CHNL_OPERATIONAL && 
                    coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr].payload_format == UTIL_GLOBAL_ODU_NULL)
                {
                    coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].payload_format = UTIL_GLOBAL_ODU_NULL;
                }
                if (coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnl_state == COREOTN_CHNL_OPERATIONAL && 
                    coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr].payload_format == UTIL_GLOBAL_ODU_NULL)
                {
                    coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].payload_format = UTIL_GLOBAL_ODU_NULL;
                } 
            }
            for (lo_chnl_itr = 0; lo_chnl_itr<COREOTN_MAX_NUM_LO_CHNL; lo_chnl_itr++)
            {
                if (coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].chnl_state == COREOTN_CHNL_OPERATIONAL && 
                    coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].payload_format == UTIL_GLOBAL_ODU_NULL)
                {
                    coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].payload_format = UTIL_GLOBAL_ODU_NULL;
                }
                if (coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnl_state == COREOTN_CHNL_OPERATIONAL && 
                    coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].payload_format == UTIL_GLOBAL_ODU_NULL)
                {
                    coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].payload_format = UTIL_GLOBAL_ODU_NULL;
                } 
            }

            /* check SYSAPP line context */
            for (ho_chnl_itr = 0; ho_chnl_itr<COREOTN_MAX_NUM_HO_CHNL; ho_chnl_itr++)
            {
                if (coreotn_var_reg->var.sysapp_line_state[ho_chnl_itr] != coreotn_handle->var.sysapp_line_state[ho_chnl_itr])
                {
                    rc = COREOTN_ERR_CONTEXT_CLEANUP;
                } else 
                {
                    coreotn_var_clean->sysapp_line_state[ho_chnl_itr] = coreotn_handle->var.sysapp_line_state[ho_chnl_itr];
                    coreotn_var_clean->prev_fmf1_sysotn_rfrm_maint_sig[ho_chnl_itr] =  coreotn_handle->var.prev_fmf1_sysotn_rfrm_maint_sig[ho_chnl_itr];                    
                    coreotn_var_clean->dummy_fmf1_sysotn_maint_sig[ho_chnl_itr]=  coreotn_handle->var.dummy_fmf1_sysotn_maint_sig[ho_chnl_itr];
                }
            }

            /* check HO channels */
            for (ho_chnl_itr = 0; ho_chnl_itr<COREOTN_MAX_NUM_HO_CHNL; ho_chnl_itr++)
            {
                if (coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_itr].chnl_state == COREOTN_CHNL_IN_PASSTHRU)
                {
                    PMC_MEMCPY(&coreotn_var_clean->rx_ho_chnl_ctxt[ho_chnl_itr],
                               &coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_itr],
                               sizeof(coreotn_chnl_ho_ctxt_t));                    
                } else  if (coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].chnl_state != coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_itr].chnl_state)
                {
                    rc = COREOTN_ERR_CONTEXT_CLEANUP;
                } else 
                {
                    if (coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].chnl_state == COREOTN_CHNL_OPERATIONAL)
                    {
                        if (coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].payload_format     == coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_itr].payload_format)
                        {

                            /* check stg3b  level*/
                            if (UTIL_GLOBAL_ODU_UNCHANNELIZED == coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].payload_format && 
                                coreotn_handle->var.stg3b_odu_level[ho_chnl_itr] != ODU_STRUCT_LEVEL_HO_ODU)
                            {
                                rc = COREOTN_ERR_CONTEXT_CLEANUP;                              
                            } else 
                            {
                                PMC_MEMCPY(&coreotn_var_clean->rx_ho_chnl_ctxt[ho_chnl_itr],
                                           &coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_itr],
                                           sizeof(coreotn_chnl_ho_ctxt_t));
                                coreotn_var_clean->rx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt = coreotn_var_reg->var.rx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt;
                                coreotn_var_clean->stg3b_odu_level[ho_chnl_itr] = ODU_STRUCT_LEVEL_HO_ODU;
                            }
                        } else 
                        {
                            rc = COREOTN_ERR_CONTEXT_CLEANUP;
                        }
                    }
                }


                if (coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_itr].chnl_state == COREOTN_CHNL_IN_PASSTHRU)
                {
                    PMC_MEMCPY(&coreotn_var_clean->tx_ho_chnl_ctxt[ho_chnl_itr],
                               &coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_itr],
                               sizeof(coreotn_chnl_ho_ctxt_t));                   
                } else if (coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].chnl_state != coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_itr].chnl_state)
                {
                    rc = COREOTN_ERR_CONTEXT_CLEANUP;
                } else 
                {
                    if (coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].chnl_state == COREOTN_CHNL_OPERATIONAL)
                    {
                        if (coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].payload_format     == coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_itr].payload_format)
                        {
                            if (UTIL_GLOBAL_ODU_UNCHANNELIZED == coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].payload_format && 
                                coreotn_handle->var.stg3b_odu_level[ho_chnl_itr] != ODU_STRUCT_LEVEL_HO_ODU)
                            {
                                rc = COREOTN_ERR_CONTEXT_CLEANUP;                              
                            } else 
                            {
                                PMC_MEMCPY(&coreotn_var_clean->tx_ho_chnl_ctxt[ho_chnl_itr],
                                           &coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_itr],
                                           sizeof(coreotn_chnl_ho_ctxt_t));
                                coreotn_var_clean->tx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt = coreotn_var_reg->var.tx_ho_chnl_ctxt[ho_chnl_itr].sub_chnls_prov_cnt;
                                coreotn_var_clean->stg3b_odu_level[ho_chnl_itr] = ODU_STRUCT_LEVEL_HO_ODU;
                                coreotn_var_clean->prev_fo1_rfrm_maint_sig[ho_chnl_itr] = coreotn_handle->var.prev_fo1_rfrm_maint_sig[ho_chnl_itr];
                                coreotn_var_clean->dummy_fo1_maint_sig[ho_chnl_itr] = coreotn_handle->var.dummy_fo1_maint_sig[ho_chnl_itr];
                            }
                        }  else 
                        {
                            rc = COREOTN_ERR_CONTEXT_CLEANUP;
                        }
                    }
                }
            }
            
            /* check MO channels */
            for (mo_chnl_itr = 0; mo_chnl_itr<COREOTN_MAX_NUM_MO_CHNL; mo_chnl_itr++)
            {
                /* fix start/passthru mode */
                if (coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnl_state == COREOTN_CHNL_IN_PASSTHRU &&
                    (coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnl_state  == COREOTN_CHNL_START ||
                     coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnl_state  == COREOTN_CHNL_EQUIPPED))
                {
                    coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnl_state = coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnl_state;
                }

                /* RX side */
                if (coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnl_state == COREOTN_CHNL_IN_PASSTHRU ||
                    coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnl_state  == COREOTN_CHNL_EQUIPPED)
                {
                    PMC_MEMCPY(&coreotn_var_clean->rx_mo_chnl_ctxt[mo_chnl_itr],
                               &coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr],
                               sizeof(coreotn_chnl_molo_ctxt_t));   
                } else  if (coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnl_state != coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnl_state)
                {
                    rc = COREOTN_ERR_CONTEXT_CLEANUP;
                } else 
                {
                    if (coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].chnl_state == COREOTN_CHNL_OPERATIONAL)
                    {
                        /* check if HO was UNCHANNELIZED, we accept it */
                        if (mo_chnl_itr < COREOTN_MAX_NUM_HO_CHNL && 
                            coreotn_var_clean->rx_ho_chnl_ctxt[mo_chnl_itr].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
                        {
                            PMC_MEMCPY(&coreotn_var_clean->rx_mo_chnl_ctxt[mo_chnl_itr],
                                       &coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr],
                                       sizeof(coreotn_chnl_molo_ctxt_t));
                        } else if (coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].lo_odu_rate        == coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr].lo_odu_rate && 
                                   coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].mapping_mode       == coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr].mapping_mode && 
                                   TRUE == util_global_array_compare((UINT8*)&coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].tribslot_mask[0],
                                                                     (UINT8*)&coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr].tribslot_mask[0],
                                                                     3*sizeof(UINT32)) )
                        {
                            /* check flex/cbr rate */
                            if ( (UTIL_GLOBAL_ODUFLEX_GFP == coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].lo_odu_rate && 
                                  coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].odu_flex_rate  != coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr].odu_flex_rate ) ||
                                 (UTIL_GLOBAL_ODUFLEX_CBR  == coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].lo_odu_rate&& 
                                  coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].odu_flex_rate  != coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr].odu_flex_rate))
                            {
                                rc = COREOTN_ERR_CONTEXT_CLEANUP;
                            } else if (UTIL_GLOBAL_ODU_UNCHANNELIZED == coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr].payload_format && 
                                       coreotn_handle->var.stg3b_odu_level[mo_chnl_itr] != ODU_STRUCT_LEVEL_MO_ODU)
                            {
                                rc = COREOTN_ERR_CONTEXT_CLEANUP;                              
                            } else 
                            {                            
                                PMC_MEMCPY(&coreotn_var_clean->rx_mo_chnl_ctxt[mo_chnl_itr],
                                           &coreotn_handle->var.rx_mo_chnl_ctxt[mo_chnl_itr],
                                           sizeof(coreotn_chnl_molo_ctxt_t));
                                coreotn_var_clean->rx_mo_chnl_ctxt[mo_chnl_itr].sub_chnls_prov_cnt = coreotn_var_reg->var.rx_mo_chnl_ctxt[mo_chnl_itr].sub_chnls_prov_cnt;
                                coreotn_var_clean->stg3b_odu_level[mo_chnl_itr] = ODU_STRUCT_LEVEL_MO_ODU;
                            }
                        } else 
                        {
                            rc = COREOTN_ERR_CONTEXT_CLEANUP;
                        }
                    }
                }

                /* fix start/passthru mode */
                if (coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnl_state == COREOTN_CHNL_IN_PASSTHRU &&
                    (coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnl_state  == COREOTN_CHNL_START ||
                     coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnl_state  == COREOTN_CHNL_EQUIPPED))
                {
                    coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnl_state = coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnl_state;
                }

                /* TX side */
                if (coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnl_state == COREOTN_CHNL_IN_PASSTHRU ||
                    coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnl_state  == COREOTN_CHNL_EQUIPPED)
                {
                    PMC_MEMCPY(&coreotn_var_clean->tx_mo_chnl_ctxt[mo_chnl_itr],
                               &coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr],
                               sizeof(coreotn_chnl_molo_ctxt_t));
                } else  if (coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnl_state != coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnl_state)
                {
                    rc = COREOTN_ERR_CONTEXT_CLEANUP;
                } else 
                {
                    if (coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].chnl_state == COREOTN_CHNL_OPERATIONAL)
                    {
                        if (mo_chnl_itr < COREOTN_MAX_NUM_HO_CHNL && 
                            coreotn_var_clean->tx_ho_chnl_ctxt[mo_chnl_itr].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
                        {
                            PMC_MEMCPY(&coreotn_var_clean->tx_mo_chnl_ctxt[mo_chnl_itr],
                                       &coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr],
                                       sizeof(coreotn_chnl_molo_ctxt_t));
                        } else if (coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].lo_odu_rate        == coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr].lo_odu_rate &&                                    
                                   coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].mapping_mode       == coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr].mapping_mode && 
                                   TRUE == util_global_array_compare((UINT8*)&coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].tribslot_mask[0],
                                                                     (UINT8*)&coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr].tribslot_mask[0],
                                                                     3*sizeof(UINT32)) )
                        {
                            /* check flex/cbr rate */
                            if ( (UTIL_GLOBAL_ODUFLEX_GFP == coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].lo_odu_rate && 
                                  coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].odu_flex_rate  != coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr].odu_flex_rate ) ||
                                 (UTIL_GLOBAL_ODUFLEX_CBR  == coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].lo_odu_rate&& 
                                  coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].odu_flex_rate  != coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr].odu_flex_rate))
                            {
                                rc = COREOTN_ERR_CONTEXT_CLEANUP;
                            } else if (UTIL_GLOBAL_ODU_UNCHANNELIZED == coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr].payload_format && 
                                       coreotn_handle->var.stg3b_odu_level[mo_chnl_itr] != ODU_STRUCT_LEVEL_MO_ODU)
                            {
                                rc = COREOTN_ERR_CONTEXT_CLEANUP;                              
                            } else 
                            {                            
                                PMC_MEMCPY(&coreotn_var_clean->tx_mo_chnl_ctxt[mo_chnl_itr],
                                           &coreotn_handle->var.tx_mo_chnl_ctxt[mo_chnl_itr],
                                           sizeof(coreotn_chnl_molo_ctxt_t));
                                coreotn_var_clean->tx_mo_chnl_ctxt[mo_chnl_itr].sub_chnls_prov_cnt = coreotn_var_reg->var.tx_mo_chnl_ctxt[mo_chnl_itr].sub_chnls_prov_cnt;
                                coreotn_var_clean->stg3b_odu_level[mo_chnl_itr] = ODU_STRUCT_LEVEL_MO_ODU;
                                coreotn_var_clean->prev_fo1_rfrm_maint_sig[mo_chnl_itr] = coreotn_handle->var.prev_fo1_rfrm_maint_sig[mo_chnl_itr];
                                coreotn_var_clean->dummy_fo1_maint_sig[mo_chnl_itr] = coreotn_handle->var.dummy_fo1_maint_sig[mo_chnl_itr];
                            }                       
                        } else 
                        {
                            rc = COREOTN_ERR_CONTEXT_CLEANUP;    
                        }
                        
                    }
                }
            }
            /* LO channels */
            for (lo_chnl_itr = 0; lo_chnl_itr<COREOTN_MAX_NUM_LO_CHNL; lo_chnl_itr++)
            {
                /* fix start/passthru mode */
                if (coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].chnl_state == COREOTN_CHNL_IN_PASSTHRU &&
                    (coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].chnl_state  == COREOTN_CHNL_START || 
                     coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].chnl_state  == COREOTN_CHNL_EQUIPPED))
                {
                    coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].chnl_state = coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].chnl_state;
                }
                    
                if (coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].chnl_state == COREOTN_CHNL_IN_PASSTHRU||
                    coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].chnl_state  == COREOTN_CHNL_EQUIPPED)
                {
                    PMC_MEMCPY(&coreotn_var_clean->rx_lo_chnl_ctxt[lo_chnl_itr],
                               &coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr],
                               sizeof(coreotn_chnl_molo_ctxt_t));
                } else if (coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].chnl_state != coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].chnl_state)
                {
                    rc = COREOTN_ERR_CONTEXT_CLEANUP;
                } else 
                {
                    if (coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].chnl_state == COREOTN_CHNL_OPERATIONAL)
                    {
                        if (coreotn_var_clean->rx_lo_chnl_ctxt[lo_chnl_itr].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED || 
                            coreotn_var_clean->rx_lo_chnl_ctxt[lo_chnl_itr].payload_format == LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD)
                        {
                            PMC_MEMCPY(&coreotn_var_clean->rx_lo_chnl_ctxt[lo_chnl_itr],
                                       &coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr],
                                       sizeof(coreotn_chnl_molo_ctxt_t));
                        } else  if (coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].odu_container      == coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].odu_container && 
                                    coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].lo_odu_rate        == coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].lo_odu_rate && 
                                    coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].mapping_mode       == coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].mapping_mode && 
                                    TRUE == util_global_array_compare((UINT8*)&coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].tribslot_mask[0],
                                                                      (UINT8*)&coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].tribslot_mask[0],
                                                                      3*sizeof(UINT32)) )
                        {
                            /* check flex/cbr rate */
                            if ( (UTIL_GLOBAL_ODUFLEX_GFP == coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].lo_odu_rate && 
                                  coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].odu_flex_rate  == coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].odu_flex_rate ) ||
                                 (UTIL_GLOBAL_ODUFLEX_CBR  == coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].lo_odu_rate&& 
                                  coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].odu_flex_rate  != coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].odu_flex_rate))
                            {
                                rc = COREOTN_ERR_CONTEXT_CLEANUP;
                            } else if (UTIL_GLOBAL_ODU_UNCHANNELIZED == coreotn_var_reg->var.rx_lo_chnl_ctxt[lo_chnl_itr].payload_format && 
                                       coreotn_handle->var.stg3b_odu_level[lo_chnl_itr] != ODU_STRUCT_LEVEL_LO_ODU)
                            {
                                rc = COREOTN_ERR_CONTEXT_CLEANUP;                              
                            } else 
                            {                            
                                PMC_MEMCPY(&coreotn_var_clean->rx_lo_chnl_ctxt[lo_chnl_itr],
                                           &coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr],
                                           sizeof(coreotn_chnl_molo_ctxt_t));
                                coreotn_var_clean->rx_lo_chnl_ctxt[lo_chnl_itr].sub_chnls_prov_cnt = coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].sub_chnls_prov_cnt;
                                coreotn_var_clean->stg3b_odu_level[lo_chnl_itr] = ODU_STRUCT_LEVEL_LO_ODU;
                            }                       
                        } else 
                        {
                            rc = COREOTN_ERR_CONTEXT_CLEANUP;                              
                        }
                    }
                }

                /* fix start/passthru mode */
                if (coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnl_state == COREOTN_CHNL_IN_PASSTHRU &&
                    (coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnl_state  == COREOTN_CHNL_START ||
                     coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnl_state  == COREOTN_CHNL_EQUIPPED))
                {
                    coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnl_state = coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnl_state;
                }


                if (coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnl_state == COREOTN_CHNL_IN_PASSTHRU ||
                    coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnl_state  == COREOTN_CHNL_EQUIPPED)
                {
                    PMC_MEMCPY(&coreotn_var_clean->tx_lo_chnl_ctxt[lo_chnl_itr],
                               &coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr],
                               sizeof(coreotn_chnl_molo_ctxt_t));
                } else if (coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnl_state != coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnl_state)
                {
                    rc = COREOTN_ERR_CONTEXT_CLEANUP;
                } else 
                {
                    if (coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnl_state == COREOTN_CHNL_OPERATIONAL)
                    {
                        if (coreotn_var_clean->tx_lo_chnl_ctxt[lo_chnl_itr].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED || 
                            coreotn_var_clean->tx_lo_chnl_ctxt[lo_chnl_itr].payload_format == LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD)
                        {
                            PMC_MEMCPY(&coreotn_var_clean->tx_lo_chnl_ctxt[lo_chnl_itr],
                                       &coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr],
                                       sizeof(coreotn_chnl_molo_ctxt_t));
                        } else if (coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnl_state == COREOTN_CHNL_OPERATIONAL &&
                                   coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].odu_container      == coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].odu_container && 
                                   coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].lo_odu_rate        == coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].lo_odu_rate && 
                                   coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].mapping_mode       == coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].mapping_mode && 
                                   TRUE == util_global_array_compare((UINT8*)&coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].tribslot_mask[0],
                                                                     (UINT8*)&coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].tribslot_mask[0],
                                                                     3*sizeof(UINT32)) )
                        {
                            /* check flex/cbr rate */
                            if ( (UTIL_GLOBAL_ODUFLEX_GFP == coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].lo_odu_rate && 
                                  coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].odu_flex_rate  == coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].odu_flex_rate ) ||
                                 (UTIL_GLOBAL_ODUFLEX_CBR  == coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].lo_odu_rate&& 
                                  coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].odu_flex_rate  != coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].odu_flex_rate))
                            {
                                rc = COREOTN_ERR_CONTEXT_CLEANUP;
                            } else if (UTIL_GLOBAL_ODU_UNCHANNELIZED == coreotn_var_reg->var.tx_lo_chnl_ctxt[lo_chnl_itr].payload_format && 
                                       coreotn_handle->var.stg3b_odu_level[lo_chnl_itr] != ODU_STRUCT_LEVEL_LO_ODU)
                            {
                                rc = COREOTN_ERR_CONTEXT_CLEANUP;                              
                            } else 
                            {                            
                                PMC_MEMCPY(&coreotn_var_clean->tx_lo_chnl_ctxt[lo_chnl_itr],
                                           &coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr],
                                           sizeof(coreotn_chnl_molo_ctxt_t));
                                coreotn_var_clean->tx_lo_chnl_ctxt[lo_chnl_itr].sub_chnls_prov_cnt = coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].sub_chnls_prov_cnt;
                                coreotn_var_clean->stg3b_odu_level[lo_chnl_itr] = ODU_STRUCT_LEVEL_LO_ODU;
                                coreotn_var_clean->prev_fo1_rfrm_maint_sig[lo_chnl_itr] = coreotn_handle->var.prev_fo1_rfrm_maint_sig[lo_chnl_itr];
                                coreotn_var_clean->dummy_fo1_maint_sig[lo_chnl_itr] = coreotn_handle->var.dummy_fo1_maint_sig[lo_chnl_itr];

                            }  
                        } else 
                        {
                            rc = COREOTN_ERR_CONTEXT_CLEANUP;    
                        }
                    }
                }
            }
        }

        /* restore dummy entry context */
        {
            UINT32 entry_itr;
            for (entry_itr = 0; entry_itr < UTIL_GLOBAL_MAX_DMX_DUMMY_SCHD;entry_itr++)
            {
                if (coreotn_handle->odtu_mux2_handle->var.dummy_schd_entry[entry_itr].dummy_cal_entry != 0x7F)
                {
                    coreotn_var_clean->extra_entry_ctxt[entry_itr].entry_state = TRUE;
                    coreotn_var_clean->extra_entry_ctxt[entry_itr].chnl_id = coreotn_handle->odtu_mux2_handle->var.dummy_schd_entry[entry_itr].dummy_mo_ch_id;
                    coreotn_var_clean->extra_entry_ctxt[entry_itr].cycle = coreotn_handle->odtu_mux2_handle->var.dummy_schd_entry[entry_itr].dummy_cal_entry;
                }
            }
        }
        /* audit PRBS */
        {
            UINT32 prbs_itr, chnl_itr;
            for (prbs_itr = 0; prbs_itr <  LAST_COREOTN_PRBS_INST;prbs_itr++)
            {
                for (chnl_itr = 0;chnl_itr < COREOTN_PRBS_NUM_CHNL;chnl_itr++)
                {
                    coreotn_var_clean->prbs_chnl_prov[prbs_itr][chnl_itr] = coreotn_var_reg->var.prbs_chnl_prov[prbs_itr][chnl_itr];
                }

                for (chnl_itr = 0;chnl_itr < COREOTN_MAX_NUM_LO_CHNL;chnl_itr++)
                {
                    coreotn_var_clean->prev_pm_mode[prbs_itr][chnl_itr] = coreotn_var_reg->var.prev_pm_mode[prbs_itr][chnl_itr];
                }
            }
        }        
    }

    PMC_RETURN(rc);
} /* coreotn_ctxt_audit */

/*******************************************************************************
* coreotn_ctxt_cleanup
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function put in place the cleaned var_t context. The register and 
*   memory context of channels that are not in OPERATIONAL state are cleaned 
*
* INPUTS:
*   *coreotn_handle        - pointer to MAPOTN handle instance to be operated on
*   *restart_init_cfg_ptr       - pointer to restart init config
*   *coreotn_var_reg       - A partial coreotn_var_t context + additional
*                           information to facilite audit phase
*   *coreotn_var_clean     - A clean context which represents the intersection
*                           between both context is also generated.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS: There is no error case in this function (not yet)
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_ctxt_cleanup(coreotn_handle_t *coreotn_handle,
                                       util_global_restart_init_cfg_t *restart_init_cfg_ptr,
                                       coreotn_recover_var_t *coreotn_var_reg,
                                       coreotn_var_t *coreotn_var_clean)
{
    PMC_ERROR rc = PMC_SUCCESS;
    
    UINT32 stg3b_rx_chnl_to_keep[COREOTN_NUM_CHNL];   
    UINT32 num_rx_stg3b_chnl_to_keep = 0;
    PMC_ENTRY();

    /* the old mapotn var context is incoherent, we use the new one */
    PMC_MEMCPY(&coreotn_handle->var,coreotn_var_clean,sizeof(coreotn_var_t));

    /* resync energy state */           
    coreotn_init(coreotn_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL,COREOTN_STG4);
    coreotn_init(coreotn_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL,COREOTN_ODUKP);
    coreotn_init(coreotn_handle, PMC_ENERGY_STATE_REQUEST_OPTIMAL,COREOTN_ODUKSW);
    
    /* Perform regiter cleanup and sub-blocks memory context cleanup */
    if (coreotn_start_state_test(coreotn_handle) == FALSE)
    {
        /* clean stage 4 */
        {
            UINT32 chnl_itr;    
            UINT32 stg4_rx_chnl_to_clean[COREOTN_NUM_CHNL];
            UINT32 num_stg4_rx_chnl_to_clean = 0;
            UINT32 stg4_tx_chnl_to_clean[COREOTN_NUM_CHNL];
            UINT32 num_stg4_tx_chnl_to_clean = 0;

            for (chnl_itr = 0; chnl_itr<COREOTN_MAX_NUM_LO_CHNL; chnl_itr++)
            {
                if (coreotn_handle->var.rx_stg4_chnl_prov[chnl_itr] == FALSE)
                {
                    stg4_rx_chnl_to_clean[num_stg4_rx_chnl_to_clean] = chnl_itr;
                    num_stg4_rx_chnl_to_clean += 1;
                }
                if (coreotn_handle->var.tx_stg4_chnl_prov[chnl_itr] == FALSE)
                {
                    stg4_tx_chnl_to_clean[num_stg4_tx_chnl_to_clean] = chnl_itr;
                    num_stg4_tx_chnl_to_clean += 1;
                }

            }
            /* STG4 */
            odu_rfrm_chnl_clean(coreotn_handle->odu_rfrm_stg4_handle,stg4_rx_chnl_to_clean, num_stg4_rx_chnl_to_clean);
            odu_tfrm_chnl_clean(coreotn_handle->odu_tfrm_stg4_handle,stg4_tx_chnl_to_clean, num_stg4_tx_chnl_to_clean);
            coreotn_odu_rcp_ohp_cleanup(coreotn_handle,TRUE,ODU_STRUCT_FRM_STG4,stg4_rx_chnl_to_clean, num_stg4_rx_chnl_to_clean);
            coreotn_odu_rcp_ohp_cleanup(coreotn_handle,FALSE,ODU_STRUCT_FRM_STG4,stg4_tx_chnl_to_clean, num_stg4_tx_chnl_to_clean);
        }
               
        
        /* ODUKP 
           MUX/DMX are already cleaned
           SYSOTN is not supported 
        */
        if (coreotn_odukp_start_state_test(coreotn_handle) == FALSE)
        {    
            UINT32 ho_chnl_itr, mo_chnl_itr, lo_chnl_itr;
            UINT32 stg1_tx_chnl_to_keep[COREOTN_NUM_CHNL];
            UINT32 stg1_rx_chnl_to_keep[COREOTN_NUM_CHNL];
            UINT32 stgN_tx_chnl_to_keep[COREOTN_NUM_CHNL];
            UINT32 stgN_rx_chnl_to_keep[COREOTN_NUM_CHNL];
            UINT32 stg2_tx_chnl_to_keep[COREOTN_NUM_CHNL];
            UINT32 stg2_rx_chnl_to_keep[COREOTN_NUM_CHNL];        
            UINT32 stg3a_rx_chnl_to_keep[COREOTN_NUM_CHNL];
            UINT32 stg3a_tx_chnl_to_keep[COREOTN_NUM_CHNL];

            UINT32 stg3b_tx_chnl_to_keep[COREOTN_NUM_CHNL];      
            UINT32 odujat1_chnl_to_keep[COREOTN_NUM_CHNL],odujat2_chnl_to_keep[COREOTN_NUM_CHNL];
            UINT32 oduksc1_chnl_to_keep[COREOTN_NUM_CHNL],oduksc2_chnl_to_keep[COREOTN_NUM_CHNL];
            UINT32 num_tx_stg1_chnl_to_keep = 0;
            UINT32 num_rx_stg1_chnl_to_keep = 0;
            UINT32 num_tx_stgN_chnl_to_keep = 0;
            UINT32 num_rx_stgN_chnl_to_keep = 0;
            UINT32 num_tx_stg2_chnl_to_keep = 0;
            UINT32 num_rx_stg2_chnl_to_keep = 0;
            UINT32 num_tx_stg3a_chnl_to_keep = 0;
            UINT32 num_rx_stg3a_chnl_to_keep = 0;
            UINT32 num_tx_stg3b_chnl_to_keep = 0;
            UINT32 num_oduksc1_chnl_to_keep = 0;
            UINT32 num_oduksc2_chnl_to_keep = 0;
            UINT32 num_odujat1_chnl_to_keep = 0;
            UINT32 num_odujat2_chnl_to_keep = 0;
            UINT32 clean_chnl_list[COREOTN_NUM_CHNL];
            UINT32 num_clean;
            UINT8 line_odu_tx_maint_sig[COREOTN_NUM_CHNL] = { 0 };
            UINT8 sys_odu_tx_maint_sig[COREOTN_NUM_CHNL] = { 0 };
            UINT8 *lineotn_tx_maint_sig = NULL;
            BOOL8 check_unchannelized_tx_maint_sig = (restart_init_cfg_ptr->opaque != NULL);
            if (check_unchannelized_tx_maint_sig == TRUE)
            {
                lineotn_tx_maint_sig = (UINT8*) restart_init_cfg_ptr->opaque; /* 0-11 -> LINEOTN , 12 == SYSOTN */
            }
            /* 
               identify items to keep  
               we use recover information from mux/demux
               the information in coreotn context is often partial and not stable
            */


            if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE
                || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
            {
                /* from LINEOTN */
                if (coreotn_var_reg->energy_state_reg.fmf1.tfrm12  == PMC_ENERGY_STATE_RUNNING && 
                    coreotn_var_reg->energy_state_reg.fmf1.rfrm12  == PMC_ENERGY_STATE_RUNNING && 
                    coreotn_var_reg->energy_state_reg.fmf1.tfrm96  == PMC_ENERGY_STATE_RUNNING && 
                    coreotn_var_reg->energy_state_reg.fmf1.rfrm96  == PMC_ENERGY_STATE_RUNNING)
                {
                    for (ho_chnl_itr = 0; ho_chnl_itr<COREOTN_MAX_NUM_HO_CHNL; ho_chnl_itr++)
                    {
                        if (coreotn_handle->var.sysapp_line_state[ho_chnl_itr] == COREOTN_CHNL_OPERATIONAL)
                        {
                            stg1_rx_chnl_to_keep[num_rx_stg1_chnl_to_keep] = ho_chnl_itr;
                            num_rx_stg1_chnl_to_keep += 1;    
                            stg1_tx_chnl_to_keep[num_tx_stg1_chnl_to_keep] = ho_chnl_itr;
                            num_tx_stg1_chnl_to_keep += 1;  
                            stg2_rx_chnl_to_keep[num_rx_stg2_chnl_to_keep] = ho_chnl_itr;
                            num_rx_stg2_chnl_to_keep += 1;    
                            if (TRUE == check_unchannelized_tx_maint_sig)
                            {
                                /* get active maintenance signals */
                                (void) odu_tfrm_chnl_maint_sig_get(coreotn_handle->odu_tfrm_stg1_handle,                            
                                                                   ho_chnl_itr,
                                                                   &line_odu_tx_maint_sig[num_rx_stg2_chnl_to_keep-1]);
                                line_odu_tx_maint_sig[num_rx_stg2_chnl_to_keep-1] = (lineotn_tx_maint_sig[ho_chnl_itr] == 3)?3:line_odu_tx_maint_sig[num_rx_stg2_chnl_to_keep-1];                            
                            }
                            stg2_tx_chnl_to_keep[num_tx_stg2_chnl_to_keep] = ho_chnl_itr;
                            num_tx_stg2_chnl_to_keep += 1;  


                        }
                    }
                }
                

                /* from SYSOTN */
                if (coreotn_var_reg->energy_state_reg.fmf2.odtu_dmx == PMC_ENERGY_STATE_RESET && 
                    coreotn_var_reg->energy_state_reg.fmf2.rfrm12 == PMC_ENERGY_STATE_RUNNING)
                {
                    for (ho_chnl_itr = 0; ho_chnl_itr<1; ho_chnl_itr++)
                    {
                        if (coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_itr].chnl_state == COREOTN_CHNL_OPERATIONAL)
                        {
                            stgN_rx_chnl_to_keep[num_rx_stgN_chnl_to_keep] = ho_chnl_itr;
                            num_rx_stgN_chnl_to_keep += 1;    
                            /* stage 3b */
                            stg3b_tx_chnl_to_keep[num_tx_stg3b_chnl_to_keep] = ho_chnl_itr;
                            num_tx_stg3b_chnl_to_keep += 1;  
                        }
                    }
                } else 
                {
                    for (ho_chnl_itr = 0; ho_chnl_itr<1; ho_chnl_itr++)
                    {        
                        /* HO stage */
                        if (coreotn_var_reg->dmx2.var.ho_chnl_cfg[ho_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL)
                        {                        
                            stgN_rx_chnl_to_keep[num_rx_stgN_chnl_to_keep] = ho_chnl_itr;
                            num_rx_stgN_chnl_to_keep += 1;    
                            if (UTIL_GLOBAL_ODU_UNCHANNELIZED == coreotn_var_reg->dmx2.var.ho_chnl_cfg[ho_chnl_itr].ts_type)
                            {
                                /* stage 3b */

                                /*   */
                                stg3b_tx_chnl_to_keep[num_tx_stg3b_chnl_to_keep] = ho_chnl_itr;
                                num_tx_stg3b_chnl_to_keep += 1;  

                                if (coreotn_var_reg->energy_state_reg.fmf2.odtu_dmx != PMC_ENERGY_STATE_RESET)
                                {
                                    /* FMF2 is present */
                                    stg3a_rx_chnl_to_keep[num_rx_stg3a_chnl_to_keep] = ho_chnl_itr;
                                    num_rx_stg3a_chnl_to_keep += 1;                
                                    odujat2_chnl_to_keep[num_odujat2_chnl_to_keep] = ho_chnl_itr;
                                    num_odujat2_chnl_to_keep += 1;
                                    oduksc2_chnl_to_keep[num_oduksc2_chnl_to_keep] = ho_chnl_itr;
                                    num_oduksc2_chnl_to_keep += 1;                                 
                                }                                                        
                            } else 
                            {
                                /* MO stage */
                                for (mo_chnl_itr = 0; mo_chnl_itr<COREOTN_MAX_NUM_LO_CHNL; mo_chnl_itr++)
                                {
                                    if (coreotn_var_reg->dmx2.var.lo_chnl_cfg[mo_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL && 
                                        coreotn_var_reg->dmx2.var.lo_chnl_cfg[mo_chnl_itr].ho_chnl_id == ho_chnl_itr)
                                    {
                                        /* stage 3b */

                                        stg3b_tx_chnl_to_keep[num_tx_stg3b_chnl_to_keep] = mo_chnl_itr;
                                        num_tx_stg3b_chnl_to_keep += 1;  

                                        if (coreotn_var_reg->energy_state_reg.fmf2.odtu_dmx != PMC_ENERGY_STATE_RESET)
                                        {
                                            /* FMF2 is present */
                                            stg3a_rx_chnl_to_keep[num_rx_stg3a_chnl_to_keep] = mo_chnl_itr;
                                            num_rx_stg3a_chnl_to_keep += 1;             
                                            odujat2_chnl_to_keep[num_odujat2_chnl_to_keep] = mo_chnl_itr;
                                            num_odujat2_chnl_to_keep += 1;
                                            oduksc2_chnl_to_keep[num_oduksc2_chnl_to_keep] = mo_chnl_itr;
                                            num_oduksc2_chnl_to_keep += 1;
                                            if (coreotn_var_reg->dmx2.var.ho_chnl_cfg[ho_chnl_itr].ts_type == UTIL_GLOBAL_ODU_TS_2G5)
                                            {
                                                stg3a_rx_chnl_to_keep[num_rx_stg3a_chnl_to_keep] = mo_chnl_itr + 48;
                                                num_rx_stg3a_chnl_to_keep += 1;             
                                                odujat2_chnl_to_keep[num_odujat2_chnl_to_keep] = mo_chnl_itr + 48;
                                                num_odujat2_chnl_to_keep += 1;
                                                oduksc2_chnl_to_keep[num_oduksc2_chnl_to_keep] = mo_chnl_itr + 48;
                                                num_oduksc2_chnl_to_keep += 1;
                                            }
                                        }
                                    }
                                }                                 
                            }
                        }
                    }
                }
                /* TX side */
                
                if (coreotn_var_reg->energy_state_reg.fmf2.odtu_mux == PMC_ENERGY_STATE_RESET && 
                    coreotn_var_reg->energy_state_reg.fmf2.tfrm12 == PMC_ENERGY_STATE_RUNNING)
                {
                    for (ho_chnl_itr = 0; ho_chnl_itr<1; ho_chnl_itr++)
                    {
                        if (coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_itr].chnl_state     == COREOTN_CHNL_OPERATIONAL)
                        {
                            stgN_tx_chnl_to_keep[num_tx_stgN_chnl_to_keep] = ho_chnl_itr;                          
                            num_tx_stgN_chnl_to_keep += 1;   
                            /* stage 3b */
                            stg3b_rx_chnl_to_keep[num_rx_stg3b_chnl_to_keep] = ho_chnl_itr;
                            num_rx_stg3b_chnl_to_keep += 1;   
                            if (TRUE == check_unchannelized_tx_maint_sig)
                            {
                                /* get active maintenance signals */
                                (void) odu_tfrm_chnl_maint_sig_get(coreotn_handle->odu_tfrm_stgN_handle,                            
                                                                   ho_chnl_itr,
                                                                   &sys_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1]);                                                        
                                sys_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1] = (lineotn_tx_maint_sig[12] == 3)?3:sys_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1];
                            }

                        }
                    }
                } else 
                {
                    for (ho_chnl_itr = 0; ho_chnl_itr<1; ho_chnl_itr++)
                    {        
                        /* HO stage */
                        if (coreotn_var_reg->mux2.var.ho_chnl_cfg[ho_chnl_itr].state == (UINT32)ODTU_MUX_CHNL_OPERATIONAL ||
                            coreotn_var_reg->mux2.var.ho_chnl_cfg[ho_chnl_itr].state == (UINT32)ODTU_MUX_CHNL_PASSTHRU)
                        {                        
                            stgN_tx_chnl_to_keep[num_tx_stgN_chnl_to_keep] = ho_chnl_itr;
                            num_tx_stgN_chnl_to_keep += 1;    
                            if (UTIL_GLOBAL_ODU_UNCHANNELIZED == coreotn_var_reg->mux2.var.ho_chnl_cfg[ho_chnl_itr].ts_type)
                            {                              
                                /* stage 3b */
                                stg3b_rx_chnl_to_keep[num_rx_stg3b_chnl_to_keep] = ho_chnl_itr;
                                num_rx_stg3b_chnl_to_keep += 1;    
                                if (TRUE == check_unchannelized_tx_maint_sig)
                                {
                                    /* get active maintenance signals */
                                    (void) odu_tfrm_chnl_maint_sig_get(coreotn_handle->odu_tfrm_stgN_handle,                            
                                                                       ho_chnl_itr,
                                                                       &sys_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1]);
                                    sys_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1] = (lineotn_tx_maint_sig[12] == 3)?3:sys_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1];
                                }
                                if (coreotn_var_reg->energy_state_reg.fmf2.odtu_mux != PMC_ENERGY_STATE_RESET)
                                {
                                    /* FMF2 is present */
                                    stg3a_tx_chnl_to_keep[num_tx_stg3a_chnl_to_keep] = ho_chnl_itr;
                                    num_tx_stg3a_chnl_to_keep += 1;      
                                }
                            } else 
                            {
                                /* MO stage */
                                for (mo_chnl_itr = 0; mo_chnl_itr<COREOTN_MAX_NUM_LO_CHNL; mo_chnl_itr++)
                                {
                                    if (coreotn_var_reg->mux2.var.lo_chnl_cfg[mo_chnl_itr].state == (UINT32)ODTU_MUX_CHNL_OPERATIONAL && 
                                        coreotn_var_reg->mux2.var.lo_chnl_cfg[mo_chnl_itr].ho_chnl_id == ho_chnl_itr)
                                    {
                                        /* stage 3b */

                                        stg3b_rx_chnl_to_keep[num_rx_stg3b_chnl_to_keep] = mo_chnl_itr;
                                        num_rx_stg3b_chnl_to_keep += 1;  

                                        if (coreotn_var_reg->energy_state_reg.fmf2.odtu_mux != PMC_ENERGY_STATE_RESET)
                                        {
                                            if (TRUE == check_unchannelized_tx_maint_sig)
                                            {
                                                /* get active maintenance signals */
                                                (void) odu_tfrm_chnl_maint_sig_get(coreotn_handle->odu_tfrm_stg3a_handle,
                                                                                   mo_chnl_itr,
                                                                                   &sys_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1]);
                                            }
                                            /* FMF2 is present */
                                            stg3a_tx_chnl_to_keep[num_tx_stg3a_chnl_to_keep] = mo_chnl_itr;                                            
                                            num_tx_stg3a_chnl_to_keep += 1;   
                                            if (UTIL_GLOBAL_ODU_TS_2G5  == coreotn_var_reg->mux1.var.ho_chnl_cfg[ho_chnl_itr].ts_type)
                                            {
                                                stg3a_tx_chnl_to_keep[num_tx_stg3a_chnl_to_keep] = mo_chnl_itr + 48;
                                                num_tx_stg3a_chnl_to_keep += 1;   
                                            }
                                        }                                     
                                    }
                                }
                            }
                        }
                    }
                }                                                               
            } else 
            {             
                /* Handle the case where both muxing stages are in power down */
            
                /* RX side */
                if (coreotn_var_reg->energy_state_reg.fmf1.odtu_dmx == PMC_ENERGY_STATE_RESET && 
                    coreotn_var_reg->energy_state_reg.fmf2.odtu_dmx == PMC_ENERGY_STATE_RESET && 
                    coreotn_var_reg->energy_state_reg.fmf1.rfrm12 == PMC_ENERGY_STATE_RUNNING)
                {
                    for (ho_chnl_itr = 0; ho_chnl_itr<COREOTN_MAX_NUM_HO_CHNL; ho_chnl_itr++)
                    {
                        if (coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_itr].chnl_state == COREOTN_CHNL_OPERATIONAL)
                        {
                            stg1_rx_chnl_to_keep[num_rx_stg1_chnl_to_keep] = ho_chnl_itr;
                            num_rx_stg1_chnl_to_keep += 1;    
                            /* stage 3b */
                            stg3b_tx_chnl_to_keep[num_tx_stg3b_chnl_to_keep] = ho_chnl_itr;
                            num_tx_stg3b_chnl_to_keep += 1;                              
                        }
                    }
                } else 
                {
                    for (ho_chnl_itr = 0; ho_chnl_itr<COREOTN_MAX_NUM_HO_CHNL; ho_chnl_itr++)
                    {        
                        /* HO stage */
                        if (coreotn_var_reg->dmx1.var.ho_chnl_cfg[ho_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL)
                        {                        
                            stg1_rx_chnl_to_keep[num_rx_stg1_chnl_to_keep] = ho_chnl_itr;
                            num_rx_stg1_chnl_to_keep += 1;    
                            if (UTIL_GLOBAL_ODU_UNCHANNELIZED == coreotn_var_reg->dmx1.var.ho_chnl_cfg[ho_chnl_itr].ts_type)
                            {
                                /* stage 3b */
                                stg3b_tx_chnl_to_keep[num_tx_stg3b_chnl_to_keep] = ho_chnl_itr;
                                num_tx_stg3b_chnl_to_keep += 1;  
                                if (coreotn_var_reg->energy_state_reg.fmf1.odtu_dmx != PMC_ENERGY_STATE_RESET)
                                {
                                    /* FMF1 is present */
                                    stg2_rx_chnl_to_keep[num_rx_stg2_chnl_to_keep] = ho_chnl_itr;
                                    num_rx_stg2_chnl_to_keep += 1;             
                                    odujat1_chnl_to_keep[num_odujat1_chnl_to_keep] = ho_chnl_itr;
                                    num_odujat1_chnl_to_keep += 1;
                                    oduksc1_chnl_to_keep[num_oduksc1_chnl_to_keep] = ho_chnl_itr;
                                    num_oduksc1_chnl_to_keep += 1;
                                }
                                if (coreotn_var_reg->energy_state_reg.fmf2.odtu_dmx != PMC_ENERGY_STATE_RESET)
                                {
                                    /* FMF2 is present */
                                    stg3a_rx_chnl_to_keep[num_rx_stg3a_chnl_to_keep] = ho_chnl_itr;
                                    num_rx_stg3a_chnl_to_keep += 1;                
                                    odujat2_chnl_to_keep[num_odujat2_chnl_to_keep] = ho_chnl_itr;
                                    num_odujat2_chnl_to_keep += 1;
                                    oduksc2_chnl_to_keep[num_oduksc2_chnl_to_keep] = ho_chnl_itr;
                                    num_oduksc2_chnl_to_keep += 1;                                 
                                }
                            
                            
                            } else 
                            {
                                /* MO stage */
                                for (mo_chnl_itr = 0; mo_chnl_itr<COREOTN_MAX_NUM_LO_CHNL; mo_chnl_itr++)
                                {
                                    if (coreotn_var_reg->dmx1.var.lo_chnl_cfg[mo_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL && 
                                        coreotn_var_reg->dmx1.var.lo_chnl_cfg[mo_chnl_itr].ho_chnl_id == ho_chnl_itr)
                                    {
                                        if (coreotn_var_reg->energy_state_reg.fmf1.odtu_dmx != PMC_ENERGY_STATE_RESET)
                                        {
                                            /* FMF1 is present */
                                            stg2_rx_chnl_to_keep[num_rx_stg2_chnl_to_keep] = mo_chnl_itr;
                                            num_rx_stg2_chnl_to_keep += 1;             
                                            odujat1_chnl_to_keep[num_odujat1_chnl_to_keep] = mo_chnl_itr;
                                            num_odujat1_chnl_to_keep += 1;
                                            oduksc1_chnl_to_keep[num_oduksc1_chnl_to_keep] = mo_chnl_itr;
                                            num_oduksc1_chnl_to_keep += 1;
                                            if (coreotn_var_reg->dmx1.var.ho_chnl_cfg[ho_chnl_itr].ts_type == UTIL_GLOBAL_ODU_TS_2G5)
                                            {
                                                stg2_rx_chnl_to_keep[num_rx_stg2_chnl_to_keep] = mo_chnl_itr + 48;
                                                num_rx_stg2_chnl_to_keep += 1;             
                                                odujat1_chnl_to_keep[num_odujat1_chnl_to_keep] = mo_chnl_itr + 48;
                                                num_odujat1_chnl_to_keep += 1;
                                                oduksc1_chnl_to_keep[num_oduksc1_chnl_to_keep] = mo_chnl_itr + 48;
                                                num_oduksc1_chnl_to_keep += 1;
                                            }
                                        }
                                     
                                        if (coreotn_var_reg->energy_state_reg.fmf2.odtu_dmx == PMC_ENERGY_STATE_RESET)
                                        {
                                            /* stage 3b */
                                            stg3b_tx_chnl_to_keep[num_tx_stg3b_chnl_to_keep] = mo_chnl_itr;
                                            num_tx_stg3b_chnl_to_keep += 1;  
                                        } else 
                                        {
                                            /* we have an LO stage */
                                            if (coreotn_var_reg->dmx2.var.ho_chnl_cfg[mo_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL)
                                            {
                                                if (UTIL_GLOBAL_ODU_UNCHANNELIZED == coreotn_var_reg->dmx2.var.ho_chnl_cfg[mo_chnl_itr].ts_type)
                                                {
                                                    /* stage 3b */
                                                    stg3b_tx_chnl_to_keep[num_tx_stg3b_chnl_to_keep] = mo_chnl_itr;
                                                    num_tx_stg3b_chnl_to_keep += 1;  
                                                    /* FMF2 is present */
                                                    stg3a_rx_chnl_to_keep[num_rx_stg3a_chnl_to_keep] = mo_chnl_itr;
                                                    num_rx_stg3a_chnl_to_keep += 1;                
                                                    odujat2_chnl_to_keep[num_odujat2_chnl_to_keep] = mo_chnl_itr;
                                                    num_odujat2_chnl_to_keep += 1;
                                                    oduksc2_chnl_to_keep[num_oduksc2_chnl_to_keep] = mo_chnl_itr;
                                                    num_oduksc2_chnl_to_keep += 1;
                                                } else 
                                                {
                                                    /* LO stage */
                                                    for (lo_chnl_itr = 0; lo_chnl_itr<COREOTN_MAX_NUM_LO_CHNL; lo_chnl_itr++)
                                                    {
                                                        if (coreotn_var_reg->dmx2.var.lo_chnl_cfg[lo_chnl_itr].state == (UINT32)ODTU_DMX_CHNL_OPERATIONAL && 
                                                            coreotn_var_reg->dmx2.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id == mo_chnl_itr)
                                                        {
                                                            /* stage 3b */
                                                            stg3b_tx_chnl_to_keep[num_tx_stg3b_chnl_to_keep] = lo_chnl_itr;
                                                            num_tx_stg3b_chnl_to_keep += 1;  
                                                            /* FMF2 is present */
                                                            stg3a_rx_chnl_to_keep[num_rx_stg3a_chnl_to_keep] = lo_chnl_itr;
                                                            num_rx_stg3a_chnl_to_keep += 1;                
                                                            odujat2_chnl_to_keep[num_odujat2_chnl_to_keep] = lo_chnl_itr;
                                                            num_odujat2_chnl_to_keep += 1;
                                                            oduksc2_chnl_to_keep[num_oduksc2_chnl_to_keep] = lo_chnl_itr;
                                                            num_oduksc2_chnl_to_keep += 1;
                                                            if (UTIL_GLOBAL_ODU_TS_2G5 == coreotn_var_reg->dmx2.var.ho_chnl_cfg[mo_chnl_itr].ts_type)
                                                            {
                                                                stg3a_rx_chnl_to_keep[num_rx_stg3a_chnl_to_keep] = lo_chnl_itr + 48;
                                                                num_rx_stg3a_chnl_to_keep += 1;                
                                                                odujat2_chnl_to_keep[num_odujat2_chnl_to_keep] = lo_chnl_itr + 48;
                                                                num_odujat2_chnl_to_keep += 1;
                                                                oduksc2_chnl_to_keep[num_oduksc2_chnl_to_keep] = lo_chnl_itr + 48;
                                                                num_oduksc2_chnl_to_keep += 1;
                                                            }                                                                                                                                                                           
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            
                /* TX side */
                if (coreotn_var_reg->energy_state_reg.fmf1.odtu_mux == PMC_ENERGY_STATE_RESET && 
                    coreotn_var_reg->energy_state_reg.fmf2.odtu_mux == PMC_ENERGY_STATE_RESET && 
                    coreotn_var_reg->energy_state_reg.fmf1.tfrm12 == PMC_ENERGY_STATE_RUNNING)
                {
                    for (ho_chnl_itr = 0; ho_chnl_itr<COREOTN_MAX_NUM_HO_CHNL; ho_chnl_itr++)
                    {
                        if (coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_itr].chnl_state     == COREOTN_CHNL_OPERATIONAL)
                        {
                            stg1_tx_chnl_to_keep[num_tx_stg1_chnl_to_keep] = ho_chnl_itr;
                            num_tx_stg1_chnl_to_keep += 1;   
                            /* stage 3b */                            
                            stg3b_rx_chnl_to_keep[num_rx_stg3b_chnl_to_keep] = ho_chnl_itr;
                            num_rx_stg3b_chnl_to_keep += 1;   
                            if (TRUE == check_unchannelized_tx_maint_sig)
                            {
                                /* get active maintenance signals */
                                (void) odu_tfrm_chnl_maint_sig_get(coreotn_handle->odu_tfrm_stg1_handle,
                                                                   ho_chnl_itr,
                                                                   &line_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1]);
                                line_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1] = (lineotn_tx_maint_sig[ho_chnl_itr] == 3)?3:line_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1];
                            }
                        }
                    }
                } else 
                {
                    for (ho_chnl_itr = 0; ho_chnl_itr<COREOTN_MAX_NUM_HO_CHNL; ho_chnl_itr++)
                    {        
                        /* HO stage */
                        if (coreotn_var_reg->mux1.var.ho_chnl_cfg[ho_chnl_itr].state == (UINT32)ODTU_MUX_CHNL_OPERATIONAL ||
                            coreotn_var_reg->mux1.var.ho_chnl_cfg[ho_chnl_itr].state == (UINT32)ODTU_MUX_CHNL_PASSTHRU)
                        {                        
                            stg1_tx_chnl_to_keep[num_tx_stg1_chnl_to_keep] = ho_chnl_itr;
                            num_tx_stg1_chnl_to_keep += 1;    
                            if (UTIL_GLOBAL_ODU_UNCHANNELIZED == coreotn_var_reg->mux1.var.ho_chnl_cfg[ho_chnl_itr].ts_type)
                            {
                                /* stage 3b */
                                stg3b_rx_chnl_to_keep[num_rx_stg3b_chnl_to_keep] = ho_chnl_itr;
                                num_rx_stg3b_chnl_to_keep += 1;  
                                if (TRUE == check_unchannelized_tx_maint_sig)
                                {
                                    /* get active maintenance signals */
                                    (void) odu_tfrm_chnl_maint_sig_get(coreotn_handle->odu_tfrm_stg1_handle,
                                                                       ho_chnl_itr,
                                                                       &line_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1]);
                                    line_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1] = (lineotn_tx_maint_sig[ho_chnl_itr] == 3)?3:line_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1];
                                }
                                if (coreotn_var_reg->energy_state_reg.fmf1.odtu_mux != PMC_ENERGY_STATE_RESET)
                                {
                                    /* FMF1 is present */
                                    stg2_tx_chnl_to_keep[num_tx_stg2_chnl_to_keep] = ho_chnl_itr;
                                    num_tx_stg2_chnl_to_keep += 1;                                           
                                }
                                if (coreotn_var_reg->energy_state_reg.fmf2.odtu_mux != PMC_ENERGY_STATE_RESET)
                                {
                                    /* FMF2 is present */
                                    stg3a_tx_chnl_to_keep[num_tx_stg3a_chnl_to_keep] = ho_chnl_itr;
                                    num_tx_stg3a_chnl_to_keep += 1;      
                                }
                            } else 
                            {
                                /* MO stage */
                                for (mo_chnl_itr = 0; mo_chnl_itr<COREOTN_MAX_NUM_LO_CHNL; mo_chnl_itr++)
                                {
                                    if (coreotn_var_reg->mux1.var.lo_chnl_cfg[mo_chnl_itr].state == (UINT32)ODTU_MUX_CHNL_OPERATIONAL && 
                                        coreotn_var_reg->mux1.var.lo_chnl_cfg[mo_chnl_itr].ho_chnl_id == ho_chnl_itr)
                                    {
                                        if (coreotn_var_reg->energy_state_reg.fmf1.odtu_mux != PMC_ENERGY_STATE_RESET)
                                        {
                                            /* FMF1 is present */
                                            stg2_tx_chnl_to_keep[num_tx_stg2_chnl_to_keep] = mo_chnl_itr;
                                            num_tx_stg2_chnl_to_keep += 1;   
                                            if (UTIL_GLOBAL_ODU_TS_2G5  == coreotn_var_reg->mux1.var.ho_chnl_cfg[ho_chnl_itr].ts_type)
                                            {
                                                stg2_tx_chnl_to_keep[num_tx_stg2_chnl_to_keep] = mo_chnl_itr + 48;
                                                num_tx_stg2_chnl_to_keep += 1;   
                                            }
                                        }
                                     
                                        if (coreotn_var_reg->energy_state_reg.fmf2.odtu_mux == PMC_ENERGY_STATE_RESET)
                                        {
                                            /* stage 3b */
                                            stg3b_rx_chnl_to_keep[num_rx_stg3b_chnl_to_keep] = mo_chnl_itr;
                                            num_rx_stg3b_chnl_to_keep += 1;  
                                            if (TRUE == check_unchannelized_tx_maint_sig)
                                            {
                                                /* get active maintenance signals */
                                                (void) odu_tfrm_chnl_maint_sig_get(coreotn_handle->odu_tfrm_stg2_handle,
                                                                                   mo_chnl_itr,
                                                                                   &line_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1]);
                                            }
                                        } else 
                                        {
                                            /* we have an LO stage */
                                            if (coreotn_var_reg->mux2.var.ho_chnl_cfg[mo_chnl_itr].state == (UINT32)ODTU_MUX_CHNL_OPERATIONAL ||
                                                coreotn_var_reg->mux2.var.ho_chnl_cfg[mo_chnl_itr].state == (UINT32)ODTU_MUX_CHNL_PASSTHRU
                                                )
                                            {
                                                if (UTIL_GLOBAL_ODU_UNCHANNELIZED == coreotn_var_reg->mux2.var.ho_chnl_cfg[mo_chnl_itr].ts_type)
                                                {
                                                    /* stage 3b */
                                                    stg3b_rx_chnl_to_keep[num_rx_stg3b_chnl_to_keep] = mo_chnl_itr;
                                                    num_rx_stg3b_chnl_to_keep += 1; 
                                                    if (TRUE == check_unchannelized_tx_maint_sig)
                                                    { 
                                                        /* get active maintenance signals */
                                                        (void) odu_tfrm_chnl_maint_sig_get(coreotn_handle->odu_tfrm_stg2_handle,
                                                                                           mo_chnl_itr,
                                                                                           &line_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1]);
                                                    }
                                                    
                                                    /* FMF2 is present */
                                                    stg3a_tx_chnl_to_keep[num_tx_stg3a_chnl_to_keep] = mo_chnl_itr;
                                                    num_tx_stg3a_chnl_to_keep += 1;                                                             
                                                } else 
                                                {
                                                    /* LO stage */
                                                    for (lo_chnl_itr = 0; lo_chnl_itr<COREOTN_MAX_NUM_LO_CHNL; lo_chnl_itr++)
                                                    {
                                                        if (coreotn_var_reg->mux2.var.lo_chnl_cfg[lo_chnl_itr].state == (UINT32)ODTU_MUX_CHNL_OPERATIONAL && 
                                                            coreotn_var_reg->mux2.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id == mo_chnl_itr)
                                                        {
                                                            /* stage 3b */
                                                            stg3b_rx_chnl_to_keep[num_rx_stg3b_chnl_to_keep] = lo_chnl_itr;
                                                            num_rx_stg3b_chnl_to_keep += 1;
                                                            if (TRUE == check_unchannelized_tx_maint_sig)
                                                            {   
                                                                /* get active maintenance signals */
                                                                (void) odu_tfrm_chnl_maint_sig_get(coreotn_handle->odu_tfrm_stg3a_handle,
                                                                                                   lo_chnl_itr,
                                                                                                   &line_odu_tx_maint_sig[num_rx_stg3b_chnl_to_keep-1]);
                                                            }
                                                                
                                                            /* FMF2 is present */
                                                            stg3a_tx_chnl_to_keep[num_tx_stg3a_chnl_to_keep] = lo_chnl_itr;
                                                            num_tx_stg3a_chnl_to_keep += 1;   
                                                            if (UTIL_GLOBAL_ODU_TS_2G5 == coreotn_var_reg->mux2.var.ho_chnl_cfg[mo_chnl_itr].ts_type)
                                                            {
                                                                stg3a_tx_chnl_to_keep[num_tx_stg3a_chnl_to_keep] = lo_chnl_itr + 48;
                                                                num_tx_stg3a_chnl_to_keep += 1;   
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            /* Clean TSBs */
            /* RX STG1 */
            coreotn_keep2clean_list_get(stg1_rx_chnl_to_keep,num_rx_stg1_chnl_to_keep,COREOTN_MAX_NUM_HO_CHNL,clean_chnl_list,&num_clean);
            odu_rfrm_chnl_clean(coreotn_handle->odu_rfrm_stg1_handle,clean_chnl_list,num_clean);
            coreotn_odu_rcp_ohp_cleanup(coreotn_handle,TRUE,ODU_STRUCT_FRM_STG1,clean_chnl_list,num_clean);
            /* TX STG1 */
            coreotn_keep2clean_list_get(stg1_tx_chnl_to_keep,num_tx_stg1_chnl_to_keep,COREOTN_MAX_NUM_HO_CHNL,clean_chnl_list,&num_clean);
            odu_tfrm_chnl_clean(coreotn_handle->odu_tfrm_stg1_handle,clean_chnl_list,num_clean);
            coreotn_odu_rcp_ohp_cleanup(coreotn_handle,FALSE,ODU_STRUCT_FRM_STG1,clean_chnl_list,num_clean);
            
            /* STG 3B */
            /* RX */
            coreotn_keep2clean_list_get(stg3b_rx_chnl_to_keep,num_rx_stg3b_chnl_to_keep,COREOTN_MAX_NUM_LO_CHNL,clean_chnl_list,&num_clean);            
            odu_rfrm_chnl_clean(coreotn_handle->odu_rfrm_stg3b_handle,clean_chnl_list,num_clean);
            coreotn_odu_rcp_ohp_cleanup(coreotn_handle,TRUE,ODU_STRUCT_FRM_STG3B,clean_chnl_list,num_clean);
            /* TX */
            coreotn_keep2clean_list_get(stg3b_tx_chnl_to_keep,num_tx_stg3b_chnl_to_keep,COREOTN_MAX_NUM_LO_CHNL,clean_chnl_list,&num_clean);    
            odu_tfrm_chnl_clean(coreotn_handle->odu_tfrm_stg3b_handle,clean_chnl_list,num_clean);
            coreotn_odu_rcp_ohp_cleanup(coreotn_handle,FALSE,ODU_STRUCT_FRM_STG3B,clean_chnl_list,num_clean);

            if (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE ||
                coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)                
            {
                coreotn_keep2clean_list_get(oduksc1_chnl_to_keep,num_oduksc1_chnl_to_keep,COREOTN_MAX_NUM_LO_CHNL,clean_chnl_list,&num_clean);
                oduksc_chnl_clean(coreotn_handle->oduksc1_handle,clean_chnl_list,num_clean);
                coreotn_keep2clean_list_get(odujat1_chnl_to_keep,num_odujat1_chnl_to_keep,COREOTN_MAX_NUM_LO_CHNL,clean_chnl_list,&num_clean);
                odujat_chnl_clean(coreotn_handle->odujat1_handle,clean_chnl_list,num_clean);
            }
            if (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE ||
                coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE ||
                coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE ||
                coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE )                
            {
                /* STG2 */
                /* RX */
                coreotn_keep2clean_list_get(stg2_rx_chnl_to_keep,num_rx_stg2_chnl_to_keep,COREOTN_MAX_NUM_LO_CHNL,clean_chnl_list,&num_clean);
                odu_rfrm_chnl_clean(coreotn_handle->odu_rfrm_stg2_handle,clean_chnl_list,num_clean);
                coreotn_odu_rcp_ohp_cleanup(coreotn_handle,TRUE,ODU_STRUCT_FRM_STG2,clean_chnl_list,num_clean);
                /* TX */
                coreotn_keep2clean_list_get(stg2_tx_chnl_to_keep,num_tx_stg2_chnl_to_keep,COREOTN_MAX_NUM_LO_CHNL,clean_chnl_list,&num_clean);
                odu_tfrm_chnl_clean(coreotn_handle->odu_tfrm_stg2_handle,clean_chnl_list,num_clean);
                coreotn_odu_rcp_ohp_cleanup(coreotn_handle,FALSE,ODU_STRUCT_FRM_STG2,clean_chnl_list,num_clean);
            }

            if (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE ||
                coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)                
            {
                coreotn_keep2clean_list_get(oduksc2_chnl_to_keep,num_oduksc2_chnl_to_keep,COREOTN_MAX_NUM_LO_CHNL,clean_chnl_list,&num_clean);
                oduksc_chnl_clean(coreotn_handle->oduksc2_handle,clean_chnl_list,num_clean);
                coreotn_keep2clean_list_get(odujat2_chnl_to_keep,num_odujat2_chnl_to_keep,COREOTN_MAX_NUM_LO_CHNL,clean_chnl_list,&num_clean);
                odujat_chnl_clean(coreotn_handle->odujat2_handle,clean_chnl_list,num_clean);
                /* STG3A */
                /* RX */
                coreotn_keep2clean_list_get(stg3a_rx_chnl_to_keep,num_rx_stg3a_chnl_to_keep,COREOTN_MAX_NUM_LO_CHNL,clean_chnl_list,&num_clean);
                odu_rfrm_chnl_clean(coreotn_handle->odu_rfrm_stg3a_handle,clean_chnl_list,num_clean);
                coreotn_odu_rcp_ohp_cleanup(coreotn_handle,TRUE,ODU_STRUCT_FRM_STG3A,clean_chnl_list,num_clean);
                /* TX */
                coreotn_keep2clean_list_get(stg3a_tx_chnl_to_keep,num_tx_stg3a_chnl_to_keep,COREOTN_MAX_NUM_LO_CHNL,clean_chnl_list,&num_clean);
                odu_tfrm_chnl_clean(coreotn_handle->odu_tfrm_stg3a_handle,clean_chnl_list,num_clean);
                coreotn_odu_rcp_ohp_cleanup(coreotn_handle,FALSE,ODU_STRUCT_FRM_STG3A,clean_chnl_list,num_clean);
            }

            if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE ||
                coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
            {
                /* STGN */
                /* RX */
                coreotn_keep2clean_list_get(stgN_rx_chnl_to_keep,num_rx_stgN_chnl_to_keep,1,clean_chnl_list,&num_clean);
                odu_rfrm_chnl_clean(coreotn_handle->odu_rfrm_stgN_handle,clean_chnl_list,num_clean); 
                coreotn_odu_rcp_ohp_cleanup(coreotn_handle,TRUE,ODU_STRUCT_FRM_STGN,clean_chnl_list,num_clean);
                /* TX */
                coreotn_keep2clean_list_get(stgN_tx_chnl_to_keep,num_tx_stgN_chnl_to_keep,1,clean_chnl_list,&num_clean);
                odu_tfrm_chnl_clean(coreotn_handle->odu_tfrm_stgN_handle,clean_chnl_list,num_clean);
                coreotn_odu_rcp_ohp_cleanup(coreotn_handle,FALSE,ODU_STRUCT_FRM_STGN,clean_chnl_list,num_clean);
            }

            /* clean/restore  tx unchannelized signals */
            if (restart_init_cfg_ptr->phase == UTIL_GLOBAL_RESTART_INIT_PHASE_SECOND && 
                TRUE == check_unchannelized_tx_maint_sig)
            {
                UINT8 cur_dummy_signal;
                UINT32 cur_chnl;
                UINT8 cur_odu_tx_maint_sig;
                if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE ||
                    coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
                {
                    /* line side */
                    for (ho_chnl_itr = 0; ho_chnl_itr< num_rx_stg2_chnl_to_keep; ho_chnl_itr++)
                    {
                        cur_chnl =  stg2_rx_chnl_to_keep[ho_chnl_itr];
                        cur_odu_tx_maint_sig = line_odu_tx_maint_sig[ho_chnl_itr];
                        if (cur_odu_tx_maint_sig == 3 ||
                            lineotn_tx_maint_sig[cur_chnl]  == 3 ||
                            coreotn_var_reg->ocpb_connect.chnl[(UINT32) UTIL_GLOBAL_ODUK_PORT_ILKN1][cur_chnl].mst.state != UTIL_GLOBAL_CHNL_OPERATIONAL)
                        {
                            /* we need a dummy signal */
                            coreotn_handle->var.dummy_fmf1_sysotn_maint_sig[cur_chnl] = TRUE;                        
                            (void) odu_rfrm_chnl_maint_sig_get(coreotn_handle->odu_rfrm_stg2_handle,
                                                               cur_chnl,
                                                               &cur_dummy_signal);
                            if (cur_dummy_signal == 0)
                            {
                                /* restore a dummy signal */
                                odu_rfrm_chnl_maint_sig_cfg(coreotn_handle->odu_rfrm_stg2_handle,
                                                            cur_chnl,
                                                            1);
                            }                                
                        }      
                    }
                }
                
                /* stage 3B */
                for (lo_chnl_itr = 0; lo_chnl_itr< num_rx_stg3b_chnl_to_keep; lo_chnl_itr++)
                {
                    cur_chnl = stg3b_rx_chnl_to_keep[lo_chnl_itr];
                    /* SYS SIDE */
                    if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE ||
                        coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
                    {
                        cur_odu_tx_maint_sig = sys_odu_tx_maint_sig[lo_chnl_itr];
                        if (cur_odu_tx_maint_sig == 3 ||
                            coreotn_var_reg->ocpb_connect.chnl[(UINT32) UTIL_GLOBAL_ODUK_PORT_COREOTN][cur_chnl].mst.state != UTIL_GLOBAL_CHNL_OPERATIONAL)
                        {                           
                            /* we need a dummy signal */
                            coreotn_handle->var.dummy_fo1_maint_sig[cur_chnl] = TRUE;                        
                            (void) odu_rfrm_chnl_maint_sig_get(coreotn_handle->odu_rfrm_stg3b_handle,
                                                               cur_chnl,
                                                               &cur_dummy_signal);
                            if (cur_dummy_signal == 0)
                            {
                                /* restore a dummy signal */
                                odu_rfrm_chnl_maint_sig_cfg(coreotn_handle->odu_rfrm_stg3b_handle,
                                                            cur_chnl,
                                                            1);
                            }
                        }
                    } else 
                    {  
                        cur_odu_tx_maint_sig = line_odu_tx_maint_sig[lo_chnl_itr];
                        /* LINE side */
                        if (cur_odu_tx_maint_sig == 3 ||
                            coreotn_var_reg->ocpb_connect.chnl[(UINT32) UTIL_GLOBAL_ODUK_PORT_COREOTN][cur_chnl].mst.state != UTIL_GLOBAL_CHNL_OPERATIONAL)
                        {
                            /* we need a dummy signal */
                            coreotn_handle->var.dummy_fo1_maint_sig[cur_chnl] = TRUE;                        
                            (void) odu_rfrm_chnl_maint_sig_get(coreotn_handle->odu_rfrm_stg3b_handle,
                                                               stg3b_rx_chnl_to_keep[lo_chnl_itr],
                                                               &cur_dummy_signal);
                            if (cur_dummy_signal == 0)
                            {
                                /* restore a dummy signal */
                                odu_rfrm_chnl_maint_sig_cfg(coreotn_handle->odu_rfrm_stg3b_handle,
                                                            stg3b_rx_chnl_to_keep[lo_chnl_itr],
                                                            1);
                            }
                        }
                    }
                }
            }                 

            /* final context resync */
            if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE ||
                coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
            {
                for (lo_chnl_itr = 0; lo_chnl_itr< COREOTN_MAX_NUM_LO_CHNL; lo_chnl_itr++)
                {
                    if (coreotn_handle->var.tx_mo_chnl_ctxt[lo_chnl_itr].chnl_state  == COREOTN_CHNL_IN_PASSTHRU) 
                    {
                        if (coreotn_var_reg->mux2.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id >= COREOTN_MAX_NUM_LO_CHNL  ||                        
                            coreotn_handle->var.tx_ho_chnl_ctxt[coreotn_var_reg->mux2.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL)
                        {
                            coreotn_handle->var.tx_mo_chnl_ctxt[lo_chnl_itr].chnl_state = COREOTN_CHNL_START;
                        }
                    }
                    if (coreotn_handle->var.rx_mo_chnl_ctxt[lo_chnl_itr].chnl_state  == COREOTN_CHNL_IN_PASSTHRU)
                    {
                        if (coreotn_var_reg->dmx2.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id >= COREOTN_MAX_NUM_LO_CHNL  ||
                            coreotn_handle->var.rx_ho_chnl_ctxt[coreotn_var_reg->dmx2.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL)
                        {
                            coreotn_handle->var.rx_mo_chnl_ctxt[lo_chnl_itr].chnl_state = COREOTN_CHNL_START;
                        }
                    }
                }
            } else 
            {
                for (lo_chnl_itr = 0; lo_chnl_itr< COREOTN_MAX_NUM_LO_CHNL; lo_chnl_itr++)
                {
                    if (coreotn_handle->var.tx_mo_chnl_ctxt[lo_chnl_itr].chnl_state  == COREOTN_CHNL_IN_PASSTHRU) 
                    {
                        if (coreotn_var_reg->mux1.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id >= COREOTN_MAX_NUM_LO_CHNL || 
                            coreotn_handle->var.tx_ho_chnl_ctxt[coreotn_var_reg->mux1.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL)
                        {
                            coreotn_handle->var.tx_mo_chnl_ctxt[lo_chnl_itr].chnl_state = COREOTN_CHNL_START;
                        }
                    }
                    if (coreotn_handle->var.rx_mo_chnl_ctxt[lo_chnl_itr].chnl_state  == COREOTN_CHNL_IN_PASSTHRU) 
                    {
                        if (coreotn_var_reg->dmx1.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id >= COREOTN_MAX_NUM_LO_CHNL ||
                            coreotn_handle->var.rx_ho_chnl_ctxt[coreotn_var_reg->dmx1.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL)
                        {
                            coreotn_handle->var.rx_mo_chnl_ctxt[lo_chnl_itr].chnl_state = COREOTN_CHNL_START;
                        }
                    }
                    if (coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnl_state  == COREOTN_CHNL_IN_PASSTHRU) 
                    {
                        if (coreotn_var_reg->mux2.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id >= COREOTN_MAX_NUM_LO_CHNL || 
                            coreotn_handle->var.tx_mo_chnl_ctxt[coreotn_var_reg->mux2.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL)
                        {
                            coreotn_handle->var.tx_lo_chnl_ctxt[lo_chnl_itr].chnl_state = COREOTN_CHNL_START;
                        }
                    }
                    if (coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].chnl_state  == COREOTN_CHNL_IN_PASSTHRU) 
                    {
                        if (coreotn_var_reg->dmx2.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id >= COREOTN_MAX_NUM_LO_CHNL || 
                            coreotn_handle->var.rx_mo_chnl_ctxt[coreotn_var_reg->dmx2.var.lo_chnl_cfg[lo_chnl_itr].ho_chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL)
                        {
                            coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_itr].chnl_state = COREOTN_CHNL_START;
                        }
                    }
                }
            }


            
        }
    

        /* clean ODUKSW */
        {
            UINT32 port_itr, chnl_itr;
            UINT32 chnl_to_clean[COREOTN_NUM_CHNL];
            UINT32 num_chnl_to_clean = 0;
            UINT32 chnl_to_restore[COREOTN_NUM_CHNL];
            UINT32 num_chnl_to_restore = 0;
            mpmo_handle_t *mpmo_hdnl;
            mpma_handle_t *mpma_hdnl;
            UINT32 num_mpmo_mpma_inst = 0;
            UINT32 ho_chnl_itr = 0;
            
            /* input side */
            for (port_itr = (UINT32) COREOTN_ODUKSW_INPUT_SIFD1;port_itr <= COREOTN_ODUKSW_INPUT_LINESIDE_COREOTN;port_itr++)
            {     
                num_mpmo_mpma_inst  = 0;
                switch(port_itr)
                {
                case COREOTN_ODUKSW_INPUT_SIFD1:
                    if (coreotn_var_reg->energy_state_reg.coreotn_ctl.mpma== PMC_ENERGY_STATE_RUNNING)
                    {
                        mpma_hdnl = coreotn_handle->mpma_core_ctl_handle;
                        num_mpmo_mpma_inst = COREOTN_MAX_NUM_HO_CHNL;
                    }
                    break;
                case COREOTN_ODUKSW_INPUT_COREOTN: 
                    if (coreotn_var_reg->energy_state_reg.fo1.mpma == PMC_ENERGY_STATE_RUNNING)
                    {    
                        mpma_hdnl = coreotn_handle->mpma_fo1_handle;
                        num_mpmo_mpma_inst = COREOTN_MAX_NUM_LO_CHNL;
                    }
                    break;
                case COREOTN_ODUKSW_INPUT_MAPOTN: 
                    if (coreotn_var_reg->energy_state_reg.fo2.mpma == PMC_ENERGY_STATE_RUNNING)
                    {
                        mpma_hdnl = coreotn_handle->mpma_fo2_handle;
                        num_mpmo_mpma_inst = COREOTN_MAX_NUM_LO_CHNL;
                    }
                    break;
                case COREOTN_ODUKSW_INPUT_SIFD2: 
                default:
                    /* no OPSA */
                    break;
                }

                if (num_mpmo_mpma_inst != 0)
                {
                    num_chnl_to_clean = 0;
                    for (chnl_itr = 0; chnl_itr<num_mpmo_mpma_inst; chnl_itr++)
                    {                   
                        if (coreotn_handle->var.rx_oduksw_chnl_ctxt[port_itr][chnl_itr].state != COREOTN_CHNL_OPERATIONAL)
                        {
                            chnl_to_clean[num_chnl_to_clean] = chnl_itr;
                            num_chnl_to_clean += 1;
                        }              

                    }
                    mpma_ch_clean(mpma_hdnl,chnl_to_clean,num_chnl_to_clean);
                }
            }

            /* output sides */            
            for (port_itr = (UINT32) COREOTN_ODUKSW_OUTPUT_SIFD1;port_itr <= COREOTN_ODUKSW_OUTPUT_LINESIDE_COREOTN;port_itr++)
            {         
                num_mpmo_mpma_inst  = 0;
                num_chnl_to_restore = 0;
                switch(port_itr)
                {
                case COREOTN_ODUKSW_OUTPUT_SIFD1:                
                    if (coreotn_var_reg->energy_state_reg.coreotn_ctl.mpmo== PMC_ENERGY_STATE_RUNNING)
                    {     
                        mpmo_hdnl = coreotn_handle->mpmo_core_ctl_handle;
                        num_mpmo_mpma_inst = COREOTN_MAX_NUM_HO_CHNL;

                        if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE
                            || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
                        {                        
                            for (ho_chnl_itr = 0; ho_chnl_itr<COREOTN_MAX_NUM_HO_CHNL; ho_chnl_itr++)
                            {
                                if (coreotn_handle->var.sysapp_line_state[ho_chnl_itr] == COREOTN_CHNL_OPERATIONAL)
                                {
                                    chnl_to_restore[num_chnl_to_restore] = ho_chnl_itr;
                                    num_chnl_to_restore += 1;
                                }
                            }
                        }                         
                    }
                    break;
                case COREOTN_ODUKSW_OUTPUT_COREOTN: 
                    if (coreotn_var_reg->energy_state_reg.fo1.mpmo == PMC_ENERGY_STATE_RUNNING)
                    {   
                        mpmo_hdnl = coreotn_handle->mpmo_fo1_handle;
                        num_mpmo_mpma_inst = COREOTN_MAX_NUM_LO_CHNL;
                        PMC_MEMCPY(&chnl_to_restore[0],&stg3b_rx_chnl_to_keep[0],COREOTN_NUM_CHNL*sizeof(UINT32));
                        num_chnl_to_restore = num_rx_stg3b_chnl_to_keep;
                    }
                    break;
                case COREOTN_ODUKSW_OUTPUT_MAPOTN: 
                    if (coreotn_var_reg->energy_state_reg.fo2.mpmo == PMC_ENERGY_STATE_RUNNING)
                    {   
                        mpmo_hdnl = coreotn_handle->mpmo_fo2_handle;
                        num_mpmo_mpma_inst = COREOTN_MAX_NUM_LO_CHNL;
                    }
                    break;
                case COREOTN_ODUKSW_OUTPUT_SIFD2: 
                default:
                    /* no OPSA */
                    break;
                }
                if (num_mpmo_mpma_inst != 0)
                {
                    num_chnl_to_clean = 0;
                    for (chnl_itr = 0; chnl_itr<num_mpmo_mpma_inst; chnl_itr++)
                    {
                        if (coreotn_handle->var.tx_oduksw_chnl_ctxt[port_itr][chnl_itr].state != COREOTN_CHNL_OPERATIONAL)
                        {
                            chnl_to_clean[num_chnl_to_clean] = chnl_itr;
                            num_chnl_to_clean += 1;
                        }                        
                    }                   
                    
                    mpmo_ch_restore_clean(mpmo_hdnl,
                                          chnl_to_clean,num_chnl_to_clean,
                                          chnl_to_restore,num_chnl_to_restore);
                }

            }

        }


        /* clean up PRBS monitor */
        {
            UINT32 prbs_itr, chnl_itr;
            for (prbs_itr = 0; prbs_itr <  LAST_COREOTN_PRBS_INST;prbs_itr++)
            {
                for (chnl_itr = 0;chnl_itr < COREOTN_PRBS_NUM_CHNL;chnl_itr++)
                {
                    if ( coreotn_var_reg->var.prbs_chnl_prov[prbs_itr][chnl_itr] == COREOTN_PRBS_MON_DISABLED)
                    {
                        if (prbs_itr < (UINT32) COREOTN_FO1_PRBS)
                        {
                            coreotn_fmf_field_PRBS_MON_EN_set(NULL, coreotn_handle, prbs_itr, chnl_itr,0);            
                        } else 
                        {
                            coreotn_fo_field_PRBS_MON_EN_set(NULL, coreotn_handle, prbs_itr-2, chnl_itr,0);            
                        }   
                    }
                }
            }

            /* disable interrupts */
            coreotn_fo_field_PRBS_DLSS_E_set(NULL,coreotn_handle,COREOTN_FO_INST_1,0);
            coreotn_fo_field_PRBS_DLSS_E_set(NULL,coreotn_handle,COREOTN_FO_INST_2,0);
            coreotn_fmf_field_PRBS_DLSS_E_set(NULL,coreotn_handle,COREOTN_FMF_INST_1,0);
            coreotn_fmf_field_PRBS_DLSS_E_set(NULL,coreotn_handle,COREOTN_FMF_INST_2,0);
            
        }

       
        /* regenerate tcm_pid_valid vector */
        {
            UINT32 itr, chnl_itr, pm_itr;
            odu_rfrm_handle_t        *rfrm_handle;
            odu_rfrm_pm_tcm_mode_t  tcm_mode;
            
            for ( itr = 0; itr <  LAST_ODU_STRUCT_LEVEL;itr++)
            {
                switch ( (odu_struct_odu_level_t)itr )
                {
                case ODU_STRUCT_LEVEL_HO_ODU:
                    rfrm_handle = coreotn_handle->odu_rfrm_stg1_handle;
                    break;
                    
                case ODU_STRUCT_LEVEL_MO_ODU:
                    rfrm_handle = coreotn_handle->odu_rfrm_stg2_handle;
                    break;
                    
                case ODU_STRUCT_LEVEL_LO_ODU:
                    rfrm_handle = coreotn_handle->odu_rfrm_stg3a_handle;
                    break;
                    
                case ODU_STRUCT_LEVEL_3B_ODU:
                    rfrm_handle = coreotn_handle->odu_rfrm_stg3b_handle;
                    break;
                    
                case ODU_STRUCT_LEVEL_4_ODU:
                    rfrm_handle = coreotn_handle->odu_rfrm_stg4_handle;
                    break;
                case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
                    rfrm_handle = coreotn_handle->odu_rfrm_stgN_handle;
                    break;
                    
                default:
                    break;
                } /* end switch */
                
                for (chnl_itr = 0; chnl_itr<COREOTN_MAX_NUM_LO_CHNL; chnl_itr++)
                {                                
                    for(pm_itr = 0;pm_itr <= 8;pm_itr++)
                    {
                        if (!((itr == ODU_STRUCT_LEVEL_HO_ODU || itr == ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC) && chnl_itr >= COREOTN_MAX_NUM_HO_CHNL))
                        {
                            (void) odu_rfrm_pm_tcmi_mode_get(rfrm_handle,chnl_itr,(odu_rfrm_pm_tcm_id_t)pm_itr,&tcm_mode);
                        }
                        if (tcm_mode != ODU_RFRM_PM_TCM_START)
                        {                            
                            (void) coreotn_tcm_pid_valid_set(coreotn_handle,(odu_struct_odu_level_t)itr,chnl_itr,pm_itr,TRUE);
                        }
                    }
                }
            }
        }        
    }

    PMC_RETURN(rc);
} /* coreotn_ctxt_cleanup */

/*******************************************************************************
* coreotn_odu_rcp_ohp_cleanup
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Convert a list of channel to keep to a list of channel to keep 
*
* INPUTS:
*   *coreotn_handle - pointer to odu ohp handle instance
*   is_rx           - rx or tx database
*   frm_id          - Framer ID
*   clean_chnl_list - The list of channel to clean
*   num_clean       - Number of channel to clean 
*
* OUTPUTS:
*   None 
*
* RETURNS:
*   None
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_odu_rcp_ohp_cleanup(coreotn_handle_t *coreotn_handle,
                                         BOOL is_rx,
                                         odu_struct_frm_id_t frm_id,
                                         UINT32 clean_chnl_list[],
                                         UINT32 num_clean)
{
    UINT32 num_element;
    odu_ohp_handle_t *ohp_handle;
    UINT32 cal_entries[COREOTN_MAX_NUM_LO_CHNL];
    UINT32 cal_entries_per_ch[COREOTN_MAX_NUM_LO_CHNL];
    UINT32 num_cal_entries;
    UINT32 i;
    BOOL odu_rcp_state_test;
    odu_ohp_port_framer_t port_framer = ODU_OHP_PORT_FRAMER_1;
    int ohp_port;
    int ohp;

    PMC_ENTRY();

    odu_rcp_state_test = odu_rcp_start_state_test(coreotn_handle->odu_rcp_handle,ODU_RCP_RI_INST);
    PMC_MEMSET(&cal_entries_per_ch[0],0,sizeof(cal_entries_per_ch));

    if (is_rx == TRUE && odu_rcp_state_test == TRUE)
    {
        if (ODU_STRUCT_FRM_STGN == frm_id || ODU_STRUCT_FRM_STG1 == frm_id)
        {
            num_element = COREOTN_MAX_NUM_HO_CHNL;
        } 
        else 
        {
            num_element = COREOTN_MAX_NUM_LO_CHNL;
        }
        
        for (i = 0; i < num_element; i++)
        {
            (void) coreotn_db_cal_entries_get(coreotn_handle,
                                              FALSE,
                                              TRUE, /* RX_DB=TRUE */
                                              i,
                                              frm_id,
                                              cal_entries, &num_cal_entries);
            cal_entries_per_ch[i] = num_cal_entries;
        } 
    }
    if (odu_rcp_state_test == TRUE)
    {
        odu_rcp_chnl_clean(coreotn_handle->odu_rcp_handle,is_rx,(odu_rcp_frm_id_t) frm_id,
                           &cal_entries_per_ch[0],&clean_chnl_list[0],num_clean);
    }

    /* OHP cleanup */
    /* MAP odu struct frame IDs to OHP */
    switch(frm_id) {
    case ODU_STRUCT_FRM_STG1:  port_framer = ODU_OHP_PORT_FRAMER_1;  break;
    case ODU_STRUCT_FRM_STG2:  port_framer = ODU_OHP_PORT_FRAMER_2;  break;
    case ODU_STRUCT_FRM_STG3A: port_framer = ODU_OHP_PORT_FRAMER_3A; break;
    case ODU_STRUCT_FRM_STG3B: port_framer = ODU_OHP_PORT_FRAMER_3B; break;
    case ODU_STRUCT_FRM_STG4:  port_framer = ODU_OHP_PORT_FRAMER_4;  break;
    case ODU_STRUCT_FRM_STGN:  port_framer = ODU_OHP_PORT_FRAMER_N;  break;
    default: PMC_ASSERT(FALSE,COREOTN_ERR_INVALID_ARG,frm_id,0);
    }
    {
        /* get calendar entries */
        (void) coreotn_db_full_cal_entries_get(coreotn_handle,TRUE,frm_id,
                                               cal_entries, &num_cal_entries);
    }

    /* Find the port with the configured framer */
    for(ohp = ODU_OHP_1; ohp <= ODU_OHP_3; ohp+=1)  
    {
        ohp_handle = coreotn_handle->odu_ohp_handle[ohp];
        for(ohp_port = ODU_OHP_PORT_A; ohp_port <= ODU_OHP_PORT_B;ohp_port+=1) 
        {
            if (ohp_handle->cfg.port_cfg[ohp_port].port_framer == port_framer) 
            {                
                if (odu_ohp_start_state_test(ohp_handle) == FALSE)
                {
                    odu_ohp_chnl_clean(ohp_handle,(odu_ohp_port_t) ohp_port,cal_entries,&clean_chnl_list[0],num_clean);                     
                    break;
                }
            }
        }
    }
    PMC_RETURN();
} /* coreotn_odu_rcp_ohp_cleanup */

/*******************************************************************************
* coreotn_keep2clean_list_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Convert a list of channel to keep to a list of channel to keep 
*
* INPUTS:
*   keep_chnl_list - The list of channel to keep
*   num_keep       - NUmbber of channel to keep 
*   max_num_chnl   - Maximun number of channel
*
* OUTPUTS:
*   clean_chnl_list - The list of channel to clean
*   *num_clean      - NUmbber of channel to clean 
*
* RETURNS:
*   None
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_keep2clean_list_get(UINT32 keep_chnl_list[],
                                         UINT32 num_keep,
                                         UINT32 max_num_chnl,
                                         UINT32 clean_chnl_list[],
                                         UINT32 *num_clean)
{
    UINT32 chnl_itr, keep_itr;
    BOOL8 hit;
    PMC_ENTRY();
    keep_itr = 0;
    *num_clean = 0;
    for (chnl_itr = 0; chnl_itr<max_num_chnl; chnl_itr++)
    {
        hit = FALSE;
        for (keep_itr = 0; keep_itr<num_keep && hit == FALSE; keep_itr++)
        {
            if (chnl_itr == keep_chnl_list[keep_itr])
            {
                hit = TRUE;
            }
        }
        if (FALSE == hit)
        {
            clean_chnl_list[*num_clean] = chnl_itr;
            *num_clean += 1;
        }      
    }
    PMC_RETURN();
}

/*******************************************************************************
* coreotn_energy_coherency_check
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function the energy state coherency based on the register space
*
* INPUTS:
*   *coreotn_handle        - pointer to MAPOTN handle instance to be operated on
*   *coreotn_var_reg       - A partial coreotn_var_t context + additional
*                           information to facilite audit phase
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS: There is no error case in this function 
*   COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT: Energy state is incoherent 
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_energy_coherency_check(coreotn_handle_t *coreotn_handle,
                                                 coreotn_recover_var_t *coreotn_var_reg)
{
    PMC_ERROR rc = PMC_SUCCESS;
    BOOL8 check_ctl_mpma_mpmo = FALSE;
    PMC_ENTRY();


    /* 
       We configure POWER with the following section:
       - STG4
       - ODUKSW
       - ODUKP             
       We use 1 power configuration to determine the state of the section and then 
       we check the coherency of the rest based on init_operation
    */
        
    if (coreotn_var_reg->energy_state_reg.fo2.frm_rcp == PMC_ENERGY_STATE_INCOHERENT ||
        coreotn_var_reg->energy_state_reg.fmf1.rfrm12 == PMC_ENERGY_STATE_INCOHERENT
        )
    {
        rc = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
    } else
    {
        coreotn_var_reg->stg4_energy   = coreotn_var_reg->energy_state_reg.fo2.frm_rcp;
        coreotn_var_reg->odukp_energy  = coreotn_var_reg->energy_state_reg.fmf1.rfrm12;
    }
    
    /* check STG4 */
    if (PMC_SUCCESS == rc)
    {
        if (!(coreotn_var_reg->energy_state_reg.fo2.frm_rcp  == coreotn_var_reg->stg4_energy &&
              coreotn_var_reg->energy_state_reg.fo2.prbs     == coreotn_var_reg->stg4_energy &&
              coreotn_var_reg->energy_state_reg.fo2.mpmo     == coreotn_var_reg->stg4_energy && 
              coreotn_var_reg->energy_state_reg.fo2.mpma     == coreotn_var_reg->stg4_energy && 
              coreotn_var_reg->energy_state_reg.fo2.tfrm     == coreotn_var_reg->stg4_energy &&
              coreotn_var_reg->energy_state_reg.fo2.rfrm     == coreotn_var_reg->stg4_energy))
        {
            rc  = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
        }

        if (PMC_ENERGY_STATE_RUNNING == coreotn_var_reg->stg4_energy)
        {
            /* check that MPMA/MPMO are enabled */
            if (0 == mpmo_enable_get(coreotn_handle->mpmo_fo2_handle) ||
                0 == mpma_enable_get(coreotn_handle->mpma_fo2_handle))
            {
                rc  = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            }
        }
    }
    
    /* check ODUKP data paths */
    if (PMC_SUCCESS == rc)
    {
        /* configure energy state in register space */
        switch (coreotn_var_reg->var.init_operation)
        {
        case COREOTN_SS_OPERATIONAL_MODE:
            /* FMF1 */
            if (!(coreotn_var_reg->energy_state_reg.fmf1.prbs == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.oduksc == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.odujat == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.frm_rcp96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.frm_rcp12 == coreotn_var_reg->odukp_energy &&     
                  coreotn_var_reg->energy_state_reg.fmf1.rfrm12 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.tfrm12 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.rfrm96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.tfrm96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.odtu_dmx == coreotn_var_reg->odukp_energy &&    
                  coreotn_var_reg->energy_state_reg.fmf1.odtu_mux == coreotn_var_reg->odukp_energy))
            {
                rc = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            }   
                    
            /* FMF2 */
            if (!(coreotn_var_reg->energy_state_reg.fmf2.prbs == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.oduksc == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.odujat == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.frm_rcp96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.rfrm96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.tfrm96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.odtu_dmx == coreotn_var_reg->odukp_energy &&    
                  coreotn_var_reg->energy_state_reg.fmf2.odtu_mux == coreotn_var_reg->odukp_energy))
            {
                rc = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            }   

            /*
            ** FO1
            */
            if (!(coreotn_var_reg->energy_state_reg.fo1.frm_rcp  == coreotn_var_reg->odukp_energy &&
                  coreotn_var_reg->energy_state_reg.fo1.prbs     == coreotn_var_reg->odukp_energy &&
                  coreotn_var_reg->energy_state_reg.fo1.mpmo     == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fo1.mpma     == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fo1.tfrm     == coreotn_var_reg->odukp_energy &&
                  coreotn_var_reg->energy_state_reg.fo1.rfrm     == coreotn_var_reg->odukp_energy))
            {
                rc  = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            }

            /*
            ** COREOTN_CTL
            */
            if (!(coreotn_var_reg->energy_state_reg.coreotn_ctl.mpmo     == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.coreotn_ctl.mpma     == coreotn_var_reg->odukp_energy))
            {
                rc  = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            }
            check_ctl_mpma_mpmo = TRUE;
            break;
        case COREOTN_SS_ONE_STAGE_MUXING_MODE:
            /*
            ** FMF1
            */
            if (!(coreotn_var_reg->energy_state_reg.fmf1.prbs == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.oduksc == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.odujat == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.frm_rcp96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.frm_rcp12 == coreotn_var_reg->odukp_energy &&     
                  coreotn_var_reg->energy_state_reg.fmf1.rfrm12 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.tfrm12 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.rfrm96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.tfrm96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.odtu_dmx == coreotn_var_reg->odukp_energy &&    
                  coreotn_var_reg->energy_state_reg.fmf1.odtu_mux == coreotn_var_reg->odukp_energy))
            {
                rc = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            }   

            /* FMF2 */
            if (!(coreotn_var_reg->energy_state_reg.fmf2.prbs == coreotn_var_reg->odukp_energy))
            {
                rc = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            } 

            /* FO1 */
            if (!(coreotn_var_reg->energy_state_reg.fo1.frm_rcp  == coreotn_var_reg->odukp_energy &&
                  coreotn_var_reg->energy_state_reg.fo1.prbs     == coreotn_var_reg->odukp_energy &&
                  coreotn_var_reg->energy_state_reg.fo1.mpmo     == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fo1.mpma     == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fo1.tfrm     == coreotn_var_reg->odukp_energy &&
                  coreotn_var_reg->energy_state_reg.fo1.rfrm     == coreotn_var_reg->odukp_energy))
            {
                rc  = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            }            
            break;
        case COREOTN_SS_SYSOTN_MODE:
            /* FMF1 blocks */   
            if (!(coreotn_var_reg->energy_state_reg.fmf1.prbs == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.frm_rcp96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.frm_rcp12 == coreotn_var_reg->odukp_energy &&     
                  coreotn_var_reg->energy_state_reg.fmf1.rfrm12 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.tfrm12 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.rfrm96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.tfrm96 == coreotn_var_reg->odukp_energy ))
            {
                rc = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            } 

            /*FMF2 blocks (full power) */
            if (!(coreotn_var_reg->energy_state_reg.fmf2.prbs == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.oduksc == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.odujat == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.frm_rcp96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.frm_rcp12 == coreotn_var_reg->odukp_energy &&     
                  coreotn_var_reg->energy_state_reg.fmf2.rfrm12 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.tfrm12 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.rfrm96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.tfrm96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.odtu_dmx == coreotn_var_reg->odukp_energy &&    
                  coreotn_var_reg->energy_state_reg.fmf2.odtu_mux == coreotn_var_reg->odukp_energy))
            {
                rc = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            } 

            /* FO1 blocks */
            if (!(coreotn_var_reg->energy_state_reg.fo1.frm_rcp  == coreotn_var_reg->odukp_energy &&
                  coreotn_var_reg->energy_state_reg.fo1.prbs     == coreotn_var_reg->odukp_energy &&
                  coreotn_var_reg->energy_state_reg.fo1.mpmo     == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fo1.mpma     == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fo1.tfrm     == coreotn_var_reg->odukp_energy &&
                  coreotn_var_reg->energy_state_reg.fo1.rfrm     == coreotn_var_reg->odukp_energy))
            {
                rc  = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            }
            
            /* COREOTN CTL blocks */
            if (!(coreotn_var_reg->energy_state_reg.coreotn_ctl.mpmo     == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.coreotn_ctl.mpma     == coreotn_var_reg->odukp_energy))
            {
                rc  = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            }
            check_ctl_mpma_mpmo = TRUE;
            break;
        case COREOTN_SS_SYSOTN_BYPASS_MODE:
            /* FMF1 blocks */
            if (!(coreotn_var_reg->energy_state_reg.fmf1.prbs == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.frm_rcp96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.frm_rcp12 == coreotn_var_reg->odukp_energy &&     
                  coreotn_var_reg->energy_state_reg.fmf1.rfrm12 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.tfrm12 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.rfrm96 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.tfrm96 == coreotn_var_reg->odukp_energy ))
            {
                rc = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            }  

            /*FMF2 blocks */
            if (!(coreotn_var_reg->energy_state_reg.fmf2.prbs == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.frm_rcp12 == coreotn_var_reg->odukp_energy &&     
                  coreotn_var_reg->energy_state_reg.fmf2.rfrm12 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf2.tfrm12 == coreotn_var_reg->odukp_energy ))
            {
                rc = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            } 
           
            /* FO1 blocks */
            if (!(coreotn_var_reg->energy_state_reg.fo1.frm_rcp  == coreotn_var_reg->odukp_energy &&
                  coreotn_var_reg->energy_state_reg.fo1.prbs     == coreotn_var_reg->odukp_energy &&
                  coreotn_var_reg->energy_state_reg.fo1.mpmo     == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fo1.mpma     == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fo1.tfrm     == coreotn_var_reg->odukp_energy &&
                  coreotn_var_reg->energy_state_reg.fo1.rfrm     == coreotn_var_reg->odukp_energy))
            {
                rc  = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            }

            /* COREOTN CTL blocks */
            if (!(coreotn_var_reg->energy_state_reg.coreotn_ctl.mpmo     == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.coreotn_ctl.mpma     == coreotn_var_reg->odukp_energy))
            {
                rc  = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            }
            check_ctl_mpma_mpmo = TRUE;
            break;
        case COREOTN_SS_BYPASS_MODE:            
            /*
            ** FMF1
            */
            if (!(coreotn_var_reg->energy_state_reg.fmf1.prbs == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.frm_rcp12 == coreotn_var_reg->odukp_energy &&     
                  coreotn_var_reg->energy_state_reg.fmf1.rfrm12 == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fmf1.tfrm12 == coreotn_var_reg->odukp_energy ))
            {
                rc = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            } 

            /*
            ** FMF2
            */
            if (!(coreotn_var_reg->energy_state_reg.fmf2.prbs == coreotn_var_reg->odukp_energy ))
            {
                rc = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            }  

            /*
            ** FO1
            */
            if (!(coreotn_var_reg->energy_state_reg.fo1.frm_rcp  == coreotn_var_reg->odukp_energy &&
                  coreotn_var_reg->energy_state_reg.fo1.prbs     == coreotn_var_reg->odukp_energy &&
                  coreotn_var_reg->energy_state_reg.fo1.mpmo     == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fo1.mpma     == coreotn_var_reg->odukp_energy && 
                  coreotn_var_reg->energy_state_reg.fo1.tfrm     == coreotn_var_reg->odukp_energy &&
                  coreotn_var_reg->energy_state_reg.fo1.rfrm     == coreotn_var_reg->odukp_energy))
            {
                rc  = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            }
            
            break;
        default:
            break;
        }
        
        /* Check MPMO/MPMA */        
        if (PMC_SUCCESS == rc && PMC_ENERGY_STATE_RUNNING == coreotn_var_reg->odukp_energy)
        {
            /* check that MPMA/MPMO are enabled */
            if (0 == mpmo_enable_get(coreotn_handle->mpmo_fo1_handle) ||
                0 == mpma_enable_get(coreotn_handle->mpma_fo1_handle))
            {
                rc  = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
            }
            if (TRUE == check_ctl_mpma_mpmo)
            {
                if (0 == mpmo_enable_get(coreotn_handle->mpmo_core_ctl_handle) ||
                    0 == mpma_enable_get(coreotn_handle->mpma_core_ctl_handle))
                {
                    rc  = COREOTN_ERR_CONTEXT_ENERGY_INCOHERENT;
                }
                
            }
        }        
    }
    PMC_RETURN(rc);
} /* coreotn_energy_coherency_check */




/*******************************************************************************
* coreotn_odukp_start_state_test
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function identifies if any resources are provisioned against the 
*   COREOTN stage4 (FO2)
*
* INPUTS:
*   *coreotn_handle      - pointer to COROTN handle instance to be operated on
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL coreotn_odukp_start_state_test(coreotn_handle_t *coreotn_handle)
{
    UINT32 itr;
    
    PMC_ENTRY(); 
#ifdef PMC_INTERNAL_COREOTN_POWER
    /* temp patch until power mode are properly debugged */
#else 
    if (coreotn_handle->var.coreotn_start_state == FALSE)
    {
        PMC_RETURN(FALSE);
    }
#endif
    for(itr = 0; itr < COREOTN_MAX_NUM_HO_CHNL; itr++)
    {
        if (coreotn_handle->var.rx_ho_chnl_ctxt[itr].chnl_state != COREOTN_CHNL_START)                
            PMC_RETURN(FALSE);
        if (coreotn_handle->var.tx_ho_chnl_ctxt[itr].chnl_state != COREOTN_CHNL_START)                
            PMC_RETURN(FALSE);
    }
    for(itr = 0; itr < COREOTN_MAX_NUM_MO_CHNL; itr++)
    {
        if (coreotn_handle->var.rx_mo_chnl_ctxt[itr].chnl_state != COREOTN_CHNL_START)                
            PMC_RETURN(FALSE);
        if (coreotn_handle->var.tx_mo_chnl_ctxt[itr].chnl_state != COREOTN_CHNL_START)                
            PMC_RETURN(FALSE);
    }  

    PMC_RETURN(TRUE);    
} /* coreotn_odukp_start_state_test */

/*******************************************************************************
* coreotn_oduksw_start_state_test
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function identifies if any resources are provisioned against the 
*   COREOTN ODUkSW
*
* INPUTS:
*   *coreotn_handle      - pointer to COROTN handle instance to be operated on
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL coreotn_oduksw_start_state_test(coreotn_handle_t *coreotn_handle)
{
    UINT32 itr, sw_itr;
    
    PMC_ENTRY();
    
    if (coreotn_handle->var.ilkn_if_enable == TRUE)
    {
        PMC_LOG_TRACE("coreotn_oduksw_start_state_test ILKN_IF\n");
        PMC_RETURN(FALSE);
    }
    for(itr = 0; itr < COREOTN_MAX_NUM_LO_CHNL; itr++)
    {
        for ( sw_itr = 0 ; sw_itr < COREOTN_OCPB_NUM_PORT ; sw_itr++ )
        {
            if (coreotn_handle->var.rx_oduksw_chnl_ctxt[sw_itr][itr].state != COREOTN_CHNL_START)
            {
                PMC_LOG_TRACE("coreotn_oduksw_start_state_test RX FALSE (%d,%d)\n",sw_itr,itr);
                PMC_RETURN(FALSE);
            }
        }        
        for ( sw_itr = 0 ; sw_itr < COREOTN_OCPB_NUM_PORT ; sw_itr++ )
        {
            if (coreotn_handle->var.tx_oduksw_chnl_ctxt[sw_itr][itr].state != COREOTN_CHNL_START)
            {
                PMC_LOG_TRACE("coreotn_oduksw_start_state_test TX FALSE (%d,%d)\n",sw_itr,itr);
                PMC_RETURN(FALSE);
            }
        }
    }       
     
    PMC_RETURN(TRUE);    
} /* coreotn_oduksw_start_state_test */

/*******************************************************************************
* coreotn_stg4_start_state_test
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function identifies if any resources are provisioned against the 
*   COREOTN stage4 (FO2)
*
* INPUTS:
*   *coreotn_handle      - pointer to COROTN handle instance to be operated on
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL coreotn_stg4_start_state_test(coreotn_handle_t *coreotn_handle)
{
    UINT32 itr;
    
    PMC_ENTRY();
    
    for(itr = 0; itr < COREOTN_NUM_CHNL; itr++)
    {
        if (TRUE == coreotn_handle->var.rx_stg4_chnl_prov[itr])
            PMC_RETURN(FALSE);
        if (TRUE == coreotn_handle->var.tx_stg4_chnl_prov[itr])
            PMC_RETURN(FALSE);
    }
        
    PMC_RETURN(TRUE);    
} /* coreotn_stg4_start_state_test */

/*******************************************************************************
*  coreotn_odukp_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures COREOTN subsystem at a block level to provide or remove the
*   ability to perform channel level configuration.
*   This function include the configuration of FMF1/FMF2,FO1 and 
*   MPMA/MPMO in COREOTN_CTL.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   energy_state        - Energy state of stg4\n*                         
*
* OUTPUTS:
*
* RETURNS:
*   None
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_odukp_init(coreotn_handle_t *coreotn_handle,
                                pmc_energy_state_t energy_state)
{
    BOOL8 enable = (PMC_ENERGY_STATE_RUNNING==energy_state)?TRUE:FALSE;
    BOOL8 schd_pacer_en;
    PMC_ENTRY();
    PMC_LOG_TRACE("coreotn_power::coreotn_odukp_init (%d)\n", energy_state);
    
    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
    /* configure energy state in register space */
    switch (coreotn_handle->var.init_operation)
    {
    case COREOTN_SS_OPERATIONAL_MODE:
        /*
        ** FMF1
        */
        coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FMF1_PRBS, energy_state);
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG1, energy_state);
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG2, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG1, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG2, energy_state);
        coreotn_odtu_dmx_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_DMX_STG1, energy_state);
        coreotn_odujat_energy_state_reg_set(coreotn_handle, COREOTN_ODUJAT1, energy_state);
        coreotn_oduksc_energy_state_reg_set(coreotn_handle, COREOTN_ODUKSC1, energy_state);
        coreotn_odtu_mux_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_MUX_STG1, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF1_FRM_RCP12, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF1_FRM_RCP96, energy_state);
        
            
        /* 
        ** FMF2 
        */
        coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FMF2_PRBS, energy_state);
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG3A, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG3A, energy_state);
        coreotn_odtu_dmx_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_DMX_STG2, energy_state);
        coreotn_odujat_energy_state_reg_set(coreotn_handle, COREOTN_ODUJAT2, energy_state);
        coreotn_odtu_mux_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_MUX_STG2, energy_state);
        coreotn_oduksc_energy_state_reg_set(coreotn_handle, COREOTN_ODUKSC2, energy_state);
        /* coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF2_FRM_RCP12, PMC_ENERGY_STATE_RESET); */
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF2_FRM_RCP96, energy_state);

        /*
        ** FO1
        */
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG3B, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG3B, energy_state);
        coreotn_mpma_energy_state_reg_set(coreotn_handle, COREOTN_MPMA_TO_COREOTN, energy_state);
        coreotn_mpmo_energy_state_reg_set(coreotn_handle, COREOTN_MPMO_TO_COREOTN, energy_state);
        coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FO1_PRBS, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FO1_FRM_RCP, energy_state);
        coreotn_ohfs_remove_energy_state_reg_set(coreotn_handle, COREOTN_FO1_OHFS_REMOVE, energy_state);
            

        /*
        ** COREOTN_CTL
        */
        coreotn_mpma_energy_state_reg_set(coreotn_handle, COREOTN_MPMA_CORECTL, energy_state);
        coreotn_mpmo_energy_state_reg_set(coreotn_handle, COREOTN_MPMO_CORECTL, energy_state);
        break;
    case COREOTN_SS_ONE_STAGE_MUXING_MODE:
        /*
        ** FMF1
        */
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG1, energy_state);
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG2, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG1, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG2, energy_state);
        coreotn_odtu_dmx_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_DMX_STG1, energy_state);
        coreotn_odtu_mux_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_MUX_STG1, energy_state);
        coreotn_oduksc_energy_state_reg_set(coreotn_handle, COREOTN_ODUKSC1, energy_state);
        coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FMF1_PRBS, energy_state);
        coreotn_odujat_energy_state_reg_set(coreotn_handle, COREOTN_ODUJAT1, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF1_FRM_RCP96, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF1_FRM_RCP12, energy_state);
        

        /* FMF2 */
        /* coreotn_odtu_dmx_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_DMX_STG2, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odtu_mux_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_MUX_STG2, PMC_ENERGY_STATE_RESET); */
        /* coreotn_oduksc_energy_state_reg_set(coreotn_handle, COREOTN_ODUKSC2, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odujat_energy_state_reg_set(coreotn_handle, COREOTN_ODUJAT2, PMC_ENERGY_STATE_RESET); */
        coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FMF2_PRBS, energy_state);

        /* FO1 */
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG3B, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG3B, energy_state);
        coreotn_mpma_energy_state_reg_set(coreotn_handle, COREOTN_MPMA_TO_COREOTN, energy_state);
        coreotn_mpmo_energy_state_reg_set(coreotn_handle, COREOTN_MPMO_TO_COREOTN, energy_state);
        coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FO1_PRBS, energy_state);            
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FO1_FRM_RCP, energy_state);
        coreotn_ohfs_remove_energy_state_reg_set(coreotn_handle, COREOTN_FO1_OHFS_REMOVE, energy_state);
            
        /* COREOTN CTL MPMA/MPMO */
        /* coreotn_mpma_energy_state_reg_set(coreotn_handle, COREOTN_MPMA_CORECTL, PMC_ENERGY_STATE_RESET); */
        /* coreotn_mpmo_energy_state_reg_set(coreotn_handle, COREOTN_MPMO_CORECTL, PMC_ENERGY_STATE_RESET);             */
            
        break;
    case COREOTN_SS_SYSOTN_MODE:

        /* FMF1 blocks */
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG1, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG1, energy_state);
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG2, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG2, energy_state);
        coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FMF1_PRBS, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF1_FRM_RCP12, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF1_FRM_RCP96, energy_state);
        /* FMF1 blocks kept in reset for SYSOTN mode */
        /* coreotn_odujat_energy_state_reg_set(coreotn_handle, COREOTN_ODUJAT1, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odtu_dmx_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_DMX_STG1, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odtu_mux_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_MUX_STG1, PMC_ENERGY_STATE_RESET); */


        /*FMF2 blocks (full power) */
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STGN, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STGN, energy_state);
        coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FMF2_PRBS, energy_state);
        coreotn_odtu_dmx_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_DMX_STG2, energy_state);
        coreotn_odtu_mux_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_MUX_STG2, energy_state);
        coreotn_oduksc_energy_state_reg_set(coreotn_handle, COREOTN_ODUKSC2, energy_state);
        coreotn_odujat_energy_state_reg_set(coreotn_handle, COREOTN_ODUJAT2, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF2_FRM_RCP12, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF2_FRM_RCP96, energy_state);
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG3A, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG3A, energy_state);

        /* FO1 blocks */
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG3B, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG3B, energy_state);
        coreotn_mpma_energy_state_reg_set(coreotn_handle, COREOTN_MPMA_TO_COREOTN, energy_state);
        coreotn_mpmo_energy_state_reg_set(coreotn_handle, COREOTN_MPMO_TO_COREOTN, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FO1_FRM_RCP, energy_state);
        coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FO1_PRBS, energy_state);
        coreotn_ohfs_remove_energy_state_reg_set(coreotn_handle, COREOTN_FO1_OHFS_REMOVE, energy_state);
            
        /* COREOTN CTL blocks */
        coreotn_mpma_energy_state_reg_set(coreotn_handle, COREOTN_MPMA_CORECTL, energy_state);
        coreotn_mpmo_energy_state_reg_set(coreotn_handle, COREOTN_MPMO_CORECTL, energy_state);        
        break;
    case COREOTN_SS_SYSOTN_BYPASS_MODE:
        /* FMF1 blocks */
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG1, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG1, energy_state);
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG2, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG2, energy_state);
        coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FMF1_PRBS, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF1_FRM_RCP12, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF1_FRM_RCP96, energy_state);

        /* FMF1 blocks kept in reset for SYSOTN mode */
        /* coreotn_odujat_energy_state_reg_set(coreotn_handle, COREOTN_ODUJAT1, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odtu_dmx_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_DMX_STG1, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odtu_mux_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_MUX_STG1, PMC_ENERGY_STATE_RESET); */

        /*FMF2 blocks */
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STGN, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STGN, energy_state);
        coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FMF2_PRBS, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF2_FRM_RCP12, energy_state);

        /* FMF2 blocks kept in reset for SYSOTN (BYPASS) mode */
        /* coreotn_odtu_dmx_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_DMX_STG2, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odtu_mux_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_MUX_STG2, PMC_ENERGY_STATE_RESET); */
        /* coreotn_oduksc_energy_state_reg_set(coreotn_handle, COREOTN_ODUKSC2, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odujat_energy_state_reg_set(coreotn_handle, COREOTN_ODUJAT2, PMC_ENERGY_STATE_RESET); */
        /* coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF2_FRM_RCP96, PMC_ENERGY_STATE_RESET); */
           
        /* FO1 blocks */
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG3B, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG3B, energy_state);
        coreotn_mpma_energy_state_reg_set(coreotn_handle, COREOTN_MPMA_TO_COREOTN, energy_state);
        coreotn_mpmo_energy_state_reg_set(coreotn_handle, COREOTN_MPMO_TO_COREOTN, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FO1_FRM_RCP, energy_state);
        coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FO1_PRBS, energy_state);
        coreotn_ohfs_remove_energy_state_reg_set(coreotn_handle, COREOTN_FO1_OHFS_REMOVE, energy_state);

        /* COREOTN CTL blocks */
        coreotn_mpma_energy_state_reg_set(coreotn_handle, COREOTN_MPMA_CORECTL, energy_state);
        coreotn_mpmo_energy_state_reg_set(coreotn_handle, COREOTN_MPMO_CORECTL, energy_state);
        break;
    case COREOTN_SS_BYPASS_MODE:
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG1, energy_state);    
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG1, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF1_FRM_RCP12, energy_state);
                        
        /*
        ** FMF1
        */
        coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FMF1_PRBS, energy_state);
        /* coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG2, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG2, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odtu_dmx_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_DMX_STG1, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odtu_mux_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_MUX_STG1, PMC_ENERGY_STATE_RESET); */
        /* coreotn_oduksc_energy_state_reg_set(coreotn_handle, COREOTN_ODUKSC1, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odujat_energy_state_reg_set(coreotn_handle, COREOTN_ODUJAT1, PMC_ENERGY_STATE_RESET); */

        /*
        ** FMF2
        */
        coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FMF2_PRBS, energy_state);
        /* coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG3A, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG3A, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odtu_dmx_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_DMX_STG2, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odtu_mux_energy_state_reg_set(coreotn_handle, COREOTN_ODTU_MUX_STG2, PMC_ENERGY_STATE_RESET); */
        /* coreotn_oduksc_energy_state_reg_set(coreotn_handle, COREOTN_ODUKSC2, PMC_ENERGY_STATE_RESET); */
        /* coreotn_odujat_energy_state_reg_set(coreotn_handle, COREOTN_ODUJAT2, PMC_ENERGY_STATE_RESET); */

        /*
        ** FO1
        */
        coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG3B, energy_state);
        coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG3B, energy_state);
        coreotn_mpma_energy_state_reg_set(coreotn_handle, COREOTN_MPMA_TO_COREOTN, energy_state);
        coreotn_mpmo_energy_state_reg_set(coreotn_handle, COREOTN_MPMO_TO_COREOTN, energy_state);
        coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FO1_PRBS, energy_state);
        coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FO1_FRM_RCP, energy_state);
        coreotn_ohfs_remove_energy_state_reg_set(coreotn_handle, COREOTN_FO1_OHFS_REMOVE, energy_state);

        /*
        ** COREOTN_CTL
        */
        /* coreotn_mpma_energy_state_reg_set(coreotn_handle, COREOTN_MPMA_CORECTL, PMC_ENERGY_STATE_RESET); */
        /* coreotn_mpmo_energy_state_reg_set(coreotn_handle, COREOTN_MPMO_CORECTL, PMC_ENERGY_STATE_RESET); */
            
        /* FRM_RCP */
        /* coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF1_FRM_RCP96, PMC_ENERGY_STATE_RESET); */
        /* coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF2_FRM_RCP12, PMC_ENERGY_STATE_RESET); */
        /* coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FMF2_FRM_RCP96, PMC_ENERGY_STATE_RESET); */
            
        break;
    default:
        break;
    }
    
    if (PMC_ENERGY_STATE_RUNNING == energy_state)
    {
        coreotn_odukp_frm_rcp_cfc_fifo_activate(coreotn_handle,
                                                coreotn_handle->var.init_operation);
    }                                                
    
    /* initialize context & blocks */
    (void) coreotn_dci_mux_ctrl_cfg(coreotn_handle, coreotn_handle->var.init_operation);        
    
    /* sysotn configuration */
    if(coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE || 
       coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
    {           
        (void) cpb_sysotn_mode_set(coreotn_handle->oduksw_handle, TRUE);
    }
    
#if defined (PMC_EMULATION) | defined (CPB_EMULATION)
    {
        UINT32 i;
        /* bypass PRBS block in FO */
        for (i = 0; i < 12; i++)
        {
            coreotn_fo_field_PRBS_CHID_set(NULL, coreotn_handle, 0, i, 96);
            coreotn_fo_field_PRBS_CHID_set(NULL, coreotn_handle, 1, i, 96);
        }
    }
#endif
    /* initialize ODU_TFRM */
    odu_tfrm_init(coreotn_handle->odu_tfrm_stg1_handle);
    odu_tfrm_init(coreotn_handle->odu_tfrm_stg2_handle);
    odu_tfrm_init(coreotn_handle->odu_tfrm_stg3b_handle);
    odu_tfrm_init(coreotn_handle->odu_tfrm_stgN_handle);
    
    /* initialize ODU_RFRM */
    odu_rfrm_init(coreotn_handle->odu_rfrm_stg1_handle, FALSE);
    odu_rfrm_init(coreotn_handle->odu_rfrm_stg3b_handle, FALSE);
    odu_rfrm_init(coreotn_handle->odu_rfrm_stgN_handle, FALSE);
 
     if(coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE || 
       coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
    {     
            odu_rfrm_init(coreotn_handle->odu_rfrm_stg2_handle, TRUE);
    }
    else
    {
            odu_rfrm_init(coreotn_handle->odu_rfrm_stg2_handle, FALSE);     
    }
    
    
    /* initialize ODTU_MUX */
    odtu_mux_init(coreotn_handle->odtu_mux1_handle, enable);
    
    /* initialize ODUJAT */
    odujat_init(coreotn_handle->odujat1_handle, 1-enable);
    
    /* initialize ODTU_DMX */
    odtu_dmx_init(coreotn_handle->odtu_dmx1_handle, enable);
    
    /* initialize MPMO */
    mpmo_init(coreotn_handle->mpmo_fo1_handle, energy_state );
    mpmo_init(coreotn_handle->mpmo_core_ctl_handle, energy_state );
    
    /* initialize MPMA */
    mpma_init(coreotn_handle->mpma_fo1_handle, energy_state );
    mpma_init(coreotn_handle->mpma_core_ctl_handle, energy_state );
    
    /* for full operation */
    if (coreotn_handle->var.init_operation != COREOTN_SS_ONE_STAGE_MUXING_MODE)
    {
        odu_tfrm_init(coreotn_handle->odu_tfrm_stg3a_handle);
        
        odu_rfrm_init(coreotn_handle->odu_rfrm_stg3a_handle, FALSE);
        
        odtu_mux_init(coreotn_handle->odtu_mux2_handle, enable);  
        odtu_dmx_init(coreotn_handle->odtu_dmx2_handle, enable);
        
        odujat_init(coreotn_handle->odujat2_handle, 1-enable);
            
        /* initialize oduk scheduler */
        oduksc_init(coreotn_handle->oduksc2_handle, energy_state );
        /* remove oduksc soft reset */
        oduksc_reset_cfg(coreotn_handle->oduksc2_handle, 0);
    }
    

    if (PMC_ENERGY_STATE_RUNNING == energy_state)
    {
        /* configure scheduling pacer mode prior to enabling MPMA */
        /* For CTL MPMA, always disable scheduling pacer mode 
        ** For FO1 MPMA, 1 for muxed datapath and 0 for unchannelized 
        ** For FO2 MPMA, always enable scheduling pacer mode 
        */
        if (coreotn_handle->var.init_operation == COREOTN_SS_BYPASS_MODE 
            || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
        {
            /* This is for non-muxing datapath. Since schd_pacer is a global
            ** configuration, ONE_STAGE or OPERATIONAL mode cannot be used to
            ** determine individual channel muxing mode. 
            */
            schd_pacer_en = 0;
        } else {
            /* This is for muxed datapath. ONE_STAGE or OPERATIONAL can be
            ** used for passthru channel; however, in this scenario, it is likely
            ** that some channel is muxed.
            */
            if(FALSE == pmc_is_digi_rev_a_revision(&coreotn_handle->base))
            {
                /* Non Rev A device must use schd_pacer_en set to 0 for FO1 */
                schd_pacer_en = 0;
            } else {
                schd_pacer_en = 1;
            }
        }
        
        mpma_schd_pacer_enable_cfg(coreotn_handle->mpma_fo1_handle, schd_pacer_en);
        mpma_schd_pacer_enable_cfg(coreotn_handle->mpma_core_ctl_handle, FALSE);
        
        
        /* Enable interrupts to go to external pin */
        coreotn_int_init(coreotn_handle, enable);
        
        /* initialize oduk scheduler */
        oduksc_init(coreotn_handle->oduksc1_handle, energy_state );

        /* remove oduksc soft reset */
        oduksc_reset_cfg(coreotn_handle->oduksc1_handle, 0);

        /* enable MPMO */
        mpmo_enable_cfg(coreotn_handle->mpmo_fo1_handle, enable);
        mpmo_enable_cfg(coreotn_handle->mpmo_core_ctl_handle, enable);
    
        /* Enable MPMA */
        mpma_enable_cfg(coreotn_handle->mpma_fo1_handle, enable);
        mpma_enable_cfg(coreotn_handle->mpma_core_ctl_handle, enable);      
    }           

    PMC_RETURN();
} /* coreotn_odukp_init */

/*******************************************************************************
*  coreotn_oduksw_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures COREOTN subsystem at a block level to provide or remove the
*   ability to perform channel level configuration.
*   This function include the configuration of ODUKSW 
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   energy_state        - Energy state of stg4\n*                         
*
* OUTPUTS:
*
* RETURNS:
*   None
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_oduksw_init(coreotn_handle_t *coreotn_handle,
                                 pmc_energy_state_t energy_state)
{  
    PMC_ENTRY();
  
    PMC_LOG_TRACE("coreotn_power::coreotn_oduksw_init (%d)\n", energy_state);

    /* initialize context & blocks */
    (void) coreotn_oduksw_sifd_path_cfg(coreotn_handle, coreotn_handle->var.init_operation);
     PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
    cpb_init(coreotn_handle->oduksw_handle, energy_state);

    PMC_RETURN();
} /* coreotn_oduksw_init */

/*******************************************************************************
*  coreotn_stg4_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Function use to dynamically turn the blocks in FO2 on an off
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   energy_state        - Energy state of stg4\n*                         
*
* OUTPUTS:
*
* RETURNS:
*   None
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_stg4_init(coreotn_handle_t *coreotn_handle,
                               pmc_energy_state_t energy_state)
{
    PMC_ENTRY();
    
    PMC_LOG_TRACE("coreotn_power::coreotn_stg4_init (%d)\n", energy_state);

    /* FO2 framers */
    coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_RFRM_STG4, energy_state);
    coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle, COREOTN_ODU_TFRM_STG4, energy_state);    
    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0); 
    odu_tfrm_init(coreotn_handle->odu_tfrm_stg4_handle);
      PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
    odu_rfrm_init(coreotn_handle->odu_rfrm_stg4_handle, FALSE); 
      PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);   
    coreotn_frm_rcp_energy_state_reg_set(coreotn_handle, COREOTN_FO2_FRM_RCP, energy_state);    
    if (PMC_ENERGY_STATE_RUNNING == energy_state)
    {
        coreotn_stg4_frm_rcp_cfc_fifo_activate(coreotn_handle);
    }
    
    /* MPMA */
    coreotn_mpma_energy_state_reg_set(coreotn_handle, COREOTN_MPMA_FROM_MAPOTN, energy_state);
    /* MPMO */
    coreotn_mpmo_energy_state_reg_set(coreotn_handle, COREOTN_MPMO_TO_MAPOTN, energy_state); 
    /* OTN_PRBS */    
    coreotn_prbs_energy_state_reg_set(coreotn_handle, COREOTN_FO2_PRBS, energy_state);         
    mpmo_init(coreotn_handle->mpmo_fo2_handle, energy_state);
      PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0); 
    mpma_init(coreotn_handle->mpma_fo2_handle, energy_state);
    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
    
    if (PMC_ENERGY_STATE_RUNNING == energy_state)
    {
        mpmo_enable_cfg(coreotn_handle->mpmo_fo2_handle, TRUE);       

        if(FALSE == pmc_is_digi_rev_a_revision(&coreotn_handle->base))
        {
            /* Non Rev A device must use schd_pacer_en set to 0 for FO1 */
            mpma_schd_pacer_enable_cfg(coreotn_handle->mpma_fo2_handle, FALSE);    
        } else {
            /* For FO2 MPMA, always enable scheduling_pacer_en 
            ** perform this prior to enabling MPMA
            */
            mpma_schd_pacer_enable_cfg(coreotn_handle->mpma_fo2_handle, TRUE);    
        }
        
        mpma_enable_cfg(coreotn_handle->mpma_fo2_handle, TRUE);
    }

    PMC_RETURN();
} /* coreotn_stg4_init */

/*******************************************************************************
*  coreotn_energy_state_reg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current energy state of coreotn
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*
* OUTPUTS:
*   *energy_state  - current energy state of COREOTN
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                         coreotn_energy_state_t *energy_state)
{    
    PMC_ENTRY();
    /* FO1 */
    coreotn_frm_rcp_energy_state_reg_get(coreotn_handle,COREOTN_FO1_FRM_RCP,          &energy_state->fo1.frm_rcp    );
    coreotn_prbs_energy_state_reg_get(coreotn_handle,COREOTN_FO1_PRBS,                &energy_state->fo1.prbs       );
    coreotn_mpmo_energy_state_reg_get(coreotn_handle,COREOTN_MPMO_TO_COREOTN,         &energy_state->fo1.mpmo       );
    coreotn_mpma_energy_state_reg_get(coreotn_handle,COREOTN_MPMA_TO_COREOTN,         &energy_state->fo1.mpma       );
    coreotn_odu_tfrm_energy_state_reg_get(coreotn_handle,COREOTN_ODU_TFRM_STG3B,      &energy_state->fo1.tfrm       );
    coreotn_odu_rfrm_energy_state_reg_get(coreotn_handle,COREOTN_ODU_RFRM_STG3B,      &energy_state->fo1.rfrm       );
    coreotn_ohfs_remove_energy_state_reg_get(coreotn_handle, COREOTN_FO1_OHFS_REMOVE, &energy_state->fo1.ohfs_remove);

    /* FO2 */
    coreotn_frm_rcp_energy_state_reg_get(coreotn_handle,COREOTN_FO2_FRM_RCP,   &energy_state->fo2.frm_rcp);
    coreotn_prbs_energy_state_reg_get(coreotn_handle,COREOTN_FO2_PRBS,         &energy_state->fo2.prbs   );
    coreotn_mpmo_energy_state_reg_get(coreotn_handle,COREOTN_MPMO_TO_MAPOTN,   &energy_state->fo2.mpmo   );
    coreotn_mpma_energy_state_reg_get(coreotn_handle,COREOTN_MPMA_FROM_MAPOTN, &energy_state->fo2.mpma   );
    coreotn_odu_tfrm_energy_state_reg_get(coreotn_handle,COREOTN_ODU_TFRM_STG4,&energy_state->fo2.tfrm   );
    coreotn_odu_rfrm_energy_state_reg_get(coreotn_handle,COREOTN_ODU_RFRM_STG4,&energy_state->fo2.rfrm   );
 
    /* FMF1 */
    coreotn_prbs_energy_state_reg_get(coreotn_handle,COREOTN_FMF1_PRBS,         &energy_state->fmf1.prbs     );
    coreotn_oduksc_energy_state_reg_get(coreotn_handle,COREOTN_ODUKSC1,         &energy_state->fmf1.oduksc   );
    coreotn_odujat_energy_state_reg_get(coreotn_handle,COREOTN_ODUJAT1,         &energy_state->fmf1.odujat   );
    coreotn_frm_rcp_energy_state_reg_get(coreotn_handle,COREOTN_FMF1_FRM_RCP96, &energy_state->fmf1.frm_rcp96);
    coreotn_frm_rcp_energy_state_reg_get(coreotn_handle,COREOTN_FMF1_FRM_RCP12, &energy_state->fmf1.frm_rcp12);    
    coreotn_odu_rfrm_energy_state_reg_get(coreotn_handle,COREOTN_ODU_RFRM_STG1, &energy_state->fmf1.rfrm12   );
    coreotn_odu_tfrm_energy_state_reg_get(coreotn_handle,COREOTN_ODU_TFRM_STG1, &energy_state->fmf1.tfrm12   );
    coreotn_odu_rfrm_energy_state_reg_get(coreotn_handle,COREOTN_ODU_RFRM_STG2, &energy_state->fmf1.rfrm96   );
    coreotn_odu_tfrm_energy_state_reg_get(coreotn_handle,COREOTN_ODU_TFRM_STG2, &energy_state->fmf1.tfrm96   );
    coreotn_odtu_dmx_energy_state_reg_get(coreotn_handle,COREOTN_ODTU_DMX_STG1, &energy_state->fmf1.odtu_dmx );   
    coreotn_odtu_mux_energy_state_reg_get(coreotn_handle,COREOTN_ODTU_MUX_STG1, &energy_state->fmf1.odtu_mux ); 

    /* FMF2 */
    coreotn_prbs_energy_state_reg_get(coreotn_handle,COREOTN_FMF2_PRBS,          &energy_state->fmf2.prbs     );
    coreotn_oduksc_energy_state_reg_get(coreotn_handle,COREOTN_ODUKSC2,          &energy_state->fmf2.oduksc   );
    coreotn_odujat_energy_state_reg_get(coreotn_handle,COREOTN_ODUJAT2,          &energy_state->fmf2.odujat   );
    coreotn_frm_rcp_energy_state_reg_get(coreotn_handle,COREOTN_FMF2_FRM_RCP96,  &energy_state->fmf2.frm_rcp96);
    coreotn_frm_rcp_energy_state_reg_get(coreotn_handle,COREOTN_FMF2_FRM_RCP12,  &energy_state->fmf2.frm_rcp12);    
    coreotn_odu_rfrm_energy_state_reg_get(coreotn_handle,COREOTN_ODU_RFRM_STGN,  &energy_state->fmf2.rfrm12   );
    coreotn_odu_tfrm_energy_state_reg_get(coreotn_handle,COREOTN_ODU_TFRM_STGN,  &energy_state->fmf2.tfrm12   );
    coreotn_odu_rfrm_energy_state_reg_get(coreotn_handle,COREOTN_ODU_RFRM_STG3A, &energy_state->fmf2.rfrm96   );
    coreotn_odu_tfrm_energy_state_reg_get(coreotn_handle,COREOTN_ODU_TFRM_STG3A, &energy_state->fmf2.tfrm96   );
    coreotn_odtu_dmx_energy_state_reg_get(coreotn_handle,COREOTN_ODTU_DMX_STG2,  &energy_state->fmf2.odtu_dmx );   
    coreotn_odtu_mux_energy_state_reg_get(coreotn_handle,COREOTN_ODTU_MUX_STG2,  &energy_state->fmf2.odtu_mux ); 

    /* COREOTN CTL */
    coreotn_mpmo_energy_state_reg_get(coreotn_handle,    COREOTN_MPMO_CORECTL,&energy_state->coreotn_ctl.mpmo);
    coreotn_mpma_energy_state_reg_get(coreotn_handle,    COREOTN_MPMA_CORECTL,&energy_state->coreotn_ctl.mpma);
    coreotn_odu_ohp_energy_state_reg_get(coreotn_handle, COREOTN_ODU_OHP_1,&energy_state->coreotn_ctl.ohp3);
    coreotn_odu_ohp_energy_state_reg_get(coreotn_handle, COREOTN_ODU_OHP_2,&energy_state->coreotn_ctl.ohp2);
    coreotn_odu_ohp_energy_state_reg_get(coreotn_handle, COREOTN_ODU_OHP_3,&energy_state->coreotn_ctl.ohp1);

    PMC_RETURN();

} /* coreotn_energy_state_reg_get */
/*******************************************************************************
*  coreotn_odu_ohp_energy_state_reg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current energy state of MPMA block.
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   ohp_instance        - OHP instance in COREOTN. See coreotn_odu_ohp_inst_t
*   *odu_ohp_energy_state  - current energy state of MPMA
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_odu_ohp_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                  coreotn_odu_ohp_inst_t ohp_instance,
                                                  pmc_energy_state_t *odu_ohp_energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    switch((odu_ohp_inst_t)ohp_instance)
    {
    case ODU_OHP_1:
        lowpwr_val     = coreotn_ctl_field_OHP1_LOWPWR_get(NULL,coreotn_handle);
        ram_lowpwr_val = coreotn_ctl_field_OHP1_RAM_LOWPWR_get(NULL,coreotn_handle);
        reset_val      = coreotn_ctl_field_OHP1_RST_get(NULL,coreotn_handle);
        break;
    case ODU_OHP_2:
        lowpwr_val     = coreotn_ctl_field_OHP2_LOWPWR_get(NULL,coreotn_handle);
        ram_lowpwr_val = coreotn_ctl_field_OHP2_RAM_LOWPWR_get(NULL,coreotn_handle);
        reset_val      = coreotn_ctl_field_OHP2_RST_get(NULL,coreotn_handle);
        break;
    case ODU_OHP_3:
        lowpwr_val     = coreotn_ctl_field_OHP3_LOWPWR_get(NULL,coreotn_handle);
        ram_lowpwr_val = coreotn_ctl_field_OHP3_RAM_LOWPWR_get(NULL,coreotn_handle);
        reset_val      = coreotn_ctl_field_OHP3_RST_get(NULL,coreotn_handle);
        break;
    default:
        break;
    }

    *odu_ohp_energy_state = util_global_recover_energy_state(lowpwr_val,ram_lowpwr_val,reset_val);
    
    PMC_RETURN();

} /* coreotn_odu_ohp_energy_state_reg_get */


/*******************************************************************************
*  coreotn_odu_ohp_energy_state_reg_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures an MPMA block in COREOTN to be in low power
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   ohp_instance        - OHP instance in COREOTN. See coreotn_odu_ohp_inst_t
*   energy_state        - Energy state of MPMA\n
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_odu_ohp_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                  coreotn_odu_ohp_inst_t ohp_instance,
                                                  pmc_energy_state_t energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    switch (energy_state)
    {
    case PMC_ENERGY_STATE_RUNNING:
        reset_val = 0;
        lowpwr_val = 0;
        ram_lowpwr_val = 0;
        break;
    case PMC_ENERGY_STATE_RESET:
        reset_val = 1;
        lowpwr_val = 1;
        ram_lowpwr_val = 1;
        break;
    default:
        break;
    }

    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "reset_val = %u\n", reset_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "lowpwr_val = %u\n", lowpwr_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "ram_lowpwr_val = %u\n", ram_lowpwr_val);

    switch((odu_ohp_inst_t)ohp_instance)
    {
    case ODU_OHP_1:
        coreotn_ctl_field_OHP1_LOWPWR_set(NULL,coreotn_handle,lowpwr_val);
        coreotn_ctl_field_OHP1_RAM_LOWPWR_set(NULL,coreotn_handle,ram_lowpwr_val);
        coreotn_ctl_field_OHP1_RST_set(NULL,coreotn_handle,reset_val);
        break;
    case ODU_OHP_2:
        coreotn_ctl_field_OHP2_LOWPWR_set(NULL,coreotn_handle,lowpwr_val);
        coreotn_ctl_field_OHP2_RAM_LOWPWR_set(NULL,coreotn_handle,ram_lowpwr_val);
        coreotn_ctl_field_OHP2_RST_set(NULL,coreotn_handle,reset_val);
        break;
    case ODU_OHP_3:
        coreotn_ctl_field_OHP3_LOWPWR_set(NULL,coreotn_handle,lowpwr_val);
        coreotn_ctl_field_OHP3_RAM_LOWPWR_set(NULL,coreotn_handle,ram_lowpwr_val);
        coreotn_ctl_field_OHP3_RST_set(NULL,coreotn_handle,reset_val);
        break;
    default:
        break;
    }


    PMC_RETURN();

} /* coreotn_odu_ohp_energy_state_reg_set */

/*******************************************************************************
*  coreotn_mpma_energy_state_reg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current energy state of MPMA block.
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   mpma_instance       - MPMA instance in COREOTN. See coreotn_mpma_inst_t
*   *mpma_energy_state  - current energy state of MPMA
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_mpma_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                               coreotn_mpma_inst_t mpma_instance,
                                               pmc_energy_state_t *mpma_energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    /*
    ** Check MPMA_RST and MPMA_LOWPWR by reading directly from the register
    ** based on reset and lowpwr value assign appropriate energy state
    */
    switch (mpma_instance)
    {
    case COREOTN_MPMA_TO_COREOTN:
        reset_val = coreotn_fo_field_MPMA_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMA_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fo_field_MPMA_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMA_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fo_field_MPMA_RAM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMA_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_MPMA_FROM_MAPOTN:
        reset_val = coreotn_fo_field_MPMA_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMA_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fo_field_MPMA_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMA_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fo_field_MPMA_RAM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMA_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_MPMA_CORECTL:
        reset_val = coreotn_ctl_field_MPMA_RST_get(NULL, coreotn_handle);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMA_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_ctl_field_MPMA_LOWPWR_get(NULL, coreotn_handle);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMA_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_ctl_field_MPMA_RAM_LOWPWR_get(NULL, coreotn_handle);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMA_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);

    }
    *mpma_energy_state = util_global_recover_energy_state(lowpwr_val,ram_lowpwr_val,reset_val);
    
    PMC_RETURN();

} /* coreotn_mpma_energy_state_reg_get */


/*******************************************************************************
*  coreotn_mpma_energy_state_reg_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures an MPMA block in COREOTN to be in low power
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   mpma_instance       - MPMA instance in COREOTN. See coreotn_mpma_inst_t
*   energy_state  - Energy state of MPMA\n
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_mpma_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                               coreotn_mpma_inst_t mpma_instance,
                                               pmc_energy_state_t energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    switch (energy_state)
    {
    case PMC_ENERGY_STATE_RUNNING:
        reset_val = 0;
        lowpwr_val = 0;
        ram_lowpwr_val = 0;
        break;
    case PMC_ENERGY_STATE_RESET:
        reset_val = 1;
        lowpwr_val = 1;
        ram_lowpwr_val = 1;
        break;
    default:
        break;
    }

    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "reset_val = %u\n", reset_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "lowpwr_val = %u\n", lowpwr_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "ram_lowpwr_val = %u\n", ram_lowpwr_val);

    switch (mpma_instance)
    {
    case COREOTN_MPMA_TO_COREOTN:
        coreotn_fo_field_MPMA_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fo_field_MPMA_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        coreotn_fo_field_MPMA_RAM_LOWPWR_set(NULL, coreotn_handle, 0, ram_lowpwr_val);
        break;
    case COREOTN_MPMA_FROM_MAPOTN:
        coreotn_fo_field_MPMA_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fo_field_MPMA_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        coreotn_fo_field_MPMA_RAM_LOWPWR_set(NULL, coreotn_handle, 1, ram_lowpwr_val);
        break;
    case COREOTN_MPMA_CORECTL:
        coreotn_ctl_field_MPMA_RST_set(NULL, coreotn_handle, reset_val);
        coreotn_ctl_field_MPMA_LOWPWR_set(NULL, coreotn_handle, lowpwr_val);
        coreotn_ctl_field_MPMA_RAM_LOWPWR_set(NULL, coreotn_handle, ram_lowpwr_val);
        break;
    default:
        /* Should not have any other case */
        PMC_ASSERT(FALSE, COREOTN_ERR_INVALID_ARG, mpma_instance, 0);
        break;

    }

    PMC_RETURN();

} /* coreotn_mpma_energy_state_reg_set */

/*******************************************************************************
*  coreotn_frm_rcp_energy_state_reg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current energy state of FRM_RCP block.
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle         - pointer to COREOTN handle instance to be operated on
*   frm_rcp_instance        - FRM_RCP instance in COREOTN. See coreotn_frm_rcp_inst_t
*   *frm_rcp_energy_state   - current energy state of FRM_RCP
*
*
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_frm_rcp_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                  coreotn_frm_rcp_inst_t frm_rcp_instance,
                                                  pmc_energy_state_t *frm_rcp_energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    
    PMC_ENTRY();
    /*
      COREOTN_FMF1_FRM_RCP12   = 0,
      COREOTN_FMF1_FRM_RCP96,
      COREOTN_FMF2_FRM_RCP12,
      COREOTN_FMF2_FRM_RCP96,
      COREOTN_FO1_FRM_RCP,
      COREOTN_FO2_FRM_RCP,
    */

    switch (frm_rcp_instance)
    {
    case COREOTN_FMF1_FRM_RCP12:
        reset_val = coreotn_fmf_field_FRM_RCP12_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading FRM_RCP12_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_FRM_RCP12_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading FRM_RCP12_LOWPWR bit = %u\n", lowpwr_val);
        break;
    case COREOTN_FMF1_FRM_RCP96:
        reset_val = coreotn_fmf_field_FRM_RCP96_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading FRM_RCP96_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_FRM_RCP96_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading FRM_RCP96_LOWPWR bit = %u\n", lowpwr_val);
        break;
    case COREOTN_FMF2_FRM_RCP12:
        reset_val = coreotn_fmf_field_FRM_RCP12_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading FRM_RCP12_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_FRM_RCP12_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading FRM_RCP12_LOWPWR bit = %u\n", lowpwr_val);
        break;
    case COREOTN_FMF2_FRM_RCP96:
        reset_val = coreotn_fmf_field_FRM_RCP96_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading FRM_RCP96_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_FRM_RCP96_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading FRM_RCP96_LOWPWR bit = %u\n", lowpwr_val);    
        break;
    case COREOTN_FO1_FRM_RCP:
        reset_val = coreotn_fo_field_FRM_RCP_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading FRM_RCP_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fo_field_FRM_RCP_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading FRM_RCP96_LOWPWR bit = %u\n", lowpwr_val);    
        break;
    case COREOTN_FO2_FRM_RCP:
        reset_val = coreotn_fo_field_FRM_RCP_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading FRM_RCP_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fo_field_FRM_RCP_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading FRM_RCP96_LOWPWR bit = %u\n", lowpwr_val);
        break;
    case LAST_COREOTN_FRM_RCP:
        /* fall through */
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);
    }

    *frm_rcp_energy_state = util_global_recover_energy_state(lowpwr_val,lowpwr_val,reset_val);

    PMC_RETURN();

} /* coreotn_frm_rcp_energy_state_reg_get */


/*******************************************************************************
*  coreotn_frm_rcp_energy_state_reg_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures an FRM_RCP block in COREOTN to be in low power
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   frm_rcp_instance    - FRM_RCP instance in COREOTN. See coreotn_frm_rcp_inst_t
*   energy_state  - Energy state of MPMA\n
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_frm_rcp_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                  coreotn_frm_rcp_inst_t frm_rcp_instance,
                                                  pmc_energy_state_t energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    /*UINT32 cfc_fifo_clrb_12 = 0xfff;
      UINT32 cfc_fifo_clrb_96_off[3];
      UINT32 cfc_fifo_clrb_96_on[3];*/
    
    PMC_ENTRY();

    switch (energy_state)
    {
    case PMC_ENERGY_STATE_RUNNING:
        reset_val = 0;
        lowpwr_val = 0;
        break;
    case PMC_ENERGY_STATE_RESET:
        reset_val = 1;
        lowpwr_val = 1;
        break;
    default:
        break;
    }


    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "reset_val = %u\n", reset_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "lowpwr_val = %u\n", lowpwr_val);
    
    /*
      COREOTN_FMF1_FRM_RCP12   = 0,
      COREOTN_FMF1_FRM_RCP96,
      COREOTN_FMF2_FRM_RCP12,
      COREOTN_FMF2_FRM_RCP96,
      COREOTN_FO1_FRM_RCP,
      COREOTN_FO2_FRM_RCP,
    */
    switch (frm_rcp_instance)
    {
    case COREOTN_FMF1_FRM_RCP12:
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        break;
    case COREOTN_FMF1_FRM_RCP96:
        coreotn_fmf_field_FRM_RCP96_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fmf_field_FRM_RCP96_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        break;
    case COREOTN_FMF2_FRM_RCP12:
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        break;
    case COREOTN_FMF2_FRM_RCP96:
        coreotn_fmf_field_FRM_RCP96_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fmf_field_FRM_RCP96_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        break;
    case COREOTN_FO1_FRM_RCP:
        coreotn_fo_field_FRM_RCP_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fo_field_FRM_RCP_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        break;
    case COREOTN_FO2_FRM_RCP:
        coreotn_fo_field_FRM_RCP_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fo_field_FRM_RCP_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        break;
    case LAST_COREOTN_FRM_RCP:
        break;
    }
    

    PMC_RETURN();

} /* coreotn_frm_rcp_energy_state_reg_set */


/*******************************************************************************
*  coreotn_odukp_frm_rcp_cfc_fifo_activate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures an FRM_RCP block in COREOTN to be in low power
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   init_op             - enum, COREOTN init operation. See coreotn_init_operation_t.
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_odukp_frm_rcp_cfc_fifo_activate(coreotn_handle_t *coreotn_handle,
                                                     coreotn_init_operation_t init_op)
{
    /* Variable declaration */
    UINT32 cfc_fifo_clrb_12 = 0xfff;
    UINT32 cfc_fifo_clrb_96_off[3];
    UINT32 cfc_fifo_clrb_96_on[3];
    UINT32 i;
    
    PMC_ENTRY();
    
    for(i = 0; i < 3; i++)
    {
        cfc_fifo_clrb_96_on[i] = 0xffffffff;
        cfc_fifo_clrb_96_off[i] = 0;
    }

    switch (init_op)
    {
    case COREOTN_SS_OPERATIONAL_MODE:
        /* COREOTN_FMF1_FRM_RCP12 
           COREOTN_FMF1_FRM_RCP96
           COREOTN_FMF2_FRM_RCP96 
           COREOTN_FO1_FRM_RCP*/
        coreotn_fmf_field_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_lfield_CFC_FIFO2_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_off);
        coreotn_fmf_lfield_CFC_FIFO2_CLRB_CFG_set(NULL, coreotn_handle, 1, cfc_fifo_clrb_96_off);
        coreotn_fo_lfield_CFC_FIFO_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_off);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 0, 1);
        coreotn_fmf_field_FRM_RCP96_RST_set(NULL, coreotn_handle, 0, 1);
        coreotn_fmf_field_FRM_RCP96_RST_set(NULL, coreotn_handle, 1, 1);
        coreotn_fo_field_FRM_RCP_RST_set(NULL, coreotn_handle, 0, 1);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 0, 1);
        coreotn_fmf_field_FRM_RCP96_LOWPWR_set(NULL, coreotn_handle, 0, 1);
        coreotn_fmf_field_FRM_RCP96_LOWPWR_set(NULL, coreotn_handle, 1, 1);
        coreotn_fo_field_FRM_RCP_LOWPWR_set(NULL, coreotn_handle, 0, 1);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_12);
        coreotn_fmf_lfield_CFC_FIFO2_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_on);
        coreotn_fmf_lfield_CFC_FIFO2_CLRB_CFG_set(NULL, coreotn_handle, 1, cfc_fifo_clrb_96_on);
        coreotn_fo_lfield_CFC_FIFO_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_on);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_field_FRM_RCP96_LOWPWR_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_field_FRM_RCP96_LOWPWR_set(NULL, coreotn_handle, 1, 0);
        coreotn_fo_field_FRM_RCP_LOWPWR_set(NULL, coreotn_handle, 0, 0);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_field_FRM_RCP96_RST_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_field_FRM_RCP96_RST_set(NULL, coreotn_handle, 1, 0);
        coreotn_fo_field_FRM_RCP_RST_set(NULL, coreotn_handle, 0, 0);
        /*PMC_Q_USLEEP(coreotn_handle,100);*/
        break;    
    case COREOTN_SS_ONE_STAGE_MUXING_MODE:
        /* COREOTN_FMF1_FRM_RCP96
           COREOTN_FMF1_FRM_RCP12
           COREOTN_FO1_FRM_RCP */
        coreotn_fmf_field_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_lfield_CFC_FIFO2_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_off);
        coreotn_fo_lfield_CFC_FIFO_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_off);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 0, 1);
        coreotn_fmf_field_FRM_RCP96_RST_set(NULL, coreotn_handle, 0, 1);
        coreotn_fo_field_FRM_RCP_RST_set(NULL, coreotn_handle, 0, 1);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 0, 1);
        coreotn_fmf_field_FRM_RCP96_LOWPWR_set(NULL, coreotn_handle, 0, 1);
        coreotn_fo_field_FRM_RCP_LOWPWR_set(NULL, coreotn_handle, 0, 1);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_12);
        coreotn_fmf_lfield_CFC_FIFO2_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_on);
        coreotn_fo_lfield_CFC_FIFO_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_on);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_field_FRM_RCP96_LOWPWR_set(NULL, coreotn_handle, 0, 0);
        coreotn_fo_field_FRM_RCP_LOWPWR_set(NULL, coreotn_handle, 0, 0);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_field_FRM_RCP96_RST_set(NULL, coreotn_handle, 0, 0);
        coreotn_fo_field_FRM_RCP_RST_set(NULL, coreotn_handle, 0, 0);
        /*PMC_Q_USLEEP(coreotn_handle,100);*/
        break;    
    case COREOTN_SS_SYSOTN_MODE:
        /* COREOTN_FMF1_FRM_RCP12
           COREOTN_FMF1_FRM_RCP96 
           COREOTN_FMF2_FRM_RCP12 
           COREOTN_FMF2_FRM_RCP96
           COREOTN_FO1_FRM_RCP */
        coreotn_fmf_field_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_lfield_CFC_FIFO2_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_off);
        coreotn_fmf_field_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 1, 0);
        coreotn_fmf_lfield_CFC_FIFO2_CLRB_CFG_set(NULL, coreotn_handle, 1, cfc_fifo_clrb_96_off);
        coreotn_fo_lfield_CFC_FIFO_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_off);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 0, 1);
        coreotn_fmf_field_FRM_RCP96_RST_set(NULL, coreotn_handle, 0, 1);
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 1, 1);
        coreotn_fmf_field_FRM_RCP96_RST_set(NULL, coreotn_handle, 1, 1);
        coreotn_fo_field_FRM_RCP_RST_set(NULL, coreotn_handle, 0, 1);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 0, 1);
        coreotn_fmf_field_FRM_RCP96_LOWPWR_set(NULL, coreotn_handle, 0, 1);
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 1, 1);
        coreotn_fmf_field_FRM_RCP96_LOWPWR_set(NULL, coreotn_handle, 1, 1);
        coreotn_fo_field_FRM_RCP_LOWPWR_set(NULL, coreotn_handle, 0, 1);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_12);
        coreotn_fmf_lfield_CFC_FIFO2_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_on);
        coreotn_fmf_field_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 1, cfc_fifo_clrb_12);
        coreotn_fmf_lfield_CFC_FIFO2_CLRB_CFG_set(NULL, coreotn_handle, 1, cfc_fifo_clrb_96_on);
        coreotn_fo_lfield_CFC_FIFO_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_on);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_field_FRM_RCP96_LOWPWR_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 1, 0);
        coreotn_fmf_field_FRM_RCP96_LOWPWR_set(NULL, coreotn_handle, 1, 0);
        coreotn_fo_field_FRM_RCP_LOWPWR_set(NULL, coreotn_handle, 0, 0);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_field_FRM_RCP96_RST_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 1, 0);
        coreotn_fmf_field_FRM_RCP96_RST_set(NULL, coreotn_handle, 1, 0);
        coreotn_fo_field_FRM_RCP_RST_set(NULL, coreotn_handle, 0, 0);
        /* PMC_Q_USLEEP(coreotn_handle,100); */
        break;  
    case COREOTN_SS_SYSOTN_BYPASS_MODE:
            
        /*  COREOTN_FMF1_FRM_RCP12
            COREOTN_FMF1_FRM_RCP96 
            COREOTN_FMF2_FRM_RCP12
            COREOTN_FO1_FRM_RCP */
        coreotn_fmf_field_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_lfield_CFC_FIFO2_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_off);
        coreotn_fmf_field_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 1, 0);
        coreotn_fo_lfield_CFC_FIFO_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_off);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 0, 1);
        coreotn_fmf_field_FRM_RCP96_RST_set(NULL, coreotn_handle, 0, 1);
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 1, 1);
        coreotn_fo_field_FRM_RCP_RST_set(NULL, coreotn_handle, 0, 1);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 0, 1);
        coreotn_fmf_field_FRM_RCP96_LOWPWR_set(NULL, coreotn_handle, 0, 1);
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 1, 1);
        coreotn_fo_field_FRM_RCP_LOWPWR_set(NULL, coreotn_handle, 0, 1);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_12);
        coreotn_fmf_lfield_CFC_FIFO2_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_on);
        coreotn_fmf_field_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 1, cfc_fifo_clrb_12);
        coreotn_fo_lfield_CFC_FIFO_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_on);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_field_FRM_RCP96_LOWPWR_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 1, 0);
        coreotn_fo_field_FRM_RCP_LOWPWR_set(NULL, coreotn_handle, 0, 0);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_field_FRM_RCP96_RST_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 1, 0);
        coreotn_fo_field_FRM_RCP_RST_set(NULL, coreotn_handle, 0, 0);
        /* PMC_Q_USLEEP(coreotn_handle,100);*/
        break; 
    case COREOTN_SS_BYPASS_MODE:
        /* COREOTN_FMF1_FRM_RCP12
           COREOTN_FO1_FRM_RCP  */
        coreotn_fmf_field_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 0, 0);
        coreotn_fo_lfield_CFC_FIFO_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_off);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 0, 1);
        coreotn_fo_field_FRM_RCP_RST_set(NULL, coreotn_handle, 0, 1);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 0, 1);
        coreotn_fo_field_FRM_RCP_LOWPWR_set(NULL, coreotn_handle, 0, 1);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_12);
        coreotn_fo_lfield_CFC_FIFO_CLRB_CFG_set(NULL, coreotn_handle, 0, cfc_fifo_clrb_96_on);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_LOWPWR_set(NULL, coreotn_handle, 0, 0);
        coreotn_fo_field_FRM_RCP_LOWPWR_set(NULL, coreotn_handle, 0, 0);
        PMC_Q_USLEEP(coreotn_handle,100);
            
        coreotn_fmf_field_FRM_RCP12_RST_set(NULL, coreotn_handle, 0, 0);
        coreotn_fo_field_FRM_RCP_RST_set(NULL, coreotn_handle, 0, 0);
        /*PMC_Q_USLEEP(coreotn_handle,100); */
    default:
        break;  
    }  
    
    PMC_RETURN();                         
} /* coreotn_odukp_frm_rcp_cfc_fifo_activate */

/*******************************************************************************
*  coreotn_stg4_frm_rcp_cfc_fifo_activate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures an FRM_RCP block in COREOTN to be in low power
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_stg4_frm_rcp_cfc_fifo_activate(coreotn_handle_t *coreotn_handle)
{
    /* Variable declaration */
    UINT32 cfc_fifo_clrb_96_off[3];
    UINT32 cfc_fifo_clrb_96_on[3];
    UINT32 i;
    
    PMC_ENTRY();

    for(i = 0; i < 3; i++)
    {
        cfc_fifo_clrb_96_on[i] = 0xffffffff;
        cfc_fifo_clrb_96_off[i] = 0;
    }

    coreotn_fo_lfield_CFC_FIFO_CLRB_CFG_set(NULL, coreotn_handle, 1, cfc_fifo_clrb_96_off);
    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,100);
    /*PMC_Q_USLEEP(coreotn_handle,100);*/
    
    coreotn_fo_field_FRM_RCP_RST_set(NULL, coreotn_handle, 1, 1);
    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,100);
    /*PMC_Q_USLEEP(coreotn_handle,100);*/
    
    coreotn_fo_field_FRM_RCP_LOWPWR_set(NULL, coreotn_handle, 1, 1);
    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,100);
    /*PMC_Q_USLEEP(coreotn_handle,100);*/
    
    coreotn_fo_lfield_CFC_FIFO_CLRB_CFG_set(NULL, coreotn_handle, 1, cfc_fifo_clrb_96_on);
    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,100);
    /*PMC_Q_USLEEP(coreotn_handle,100);*/
    
    coreotn_fo_field_FRM_RCP_LOWPWR_set(NULL, coreotn_handle, 1, 0);
    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,100);
    /*PMC_Q_USLEEP(coreotn_handle,100);*/
    
    coreotn_fo_field_FRM_RCP_RST_set(NULL, coreotn_handle, 1, 0);
    /*PMC_Q_USLEEP(coreotn_handle,100); */
    
    PMC_RETURN();
    
} /* coreotn_stg4_frm_rcp_cfc_fifo_activate */
       
/*******************************************************************************
*  coreotn_mpmo_energy_state_reg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current energy state of an MPMO block.
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   mpmo_instance       - MPMO instance in COREOTN. See coreotn_mpmo_inst_t
*   *mpmo_energy_state  - current energy state of MPMO
*
*
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_mpmo_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                               coreotn_mpmo_inst_t mpmo_instance,
                                               pmc_energy_state_t *mpmo_energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    /*
    ** Check MPMA_RST and MPMA_LOWPWR by reading directly from the register
    ** based on reset and lowpwr value assign appropriate energy state
    */
    switch (mpmo_instance)
    {
    case COREOTN_MPMO_TO_COREOTN:
        reset_val = coreotn_fo_field_MPMO_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMO_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fo_field_MPMO_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMO_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fo_field_MPMO_RAM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMO_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_MPMO_TO_MAPOTN:
        reset_val = coreotn_fo_field_MPMO_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMO_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fo_field_MPMO_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMO_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fo_field_MPMO_RAM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMO_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_MPMO_CORECTL:
        reset_val = coreotn_ctl_field_MPMO_RST_get(NULL, coreotn_handle);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMO_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_ctl_field_MPMO_LOWPWR_get(NULL, coreotn_handle);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMO_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_ctl_field_MPMO_RAM_LOWPWR_get(NULL, coreotn_handle);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading MPMO_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            
    }

    *mpmo_energy_state = util_global_recover_energy_state(lowpwr_val,ram_lowpwr_val,reset_val);

    PMC_RETURN();

} /* coreotn_mpmo_energy_state_reg_get */


/*******************************************************************************
*  coreotn_mpmo_energy_state_reg_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures an MPMA block in COREOTN to be in low power
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   mpmo_instance       - MPMA instance in COREOTN. See coreotn_mpmo_inst_t
*   energy_state - Energy state of MPMA\n
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_mpmo_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                               coreotn_mpmo_inst_t mpmo_instance,
                                               pmc_energy_state_t energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    switch (energy_state)
    {
    case PMC_ENERGY_STATE_RUNNING:
        reset_val = 0;
        lowpwr_val = 0;
        ram_lowpwr_val = 0;
        break;
    case PMC_ENERGY_STATE_RESET:
        reset_val = 1;
        lowpwr_val = 1;
        ram_lowpwr_val = 1;
        break;
    default:
        /*PMC_RETURN(some error);*/
        break;
    }


    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "reset_val = %u\n", reset_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "lowpwr_val = %u\n", lowpwr_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "ram_lowpwr_val = %u\n", ram_lowpwr_val);

    switch (mpmo_instance)
    {
    case COREOTN_MPMO_TO_COREOTN:
        coreotn_fo_field_MPMO_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fo_field_MPMO_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        coreotn_fo_field_MPMO_RAM_LOWPWR_set(NULL, coreotn_handle, 0, ram_lowpwr_val);
        break;
    case COREOTN_MPMO_TO_MAPOTN:
        coreotn_fo_field_MPMO_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fo_field_MPMO_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        coreotn_fo_field_MPMO_RAM_LOWPWR_set(NULL, coreotn_handle, 1, ram_lowpwr_val);
        break;
    case COREOTN_MPMO_CORECTL:
        coreotn_ctl_field_MPMO_RST_set(NULL, coreotn_handle, reset_val);
        coreotn_ctl_field_MPMO_LOWPWR_set(NULL, coreotn_handle, lowpwr_val);
        coreotn_ctl_field_MPMO_RAM_LOWPWR_set(NULL, coreotn_handle, ram_lowpwr_val);
        break;
    default:
        /* Should not have any other case */
        PMC_ASSERT(FALSE, COREOTN_ERR_INVALID_ARG, mpmo_instance, 0);
        break;
    }

    PMC_RETURN();

} /* coreotn_mpmo_energy_state_reg_set */

/*******************************************************************************
*  coreotn_odu_rfrm_energy_state_reg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current energy state of an ODU_RFRM block.
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle         - pointer to COREOTN handle instance to be operated on
*   rfrm_stg                - ODU_RFRM stage in COREOTN. See coreotn_odu_rfrm_inst_t
*   *odu_rfrm_energy_state  - current energy state of ODU_RFRM
*
*
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_odu_rfrm_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odu_rfrm_inst_t rfrm_stg,
                                                   pmc_energy_state_t *odu_rfrm_energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    /*
    ** Check MPMA_RST and MPMA_LOWPWR by reading directly from the register
    ** based on reset and lowpwr value assign appropriate energy state
    */
    switch (rfrm_stg)
    {
    case COREOTN_ODU_RFRM_STG1:
        reset_val = coreotn_fmf_field_RFRM12_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STG1: Reading ODU_RFRM_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_RFRM12_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STG1: Reading ODU_RFRM_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_RFRM12_RAM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STG1: Reading ODU_RFRM_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_ODU_RFRM_STG2:
        reset_val = coreotn_fmf_field_RFRM96_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STG2: Reading ODU_RFRM_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_RFRM96_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STG2: Reading ODU_RFRM_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_RFRM96_RAM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STG2: Reading ODU_RFRM_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_ODU_RFRM_STGN:
        reset_val = coreotn_fmf_field_RFRM12_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STGN: Reading ODU_RFRM_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_RFRM12_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STGN: Reading ODU_RFRM_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_RFRM12_RAM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STGN: Reading ODU_RFRM_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_ODU_RFRM_STG3A:
        reset_val = coreotn_fmf_field_RFRM96_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STG3A: Reading ODU_RFRM_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_RFRM96_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STG3A: Reading ODU_RFRM_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_RFRM96_RAM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STG3A: Reading ODU_RFRM_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_ODU_RFRM_STG3B:
        reset_val = coreotn_fo_field_RFRM_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STG3B: Reading ODU_RFRM_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fo_field_RFRM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STG3B: Reading ODU_RFRM_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fo_field_RFRM_RAM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STG3B: Reading ODU_RFRM_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_ODU_RFRM_STG4:
        reset_val = coreotn_fo_field_RFRM_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STG4: Reading ODU_RFRM_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fo_field_RFRM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STG4: Reading ODU_RFRM_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fo_field_RFRM_RAM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "COREOTN_ODU_RFRM_STG4: Reading ODU_RFRM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            

    }

    *odu_rfrm_energy_state = util_global_recover_energy_state(lowpwr_val,ram_lowpwr_val,reset_val);
    
    PMC_RETURN();

} /* coreotn_odu_rfrm_energy_state_reg_get */


/*******************************************************************************
*  coreotn_odu_rfrm_energy_state_reg_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures an ODU_RFRM block in COREOTN to be in low power
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   rfrm_stg            - ODU_RFRM stage in COREOTN. See coreotn_odu_rfrm_inst_t
*   energy_state - Energy state of ODU_RFRM\n
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_odu_rfrm_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odu_rfrm_inst_t rfrm_stg,
                                                   pmc_energy_state_t energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    switch (energy_state)
    {
    case PMC_ENERGY_STATE_RUNNING:
        reset_val = 0;
        lowpwr_val = 0;
        ram_lowpwr_val = 0;
        break;
    case PMC_ENERGY_STATE_RESET:
        reset_val = 1;
        lowpwr_val = 1;
        ram_lowpwr_val = 1;
        break;
    default:
        /*PMC_RETURN(some error);*/
        break;
    }


    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "reset_val = %u\n", reset_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "lowpwr_val = %u\n", lowpwr_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "ram_lowpwr_val = %u\n", ram_lowpwr_val);

    switch (rfrm_stg)
    {
    case COREOTN_ODU_RFRM_STG1:
        coreotn_fmf_field_RFRM12_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fmf_field_RFRM12_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        coreotn_fmf_field_RFRM12_RAM_LOWPWR_set(NULL, coreotn_handle, 0, ram_lowpwr_val);
        break;
    case COREOTN_ODU_RFRM_STG2:
        coreotn_fmf_field_RFRM96_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fmf_field_RFRM96_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        coreotn_fmf_field_RFRM96_RAM_LOWPWR_set(NULL, coreotn_handle, 0, ram_lowpwr_val);
        break;
    case COREOTN_ODU_RFRM_STGN:
        coreotn_fmf_field_RFRM12_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fmf_field_RFRM12_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        coreotn_fmf_field_RFRM12_RAM_LOWPWR_set(NULL, coreotn_handle, 1, ram_lowpwr_val);
        break;
    case COREOTN_ODU_RFRM_STG3A:
        coreotn_fmf_field_RFRM96_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fmf_field_RFRM96_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        coreotn_fmf_field_RFRM96_RAM_LOWPWR_set(NULL, coreotn_handle, 1, ram_lowpwr_val);
        break;
    case COREOTN_ODU_RFRM_STG3B:
        coreotn_fo_field_RFRM_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fo_field_RFRM_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        coreotn_fo_field_RFRM_RAM_LOWPWR_set(NULL, coreotn_handle, 0, ram_lowpwr_val);
        break;
    case COREOTN_ODU_RFRM_STG4:
        coreotn_fo_field_RFRM_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fo_field_RFRM_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        coreotn_fo_field_RFRM_RAM_LOWPWR_set(NULL, coreotn_handle, 1, ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            
    }

    PMC_RETURN();

} /* coreotn_odu_rfrm_energy_state_reg_set */

/*******************************************************************************
*  coreotn_odu_tfrm_energy_state_reg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current energy state of an ODU_TFRM block.
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle         - pointer to COREOTN handle instance to be operated on
*   tfrm_stg                - ODU_TFRM stage in COREOTN. See coreotn_odu_tfrm_inst_t
*   *odu_tfrm_energy_state  - current energy state of ODU_TFRM
*
*
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_odu_tfrm_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odu_tfrm_inst_t tfrm_stg,
                                                   pmc_energy_state_t *odu_tfrm_energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    /*
    ** Check ODU_RFRM_RST and ODU_RFRM_LOWPWR by reading directly from the register
    ** based on reset and lowpwr value assign appropriate energy state
    */
    switch (tfrm_stg)
    {
    case COREOTN_ODU_TFRM_STG1:
        reset_val = coreotn_fmf_field_TFRM12_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_TFRM12_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_TFRM12_RAM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_ODU_TFRM_STG2:
        reset_val = coreotn_fmf_field_TFRM96_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_TFRM96_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_TFRM96_RAM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_ODU_TFRM_STGN:
        reset_val = coreotn_fmf_field_TFRM12_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_TFRM12_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_TFRM12_RAM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_ODU_TFRM_STG3A:
        reset_val = coreotn_fmf_field_TFRM96_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_TFRM96_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_TFRM96_RAM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_ODU_TFRM_STG3B:
        reset_val = coreotn_fo_field_TFRM_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fo_field_TFRM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fo_field_TFRM_RAM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_ODU_TFRM_STG4:
        reset_val = coreotn_fo_field_TFRM_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_TFRM_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fo_field_TFRM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_RFRM_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fo_field_TFRM_RAM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODU_RFRM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            

    }

    *odu_tfrm_energy_state = util_global_recover_energy_state(lowpwr_val,ram_lowpwr_val,reset_val);

    PMC_RETURN();

} /* coreotn_odu_tfrm_energy_state_reg_get */


/*******************************************************************************
*  coreotn_odu_tfrm_energy_state_reg_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures an ODU_TFRM block in COREOTN to be in low power
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   tfrm_stg            - ODU_TFRM stage in COREOTN. See coreotn_odu_tfrm_inst_t
*   energy_state - Energy state of ODU_TFRM\n
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_odu_tfrm_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odu_tfrm_inst_t tfrm_stg,
                                                   pmc_energy_state_t energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    switch (energy_state)
    {
    case PMC_ENERGY_STATE_RUNNING:
        reset_val = 0;
        lowpwr_val = 0;
        ram_lowpwr_val = 0;
        break;
    case PMC_ENERGY_STATE_RESET:
        reset_val = 1;
        lowpwr_val = 1;
        ram_lowpwr_val = 1;
        break;
    default:
        /*PMC_RETURN(some error);*/
        break;
    }


    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "reset_val = %u\n", reset_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "lowpwr_val = %u\n", lowpwr_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "ram_lowpwr_val = %u\n", ram_lowpwr_val);

    switch (tfrm_stg)
    {
    case COREOTN_ODU_TFRM_STG1:
        coreotn_fmf_field_TFRM12_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fmf_field_TFRM12_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        coreotn_fmf_field_TFRM12_RAM_LOWPWR_set(NULL, coreotn_handle, 0, ram_lowpwr_val);
        break;
    case COREOTN_ODU_TFRM_STG2:
        coreotn_fmf_field_TFRM96_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fmf_field_TFRM96_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        coreotn_fmf_field_TFRM96_RAM_LOWPWR_set(NULL, coreotn_handle, 0, ram_lowpwr_val);
        break;
    case COREOTN_ODU_TFRM_STGN:
        coreotn_fmf_field_TFRM12_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fmf_field_TFRM12_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        coreotn_fmf_field_TFRM12_RAM_LOWPWR_set(NULL, coreotn_handle, 1, ram_lowpwr_val);
        break;
    case COREOTN_ODU_TFRM_STG3A:
        coreotn_fmf_field_TFRM96_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fmf_field_TFRM96_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        coreotn_fmf_field_TFRM96_RAM_LOWPWR_set(NULL, coreotn_handle, 1, ram_lowpwr_val);
        break;
    case COREOTN_ODU_TFRM_STG3B:
        coreotn_fo_field_TFRM_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fo_field_TFRM_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        coreotn_fo_field_TFRM_RAM_LOWPWR_set(NULL, coreotn_handle, 0, ram_lowpwr_val);
        break;
    case COREOTN_ODU_TFRM_STG4:
        coreotn_fo_field_TFRM_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fo_field_TFRM_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        coreotn_fo_field_TFRM_RAM_LOWPWR_set(NULL, coreotn_handle, 1, ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            
    }

    PMC_RETURN();

} /* coreotn_odu_tfrm_energy_state_reg_set */

/*******************************************************************************
*  coreotn_odtu_dmx_energy_state_reg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current energy state of an ODU_TFRM block.
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle    - pointer to COREOTN handle instance to be operated on
*   dmx_stg            - ODTU_DMX stage in COREOTN. See coreotn_odtu_dmx_inst_t
*   *dmx_energy_state  - current energy state of ODU_TFRM
*
* OUTPUTS:
*  None 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_odtu_dmx_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odtu_dmx_inst_t dmx_stg,
                                                   pmc_energy_state_t *dmx_energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    /*
    ** Check ODTU_DMX_RST and ODTU_DMX_LOWPWR by reading directly from the register
    ** based on reset and lowpwr value assign appropriate energy state
    */
    switch (dmx_stg)
    {
    case COREOTN_ODTU_DMX_STG1:
        reset_val = coreotn_fmf_field_ODTU_DMX_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODTU_DMX_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_ODTU_DMX_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODTU_DMX_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_ODTU_DMX_RAM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODTU_DMX_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_ODTU_DMX_STG2:
        reset_val = coreotn_fmf_field_ODTU_DMX_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODTU_DMX_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_ODTU_DMX_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODTU_DMX_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_ODTU_DMX_RAM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODTU_DMX_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            
    }

    *dmx_energy_state = util_global_recover_energy_state(lowpwr_val,ram_lowpwr_val,reset_val);

    PMC_RETURN();

} /* coreotn_odtu_dmx_energy_state_reg_get */


/*******************************************************************************
*  coreotn_odtu_dmx_energy_state_reg_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures an ODTU_DMX block in COREOTN to be in low power
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   dmx_stg             - ODTU_DMX stage in COREOTN. See coreotn_odtu_dmx_inst_t
*   energy_state - Energy state of ODU_TFRM\n

* OUTPUTS:
*
* RETURNS:
*   None
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_odtu_dmx_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odtu_dmx_inst_t dmx_stg,
                                                   pmc_energy_state_t energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    switch (energy_state)
    {
    case PMC_ENERGY_STATE_RUNNING:
        reset_val = 0;
        lowpwr_val = 0;
        ram_lowpwr_val = 0;
        break;
    case PMC_ENERGY_STATE_RESET:
        reset_val = 1;
        lowpwr_val = 1;
        ram_lowpwr_val = 1;
        break;
    default:
        break;
    }


    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "reset_val = %u\n", reset_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "lowpwr_val = %u\n", lowpwr_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "ram_lowpwr_val = %u\n", ram_lowpwr_val);

    switch (dmx_stg)
    {
    case COREOTN_ODTU_DMX_STG1:
        coreotn_fmf_field_ODTU_DMX_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fmf_field_ODTU_DMX_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        coreotn_fmf_field_ODTU_DMX_RAM_LOWPWR_set(NULL, coreotn_handle, 0, ram_lowpwr_val);
        break;
    case COREOTN_ODTU_DMX_STG2:
        coreotn_fmf_field_ODTU_DMX_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fmf_field_ODTU_DMX_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        coreotn_fmf_field_ODTU_DMX_RAM_LOWPWR_set(NULL, coreotn_handle, 1, ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            
    }

    PMC_RETURN();

} /* coreotn_odtu_dmx_energy_state_reg_set */


/*******************************************************************************
*  coreotn_ohfs_remove_energy_state_reg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current energy state of an OHFS_REMOVE block in COREOTN FO1 
*   and FO2 PCBI_SLV.
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle    - pointer to COREOTN handle instance to be operated on
*   ohfs_remove_blk    - OHFS_REMOVE block in COREOTN FO1/FO2 MTSB PCBI_SLV. 
*                        See ohfs_remove_blk
*
* OUTPUTS:
*   *ohfs_remove_energy_state  - current energy state of OHFS_REMOVE
*
* RETURNS:
*   None
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_ohfs_remove_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                      coreotn_ohfs_remove_inst_t ohfs_remove_blk,
                                                      pmc_energy_state_t *ohfs_remove_energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    /*
    ** Check ODTU_DMX_RST and ODTU_DMX_LOWPWR by reading directly from the register
    ** based on reset and lowpwr value assign appropriate energy state
    */
    switch (ohfs_remove_blk)
    {
        case COREOTN_FO1_OHFS_REMOVE:
            reset_val = coreotn_fo_field_OHFS_REMOVE_RST_get(NULL, coreotn_handle, 0);
            PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading OHFS_REMOVE_RST bit = %u\n", reset_val);

            lowpwr_val = coreotn_fo_field_OHFS_REMOVE_LOWPWR_get(NULL, coreotn_handle, 0);
            PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading OHFS_REMOVE_LOWPWR bit = %u\n", lowpwr_val);

            ram_lowpwr_val = coreotn_fo_field_OHFS_REMOVE_RAM_LOWPWR_get(NULL, coreotn_handle, 0);
            PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading OHFS_REMOVE_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
        case COREOTN_FO2_OHFS_REMOVE:
            reset_val = coreotn_fo_field_OHFS_REMOVE_RST_get(NULL, coreotn_handle, 1);
            PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading OHFS_REMOVE_RST bit = %u\n", reset_val);

            lowpwr_val = coreotn_fo_field_OHFS_REMOVE_LOWPWR_get(NULL, coreotn_handle, 1);
            PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading OHFS_REMOVE_LOWPWR bit = %u\n", lowpwr_val);

            ram_lowpwr_val = coreotn_fo_field_OHFS_REMOVE_RAM_LOWPWR_get(NULL, coreotn_handle, 1);
            PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading OHFS_REMOVE_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
        default:
            PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            
    }

    *ohfs_remove_energy_state = util_global_recover_energy_state(lowpwr_val,ram_lowpwr_val,reset_val);

    PMC_RETURN();

} /* coreotn_ohfs_remove_energy_state_reg_get */

/*******************************************************************************
*  coreotn_ohfs_remove_energy_state_reg_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures the power mode of OHFS_REMOVE block in COREOTN FO1 and 
*   COREOTN FO2.
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   ohfs_remove_blk     - OHFS_REMOVE instance in COREOTN. See coreotn_ohfs_remove_inst_t
*   energy_state        - Energy state of OHFS_REMOVE\n

* OUTPUTS:
*
* RETURNS:
*   None
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_ohfs_remove_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                      coreotn_ohfs_remove_inst_t ohfs_remove_blk,
                                                      pmc_energy_state_t energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    switch (energy_state)
    {
        case PMC_ENERGY_STATE_RUNNING:
            reset_val = 0;
            lowpwr_val = 0;
            ram_lowpwr_val = 0;
            break;
        case PMC_ENERGY_STATE_RESET:
            reset_val = 1;
            lowpwr_val = 1;
            ram_lowpwr_val = 1;
            break;
        default:
            break;
    }


    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "reset_val = %u\n", reset_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "lowpwr_val = %u\n", lowpwr_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "ram_lowpwr_val = %u\n", ram_lowpwr_val);

    switch (ohfs_remove_blk)
    {
        case COREOTN_FO1_OHFS_REMOVE:
            coreotn_fo_field_OHFS_REMOVE_RST_set(NULL, coreotn_handle, 0, reset_val);
            coreotn_fo_field_OHFS_REMOVE_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
            coreotn_fo_field_OHFS_REMOVE_RAM_LOWPWR_set(NULL, coreotn_handle, 0, ram_lowpwr_val);
        break;
        case COREOTN_FO2_OHFS_REMOVE:
            coreotn_fo_field_OHFS_REMOVE_RST_set(NULL, coreotn_handle, 1, reset_val);
            coreotn_fo_field_OHFS_REMOVE_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
            coreotn_fo_field_OHFS_REMOVE_RAM_LOWPWR_set(NULL, coreotn_handle, 1, ram_lowpwr_val);
        break;
        default:
            PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            
    }

    PMC_RETURN();

} /* coreotn_ohfs_remove_energy_state_reg_set */

/*******************************************************************************
*  coreotn_odtu_mux_energy_state_reg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current energy state of an ODTU_MUX block.
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle         - pointer to COREOTN handle instance to be operated on
*   mux_stg                 - ODTU_MUX stage in COREOTN. See coreotn_odtu_mux_inst_t
*   *mux_energy_state  - current energy state of ODTU_MUX
*
*
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_odtu_mux_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odtu_mux_inst_t mux_stg,
                                                   pmc_energy_state_t *mux_energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    /*
    ** Check ODTU_MUX_RST and ODTU_MUX_LOWPWR by reading directly from the register
    ** based on reset and lowpwr value assign appropriate energy state
    */
    switch (mux_stg)
    {
    case COREOTN_ODTU_MUX_STG1:
        reset_val = coreotn_fmf_field_ODTU_MUX_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODTU_DMX_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_ODTU_MUX_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODTU_DMX_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_ODTU_MUX_RAM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODTU_DMX_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_ODTU_MUX_STG2:
        reset_val = coreotn_fmf_field_ODTU_MUX_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODTU_DMX_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_ODTU_MUX_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODTU_DMX_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_ODTU_MUX_RAM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODTU_DMX_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            
    }

    *mux_energy_state = util_global_recover_energy_state(lowpwr_val,ram_lowpwr_val,reset_val);

    PMC_RETURN();

} /* coreotn_odtu_mux_energy_state_reg_get */


/*******************************************************************************
*  coreotn_odtu_mux_energy_state_reg_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures an ODTU_MUX block in COREOTN to be in low power
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   mux_stg            - ODTU_MUX stage in COREOTN. See coreotn_odtu_mux_inst_t
*   energy_state - Energy state of ODTU_MUX\n

* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_odtu_mux_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                   coreotn_odtu_mux_inst_t mux_stg,
                                                   pmc_energy_state_t energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    switch (energy_state)
    {
    case PMC_ENERGY_STATE_RUNNING:
        reset_val = 0;
        lowpwr_val = 0;
        ram_lowpwr_val = 0;
        break;
    case PMC_ENERGY_STATE_RESET:
        reset_val = 1;
        lowpwr_val = 1;
        ram_lowpwr_val = 1;
        break;
    default:
        break;
    }


    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "reset_val = %u\n", reset_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "lowpwr_val = %u\n", lowpwr_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "ram_lowpwr_val = %u\n", ram_lowpwr_val);

    switch (mux_stg)
    {
    case COREOTN_ODTU_MUX_STG1:
        coreotn_fmf_field_ODTU_MUX_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fmf_field_ODTU_MUX_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        coreotn_fmf_field_ODTU_MUX_RAM_LOWPWR_set(NULL, coreotn_handle, 0, ram_lowpwr_val);
        break;
    case COREOTN_ODTU_MUX_STG2:
        coreotn_fmf_field_ODTU_MUX_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fmf_field_ODTU_MUX_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        coreotn_fmf_field_ODTU_MUX_RAM_LOWPWR_set(NULL, coreotn_handle, 1, ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            
    }

    PMC_RETURN();

} /* coreotn_odtu_mux_energy_state_reg_set */

/*******************************************************************************
*  coreotn_oduksc_energy_state_reg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current energy state of an ODUKSC block.
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle      - pointer to COREOTN handle instance to be operated on
*   oduksc_inst          - ODUKSC stage in COREOTN. See coreotn_oduksc_inst_t
*   *oduksc_energy_state - current energy state of ODUKSC
*
*
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_oduksc_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                 coreotn_oduksc_inst_t oduksc_inst,
                                                 pmc_energy_state_t *oduksc_energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    /*
    ** Check ODUKSC_RST and ODUKSC_LOWPWR by reading directly from the register
    ** based on reset and lowpwr value assign appropriate energy state
    */
    switch (oduksc_inst)
    {
    case COREOTN_ODUKSC1:
        reset_val = coreotn_fmf_field_ODUKSC2_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODUKSC_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_ODUKSC2_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODUKSC_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_ODUKSC2_RAM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODUKSC_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_ODUKSC2:

        reset_val = coreotn_fmf_field_ODUKSC2_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODUKSC_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_ODUKSC2_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODUKSC_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_ODUKSC2_RAM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODUKSC_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            
    }

    *oduksc_energy_state = util_global_recover_energy_state(lowpwr_val,ram_lowpwr_val,reset_val);

    PMC_RETURN();

} /* coreotn_oduksc_energy_state_reg_get */


/*******************************************************************************
*  coreotn_oduksc_energy_state_reg_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures an ODUKSC block in COREOTN to be in low power
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   oduksc_inst         - ODUKSC stage in COREOTN. See coreotn_odtu_mux_inst_t
*   energy_state - Energy state of ODUKSC\n

* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_oduksc_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                 coreotn_oduksc_inst_t oduksc_inst,
                                                 pmc_energy_state_t energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    switch (energy_state)
    {
    case PMC_ENERGY_STATE_RUNNING:
        reset_val = 0;
        lowpwr_val = 0;
        ram_lowpwr_val = 0;
        break;
    case PMC_ENERGY_STATE_RESET:
        reset_val = 1;
        lowpwr_val = 1;
        ram_lowpwr_val = 1;
        break;
    default:
        break;
    }


    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "reset_val = %u\n", reset_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "lowpwr_val = %u\n", lowpwr_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "ram_lowpwr_val = %u\n", ram_lowpwr_val);

    switch (oduksc_inst)
    {
    case COREOTN_ODUKSC1:
        coreotn_fmf_field_ODUKSC2_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fmf_field_ODUKSC2_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        coreotn_fmf_field_ODUKSC2_RAM_LOWPWR_set(NULL, coreotn_handle, 0, ram_lowpwr_val);
        break;
    case COREOTN_ODUKSC2:
        coreotn_fmf_field_ODUKSC2_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fmf_field_ODUKSC2_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        coreotn_fmf_field_ODUKSC2_RAM_LOWPWR_set(NULL, coreotn_handle, 1, ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            
    }

    PMC_RETURN();

} /* coreotn_oduksc_energy_state_reg_set */

/*******************************************************************************
*  coreotn_odujat_energy_state_reg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current energy state of an ODUJAT block.
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle      - pointer to COREOTN handle instance to be operated on
*   odujat_inst          - ODUJAT stage in COREOTN. See coreotn_odujat_inst_t
*   *odujat_energy_state - current energy state of ODUJAT
*
*
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_odujat_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                                 coreotn_odujat_inst_t odujat_inst,
                                                 pmc_energy_state_t *odujat_energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    /*
    ** Check ODUJAT_RST and ODUJAT_LOWPWR by reading directly from the register
    ** based on reset and lowpwr value assign appropriate energy state
    */
    switch (odujat_inst)
    {
    case COREOTN_ODUJAT1:
        reset_val = coreotn_fmf_field_ODUJAT_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODUJAT_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_ODUJAT_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODUJAT_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_ODUJAT_RAM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODUJAT_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_ODUJAT2:
        reset_val = coreotn_fmf_field_ODUJAT_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODUJAT_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_ODUJAT_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODUJAT_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_ODUJAT_RAM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading ODUJAT_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            
    }
    *odujat_energy_state = util_global_recover_energy_state(lowpwr_val,ram_lowpwr_val,reset_val);

    PMC_RETURN();

} /* coreotn_odujat_energy_state_reg_get */


/*******************************************************************************
*  coreotn_oduksc_energy_state_reg_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures an ODUJAT block in COREOTN to be in low power
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   odujat_inst         - ODUJAT stage in COREOTN. See coreotn_odujat_inst_t
*   energy_state - Energy state of ODUJAT\n

* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_odujat_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                                 coreotn_odujat_inst_t odujat_inst,
                                                 pmc_energy_state_t energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    switch (energy_state)
    {
    case PMC_ENERGY_STATE_RUNNING:
        reset_val = 0;
        lowpwr_val = 0;
        ram_lowpwr_val = 0;
        break;
    case PMC_ENERGY_STATE_RESET:
        reset_val = 1;
        lowpwr_val = 1;
        ram_lowpwr_val = 1;
        break;
    default:
        break;
    }


    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "reset_val = %u\n", reset_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "lowpwr_val = %u\n", lowpwr_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "ram_lowpwr_val = %u\n", ram_lowpwr_val);

    switch ((coreotn_oduksc_inst_t)odujat_inst)
    {
    case COREOTN_ODUKSC1:
        coreotn_fmf_field_ODUJAT_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fmf_field_ODUJAT_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        coreotn_fmf_field_ODUJAT_RAM_LOWPWR_set(NULL, coreotn_handle, 0, ram_lowpwr_val);
        break;
    case COREOTN_ODUKSC2:
        coreotn_fmf_field_ODUJAT_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fmf_field_ODUJAT_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        coreotn_fmf_field_ODUJAT_RAM_LOWPWR_set(NULL, coreotn_handle, 1, ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            
    }

    PMC_RETURN();

} /* coreotn_odujat_energy_state_reg_set */

/*******************************************************************************
*  coreotn_prbs_energy_state_reg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves the current energy state of PRBS block.
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   prbs_instance       - PRBS instance in COREOTN. See coreotn_prbs_inst_t
*   *prbs_energy_state  - current energy state of PRBS
*
*
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_prbs_energy_state_reg_get(coreotn_handle_t *coreotn_handle,
                                               coreotn_prbs_inst_t prbs_instance,
                                               pmc_energy_state_t  *prbs_energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    /*
    ** Check MPMA_RST and MPMA_LOWPWR by reading directly from the register
    ** based on reset and lowpwr value assign appropriate energy state
    */
    switch (prbs_instance)
    {
    case COREOTN_FMF1_PRBS:
        reset_val = coreotn_fmf_field_PRBS_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading PRBS_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_PRBS_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading PRBS_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_PRBS_RAM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading PRBS_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_FMF2_PRBS:
        reset_val = coreotn_fmf_field_PRBS_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading PRBS_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fmf_field_PRBS_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading PRBS_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fmf_field_PRBS_RAM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading PRBS_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_FO1_PRBS:
        reset_val = coreotn_fo_field_PRBS_RST_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading PRBS_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fo_field_PRBS_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading PRBS_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fo_field_PRBS_RAM_LOWPWR_get(NULL, coreotn_handle, 0);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading PRBS_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    case COREOTN_FO2_PRBS:
        reset_val = coreotn_fo_field_PRBS_RST_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading PRBS_SOFT_RST bit = %u\n", reset_val);

        lowpwr_val = coreotn_fo_field_PRBS_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading PRBS_LOWPWR bit = %u\n", lowpwr_val);

        ram_lowpwr_val = coreotn_fo_field_PRBS_RAM_LOWPWR_get(NULL, coreotn_handle, 1);
        PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "Reading PRBS_RAM_LOWPWR bit = %u\n", ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(0,COREOTN_ERR_CODE_ASSERT,0,0);            
    }

    *prbs_energy_state = util_global_recover_energy_state(lowpwr_val,ram_lowpwr_val,reset_val);

    PMC_RETURN();

} /* coreotn_prbs_energy_state_reg_get */

/*******************************************************************************
*  coreotn_prbs_energy_state_reg_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures a PRBS block in COREOTN to be in low power
*   - power savings mode or out of low power mode and ready for individual
*   configuration.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   prbs_instance       - MPMA instance in COREOTN. See coreotn_prbs_inst_t
*   energy_state - Energy state of PRBS\n
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_prbs_energy_state_reg_set(coreotn_handle_t *coreotn_handle,
                                               coreotn_prbs_inst_t prbs_instance,
                                               pmc_energy_state_t energy_state)
{
    /* Variable declaration */
    UINT32 reset_val = 0;
    UINT32 lowpwr_val = 0;
    UINT32 ram_lowpwr_val = 0;

    PMC_ENTRY();

    switch (energy_state)
    {
    case PMC_ENERGY_STATE_RUNNING: 
        reset_val = 0;
        lowpwr_val = 0;
        ram_lowpwr_val = 0;
        break;
    case PMC_ENERGY_STATE_RESET:
        reset_val = 1;
        lowpwr_val = 1;
        ram_lowpwr_val = 1;
        break;
    default:
        break;
    }


    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "reset_val = %u\n", reset_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "lowpwr_val = %u\n", lowpwr_val);
    PMC_LOG(PMC_LOG_SEV_LOW, COREOTN_LOG_CODE_LOG, 0, 0, "ram_lowpwr_val = %u\n", ram_lowpwr_val);

    switch (prbs_instance)
    {
    case COREOTN_FMF1_PRBS:
        coreotn_fmf_field_PRBS_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fmf_field_PRBS_LOWPWR_set(NULL, coreotn_handle, 0, lowpwr_val);
        coreotn_fmf_field_PRBS_RAM_LOWPWR_set(NULL, coreotn_handle, 0, ram_lowpwr_val);
        break;
    case COREOTN_FMF2_PRBS:
        coreotn_fmf_field_PRBS_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fmf_field_PRBS_LOWPWR_set(NULL, coreotn_handle, 1, lowpwr_val);
        coreotn_fmf_field_PRBS_RAM_LOWPWR_set(NULL, coreotn_handle, 1, ram_lowpwr_val);
        break;
    case COREOTN_FO1_PRBS:
        coreotn_fo_field_PRBS_RST_set(NULL, coreotn_handle, 0, reset_val);
        coreotn_fo_field_PRBS_LOWPWR_set(NULL, coreotn_handle, 0,  lowpwr_val);
        coreotn_fo_field_PRBS_RAM_LOWPWR_set(NULL, coreotn_handle, 0, ram_lowpwr_val);
        break;
    case COREOTN_FO2_PRBS:
        coreotn_fo_field_PRBS_RST_set(NULL, coreotn_handle, 1, reset_val);
        coreotn_fo_field_PRBS_LOWPWR_set(NULL, coreotn_handle, 1,  lowpwr_val);
        coreotn_fo_field_PRBS_RAM_LOWPWR_set(NULL, coreotn_handle, 1, ram_lowpwr_val);
        break;
    default:
        PMC_ASSERT(NULL, COREOTN_ERR_INVALID_ARG, prbs_instance, 0);
        break;
    }

    PMC_RETURN();

} /* coreotn_prbs_energy_state_reg_set */


/*
** PRIVATE APIs
*/
/*******************************************************************************
*  coreotn_var_default_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Initializes COREOTN var_t variables.
*
* INPUTS:
*   *coreotn_handle - pointer to the coreotn handle
*   *coreotn_var      - pointer to COREOTN handle instance to be operated on
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_var_default_init(coreotn_handle_t *coreotn_handle, coreotn_var_t *coreotn_var)
{
    /* Variable declaration */
    UINT32 chnl;
    UINT32 i;
    UINT32 j;
    UINT32 k;

    PMC_ENTRY();
       
    for (i = 0; i < COREOTN_NUM_DDEG_MOD; i++)
    {
        /*by default, set context to use hardware ddeg */
        coreotn_var->ddeg_mon[i].ddeg_mode = LAST_COREOTN_DDEG_MODE;
        coreotn_var->ddeg_mon[i].mon_status = FALSE;
    }

    coreotn_var->ddeg_mon_seg = LAST_COREOTN_DDEG_MON_SEG;
   
    coreotn_var->prov_mode = COREOTN_ODU_CHNL_PROV_IN_INCREMENT;
   
    for (chnl = 0; chnl < 12; chnl++)
    { 
        coreotn_var->mux_profile[chnl].num_mo_chnls = 0xFF;
        coreotn_var->mux_profile[chnl].num_lo_chnls = 0xFF;
    }

    for (chnl = 0; chnl < 12; chnl++)
    {
        coreotn_var->rx_ho_chnl_ctxt[chnl].chnl_state = COREOTN_CHNL_START;
        coreotn_var->rx_ho_chnl_ctxt[chnl].payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
        coreotn_var->rx_ho_chnl_ctxt[chnl].odu_container = UTIL_GLOBAL_LAST_ODUK;                
        coreotn_var->rx_ho_chnl_ctxt[chnl].chnls_prov_cnt = 0;
        coreotn_var->rx_ho_chnl_ctxt[chnl].sub_chnls_prov_cnt = 0;
        
        coreotn_var->tx_ho_chnl_ctxt[chnl].chnl_state = COREOTN_CHNL_START;
        coreotn_var->tx_ho_chnl_ctxt[chnl].payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
        coreotn_var->tx_ho_chnl_ctxt[chnl].odu_container = UTIL_GLOBAL_LAST_ODUK;        
        coreotn_var->tx_ho_chnl_ctxt[chnl].chnls_prov_cnt = 0;
        coreotn_var->tx_ho_chnl_ctxt[chnl].sub_chnls_prov_cnt = 0;
        coreotn_var->sysapp_line_state[chnl] = COREOTN_CHNL_START;
    }

    for (chnl = 0; chnl < 96; chnl++)
    {
        coreotn_var->rx_mo_chnl_ctxt[chnl].chnl_state = COREOTN_CHNL_START;
        coreotn_var->rx_mo_chnl_ctxt[chnl].payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
        coreotn_var->rx_mo_chnl_ctxt[chnl].odu_container = UTIL_GLOBAL_LAST_ODUK;
        coreotn_var->rx_mo_chnl_ctxt[chnl].lo_odu_rate = UTIL_GLOBAL_LAST_ODUK;
        coreotn_var->rx_mo_chnl_ctxt[chnl].odu_flex_rate = 0;
        coreotn_var->rx_mo_chnl_ctxt[chnl].mapping_mode = (coreotn_mapping_type_t)UTIL_GLOBAL_NO_MAP;
        coreotn_var->rx_mo_chnl_ctxt[chnl].trib_port = 0;
        
        coreotn_var->rx_mo_chnl_ctxt[chnl].chnls_prov_cnt = 0;
        coreotn_var->rx_mo_chnl_ctxt[chnl].sub_chnls_prov_cnt = 0;
        
        coreotn_var->tx_mo_chnl_ctxt[chnl].chnl_state = COREOTN_CHNL_START;
        coreotn_var->tx_mo_chnl_ctxt[chnl].payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
        coreotn_var->tx_mo_chnl_ctxt[chnl].odu_container = UTIL_GLOBAL_LAST_ODUK;
        coreotn_var->tx_mo_chnl_ctxt[chnl].lo_odu_rate = UTIL_GLOBAL_LAST_ODUK;
        coreotn_var->tx_mo_chnl_ctxt[chnl].odu_flex_rate = 0;
        coreotn_var->tx_mo_chnl_ctxt[chnl].mapping_mode = (coreotn_mapping_type_t)UTIL_GLOBAL_NO_MAP;
        coreotn_var->tx_mo_chnl_ctxt[chnl].trib_port = 0;
        
        for (i = 0; i < COREOTN_TRIB_WRD_CNT; i++)
        {
            coreotn_var->rx_mo_chnl_ctxt[chnl].tribslot_mask[i] = 0;
            coreotn_var->rx_lo_chnl_ctxt[chnl].tribslot_mask[i] = 0;
            coreotn_var->tx_mo_chnl_ctxt[chnl].tribslot_mask[i] = 0;
            coreotn_var->tx_lo_chnl_ctxt[chnl].tribslot_mask[i] = 0;
        }
        coreotn_var->tx_mo_chnl_ctxt[chnl].chnls_prov_cnt = 0;
        coreotn_var->tx_mo_chnl_ctxt[chnl].sub_chnls_prov_cnt = 0;
        
        coreotn_var->rx_lo_chnl_ctxt[chnl].chnl_state = COREOTN_CHNL_START;
        coreotn_var->rx_lo_chnl_ctxt[chnl].payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
        coreotn_var->rx_lo_chnl_ctxt[chnl].odu_container = UTIL_GLOBAL_LAST_ODUK;
        coreotn_var->rx_lo_chnl_ctxt[chnl].lo_odu_rate = UTIL_GLOBAL_LAST_ODUK;
        coreotn_var->rx_lo_chnl_ctxt[chnl].odu_flex_rate = 0;
        coreotn_var->rx_lo_chnl_ctxt[chnl].mapping_mode = (coreotn_mapping_type_t)UTIL_GLOBAL_NO_MAP;
        coreotn_var->rx_lo_chnl_ctxt[chnl].trib_port = 0;
        
        coreotn_var->rx_lo_chnl_ctxt[chnl].chnls_prov_cnt = 0;
        coreotn_var->rx_lo_chnl_ctxt[chnl].sub_chnls_prov_cnt = 0;
        
        coreotn_var->tx_lo_chnl_ctxt[chnl].chnl_state = COREOTN_CHNL_START;
        coreotn_var->tx_lo_chnl_ctxt[chnl].payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
        coreotn_var->tx_lo_chnl_ctxt[chnl].odu_container = UTIL_GLOBAL_LAST_ODUK;
        coreotn_var->tx_lo_chnl_ctxt[chnl].lo_odu_rate = UTIL_GLOBAL_LAST_ODUK;
        coreotn_var->tx_lo_chnl_ctxt[chnl].odu_flex_rate = 0;
        coreotn_var->tx_lo_chnl_ctxt[chnl].mapping_mode = (coreotn_mapping_type_t)UTIL_GLOBAL_NO_MAP;
        coreotn_var->tx_lo_chnl_ctxt[chnl].trib_port = 0;
        
        coreotn_var->tx_lo_chnl_ctxt[chnl].chnls_prov_cnt = 0;
        coreotn_var->tx_lo_chnl_ctxt[chnl].sub_chnls_prov_cnt = 0;

        coreotn_var->tx_stg4_chnl_prov[chnl] = FALSE;
        coreotn_var->rx_stg4_chnl_prov[chnl] = FALSE;
       
        for (j = 0; j < COREOTN_OCPB_NUM_PORT; j++)
        {
            coreotn_var->rx_oduksw_chnl_ctxt[j][chnl].state = COREOTN_CHNL_START;
            coreotn_var->rx_oduksw_chnl_ctxt[j][chnl].input_map_count = 0;
            coreotn_var->rx_oduksw_chnl_ctxt[j][chnl].dest_active_count = 0;
        }
        
        for (j = 0; j < COREOTN_OCPB_NUM_PORT; j++)
        {    
            coreotn_var->tx_oduksw_chnl_ctxt[j][chnl].state = COREOTN_CHNL_START;
            coreotn_var->tx_oduksw_chnl_ctxt[j][chnl].input_map_count = 0;
            coreotn_var->tx_oduksw_chnl_ctxt[j][chnl].dest_active_count = 0;        
        }    
        coreotn_var->stg3b_odu_level[chnl] = LAST_ODU_STRUCT_LEVEL;
    }

    for (i = 0; i < LAST_ODU_STRUCT_LEVEL; i++)
    {
        for (j = 0; j < COREOTN_MAX_NUM_LO_CHNL; j++)
        {
            for (k = 0; k < ODU_STRUCT_PIDS_PER_CHNL; k++)
            {
                pmc_bitarray_t  *odu_ba_ptr;
                UINT32           bit_loc;
                
                
                /*
                 * HO ODU:       
                 *    Channel    Chnl 0   Chnl 1   Chnl 3   ...
                 *    Bitarray  [0000000][0000000][0000000] ... 
                 *    Bit Loc    0     6  7    13  14   20  ...
                 * 
                 * MO ODU:
                 *    Bitarray  [0000000][0000000][0000000] ...
                 * 
                 * LO ODU:
                 *    Bitarray  [0000000][0000000][0000000] ...
                 *
                 *    ...
                 */
                odu_ba_ptr = coreotn_var->tcm_pid_valid[(odu_struct_odu_level_t) i];
                bit_loc    = (j * ODU_STRUCT_PIDS_PER_CHNL) + k;
                                
                pmc_bitarray_clr_bit(odu_ba_ptr, bit_loc);                
            } /* end for: TCM PIDs per channel */
        } /* end for: max LO channels */
    } /* end for: odu levels */
    
    for (i = 0; i < (UINT32) LAST_COREOTN_PRBS_INST; i++)
    {
        for (j = 0; j < COREOTN_PRBS_NUM_CHNL; j++)
        {
            coreotn_var->prev_pm_mode[i][j] = ODU_TFRM_PM_TCM_START;
            coreotn_var->prbs_chnl_prov[i][j] = COREOTN_PRBS_MON_DISABLED;
        }
    }
    for (i = 0; i < 2; i++)
    {
        coreotn_var->extra_entry_ctxt[i].entry_state = FALSE;
        coreotn_var->extra_entry_ctxt[i].chnl_id = 0x7F;
        coreotn_var->extra_entry_ctxt[i].cycle = 0x7F;
    }
                            
    PMC_RETURN();
    
} /* coreotn_var_default_init */


/*******************************************************************************
*  coreotn_dci_mux4_xoff_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures the traffic through the second stage framer and demux based on
*   the number of stages involved in de-multiplexing ODUk traffic.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   fmf_inst            - COREOTN_INST_FMF1 -- FMF1 \n
*                         COREOTN_INST_FMF2 -- FMF2
*   dci_mux             - DCI MUX control 4 setting. 
*   xoff                - COREOTN_XOFF_SEL_ZERO \n
*                         COREOTN_XOFF_SEL_ONE
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_dci_mux4_xoff_cfg(coreotn_handle_t *coreotn_handle,
                                           coreotn_fmf_inst_t fmf_inst,
                                           coreotn_dci_mux4_src_t dci_mux, 
                                           coreotn_xoff_sel_t xoff)
{
    PMC_ERROR result = PMC_SUCCESS;
   
    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    
    /* argument checking */
    if ((fmf_inst >= LAST_COREOTN_FMF_INST) ||
        (dci_mux >= LAST_COREOTN_DCI_MUX4) ||
        (xoff >= LAST_COREOTN_XOFF_SEL)) {

        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    coreotn_dci_mux4_cfg(coreotn_handle, fmf_inst, dci_mux);

    coreotn_fmf_field_DCI_XOFF_CTRL_2_set(NULL, coreotn_handle, fmf_inst, xoff);
    
    PMC_RETURN(result);
} /* coreotn_dci_mux4_xoff_cfg */

/*******************************************************************************
*  coreotn_dci_mux3_pub_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures the traffic through the second stage framer and demux based on
*   the number of stages involved in de-multiplexing ODUk traffic.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   fmf_inst            - COREOTN_INST_FMF1 -- FMF1 \n
*                         COREOTN_INST_FMF2 -- FMF2
*   dci_mux             - DCI MUX control 3 setting. 
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_dci_mux3_pub_cfg(coreotn_handle_t *coreotn_handle,
                                          coreotn_fmf_inst_t fmf_inst,
                                          coreotn_dci_mux3_src_t dci_mux)
{
    PMC_ERROR result = PMC_SUCCESS;
   
    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    
    /* argument checking */
    if ((fmf_inst >= LAST_COREOTN_FMF_INST) ||
        (dci_mux >= LAST_COREOTN_DCI_MUX3)) {

        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    coreotn_dci_mux3_cfg(coreotn_handle, fmf_inst, dci_mux);

    PMC_RETURN(result);
} /* coreotn_dci_mux3_pub_cfg */

/*
** PRIVATE: COREOTN DCI MUX configuration APIs
*/
/*******************************************************************************
*  coreotn_dci_mux_ctrl_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Perform any initialization sequences in sub-blocks of COREOTN subsystem
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   init_operation      - Operational mode\n
*                         0 -- put coreotn in lowest energy state\n
*                         1 -- put coreotn resources operational\n
*                         2 -- put coreotn resources operational except OHP\n
*                         3 -- put second stage MUX/DMX in lowest energy state\n
*                         4 -- put first stage MUX/DMX in lowest energy state\n
*                         5 -- put coreotn in bypass mode
*
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_dci_mux_ctrl_cfg(coreotn_handle_t *coreotn_handle,
                                           coreotn_init_operation_t init_operation)
{
    /*
      COREOTN_SS_OPERATIONAL_MODE         
      COREOTN_SS_ONE_STAGE_MUXING_MODE    
      COREOTN_SS_SYSOTN_MODE              
      COREOTN_SS_BYPASS_MODE              
      COREOTN_SS_SYSOTN_BYPASS_MODE        */

    PMC_ENTRY();
    
    if(init_operation != COREOTN_SS_SYSOTN_MODE && init_operation != COREOTN_SS_SYSOTN_BYPASS_MODE) {

        /* Static MUX control configuration regardless of number of muxing stages */
        coreotn_dci_mux1_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX1_ODU_RFRM_12);
        coreotn_dci_mux2_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX2_ODTU_DMX);

        coreotn_dci_mux2_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX2_ODTU_DMX);

        /* static XOFF control configuration */
        /* no XOFF to RX line */
        coreotn_fmf_field_DCI_XOFF_CTRL_3_set(NULL, coreotn_handle, 0, 1);
        /* take from HO FMF */
        coreotn_fmf_field_DCI_XOFF_CTRL_3_set(NULL, coreotn_handle, 1, 1);

        /* configure MUX control */
        coreotn_dci_mux5_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX5_LO_DCI_INTF);
        coreotn_dci_mux5_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX5_LO_DCI_INTF);

        
        /* static XOFF control configuration */
        /* always take from line */
        coreotn_fmf_field_DCI_XOFF_CTRL_1_set(NULL, coreotn_handle, 0, 0);
        coreotn_fmf_field_DCI_XOFF_CTRL_1_set(NULL, coreotn_handle, 1, 1);

    } else {
        
        /* Static MUX control configuration regardless of number of muxing stages for SYSOTN */

        /*FMF1 static configs*/
        coreotn_dci_mux1_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX1_ODU_RFRM_12);

        coreotn_dci_mux2_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX2_COREOTN_CTL);

        coreotn_dci_mux3_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX3_MUX1_CTRL);

        coreotn_dci_mux4_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX4_ODU_RFRM_96);

        coreotn_dci_mux5_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX5_MUX3_CTRL);


        /* From TFRM... */
        coreotn_fmf_field_DCI_XOFF_CTRL_1_set(NULL, coreotn_handle, 0, 0);
        /* Need to receive backpressure from LINE TX interface... */
        coreotn_fmf_field_DCI_XOFF_CTRL_3_set(NULL, coreotn_handle, 0, 0);



        /*FMF2 static configs*/

        /*need to take from SYSOTN interface */
        coreotn_dci_mux1_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX1_ODU_RFRM_12);

        coreotn_dci_mux2_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX2_ODTU_DMX);

        coreotn_dci_mux5_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX5_LO_DCI_INTF);


        /* static XOFF control configuration */
        coreotn_fmf_field_DCI_XOFF_CTRL_1_set(NULL, coreotn_handle, 1, 0);

        coreotn_fmf_field_DCI_XOFF_CTRL_3_set(NULL, coreotn_handle, 1, 1);

    }

    /* configure DCI MUX controls */
    switch (init_operation)
    {
    case COREOTN_SS_OPERATIONAL_MODE:
        /* configure FMF2_MUX1 control */
        coreotn_dci_mux1_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX1_HO_DCI_INTF);
                                                                  
        /* configure FMF1_MUX3 control */                     
        coreotn_dci_mux3_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX3_ODU_RFRM_96);
                                                                  
        /* configure FMF2_MUX3 control */                     
        coreotn_dci_mux3_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX3_ODU_RFRM_96);
                                                                  
        /* configure FMF1_MUX4 control */                     
        coreotn_dci_mux4_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX4_ODTU_MUX);
                                                                  
        /* configure FMF2_MUX4 control */                     
        coreotn_dci_mux4_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX4_ODTU_MUX);

        /* XOFF config */
        coreotn_fmf_field_DCI_XOFF_CTRL_2_set(NULL, coreotn_handle, 0, 1);
        coreotn_fmf_field_DCI_XOFF_CTRL_2_set(NULL, coreotn_handle, 1, 1);

        break;
    case COREOTN_SS_ONE_STAGE_MUXING_MODE:
        /* configure FMF1_MUX1 control */
        coreotn_dci_mux1_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX1_ODU_RFRM_12);
                                                                  
        /* configure FMF1_MUX3 control */                     
        coreotn_dci_mux3_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX3_ODU_RFRM_96);
                                                                  
        /* configure FMF1_MUX4 control */                     
        coreotn_dci_mux4_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX4_ODTU_MUX);
            
        /* XOFF config */
        coreotn_fmf_field_DCI_XOFF_CTRL_2_set(NULL, coreotn_handle, 0, 1);
            
        /* configure FMF2_MUX1 control */
        coreotn_dci_mux1_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX1_HO_DCI_INTF);
                                                                   
        /* configure FMF2_MUX3 control */                      
        coreotn_dci_mux3_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX3_MUX1_CTRL);
                                                                   
        /* configure FMF2_MUX4 control */                      
        coreotn_dci_mux4_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX4_LO_DCI_INTF);
            
        /* XOFF config */
        coreotn_fmf_field_DCI_XOFF_CTRL_1_set(NULL, coreotn_handle, 1, 1);
        coreotn_fmf_field_DCI_XOFF_CTRL_2_set(NULL, coreotn_handle, 1, 0);
            
        break;
    case COREOTN_SS_SYSOTN_MODE:

        coreotn_dci_mux3_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX3_ODU_RFRM_96);
                                                                   
        coreotn_dci_mux4_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX4_ODTU_MUX);


        coreotn_fmf_field_DCI_XOFF_CTRL_2_set(NULL, coreotn_handle, 1, 1);

        break;
    case COREOTN_SS_SYSOTN_BYPASS_MODE:

        coreotn_dci_mux3_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX3_MUX1_CTRL);
                                                                  
        coreotn_dci_mux4_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX4_LO_DCI_INTF);


        coreotn_fmf_field_DCI_XOFF_CTRL_2_set(NULL, coreotn_handle, 1, 0);

        break;
    case COREOTN_SS_BYPASS_MODE:
        /* configure FMF1_MUX1 control */
        coreotn_dci_mux1_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX1_ODU_RFRM_12);
                                                                   
        /* configure FMF1_MUX3 control */                      
        coreotn_dci_mux3_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX3_MUX1_CTRL);
                                                                   
        /* configure FMF1_MUX4 control */                      
        coreotn_dci_mux4_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX4_LO_DCI_INTF);
                                                                   
        /* configure FMF1_MUX5 control */                      
        coreotn_dci_mux5_cfg(coreotn_handle, COREOTN_FMF_INST_1, COREOTN_DCI_MUX5_LO_DCI_INTF);
            
        /* XOFF config */
        coreotn_fmf_field_DCI_XOFF_CTRL_2_set(NULL, coreotn_handle, 0, 0);
            
        /* configure FMF2_MUX1 control */
        coreotn_dci_mux1_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX1_HO_DCI_INTF);
                                                                   
        /* configure FMF2_MUX3 control */                      
        coreotn_dci_mux3_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX3_MUX1_CTRL);
                                                                   
        /* configure FMF2_MUX4 control */                      
        coreotn_dci_mux4_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX4_LO_DCI_INTF);
                                                                   
        /* configure FMF2_MUX5 control */                      
        coreotn_dci_mux5_cfg(coreotn_handle, COREOTN_FMF_INST_2, COREOTN_DCI_MUX5_LO_DCI_INTF);
            
        /* XOFF config */
        coreotn_fmf_field_DCI_XOFF_CTRL_1_set(NULL, coreotn_handle, 1, 1);
        coreotn_fmf_field_DCI_XOFF_CTRL_2_set(NULL, coreotn_handle, 1, 0);
        break;
    default:
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* coreotn_dci_mux_ctrl_cfg */

/*******************************************************************************
*  coreotn_dci_mux1_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures MUX control 1.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   fmf_instance        - COREOTN_FMF1_INST -- mux1 control in FMF1 \n
*                         COREOTN_FMF2_INST -- mux1 control in FMF2
*   mux_src             - source of the traffic. \n
*                         0 -- HO DCI interface (invalid if 'mux_instance' = 0) \n
*                         1 -- ODU_RFRM12
*
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_dci_mux1_cfg(coreotn_handle_t *coreotn_handle,
                                  coreotn_fmf_inst_t fmf_instance,
                                  coreotn_dci_mux1_src_t mux_src)
{
    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(fmf_instance < LAST_COREOTN_FMF_INST, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(mux_src < LAST_COREOTN_DCI_MUX1, COREOTN_ERR_INVALID_ARG, 0, 0);

    coreotn_fmf_field_DCI_MUX_CTRL_1_set(NULL, coreotn_handle, fmf_instance, mux_src);

    PMC_RETURN();
} /* coreotn_dci_mux1_cfg */

/*******************************************************************************
*  coreotn_dci_mux2_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures the traffic through the second stage framer and demux based on
*   the number of stages involved in de-multiplexing ODUk traffic.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   fmf_instance        - COREOTN_FMF1_INST -- mux2 control in FMF1 \n
*                         COREOTN_FMF2_INST -- mux2 control in FMF2
*   mux_src             - source of the traffic. \n
*                         0 -- COREOTN_CTL \n
*                         1 -- ODTU_DMX
*
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_dci_mux2_cfg(coreotn_handle_t *coreotn_handle,
                                  coreotn_fmf_inst_t fmf_instance,
                                  coreotn_dci_mux2_src_t mux_src)
{
    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(fmf_instance < LAST_COREOTN_FMF_INST, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(mux_src < LAST_COREOTN_DCI_MUX2, COREOTN_ERR_INVALID_ARG, 0, 0);

    coreotn_fmf_field_DCI_MUX_CTRL_2_set(NULL, coreotn_handle, fmf_instance, mux_src);
                                         
    PMC_RETURN();
} /* coreotn_dci_mux2_cfg */

/*******************************************************************************
*  coreotn_dci_mux3_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures the traffic through the second stage framer and demux based on
*   the number of stages involved in de-multiplexing ODUk traffic.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   fmf_instance        - COREOTN_FMF1_INST -- mux3 control in FMF1 \n
*                         COREOTN_FMF2_INST -- mux3 control in FMF2
*   mux_src             - source of the traffic. \n
*                         0 -- ODU_RFRM96 (if mux_instance = 0, stage 2 framer,
*                                          if mux_instance = 1, stage 3a framer)\n
*                         1 -- DCI_MUX1
*
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_dci_mux3_cfg(coreotn_handle_t *coreotn_handle,
                                  coreotn_fmf_inst_t fmf_instance,
                                  coreotn_dci_mux3_src_t mux_src)
{
    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(fmf_instance < LAST_COREOTN_FMF_INST, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(mux_src < LAST_COREOTN_DCI_MUX3, COREOTN_ERR_INVALID_ARG, 0, 0);

    coreotn_fmf_field_DCI_MUX_CTRL_3_set(NULL, coreotn_handle, fmf_instance, mux_src);
    
    PMC_RETURN();

} /* coreotn_dci_mux3_cfg */

/*******************************************************************************
*  coreotn_dci_mux4_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures the traffic through the second stage framer and demux based on
*   the number of stages involved in de-multiplexing ODUk traffic.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   fmf_instance        - COREOTN_FMF1_INST -- mux4 control in FMF1 \n
*                         COREOTN_FMF2_INST -- mux4 control in FMF2
*   mux_src             - source of the traffic. \n
*                         0 -- ODTU_MUX (if mux_instance = 0, ODTU_MUX_1,
*                                        if mux_instance = 1, ODTU_MUX_2) \n
*                         1 -- ODU_RFRM96 (if mux_instance = 0, stage 2 framer,
*                                          invalid if mux_instance = 1)
*                         2 -- LO DCI interface (if mux_instance = 0, MO channel
*                              DCI interface; if mux_instance = 1, LO channel
*                              DCI interface)
*
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_dci_mux4_cfg(coreotn_handle_t *coreotn_handle,
                                  coreotn_fmf_inst_t fmf_instance,
                                  coreotn_dci_mux4_src_t mux_src)
{
    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(fmf_instance < LAST_COREOTN_FMF_INST, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(mux_src < LAST_COREOTN_DCI_MUX4, COREOTN_ERR_INVALID_ARG, 0, 0);

    coreotn_fmf_field_DCI_MUX_CTRL_4_set(NULL, coreotn_handle, fmf_instance, mux_src);

    PMC_RETURN();
} /* coreotn_dci_mux4_cfg */

/*******************************************************************************
*  coreotn_dci_mux5_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures the traffic through the second stage framer and demux based on
*   the number of stages involved in de-multiplexing ODUk traffic.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   fmf_instance        - COREOTN_FMF1_INST -- mux5 control in FMF1 \n
*                         COREOTN_FMF2_INST -- mux5 control in FMF2
*   mux_src             - source of the traffic. \n
*                         0 -- LO DCI interface (if mux_instance = 0, MO DCI
*                              interface, if mux_instance = 1, LO DCI interface) \n
*                         1 -- DCI_MUX3 (if mux_instance = 0, DCI_MUX3 control,
*                                        invalid if mux_instance = 1)
*
*
* OUTPUTS:
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_dci_mux5_cfg(coreotn_handle_t *coreotn_handle,
                                  coreotn_fmf_inst_t fmf_instance,
                                  coreotn_dci_mux5_src_t mux_src)
{
    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(fmf_instance < LAST_COREOTN_FMF_INST, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(mux_src < LAST_COREOTN_DCI_MUX5, COREOTN_ERR_INVALID_ARG, 0, 0);

    coreotn_fmf_field_DCI_MUX_CTRL_5_set(NULL, coreotn_handle, fmf_instance, mux_src);

    PMC_RETURN();
}  /* coreotn_dci_mux5_cfg */


/*
** PRIVATE: OPSA helper functions
*/
/*******************************************************************************
*  coreotn_mpmo_cn_frame_period_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Assings cn frame period (= Tf) to be used by MPMO. Cn frame period is set to
*   the first stage mux's multi-frame period, thus it is dependent on the HO
*   ODUk type.
*
* INPUTS:
*   oduk_type           - HO ODUk type. See util_global_odukp_type_t.
*   client_oduk_type    - LO ODUk type. See util_global_odukp_type_t.
*   payload_format      - Enum for ODU payload format. See util_global_odu_line_payload_t.
*
* OUTPUTS:
*   *per                - Cn frame period for oduk type
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_mpmo_cn_frame_period_set(util_global_odukp_type_t oduk_type,
                                                   util_global_odukp_type_t client_oduk_type, 
                                                   util_global_odu_line_payload_t payload_format,
                                                   util_opsa_cn_frame_period_t *per)
{
    PMC_ENTRY();

    switch (oduk_type)
    {
    case UTIL_GLOBAL_ODU1:
        *per = UTIL_OPSA_COREOTN_ODU1_1G25_T_FRAME;
        break;
    case UTIL_GLOBAL_ODU2:
        if (payload_format == UTIL_GLOBAL_ODU_TS_1G25)
        {
            *per = UTIL_OPSA_COREOTN_ODU2_1G25_T_FRAME;
        }
        else if (payload_format == UTIL_GLOBAL_ODU_TS_2G5)
        {
            *per = UTIL_OPSA_COREOTN_ODU2_2G5_T_FRAME;
        }
        break;
    case UTIL_GLOBAL_ODU3:
        if (payload_format == UTIL_GLOBAL_ODU_TS_1G25)
        {
            *per = UTIL_OPSA_COREOTN_ODU3_1G25_T_FRAME;
        }
        else if (payload_format == UTIL_GLOBAL_ODU_TS_2G5)
        {
            *per = UTIL_OPSA_COREOTN_ODU3_2G5_T_FRAME;
        }
        break;
    case UTIL_GLOBAL_ODU3E1:
        *per = UTIL_OPSA_COREOTN_ODU3E1_2G5_T_FRAME;
        break;
    case UTIL_GLOBAL_ODU3E2:
        *per = UTIL_OPSA_COREOTN_ODU3E2_1G25_T_FRAME;
        break;
    case UTIL_GLOBAL_ODU4:
        *per = UTIL_OPSA_COREOTN_ODU4_1G25_T_FRAME;
        break;
    default:
        *per = UTIL_OPSA_T_FRAME_UNUSED;
        break;
    }

    PMC_RETURN(PMC_SUCCESS);
} /* coreotn_mpmo_cn_frame_period_set */


/*******************************************************************************
* coreotn_chnl_id_and_order_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Queries the database to determine the chnl_id and the channel order.
*
*
* INPUTS:
*   *coreotn_handle   - pointer to COREOTN handle instance
*   output_chnl_id    - output channel ID from ODUk Switch
*                       Valid range: 0 - 95
*   db_inst           - 0 : TX DB
*                       1 : RX DB
*
* OUTPUTS:
*   chnl_id           - The chnl id located in the database
*   ho_chnl_id        - The parent channel ID of current channel
*   order_type        - The order flavour of the specific channel.
*                       See coreotn_chnl_order_t for more details.
*   num_of_recs       - The number of records in the result. This is required
*                       by a helper at another layer.
*   q_result          - The result of the query. This is required by a helper
*                       at another layer.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_chnl_id_and_order_get(coreotn_handle_t* coreotn_handle,
                                               UINT32 output_chnl_id,
                                               UINT32 db_inst,
                                               UINT32* chnl_id,
                                               UINT32* ho_chnl_id,
                                               coreotn_chnl_order_t* order_type,
                                               UINT32* num_of_recs,
                                               line_core_otn_db_query_res** q_result)
{
    PMC_ERROR result = COREOTN_ERR_CODE_ASSERT;

    line_core_otn_db_key       key;
    UINT32 db_handle = 0; 
    util_gen_db_id_t db_id;
    line_core_otn_db_query_res *my_q_result = NULL;

    PMC_ENTRY();

    db_id = (db_inst == 0)? UTIL_GEN_DB_LINE_CORE_OTN_TX_DB:UTIL_GEN_DB_LINE_CORE_OTN_RX_DB;     
    db_handle = (db_inst == 0)? coreotn_handle->cfg.tx_db_handle:coreotn_handle->cfg.rx_db_handle;

    key.calendar_entry = DO_NOT_USE_KEY;
    key.ho_channel = DO_NOT_USE_KEY;
    key.mo_channel = DO_NOT_USE_KEY;
    key.lo_channel = output_chnl_id;
    key.trib_slot = DO_NOT_USE_KEY;



    /* find the total number of records that matches the LO channel ID */
    *num_of_recs = gen_db_query(&(coreotn_handle->base),
                                db_id,
                                db_handle,
                                (void *)&key, (void **)&my_q_result);

    if (*num_of_recs == 0) {

        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = DO_NOT_USE_KEY;
        key.mo_channel = output_chnl_id;
        key.lo_channel = DO_NOT_USE_KEY;
        key.trib_slot = DO_NOT_USE_KEY;

        /* find the total number of records that matches the MO channel ID */
        *num_of_recs = gen_db_query(&(coreotn_handle->base),
                                    db_id,
                                    db_handle,
                                    (void *)&key, (void **)&my_q_result);

        if (*num_of_recs == 0) {

            key.calendar_entry = DO_NOT_USE_KEY;
            key.ho_channel = output_chnl_id;
            key.mo_channel = DO_NOT_USE_KEY;
            key.lo_channel = DO_NOT_USE_KEY;
            key.trib_slot = DO_NOT_USE_KEY;

            /* find the total number of records that matches the HO channel ID */
            *num_of_recs = gen_db_query(&(coreotn_handle->base),
                                        db_id,
                                        db_handle, 
                                        (void *)&key, (void **)&my_q_result);

            if (*num_of_recs == 0) {

                PMC_RETURN(COREOTN_ERR_DB_ENTRY_NOT_FOUND);
            }

            *chnl_id = my_q_result->p_recs[0]->ho_channel;
            *ho_chnl_id = *chnl_id;
            *order_type = COREOTN_CHNL_ORDER_HO;
            result = PMC_SUCCESS;

        } else {

            *ho_chnl_id = my_q_result->p_recs[0]->ho_channel;
            *chnl_id = my_q_result->p_recs[0]->mo_channel;
            *order_type = COREOTN_CHNL_ORDER_MO;
            result = PMC_SUCCESS;
        }

    } else {

        *ho_chnl_id = my_q_result->p_recs[0]->mo_channel;
        *chnl_id = my_q_result->p_recs[0]->lo_channel;
        *order_type = COREOTN_CHNL_ORDER_LO;
        result = PMC_SUCCESS;
    }

    *q_result = my_q_result;
               
    PMC_RETURN(result);

} /* coreotn_chnl_id_and_order_get */

/*******************************************************************************
* coreotn_oduksw_port_bulk_update_req_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   Set an a indication whether a bulk prov/deprov for an ODUKSW port and
*   direction is required.
*
* INPUTS:
*   *coreotn_handle     - pointer to CoreOTN handle instance
*   port_type           - the ODUKSW port port_type.
*   port_direction      - the ODUKSW port direction.
*   update_required     - TRUE: if the update is required.
*
* RETURNS:
*   none
*
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_oduksw_port_bulk_update_req_set(coreotn_handle_t *coreotn_handle,
                                                    util_global_oduk_port_t port_type,
                                                    util_global_datapath_dir_t port_direction,
                                                    BOOL8 update_required)
{
    PMC_ENTRY();

    cpb_oduksw_port_bulk_update_req_set(coreotn_handle->oduksw_handle,
                                        port_type,
                                        port_direction,
                                        update_required);

    PMC_RETURN();
}/*coreotn_oduksw_port_bulk_update_req_set*/

/*******************************************************************************
* coreotn_oduksw_port_bulk_update_req_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   Get the indication whether there should be an update on an ODUKSW port
*   in the desired direction while performing bulk reprovision on ODUKSW.
*
* INPUTS:
*   *coreotn_handle     - pointer to CoreOTN handle instance
*   port_type           - the ODUKSW port number.
*   port_direction      - the ODUKSW port direction.
*
* RETURNS:
*   TRUE: if the update is needed.
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 coreotn_oduksw_port_bulk_update_req_get(coreotn_handle_t *coreotn_handle,
                                                     util_global_oduk_port_t port_type,
                                                     util_global_datapath_dir_t port_direction)
{
    PMC_ENTRY();

    PMC_RETURN(cpb_oduksw_port_bulk_update_req_get(coreotn_handle->oduksw_handle,
                                                   port_type,
                                                   port_direction));
}/*coreotn_oduksw_port_bulk_update_req_get*/

/*******************************************************************************
*  coreotn_odtu_dmx_dummy_schd_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function schedules a calendar entry to be assigned for a MO channel. 
*
* INPUTS:
*   *coreotn_handle     - handle to the COREOTN instance to be operated on
*   dmx_schd_idx        - dummy schedule channel instance. Valid range: 0 - 1
*
* OUTPUTS:
*   *mo_chnl_id          - MO channel ID that requires an additional calendar entry.
*                          Valid range: 0 - 95
*   *calendar_entry      - Calendar entry to be assigned for the additional scheduling
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_odtu_dmx_dummy_schd_get(coreotn_handle_t *coreotn_handle,
                                                 UINT32 dmx_schd_idx,
                                                 UINT8 *mo_chnl_id,
                                                 UINT8 *calendar_entry)
{
    PMC_ERROR result = PMC_SUCCESS; 
    
    PMC_ENTRY();
    
    result = odtu_dmx_dummy_schd_get(coreotn_handle->odtu_dmx2_handle,
                                     dmx_schd_idx,
                                     mo_chnl_id,
                                     calendar_entry);
                                     
    PMC_RETURN(result);                                     
    
} /* coreotn_odtu_dmx_dummy_schd_get */                                         

/*******************************************************************************
* coreotn_db_ret_sched_populate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Read from DB to retrieve the calendar usage in COREOTN.
*   Retrieve the database for the current scheduler state 
*   Query the record to update
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   output_port         - destination of the data.
*                         See coreotn_oduk_sw_output_port_t.\n
*   output_chnl_id      - output channel ID from ODUk Switch
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   ho_chnl_id          - The chnl id located in the database
*   order_type          - Order Type
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_ret_sched_populate(coreotn_handle_t* coreotn_handle,
                                               coreotn_oduksw_output_port_type_t output_port,
                                               UINT32 output_chnl_id,
                                               UINT32* ho_chnl_id,
                                               coreotn_chnl_order_t* order_type)
{
    PMC_ERROR result = COREOTN_ERR_CODE_ASSERT;

    UINT32 i;
    UINT32 chnl_id;
    UINT32                     num_of_recs = 0;
    /*coreotn_chnl_order_t       order_type;*/
    line_core_otn_db_query_res *q_result = NULL;

    PMC_ENTRY();

    if (output_port == COREOTN_ODUKSW_OUTPUT_COREOTN)
    {

        result = coreotn_chnl_id_and_order_get(coreotn_handle,
                                               output_chnl_id,
                                               0, /*TX DB*/
                                               &chnl_id,
                                               ho_chnl_id,
                                               order_type,
                                               &num_of_recs,
                                               &q_result);
PMC_ASSERT(q_result->num_of_recs == num_of_recs, 0, 0, 0);
        if (result == PMC_SUCCESS) 
        {

            /* check the scheduler populate method in ODUKSW  */
            if (coreotn_handle->cfg.schdpopulate_mode[output_port] == CPB_SCHD_POPULATE_DB)
            {
                for (i = 0; i < num_of_recs; i++)
                {
                    result = cpb_dcs_db_entry_set(coreotn_handle->oduksw_handle,
                                                  output_port,
                                                  q_result->p_recs[i]->calendar_entry,
                                                  output_port,
                                                  output_chnl_id);
                }
            }
        }


    } else {

        /* Nothing to do */
        result = PMC_SUCCESS;
    }

    PMC_RETURN(result);

} /* coreotn_db_ret_sched_populate */

/*******************************************************************************
* coreotn_oduksw_odu_payload_format_validate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Read from DB to retrieve the calendar usage in COREOTN.
*   Retrieve the database for the current scheduler state 
*   Query the record to update
*
* INPUTS:
*   *coreotn_handle         - pointer to COREOTN handle instance
*   *local_output_pc_ptr    - pointer to coreotn channel pointer
*
* OUTPUTS:
*   *valid_payload          - output value to indicate whether or not 
*                             ODUk payload format is valid.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_odu_payload_format_validate(coreotn_handle_t* coreotn_handle,
                                                            util_global_oduk_port_data_t *local_output_pc_ptr,
                                                            BOOL8 *valid_payload)
{
    PMC_ERROR result = PMC_SUCCESS;
    util_global_odu_line_payload_t payload_format;
    
    PMC_ENTRY();
    /*
     * Initialized the payload to false and then pulled the check into
     * the if statement to ensure that it is updated correctly of the port
     * type is coreotn
     */
    *valid_payload = FALSE; 

    if (local_output_pc_ptr->port_type == UTIL_GLOBAL_ODUK_PORT_COREOTN)
    {
        if (local_output_pc_ptr->odu_level == UTIL_GLOBAL_LEVEL_LO_ODU)
        {
            payload_format = coreotn_handle->var.tx_lo_chnl_ctxt[local_output_pc_ptr->channel].payload_format;
        }
        else if (local_output_pc_ptr->odu_level == UTIL_GLOBAL_LEVEL_MO_ODU)
        {
            payload_format = coreotn_handle->var.tx_mo_chnl_ctxt[local_output_pc_ptr->channel].payload_format;
        } 
        else 
        {
            payload_format = coreotn_handle->var.tx_ho_chnl_ctxt[local_output_pc_ptr->channel].payload_format;
        }             
    
        if (payload_format != UTIL_GLOBAL_ODU_UNCHANNELIZED)
        {
            *valid_payload = FALSE;
        }
        else {
          *valid_payload = TRUE;
        }
    }
    
    PMC_RETURN(result);
} /* coreotn_oduksw_odu_payload_format_validate */    
                                         

/*******************************************************************************
* coreotn_frm_rcp_fifo_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Read from DB to retrieve the calendar usage in COREOTN.
*   Retrieve the database for the current scheduler state 
*   Query the record to update
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   frm_rcp_instance    - Enum for FRM_RCP instance.
*                         See coreotn_frm_rcp_inst_t.\n
*   chnl_id             - ODUk channel ID 
*                         Valid range: 0 - 95
*   enbl                - enables or disables the CFC FIFO in FRM_RCP
*                         0 -- CFC FIFO is in reset.
*                         1 -- CFC FIFO is operating normally.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_frm_rcp_fifo_cfg(coreotn_handle_t* coreotn_handle,
                                           coreotn_frm_rcp_inst_t frm_rcp_instance,
                                           UINT32 chnl_id, UINT32 enbl)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();    
    
    
    
    /*
      COREOTN_FMF1_FRM_RCP12   = 0,
      COREOTN_FMF1_FRM_RCP96,
      COREOTN_FMF2_FRM_RCP12,
      COREOTN_FMF2_FRM_RCP96,
      COREOTN_FO1_FRM_RCP,
      COREOTN_FO2_FRM_RCP,
    */
    
    /* enable FRM_RCP FIFO to operate normally 
       switch (frm_rcp_instance)
       {
       case COREOTN_FMF1_FRM_RCP12:
       coreotn_fmf_field_range_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 0, chnl_id, chnl_id, enbl);
       break;
       case COREOTN_FMF1_FRM_RCP96:
       coreotn_fmf_lfield_range_CFC_FIFO2_CLRB_CFG_set(NULL, coreotn_handle, 0, chnl_id, chnl_id, enbl);
       break;
       case COREOTN_FMF2_FRM_RCP12:
       coreotn_fmf_field_range_CFC_FIFO1_CLRB_CFG_set(NULL, coreotn_handle, 1, chnl_id, chnl_id, enbl);
       break;
       case COREOTN_FMF2_FRM_RCP96:
       coreotn_fmf_lfield_range_CFC_FIFO2_CLRB_CFG_set(NULL, coreotn_handle, 1, chnl_id, chnl_id, enbl);
       break;
       case COREOTN_FO1_FRM_RCP:
       coreotn_fo_lfield_range_CFC_FIFO_CLRB_CFG_set(NULL, coreotn_handle, 0, chnl_id, chnl_id, enbl);
       break;
       case COREOTN_FO2_FRM_RCP:
       coreotn_fo_lfield_range_CFC_FIFO_CLRB_CFG_set(NULL, coreotn_handle, 1, chnl_id, chnl_id, enbl);
       break;
       default:
       PMC_RETURN(COREOTN_ERR_INVALID_ARG);
       }
    */ 
    PMC_RETURN(result);

} /* coreotn_frm_rcp_fifo_cfg */

/*******************************************************************************
* coreotn_odu_tfrm_chnl_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function takes the ODU TFRM channel out of passthru and enables
*   FRM_RCP to communicate between ODU_TFRM and ODU_RFRM. This function also
*   initializes STAT overhead field of ODU_TFRM to operate normally.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   odu_tfrm_inst       - Enum for ODU_TFRM instance.
*                         See odu_tfrm_inst_t.\n
*   chnl_id             - ODU framer channel ID 
*                         Valid range: 0 - 95
*   enbl                - enables or disables the ODUk channel through desired
*                         ODU_TFRM block.
*                         0 -- Channel is in passthru.
*                         1 -- Channel is operating normally.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odu_tfrm_chnl_init(coreotn_handle_t* coreotn_handle,
                                             odu_tfrm_inst_t odu_tfrm_inst,
                                             UINT32 chnl_id, UINT32 enbl)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    odu_tfrm_handle_t *local_odu_tfrm_handle = NULL;
    coreotn_frm_rcp_inst_t frm_rcp_inst;
    
    PMC_ENTRY();
    
    switch (odu_tfrm_inst)
    {
    case ODU_TFRM_STG1:
        local_odu_tfrm_handle = coreotn_handle->odu_tfrm_stg1_handle;
        frm_rcp_inst = COREOTN_FMF1_FRM_RCP12;
        break;
    case ODU_TFRM_STG2:
        local_odu_tfrm_handle = coreotn_handle->odu_tfrm_stg2_handle;
        frm_rcp_inst = COREOTN_FMF1_FRM_RCP96;
        break; 
    case ODU_TFRM_STG3A:
        local_odu_tfrm_handle = coreotn_handle->odu_tfrm_stg3a_handle;
        frm_rcp_inst = COREOTN_FMF2_FRM_RCP96;
        break;
    case ODU_TFRM_STG3B:
        local_odu_tfrm_handle = coreotn_handle->odu_tfrm_stg3b_handle;
        frm_rcp_inst = COREOTN_FO1_FRM_RCP;
        break;
    case ODU_TFRM_STG4:
        local_odu_tfrm_handle = coreotn_handle->odu_tfrm_stg4_handle;
        frm_rcp_inst = COREOTN_FO2_FRM_RCP;
        break;
    case ODU_TFRM_STGN:
        local_odu_tfrm_handle = coreotn_handle->odu_tfrm_stgN_handle;
        frm_rcp_inst = COREOTN_FMF2_FRM_RCP12;
        break;  
    default:
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    } 
            
    /* enable FRM_RCP FIFO to operate normally */                                 
    ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle, frm_rcp_inst,
                                       chnl_id, enbl);
    
    if (PMC_SUCCESS == ret_val)
    {                                       
        /* Provision a PM layer on STG1 TFRM */
        ret_val = odu_tfrm_chnl_prov(local_odu_tfrm_handle,
                                     chnl_id,
                                     (odu_tfrm_pm_tcm_id_t)ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM,
                                     (odu_tfrm_pm_tcm_id_t)ODU_TFRM_MESSAGE_TYPE_DCI,
                                     (odu_tfrm_pm_tcm_mode_t)ODU_TFRM_PM_TCM_TT_OPERATIONAL,
                                     enbl);  
    }
    
    /* set STAT to normal operation */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = odu_tfrm_pm_tcmi_stat_src_cfg(local_odu_tfrm_handle,
                                                chnl_id,
                                                (odu_tfrm_pm_tcm_id_t)ODU_STRUCT_ODU_FRM_MESSAGE_TYPE_PM,
                                                enbl);
    }

    PMC_RETURN(ret_val);
} /* coreotn_odu_tfrm_chnl_init */

#ifndef DOXYGEN_PUBLIC_ONLY /* Signals doxygen to not include all APIs */ 
/* LCOV_EXCL_START */
/*******************************************************************************
* coreotn_prbs_dlss_status_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function is used to retreive the state of PRBS DLSS defects on the 
*   PRBS channel.
*
* INPUTS:
*   *coreotn_handle        - pointer to COREOTN handle instance.
*   prbs_inst              - enum for PRBS instance. See coreotn_prbs_inst_t.
*   prbs_chnl              - prbs channel ID
*                            Valid range: 0 - 11
*
* OUTPUTS:
*   *dlss_stat             - current state of PRBS dlss defect for the prbs channel
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_prbs_dlss_status_get(coreotn_handle_t* coreotn_handle,
                                              coreotn_prbs_inst_t prbs_inst, 
                                              UINT32 prbs_chnl, 
                                              UINT8 *dlss_stat)
{

    PMC_ERROR result = PMC_SUCCESS;
    UINT16 dlss_val;

    PMC_ENTRY();
    
    
    
    switch (prbs_inst)
    {
    case COREOTN_FMF1_PRBS:
        dlss_val = coreotn_fmf_field_PRBS_DLSS_V_get(NULL, coreotn_handle, 0);
        break;
    case COREOTN_FMF2_PRBS:
        dlss_val = coreotn_fmf_field_PRBS_DLSS_V_get(NULL, coreotn_handle, 1);
        break;
    case COREOTN_FO1_PRBS:
        dlss_val = coreotn_fo_field_PRBS_DLSS_V_get(NULL, coreotn_handle, 0);
        break;
    case COREOTN_FO2_PRBS:
        dlss_val = coreotn_fo_field_PRBS_DLSS_V_get(NULL, coreotn_handle, 1);
        break;
    default:
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }
    
    *dlss_stat = (dlss_val >> prbs_chnl) & 1; 
    
    PMC_RETURN(result);
} /* coreotn_prbs_dlss_status_get */
 
/* LCOV_EXCL_STOP */
#endif/*#ifndef DOXYGEN_PUBLIC_ONLY*/



/*******************************************************************************
* coreotn_validate_tribslot_mask
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs error checking on the tribslot mask provided
*   in coreotn_lo_chnl_prov()
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   lo_odu_type         - LO ODUj type. See odukp_type_enum.
*                         Valid range: all available oduk types.
*   ho_odu_type         - HO ODUj type. See odukp_type_enum.
*                         Valid range: all available oduk types.
*   ho_chnl_id          - HO channel ID that this LO belongs to.
*                         Valid range: 0 - 95
*   tribslot_mask       - 3 x 32 bit mask to represent the tributary slot
*                         assignment for this LO channel.\n
*                         Valid range: 0 - 0x4F\n
*                         Bit 0 -- Tributary slot 1\n
*                         Bit 1 -- Tributary slot 2\n
*                         Bit 2 -- Tributary slot 3\n
*                                ...\n
*                         Bit 79 -- Tributary slot 80\n
*                         NOTE : This is a "normalized" view of the server (so, if
*                                adding a client to an ODU2 server, only bits 0-7
*                                of tribslot_mask[0] can get set).
*                                In the event of 2.5G TS ODU2, only bits 0-3 can
*                                get set.
*   ho_chnl_id          - The HO channel id associated with the server.
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   rx_segment          - TRUE : provisioning the RX segment
*                         FALSE : provisioning the TX segment
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_validate_tribslot_mask(coreotn_handle_t* coreotn_handle,
                                                util_global_odukp_type_t lo_odu_type,
                                                util_global_odukp_type_t ho_odu_type,
                                                UINT32 tribslot_mask[3],
                                                UINT32 ho_chnl_id,
                                                coreotn_mux_stage_t mux_stage,
                                                BOOL rx_segment)
{
    PMC_ERROR result = COREOTN_ERR_CODE_ASSERT;

    UINT32 i = 0;
    UINT32 count = 0;
    UINT32 row_count = 0;
    UINT32 ts_copy[3];
    UINT32 num_server_ts = 0;
    UINT32 num_client_ts = 0;
    UINT32 last_ts = 0;
    util_global_odu_line_payload_t ts_type = UTIL_GLOBAL_ODU_UNCHANNELIZED;
    
    PMC_ENTRY();

    for (i = 0; i < 3; i++) 
    {
        ts_copy[i] = tribslot_mask[i];
    }

    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if(rx_segment)
        {
            ts_type = coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].payload_format;
        }
        else
        {
            ts_type = coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].payload_format;
        }
    } 
    else if(mux_stage == COREOTN_MUX_STAGE_TWO) 
    {
        if(rx_segment)
        {
            ts_type = coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].payload_format;
        }
        else
        {
            ts_type = coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].payload_format;
        }
    }

    /* determine the valid range for tribslots set in the server */
    result = util_global_max_server_num_ts_get(UTIL_GLOBAL_MUX_DEMUX,
                                               ho_odu_type,
                                               ts_type,
                                               &num_server_ts);
                                               
    if (PMC_SUCCESS == result)
    {                                              
        /*calculate the number of bits set in the tribslot mask*/    
        for (i = 0; i < 3; i++)
        {           
            row_count = 0;

            while(ts_copy[i] > 0) 
            {                
                if ((ts_copy[i] & 1) == 1) 
                {
                    count++;
                    last_ts = (i*32)+row_count;
                }
                
                row_count++;
                ts_copy[i] >>= 1;
            }       
        } 
    
        result = util_global_max_client_num_ts_get(ho_odu_type,
                                                   lo_odu_type,
                                                   ts_type,
                                                   &num_client_ts);  
    }
    
    if (PMC_SUCCESS == result)
    {
        /*perform both checks on tribslot mask */
        if (lo_odu_type != UTIL_GLOBAL_ODUFLEX_GFP && lo_odu_type != UTIL_GLOBAL_ODUFLEX_CBR)
        {
            /* For Non-flex clients */
            if(last_ts > num_server_ts || count != num_client_ts) 
            {
                PMC_ASSERT(FALSE, COREOTN_INVALID_TRIBSLOT_MASK, 0, 0);
            }
        }
        else {
            /* For FLEX clients, count must be less than or equal to num_server_ts */
            if (count > num_server_ts)
            {
                PMC_ASSERT(FALSE, COREOTN_INVALID_TRIBSLOT_MASK, 0, 0);    
            }
        }
    }
    
    PMC_RETURN(result);
} /* coreotn_validate_tribslot_mask */

/*
* DI/RI RCP 
*/
/*******************************************************************************
* coreotn_odu_rcp_uninit
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The function initialize a Ring Control Port (RCP) instance
*
* INPUTS:
*   *coreotn_handle       - pointer to COREOTN handle instance
*    odu_rcp_id           - identify the RCP instance 
*   *prov_cfg_ptr         - pointer to RCP port configuration
*
*
* OUTPUTS:
*  None
*
* RETURNS:
*   PMC_SUCCESS           - when API execution is successful otherwise a 
*                           descriptive error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_odu_rcp_init(coreotn_handle_t *coreotn_handle,
                                      odu_rcp_inst_t odu_rcp_id,
                                      odu_rcp_init_cfg_t* prov_cfg_ptr)
{
    PMC_ERROR rc = PMC_SUCCESS;
    PMC_ENTRY();

    rc  = odu_rcp_init(coreotn_handle->odu_rcp_handle,odu_rcp_id,prov_cfg_ptr);

    PMC_RETURN(rc);
}

/*******************************************************************************
* coreotn_odu_rcp_uninit
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The function un-initializes a Ring Control Port (RCP) instance
*
* INPUTS:
*   *coreotn_handle   - pointer to COREOTN handle instance
*    odu_rcp_id       - identify the RCP instance 
*
* OUTPUTS:
*  None
*
* RETURNS:
*   PMC_SUCCESS           - when API execution is successful otherwise a 
*                           descriptive error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_odu_rcp_uninit(coreotn_handle_t *coreotn_handle,
                                        odu_rcp_inst_t odu_rcp_id)
{
    PMC_ERROR rc = PMC_SUCCESS;
    PMC_ENTRY();

    rc  = odu_rcp_uninit(coreotn_handle->odu_rcp_handle,odu_rcp_id);

    PMC_RETURN(rc);
}

/*******************************************************************************
* coreotn_odu_rcp_init_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   The function gets initialize status of a Ring Control Port (RCP) instance
*
* INPUTS:
*   *coreotn_handle       - pointer to COREOTN handle instance
*    odu_rcp_id           - identify the RCP instance 
*
*
* OUTPUTS:
*   *prov_cfg_ptr         - pointer to RCP port configuration
*   enable                - TRUE when RCP initialized or FALSE when uninitialized
*
* RETURNS:
*   PMC_SUCCESS           - when API execution is successful otherwise a 
*                           descriptive error is returned.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_odu_rcp_init_get(coreotn_handle_t *coreotn_handle,
                                          odu_rcp_inst_t odu_rcp_id,
                                          odu_rcp_init_cfg_t* prov_cfg_ptr,
                                          BOOL *enable)
{
    PMC_ERROR rc = PMC_SUCCESS;
    PMC_ENTRY();

    rc  = odu_rcp_init_get(coreotn_handle->odu_rcp_handle,odu_rcp_id,prov_cfg_ptr,enable);

    PMC_RETURN(rc);
}

/*******************************************************************************
* coreotn_oduksw_handle_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the ODUk switch handle
*
*
* INPUTS:
*   *coreotn_handle   - pointer to COREOTN handle instance
*   
*
* RETURNS:
*   cpb_handle_t        - pointer to ODUKSW handle
*
* NOTES:
*
*******************************************************************************/
PUBLIC cpb_handle_t * coreotn_oduksw_handle_get(coreotn_handle_t* coreotn_handle)
{   
    PMC_ENTRY();
    PMC_RETURN(coreotn_handle->oduksw_handle);

} /* coreotn_oduksw_handle_get */

/*******************************************************************************
* coreotn_enet_fege_handle_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the enet_fege handle
*
*
* INPUTS:
*   *coreotn_handle   - pointer to COREOTN handle instance
*   inst              - COREOTN FEGE Port Instance
*   
*
* RETURNS:
*   enet_fege_handle_t  - pointer to enet_fege handle
*
* NOTES:
*
*******************************************************************************/
PUBLIC enet_fege_handle_t * coreotn_enet_fege_handle_get(coreotn_handle_t* coreotn_handle,
                                                         util_global_coreotn_sgmii_inst_t inst)
{   
    PMC_ENTRY();

    switch(inst)
    {
        case UTIL_GLOBAL_COREOTN_SGMII_INST_DIRCP:
            PMC_RETURN(coreotn_handle->odu_rcp_handle->enet_fege_handle[(UINT32)ODU_RCP_DI_INST]);
            break;
        case UTIL_GLOBAL_COREOTN_SGMII_INST_RIRCP:
            PMC_RETURN(coreotn_handle->odu_rcp_handle->enet_fege_handle[(UINT32)ODU_RCP_RI_INST]);
            break;
        case UTIL_GLOBAL_COREOTN_SGMII_INST_OHP_1:
            PMC_RETURN(coreotn_handle->odu_ohp_handle[COREOTN_ODU_OHP_1]->enet_fege_handle);
            break;
        case UTIL_GLOBAL_COREOTN_SGMII_INST_OHP_2:
            PMC_RETURN(coreotn_handle->odu_ohp_handle[COREOTN_ODU_OHP_2]->enet_fege_handle);
            break;
        case UTIL_GLOBAL_COREOTN_SGMII_INST_OHP_3:
            PMC_RETURN(coreotn_handle->odu_ohp_handle[COREOTN_ODU_OHP_3]->enet_fege_handle);
            break;
        default:
            PMC_ASSERT(FALSE, COREOTN_ERR_INVALID_ARG, 0, 0);
            PMC_RETURN(NULL);
            break;
    }

    PMC_RETURN(NULL);
} /* coreotn_enet_fege_handle_get */


/*******************************************************************************
* coreotn_ohp_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*             There are three ODU Overhead processors (OHPs). Each OHP contains 
*             two ports (port A and port B) which can connect to two different
*             framers. The first OHP (DIGI_OHP_1) supports 12 channels and 
*             has a fixed connection to the stage 1 (HO) framer. The second and 
*             third OHPs can be configured to connect to framer 2 (MO), 
*             framer 3A (LO), framer 3B (LO) or framer 4 (SNC).
*
*             This function initializes a single OHP. The function should be 
*             called once for each of the three OHPs. The port to framer connections
*             are specified using the port_a and port_b parameters.  If a port is 
*             unused, the value should be set to DIGI_OHP_PORT_UNUSED.
*
*             The ethernet source and destination addresses consits of the 
*             32 bit source/dest user ID, 8 bit framer ID and 8 bit channel id.
*              
*
* INPUTS:
*   *coreotn_handle        - coreotn handle instance
*   cfg_ptr                - configuration structure describing the setup
*                            for the overhead port.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_ERROR             - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ohp_init(coreotn_handle_t *coreotn_handle,
                                  odu_ohp_cfg_t *cfg_ptr)
{

    odu_ohp_handle_t *ohp_handle;
    PMC_ERROR rc = PMC_SUCCESS;
   
    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    ohp_handle = coreotn_handle->odu_ohp_handle[cfg_ptr->ohp];
    PMC_ASSERT(NULL != ohp_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    
    coreotn_odu_ohp_energy_state_reg_set(coreotn_handle,(coreotn_odu_ohp_inst_t)cfg_ptr->ohp,PMC_ENERGY_STATE_RUNNING);
    switch(cfg_ptr->ohp)
    {
    case ODU_OHP_1:
        /* OHP1 has fixed framer connections - no need to call ohp_port_cfg */
        break;
    case ODU_OHP_2:
        rc = coreotn_ohp_port_framer_cfg(coreotn_handle,cfg_ptr->ohp,ODU_OHP_PORT_A,cfg_ptr->port_a_framer);
        rc |= coreotn_ohp_port_framer_cfg(coreotn_handle,cfg_ptr->ohp,ODU_OHP_PORT_B,cfg_ptr->port_b_framer);
        break;
    case ODU_OHP_3:
        rc = coreotn_ohp_port_framer_cfg(coreotn_handle,cfg_ptr->ohp,ODU_OHP_PORT_A,cfg_ptr->port_a_framer);
        rc |= coreotn_ohp_port_framer_cfg(coreotn_handle,cfg_ptr->ohp,ODU_OHP_PORT_B,cfg_ptr->port_b_framer);
        break;
    default:
        PMC_ASSERT(FALSE,COREOTN_ERR_INVALID_ARG,cfg_ptr->ohp,0);
    }
    if (rc == PMC_SUCCESS)
    {
        rc = odu_ohp_init(ohp_handle,cfg_ptr);
    }
    PMC_RETURN(rc);
} /* coreotn_ohp_init */


/*******************************************************************************
* coreotn_ohp_init_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*    Gets ODU Overhead processors (OHPs) status.
*              
*
* INPUTS:
*   *coreotn_handle        - coreotn handle instance
*   ohp                    - enumeration of the three OHPs
*
* OUTPUTS:
*   cfg_ptr                - Configuration structure for the OHP port.
*                            Its content is invalid when it is uninited.
*   enable                 - TRUE when OHP inited or FALSE when OHP uninited
*
* RETURNS:
*   PMC_ERROR             - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ohp_init_get(coreotn_handle_t *coreotn_handle,
                                      odu_ohp_inst_t ohp,
                                      odu_ohp_cfg_t *cfg_ptr,
                                      BOOL *enable)
{
    odu_ohp_handle_t *ohp_handle;
    PMC_ERROR rc = PMC_SUCCESS;
   
    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    switch(ohp)
    {
    case ODU_OHP_1:
    case ODU_OHP_2:
    case ODU_OHP_3:
        break;
    default:
        PMC_ASSERT(FALSE,COREOTN_ERR_INVALID_ARG,ohp,0);
    }
    ohp_handle = coreotn_handle->odu_ohp_handle[ohp];
    PMC_ASSERT(NULL != ohp_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    rc = odu_ohp_init_get(ohp_handle,cfg_ptr,enable);

    PMC_RETURN(rc);
} /* coreotn_ohp_init_get */


/*******************************************************************************
* coreotn_ohp_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*             Enable/Disable all OHPs.
*
* INPUTS:
*   *coreotn_handle        - coreotn handle instance
*   enable                 - Enable/Disable all OHPs
*
* OUTPUTS:
*
* RETURNS:
*   PMC_ERROR             - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
* 
*   This function is used to power up OHP when RCP APS insertion is used. For 
*   normal OHP configuration, the coreotn_ohp_init function should be used.
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ohp_cfg(coreotn_handle_t *coreotn_handle, BOOL enable)
{

    PMC_ERROR rc = PMC_SUCCESS;
    pmc_energy_state_t energy_state = (enable ? PMC_ENERGY_STATE_RUNNING : PMC_ENERGY_STATE_RESET);
    
   
    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
   
    if (!enable)
    {
        odu_ohp_cfg(coreotn_handle->odu_ohp_handle[COREOTN_ODU_OHP_1],enable);
        odu_ohp_cfg(coreotn_handle->odu_ohp_handle[COREOTN_ODU_OHP_2],enable);
        odu_ohp_cfg(coreotn_handle->odu_ohp_handle[COREOTN_ODU_OHP_3],enable);
    }
 
    coreotn_odu_ohp_energy_state_reg_set(coreotn_handle, COREOTN_ODU_OHP_1,energy_state);
    coreotn_odu_ohp_energy_state_reg_set(coreotn_handle, COREOTN_ODU_OHP_2,energy_state);
    coreotn_odu_ohp_energy_state_reg_set(coreotn_handle, COREOTN_ODU_OHP_3,energy_state);

    /* OHP port -> framer config */
    rc  = coreotn_ohp_port_framer_cfg(coreotn_handle,ODU_OHP_2, ODU_OHP_PORT_A,ODU_OHP_PORT_FRAMER_2);
    rc |= coreotn_ohp_port_framer_cfg(coreotn_handle,ODU_OHP_2, ODU_OHP_PORT_B,ODU_OHP_PORT_FRAMER_3A);
    rc |= coreotn_ohp_port_framer_cfg(coreotn_handle,ODU_OHP_3, ODU_OHP_PORT_A,ODU_OHP_PORT_FRAMER_3B);
    rc |= coreotn_ohp_port_framer_cfg(coreotn_handle,ODU_OHP_3, ODU_OHP_PORT_B,ODU_OHP_PORT_FRAMER_4);

   
    if (enable)
    {
        odu_ohp_cfg(coreotn_handle->odu_ohp_handle[COREOTN_ODU_OHP_1],enable);
        odu_ohp_cfg(coreotn_handle->odu_ohp_handle[COREOTN_ODU_OHP_2],enable);
        odu_ohp_cfg(coreotn_handle->odu_ohp_handle[COREOTN_ODU_OHP_3],enable);
    }
    
    PMC_RETURN(rc);
} /* coreotn_ohp_cfg */


/*******************************************************************************
* coreotn_ohp_uninit
* ______________________________________________________________________________
*
* DESCRIPTION:
*             Reset an OHP.
*              
*
* INPUTS:
*   *coreotn_handle        - coreotn handle instance
*
*   ohp                    - Specifies which OHP to configure (DIGI_OHP_1, 
*                            DIGI_OHP_2 or DIGI_OHP_3)
*                            
* OUTPUTS:
*
* RETURNS:
*   PMC_ERROR             - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
*
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ohp_uninit(coreotn_handle_t *coreotn_handle, 
                                    odu_ohp_inst_t ohp)
{

    PMC_ERROR rc;
    odu_ohp_handle_t *ohp_handle;
   
    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(ohp < COREOTN_NUM_ODU_OHP_MAX, COREOTN_ERR_INVALID_ARG, 0, 0);
    ohp_handle = coreotn_handle->odu_ohp_handle[ohp];
    PMC_ASSERT(NULL != ohp_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    rc = odu_ohp_uninit(ohp_handle);
    coreotn_odu_ohp_energy_state_reg_set(coreotn_handle,(coreotn_odu_ohp_inst_t)ohp,PMC_ENERGY_STATE_RESET);
    PMC_RETURN(rc);
} /* coreotn_ohp_uninit */

/*******************************************************************************
* coreotn_ohp_ch_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enable/Disable overhead extraction/insertion for the given channel.

*
* INPUTS:
*  *coreotn_handle   - pointer to ODU_OHP handle instance
*  odu_ptr           - ODU struct 
*  extract_mask      - Extraction mask (16 bits). Each bit indicates 
*                      whether the corresponding overhead word should be 
*                      extracted. A maximum of 10 bits can be set to 1.
*                      (corresponding to the extraction of 10 words).
*
*   insert_mask      - Insertion mask (16 bits). Each bit indicates 
*                      whether the corresponding overhead word will be 
*                      inserted. A maximum of 10 bits can be set to 1.
*                      (corresponding to the insertion of 10 words).
*
*   num_cal_entries  - Number of calendar entries
*
*   cal_entries      - Calendar 
*
*   enable           - Enable (when TRUE) or disable (when FALSE) the overhead 
*                      insertion/extraction for this channel.

*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ohp_ch_cfg(coreotn_handle_t *coreotn_handle,
                                    odu_struct_t *odu_ptr, 
                                    UINT16 extract_mask,
                                    UINT16 insert_mask,
                                    UINT32 num_cal_entries,
                                    UINT32 *cal_entries,
                                    BOOL enable)
{
    PMC_ERROR rc = COREOTN_ERR_INVALID_ARG;
    odu_ohp_handle_t *ohp_handle;
    int ohp_port;
    int ohp;
    odu_struct_frm_id_t frm_id;
    odu_ohp_port_framer_t port_framer = ODU_OHP_PORT_FRAMER_1;
    UINT32 ch_id; 

    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != odu_ptr, COREOTN_ERR_NULL_HANDLE, 0, 0);

    frm_id = odu_struct_frm_id_get(coreotn_handle,odu_ptr);
    ch_id = odu_struct_ch_id_get(odu_ptr);

    switch(frm_id) {
    case ODU_STRUCT_FRM_STG1:  port_framer = ODU_OHP_PORT_FRAMER_1;  break;
    case ODU_STRUCT_FRM_STG2:  port_framer = ODU_OHP_PORT_FRAMER_2;  break;
    case ODU_STRUCT_FRM_STG3A: port_framer = ODU_OHP_PORT_FRAMER_3A; break;
    case ODU_STRUCT_FRM_STG3B: port_framer = ODU_OHP_PORT_FRAMER_3B; break;
    case ODU_STRUCT_FRM_STG4:  port_framer = ODU_OHP_PORT_FRAMER_4;  break;
    case ODU_STRUCT_FRM_STGN:  port_framer = ODU_OHP_PORT_FRAMER_N;  break;
    default: 
        PMC_ASSERT(FALSE,COREOTN_ERR_INVALID_ARG,frm_id,0);
    }
    
    PMC_LOG_TRACE("ohp: ch = %d frm_id = %d extract =%x insert %x enable=%d\n", 
                  ch_id,frm_id,extract_mask,insert_mask,enable );

    /* Find the port with the configured framer */
    for(ohp = ODU_OHP_1; ohp <= ODU_OHP_3; ohp++)
    {
        ohp_handle = coreotn_handle->odu_ohp_handle[ohp];
        for(ohp_port = ODU_OHP_PORT_A; ohp_port <= ODU_OHP_PORT_B;ohp_port++) 
        {
            if (ohp_handle->cfg.port_cfg[ohp_port].port_framer == port_framer) 
            {
                rc = odu_ohp_ch_cfg(ohp_handle,
                                    (odu_ohp_port_t)ohp_port,
                                    ch_id,
                                    extract_mask,insert_mask,
                                    num_cal_entries,cal_entries,
                                    enable);
                PMC_RETURN(rc);
            }
        }
    }
    /* Port not found */
    PMC_RETURN(COREOTN_ERR_OHP_PORT_NOT_DEFINED);
} /* coreotn_ohp_ch_cfg */

/*******************************************************************************
* coreotn_ohp_ch_cfg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Gets overhead extraction/insertion config for the given channel.

*
* INPUTS:
*  *coreotn_handle   - pointer to ODU_OHP handle instance
*  odu_ptr           - ODU struct 
*
* OUTPUTS:
*   extract_mask     - Extraction mask (16 bits). Each bit indicates 
*                      whether the corresponding overhead word should be 
*                      extracted. A maximum of 10 bits can be set to 1.
*                      (corresponding to the extraction of 10 words).
*
*   insert_mask      - Insertion mask (16 bits). Each bit indicates 
*                      whether the corresponding overhead word will be 
*                      inserted. A maximum of 10 bits can be set to 1.
*                      (corresponding to the insertion of 10 words).
*
*   enable           - Enable (when TRUE) or disable (when FALSE) the overhead 
*                      insertion/extraction for this channel.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ohp_ch_cfg_get(coreotn_handle_t *coreotn_handle,
                                        odu_struct_t *odu_ptr, 
                                        UINT16 *extract_mask,
                                        UINT16 *insert_mask,
                                        BOOL *enable)
{
    PMC_ERROR rc = PMC_SUCCESS;
    odu_ohp_handle_t *ohp_handle;
    int ohp_port;
    int ohp;
    odu_struct_frm_id_t frm_id;
    odu_ohp_port_framer_t port_framer = ODU_OHP_PORT_FRAMER_1;
    UINT32 ch_id; 

    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != odu_ptr, COREOTN_ERR_NULL_HANDLE, 0, 0);

    frm_id = odu_struct_frm_id_get(coreotn_handle,odu_ptr);
    ch_id = odu_struct_ch_id_get(odu_ptr);

    switch(frm_id) {
    case ODU_STRUCT_FRM_STG1:  port_framer = ODU_OHP_PORT_FRAMER_1;  break;
    case ODU_STRUCT_FRM_STG2:  port_framer = ODU_OHP_PORT_FRAMER_2;  break;
    case ODU_STRUCT_FRM_STG3A: port_framer = ODU_OHP_PORT_FRAMER_3A; break;
    case ODU_STRUCT_FRM_STG3B: port_framer = ODU_OHP_PORT_FRAMER_3B; break;
    case ODU_STRUCT_FRM_STG4:  port_framer = ODU_OHP_PORT_FRAMER_4;  break;
    case ODU_STRUCT_FRM_STGN:  port_framer = ODU_OHP_PORT_FRAMER_N;  break;
    default: 
        PMC_ASSERT(FALSE,COREOTN_ERR_INVALID_ARG,frm_id,0);
    }
    
    /* Find the port with the configured framer */
    for(ohp = ODU_OHP_1; ohp <= ODU_OHP_3; ohp++)
    {
        ohp_handle = coreotn_handle->odu_ohp_handle[ohp];
        for(ohp_port = ODU_OHP_PORT_A; ohp_port <= ODU_OHP_PORT_B;ohp_port++) 
        {
            if (ohp_handle->cfg.port_cfg[ohp_port].port_framer == port_framer) 
            {
                rc = odu_ohp_ch_cfg_get(ohp_handle,
                                        (odu_ohp_port_t)ohp_port,
                                        ch_id,
                                        extract_mask,insert_mask,
                                        enable);
                PMC_RETURN(rc);
            }
        }
    }
    /* Port not found */
    *enable = FALSE;
    PMC_RETURN(rc);
} /* coreotn_ohp_ch_cfg_get */

/*******************************************************************************
* coreotn_ohp_ch_unidir_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enable/Disable overhead insertion OR extraction for the given channel. The
*   insertion_mode parameter determines whether insertion is enabled or 
*   extraction.

*
* INPUTS:
*  *coreotn_handle   - pointer to ODU_OHP handle instance
*  odu_ptr           - ODU struct 
*
*  mask              - Insertion or extraction mask (16 bits). Each bit indicates 
*                      whether the corresponding overhead word will be 
*                      inserted. A maximum of 10 bits can be set to 1.
*                      (corresponding to the insertion of 10 words).
*
*   num_cal_entries  - Number of calendar entries
*
*   cal_entries      - Calendar 
*
*   insertion_mode   - if TRUE enable insertion, else enable extraction
*
*   enable           - Enable (when TRUE) or disable (when FALSE) the overhead 
*                      insertion/extraction for this channel.

*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ohp_ch_unidir_cfg(coreotn_handle_t *coreotn_handle,
                                           odu_struct_t *odu_ptr, 
                                           UINT16 mask,
                                           UINT32 num_cal_entries,
                                           UINT32 *cal_entries,
                                           BOOL insertion_mode,
                                           BOOL enable)
{
    PMC_ERROR rc = COREOTN_ERR_INVALID_ARG;
    odu_ohp_handle_t *ohp_handle;
    int ohp_port;
    int ohp;
    odu_struct_frm_id_t frm_id;
    odu_ohp_port_framer_t port_framer = ODU_OHP_PORT_FRAMER_1;
    UINT32 ch_id; 

    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != odu_ptr, COREOTN_ERR_NULL_HANDLE, 0, 0);

    frm_id = odu_struct_frm_id_get(coreotn_handle,odu_ptr);
    ch_id = odu_struct_ch_id_get(odu_ptr);

    switch(frm_id) {
    case ODU_STRUCT_FRM_STG1:  port_framer = ODU_OHP_PORT_FRAMER_1;  break;
    case ODU_STRUCT_FRM_STG2:  port_framer = ODU_OHP_PORT_FRAMER_2;  break;
    case ODU_STRUCT_FRM_STG3A: port_framer = ODU_OHP_PORT_FRAMER_3A; break;
    case ODU_STRUCT_FRM_STG3B: port_framer = ODU_OHP_PORT_FRAMER_3B; break;
    case ODU_STRUCT_FRM_STG4:  port_framer = ODU_OHP_PORT_FRAMER_4;  break;
    case ODU_STRUCT_FRM_STGN:  port_framer = ODU_OHP_PORT_FRAMER_N;  break;
    default: 
        PMC_ASSERT(FALSE,COREOTN_ERR_INVALID_ARG,frm_id,0);
    }
    
    PMC_LOG_TRACE("ohp: ch = %d frm_id = %d mask=%x enable=%d\n",ch_id,frm_id,mask,enable);

    /* Find the port with the configured framer */
    for(ohp = ODU_OHP_1; ohp <= ODU_OHP_3; ohp++)
    {
        ohp_handle = coreotn_handle->odu_ohp_handle[ohp];
        for(ohp_port = ODU_OHP_PORT_A; ohp_port <= ODU_OHP_PORT_B;ohp_port++) 
        {
            if (ohp_handle->cfg.port_cfg[ohp_port].port_framer == port_framer) 
            {
                if (insertion_mode)
                {
                    rc = odu_ohp_ch_insert_cfg(ohp_handle,
                                    (odu_ohp_port_t)ohp_port,
                                    ch_id,
                                    mask,
                                    num_cal_entries,cal_entries,
                                    enable);
                }
                else
                    rc = odu_ohp_ch_extract_cfg(ohp_handle,
                                    (odu_ohp_port_t)ohp_port,
                                    ch_id,
                                    mask,
                                    num_cal_entries,cal_entries,
                                    enable);
                PMC_RETURN(rc);
            }
        }
    }
    /* Port not found */
    PMC_RETURN(COREOTN_ERR_OHP_PORT_NOT_DEFINED);
} /* coreotn_ohp_ch_cfg */

/*******************************************************************************
* coreotn_ohp_ch_unidir_cfg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Gets enable/disable status and mask of overhead insertion OR extraction for 
*   the given channel.
*
* INPUTS:
*   *coreotn_handle  - pointer to ODU_OHP handle instance
*   odu_ptr          - ODU struct 
*   insertion_mode   - if TRUE enable insertion, else enable extraction
*
* OUTPUTS:
*   mask             - Insertion or extraction mask (16 bits). Each bit indicates 
*                      whether the corresponding overhead word will be 
*                      inserted. A maximum of 10 bits can be set to 1.
*                      (corresponding to the insertion of 10 words).
*   enable           - Enable (when TRUE) or disable (when FALSE) the overhead 
*                      insertion/extraction for this channel.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ohp_ch_unidir_cfg_get(coreotn_handle_t *coreotn_handle,
                                               odu_struct_t *odu_ptr, 
                                               BOOL insertion_mode,
                                               UINT16 *mask,
                                               BOOL *enable)
{
    PMC_ERROR rc = PMC_SUCCESS;
    odu_ohp_handle_t *ohp_handle;
    int ohp_port;
    int ohp;
    odu_struct_frm_id_t frm_id;
    odu_ohp_port_framer_t port_framer = ODU_OHP_PORT_FRAMER_1;
    UINT32 ch_id; 

    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != odu_ptr, COREOTN_ERR_NULL_HANDLE, 0, 0);

    frm_id = odu_struct_frm_id_get(coreotn_handle,odu_ptr);
    ch_id = odu_struct_ch_id_get(odu_ptr);

    switch(frm_id) {
    case ODU_STRUCT_FRM_STG1:  port_framer = ODU_OHP_PORT_FRAMER_1;  break;
    case ODU_STRUCT_FRM_STG2:  port_framer = ODU_OHP_PORT_FRAMER_2;  break;
    case ODU_STRUCT_FRM_STG3A: port_framer = ODU_OHP_PORT_FRAMER_3A; break;
    case ODU_STRUCT_FRM_STG3B: port_framer = ODU_OHP_PORT_FRAMER_3B; break;
    case ODU_STRUCT_FRM_STG4:  port_framer = ODU_OHP_PORT_FRAMER_4;  break;
    case ODU_STRUCT_FRM_STGN:  port_framer = ODU_OHP_PORT_FRAMER_N;  break;
    default: 
        PMC_ASSERT(FALSE,COREOTN_ERR_INVALID_ARG,frm_id,0);
    }
    
    /* Find the port with the configured framer */
    for(ohp = ODU_OHP_1; ohp <= ODU_OHP_3; ohp++)
    {
        ohp_handle = coreotn_handle->odu_ohp_handle[ohp];
        for(ohp_port = ODU_OHP_PORT_A; ohp_port <= ODU_OHP_PORT_B;ohp_port++) 
        {
            if (ohp_handle->cfg.port_cfg[ohp_port].port_framer == port_framer) 
            {
                if (insertion_mode)
                {
                    rc = odu_ohp_ch_insert_cfg_get(ohp_handle,
                                                   (odu_ohp_port_t)ohp_port,
                                                   ch_id,
                                                   mask,
                                                   enable);
                }
                else
                {
                    rc = odu_ohp_ch_extract_cfg_get(ohp_handle,
                                                    (odu_ohp_port_t)ohp_port,
                                                    ch_id,
                                                    mask,
                                                    enable);
                }
                PMC_RETURN(rc);
            }
        }
    }
    /* Port not found */
    *enable = FALSE;
    PMC_RETURN(rc);
} /* coreotn_ohp_ch_cfg */

/*******************************************************************************
* coreotn_ohp_ch_resize
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   Resize OHP.

*
* INPUTS:
*  *coreotn_handle   - pointer to ODU_OHP handle instance
*  odu_ptr           - ODU struct 
*  num_cal_entries   - number of calendar entries to resize. The value is -ve to
*                      ramp down, +ve to ramp up.
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ohp_ch_resize(coreotn_handle_t *coreotn_handle,
                                       odu_struct_t *odu_ptr, 
                                       INT32 num_cal_entries)
{
    PMC_ERROR rc = COREOTN_ERR_INVALID_ARG;
    odu_ohp_handle_t *ohp_handle;
    int ohp_port;
    int ohp;
    odu_struct_frm_id_t frm_id;
    odu_ohp_port_framer_t port_framer = ODU_OHP_PORT_FRAMER_1;
    UINT32 ch_id; 

    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != odu_ptr, COREOTN_ERR_NULL_HANDLE, 0, 0);

    frm_id = odu_struct_frm_id_get(coreotn_handle,odu_ptr);
    ch_id = odu_struct_ch_id_get(odu_ptr);

    switch(frm_id) 
    {
    case ODU_STRUCT_FRM_STG1:  port_framer = ODU_OHP_PORT_FRAMER_1;  break;
    case ODU_STRUCT_FRM_STG2:  port_framer = ODU_OHP_PORT_FRAMER_2;  break;
    case ODU_STRUCT_FRM_STG3A: port_framer = ODU_OHP_PORT_FRAMER_3A; break;
    case ODU_STRUCT_FRM_STG3B: port_framer = ODU_OHP_PORT_FRAMER_3B; break;
    case ODU_STRUCT_FRM_STG4:  port_framer = ODU_OHP_PORT_FRAMER_4;  break;
    case ODU_STRUCT_FRM_STGN:  port_framer = ODU_OHP_PORT_FRAMER_N;  break;
    default: 
        PMC_ASSERT(FALSE,COREOTN_ERR_INVALID_ARG,frm_id,0);
    }

    PMC_LOG_TRACE("ohp: ch = %d frm_id = %d\n", ch_id,frm_id);

    /* Find the port with the configured framer */
    for(ohp = ODU_OHP_1; ohp <= ODU_OHP_3; ohp++)
    {
        ohp_handle = coreotn_handle->odu_ohp_handle[ohp];
        for(ohp_port = ODU_OHP_PORT_A; ohp_port <= ODU_OHP_PORT_B;ohp_port++) 
        {
            if (ohp_handle->cfg.port_cfg[ohp_port].port_framer == port_framer) 
            {
                rc = odu_ohp_ch_resize(ohp_handle,
                                       (odu_ohp_port_t)ohp_port,
                                       ch_id,
                                       num_cal_entries);
                PMC_RETURN(rc);
            }
        }
    }
    /* Port not found */
    PMC_LOG(PMC_LOG_SEV_HIGHEST, rc, frm_id, ch_id, "OHP port not found for framer = %d\n", frm_id);
    PMC_RETURN(COREOTN_ERR_OHP_PORT_NOT_DEFINED);
} /* coreotn_ohp_ch_resize */




/*******************************************************************************
* coreotn_ohp_port_framer_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*             Convert ODU ohp 
*              
*
* INPUTS:
*   *coreotn_handle        - coreotn handle instance
*
*   ohp                    - Specifies which OHP to configure (DIGI_OHP_1, 
*                            DIGI_OHP_2 or DIGI_OHP_3)
*                            
*   port                   - ODU Port (ODU_OHP_PORT_A or ODU_OHP_PORT_B)
*
*   port_framer             - ODU Port Framer
*
* OUTPUTS:
*
* RETURNS:
*   PMC_ERROR             - PMC_SUCCESS if successful, error code otherwise
*
* NOTES:
*
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_ohp_port_framer_cfg(coreotn_handle_t *coreotn_handle, 
                                              odu_ohp_inst_t ohp, 
                                              odu_ohp_port_t port,
                                              odu_ohp_port_framer_t port_framer)
{

    UINT32 framer_code;
    
    PMC_ENTRY();
    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);


    /* OHP 1 (framer 1/N) has a fixed connection to the framer */
    if (ohp == ODU_OHP_1)
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    switch(port_framer)
    {
    case ODU_OHP_PORT_FRAMER_2:
        framer_code = 1;
        break;
    case ODU_OHP_PORT_FRAMER_3A:
        framer_code = 2;
        break;
    case ODU_OHP_PORT_FRAMER_3B:
        framer_code = 3;
        break;
    case ODU_OHP_PORT_FRAMER_4:
        framer_code = 4;
        break;
    default:
        framer_code = 0; /* Unused port */
        break;
    } 
    switch(ohp) 
    {
    case ODU_OHP_2:
        if (port == ODU_OHP_PORT_A)
        {
            coreotn_ctl_field_OHP2_SEL_A_set(NULL,coreotn_handle,framer_code);
        }
        else
        {
            coreotn_ctl_field_OHP2_SEL_B_set(NULL,coreotn_handle,framer_code);
        }
        break;
    case ODU_OHP_3:
        if (port == ODU_OHP_PORT_A)
        {
            coreotn_ctl_field_OHP3_SEL_A_set(NULL,coreotn_handle,framer_code);
        }
        else
        {
            coreotn_ctl_field_OHP3_SEL_B_set(NULL,coreotn_handle,framer_code);
        }
        break;
    default:
        PMC_ASSERT(FALSE, COREOTN_ERR_INVALID_ARG, 0, 0);
    }

    PMC_RETURN(PMC_SUCCESS);

} /*coreotn_ohp_port_framer_cfg*/

/*******************************************************************************
* coreotn_db_full_cal_entries_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function retrieves calendar entries for framer stage 1, N, 2
*   3A or 3B. 
*
* INPUTS:
*   *coreotn_handle - pointer to odu ohp handle instance
*   rx_db           - rx or tx database
*   frm_id          - Framer ID
*
* OUTPUTS:
*   *cal_entry_ptr      - storage for an array of calendar entries occupied by
*                         the channel.
*   *num_cal_entries    - number of calendar entries 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_full_cal_entries_get(coreotn_handle_t * coreotn_handle,
                                                 BOOL rx_db,
                                                 odu_struct_frm_id_t frm_id,
                                                 UINT32 *cal_entry_ptr,
                                                 UINT32 *num_cal_entries)
{
    PMC_ERROR rc = PMC_SUCCESS;
    UINT32 db_handle;
    util_gen_db_id_t db_id;
    UINT32 num_of_recs;
    UINT32 cal_itr;

    PMC_ENTRY();

    /*
     * FRM_STG1/N/2/3a/3b - use coreotn db 
     * FRM_STG4 - use mapotn db 
     */
    if (ODU_STRUCT_FRM_STG4 == frm_id)
    {
        mapotn_db_key   key;
        mapotn_db_query_res *q_result = NULL;
    
        db_handle = (rx_db ? coreotn_handle->cfg.rx_mapotn_db_handle : coreotn_handle->cfg.tx_mapotn_db_handle);
        db_id =     (rx_db ? coreotn_handle->cfg.rx_mapotn_db_id     : coreotn_handle->cfg.tx_mapotn_db_id);
        
        for(cal_itr = 0;cal_itr<COREOTN_NUM_CHNL;cal_itr++)
        {            
            key.calendar_entry = cal_itr;
            key.channel_num = DO_NOT_USE_KEY;
            num_of_recs = gen_db_query(&(coreotn_handle->base),
                                       db_id,
                                       db_handle,
                                       (void *)&key,
                                       (void **)&q_result);   

            cal_entry_ptr[0] = (num_of_recs == 1)?q_result->p_recs[0]->channel_num:0xFF;
        }
    } else 
    {
        line_core_otn_db_key key;
        line_core_otn_db_query_res *q_result = NULL;

        db_handle = (rx_db ? coreotn_handle->cfg.rx_db_handle : coreotn_handle->cfg.tx_db_handle);
        db_id =     (rx_db ? coreotn_handle->cfg.rx_db_id     : coreotn_handle->cfg.tx_db_id);

        for(cal_itr = 0;cal_itr<COREOTN_NUM_CHNL;cal_itr++)
        { 
            key.calendar_entry = cal_itr;
            key.ho_channel = DO_NOT_USE_KEY;
            key.mo_channel = DO_NOT_USE_KEY;
            key.lo_channel = DO_NOT_USE_KEY;
            key.trib_slot = DO_NOT_USE_KEY;
            
            num_of_recs = gen_db_query(&(coreotn_handle->base),
                                       db_id,
                                       db_handle,
                                       (void *)&key,
                                       (void **)&q_result);
            switch(frm_id) 
            {
            case ODU_STRUCT_FRM_STG1:  
            case ODU_STRUCT_FRM_STGN: 
                cal_entry_ptr[cal_itr] = (num_of_recs == 1)?q_result->p_recs[0]->ho_channel:0xFF;
                break;
            case ODU_STRUCT_FRM_STG2:  
                cal_entry_ptr[cal_itr] = (num_of_recs == 1)?q_result->p_recs[0]->mo_channel:0xFF;
                break;
            case ODU_STRUCT_FRM_STG3A: 
            case ODU_STRUCT_FRM_STG3B:
                cal_entry_ptr[cal_itr] = (num_of_recs == 1)?q_result->p_recs[0]->lo_channel:0xFF;
                break;
            default: 
                /* NOTE: stage 4 framer uses mapotn db - assert an error if frm_id = stg4 */
                PMC_ASSERT(FALSE, COREOTN_ERR_INVALID_ARG, 0, 0);
            }
        }       
    }
    
    *num_cal_entries = COREOTN_NUM_CHNL;
        
    PMC_RETURN(rc);

} /* coretn_db_full_cal_entries_get */

/*******************************************************************************
* coreotn_db_cal_entries_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function retrieves a channel's calendar entries for framer stage 1, N, 2
*      3A or 3B. This function should not be called for framer stage 4.
*
* INPUTS:
*   *coreotn_handle - pointer to odu ohp handle instance
*   sysotn          - sysotn database (only valid for FRM stage 1)
*   rx_db           - rx or tx database
*   ch_id           - Channel ID
*   frm_id          - Framer ID
*
* OUTPUTS:
*   *cal_entry_ptr      - storage for an array of calendar entries occupied by
*                         the channel.  
*                         If this is NULL, only a count of the
*                         number of matching calendar entries will be done.
*   *num_cal_entries    - number of calendar entries 
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_cal_entries_get(coreotn_handle_t * coreotn_handle,
                                            BOOL sysotn,
                                            BOOL rx_db,
                                            UINT32 ch_id,
                                            odu_struct_frm_id_t frm_id,
                                            UINT32 *cal_entry_ptr,
                                            UINT32 *num_cal_entries)
{
    PMC_ERROR rc = PMC_SUCCESS;
    UINT32 db_handle;
    util_gen_db_id_t db_id;
    UINT32 num_of_recs;
    UINT32 i;

    PMC_ENTRY();
    if (sysotn == TRUE) 
    {
        PMC_ASSERT(frm_id == ODU_STRUCT_FRM_STG1, COREOTN_ERR_INVALID_ARG, 0, 0);
    }
    /*
     * FRM_STG1/N/2/3a/3b - use coreotn db 
     * FRM_STG4 - use mapotn db 
     */
    if (ODU_STRUCT_FRM_STG4 == frm_id ||
        (ODU_STRUCT_FRM_STG1 == frm_id && sysotn == TRUE))
    {
        mapotn_db_key   key;
        mapotn_db_query_res *q_result = NULL;
    
        if (ODU_STRUCT_FRM_STG4 == frm_id) 
        {
            db_handle = (rx_db ? coreotn_handle->cfg.rx_mapotn_db_handle : coreotn_handle->cfg.tx_mapotn_db_handle);
            db_id =     (rx_db ? coreotn_handle->cfg.rx_mapotn_db_id     : coreotn_handle->cfg.tx_mapotn_db_id);
        } 
        else 
        {
            db_handle = coreotn_handle->cfg.lineotn_sysotn_card_db_handle;
            db_id = coreotn_handle->cfg.lineotn_sysotn_card_db_id;
        }
        
        key.calendar_entry = DO_NOT_USE_KEY;
        key.channel_num = ch_id;
        if (NULL == cal_entry_ptr)
        {
            num_of_recs = gen_db_query_count(&(coreotn_handle->base),
                                             db_id,
                                             db_handle,
                                             (void *)&key);
        }
        else
        {
            num_of_recs = gen_db_query(&(coreotn_handle->base),
                                       db_id,
                                       db_handle,
                                       (void *)&key,
                                       (void **)&q_result);   
   
            for (i = 0; i < num_of_recs; i++)
            {
                cal_entry_ptr[i] = q_result->p_recs[i]->calendar_entry;
                PMC_LOG_TRACE("mapotn: cal_entry[%u] = %u\n", i, cal_entry_ptr[i]);
            }
        }
    } 
    else 
    {
        line_core_otn_db_key key;
        line_core_otn_db_query_res *q_result = NULL;

        db_handle = (rx_db ? coreotn_handle->cfg.rx_db_handle : coreotn_handle->cfg.tx_db_handle);
        db_id =     (rx_db ? coreotn_handle->cfg.rx_db_id     : coreotn_handle->cfg.tx_db_id);

        
        key.calendar_entry = DO_NOT_USE_KEY;
        key.ho_channel = DO_NOT_USE_KEY;
        key.mo_channel = DO_NOT_USE_KEY;
        key.lo_channel = DO_NOT_USE_KEY;
        key.trib_slot = DO_NOT_USE_KEY;
        
        switch(frm_id) 
        {
        case ODU_STRUCT_FRM_STG1:  
        case ODU_STRUCT_FRM_STGN: 
            key.ho_channel = ch_id;
            break;
        case ODU_STRUCT_FRM_STG2:  
            key.mo_channel = ch_id;
            break;
        case ODU_STRUCT_FRM_STG3A: 
        case ODU_STRUCT_FRM_STG3B:
            key.lo_channel = ch_id;
            break;
        default: 
            /* NOTE: stage 4 framer uses mapotn db - assert an error if frm_id = stg4 */
            PMC_ASSERT(FALSE, COREOTN_ERR_INVALID_ARG, 0, 0);
        }
        if (NULL == cal_entry_ptr)
        {
            num_of_recs = gen_db_query_count(&(coreotn_handle->base),
                                             db_id,
                                             db_handle,
                                             (void *)&key);
        }
        else
        {
            num_of_recs = gen_db_query(&(coreotn_handle->base),
                                       db_id,
                                       db_handle,
                                       (void *)&key,
                                       (void **)&q_result);
        }
        /* SYSOTN & one stage muxing -> the schedule for 3A/3B is retrieved using key.mo_channel */
        if (num_of_recs == 0 && key.lo_channel == ch_id)
        {
            key.mo_channel = ch_id;
            key.lo_channel = DO_NOT_USE_KEY;
            if (NULL == cal_entry_ptr)
            {
                num_of_recs = gen_db_query_count(&(coreotn_handle->base),
                                                 db_id,
                                                 db_handle,
                                                 (void *)&key);
            }
            else
            {
                num_of_recs = gen_db_query(&(coreotn_handle->base),
                                           db_id,
                                           db_handle,
                                           (void *)&key,
                                           (void **)&q_result);
            }
        }
        
        if (num_of_recs == 0 && key.mo_channel == ch_id)
        {
            key.ho_channel = ch_id;
            key.mo_channel = DO_NOT_USE_KEY;
            key.lo_channel = DO_NOT_USE_KEY;

            if (NULL == cal_entry_ptr)
            {
                num_of_recs = gen_db_query_count(&(coreotn_handle->base),
                                                 db_id,
                                                 db_handle,
                                                 (void *)&key);
            }
            else
            {
                num_of_recs = gen_db_query(&(coreotn_handle->base),
                                           db_id,
                                           db_handle,
                                           (void *)&key,
                                           (void **)&q_result);
            }
        }


        if (NULL != cal_entry_ptr)
        {
            for (i = 0; i < num_of_recs; i++)
            {
                cal_entry_ptr[i] = q_result->p_recs[i]->calendar_entry;
                PMC_LOG_TRACE("coreotn: cal_entry[%u] = %u\n", i, cal_entry_ptr[i]);
            }
        }
    }
    
    PMC_LOG_TRACE("coreotn: ch_id = %d, framer = %d, num of recs = %d\n", ch_id,frm_id, num_of_recs);

    *num_cal_entries = num_of_recs;
        
    PMC_RETURN(rc);

} /* coretn_db_cal_entries_get */

/*******************************************************************************
* FUNCTION: coreotn_stg3b_odu_level_set()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Sets the ODU level (HO/MO/LO) that the stg3b channel is attached to
*
* INPUTS:
*   coreotn_handle     - Pointer to coreotn handle
*   chnl_id            - Channel id (0...95)
*   odu_level          - ODU Level that this stg3b channel is attached to
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_stg3b_odu_level_set(coreotn_handle_t       *coreotn_handle,
                                             UINT32                  chnl_id,
                                             odu_struct_odu_level_t  odu_level)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    
    if ((chnl_id >= COREOTN_MAX_NUM_LO_CHNL) ||
        (odu_level >= LAST_ODU_STRUCT_LEVEL))
    {
        result = COREOTN_ERR_INVALID_ARG;
    }

    /* If there is a coding error use assert to prevent return nesting. */
    PMC_ASSERT(PMC_SUCCESS==result, COREOTN_ERR_INVALID_ARG, 0, 0);

    coreotn_handle->var.stg3b_odu_level[chnl_id] = odu_level;

    PMC_RETURN(result);
} /* coreotn_stg3b_odu_level_set */

/*******************************************************************************
* FUNCTION: coreotn_stg3b_odu_level_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Gets the ODU level (HO/MO/LO) that the stg3b channel is attached to
*
* INPUTS:
*   coreotn_handle     - Pointer to coreotn handle
*   chnl_id            - Channel id (0...95)
*
* OUTPUTS:
*   odu_level          - ODU Level that this stg3b channel is attached to
*
* RETURNS:
*   PMC_SUCCESS     - 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_stg3b_odu_level_get(coreotn_handle_t       *coreotn_handle,
                                             UINT32                  chnl_id,
                                             odu_struct_odu_level_t *odu_level)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    
    if (chnl_id >= COREOTN_MAX_NUM_LO_CHNL)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    *odu_level = coreotn_handle->var.stg3b_odu_level[chnl_id];

    PMC_RETURN(result);
} /* coreotn_stg3b_odu_level_get */


/*******************************************************************************
* FUNCTION: coreotn_int_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Validates input for interrupt functions.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_table_ptr     - pointer to aggregation or channel interrupt table with
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_validate(coreotn_handle_t         *coreotn_handle,
                                      coreotn_int_chnl_info_t  *chnl_info,
                                      void                     *int_table_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();
    
    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != chnl_info, COREOTN_ERR_NULL_HANDLE, 0, 0);

    if (NULL == int_table_ptr)
    {
        result = COREOTN_ERR_INVALID_ARG;
    }

    /* Check chnl_info. chnl_info->chnl_id will be checked by the subblocks,
     * as the valid channel range differs by odu_level */
    switch (chnl_info->odu_level)
    {
    case ODU_STRUCT_LEVEL_HO_ODU:
    case ODU_STRUCT_LEVEL_MO_ODU:
    case ODU_STRUCT_LEVEL_LO_ODU:
    case ODU_STRUCT_LEVEL_3B_ODU:
    case ODU_STRUCT_LEVEL_4_ODU:
    case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
        break;
    
    default:
        result = COREOTN_ERR_ODU_LEVEL_NOT_VALID;
        break;
    } /* end switch */

    if (chnl_info->source >= LAST_COREOTN_INT_SOURCE)
    {
        result = COREOTN_ERR_ODU_LEVEL_NOT_VALID;
    }

    PMC_RETURN(result);
} /* coreotn_int_validate */


/*******************************************************************************
* FUNCTION: coreotn_rfrm_handle_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Obtains RFRM handle based on odu_level and line/server source.  
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*
* OUTPUTS:
*   rfrm_handle     - Returned RFRM handle
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rfrm_handle_get(coreotn_handle_t           *coreotn_handle,
                                          coreotn_int_chnl_info_t    *chnl_info,
                                          odu_rfrm_handle_t         **rfrm_handle)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    /* Determine which ODU level channel handle is for */
    if (COREOTN_INT_SOURCE_LINE == chnl_info->source)
    {
        switch (chnl_info->odu_level)
        {
        case ODU_STRUCT_LEVEL_HO_ODU:
            *rfrm_handle = coreotn_handle->odu_rfrm_stg1_handle;
            break;
            
        case ODU_STRUCT_LEVEL_MO_ODU:
            *rfrm_handle = coreotn_handle->odu_rfrm_stg2_handle;
            break;
            
        case ODU_STRUCT_LEVEL_LO_ODU:
            *rfrm_handle = coreotn_handle->odu_rfrm_stg3a_handle;
            break;
          
        case ODU_STRUCT_LEVEL_3B_ODU:
            *rfrm_handle = coreotn_handle->odu_rfrm_stg3b_handle;
            break;
          
        case ODU_STRUCT_LEVEL_4_ODU:
            *rfrm_handle = coreotn_handle->odu_rfrm_stg4_handle;
            break;
        
        default:
            *rfrm_handle = NULL;
            break;
        } /* end switch */
    }
    else 
    {
        switch (chnl_info->odu_level)
        {
        case ODU_STRUCT_LEVEL_HO_ODU:
            *rfrm_handle = coreotn_handle->odu_rfrm_stgN_handle;
            break;
            
        case ODU_STRUCT_LEVEL_MO_ODU:
            *rfrm_handle = coreotn_handle->odu_rfrm_stg3a_handle;
            break;
            
        case ODU_STRUCT_LEVEL_LO_ODU:
            *rfrm_handle = coreotn_handle->odu_rfrm_stg1_handle;
            break;
          
        case ODU_STRUCT_LEVEL_3B_ODU:
            *rfrm_handle = coreotn_handle->odu_rfrm_stg3b_handle;
            break;
          
        case ODU_STRUCT_LEVEL_4_ODU:
            *rfrm_handle = coreotn_handle->odu_rfrm_stg4_handle;
            break;
        
        case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
            *rfrm_handle = coreotn_handle->odu_rfrm_stg2_handle;
            break;
        
        default:
            *rfrm_handle = NULL;
            break;
        } /* end switch */
    }


    PMC_RETURN(result);
} /* coreotn_rfrm_handle_get */

/*******************************************************************************
* FUNCTION: coreotn_tfrm_handle_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Obtains TFRM handle based on odu_level and line/server source.  
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*
* OUTPUTS:
*   tfrm_handle     - Returned TFRM handle
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tfrm_handle_get(coreotn_handle_t           *coreotn_handle,
                                          coreotn_int_chnl_info_t    *chnl_info,
                                          odu_tfrm_handle_t         **tfrm_handle)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    /* Determine which ODU level channel handle is for */
    if (COREOTN_INT_SOURCE_LINE == chnl_info->source)
    {
        switch (chnl_info->odu_level)
        {
        case ODU_STRUCT_LEVEL_HO_ODU:
            *tfrm_handle = coreotn_handle->odu_tfrm_stg1_handle;
            break;
            
        case ODU_STRUCT_LEVEL_MO_ODU:
            *tfrm_handle = coreotn_handle->odu_tfrm_stg2_handle;
            break;
            
        case ODU_STRUCT_LEVEL_LO_ODU:
            *tfrm_handle = coreotn_handle->odu_tfrm_stg3a_handle;
            break;
          
        case ODU_STRUCT_LEVEL_3B_ODU:
            *tfrm_handle = coreotn_handle->odu_tfrm_stg3b_handle;
            break;
          
        case ODU_STRUCT_LEVEL_4_ODU:
            *tfrm_handle = coreotn_handle->odu_tfrm_stg4_handle;
            break;
        
        default:
            *tfrm_handle = NULL;
            break;
        } /* end switch */
    }
    else 
    {
        switch (chnl_info->odu_level)
        {
        case ODU_STRUCT_LEVEL_HO_ODU:
            *tfrm_handle = coreotn_handle->odu_tfrm_stgN_handle;
            break;
            
        case ODU_STRUCT_LEVEL_MO_ODU:
            *tfrm_handle = coreotn_handle->odu_tfrm_stg3a_handle;
            break;
            
        case ODU_STRUCT_LEVEL_LO_ODU:
            *tfrm_handle = coreotn_handle->odu_tfrm_stg1_handle;
            break;
          
        case ODU_STRUCT_LEVEL_3B_ODU:
            *tfrm_handle = coreotn_handle->odu_tfrm_stg3b_handle;
            break;
          
        case ODU_STRUCT_LEVEL_4_ODU:
            *tfrm_handle = coreotn_handle->odu_tfrm_stg4_handle;
            break;
        
        case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
            *tfrm_handle = coreotn_handle->odu_tfrm_stg2_handle;
            break;
        
        default:
            *tfrm_handle = NULL;
            break;
        } /* end switch */
    }


    PMC_RETURN(result);
} /* coreotn_tfrm_handle_get */


/*******************************************************************************
* FUNCTION: coreotn_odtu_dmx_handle_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Obtains ODTU_DMX handle based on odu_level and line/server source.
*   There are only two ODTU_DMX that sit between the three framers (between
*   HO/MO and between MO/LO). However, interrupt and status are reported on a
*   per odu level (HO/MO/LO), so we need to apply the ODTU DMX interrupts to the
*   correct odu level. Some ODTU DMX interrupts only apply to the "higher order"
*   odus (HO and MO), and some ODTU DMX interrupts only apply to the "lower order"
*   odus (MO and LO). Because of this, we need to return two sets of ODTU DMX
*   handles, so that the higher order and lower order interrupts can be applied
*   to the correct ODUs.
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*
* OUTPUTS:
*   odtu_dmx_ho_handle - Returned odtu_dmx handle for higher order ODUs (HO, MO)
*   odtu_dmx_lo_handle - Returned odtu_dmx handle for lower order ODUs (MO, LO)
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odtu_dmx_handle_get(coreotn_handle_t           *coreotn_handle,
                                              coreotn_int_chnl_info_t    *chnl_info,
                                              odtu_dmx_handle_t         **odtu_dmx_ho_handle,
                                              odtu_dmx_handle_t         **odtu_dmx_lo_handle)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();
    
    *odtu_dmx_ho_handle = NULL;
    *odtu_dmx_lo_handle = NULL;

    /* Determine which ODU level channel handle is for */
    if (COREOTN_INT_SOURCE_LINE == chnl_info->source)
    {
        switch (chnl_info->odu_level)
        {
        case ODU_STRUCT_LEVEL_HO_ODU:
            *odtu_dmx_ho_handle = coreotn_handle->odtu_dmx1_handle;
            *odtu_dmx_lo_handle = NULL;
            break;
            
        case ODU_STRUCT_LEVEL_MO_ODU:
            *odtu_dmx_ho_handle = coreotn_handle->odtu_dmx2_handle;
            *odtu_dmx_lo_handle = coreotn_handle->odtu_dmx1_handle;
            break;
            
        case ODU_STRUCT_LEVEL_LO_ODU:
            *odtu_dmx_ho_handle = NULL;
            *odtu_dmx_lo_handle = coreotn_handle->odtu_dmx2_handle;
            break;
          
        case ODU_STRUCT_LEVEL_3B_ODU:
        case ODU_STRUCT_LEVEL_4_ODU:
        default:
            break;
        } /* end switch */
    }
    else 
    {
        switch (chnl_info->odu_level)
        {
        case ODU_STRUCT_LEVEL_HO_ODU:
            *odtu_dmx_ho_handle = coreotn_handle->odtu_dmx2_handle;
            *odtu_dmx_lo_handle = NULL;
            break;
            
        case ODU_STRUCT_LEVEL_MO_ODU:
            *odtu_dmx_ho_handle = NULL;
            *odtu_dmx_lo_handle = coreotn_handle->odtu_dmx2_handle;
            break;

        case ODU_STRUCT_LEVEL_LO_ODU:
        case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
        case ODU_STRUCT_LEVEL_3B_ODU:
        case ODU_STRUCT_LEVEL_4_ODU:
        default:
            break;
        } /* end switch */
    }


    PMC_RETURN(result);
} /* coreotn_odtu_dmx_handle_get */


/*******************************************************************************
* FUNCTION: coreotn_mpma_mpmo_handle_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Obtains MPMO/MPMA handle based on odu_level and line/server source.
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*
* OUTPUTS:
*   mpma_handle - Returned mpma handle for higher order ODUs (HO, MO)
*   mpmo_handle - Returned mpmo handle for lower order ODUs (MO, LO)
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_mpma_mpmo_handle_get(coreotn_handle_t           *coreotn_handle,
                                               coreotn_int_chnl_info_t    *chnl_info,
                                               mpma_handle_t              **mpma_handle,
                                               mpmo_handle_t              **mpmo_handle)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();
    
    *mpma_handle = NULL;
    *mpmo_handle = NULL;

    /* Determine which ODU level channel handle is for */
    switch (chnl_info->odu_level)
    {                                     
    case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:      
        if (COREOTN_INT_SOURCE_LINE != chnl_info->source)
        {            
            if (coreotn_handle->var.sysapp_line_state[chnl_info->chnl_id] ==  COREOTN_CHNL_OPERATIONAL)
            {
                *mpma_handle = coreotn_handle->mpma_core_ctl_handle;
                *mpmo_handle = coreotn_handle->mpmo_core_ctl_handle;
            }
        }
        break;
    case ODU_STRUCT_LEVEL_3B_ODU:
        if (coreotn_handle->var.rx_oduksw_chnl_ctxt[(UINT32) COREOTN_ODUKSW_INPUT_COREOTN][chnl_info->chnl_id].state == COREOTN_CHNL_OPERATIONAL )
        {
            *mpma_handle = coreotn_handle->mpma_fo1_handle;   
        } 
        if (coreotn_handle->var.tx_oduksw_chnl_ctxt[(UINT32) COREOTN_ODUKSW_OUTPUT_COREOTN][chnl_info->chnl_id].state == COREOTN_CHNL_OPERATIONAL )
        {
            *mpmo_handle = coreotn_handle->mpmo_fo1_handle;   
        }
        break;
    case ODU_STRUCT_LEVEL_4_ODU:
        if (coreotn_handle->var.rx_stg4_chnl_prov[chnl_info->chnl_id] == TRUE)
        {
            *mpmo_handle = coreotn_handle->mpmo_fo2_handle;   
        }
        if (coreotn_handle->var.tx_stg4_chnl_prov[chnl_info->chnl_id] == TRUE)
        {
            *mpma_handle = coreotn_handle->mpma_fo2_handle;   
        }
        break;      
    default:
        break;
    } /* end switch */

   

    PMC_RETURN(result);
} /* coreotn_mpma_mpmo_handle_get */

/*******************************************************************************
* FUNCTION: coreotn_oduksc_handle_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Obtains ODUKSC handle based on odu_level and line/server source.
*   There are only two ODUKSC that sit between the three framers (between
*   HO/MO and between MO/LO). However, interrupt and status are reported on a
*   per odu level (HO/MO/LO), so we need to apply the ODUKSC interrupts to the
*   correct odu level. Some ODUKSC interrupts only apply to the "higher order"
*   odus (HO and MO), and some ODUKSC interrupts only apply to the "lower order"
*   odus (MO and LO). Because of this, we need to return two sets of ODUKSC
*   handles, so that the higher order and lower order interrupts can be applied
*   to the correct ODUs.
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*
* OUTPUTS:
*   oduksc_ho_handle - Returned oduksc handle for higher order ODUs (HO, MO)
*   oduksc_lo_handle - Returned oduksc handle for lower order ODUs (MO, LO)
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_oduksc_handle_get(coreotn_handle_t           *coreotn_handle,
                                            coreotn_int_chnl_info_t    *chnl_info,
                                            oduksc_handle_t           **oduksc_ho_handle,
                                            oduksc_handle_t           **oduksc_lo_handle)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();
    
    *oduksc_ho_handle = NULL;
    *oduksc_lo_handle = NULL;

    /* Determine which ODU level channel handle is for */
    if (COREOTN_INT_SOURCE_LINE == chnl_info->source)
    {
        switch (chnl_info->odu_level)
        {
        case ODU_STRUCT_LEVEL_HO_ODU:
            *oduksc_ho_handle = coreotn_handle->oduksc1_handle;
            break;
            
        case ODU_STRUCT_LEVEL_MO_ODU:
            *oduksc_lo_handle = coreotn_handle->oduksc1_handle;
            break;
            
        case ODU_STRUCT_LEVEL_LO_ODU:
            *oduksc_lo_handle = coreotn_handle->oduksc2_handle;
            break;
          
        case ODU_STRUCT_LEVEL_3B_ODU:
        case ODU_STRUCT_LEVEL_4_ODU:
        default:
            break;
        } /* end switch */
    }
    else 
    {
        switch (chnl_info->odu_level)
        {
        case ODU_STRUCT_LEVEL_HO_ODU:
            *oduksc_ho_handle = coreotn_handle->oduksc2_handle;
            break;
            
        case ODU_STRUCT_LEVEL_MO_ODU:
            *oduksc_lo_handle = coreotn_handle->oduksc2_handle;
            break;
            
        case ODU_STRUCT_LEVEL_LO_ODU:
            *oduksc_ho_handle = coreotn_handle->oduksc1_handle;
            break;
          
        case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
            *oduksc_lo_handle = coreotn_handle->oduksc1_handle;
            break;
          
        case ODU_STRUCT_LEVEL_3B_ODU:
        case ODU_STRUCT_LEVEL_4_ODU:
        default:
            break;
        } /* end switch */
    }


    PMC_RETURN(result);
} /* coreotn_oduksc_handle_get */


/*******************************************************************************
* FUNCTION: coreotn_odujat_handle_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Obtains ODUJAT handle based on odu_level and line/server source.
*   There are only two ODUJAT that sit between the three framers (between
*   HO/MO and between MO/LO). However, interrupt and status are reported on a
*   per odu level (HO/MO/LO), so we need to apply the ODUJAT interrupts to the
*   correct odu level. Some ODUJAT interrupts only apply to the "higher order"
*   odus (HO and MO), and some ODUJAT interrupts only apply to the "lower order"
*   odus (MO and LO). Because of this, we need to return two sets of ODUJAT
*   handles, so that the higher order and lower order interrupts can be applied
*   to the correct ODUs.
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*
* OUTPUTS:
*   odujat_ho_handle - Returned odujat handle for higher order ODUs (HO, MO)
*   odujat_lo_handle - Returned odujat handle for lower order ODUs (MO, LO)
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odujat_handle_get(coreotn_handle_t           *coreotn_handle,
                                            coreotn_int_chnl_info_t    *chnl_info,
                                            odujat_handle_t           **odujat_ho_handle,
                                            odujat_handle_t           **odujat_lo_handle)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();
    
    *odujat_ho_handle = NULL;
    *odujat_lo_handle = NULL;

    /* Determine which ODU level channel handle is for */
    if (COREOTN_INT_SOURCE_LINE == chnl_info->source)
    {
        switch (chnl_info->odu_level)
        {
        case ODU_STRUCT_LEVEL_HO_ODU:
            *odujat_ho_handle = coreotn_handle->odujat1_handle;
            break;
            
        case ODU_STRUCT_LEVEL_MO_ODU:
            *odujat_lo_handle = coreotn_handle->odujat1_handle;
            break;
            
        case ODU_STRUCT_LEVEL_LO_ODU:
            *odujat_lo_handle = coreotn_handle->odujat2_handle;
            break;
          
        case ODU_STRUCT_LEVEL_3B_ODU:
        case ODU_STRUCT_LEVEL_4_ODU:
        default:
            break;
        } /* end switch */
    }
    else 
    {
        switch (chnl_info->odu_level)
        {
        case ODU_STRUCT_LEVEL_HO_ODU:
            *odujat_ho_handle = coreotn_handle->odujat2_handle;
            break;
            
        case ODU_STRUCT_LEVEL_MO_ODU:
            *odujat_lo_handle = coreotn_handle->odujat2_handle;
            break;
            
        case ODU_STRUCT_LEVEL_LO_ODU:
            *odujat_ho_handle = coreotn_handle->odujat1_handle;
            break;
          
        case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
            *odujat_lo_handle = coreotn_handle->odujat1_handle;
            break;
          
        case ODU_STRUCT_LEVEL_3B_ODU:
        case ODU_STRUCT_LEVEL_4_ODU:
        default:
            break;
        } /* end switch */
    }


    PMC_RETURN(result);
} /* coreotn_odujat_handle_get */

/*******************************************************************************
* FUNCTION: coreotn_odtu_mux_handle_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Obtains ODTU_MUX handle based on odu_level and line/server source.
*   There are only two ODTU_MUX that sit between the three framers (between
*   HO/MO and between MO/LO). However, interrupt and status are reported on a
*   per odu level (HO/MO/LO), so we need to apply the ODTU MUX interrupts to the
*   correct odu level. Some ODTU MUX interrupts only apply to the "higher order"
*   odus (HO and MO), and some ODTU MUX interrupts only apply to the "lower order"
*   odus (MO and LO). Because of this, we need to return two sets of ODTU MUX
*   handles, so that the higher order and lower order interrupts can be applied
*   to the correct ODUs.
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*
* OUTPUTS:
*   odtu_mux_ho_handle - Returned odtu_mux handle for higher order ODUs (HO, MO)
*   odtu_mux_lo_handle - Returned odtu_mux handle for lower order ODUs (MO, LO)
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odtu_mux_handle_get(coreotn_handle_t           *coreotn_handle,
                                            coreotn_int_chnl_info_t    *chnl_info,
                                            odtu_mux_handle_t           **odtu_mux_ho_handle,
                                            odtu_mux_handle_t           **odtu_mux_lo_handle)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();
    
    *odtu_mux_ho_handle = NULL;
    *odtu_mux_lo_handle = NULL;

    /* Determine which ODU level channel handle is for */
    if (COREOTN_INT_SOURCE_LINE == chnl_info->source)
    {
        switch (chnl_info->odu_level)
        {
        case ODU_STRUCT_LEVEL_HO_ODU:
            *odtu_mux_ho_handle = coreotn_handle->odtu_mux1_handle;
            break;
            
        case ODU_STRUCT_LEVEL_MO_ODU:
            *odtu_mux_lo_handle = coreotn_handle->odtu_mux1_handle;
            break;
            
        case ODU_STRUCT_LEVEL_LO_ODU:
            *odtu_mux_lo_handle = coreotn_handle->odtu_mux2_handle;
            break;
          
        case ODU_STRUCT_LEVEL_3B_ODU:
        case ODU_STRUCT_LEVEL_4_ODU:
        default:
            break;
        } /* end switch */
    }
    else 
    {
        switch (chnl_info->odu_level)
        {
        case ODU_STRUCT_LEVEL_HO_ODU:
            *odtu_mux_ho_handle = coreotn_handle->odtu_mux2_handle;
            break;
            
        case ODU_STRUCT_LEVEL_MO_ODU:
            *odtu_mux_lo_handle = coreotn_handle->odtu_mux2_handle;
            break;
            
        case ODU_STRUCT_LEVEL_LO_ODU:
            *odtu_mux_ho_handle = coreotn_handle->odtu_mux1_handle;
            break;
          
        case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
            *odtu_mux_lo_handle = coreotn_handle->odtu_mux1_handle;
            break;
          
        case ODU_STRUCT_LEVEL_3B_ODU:
        case ODU_STRUCT_LEVEL_4_ODU:
        default:
            break;
        } /* end switch */
    }

    PMC_RETURN(result);
} /* coreotn_odtu_mux_handle_get */

/*******************************************************************************
* FUNCTION: coreotn_odtu_dmx_trib_slot_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Obtains the tribslots for a given channel id and odu level.
*
* INPUTS:
*   coreotn_handle      - Pointer to coreotn handle
*   chnl_info_ptr       - structure describing the channel: chnl id, odu level
*                         lineotn/sysotn
*   *odtu_dmx_handle    - ODTU DMX handle
*
* OUTPUTS:
*   odtu_dmx_info_ptr   - structure describing the odtu dmx channel: chnl id,
*                         trib slots
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odtu_dmx_trib_slot_get(coreotn_handle_t           *coreotn_handle,
                                                 coreotn_int_chnl_info_t    *chnl_info_ptr,
                                                 odtu_dmx_handle_t          *odtu_dmx_handle,
                                                 odtu_dmx_int_chnl_info_t   *odtu_dmx_info_ptr)
{
    PMC_ERROR               result = PMC_SUCCESS;
    odu_struct_odu_level_t  odu_level;

    PMC_ENTRY();

    if (NULL == odtu_dmx_handle)
    {
        PMC_RETURN(result);   
    }


    odu_level = chnl_info_ptr->odu_level;


    /* Retrieve trib slot ID corresponding to chnl_id */
    switch (odu_level)
    {
    case ODU_STRUCT_LEVEL_HO_ODU:
        result = coreotn_db_ho_cal_entry_all_get(coreotn_handle,
                                                 chnl_info_ptr->chnl_id,
                                                 odtu_dmx_info_ptr->calendar_id,      /* output */
                                                 &odtu_dmx_info_ptr->num_cal_entries); /* output */
        break;
        
    case ODU_STRUCT_LEVEL_MO_ODU:
        result = coreotn_db_mo_cal_entry_all_get(coreotn_handle,
                                                 chnl_info_ptr->chnl_id,
                                                 1, /*RX DB*/
                                                 odtu_dmx_info_ptr->calendar_id,      /* output */
                                                 &odtu_dmx_info_ptr->num_cal_entries); /* output */
        break;
        
    case ODU_STRUCT_LEVEL_LO_ODU:
    case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:
        result = coreotn_db_lo_cal_entry_all_get(coreotn_handle,
                                                 chnl_info_ptr->chnl_id,
                                                 1, /*RX DB*/
                                                 odtu_dmx_info_ptr->calendar_id,      /* output */
                                                 &odtu_dmx_info_ptr->num_cal_entries); /* output */
        break;
    
    default:
        PMC_ASSERT(NULL, COREOTN_ERR_INVALID_ARG, odu_level, 0);
        break;
    } /* end switch */
    



    PMC_RETURN(result);
} /* coreotn_odtu_dmx_trib_slot_get */


/*******************************************************************************
* FUNCTION: coreotn_odtu_dmx_int_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Obtains the correct ODTU DMX handles and trib slots for given ODU level and
*  channel number and enable interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to enable interrupts. If NULL, enables/disables
*                       all interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odtu_dmx_int_chnl_enable(coreotn_handle_t           *coreotn_handle,
                                                   coreotn_int_chnl_info_t    *chnl_info,
                                                   coreotn_int_framer_chnl_t  *int_table_ptr,
                                                   coreotn_int_framer_chnl_t  *int_en_table_ptr,
                                                   BOOL                        enable)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    odtu_dmx_handle_t          *odtu_dmx_ho_handle;
    odtu_dmx_handle_t          *odtu_dmx_lo_handle;
    odtu_dmx_int_chnl_info_t    odtu_info;
    
    PMC_ENTRY();
    
    PMC_MEMSET((void*) &odtu_info, 0, sizeof(odtu_info));
   
    /* Obtain the higher and lower order ODTU handles valid for this ODU level */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odtu_dmx_handle_get(coreotn_handle,
                                             chnl_info,
                                             &odtu_dmx_ho_handle,
                                             &odtu_dmx_lo_handle);   
    }   
   


    /* Obtain valid trib slots for lower order ODUs (MO/LO) */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odtu_dmx_trib_slot_get(coreotn_handle,
                                                chnl_info,
                                                odtu_dmx_lo_handle,
                                                &odtu_info);
    
        odtu_info.chnl_id = chnl_info->chnl_id;
    }




    int_en_table_ptr->odtu_dmx_valid = FALSE;
    /* Enable ODTU DMX lower order interrupts */
    if ((NULL != odtu_dmx_lo_handle) &&
        (PMC_SUCCESS == result))
    {
        odtu_info.higher_order = FALSE;
        int_en_table_ptr->odtu_dmx_valid = TRUE;

        result = odtu_dmx_int_chnl_enable(odtu_dmx_lo_handle,
                                          &odtu_info,
                                          &int_table_ptr->odtu_dmx,
                                          &int_en_table_ptr->odtu_dmx,
                                          enable);
    }
    
    /* Retrieve ODTU DMX higher order interrupts */
    if ((NULL != odtu_dmx_ho_handle) &&
        (PMC_SUCCESS == result))
    {
        odtu_info.higher_order = TRUE;
        int_en_table_ptr->odtu_dmx_valid = TRUE;

        result = odtu_dmx_int_chnl_enable(odtu_dmx_ho_handle,
                                          &odtu_info,
                                          &int_table_ptr->odtu_dmx,
                                          &int_en_table_ptr->odtu_dmx,
                                          enable);
    }




    PMC_RETURN(result);
} /* coreotn_odtu_dmx_int_chnl_enable */


/*******************************************************************************
* FUNCTION: coreotn_odtu_dmx_int_chnl_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Obtains the correct ODTU DMX handles and trib slots for given ODU level and
*  channel number and retrieves interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   filt_table_ptr    - pointer to filter table. Mark fields as TRUE within this
*                       table to indicate that the interrupt/status will be retrieved
*                       to the output table. NULL to retrieve all 
*                       interrupt/status.
*
* OUTPUTS:
*   int_table_ptr     - pointer to channel interrupt table for output
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odtu_dmx_int_chnl_retrieve(coreotn_handle_t           *coreotn_handle,
                                                     coreotn_int_chnl_info_t    *chnl_info,
                                                     coreotn_int_chnl_t         *filt_table_ptr,
                                                     coreotn_int_chnl_t         *int_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    odtu_dmx_handle_t          *odtu_dmx_ho_handle;
    odtu_dmx_handle_t          *odtu_dmx_lo_handle;
    odtu_dmx_int_chnl_info_t    odtu_info;
    
    PMC_ENTRY();
    
    PMC_MEMSET((void*) &odtu_info, 0, sizeof(odtu_info));
   
    /* Obtain the higher and lower order ODTU handles valid for this ODU level */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odtu_dmx_handle_get(coreotn_handle,
                                             chnl_info,
                                             &odtu_dmx_ho_handle,
                                             &odtu_dmx_lo_handle);   
    }   
   



    int_table_ptr->framer_chnl.odtu_dmx_valid = FALSE;
    odtu_info.chnl_id      = chnl_info->chnl_id;
    /* Retrieve ODTU DMX lower order interrupts */
    if ((NULL != odtu_dmx_lo_handle) &&
        (PMC_SUCCESS == result))
    {
        odtu_info.higher_order = FALSE;

        int_table_ptr->framer_chnl.odtu_dmx_valid = TRUE;

        result = odtu_dmx_int_chnl_retrieve(odtu_dmx_lo_handle,
                                            &odtu_info,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_chnl.odtu_dmx),
                                            &int_table_ptr->framer_chnl.odtu_dmx);
    }
    
    /* Retrieve ODTU DMX higher order interrupts */
    if ((NULL != odtu_dmx_ho_handle) &&
        (PMC_SUCCESS == result))
    {
        odtu_info.higher_order = TRUE;
        int_table_ptr->framer_chnl.odtu_dmx_valid = TRUE;

        result = odtu_dmx_int_chnl_retrieve(odtu_dmx_ho_handle,
                                            &odtu_info,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_chnl.odtu_dmx),
                                            &int_table_ptr->framer_chnl.odtu_dmx);
    }




    PMC_RETURN(result);
} /* coreotn_odtu_dmx_int_chnl_retrieve */


/*******************************************************************************
* FUNCTION: coreotn_odtu_dmx_int_chnl_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Obtains the correct ODTU DMX handles and trib slots for given ODU level and
*  channel number and checks for enabled interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*
* OUTPUTS:
*   int_found_ptr     - Returns TRUE if an active interrupt is found
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odtu_dmx_int_chnl_enabled_check(coreotn_handle_t           *coreotn_handle,
                                                          coreotn_int_chnl_info_t    *chnl_info,
                                                          coreotn_int_framer_chnl_t  *int_en_table_ptr,
                                                          BOOL8                      *int_found_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    odtu_dmx_handle_t          *odtu_dmx_ho_handle;
    odtu_dmx_handle_t          *odtu_dmx_lo_handle;
    odtu_dmx_int_chnl_info_t    odtu_info;
    
    PMC_ENTRY();
    
    PMC_MEMSET((void*) &odtu_info, 0, sizeof(odtu_info));
   
    /* Obtain the higher and lower order ODTU handles valid for this ODU level */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odtu_dmx_handle_get(coreotn_handle,
                                             chnl_info,
                                             &odtu_dmx_ho_handle,
                                             &odtu_dmx_lo_handle);   
    }   
   


    /* Obtain valid trib slots for lower order ODUs (MO/LO) */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odtu_dmx_trib_slot_get(coreotn_handle,
                                                chnl_info,
                                                odtu_dmx_lo_handle,
                                                &odtu_info);
    
        odtu_info.chnl_id = chnl_info->chnl_id;
    }




    /* Retrieve ODTU DMX lower order interrupts */
    if ((NULL != odtu_dmx_lo_handle) &&
        (PMC_SUCCESS == result) &&
        (FALSE == *int_found_ptr))
    {
        odtu_info.higher_order = FALSE;

        result = odtu_dmx_int_chnl_enabled_check(odtu_dmx_lo_handle,
                                                 &odtu_info,
                                                 &int_en_table_ptr->odtu_dmx,
                                                 int_found_ptr);
    }
    
    /* Retrieve ODTU DMX higher order interrupts */
    if ((NULL != odtu_dmx_ho_handle) &&
        (PMC_SUCCESS == result) &&
        (FALSE == *int_found_ptr))
    {
        odtu_info.higher_order = TRUE;

        result = odtu_dmx_int_chnl_enabled_check(odtu_dmx_ho_handle,
                                                 &odtu_info,
                                                 &int_en_table_ptr->odtu_dmx,
                                                 int_found_ptr);
    }

    PMC_RETURN(result);
} /* coreotn_odtu_dmx_int_chnl_enabled_check */

/*******************************************************************************
* FUNCTION: coreotn_odtu_mux_int_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Obtains the correct ODTU_MUX handles and trib slots for given ODU level and
*  channel number and enable interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to enable interrupts. If NULL, enables/disables
*                       all interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odtu_mux_int_chnl_enable(coreotn_handle_t           *coreotn_handle,
                                                   coreotn_int_chnl_info_t    *chnl_info,
                                                   coreotn_int_framer_chnl_t  *int_table_ptr,
                                                   coreotn_int_framer_chnl_t  *int_en_table_ptr,
                                                   BOOL                        enable)
{
    PMC_ERROR                 result = PMC_SUCCESS;
    odtu_mux_handle_t         *odtu_mux_ho_handle;
    odtu_mux_handle_t         *odtu_mux_lo_handle;
    
    PMC_ENTRY();
   
    /* Obtain the higher and lower order ODTU_MUX handles valid for this ODU level */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odtu_mux_handle_get(coreotn_handle,
                                             chnl_info,
                                             &odtu_mux_ho_handle,
                                             &odtu_mux_lo_handle);   
    }      

    int_en_table_ptr->odtu_mux_valid = FALSE;

    /* Enable ODTU_MUX lower order interrupts */
    if ((NULL != odtu_mux_lo_handle) &&
        (PMC_SUCCESS == result))
    {
        int_en_table_ptr->odtu_mux_valid = TRUE;

        result = odtu_mux_int_chnl_enable(odtu_mux_lo_handle,
                                          chnl_info->chnl_id,
                                          UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, odtu_mux),
                                          &int_en_table_ptr->odtu_mux,
                                          enable);
    }
    
    /* Retrieve ODTU_MUX higher order interrupts */
    if ((NULL != odtu_mux_ho_handle) &&
        (PMC_SUCCESS == result))
    {
        int_en_table_ptr->odtu_mux_valid = TRUE;

        result = odtu_mux_int_chnl_enable(odtu_mux_ho_handle,
                                        chnl_info->chnl_id,
                                        &int_table_ptr->odtu_mux,
                                        &int_en_table_ptr->odtu_mux,
                                        enable);
    }




    PMC_RETURN(result);
} /* coreotn_odtu_mux_int_chnl_enable */

/*******************************************************************************
* FUNCTION: coreotn_odtu_mux_int_chnl_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Clear Coreotn ODTU_MUX active interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_table_ptr     - Pointer to active interrupts table to clear
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odtu_mux_int_chnl_clear(coreotn_handle_t           *coreotn_handle,
                                                  coreotn_int_chnl_info_t    *chnl_info,
                                                  coreotn_int_framer_chnl_t  *int_table_ptr,
                                                  coreotn_int_framer_chnl_t  *int_en_table_ptr)
{
    PMC_ERROR                 result = PMC_SUCCESS;
    odtu_mux_handle_t          *odtu_mux_ho_handle;
    odtu_mux_handle_t          *odtu_mux_lo_handle;
    
    PMC_ENTRY();
    
   
    /* Obtain the higher and lower order ODTU handles valid for this ODU level */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odtu_mux_handle_get(coreotn_handle,
                                             chnl_info,
                                             &odtu_mux_ho_handle,
                                             &odtu_mux_lo_handle);   
    }   
    
    
    /* Retrieve ODTU_MUX lower order interrupts */
    if ((NULL != odtu_mux_lo_handle) &&
        (PMC_SUCCESS == result))
    {
        result = odtu_mux_int_chnl_clear(odtu_mux_lo_handle,
                                         chnl_info->chnl_id,
                                         UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, odtu_mux),
                                         UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, odtu_mux));
    }
    
    /* Retrieve ODTU_MUX higher order interrupts */
    if ((NULL != odtu_mux_ho_handle) &&
        (PMC_SUCCESS == result))
    {

        result = odtu_mux_int_chnl_clear(odtu_mux_ho_handle,
                                         chnl_info->chnl_id,
                                         UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, odtu_mux),
                                         UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, odtu_mux));
    }
    
    


    PMC_RETURN(result);
} /* coreotn_odtu_mux_int_chnl_clear */

/*******************************************************************************
* FUNCTION: coreotn_odtu_mux_int_chnl_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Obtains the correct ODTU_MUX handles and trib slots for given ODU level and
*  channel number and retrieves interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   filt_table_ptr    - pointer to filter table. Mark fields as TRUE within this
*                       table to indicate that the interrupt/status will be retrieved
*                       to the output table. NULL to retrieve all 
*                       interrupt/status.
*
* OUTPUTS:
*   int_table_ptr     - pointer to channel interrupt table for output
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odtu_mux_int_chnl_retrieve(coreotn_handle_t           *coreotn_handle,
                                                     coreotn_int_chnl_info_t    *chnl_info,
                                                     coreotn_int_chnl_t         *filt_table_ptr,
                                                     coreotn_int_chnl_t         *int_table_ptr)
{
    PMC_ERROR                 result = PMC_SUCCESS;
    odtu_mux_handle_t        *odtu_mux_ho_handle;
    odtu_mux_handle_t        *odtu_mux_lo_handle;
    
    PMC_ENTRY();
    
   
    /* Obtain the higher and lower order ODTU handles valid for this ODU level */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odtu_mux_handle_get(coreotn_handle,
                                           chnl_info,
                                           &odtu_mux_ho_handle,
                                           &odtu_mux_lo_handle);   
    }   
   

    int_table_ptr->framer_chnl.odtu_mux_valid = FALSE;

    /* Retrieve ODTU_MUX lower order interrupts */
    if ((NULL != odtu_mux_lo_handle) &&
        (PMC_SUCCESS == result))
    {
        int_table_ptr->framer_chnl.odtu_mux_valid = TRUE;

        result = odtu_mux_int_chnl_retrieve(odtu_mux_lo_handle,
                                          chnl_info->chnl_id,
                                          UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_chnl.odtu_mux),
                                          &int_table_ptr->framer_chnl.odtu_mux);
    }
    
    /* Retrieve ODTU_MUX higher order interrupts */
    if ((NULL != odtu_mux_ho_handle) &&
        (PMC_SUCCESS == result))
    {
        int_table_ptr->framer_chnl.odtu_mux_valid = TRUE;

        result = odtu_mux_int_chnl_retrieve(odtu_mux_ho_handle,
                                          chnl_info->chnl_id,
                                          UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_chnl.odtu_mux),
                                          &int_table_ptr->framer_chnl.odtu_mux);
    }
    



    PMC_RETURN(result);
} /* coreotn_odtu_mux_int_chnl_retrieve */



/*******************************************************************************
* FUNCTION: coreotn_odtu_mux_int_chnl_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Obtains the correct ODTU_MUX handles for given ODU level and
*  channel number and checks for enabled interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*
* OUTPUTS:
*   int_found_ptr     - Returns TRUE if an active interrupt is found
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odtu_mux_int_chnl_enabled_check(coreotn_handle_t           *coreotn_handle,
                                                        coreotn_int_chnl_info_t    *chnl_info,
                                                        coreotn_int_framer_chnl_t  *int_en_table_ptr,
                                                        BOOL8                      *int_found_ptr)
{
    PMC_ERROR                 result = PMC_SUCCESS;
    odtu_mux_handle_t          *odtu_mux_ho_handle;
    odtu_mux_handle_t          *odtu_mux_lo_handle;
    
    PMC_ENTRY();
    
   
    /* Obtain the higher and lower order ODTU handles valid for this ODU level */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odtu_mux_handle_get(coreotn_handle,
                                           chnl_info,
                                           &odtu_mux_ho_handle,
                                           &odtu_mux_lo_handle);   
    }   
    
    
    /* Retrieve ODTU_MUX lower order interrupts */
    if ((NULL != odtu_mux_lo_handle) &&
        (PMC_SUCCESS == result) &&
        (FALSE == *int_found_ptr))
    {
        result = odtu_mux_int_chnl_enabled_check(odtu_mux_lo_handle,
                                               chnl_info->chnl_id,
                                               UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, odtu_mux),
                                               int_found_ptr);
    }
    
    /* Retrieve ODTU_MUX higher order interrupts */
    if ((NULL != odtu_mux_ho_handle) &&
        (PMC_SUCCESS == result) &&
        (FALSE == *int_found_ptr))
    {

        result = odtu_mux_int_chnl_enabled_check(odtu_mux_ho_handle,
                                               chnl_info->chnl_id,
                                               UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, odtu_mux),
                                               int_found_ptr);
    }
    
    


    PMC_RETURN(result);
} /* coreotn_odtu_mux_int_chnl_enabled_check */

/*******************************************************************************
* FUNCTION: coreotn_oduksc_int_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Obtains the correct ODUKSC handles for given ODU level and
*  channel number and enable interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to enable interrupts. If NULL, enables/disables
*                       all interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_oduksc_int_chnl_enable(coreotn_handle_t           *coreotn_handle,
                                                 coreotn_int_chnl_info_t    *chnl_info,
                                                 coreotn_int_framer_chnl_t  *int_table_ptr,
                                                 coreotn_int_framer_chnl_t  *int_en_table_ptr,
                                                 BOOL                        enable)
{
    PMC_ERROR                 result = PMC_SUCCESS;
    oduksc_handle_t          *oduksc_ho_handle;
    oduksc_handle_t          *oduksc_lo_handle;
    
    PMC_ENTRY();
   
    /* Obtain the higher and lower order ODUKSC handles valid for this ODU level */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_oduksc_handle_get(coreotn_handle,
                                           chnl_info,
                                           &oduksc_ho_handle,
                                           &oduksc_lo_handle);   
    }   
   

    int_en_table_ptr->oduksc_valid = FALSE;

    /* Enable ODUKSC lower order interrupts */
    if ((NULL != oduksc_lo_handle) &&
        (PMC_SUCCESS == result))
    {
        int_en_table_ptr->oduksc_valid = TRUE;

        result = oduksc_int_chnl_enable(oduksc_lo_handle,
                                        chnl_info->chnl_id,
                                        &int_table_ptr->oduksc,
                                        &int_en_table_ptr->oduksc,
                                        enable);
    }
    
    /* Retrieve ODUKSC higher order interrupts */
    if ((NULL != oduksc_ho_handle) &&
        (PMC_SUCCESS == result))
    {
        int_en_table_ptr->oduksc_valid = TRUE;

        result = oduksc_int_chnl_enable(oduksc_ho_handle,
                                        chnl_info->chnl_id,
                                        &int_table_ptr->oduksc,
                                        &int_en_table_ptr->oduksc,
                                        enable);
    }




    PMC_RETURN(result);
} /* coreotn_oduksc_int_chnl_enable */

/*******************************************************************************
* FUNCTION: coreotn_oduksc_int_chnl_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Clear Coreotn ODUKSC active interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_table_ptr     - Pointer to active interrupts table to clear
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_oduksc_int_chnl_clear(coreotn_handle_t           *coreotn_handle,
                                                coreotn_int_chnl_info_t    *chnl_info,
                                                coreotn_int_framer_chnl_t  *int_table_ptr,
                                                coreotn_int_framer_chnl_t  *int_en_table_ptr)
{
    PMC_ERROR                 result = PMC_SUCCESS;
    oduksc_handle_t          *oduksc_ho_handle;
    oduksc_handle_t          *oduksc_lo_handle;
    
    PMC_ENTRY();
    
   
    /* Obtain the higher and lower order ODUKSC handles valid for this ODU level */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_oduksc_handle_get(coreotn_handle,
                                           chnl_info,
                                           &oduksc_ho_handle,
                                           &oduksc_lo_handle);   
    }   
    
    
    /* Retrieve ODUKSC lower order interrupts */
    if ((NULL != oduksc_lo_handle) &&
        (PMC_SUCCESS == result))
    {
        result = oduksc_int_chnl_clear(oduksc_lo_handle,
                                       chnl_info->chnl_id,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, oduksc),
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, oduksc));
    }
    
    /* Retrieve ODUKSC higher order interrupts */
    if ((NULL != oduksc_ho_handle) &&
        (PMC_SUCCESS == result))
    {

        result = oduksc_int_chnl_clear(oduksc_ho_handle,
                                       chnl_info->chnl_id,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, oduksc),
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, oduksc));
    }
    
    


    PMC_RETURN(result);
} /* coreotn_oduksc_int_chnl_clear */

/*******************************************************************************
* FUNCTION: coreotn_oduksc_int_chnl_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Obtains the correct ODUKSC handles for given ODU level and
*  channel number and retrieves interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   filt_table_ptr    - pointer to filter table. Mark fields as TRUE within this
*                       table to indicate that the interrupt/status will be retrieved
*                       to the output table. NULL to retrieve all 
*                       interrupt/status.
*
* OUTPUTS:
*   int_table_ptr     - pointer to channel interrupt table for output
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_oduksc_int_chnl_retrieve(coreotn_handle_t           *coreotn_handle,
                                                   coreotn_int_chnl_info_t    *chnl_info,
                                                   coreotn_int_chnl_t         *filt_table_ptr,
                                                   coreotn_int_chnl_t         *int_table_ptr)
{
    PMC_ERROR                 result = PMC_SUCCESS;
    oduksc_handle_t          *oduksc_ho_handle;
    oduksc_handle_t          *oduksc_lo_handle;
    
    PMC_ENTRY();
    
   
    /* Obtain the higher and lower order ODUKSC handles valid for this ODU level */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_oduksc_handle_get(coreotn_handle,
                                           chnl_info,
                                           &oduksc_ho_handle,
                                           &oduksc_lo_handle);   
    }   
   

    int_table_ptr->framer_chnl.oduksc_valid = FALSE;

    /* Retrieve ODUKSC lower order interrupts */
    if ((NULL != oduksc_lo_handle) &&
        (PMC_SUCCESS == result))
    {
        int_table_ptr->framer_chnl.oduksc_valid = TRUE;

        result = oduksc_int_chnl_retrieve(oduksc_lo_handle,
                                          chnl_info->chnl_id,
                                          UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_chnl.oduksc),
                                          &int_table_ptr->framer_chnl.oduksc);
    }
    
    /* Retrieve ODUKSC higher order interrupts */
    if ((NULL != oduksc_ho_handle) &&
        (PMC_SUCCESS == result))
    {
        int_table_ptr->framer_chnl.oduksc_valid = TRUE;

        result = oduksc_int_chnl_retrieve(oduksc_ho_handle,
                                          chnl_info->chnl_id,
                                          UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_chnl.oduksc),
                                          &int_table_ptr->framer_chnl.oduksc);
    }
    



    PMC_RETURN(result);
} /* coreotn_oduksc_int_chnl_retrieve */



/*******************************************************************************
* FUNCTION: coreotn_oduksc_int_chnl_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Obtains the correct ODUKSC handles for given ODU level and
*  channel number and checks for enabled interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*
* OUTPUTS:
*   int_found_ptr     - Returns TRUE if an active interrupt is found
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_oduksc_int_chnl_enabled_check(coreotn_handle_t           *coreotn_handle,
                                                        coreotn_int_chnl_info_t    *chnl_info,
                                                        coreotn_int_framer_chnl_t  *int_en_table_ptr,
                                                        BOOL8                      *int_found_ptr)
{
    PMC_ERROR                 result = PMC_SUCCESS;
    oduksc_handle_t          *oduksc_ho_handle;
    oduksc_handle_t          *oduksc_lo_handle;
    
    PMC_ENTRY();
    
   
    /* Obtain the higher and lower order ODUKSC handles valid for this ODU level */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_oduksc_handle_get(coreotn_handle,
                                           chnl_info,
                                           &oduksc_ho_handle,
                                           &oduksc_lo_handle);   
    }   
    
    
    /* Retrieve ODUKSC lower order interrupts */
    if ((NULL != oduksc_lo_handle) &&
        (PMC_SUCCESS == result) &&
        (FALSE == *int_found_ptr))
    {
        result = oduksc_int_chnl_enabled_check(oduksc_lo_handle,
                                               chnl_info->chnl_id,
                                               UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, oduksc),
                                               int_found_ptr);
    }
    
    /* Retrieve ODUKSC higher order interrupts */
    if ((NULL != oduksc_ho_handle) &&
        (PMC_SUCCESS == result) &&
        (FALSE == *int_found_ptr))
    {

        result = oduksc_int_chnl_enabled_check(oduksc_ho_handle,
                                               chnl_info->chnl_id,
                                               UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, oduksc),
                                               int_found_ptr);
    }
    
    


    PMC_RETURN(result);
} /* coreotn_oduksc_int_chnl_enabled_check */


/*******************************************************************************
* FUNCTION: coreotn_odujat_int_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Obtains the correct ODUJAT handles for given ODU level and
*  channel number and enable interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to enable interrupts. If NULL, enables/disables
*                       all interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odujat_int_chnl_enable(coreotn_handle_t           *coreotn_handle,
                                                 coreotn_int_chnl_info_t    *chnl_info,
                                                 coreotn_int_framer_chnl_t  *int_table_ptr,
                                                 coreotn_int_framer_chnl_t  *int_en_table_ptr,
                                                 BOOL                        enable)
{
    PMC_ERROR                 result = PMC_SUCCESS;
    odujat_handle_t          *odujat_ho_handle;
    odujat_handle_t          *odujat_lo_handle;
    
    PMC_ENTRY();
   
    /* Obtain the higher and lower order ODUJAT handles valid for this ODU level */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odujat_handle_get(coreotn_handle,
                                           chnl_info,
                                           &odujat_ho_handle,
                                           &odujat_lo_handle);   
    }   
   

    int_en_table_ptr->odujat_valid = FALSE;

    /* Enable ODUJAT lower order interrupts */
    if ((NULL != odujat_lo_handle) &&
        (PMC_SUCCESS == result))
    {
        int_en_table_ptr->odujat_valid = TRUE;

        result = odujat_int_chnl_enable(odujat_lo_handle,
                                        chnl_info->chnl_id,
                                        &int_table_ptr->odujat,
                                        &int_en_table_ptr->odujat,
                                        enable);
    }
    
    /* Retrieve ODUJAT higher order interrupts */
    if ((NULL != odujat_ho_handle) &&
        (PMC_SUCCESS == result))
    {
        int_en_table_ptr->odujat_valid = TRUE;

        result = odujat_int_chnl_enable(odujat_ho_handle,
                                        chnl_info->chnl_id,
                                        &int_table_ptr->odujat,
                                        &int_en_table_ptr->odujat,
                                        enable);
    }




    PMC_RETURN(result);
} /* coreotn_odujat_int_chnl_enable */

/*******************************************************************************
* FUNCTION: coreotn_odujat_int_chnl_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Clear Coreotn ODUJAT active interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_table_ptr     - Pointer to active interrupts table to clear
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odujat_int_chnl_clear(coreotn_handle_t           *coreotn_handle,
                                                coreotn_int_chnl_info_t    *chnl_info,
                                                coreotn_int_framer_chnl_t  *int_table_ptr,
                                                coreotn_int_framer_chnl_t  *int_en_table_ptr)
{
    PMC_ERROR                 result = PMC_SUCCESS;
    odujat_handle_t          *odujat_ho_handle;
    odujat_handle_t          *odujat_lo_handle;
    
    PMC_ENTRY();
    
   
    /* Obtain the higher and lower order ODUJAT handles valid for this ODU level */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odujat_handle_get(coreotn_handle,
                                           chnl_info,
                                           &odujat_ho_handle,
                                           &odujat_lo_handle);   
    }   
    
    
    /* Retrieve ODUJAT lower order interrupts */
    if ((NULL != odujat_lo_handle) &&
        (PMC_SUCCESS == result))
    {
        result = odujat_int_chnl_clear(odujat_lo_handle,
                                       chnl_info->chnl_id,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, odujat),
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, odujat));
    }
    
    /* Retrieve ODUJAT higher order interrupts */
    if ((NULL != odujat_ho_handle) &&
        (PMC_SUCCESS == result))
    {

        result = odujat_int_chnl_clear(odujat_ho_handle,
                                       chnl_info->chnl_id,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, odujat),
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, odujat));
    }
    
    


    PMC_RETURN(result);
} /* coreotn_odujat_int_chnl_clear */

/*******************************************************************************
* FUNCTION: coreotn_odujat_int_chnl_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Obtains the correct ODUJAT handles for given ODU level and
*  channel number and retrieves interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   filt_table_ptr    - pointer to filter table. Mark fields as TRUE within this
*                       table to indicate that the interrupt/status will be retrieved
*                       to the output table. NULL to retrieve all 
*                       interrupt/status.
*
* OUTPUTS:
*   int_table_ptr     - pointer to channel interrupt table for output
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odujat_int_chnl_retrieve(coreotn_handle_t           *coreotn_handle,
                                                   coreotn_int_chnl_info_t    *chnl_info,
                                                   coreotn_int_chnl_t         *filt_table_ptr,
                                                   coreotn_int_chnl_t         *int_table_ptr)
{
    PMC_ERROR                 result = PMC_SUCCESS;
    odujat_handle_t          *odujat_ho_handle;
    odujat_handle_t          *odujat_lo_handle;
    
    PMC_ENTRY();
    
   
    /* Obtain the higher and lower order ODUJAT handles valid for this ODU level */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odujat_handle_get(coreotn_handle,
                                           chnl_info,
                                           &odujat_ho_handle,
                                           &odujat_lo_handle);   
    }   
   
    int_table_ptr->framer_chnl.odujat_valid = FALSE;

    /* Retrieve ODUJAT lower order interrupts */
    if ((NULL != odujat_lo_handle) &&
        (PMC_SUCCESS == result))
    {
        int_table_ptr->framer_chnl.odujat_valid = TRUE;

        result = odujat_int_chnl_retrieve(odujat_lo_handle,
                                          chnl_info->chnl_id,
                                          UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_chnl.odujat),
                                          &int_table_ptr->framer_chnl.odujat);
    }
    
    /* Retrieve ODUJAT higher order interrupts */
    if ((NULL != odujat_ho_handle) &&
        (PMC_SUCCESS == result))
    {
        int_table_ptr->framer_chnl.odujat_valid = TRUE;

        result = odujat_int_chnl_retrieve(odujat_ho_handle,
                                          chnl_info->chnl_id,
                                          UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_chnl.odujat),
                                          &int_table_ptr->framer_chnl.odujat);
    }
    



    PMC_RETURN(result);
} /* coreotn_odujat_int_chnl_retrieve */



/*******************************************************************************
* FUNCTION: coreotn_odujat_int_chnl_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Obtains the correct ODUJAT handles for given ODU level and
*  channel number and checks for enabled interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*
* OUTPUTS:
*   int_found_ptr     - Returns TRUE if an active interrupt is found
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_odujat_int_chnl_enabled_check(coreotn_handle_t           *coreotn_handle,
                                                        coreotn_int_chnl_info_t    *chnl_info,
                                                        coreotn_int_framer_chnl_t  *int_en_table_ptr,
                                                        BOOL8                      *int_found_ptr)
{
    PMC_ERROR                 result = PMC_SUCCESS;
    odujat_handle_t          *odujat_ho_handle;
    odujat_handle_t          *odujat_lo_handle;
    
    PMC_ENTRY();
    
   
    /* Obtain the higher and lower order ODUJAT handles valid for this ODU level */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odujat_handle_get(coreotn_handle,
                                           chnl_info,
                                           &odujat_ho_handle,
                                           &odujat_lo_handle);   
    }   
    
    
    /* Retrieve ODUJAT lower order interrupts */
    if ((NULL != odujat_lo_handle) &&
        (PMC_SUCCESS == result) &&
        (FALSE == *int_found_ptr))
    {
        result = odujat_int_chnl_enabled_check(odujat_lo_handle,
                                               chnl_info->chnl_id,
                                               UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, odujat),
                                               int_found_ptr);
    }
    
    /* Retrieve ODUJAT higher order interrupts */
    if ((NULL != odujat_ho_handle) &&
        (PMC_SUCCESS == result) &&
        (FALSE == *int_found_ptr))
    {

        result = odujat_int_chnl_enabled_check(odujat_ho_handle,
                                               chnl_info->chnl_id,
                                               UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, odujat),
                                               int_found_ptr);
    }
    
    


    PMC_RETURN(result);
} /* coreotn_odujat_int_chnl_enabled_check */



/*******************************************************************************
* FUNCTION: coreotn_tcm_pid_valid_set()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Sets whether or not a given HO/MO/LO channel id's TCM PID slots contain
*   valid PID values or not.
*
*   The PID values in odu_struct_t are 8-bits, supporting the required 256
*   unique PIDs. This does not leave a slot for an invalid flag,
*   so this function tracks the PID validity in a bit array organized
*   by ODU level, channel id, and TCM PID slot.
*
* INPUTS:
*   coreotn_handle     - Pointer to coreotn handle
*   odu_level          - ODU level
*   chnl_id            - Channel id (0..95)
*   tcm_pid_slot       - TCM PID slot (0..6)
*   valid              - boolean to set if PID is valid or not
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_tcm_pid_valid_set(coreotn_handle_t        *coreotn_handle,
                                           odu_struct_odu_level_t   odu_level,
                                           UINT32                   chnl_id,
                                           UINT32                   tcm_pid_slot,
                                           BOOL                     valid)
{
    PMC_ERROR        result = PMC_SUCCESS;
    pmc_bitarray_t  *odu_ba_ptr;
    UINT32           bit_loc;

    PMC_ENTRY();


    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    if (chnl_id >= COREOTN_MAX_NUM_LO_CHNL)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    if (odu_level >= LAST_ODU_STRUCT_LEVEL)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }
    
    if (tcm_pid_slot >= ODU_STRUCT_PIDS_PER_CHNL)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }


    /*
     * HO ODU:       
     *    Channel    Chnl 0   Chnl 1   Chnl 3   ...
     *    Bitarray  [0000000][0000000][0000000] ... 
     *    Bit Loc    0     6  7    13  14   20  ...
     * 
     * MO ODU:
     *    Bitarray  [0000000][0000000][0000000] ...
     * 
     * LO ODU:
     *    Bitarray  [0000000][0000000][0000000] ...
     *
     *    ...
     */
    odu_ba_ptr = coreotn_handle->var.tcm_pid_valid[odu_level];
    bit_loc    = (chnl_id * ODU_STRUCT_PIDS_PER_CHNL) + tcm_pid_slot;


    if (TRUE == valid)
    {
        pmc_bitarray_set_bit(odu_ba_ptr, bit_loc);
    } else
    {
        pmc_bitarray_clr_bit(odu_ba_ptr, bit_loc);
    }

    PMC_RETURN(result);
} /* coreotn_tcm_pid_valid_set */


/*******************************************************************************
* FUNCTION: coreotn_is_tcm_pid_valid()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns if a TCM PID slot is valid given odu level, channel id, and tcm pid
*   slot number
*
* INPUTS:
*   coreotn_handle     - Pointer to coreotn handle
*   odu_level          - ODU level
*   chnl_id            - Channel id (0..95)
*   tcm_pid_slot       - TCM PID slot (0..6)
*
* OUTPUTS:
*
* RETURNS:
*   TRUE    - TCM PID slot is valid
*   FALSE   - TCM PID slot is not valid
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL coreotn_is_tcm_pid_valid(coreotn_handle_t        *coreotn_handle,
                                     odu_struct_odu_level_t   odu_level,
                                     UINT32                   chnl_id,
                                     UINT32                   tcm_pid_slot)
{
    pmc_bitarray_t  *odu_ba_ptr;
    UINT32           bit_loc;
    BOOL    is_bit_set;

    PMC_ENTRY();


    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    if (chnl_id >= COREOTN_MAX_NUM_LO_CHNL)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }

    if (odu_level >= LAST_ODU_STRUCT_LEVEL)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }
    
    if (tcm_pid_slot >= ODU_STRUCT_PIDS_PER_CHNL)
    {
        PMC_RETURN(COREOTN_ERR_INVALID_ARG);
    }


    odu_ba_ptr = coreotn_handle->var.tcm_pid_valid[odu_level];
    bit_loc    = (chnl_id * ODU_STRUCT_PIDS_PER_CHNL) + tcm_pid_slot;


    is_bit_set = pmc_bitarray_is_bit_set(odu_ba_ptr, bit_loc);
    PMC_RETURN(is_bit_set);

} /* coreotn_is_tcm_pid_valid */

/*******************************************************************************
* FUNCTION: coreotn_int_latch_rfrm_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*    Retrieves array of rfrm handles corresponding to desired latch type
*
* INPUTS:
*   coreotn_handle     - Pointer to coreotn handle
*   latch_defect       -  latch defect mode 
*
* OUTPUTS:
*   rfrm_array         - Array of rfrm handles
*   num_rfrm_ptr       - Number of rfrm handles in array
*
* RETURNS:
*   PMC_SUCCESS     - On success, otherwise specific error code.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_int_latch_rfrm_get(coreotn_handle_t       *coreotn_handle,
                                             coreotn_latch_defect_t  latch_defect,
                                             odu_rfrm_handle_t     **rfrm_array,
                                             UINT32                 *num_rfrm_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;
    UINT32          num_rfrm = 0;

    PMC_ENTRY();

    if (pmc_is_digi_rev_a_revision(&coreotn_handle->base) == TRUE)
    {
        PMC_ASSERT(COREOTN_LATCH_DEFECT_ALL == latch_defect, COREOTN_ERR_INVALID_ARG, 0, 0);
        rfrm_array[0] = coreotn_handle->odu_rfrm_stg1_handle;
        rfrm_array[1] = coreotn_handle->odu_rfrm_stg2_handle;
        rfrm_array[2] = coreotn_handle->odu_rfrm_stg3a_handle;
        rfrm_array[3] = coreotn_handle->odu_rfrm_stg3b_handle;
        rfrm_array[4] = coreotn_handle->odu_rfrm_stg4_handle;
        rfrm_array[5] = coreotn_handle->odu_rfrm_stgN_handle;
        *num_rfrm_ptr = 6;
    } else 
    {
        
        if (COREOTN_LATCH_DEFECT_STG4 == latch_defect ||
            COREOTN_LATCH_DEFECT_ALL  == latch_defect)
        {
            rfrm_array[num_rfrm] = coreotn_handle->odu_rfrm_stg4_handle;
            num_rfrm += 1;
        }
        if (COREOTN_LATCH_DEFECT_ODUKP == latch_defect ||
            COREOTN_LATCH_DEFECT_ALL  == latch_defect)
        {
            /* stg1 and stg3b are always there */
            rfrm_array[num_rfrm] = coreotn_handle->odu_rfrm_stg1_handle;           
            num_rfrm += 1;
            rfrm_array[num_rfrm] = coreotn_handle->odu_rfrm_stg3b_handle;           
            num_rfrm += 1;
            

            /* stg 2 is not there when we are in bypass mode*/
            if (coreotn_handle->var.init_operation != COREOTN_SS_BYPASS_MODE)
            {
                rfrm_array[num_rfrm] = coreotn_handle->odu_rfrm_stg2_handle;           
                num_rfrm += 1;                
            }
            /* stg3a */                        
            if ((coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) ||
                (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE) )
            {
                rfrm_array[num_rfrm] = coreotn_handle->odu_rfrm_stg3a_handle;           
                num_rfrm += 1;                
            }
            /* stgN */
            if ((coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE) ||
                (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE) )
            {
                rfrm_array[num_rfrm] = coreotn_handle->odu_rfrm_stgN_handle;           
                num_rfrm += 1;                
            }        
        }

        *num_rfrm_ptr = num_rfrm;
    }


    PMC_RETURN(result);
} /* coreotn_int_latch_rfrm_get */

/*******************************************************************************
* FUNCTION: coreotn_int_start()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Starts and ends ODU RFRM interrupt processing.
*   Stores active combined summary interrupts and
*   clears active combined summary interrupts.
*   
*
* INPUTS:
*   coreotn_handle     - Pointer to coreotn handle
*   latch_defect       - latch defect mode 
*   start              - TRUE for RFRM interrupt processing start,
*                        FALSE for interrupt processing end
*   clear              - Whether the ODU_RFRM should be cleared or not.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_start(coreotn_handle_t          *coreotn_handle, 
                                   coreotn_latch_defect_t     latch_defect,
                                   BOOL                       start,
                                   BOOL8                      clear)
{
    PMC_ERROR           result = PMC_SUCCESS;
    odu_rfrm_handle_t  *rfrm_handle[6];
    UINT32              i;
    UINT32              num_rfrm = 0;

    PMC_ENTRY();

    
    result = coreotn_int_latch_rfrm_get(coreotn_handle, latch_defect, rfrm_handle, &num_rfrm);



    for (i = 0; (i < num_rfrm) && (PMC_SUCCESS == result); i++)
    {
        result = odu_rfrm_int_start(rfrm_handle[i], start, clear);
    }



    PMC_RETURN(result);
} /* coreotn_int_start */


/*******************************************************************************
* FUNCTION: coreotn_int_transfer_done_clr()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Triggers a transfer of ODU_RFRM interrupt tables to the shadow registers
*   for reading by SW.
*   
*
* INPUTS:
*   coreotn_handle     - Pointer to coreotn handle
*   latch_defect       - latch defect mode 
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_transfer_done_clr(coreotn_handle_t    *coreotn_handle, 
                                               coreotn_latch_defect_t latch_defect)
{
    PMC_ERROR           result = PMC_SUCCESS;
    odu_rfrm_handle_t  *rfrm_handle[6];
    UINT32              num_rfrm = 0;
    UINT32              i;

    PMC_ENTRY();

    result = coreotn_int_latch_rfrm_get(coreotn_handle, latch_defect, rfrm_handle, &num_rfrm);

    /*called coreotn_int_transfer_enable to decide where LCLK should
    be steered towards*/
    if (pmc_is_digi_rev_a_revision(&coreotn_handle->base) == FALSE)
    {
        coreotn_int_transfer_enable(coreotn_handle,latch_defect,TRUE);
    }

    for (i = 0; (i < num_rfrm) && (PMC_SUCCESS == result); i++)
    {
        result = odu_rfrm_int_transfer_done_clr(rfrm_handle[i]);
    }
    
    PMC_RETURN(result);
} /* coreotn_int_transfer_done_clr */


/*******************************************************************************
* FUNCTION: coreotn_int_transfer_done_poll()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Polls RFRMs for completion of interrupt shadow register transfer.  
*
* INPUTS:
*   coreotn_handle     - Pointer to coreotn handle
*   latch_defect       -  latch defect mode 
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_transfer_done_poll(coreotn_handle_t *coreotn_handle, 
                                                coreotn_latch_defect_t latch_defect)
{
    PMC_ERROR           result = PMC_SUCCESS;
    odu_rfrm_handle_t  *rfrm_handle[6];
    UINT32              i;
    UINT32              num_rfrm = 0;

    PMC_ENTRY();
    
    result = coreotn_int_latch_rfrm_get(coreotn_handle, latch_defect, rfrm_handle, &num_rfrm);



    for (i = 0; (i < num_rfrm) && (PMC_SUCCESS == result); i++)
    {
        result = odu_rfrm_int_transfer_done_poll(rfrm_handle[i]);
    }

    if (pmc_is_digi_rev_a_revision(&coreotn_handle->base) == FALSE)
    {
        coreotn_int_transfer_enable(coreotn_handle,latch_defect,FALSE);
    }
    PMC_RETURN(result);
} /* coreotn_int_transfer_done_poll */

/*******************************************************************************
* FUNCTION: coreotn_int_transfer_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Triggers a transfer of ODU_RFRM interrupt tables to the shadow registers
*   for reading by SW.
*   
*
* INPUTS:
*   coreotn_handle     - Pointer to coreotn handle
*   latch_defect       - latch defect mode 
*   enable             - TRUE: enable LCLK propagation toward RFRMs\n
*                        FALSE: disanle LCLK propagation toward RFRMs\n
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_int_transfer_enable(coreotn_handle_t    *coreotn_handle, 
                                              coreotn_latch_defect_t latch_defect,
                                              BOOL8 enable)
{
    PMC_ERROR           result = PMC_SUCCESS;
    UINT32              disable_fo_spare_io_word;    
    UINT32              disable_fmf_spare_io_word;


    UINT32              fo1, fo2, fmf1, fmf2;


    PMC_ENTRY();

    /* this feature cannot be used in revA */
    PMC_ASSERT(pmc_is_digi_rev_a_revision(&coreotn_handle->base) == FALSE, COREOTN_ERR_INVALID_ARG, 0, 0);


    fo1 = coreotn_fo_field_SPARE_GPO_get(NULL,coreotn_handle,COREOTN_FO_INST_1 );        
    fo2 = coreotn_fo_field_SPARE_GPO_get(NULL,coreotn_handle,COREOTN_FO_INST_2 );        
    fmf1 = coreotn_fmf_field_SPARE_GPO_get(NULL,coreotn_handle,COREOTN_FMF_INST_1 );        
    fmf2 = coreotn_fmf_field_SPARE_GPO_get(NULL,coreotn_handle,COREOTN_FMF_INST_2 );        
    
    
    /* the default is that the LCLK defect is propagated, so we mask the stages that we don't want to sample*/
    disable_fo_spare_io_word = (TRUE == enable)?0x10:0x0;
    disable_fmf_spare_io_word = (TRUE == enable)?0x50:0x0;
    
    if (latch_defect == COREOTN_LATCH_DEFECT_STG4)
    {
        /* FO1 stg3b */
        coreotn_fo_field_SPARE_GPO_set(NULL,coreotn_handle,COREOTN_FO_INST_1,disable_fo_spare_io_word );
        /* FMF1 and 2 */        
        coreotn_fmf_field_SPARE_GPO_set(NULL,coreotn_handle,COREOTN_FMF_INST_1,disable_fmf_spare_io_word);
        coreotn_fmf_field_SPARE_GPO_set(NULL,coreotn_handle,COREOTN_FMF_INST_2,disable_fmf_spare_io_word);                       
    } else if (latch_defect == COREOTN_LATCH_DEFECT_ODUKP)
    {
        /* FO2 stage 4 */
        coreotn_fo_field_SPARE_GPO_set(NULL,coreotn_handle,COREOTN_FO_INST_2,disable_fo_spare_io_word );        
    }
       
    PMC_RETURN(result);
} /* coreotn_int_transfer_enable */

/*******************************************************************************
* FUNCTION: coreotn_int_framer_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts based on bits that are set in the 
*   channel interrupt table.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to enable interrupts. If NULL, enables/disables
*                       all interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_framer_chnl_enable(coreotn_handle_t           *coreotn_handle,
                                                coreotn_int_chnl_info_t    *chnl_info,
                                                coreotn_int_framer_chnl_t  *int_table_ptr,
                                                coreotn_int_framer_chnl_t  *int_en_table_ptr,
                                                BOOL                        enable)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    odu_rfrm_handle_t          *rfrm_handle = NULL;
    odu_tfrm_handle_t          *tfrm_handle = NULL;
    mpmo_handle_t              *mpmo_handle;
    mpma_handle_t              *mpma_handle;

    PMC_ENTRY();

    result = coreotn_int_validate(coreotn_handle, chnl_info, int_table_ptr);
    PMC_ASSERT(int_en_table_ptr != NULL, COREOTN_ERR_INVALID_ARG, 0, 0);


    if (PMC_SUCCESS == result)
    {
        result = coreotn_rfrm_handle_get(coreotn_handle,
                                         chnl_info,
                                         &rfrm_handle);   
    }   
    
    if (PMC_SUCCESS == result)
    {
        result = coreotn_tfrm_handle_get(coreotn_handle,
                                         chnl_info,
                                         &tfrm_handle);   
    }   
    
    if ((PMC_SUCCESS == result) &&
        (NULL != rfrm_handle))
    {
        result = odu_rfrm_int_chnl_enable(rfrm_handle,
                                          chnl_info->chnl_id,
                                          UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, rfrm),
                                          &int_en_table_ptr->rfrm,
                                          enable);                                 
    }
    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
    /* TFFRM */
    if ((PMC_SUCCESS == result) &&
        (NULL != tfrm_handle))
    {
        result = odu_tfrm_int_chnl_enable(tfrm_handle,
                                          chnl_info->chnl_id,
                                          UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, tfrm),
                                          &int_en_table_ptr->tfrm,
                                          enable);
    }
    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0); 
    
    /* ODUKSC */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_oduksc_int_chnl_enable(coreotn_handle,
                                                chnl_info,
                                                int_table_ptr,
                                                int_en_table_ptr,
                                                enable);
    }
    
    /* ODUJAT */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odujat_int_chnl_enable(coreotn_handle,
                                                chnl_info,
                                                int_table_ptr,
                                                int_en_table_ptr,
                                                enable);
    }
    
    /* ODTU_MUX */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odtu_mux_int_chnl_enable(coreotn_handle,
                                                  chnl_info,
                                                  int_table_ptr,
                                                  int_en_table_ptr,
                                                  enable);
    }

    /* ODTU_DMX */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_odtu_dmx_int_chnl_enable(coreotn_handle,
                                                  chnl_info,
                                                  int_table_ptr,
                                                  int_en_table_ptr,
                                                  enable);
        PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);                                           
                                                  
    }

    if (PMC_SUCCESS == result)
    {
        result = coreotn_mpma_mpmo_handle_get(coreotn_handle,
                                              chnl_info,
                                              &mpma_handle,
                                              &mpmo_handle);
        if (mpmo_handle != NULL && PMC_SUCCESS == result)
        {            
            result = mpmo_int_chnl_enable(mpmo_handle,
                                          chnl_info->chnl_id,
                                          UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, mpmo),
                                          &int_en_table_ptr->mpmo,
                                          enable);
            PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);                             
                                           
        }
        if (mpma_handle != NULL && PMC_SUCCESS == result)
        {
            result = mpma_int_chnl_enable(mpma_handle,
                                          chnl_info->chnl_id,
                                          UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, mpma),
                                          &int_en_table_ptr->mpma,
                                          enable);
            PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);                              
                                           
        }
    }

    PMC_RETURN(result);
} /* coreotn_int_framer_chnl_enable */

/*******************************************************************************
* FUNCTION: coreotn_int_ohp_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables ODU OHP interrupts based on bits that are set in the 
*   channel interrupt table.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   ohp               - Specifies the OHP block 
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to enable interrupts. If NULL, enables/disables
*                       all interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_ohp_chnl_enable(coreotn_handle_t          *coreotn_handle,
                                             odu_ohp_inst_t             ohp,
                                             coreotn_int_chnl_info_t   *chnl_info,
                                             odu_ohp_int_chnl_t        *int_table_ptr,
                                             odu_ohp_int_chnl_t        *int_en_table_ptr,
                                             BOOL                       enable)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    odu_ohp_port_framer_t       port_framer = ODU_OHP_PORT_FRAMER_1;
    UINT32              ohp_port;
    odu_ohp_handle_t           *ohp_handle_ptr;

    PMC_ENTRY();

    PMC_ASSERT(int_en_table_ptr != NULL, COREOTN_ERR_INVALID_ARG, 0, 0);

    result = coreotn_int_validate(coreotn_handle, chnl_info, int_table_ptr);

    if (PMC_SUCCESS == result)
    {
        port_framer = coreotn_odu_ohp_port_framer_get(coreotn_handle, chnl_info);

        /* Find the port with the configured framer */
        ohp_handle_ptr = coreotn_handle->odu_ohp_handle[ohp];
        for (ohp_port = (UINT32)ODU_OHP_PORT_A; ohp_port <= (UINT32)ODU_OHP_PORT_B && PMC_SUCCESS == result; ohp_port++) 
        {
            if (ohp_handle_ptr->cfg.port_cfg[ohp_port].port_framer == port_framer) 
            {
                result = odu_ohp_int_chnl_enable(ohp_handle_ptr, 
                                                 chnl_info->chnl_id,
                                                 int_table_ptr,
                                                 int_en_table_ptr,
                                                 enable);
            }
        }
    }

    PMC_RETURN(result);
} /* coreotn_int_ohp_chnl_enable */

/*******************************************************************************
* FUNCTION: coreotn_int_ri_rcp_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables ODU RI_RCP interrupts based on bits that are set in the 
*   channel interrupt table.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to enable interrupts. If NULL, enables/disables
*                       all interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_ri_rcp_chnl_enable(coreotn_handle_t           *coreotn_handle,
                                                coreotn_int_chnl_info_t    *chnl_info,
                                                odu_ri_rcp_int_chnl_t      *int_table_ptr,
                                                odu_ri_rcp_int_chnl_t      *int_en_table_ptr,
                                                BOOL                        enable)
{
    PMC_ERROR                   result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(int_en_table_ptr != NULL, COREOTN_ERR_INVALID_ARG, 0, 0);

    result = coreotn_int_validate(coreotn_handle, chnl_info, int_table_ptr);

    if (PMC_SUCCESS == result)
    {
        odu_ri_rcp_int_chnl_enable(coreotn_handle->odu_rcp_handle, 
                                   chnl_info->chnl_id,
                                   int_table_ptr,
                                   int_en_table_ptr,
                                   enable);
    }

    PMC_RETURN(result);
} /* coreotn_int_ri_rcp_chnl_enable */


/*******************************************************************************
* FUNCTION: coreotn_int_pm_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts on an ODU RFRM PM channel.
*   
*
* INPUTS:
*   coreotn_handle     - Pointer to coreotn handle
*   chnl_info_ptr      - structure describing the channel: chnl id, odu level
*                        lineotn/sysotn
*   enable             - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_pm_chnl_enable(coreotn_handle_t        *coreotn_handle,
                                            coreotn_int_chnl_info_t *chnl_info_ptr,
                                            BOOL                     enable)
{
    PMC_ERROR           result = PMC_SUCCESS;
    odu_rfrm_handle_t  *rfrm_handle = NULL;

    PMC_ENTRY();

    result = coreotn_int_validate(coreotn_handle, chnl_info_ptr, chnl_info_ptr);


    if (PMC_SUCCESS == result)
    {
        result = coreotn_rfrm_handle_get(coreotn_handle,
                                         chnl_info_ptr,
                                         &rfrm_handle);   
    }   


    if ((NULL != rfrm_handle) &&
        (PMC_SUCCESS == result))
    {

        result = odu_rfrm_int_pm_chnl_enable(rfrm_handle,
                                             chnl_info_ptr->chnl_id,
                                             enable);
    }

    PMC_RETURN(result);
} /* coreotn_int_pm_chnl_enable */



/*******************************************************************************
* FUNCTION: coreotn_int_pid_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables/disables interrupts on an ODU RFRM TCM pool id.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   chnl_info_ptr     - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_pid_chnl_enable(coreotn_handle_t           *coreotn_handle,
                                             coreotn_int_chnl_info_t    *chnl_info_ptr,
                                             BOOL                        enable)
{
    PMC_ERROR           result = PMC_SUCCESS;
    odu_rfrm_handle_t  *rfrm_handle = NULL;
    UINT32              pool_id;

    PMC_ENTRY();

    result = coreotn_int_validate(coreotn_handle, chnl_info_ptr, chnl_info_ptr);


    if (PMC_SUCCESS == result)
    {
        result = coreotn_rfrm_handle_get(coreotn_handle,
                                         chnl_info_ptr,
                                         &rfrm_handle);   
    }   


    if ((NULL != rfrm_handle) &&
        (PMC_SUCCESS == result))
    {
        pool_id = chnl_info_ptr->rx_pool_id[0];

        result = odu_rfrm_int_pid_chnl_enable(rfrm_handle,
                                              pool_id,
                                              enable);
    }


    PMC_RETURN(result);
} /* coreotn_int_pid_chnl_enable */

/*******************************************************************************
* FUNCTION: coreotn_int_pid_chnl_tbl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables TCM PID interrupts based on bits that are set in the 
*   channel interrupt table.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to enable interrupts. If NULL, enables/disables
*                       all interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_pid_chnl_tbl_enable(coreotn_handle_t           *coreotn_handle,
                                                 coreotn_int_chnl_info_t    *chnl_info,
                                                 odu_rfrm_int_pid_chnl_t    *int_table_ptr,
                                                 odu_rfrm_int_pid_chnl_t    *int_en_table_ptr,
                                                 BOOL                        enable)
{
    PMC_ERROR           result = PMC_SUCCESS;
    odu_rfrm_handle_t  *rfrm_handle = NULL;
    UINT32              pool_id;

    PMC_ENTRY();

    result = coreotn_int_validate(coreotn_handle, chnl_info, int_table_ptr);
    PMC_ASSERT(int_en_table_ptr != NULL, COREOTN_ERR_INVALID_ARG, 0, 0);


    if (PMC_SUCCESS == result)
    {
        result = coreotn_rfrm_handle_get(coreotn_handle,
                                         chnl_info,
                                         &rfrm_handle);   
    }   


    if ((NULL != rfrm_handle) &&
        (PMC_SUCCESS == result))
    {
        pool_id = chnl_info->rx_pool_id[0];

        result = odu_rfrm_int_pid_chnl_tbl_enable(rfrm_handle,
                                                  pool_id,
                                                  int_table_ptr, 
                                                  &int_en_table_ptr[pool_id],
                                                  enable);
    }


    PMC_RETURN(result);
} /* coreotn_int_pid_chnl_tbl_enable */


/*******************************************************************************
* FUNCTION: coreotn_int_defect_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables/disable specified defect.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   chnl_info_ptr     - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_defect_enable(coreotn_handle_t           *coreotn_handle,
                                           coreotn_int_chnl_info_t    *chnl_info_ptr,
                                           BOOL                        enable)
{
    PMC_ERROR           result = PMC_SUCCESS;
    odu_rfrm_handle_t  *rfrm_handle = NULL;

    PMC_ENTRY();

    result = coreotn_int_validate(coreotn_handle, chnl_info_ptr, chnl_info_ptr);


    if (PMC_SUCCESS == result)
    {
        result = coreotn_rfrm_handle_get(coreotn_handle,
                                         chnl_info_ptr,
                                         &rfrm_handle);   
    }   


    if ((NULL != rfrm_handle) &&
        (PMC_SUCCESS == result))
    {
        result = odu_rfrm_int_defect_enable(rfrm_handle,
                                            chnl_info_ptr->defect,
                                            enable);
    }


    PMC_RETURN(result);
} /* coreotn_int_defect_enable */



/*******************************************************************************
* FUNCTION: coreotn_int_prbs_chnl_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables PRBS based on bits that are set in the 
*   channel interrupt table.
*   
*
* INPUTS:
*   coreotn_handle      - Pointer to coreotn handle
*   prbs_chnl           - PRBS channel
*   prbs_inst           - PRBS instance
*   int_table_ptr       - pointer to channel interrupt table with
*                         bits set to enable interrupts.
*   int_en_table_ptr    - Pointer to table tracking enabled interrupts
*   enable              - Enable or disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_prbs_chnl_enable(coreotn_handle_t          *coreotn_handle,
                                              UINT32                     prbs_chnl,
                                              coreotn_prbs_inst_t        prbs_inst, 
                                              coreotn_int_prbs_chnl_t   *int_table_ptr,
                                              coreotn_int_prbs_chnl_t   *int_en_table_ptr,
                                              BOOL                       enable)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(prbs_chnl < COREOTN_PRBS_NUM_CHNL, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(prbs_inst < LAST_COREOTN_PRBS_INST, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(int_en_table_ptr != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);


    if ((NULL == int_table_ptr) || (TRUE == int_table_ptr->prbs_dlss_i))
    {
        int_en_table_ptr->prbs_dlss_i = enable;

        if (prbs_inst < COREOTN_FO1_PRBS)
        {
            coreotn_fmf_field_range_PRBS_DLSS_E_set(NULL, coreotn_handle, prbs_inst, prbs_chnl, prbs_chnl, enable);
        }
        else
        {
            coreotn_fo_field_range_PRBS_DLSS_E_set(NULL, coreotn_handle, prbs_inst-2, prbs_chnl, prbs_chnl, enable);
        }    
    }


    PMC_RETURN(result);
} /* coreotn_int_prbs_chnl_enable */



/*******************************************************************************
* FUNCTION: coreotn_is_prbs_prov()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks if PRBS is provisioned on a given ODU channel, and returns
*   the prbs channel and instance if it is.
*
* INPUTS:
*   coreotn_handle  - Pointer to digi handle
*   chnl_info       - structure describing the channel: chnl id, odu level
*                     lineotn/sysotn
*
* OUTPUTS:
*   prbs_chnl_ptr   - PRBS channel
*   prbs_inst_ptr   - PRBS instance
*
* RETURNS:
*   TRUE            - if PRBS is provisioned on the channel
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_is_prbs_prov(coreotn_handle_t         *coreotn_handle,
                                       coreotn_int_chnl_info_t  *chnl_info,
                                       UINT32                   *prbs_chnl_ptr,
                                       coreotn_prbs_inst_t      *prbs_inst_ptr)
{
    BOOL                    result = PMC_SUCCESS;
    UINT32                  prbs_chnl;
    coreotn_prbs_inst_t     prbs_inst;
    BOOL                    prbs_chnl_valid = FALSE;

    PMC_ENTRY();

    /* Retrieve prbs instance for this ODU channel */
    if (PMC_SUCCESS == result)
    {
        result = odu_struct_prbs_inst_get_helper(coreotn_handle,
                                                 chnl_info->odu_level,
                                                 &prbs_inst);
    }

    /* Retrieve the PRBS channel for this ODU channel */
    if (PMC_SUCCESS == result)
    {
        result = coreotn_prbs_chnl_get(coreotn_handle,
                                       prbs_inst,
                                       chnl_info->chnl_id,
                                       &prbs_chnl,
                                       &prbs_chnl_valid);
    }

    if (PMC_SUCCESS == result)
    {
        if (TRUE == prbs_chnl_valid)
        {
            *prbs_chnl_ptr = prbs_chnl;
            *prbs_inst_ptr = prbs_inst;
        }
    }

    PMC_RETURN(prbs_chnl_valid);
} /* coreotn_is_prbs_prov */



/*******************************************************************************
* FUNCTION: coreotn_int_summary_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves summary of coreotn RFRM interrupts for a given ODU level.  
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   summary_type      - Type of summary to retrieve
*
* OUTPUTS:
*   bitmask_ptr       - Pointer to active chnls/ints
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_summary_get(coreotn_handle_t              *coreotn_handle,
                                         coreotn_int_chnl_info_t       *chnl_info,
                                         odu_rfrm_int_summary_type_t    summary_type,
                                         UINT32                        *bitmask_ptr)
{
    PMC_ERROR            result = PMC_SUCCESS;
    odu_rfrm_handle_t   *rfrm_handle = NULL;

    PMC_ENTRY();
        
    result = coreotn_int_validate(coreotn_handle, chnl_info, bitmask_ptr);

    if (PMC_SUCCESS == result)
    {
        result = coreotn_rfrm_handle_get(coreotn_handle,
                                         chnl_info,
                                         &rfrm_handle);   
    }   

    if ((NULL != rfrm_handle) &&
        (PMC_SUCCESS == result))
    {
        result = odu_rfrm_int_summary_get(rfrm_handle,
                                          summary_type,
                                          bitmask_ptr);
    }

    if (NULL == rfrm_handle)
    {
        result = COREOTN_ERR_NULL_HANDLE;
    }

    PMC_RETURN(result);
} /* coreotn_int_summary_get */


/*******************************************************************************
* FUNCTION: coreotn_int_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts based on bits that are set in the 
*   channel interrupt table.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to enable interrupts. If NULL, enables/disables
*                       all interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_enable(coreotn_handle_t      *coreotn_handle,
                                    coreotn_int_t         *int_table_ptr,
                                    coreotn_int_t         *int_en_table_ptr,
                                    BOOL                   enable)
{
    PMC_ERROR                   result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_en_table_ptr != NULL, COREOTN_ERR_INVALID_ARG, 0, 0);

    
    if (PMC_SUCCESS == result)
    {
        result = coreotn_int_params_get(coreotn_handle,
                                        &int_en_table_ptr->framer_stg1.tfrm_valid,
                                        &int_en_table_ptr->framer_stg2.tfrm_valid,
                                        &int_en_table_ptr->framer_stg3a.tfrm_valid,
                                        &int_en_table_ptr->framer_stg3b.tfrm_valid,
                                        &int_en_table_ptr->framer_stgN.tfrm_valid,
                                        &int_en_table_ptr->framer_stg1.rfrm_valid,
                                        &int_en_table_ptr->framer_stg2.rfrm_valid,
                                        &int_en_table_ptr->framer_stg3a.rfrm_valid,
                                        &int_en_table_ptr->framer_stg3b.rfrm_valid,
                                        &int_en_table_ptr->framer_stgN.rfrm_valid,
                                        &int_en_table_ptr->fmf1_dmx_valid,
                                        &int_en_table_ptr->fmf2_dmx_valid,
                                        &int_en_table_ptr->fmf1_oduksc_valid,
                                        &int_en_table_ptr->fmf2_oduksc_valid,
                                        &int_en_table_ptr->fmf1_odujat_valid,
                                        &int_en_table_ptr->fmf2_odujat_valid);
    }


    /* TFRM 1 */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->framer_stg1.tfrm_valid)
    {
        result = odu_tfrm_int_enable(coreotn_handle->odu_tfrm_stg1_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg1.tfrm),
                                     &int_en_table_ptr->framer_stg1.tfrm,
                                     enable);
    }

    /* TFRM 2 */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->framer_stg2.tfrm_valid)
    {
        result = odu_tfrm_int_enable(coreotn_handle->odu_tfrm_stg2_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg2.tfrm),
                                     &int_en_table_ptr->framer_stg2.tfrm,
                                     enable);
    }

    /* TFRM 3a */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->framer_stg3a.tfrm_valid)
    {
        result = odu_tfrm_int_enable(coreotn_handle->odu_tfrm_stg3a_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg3a.tfrm),
                                     &int_en_table_ptr->framer_stg3a.tfrm,
                                     enable);
    }

    /* TFRM 3b */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->framer_stg3b.tfrm_valid)
    {
        result = odu_tfrm_int_enable(coreotn_handle->odu_tfrm_stg3b_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg3b.tfrm),
                                     &int_en_table_ptr->framer_stg3b.tfrm,
                                     enable);
    }

    /* TFRM N */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->framer_stgN.tfrm_valid)
    {
        result = odu_tfrm_int_enable(coreotn_handle->odu_tfrm_stg4_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stgN.tfrm),
                                     &int_en_table_ptr->framer_stgN.tfrm,
                                     enable);
    }


    /* RFRM 1 */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->framer_stg1.rfrm_valid)
    {
        result = odu_rfrm_int_enable(coreotn_handle->odu_rfrm_stg1_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg1.rfrm),
                                     &int_en_table_ptr->framer_stg1.rfrm,
                                     enable);
    }

    /* RFRM 2 */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->framer_stg2.rfrm_valid)
    {
        result = odu_rfrm_int_enable(coreotn_handle->odu_rfrm_stg2_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg2.rfrm),
                                     &int_en_table_ptr->framer_stg2.rfrm,
                                     enable);
    }

    /* RFRM 3a */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->framer_stg3a.rfrm_valid)
    {
        result = odu_rfrm_int_enable(coreotn_handle->odu_rfrm_stg3a_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg3a.rfrm),
                                     &int_en_table_ptr->framer_stg3a.rfrm,
                                     enable);
    }

    /* RFRM 3b */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->framer_stg3b.rfrm_valid)
    {
        result = odu_rfrm_int_enable(coreotn_handle->odu_rfrm_stg3b_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg3b.rfrm),
                                     &int_en_table_ptr->framer_stg3b.rfrm,
                                     enable);
    }

    /* RFRM N */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->framer_stgN.rfrm_valid)
    {
        result = odu_rfrm_int_enable(coreotn_handle->odu_rfrm_stg4_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stgN.rfrm),
                                     &int_en_table_ptr->framer_stgN.rfrm,
                                     enable);
    }


    /* DEMUX 1 */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->fmf1_dmx_valid)
    {
        result = odtu_dmx_int_enable(coreotn_handle->odtu_dmx1_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, fmf1_dmx),
                                     &int_en_table_ptr->fmf1_dmx,
                                     enable);
    }
    
    /* DEMUX 2 */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->fmf2_dmx_valid)
    {
        result = odtu_dmx_int_enable(coreotn_handle->odtu_dmx2_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, fmf2_dmx),
                                     &int_en_table_ptr->fmf2_dmx,
                                     enable);
    }


    /* ODUKSC 1 */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->fmf1_oduksc_valid)
    {
        result = oduksc_int_enable(coreotn_handle->oduksc1_handle,
                                   UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, fmf1_oduksc),
                                   &int_en_table_ptr->fmf1_oduksc,
                                   enable);
    }
    
    /* ODUKSC 2 */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->fmf2_oduksc_valid)
    {
        result = oduksc_int_enable(coreotn_handle->oduksc2_handle,
                                   UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, fmf2_oduksc),
                                   &int_en_table_ptr->fmf2_oduksc,
                                   enable);
    }

    /* ODUJAT 1 */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->fmf1_odujat_valid)
    {
        result = odujat_int_enable(coreotn_handle->odujat1_handle,
                                   UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, fmf1_odujat),
                                   &int_en_table_ptr->fmf1_odujat,
                                   enable);
    }
    
    /* ODUJAT 2 */
    if (PMC_SUCCESS == result && TRUE == int_en_table_ptr->fmf2_odujat_valid)
    {
        result = odujat_int_enable(coreotn_handle->odujat2_handle,
                                   UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, fmf2_odujat),
                                   &int_en_table_ptr->fmf2_odujat,
                                   enable);
    }
    
    PMC_RETURN(result);
} /* coreotn_int_enable */


/*******************************************************************************
* FUNCTION: coreotn_int_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieve interrupts based on bits that are set in the 
*   channel interrupt enable table.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   filt_table_ptr    - pointer to filter table. Mark fields as TRUE within this
*                       table to indicate that the interrupt/status will be retrieved
*                       to the output table. NULL to retrieve all 
*                       interrupt/status.
*
* OUTPUTS:
*   int_table_ptr     - pointer to channel interrupt table for output
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_retrieve(coreotn_handle_t      *coreotn_handle,
                                      coreotn_int_t         *filt_table_ptr,
                                      coreotn_int_t         *int_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_table_ptr != NULL, COREOTN_ERR_INVALID_ARG, 0, 0);

    
    if (PMC_SUCCESS == result)
    {
        result = coreotn_int_params_get(coreotn_handle,
                                        &int_table_ptr->framer_stg1.tfrm_valid,
                                        &int_table_ptr->framer_stg2.tfrm_valid,
                                        &int_table_ptr->framer_stg3a.tfrm_valid,
                                        &int_table_ptr->framer_stg3b.tfrm_valid,
                                        &int_table_ptr->framer_stgN.tfrm_valid,
                                        &int_table_ptr->framer_stg1.rfrm_valid,
                                        &int_table_ptr->framer_stg2.rfrm_valid,
                                        &int_table_ptr->framer_stg3a.rfrm_valid,
                                        &int_table_ptr->framer_stg3b.rfrm_valid,
                                        &int_table_ptr->framer_stgN.rfrm_valid,
                                        &int_table_ptr->fmf1_dmx_valid,
                                        &int_table_ptr->fmf2_dmx_valid,
                                        &int_table_ptr->fmf1_oduksc_valid,
                                        &int_table_ptr->fmf2_oduksc_valid,
                                        &int_table_ptr->fmf1_odujat_valid,
                                        &int_table_ptr->fmf2_odujat_valid);
    }


    /* TFRM 1 */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->framer_stg1.tfrm_valid)
    {
        result = odu_tfrm_int_retrieve(coreotn_handle->odu_tfrm_stg1_handle,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_stg1.tfrm),
                                       &int_table_ptr->framer_stg1.tfrm);
    }
    
    /* TFRM 2 */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->framer_stg2.tfrm_valid)
    {
        result = odu_tfrm_int_retrieve(coreotn_handle->odu_tfrm_stg2_handle,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_stg2.tfrm),
                                       &int_table_ptr->framer_stg2.tfrm);
    }
    
    /* TFRM 3a */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->framer_stg3a.tfrm_valid)
    {
        result = odu_tfrm_int_retrieve(coreotn_handle->odu_tfrm_stg3a_handle,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_stg3a.tfrm),
                                       &int_table_ptr->framer_stg3a.tfrm);
    }
    
    /* TFRM 3b */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->framer_stg3b.tfrm_valid)
    {
        result = odu_tfrm_int_retrieve(coreotn_handle->odu_tfrm_stg3b_handle,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_stg3b.tfrm),
                                       &int_table_ptr->framer_stg3b.tfrm);
    }
    
    /* TFRM N */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->framer_stgN.tfrm_valid)
    {
        result = odu_tfrm_int_retrieve(coreotn_handle->odu_tfrm_stgN_handle,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_stgN.tfrm),
                                       &int_table_ptr->framer_stgN.tfrm);
    }

    
    /* RFRM 1 */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->framer_stg1.rfrm_valid)
    {
        result = odu_rfrm_int_retrieve(coreotn_handle->odu_rfrm_stg1_handle,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_stg1.rfrm),
                                       &int_table_ptr->framer_stg1.rfrm);
    }
    
    /* RFRM 2 */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->framer_stg2.rfrm_valid)
    {
        result = odu_rfrm_int_retrieve(coreotn_handle->odu_rfrm_stg2_handle,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_stg2.rfrm),
                                       &int_table_ptr->framer_stg2.rfrm);
    }
    
    /* RFRM 3a */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->framer_stg3a.rfrm_valid)
    {
        result = odu_rfrm_int_retrieve(coreotn_handle->odu_rfrm_stg3a_handle,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_stg3a.rfrm),
                                       &int_table_ptr->framer_stg3a.rfrm);
    }
    
    /* RFRM 3b */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->framer_stg3b.rfrm_valid)
    {
        result = odu_rfrm_int_retrieve(coreotn_handle->odu_rfrm_stg3b_handle,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_stg3b.rfrm),
                                       &int_table_ptr->framer_stg3b.rfrm);
    }
    
    /* RFRM N */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->framer_stgN.rfrm_valid)
    {
        result = odu_rfrm_int_retrieve(coreotn_handle->odu_rfrm_stgN_handle,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_stgN.rfrm),
                                       &int_table_ptr->framer_stgN.rfrm);
    }

    
    /* DEMUX 1 */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->fmf1_dmx_valid)
    {
        result = odtu_dmx_int_retrieve(coreotn_handle->odtu_dmx1_handle,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, fmf1_dmx),
                                       &int_table_ptr->fmf1_dmx);
    }
    
    /* DEMUX 2 */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->fmf2_dmx_valid)
    {
        result = odtu_dmx_int_retrieve(coreotn_handle->odtu_dmx2_handle,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, fmf2_dmx),
                                       &int_table_ptr->fmf2_dmx);
    }


    /* ODUKSC 1 */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->fmf1_oduksc_valid)
    {
        result = oduksc_int_retrieve(coreotn_handle->oduksc1_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, fmf1_oduksc),
                                     &int_table_ptr->fmf1_oduksc);
    }
    
    /* ODUKSC 2 */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->fmf2_oduksc_valid)
    {
        result = oduksc_int_retrieve(coreotn_handle->oduksc2_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, fmf2_oduksc),
                                     &int_table_ptr->fmf2_oduksc);
    }

    /* ODUJAT 1 */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->fmf1_odujat_valid)
    {
        result = odujat_int_retrieve(coreotn_handle->odujat1_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, fmf1_odujat),
                                     &int_table_ptr->fmf1_odujat);
    }
    
    /* ODUJAT 2 */
    if (PMC_SUCCESS == result && TRUE == int_table_ptr->fmf2_odujat_valid)
    {
        result = odujat_int_retrieve(coreotn_handle->odujat2_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, fmf2_odujat),
                                     &int_table_ptr->fmf2_odujat);
    }
    
    PMC_RETURN(result);
} /* coreotn_int_retrieve */


/*******************************************************************************
* FUNCTION: coreotn_int_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears interrupts based on bits that are set in the 
*   channel interrupt table.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to enable interrupts. If NULL, enables/disables
*                       all interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_clear(coreotn_handle_t      *coreotn_handle,
                                   coreotn_int_t         *int_table_ptr,
                                   coreotn_int_t         *int_en_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    BOOL8 framer_stg1_tfrm_valid;
    BOOL8 framer_stg2_tfrm_valid;
    BOOL8 framer_stg3a_tfrm_valid;
    BOOL8 framer_stg3b_tfrm_valid;
    BOOL8 framer_stgN_tfrm_valid;
    BOOL8 framer_stg1_rfrm_valid;
    BOOL8 framer_stg2_rfrm_valid;
    BOOL8 framer_stg3a_rfrm_valid;
    BOOL8 framer_stg3b_rfrm_valid;
    BOOL8 framer_stgN_rfrm_valid;
    BOOL8 fmf1_dmx_valid;
    BOOL8 fmf2_dmx_valid;
    BOOL8 fmf1_oduksc_valid;
    BOOL8 fmf2_oduksc_valid;
    BOOL8 fmf1_odujat_valid;
    BOOL8 fmf2_odujat_valid;

    PMC_ENTRY();

    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);

    
    if (PMC_SUCCESS == result)
    {
        result = coreotn_int_params_get(coreotn_handle,
                                        &framer_stg1_tfrm_valid,
                                        &framer_stg2_tfrm_valid,
                                        &framer_stg3a_tfrm_valid,
                                        &framer_stg3b_tfrm_valid,
                                        &framer_stgN_tfrm_valid,
                                        &framer_stg1_rfrm_valid,
                                        &framer_stg2_rfrm_valid,
                                        &framer_stg3a_rfrm_valid,
                                        &framer_stg3b_rfrm_valid,
                                        &framer_stgN_rfrm_valid,
                                        &fmf1_dmx_valid,
                                        &fmf2_dmx_valid,
                                        &fmf1_oduksc_valid,
                                        &fmf2_oduksc_valid,
                                        &fmf1_odujat_valid,
                                        &fmf2_odujat_valid);
    }


    /* TFRM 1 */
    if (PMC_SUCCESS == result && TRUE == framer_stg1_tfrm_valid)
    {
        result = odu_tfrm_int_clear(coreotn_handle->odu_tfrm_stg1_handle,             
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg1.tfrm),
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg1.tfrm));
    }
    
    /* TFRM 2 */
    if (PMC_SUCCESS == result && TRUE == framer_stg2_tfrm_valid)
    {
        result = odu_tfrm_int_clear(coreotn_handle->odu_tfrm_stg2_handle,             
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg2.tfrm),
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg2.tfrm));
    }
    
    /* TFRM 3a */
    if (PMC_SUCCESS == result && TRUE == framer_stg3a_tfrm_valid)
    {
        result = odu_tfrm_int_clear(coreotn_handle->odu_tfrm_stg3a_handle,             
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg3a.tfrm),
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg3a.tfrm));
    }
    
    /* TFRM 3b */
    if (PMC_SUCCESS == result && TRUE == framer_stg3b_tfrm_valid)
    {
        result = odu_tfrm_int_clear(coreotn_handle->odu_tfrm_stg3b_handle,             
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg3b.tfrm),
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg3b.tfrm));
    }
    
    /* TFRM N */
    if (PMC_SUCCESS == result && TRUE == framer_stgN_tfrm_valid)
    {
        result = odu_tfrm_int_clear(coreotn_handle->odu_tfrm_stgN_handle,             
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stgN.tfrm),
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stgN.tfrm));
    }
    

    /* RFRM 1 */
    if (PMC_SUCCESS == result && TRUE == framer_stg1_rfrm_valid)
    {
        result = odu_rfrm_int_clear(coreotn_handle->odu_rfrm_stg1_handle,             
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg1.rfrm),
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg1.rfrm));
    }
    
    /* RFRM 2 */
    if (PMC_SUCCESS == result && TRUE == framer_stg2_rfrm_valid)
    {
        result = odu_rfrm_int_clear(coreotn_handle->odu_rfrm_stg2_handle,             
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg2.rfrm),
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg2.rfrm));
    }
    
    /* RFRM 3a */
    if (PMC_SUCCESS == result && TRUE == framer_stg3a_rfrm_valid)
    {
        result = odu_rfrm_int_clear(coreotn_handle->odu_rfrm_stg3a_handle,             
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg3a.rfrm),
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg3a.rfrm));
    }
    
    /* RFRM 3b */
    if (PMC_SUCCESS == result && TRUE == framer_stg3b_rfrm_valid)
    {
        result = odu_rfrm_int_clear(coreotn_handle->odu_rfrm_stg3b_handle,             
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stg3b.rfrm),
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg3b.rfrm));
    }
    
    /* RFRM N */
    if (PMC_SUCCESS == result && TRUE == framer_stgN_rfrm_valid)
    {
        result = odu_rfrm_int_clear(coreotn_handle->odu_rfrm_stgN_handle,             
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_stgN.rfrm),
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stgN.rfrm));
    }
    

    /* DEMUX 1 */
    if (PMC_SUCCESS == result && TRUE == fmf1_dmx_valid)
    {
        result = odtu_dmx_int_clear(coreotn_handle->odtu_dmx1_handle,             
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, fmf1_dmx));
    }
    
    /* DEMUX 2 */
    if (PMC_SUCCESS == result && TRUE == fmf2_dmx_valid)
    {
        result = odtu_dmx_int_clear(coreotn_handle->odtu_dmx2_handle,             
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, fmf2_dmx));
    }


    /* ODUKSC 1 */
    if (PMC_SUCCESS == result && TRUE == fmf1_oduksc_valid)
    {
        result = oduksc_int_clear(coreotn_handle->oduksc1_handle,             
                                  UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, fmf1_oduksc),
                                  UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, fmf1_oduksc));
    }
    
    /* ODUKSC 2 */
    if (PMC_SUCCESS == result && TRUE == fmf2_oduksc_valid)
    {
        result = oduksc_int_clear(coreotn_handle->oduksc2_handle,
                                  UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, fmf2_oduksc),
                                  UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, fmf2_oduksc));
    }
    
    /* ODUJAT 1 */
    if (PMC_SUCCESS == result && TRUE == fmf1_odujat_valid)
    {
        result = odujat_int_clear(coreotn_handle->odujat1_handle,
                                  UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, fmf1_odujat),
                                  UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, fmf1_odujat));
    }
    
    /* ODUJAT 2 */
    if (PMC_SUCCESS == result && TRUE == fmf2_odujat_valid)
    {
        result = odujat_int_clear(coreotn_handle->odujat2_handle,
                                  UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, fmf2_odujat),
                                  UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, fmf2_odujat));
    }    
    
    PMC_RETURN(result);
} /* coreotn_int_clear */



/*******************************************************************************
* FUNCTION: coreotn_int_enabled_check()
*______________________________________________________________________________
*
* DESCRIPTION:
*   Searches for active interrupt bits based on the enabled interrupt table.
*   
*
* INPUTS:
*   coreotn_handle          - Pointer to subsystem handle
*   int_en_table_ptr        - Pointer to table tracking enabled interrupts
*
* OUTPUTS:
*   int_found_ptr     - Returns TRUE if an active interrupt is found
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_enabled_check(coreotn_handle_t     *coreotn_handle,
                                           coreotn_int_t        *int_en_table_ptr,
                                           BOOL                 *int_found_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;
    BOOL8                        internal_int_found = FALSE;
    BOOL8 framer_stg1_tfrm_valid;
    BOOL8 framer_stg2_tfrm_valid;
    BOOL8 framer_stg3a_tfrm_valid;
    BOOL8 framer_stg3b_tfrm_valid;
    BOOL8 framer_stgN_tfrm_valid;
    BOOL8 framer_stg1_rfrm_valid;
    BOOL8 framer_stg2_rfrm_valid;
    BOOL8 framer_stg3a_rfrm_valid;
    BOOL8 framer_stg3b_rfrm_valid;
    BOOL8 framer_stgN_rfrm_valid;
    BOOL8 fmf1_dmx_valid;
    BOOL8 fmf2_dmx_valid;
    BOOL8 fmf1_oduksc_valid;
    BOOL8 fmf2_oduksc_valid;
    BOOL8 fmf1_odujat_valid;
    BOOL8 fmf2_odujat_valid;

    PMC_ENTRY();

    PMC_ASSERT(int_en_table_ptr != NULL, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(int_found_ptr != NULL, COREOTN_ERR_INVALID_ARG, 0, 0);

    internal_int_found = UTIL_GLOBAL_BOOL_TO_BOOL8_CONVERT(*int_found_ptr);


    if (PMC_SUCCESS == result)
    {
        result = coreotn_int_params_get(coreotn_handle,
                                        &framer_stg1_tfrm_valid,
                                        &framer_stg2_tfrm_valid,
                                        &framer_stg3a_tfrm_valid,
                                        &framer_stg3b_tfrm_valid,
                                        &framer_stgN_tfrm_valid,
                                        &framer_stg1_rfrm_valid,
                                        &framer_stg2_rfrm_valid,
                                        &framer_stg3a_rfrm_valid,
                                        &framer_stg3b_rfrm_valid,
                                        &framer_stgN_rfrm_valid,
                                        &fmf1_dmx_valid,
                                        &fmf2_dmx_valid,
                                        &fmf1_oduksc_valid,
                                        &fmf2_oduksc_valid,
                                        &fmf1_odujat_valid,
                                        &fmf2_odujat_valid);
    }


    /* TFRM 1 */
    if (PMC_SUCCESS == result &&
        (TRUE == framer_stg1_tfrm_valid) &&
        (FALSE == internal_int_found))
    {
        result = odu_tfrm_int_enabled_check(coreotn_handle->odu_tfrm_stg1_handle,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg1.tfrm),
                                            &internal_int_found);
    }

    /* TFRM 2 */
    if (PMC_SUCCESS == result &&
        (TRUE == framer_stg2_tfrm_valid) &&
        (FALSE == internal_int_found))
    {
        result = odu_tfrm_int_enabled_check(coreotn_handle->odu_tfrm_stg2_handle,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg2.tfrm),
                                            &internal_int_found);
    }

    /* TFRM 3a */
    if (PMC_SUCCESS == result &&
        (TRUE == framer_stg3a_tfrm_valid) &&
        (FALSE == internal_int_found))
    {
        result = odu_tfrm_int_enabled_check(coreotn_handle->odu_tfrm_stg3a_handle,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg3a.tfrm),
                                            &internal_int_found);
    }

    /* TFRM 3b */
    if (PMC_SUCCESS == result &&
        (TRUE == framer_stg3b_tfrm_valid) &&
        (FALSE == internal_int_found))
    {
        result = odu_tfrm_int_enabled_check(coreotn_handle->odu_tfrm_stg3b_handle,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg3b.tfrm),
                                            &internal_int_found);
    }

    /* TFRM N */
    if (PMC_SUCCESS == result &&
        (TRUE == framer_stgN_tfrm_valid) &&
        (FALSE == internal_int_found))
    {
        result = odu_tfrm_int_enabled_check(coreotn_handle->odu_tfrm_stgN_handle,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stgN.tfrm),
                                            &internal_int_found);
    }

    /* RFRM 1 */
    if (PMC_SUCCESS == result &&
        (TRUE == framer_stg1_rfrm_valid) &&
        (FALSE == internal_int_found))
    {
        result = odu_rfrm_int_enabled_check(coreotn_handle->odu_rfrm_stg1_handle,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg1.rfrm),
                                            &internal_int_found);
    }

    /* RFRM 2 */
    if (PMC_SUCCESS == result &&
        (TRUE == framer_stg2_rfrm_valid) &&
        (FALSE == internal_int_found))
    {
        result = odu_rfrm_int_enabled_check(coreotn_handle->odu_rfrm_stg2_handle,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg2.rfrm),
                                            &internal_int_found);
    }

    /* RFRM 3a */
    if (PMC_SUCCESS == result &&
        (TRUE == framer_stg3a_rfrm_valid) &&
        (FALSE == internal_int_found))
    {
        result = odu_rfrm_int_enabled_check(coreotn_handle->odu_rfrm_stg3a_handle,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg3a.rfrm),
                                            &internal_int_found);
    }

    /* RFRM 3b */
    if (PMC_SUCCESS == result &&
        (TRUE == framer_stg3b_rfrm_valid) &&
        (FALSE == internal_int_found))
    {
        result = odu_rfrm_int_enabled_check(coreotn_handle->odu_rfrm_stg3b_handle,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stg3b.rfrm),
                                            &internal_int_found);
    }

    /* RFRM N */
    if (PMC_SUCCESS == result &&
        (TRUE == framer_stgN_rfrm_valid) &&
        (FALSE == internal_int_found))
    {
        result = odu_rfrm_int_enabled_check(coreotn_handle->odu_rfrm_stgN_handle,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, framer_stgN.rfrm),
                                            &internal_int_found);
    }


    /* DEMUX 1 */
    if (PMC_SUCCESS == result &&
        (TRUE == fmf1_dmx_valid) &&
        (FALSE == internal_int_found))
    {
        result = odtu_dmx_int_enabled_check(coreotn_handle->odtu_dmx1_handle,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, fmf1_dmx),
                                            &internal_int_found);
    }
    
    /* DEMUX 2 */
    if (PMC_SUCCESS == result &&
        (TRUE == fmf2_dmx_valid) &&
        (FALSE == internal_int_found))
    {
        result = odtu_dmx_int_enabled_check(coreotn_handle->odtu_dmx2_handle,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, fmf2_dmx),
                                            &internal_int_found);
    }


    /* ODUKSC 1 */
    if (PMC_SUCCESS == result &&
        (TRUE == fmf1_oduksc_valid) &&
        (FALSE == internal_int_found))
    {
        result = oduksc_int_enabled_check(coreotn_handle->oduksc1_handle,
                                          UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, fmf1_oduksc),
                                          &internal_int_found);
    }

    /* ODUKSC 2 */
    if (PMC_SUCCESS == result &&
        (TRUE == fmf2_oduksc_valid) &&
        (FALSE == internal_int_found))
    {
        result = oduksc_int_enabled_check(coreotn_handle->oduksc2_handle,
                                          UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, fmf2_oduksc),
                                          &internal_int_found);
    }

    /* ODUJAT 1 */
    if (PMC_SUCCESS == result &&
        (TRUE == fmf1_odujat_valid) &&
        (FALSE == internal_int_found))
    {
        result = odujat_int_enabled_check(coreotn_handle->odujat1_handle,
                                          UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, fmf1_odujat),
                                          &internal_int_found);
    }

    /* ODUJAT 2 */
    if (PMC_SUCCESS == result &&
        (TRUE == fmf2_odujat_valid) &&
        (FALSE == internal_int_found))
    {
        result = odujat_int_enabled_check(coreotn_handle->odujat2_handle,
                                          UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_en_table_ptr, fmf2_odujat),
                                          &internal_int_found);
    }

    *int_found_ptr = UTIL_GLOBAL_BOOL8_TO_BOOL_CONVERT(internal_int_found);

    PMC_RETURN(result);
} /* coreotn_int_enabled_check */



/*******************************************************************************
* FUNCTION: coreotn_fo2_int_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables interrupts based on bits that are set in the 
*   channel interrupt table.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to enable interrupts. If NULL, enables/disables
*                       all interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_fo2_int_enable(coreotn_handle_t      *coreotn_handle,
                                        coreotn_int_framer_t  *int_table_ptr,
                                        coreotn_int_framer_t  *int_en_table_ptr,
                                        BOOL                   enable)
{
    PMC_ERROR                   result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_en_table_ptr != NULL, COREOTN_ERR_INVALID_ARG, 0, 0);


    /* TFRM 4 */
    if (PMC_SUCCESS == result)
    {
        result = odu_tfrm_int_enable(coreotn_handle->odu_tfrm_stg4_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, tfrm),
                                     &int_en_table_ptr->tfrm,
                                     enable);
        int_en_table_ptr->tfrm_valid = TRUE;
    }

    /* RFRM 4 */
    if (PMC_SUCCESS == result)
    {
        result = odu_rfrm_int_enable(coreotn_handle->odu_rfrm_stg4_handle,
                                     UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, rfrm),
                                     &int_en_table_ptr->rfrm,
                                     enable);
        int_en_table_ptr->rfrm_valid = TRUE;
    }

    PMC_RETURN(result);
} /* coreotn_fo2_int_enable */


/*******************************************************************************
* FUNCTION: coreotn_fo2_int_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieve interrupts based on bits that are set in the 
*   channel interrupt enable table.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   filt_table_ptr    - pointer to filter table. Mark fields as TRUE within this
*                       table to indicate that the interrupt/status will be retrieved
*                       to the output table. NULL to retrieve all 
*                       interrupt/status.
*
* OUTPUTS:
*   int_table_ptr     - pointer to channel interrupt table for output
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_fo2_int_retrieve(coreotn_handle_t      *coreotn_handle,
                                          coreotn_int_framer_t  *filt_table_ptr,
                                          coreotn_int_framer_t  *int_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_table_ptr != NULL, COREOTN_ERR_INVALID_ARG, 0, 0);


    /* TFRM 4 */
    if (PMC_SUCCESS == result)
    {
        result = odu_tfrm_int_retrieve(coreotn_handle->odu_tfrm_stg4_handle,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, tfrm),
                                       &int_table_ptr->tfrm);
        int_table_ptr->tfrm_valid = TRUE;
    }

    /* RFRM 4 */
    if (PMC_SUCCESS == result)
    {
        result = odu_rfrm_int_retrieve(coreotn_handle->odu_rfrm_stg4_handle,
                                       UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, rfrm),
                                       &int_table_ptr->rfrm);
        int_table_ptr->rfrm_valid = TRUE;
    }

    PMC_RETURN(result);
} /* coreotn_fo2_int_retrieve */


/*******************************************************************************
* FUNCTION: coreotn_fo2_int_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears interrupts based on bits that are set in the 
*   channel interrupt table.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to enable interrupts. If NULL, enables/disables
*                       all interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_fo2_int_clear(coreotn_handle_t      *coreotn_handle,
                                       coreotn_int_framer_t  *int_table_ptr,
                                       coreotn_int_framer_t  *int_en_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);


    /* TFRM 4 */
    if (PMC_SUCCESS == result)
    {
        result = odu_tfrm_int_clear(coreotn_handle->odu_tfrm_stg4_handle,             
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, tfrm),
                                    &int_en_table_ptr->tfrm);
    }
    
    /* RFRM 4 */
    if (PMC_SUCCESS == result)
    {
        result = odu_rfrm_int_clear(coreotn_handle->odu_rfrm_stg4_handle,             
                                    UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, rfrm),
                                    &int_en_table_ptr->rfrm);
    }
    
    PMC_RETURN(result);
} /* coreotn_fo2_int_clear */



/*******************************************************************************
* FUNCTION: coreotn_fo2_int_enabled_check()
*______________________________________________________________________________
*
* DESCRIPTION:
*   Searches for active interrupt bits based on the enabled interrupt table.
*   
*
* INPUTS:
*   coreotn_handle          - Pointer to subsystem handle
*   int_en_table_ptr        - Pointer to table tracking enabled interrupts
*
* OUTPUTS:
*   int_found_ptr     - Returns TRUE if an active interrupt is found
*
* RETURNS:
*   PMC_SUCCESS     - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_fo2_int_enabled_check(coreotn_handle_t     *coreotn_handle,
                                               coreotn_int_framer_t *int_en_table_ptr,
                                               BOOL                 *int_found_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;
    BOOL8                        internal_int_found = FALSE;

    PMC_ENTRY();

    PMC_ASSERT(int_en_table_ptr != NULL, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(int_found_ptr != NULL, COREOTN_ERR_INVALID_ARG, 0, 0);

    internal_int_found = UTIL_GLOBAL_BOOL_TO_BOOL8_CONVERT(*int_found_ptr);

    /* TFRM 4 */
    if (PMC_SUCCESS == result &&
        (FALSE == internal_int_found))
    {
        result = odu_tfrm_int_enabled_check(coreotn_handle->odu_tfrm_stg4_handle,
                                            &int_en_table_ptr->tfrm,
                                            &internal_int_found);
    }

    /* RFRM 4 */
    if (PMC_SUCCESS == result &&
        (FALSE == internal_int_found))
    {
        result = odu_rfrm_int_enabled_check(coreotn_handle->odu_rfrm_stg4_handle,
                                            &int_en_table_ptr->rfrm,
                                            &internal_int_found);
    }


    *int_found_ptr = UTIL_GLOBAL_BOOL8_TO_BOOL_CONVERT(internal_int_found);

    PMC_RETURN(result);
} /* coreotn_fo2_int_enabled_check */



/*******************************************************************************
*  coreotn_odukp_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Configures COREOTN subsystem at a block level to provide or remove the
*   ability to perform channel level configuration.
*   This function include the configuration of FMF1/FMF2,FO1 and 
*   MPMA/MPMO in COREOTN_CTL.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*
* OUTPUTS:
*   stg1_tfrm_en        - TRUE: STG1 TFRM is active and interrupts are valid
*   stg2_tfrm_en        - TRUE: STG2 TFRM is active and interrupts are valid
*   stg3a_tfrm_en       - TRUE: STG3A TFRM is active and interrupts are valid
*   stg3b_tfrm_en       - TRUE: STG3B TFRM is active and interrupts are valid
*   stgN_tfrm_en        - TRUE: STGN TFRM is active and interrupts are valid
*   stg1_rfrm_en        - TRUE: STG1 RFRM is active and interrupts are valid
*   stg2_rfrm_en        - TRUE: STG2 RFRM is active and interrupts are valid
*   stg3a_rfrm_en       - TRUE: STG3A RFRM is active and interrupts are valid
*   stg3b_rfrm_en       - TRUE: STG3B RFRM is active and interrupts are valid
*   stgN_rfrm_en        - TRUE: STGN RFRM is active and interrupts are valid
*   fo1_dmx_en          - TRUE: FO1 DEMUX is active and interrupts are valid
*   fo2_dmx_en          - TRUE: FO2 DEMUX is active and interrupts are valid
*   fo1_oduksc_en       - TRUE: FO1 ODUKSC is active and interrupts are valid
*   fo2_oduksc_en       - TRUE: FO2 ODUKSC is active and interrupts are valid
*   fo1_odujat_en       - TRUE: FO1 ODUJAT is active and interrupts are valid
*   fo2_odujat_en       - TRUE: FO2 ODUJAT is active and interrupts are valid
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_int_params_get(coreotn_handle_t *coreotn_handle,
                                         BOOL8            *stg1_tfrm_en,
                                         BOOL8            *stg2_tfrm_en,
                                         BOOL8            *stg3a_tfrm_en,
                                         BOOL8            *stg3b_tfrm_en,
                                         BOOL8            *stgN_tfrm_en,
                                         BOOL8            *stg1_rfrm_en,
                                         BOOL8            *stg2_rfrm_en,
                                         BOOL8            *stg3a_rfrm_en,
                                         BOOL8            *stg3b_rfrm_en,
                                         BOOL8            *stgN_rfrm_en,
                                         BOOL8            *fo1_dmx_en,
                                         BOOL8            *fo2_dmx_en,
                                         BOOL8            *fo1_oduksc_en,
                                         BOOL8            *fo2_oduksc_en,
                                         BOOL8            *fo1_odujat_en,
                                         BOOL8            *fo2_odujat_en)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();
    
    switch (coreotn_handle->var.init_operation)
    {
    case COREOTN_SS_OPERATIONAL_MODE:
        /*
        ** FMF1
        */
        *stg1_tfrm_en = TRUE;
        *stg1_rfrm_en = TRUE;
        *stg2_tfrm_en = TRUE;
        *stg2_rfrm_en = TRUE;
        *fo1_dmx_en = TRUE;
        *fo1_oduksc_en = TRUE;
        *fo1_odujat_en = TRUE;

        /* 
        ** FMF2 
        */
        *stgN_tfrm_en = FALSE;
        *stgN_rfrm_en = FALSE;
        *stg3a_tfrm_en = TRUE;
        *stg3a_rfrm_en = TRUE;
        *fo2_dmx_en = TRUE;
        *fo2_oduksc_en = TRUE;
        *fo2_odujat_en = TRUE;

        /*
        ** FO1
        */
        *stg3b_tfrm_en = TRUE;
        *stg3b_rfrm_en = TRUE;
        break;

    case COREOTN_SS_ONE_STAGE_MUXING_MODE:
        /*
        ** FMF1
        */
        *stg1_tfrm_en = TRUE;
        *stg1_rfrm_en = TRUE;
        *stg2_tfrm_en = TRUE;
        *stg2_rfrm_en = TRUE;
        *fo1_dmx_en = TRUE;
        *fo1_oduksc_en = TRUE;
        *fo1_odujat_en = TRUE;

        /* 
        ** FMF2 
        */
        *stgN_tfrm_en = FALSE;
        *stgN_rfrm_en = FALSE;
        *stg3a_tfrm_en = FALSE;
        *stg3a_rfrm_en = FALSE;
        *fo2_dmx_en = FALSE;
        *fo2_oduksc_en = FALSE;
        *fo2_odujat_en = FALSE;

        /*
        ** FO1
        */
        *stg3b_tfrm_en = TRUE;
        *stg3b_rfrm_en = TRUE;
        break;

    case COREOTN_SS_SYSOTN_MODE:
        /*
        ** FMF1
        */
        *stg1_tfrm_en = TRUE;
        *stg1_rfrm_en = TRUE;
        *stg2_tfrm_en = TRUE;
        *stg2_rfrm_en = TRUE;
        *fo1_dmx_en = FALSE;
        *fo1_oduksc_en = FALSE;
        *fo1_odujat_en = FALSE;

        /* 
        ** FMF2 
        */
        *stgN_tfrm_en = TRUE;
        *stgN_rfrm_en = TRUE;
        *stg3a_tfrm_en = TRUE;
        *stg3a_rfrm_en = TRUE;
        *fo2_dmx_en = TRUE;
        *fo2_oduksc_en = TRUE;
        *fo2_odujat_en = TRUE;

        /*
        ** FO1
        */
        *stg3b_tfrm_en = TRUE;
        *stg3b_rfrm_en = TRUE;
        break;

    case COREOTN_SS_SYSOTN_BYPASS_MODE:
        /*
        ** FMF1
        */
        *stg1_tfrm_en = TRUE;
        *stg1_rfrm_en = TRUE;
        *stg2_tfrm_en = TRUE;
        *stg2_rfrm_en = TRUE;
        *fo1_dmx_en = FALSE;
        *fo1_oduksc_en = FALSE;
        *fo1_odujat_en = FALSE;

        /* 
        ** FMF2 
        */
        *stgN_tfrm_en = TRUE;
        *stgN_rfrm_en = TRUE;
        *stg3a_tfrm_en = FALSE;
        *stg3a_rfrm_en = FALSE;
        *fo2_dmx_en = FALSE;
        *fo2_oduksc_en = FALSE;
        *fo2_odujat_en = FALSE;

        /*
        ** FO1
        */
        *stg3b_tfrm_en = TRUE;
        *stg3b_rfrm_en = TRUE;
        break;

    case COREOTN_SS_BYPASS_MODE:
        /*
        ** FMF1
        */
        *stg1_tfrm_en = TRUE;
        *stg1_rfrm_en = TRUE;
        *stg2_tfrm_en = FALSE;
        *stg2_rfrm_en = FALSE;
        *fo1_dmx_en = FALSE;
        *fo1_oduksc_en = FALSE;
        *fo1_odujat_en = FALSE;

        /* 
        ** FMF2 
        */
        *stgN_tfrm_en = FALSE;
        *stgN_rfrm_en = FALSE;
        *stg3a_tfrm_en = FALSE;
        *stg3a_rfrm_en = FALSE;
        *fo2_dmx_en = FALSE;
        *fo2_oduksc_en = FALSE;
        *fo2_odujat_en = FALSE;

        /*
        ** FO1
        */
        *stg3b_tfrm_en = TRUE;
        *stg3b_rfrm_en = TRUE;
        break;

    default:
        /*
        ** FMF1
        */
        *stg1_tfrm_en = FALSE;
        *stg1_rfrm_en = FALSE;
        *stg2_tfrm_en = FALSE;
        *stg2_rfrm_en = FALSE;
        *fo1_dmx_en = FALSE;
        *fo1_oduksc_en = FALSE;
        *fo1_odujat_en = FALSE;

        /* 
        ** FMF2 
        */
        *stgN_tfrm_en = FALSE;
        *stgN_rfrm_en = FALSE;
        *stg3a_tfrm_en = FALSE;
        *stg3a_rfrm_en = FALSE;
        *fo2_dmx_en = FALSE;
        *fo2_oduksc_en = FALSE;
        *fo2_odujat_en = FALSE;

        /*
        ** FO1
        */
        *stg3b_tfrm_en = FALSE;
        *stg3b_rfrm_en = FALSE;
        break;
    }
    
    PMC_RETURN(result);
} /* coreotn_int_params_get */



/*******************************************************************************
* FUNCTION: coreotn_int_filt_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks if a block is set in the filter mask
*
* INPUTS:
*   filter_mask     - Bitmask indicating blocks to retrieve
*   block           - Block enum to check if in filter_mask
*
* OUTPUTS:
*
* RETURNS:
*   TRUE            - if filter mask contains desired block
*   FALSE           - if filter mask does not contain desired block
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL coreotn_int_filt_check(UINT32                          filter_mask,
                                   coreotn_int_filter_blocks_t     block)
{
    BOOL block_set;
    PMC_ENTRY();

    if (block & filter_mask)
    {
        block_set = TRUE;
    }
    else
    {
        block_set = FALSE;
    }

    PMC_RETURN(block_set);

} /* coreotn_int_filt_check */






/*******************************************************************************
* FUNCTION: coreotn_int_chnl_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves channel interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   filt_table_ptr    - pointer to filter table. Mark fields as TRUE within this
*                       table to indicate that the interrupt/status will be retrieved
*                       to the output table. NULL to retrieve all 
*                       interrupt/status.
*
* OUTPUTS:
*   int_table_ptr     - pointer to channel interrupt table for output
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_chnl_retrieve(coreotn_handle_t           *coreotn_handle,
                                           coreotn_int_chnl_info_t    *chnl_info,
                                           coreotn_int_chnl_t         *filt_table_ptr,
                                           coreotn_int_chnl_t         *int_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    odu_rfrm_handle_t          *rfrm_handle = NULL;
    odu_tfrm_handle_t          *tfrm_handle = NULL;
    UINT32                      prbs_chnl;
    coreotn_prbs_inst_t         prbs_inst;
    mpmo_handle_t              *mpmo_handle;
    mpma_handle_t              *mpma_handle;
    odu_ohp_port_framer_t       port_framer = ODU_OHP_PORT_FRAMER_1;
    odu_ohp_inst_t              ohp;
    odu_ohp_port_t              ohp_port;
    odu_ohp_handle_t           *ohp_handle_ptr = NULL;

    PMC_ENTRY();

    result = coreotn_int_validate(coreotn_handle, chnl_info, int_table_ptr);



    if (PMC_SUCCESS == result)
    {
        result = coreotn_rfrm_handle_get(coreotn_handle,
                                         chnl_info,
                                         &rfrm_handle);   
    }   

    if (PMC_SUCCESS == result)
    {
        result = coreotn_tfrm_handle_get(coreotn_handle,
                                         chnl_info,
                                         &tfrm_handle);   
    }       

    /* RFRM */
    if ((NULL != rfrm_handle) &&
        (PMC_SUCCESS == result))
    {     
        int_table_ptr->framer_chnl.rfrm_valid = TRUE;   
        result = odu_rfrm_int_chnl_retrieve(rfrm_handle,
                                            chnl_info->chnl_id,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_chnl.rfrm),
                                            &int_table_ptr->framer_chnl.rfrm);
    }
    
    /* RFRM tcm-related */
    if ((NULL != rfrm_handle) &&
        (PMC_SUCCESS == result))
    {
        result = odu_rfrm_int_pid_chnl_retrieve(rfrm_handle,
                                                chnl_info->chnl_id,
                                                chnl_info->rx_pool_id,
                                                UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, pid.rx_tcm[0]),
                                                (UINT32 *)int_table_ptr->pid.rx_tcm_pool_ids,
                                                int_table_ptr->pid.rx_tcm);
    }
  
    /* TFRM */
    if ((NULL != tfrm_handle) &&
        (PMC_SUCCESS == result) &&
        (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_TFRM)))
    {
        int_table_ptr->framer_chnl.tfrm_valid = TRUE;   
        result = odu_tfrm_int_chnl_retrieve(tfrm_handle,
                                            chnl_info->chnl_id,
                                            UTIL_GLOBAL_INT_SAFE_GET_OFFSET(filt_table_ptr, framer_chnl.tfrm),
                                            &int_table_ptr->framer_chnl.tfrm);
    }
    

    /* ODUKSC */
    if ((PMC_SUCCESS == result) &&
        (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_ODUKSC)))
    {
        result = coreotn_oduksc_int_chnl_retrieve(coreotn_handle,
                                                  chnl_info,
                                                  filt_table_ptr,
                                                  int_table_ptr);
    }

    /* ODUJAT */
    if ((PMC_SUCCESS == result) &&
        (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_ODUJAT)))
    {
        result = coreotn_odujat_int_chnl_retrieve(coreotn_handle,
                                                  chnl_info,
                                                  filt_table_ptr,
                                                  int_table_ptr);
    }

    /* ODTU_MUX */
    if ((PMC_SUCCESS == result) &&
        (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_ODTU_MUX)))
    {
        result = coreotn_odtu_mux_int_chnl_retrieve(coreotn_handle,
                                                    chnl_info,
                                                    filt_table_ptr,
                                                    int_table_ptr);
    }
        
    /* ODTU_DMX */
    if ((PMC_SUCCESS == result) &&
        (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_ODTU_DMX)))
    {
        result = coreotn_odtu_dmx_int_chnl_retrieve(coreotn_handle,
                                                    chnl_info,
                                                    filt_table_ptr,
                                                    int_table_ptr);
    }

    if ((PMC_SUCCESS == result) &&
        (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_PRBS)) &&
        (coreotn_is_prbs_prov(coreotn_handle, chnl_info, &prbs_chnl, &prbs_inst)))
    {
        int_table_ptr->prbs_valid = TRUE;
        result = coreotn_int_prbs_chnl_retrieve(coreotn_handle,
                                                prbs_chnl,
                                                prbs_inst,
                                                &int_table_ptr->prbs);
    }

    if (PMC_SUCCESS == result)
    {
        result = coreotn_mpma_mpmo_handle_get(coreotn_handle,
                                              chnl_info,
                                              &mpma_handle,
                                              &mpmo_handle);
        if ((mpmo_handle != NULL) &&
            (PMC_SUCCESS == result) &&
            (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_MPMO)))
        {            
            int_table_ptr->framer_chnl.mpmo_valid = TRUE;
            result = mpmo_int_chnl_retrieve(mpmo_handle,
                                            chnl_info->chnl_id,
                                            NULL,
                                            &int_table_ptr->framer_chnl.mpmo);
        }
        
        if ((mpma_handle != NULL) &&
            (PMC_SUCCESS == result) &&
            (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_MPMA)))
        {
            int_table_ptr->framer_chnl.mpma_valid = TRUE;
            result = mpma_int_chnl_retrieve(mpma_handle,
                                            chnl_info->chnl_id,
                                            NULL,
                                            &int_table_ptr->framer_chnl.mpma);
        }
    }

    /* retrieve OHPs channelized interrupts */
    if ((PMC_SUCCESS == result) &&
        (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_OHP)))
    {
        port_framer = coreotn_odu_ohp_port_framer_get(coreotn_handle, chnl_info);

        if (ODU_OHP_PORT_FRAMER_LAST > port_framer)
        {
            /* Find the port with the configured framer */
            for(ohp = ODU_OHP_1; ohp <= ODU_OHP_3; ohp = (odu_ohp_inst_t)((UINT32)ohp + 1))
            {
                ohp_handle_ptr = coreotn_handle->odu_ohp_handle[ohp];
                for (ohp_port = ODU_OHP_PORT_A; ohp_port <= ODU_OHP_PORT_B;ohp_port = (odu_ohp_port_t)((UINT32)ohp_port + 1)) 
                {
                    if (ohp_handle_ptr->cfg.port_cfg[ohp_port].port_framer == port_framer) 
                    {
                        odu_ohp_int_chnl_retrieve(ohp_handle_ptr, 
                                                  chnl_info->chnl_id,
                                                  NULL == filt_table_ptr ? NULL : &filt_table_ptr->ohp_chnl[(UINT32)ohp],
                                                  &int_table_ptr->ohp_chnl[(UINT32)ohp]);
                    }
                }
            }
        }
    }

    /* retrieve RI RCP channelized interrupts */
    if ((PMC_SUCCESS == result) &&
        (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_RCP)))
    {
        odu_ri_rcp_int_chnl_retrieve(coreotn_handle->odu_rcp_handle,
                                     chnl_info->chnl_id,
                                     NULL == filt_table_ptr ? NULL : &filt_table_ptr->ri_rcp_chnl,
                                     &int_table_ptr->ri_rcp_chnl);
    }
    
    PMC_RETURN(result);
} /* coreotn_int_chnl_retrieve */

/*******************************************************************************
* FUNCTION: coreotn_int_ohp_chnl_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves OHP channelized interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle         
*   ohp               - Specifies which OHP block (see odu_ohp_inst_t)
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   filt_table_ptr    - pointer to filter table. Mark fields as TRUE within this
*                       table to indicate that the interrupt/status will be retrieved
*                       to the output table. NULL to retrieve all 
*                       interrupt/status.
*
* OUTPUTS:
*   int_table_ptr     - pointer to channel interrupt table for output
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_ohp_chnl_retrieve(coreotn_handle_t           *coreotn_handle,
                                               odu_ohp_inst_t              ohp,
                                               coreotn_int_chnl_info_t    *chnl_info,
                                               odu_ohp_int_chnl_t         *filt_table_ptr,
                                               odu_ohp_int_chnl_t         *int_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    odu_ohp_port_framer_t       port_framer = ODU_OHP_PORT_FRAMER_1;
    odu_ohp_port_t              ohp_port;
    odu_ohp_handle_t           *ohp_handle_ptr;

    PMC_ENTRY();

    if (ODU_OHP_LAST  <= ohp)
    {
        result = COREOTN_ERR_INVALID_ARG;
    }

    if (PMC_SUCCESS == result)
    {

        port_framer = coreotn_odu_ohp_port_framer_get(coreotn_handle, chnl_info);
        
        if (ODU_OHP_PORT_FRAMER_LAST > port_framer)
        {
            /* Find the port with the configured framer */
            ohp_handle_ptr = coreotn_handle->odu_ohp_handle[ohp];
            for (ohp_port = ODU_OHP_PORT_A; ohp_port <= ODU_OHP_PORT_B;ohp_port = (odu_ohp_port_t)((UINT32)ohp_port + 1)) 
            {
                if (ohp_handle_ptr->cfg.port_cfg[ohp_port].port_framer == port_framer) 
                {
                    odu_ohp_int_chnl_retrieve(ohp_handle_ptr, 
                                              chnl_info->chnl_id,
                                              filt_table_ptr,
                                              int_table_ptr);
                }
            }
        }
    }
    
    PMC_RETURN(result);
} /* coreotn_int_ohp_chnl_retrieve */

/*******************************************************************************
* FUNCTION: coreotn_int_ri_rcp_chnl_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves ODU RI_RCP channelized interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle         
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   filt_table_ptr    - pointer to filter table. Mark fields as TRUE within this
*                       table to indicate that the interrupt/status will be retrieved
*                       to the output table. NULL to retrieve all 
*                       interrupt/status.
*
* OUTPUTS:
*   int_table_ptr     - pointer to channel interrupt table for output
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_ri_rcp_chnl_retrieve(coreotn_handle_t           *coreotn_handle,
                                                  coreotn_int_chnl_info_t    *chnl_info,
                                                  odu_ri_rcp_int_chnl_t      *filt_table_ptr,
                                                  odu_ri_rcp_int_chnl_t      *int_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;

    PMC_ENTRY();

    result = odu_ri_rcp_int_chnl_retrieve(coreotn_handle->odu_rcp_handle, 
                                          chnl_info->chnl_id,
                                          filt_table_ptr,
                                          int_table_ptr);

    PMC_RETURN(result);
} /* coreotn_int_ri_rcp_chnl_retrieve */

/*******************************************************************************
* FUNCTION: coreotn_int_ohp_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves OHP unchannelized interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   ohp               - Specifies which OHP block (see odu_ohp_inst_t)
*   filt_table_ptr    - pointer to filter table. Mark fields as TRUE within this
*                       table to indicate that the interrupt/status will be retrieved
*                       to the output table. NULL to retrieve all 
*                       interrupt/status.
*
* OUTPUTS:
*   int_table_ptr     - pointer to channel interrupt table for output
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_ohp_retrieve(coreotn_handle_t           *coreotn_handle,
                                          odu_ohp_inst_t              ohp,
                                          odu_ohp_int_t              *filt_table_ptr,
                                          odu_ohp_int_t              *int_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    odu_ohp_handle_t           *ohp_handle_ptr;

    PMC_ENTRY();

    if (ODU_OHP_LAST  <= ohp)
    {
        result = COREOTN_ERR_INVALID_ARG;
    }

    if (PMC_SUCCESS == result)
    {
        /* Find the port with the configured framer */
        ohp_handle_ptr = coreotn_handle->odu_ohp_handle[ohp];
        odu_ohp_int_retrieve(ohp_handle_ptr, 
                             filt_table_ptr,
                             int_table_ptr);
    }
    
    PMC_RETURN(result);
} /* coreotn_int_ohp_retrieve */


/*******************************************************************************
* FUNCTION: coreotn_int_ohp_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables/Disables OHP block unchannelized interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handlechannel
*   ohp               - Specifies which OHP block (see odu_ohp_inst_t)
*   int_table_ptr     - pointer to interrupt table. Mark fields as TRUE within this
*                       table to indicate that the interrupt/status will be enabled.
*                       NULL to enable/disable all interrupt/status.
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_ohp_enable(coreotn_handle_t     *coreotn_handle,
                                        odu_ohp_inst_t        ohp,
                                        odu_ohp_int_t        *int_table_ptr,
                                        odu_ohp_int_t        *int_en_table_ptr,
                                        BOOL                  enable)
{
    PMC_ERROR                   result = PMC_SUCCESS;
    odu_ohp_handle_t           *ohp_handle_ptr;

    PMC_ENTRY();

    if (ODU_OHP_LAST  <= ohp)
    {
        result = COREOTN_ERR_INVALID_ARG;
    }

    if (PMC_SUCCESS == result)
    {
        /* Find the port with the configured framer */
        ohp_handle_ptr = coreotn_handle->odu_ohp_handle[ohp];
        odu_ohp_int_enable(ohp_handle_ptr,                        
                           int_table_ptr,
                           int_en_table_ptr,
                           enable);
    }

    PMC_RETURN(result);
} /* coreotn_int_ohp_chnl_enable */

/*******************************************************************************
* FUNCTION: coreotn_int_ohp_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears ODU OHP unchannelized interrupts.
*   
*
* INPUTS:
*   coreotn_handle     - Pointer to subsystem handle.
*   ohp                - Specifies which OHP block (see odu_ohp_inst_t)
*   int_table_ptr      - pointer to odu ohp interrupt table with
*                        bits to clear
*   int_en_table_ptr   - Enabled interrupts table. 
*                        When NULL, all interrupts are cleared.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_ohp_clear(coreotn_handle_t      *coreotn_handle,
                                       odu_ohp_inst_t         ohp,
                                       odu_ohp_int_t         *int_table_ptr,
                                       odu_ohp_int_t         *int_en_table_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;
    odu_ohp_handle_t           *ohp_handle_ptr = NULL;

    PMC_ENTRY();

    if (ODU_OHP_LAST  <= ohp)
    {
        result = COREOTN_ERR_INVALID_ARG;
    }

    if (PMC_SUCCESS == result)
    {
        /* Find the port with the configured framer */
        ohp_handle_ptr = coreotn_handle->odu_ohp_handle[ohp];
    
        /* clear ODU OHP interrupt associated to given channel */
        if (NULL != ohp_handle_ptr)
        {
            result = odu_ohp_int_clear(ohp_handle_ptr,
                                       int_table_ptr, 
                                       int_en_table_ptr);
        }
    }

    PMC_RETURN(result);
} /* coreotn_int_ohp_clear */

/*******************************************************************************
* FUNCTION: coreotn_int_rcp_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves DI or RCP RCP unchannelized interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   rcp_inst          - identify the RI or DI RCP instance.
*   filt_table_ptr    - pointer to filter table. Mark fields as TRUE within this
*                       table to indicate that the interrupt/status will be retrieved
*                       to the output table. NULL to retrieve all 
*                       interrupt/status.
*
* OUTPUTS:
*   int_table_ptr     - pointer to channel interrupt table for output
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_rcp_retrieve(coreotn_handle_t     *coreotn_handle,
                                          odu_rcp_inst_t        rcp_inst,
                                          odu_rcp_int_t        *filt_table_ptr,
                                          odu_rcp_int_t        *int_table_ptr)
{
    PMC_ERROR                   result = PMC_SUCCESS;

    PMC_ENTRY();

    /* Find the port with the configured framer */
    odu_rcp_int_retrieve(coreotn_handle->odu_rcp_handle, 
                         rcp_inst,
                         filt_table_ptr,
                         int_table_ptr);
    
    PMC_RETURN(result);
} /* coreotn_int_rcp_retrieve */

/*******************************************************************************
* FUNCTION: coreotn_int_rcp_enable()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enables/Disables DI or RI RCP block unchannelized interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handlechannel
*   rcp_inst          - identify the RI or DI RCP instance.
*   int_table_ptr     - pointer to interrupt table. Mark fields as TRUE within this
*                       table to indicate that the interrupt/status will be enabled.
*                       NULL to enable/disable all interrupt/status.
*   enable            - TRUE to enable interrupts, FALSE to disable interrupts
*
* OUTPUTS:
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_rcp_enable(coreotn_handle_t     *coreotn_handle,
                                        odu_rcp_inst_t        rcp_inst,
                                        odu_rcp_int_t       *int_table_ptr,
                                        odu_rcp_int_t       *int_en_table_ptr,
                                        BOOL                  enable)
{
    PMC_ERROR                   result = PMC_SUCCESS;

    PMC_ENTRY();

    /* Find the port with the configured framer */
    odu_rcp_int_enable(coreotn_handle->odu_rcp_handle,
                       rcp_inst,
                       int_table_ptr,
                       int_en_table_ptr,
                       enable);
    
    PMC_RETURN(result);
} /* coreotn_int_rcp_chnl_enable */

/*******************************************************************************
* FUNCTION: coreotn_int_prbs_chnl_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves channel PRBS interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   prbs_chnl         - PRBS channel
*   prbs_inst         - PRBS instance
*
* OUTPUTS:
*   int_table_ptr     - pointer to channel interrupt table for output
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_int_prbs_chnl_retrieve(coreotn_handle_t           *coreotn_handle,
                                                 UINT32                      prbs_chnl,
                                                 coreotn_prbs_inst_t         prbs_inst, 
                                                 coreotn_int_prbs_chnl_t    *int_table_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();
    
    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(prbs_chnl < COREOTN_PRBS_NUM_CHNL, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(prbs_inst < LAST_COREOTN_PRBS_INST, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(int_table_ptr != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);

    if (prbs_inst < COREOTN_FO1_PRBS)
    {
        int_table_ptr->prbs_dlss_i = coreotn_fmf_field_range_PRBS_DLSS_I_get(NULL, coreotn_handle, prbs_inst, prbs_chnl, prbs_chnl);
        int_table_ptr->prbs_dlss_v = coreotn_fmf_field_range_PRBS_DLSS_V_get(NULL, coreotn_handle, prbs_inst, prbs_chnl, prbs_chnl);
    }
    else
    {
        int_table_ptr->prbs_dlss_i = coreotn_fo_field_range_PRBS_DLSS_I_get(NULL, coreotn_handle, prbs_inst-2, prbs_chnl, prbs_chnl);
        int_table_ptr->prbs_dlss_v = coreotn_fo_field_range_PRBS_DLSS_V_get(NULL, coreotn_handle, prbs_inst-2, prbs_chnl, prbs_chnl);
    }    


    PMC_RETURN(result);
} /* coreotn_int_prbs_chnl_retrieve */




/*******************************************************************************
* FUNCTION: coreotn_int_prbs_chnl_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears channel PRBS interrupts.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   prbs_chnl         - PRBS channel
*   prbs_inst         - PRBS instance
*   int_table_ptr     - pointer to channel interrupt table to clear. 
*                       NULL to clear all interrupts.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_int_prbs_chnl_clear(coreotn_handle_t           *coreotn_handle,
                                              UINT32                      prbs_chnl,
                                              coreotn_prbs_inst_t         prbs_inst, 
                                              coreotn_int_prbs_chnl_t    *int_table_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();
    
    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(prbs_chnl < COREOTN_PRBS_NUM_CHNL, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(prbs_inst < LAST_COREOTN_PRBS_INST, COREOTN_ERR_INVALID_ARG, 0, 0);

    if ((NULL == int_table_ptr) || (TRUE == int_table_ptr->prbs_dlss_i))
    {
        if (prbs_inst < COREOTN_FO1_PRBS)
        {
            coreotn_fmf_field_range_PRBS_DLSS_I_set_to_clear(NULL, coreotn_handle, prbs_inst, prbs_chnl, prbs_chnl, TRUE);
        }
        else
        {
            coreotn_fo_field_range_PRBS_DLSS_I_set_to_clear(NULL, coreotn_handle, prbs_inst-2, prbs_chnl, prbs_chnl, TRUE);
        }
    }


    PMC_RETURN(result);
} /* coreotn_int_prbs_chnl_clear */




/*******************************************************************************
* FUNCTION: coreotn_int_prbs_chnl_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Searches for active interrupt bits based on the enabled interrupt table.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to coreotn handle
*   prbs_chnl         - PRBS channel
*   prbs_inst         - PRBS instance
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*
* OUTPUTS:
*   int_found_ptr     - Returns TRUE if an active interrupt is found
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise. 
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_int_prbs_chnl_enabled_check(coreotn_handle_t           *coreotn_handle,
                                                      UINT32                      prbs_chnl,
                                                      coreotn_prbs_inst_t         prbs_inst, 
                                                      coreotn_int_prbs_chnl_t    *int_en_table_ptr,
                                                      BOOL                       *int_found_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();
    
    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(prbs_chnl < COREOTN_PRBS_NUM_CHNL, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(prbs_inst < LAST_COREOTN_PRBS_INST, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(int_en_table_ptr != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_found_ptr != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);

    if ((FALSE == *int_found_ptr) &&
        (TRUE == int_en_table_ptr->prbs_dlss_i))
    {
        if (prbs_inst < COREOTN_FO1_PRBS)
        {
            *int_found_ptr = coreotn_fmf_field_range_PRBS_DLSS_I_get(NULL, coreotn_handle, prbs_inst, prbs_chnl, prbs_chnl);
        }
        else
        {
            *int_found_ptr = coreotn_fo_field_range_PRBS_DLSS_I_get(NULL, coreotn_handle, prbs_inst-2, prbs_chnl, prbs_chnl);
        }    
    }

    PMC_RETURN(result);
} /* coreotn_int_prbs_chnl_enabled_check */


/*******************************************************************************
* FUNCTION: coreotn_int_chnl_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears interrupts based on bits that are set in the channlized 
*   interrupt table.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*   int_table_ptr     - pointer to channel interrupt table with bits set to
*                       clear interrupts. NULL to clear all interrupts.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_chnl_clear(coreotn_handle_t           *coreotn_handle,
                                        coreotn_int_chnl_info_t    *chnl_info,
                                        coreotn_int_chnl_t         *int_table_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;
    odtu_dmx_handle_t           *odtu_dmx_ho_handle = NULL;
    odtu_dmx_handle_t           *odtu_dmx_lo_handle = NULL;
    UINT32                       prbs_chnl;
    coreotn_prbs_inst_t          prbs_inst;
    odtu_dmx_int_chnl_info_t     odtu_info;
    mpmo_handle_t               *mpmo_handle;
    mpma_handle_t               *mpma_handle;
    odu_ohp_port_framer_t        port_framer = ODU_OHP_PORT_FRAMER_1;
    odu_ohp_inst_t               ohp;
    odu_ohp_port_t               ohp_port;
    odu_ohp_handle_t            *ohp_handle_ptr;
    odu_tfrm_handle_t           *tfrm_handle = NULL;

    PMC_ENTRY();

    result = coreotn_int_validate(coreotn_handle, chnl_info, chnl_info);
    
    /* get tfrm channel interrupt*/
    if (PMC_SUCCESS == result)
    {
        result = coreotn_tfrm_handle_get(coreotn_handle,
                                         chnl_info,
                                         &tfrm_handle);   
    }   
     
    /* TFRM */
    if ((NULL != tfrm_handle) &&
        (PMC_SUCCESS == result) &&
        (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_TFRM)))
    {
        result = odu_tfrm_int_chnl_clear(tfrm_handle,
                                         chnl_info->chnl_id,
                                         UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_chnl.tfrm),
                                         UTIL_GLOBAL_ALL_INTS);
    }

    /* ODUKSC */
    if ((PMC_SUCCESS == result) &&
        (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_ODUKSC)))
    {
        result = coreotn_oduksc_int_chnl_clear(coreotn_handle,
                                               chnl_info,
                                               UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_chnl),
                                               UTIL_GLOBAL_ALL_INTS);
    }
    
    /* ODUJAT */
    if ((PMC_SUCCESS == result) &&
        (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_ODUJAT)))
    {
        result = coreotn_odujat_int_chnl_clear(coreotn_handle,
                                               chnl_info,
                                               UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_chnl),
                                               UTIL_GLOBAL_ALL_INTS);
    }
    
    /* ODTU_MUX */
    if ((PMC_SUCCESS == result) &&
        (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_ODTU_MUX)))
    {
        result = coreotn_odtu_mux_int_chnl_clear(coreotn_handle,
                                                 chnl_info,
                                                 UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_chnl),
                                                 UTIL_GLOBAL_ALL_INTS);
    }
    
    /* ODTU_DMX */
    if ((PMC_SUCCESS == result) &&
        (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_ODTU_DMX)))
    {
        result = coreotn_odtu_dmx_handle_get(coreotn_handle,
                                             chnl_info,
                                             &odtu_dmx_ho_handle,  
                                             &odtu_dmx_lo_handle);   
    }   
   
    if ((PMC_SUCCESS == result) &&
        (NULL != odtu_dmx_ho_handle))
    {
        odtu_info.chnl_id = chnl_info->chnl_id;
        odtu_info.higher_order = TRUE;
        result = odtu_dmx_int_chnl_clear(odtu_dmx_ho_handle,
                                         &odtu_info,
                                         UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_chnl.odtu_dmx));
    }
    
    
    if ((PMC_SUCCESS == result) &&
        (NULL != odtu_dmx_lo_handle))
    {
        odtu_info.chnl_id = chnl_info->chnl_id;
        odtu_info.higher_order = FALSE;
        result = odtu_dmx_int_chnl_clear(odtu_dmx_lo_handle,
                                         &odtu_info,
                                         UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_chnl.odtu_dmx));
    }
    

    if ((PMC_SUCCESS == result) &&
        (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_PRBS)) &&
        (coreotn_is_prbs_prov(coreotn_handle, chnl_info, &prbs_chnl, &prbs_inst)))
    {
        result = coreotn_int_prbs_chnl_clear(coreotn_handle,
                                             prbs_chnl,
                                             prbs_inst,
                                             UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, prbs));
    }

    if (PMC_SUCCESS == result)
    {
        result = coreotn_mpma_mpmo_handle_get(coreotn_handle,
                                              chnl_info,
                                              &mpma_handle,
                                              &mpmo_handle);
        if ((mpmo_handle != NULL) &&
            (PMC_SUCCESS == result) &&
            (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_MPMO)))
        {            
            result = mpmo_int_chnl_clear(mpmo_handle,
                                         chnl_info->chnl_id,
                                         UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_chnl.mpmo),
                                         NULL);
        }
        
        if ((mpma_handle != NULL) &&
            (PMC_SUCCESS == result) &&
            (coreotn_int_filt_check(chnl_info->blk_filter, COREOTN_INT_FILTER_BLOCKS_MPMA)))
        {
            result = mpma_int_chnl_clear(mpma_handle,
                                         chnl_info->chnl_id,
                                         UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, framer_chnl.mpma),
                                         NULL);
        }
    }

    /* clear OHPs interrupt associated to given channel */
    if (PMC_SUCCESS == result)
    {
        port_framer = coreotn_odu_ohp_port_framer_get(coreotn_handle, chnl_info);

        if (ODU_OHP_PORT_FRAMER_LAST > port_framer)
        {
            /* Find the port with the configured framer */
            for(ohp = ODU_OHP_1; ohp <= ODU_OHP_3; ohp = (odu_ohp_inst_t)((UINT32)ohp + 1))
            {
                ohp_handle_ptr = coreotn_handle->odu_ohp_handle[ohp];
                for (ohp_port = ODU_OHP_PORT_A; ohp_port <= ODU_OHP_PORT_B;ohp_port = (odu_ohp_port_t)((UINT32)ohp_port + 1)) 
                {
                    if (ohp_handle_ptr->cfg.port_cfg[ohp_port].port_framer == port_framer) 
                    {
                        odu_ohp_int_chnl_clear(ohp_handle_ptr, 
                                               chnl_info->chnl_id,
                                               UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, ohp_chnl[ohp]));
                    }
                }
            }
        }
    }

    /* clear RI_RCP interrupt associated to given channel */
    if (PMC_SUCCESS == result)
    {        
        odu_ri_rcp_int_chnl_clear(coreotn_handle->odu_rcp_handle, 
                                  chnl_info->chnl_id,
                                  UTIL_GLOBAL_INT_SAFE_GET_OFFSET(int_table_ptr, ri_rcp_chnl));
    }

    PMC_RETURN(result);
} /* coreotn_int_chnl_clear */


/*******************************************************************************
* FUNCTION: coreotn_rfrm_chnl_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Clears the one RFRM AC_APS interrupt.
*   
*
* INPUTS:
*   coreotn_handle    - Pointer to subsystem handle
*   chnl_info         - structure describing the channel: chnl id, odu level
*                       lineotn/sysotn
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rfrm_chnl_clear(coreotn_handle_t           *coreotn_handle,
                                        coreotn_int_chnl_info_t    *chnl_info)
{
    PMC_ERROR result = PMC_SUCCESS;
    odu_rfrm_handle_t *rfrm_handle = NULL;

    PMC_ENTRY();

    result = coreotn_int_validate(coreotn_handle, chnl_info, chnl_info);
    
    /* get tfrm channel interrupt*/
    if (PMC_SUCCESS == result)
    {
        result = coreotn_rfrm_handle_get(coreotn_handle,
                                         chnl_info,
                                         &rfrm_handle);   
    }   
    if (PMC_SUCCESS == result && NULL != rfrm_handle)
    {
        result = odu_rfrm_int_chnl_clear(rfrm_handle,
                                         chnl_info->chnl_id,
                                         UTIL_GLOBAL_ALL_INTS);
    }
    PMC_RETURN(result);
} /* coreotn_rfrm_chnl_clear */

/*******************************************************************************
* FUNCTION: coreotn_int_rcp_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears DI or RI RCP unchannelized interrupts.
*   
*
* INPUTS:
*   coreotn_handle     - Pointer to subsystem handle.
*   rcp_inst           - identify the RI or DI RCP instance.
*   int_table_ptr      - pointer to DI RCP interrupt table with
*                        bits to clear
*                        When NULL, all interrupts are cleared.
*   int_en_table_ptr   - Enabled interrupts table. 
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_rcp_clear(coreotn_handle_t   *coreotn_handle,
                                       odu_rcp_inst_t      rcp_inst,
                                       odu_rcp_int_t      *int_table_ptr,
                                       odu_rcp_int_t      *int_en_table_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;

    PMC_ENTRY();

    /* clear DI_RCP interrupt associated to given channel */
    result = odu_rcp_int_clear(coreotn_handle->odu_rcp_handle, 
                               rcp_inst,
                               int_table_ptr, 
                               int_en_table_ptr);
    
    PMC_RETURN(result);
} /* coreotn_int_rcp_clear */


/*******************************************************************************
* FUNCTION: coreotn_int_chnl_enabled_check()
*______________________________________________________________________________
*
* DESCRIPTION:
*   Searches for active interrupt bits based on the enabled interrupt table.
*   
*
* INPUTS:
*   coreotn_handle          - Pointer to subsystem handle
*   chnl_info               - structure describing the channel: chnl id, odu level
*                             lineotn/sysotn
*   int_en_table_ptr        - Pointer to table tracking enabled interrupts
*   pid_int_en_table_ptr    - Pointer to TCM PID table tracking enabled interrupts
*   prbs_en_table_ptr       - Pointer to table tracking enabled PRBS interrupts 
*   ohp_en_table_pptr       - Pointer to OHPs enabled interrupts.
*   ri_rcp_en_table_ptr     - Pointer to RI RCP enabled interrupts.
*
* OUTPUTS:
*   int_found_ptr     - Returns TRUE if an active interrupt is found
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_chnl_enabled_check(coreotn_handle_t           *coreotn_handle,
                                                coreotn_int_chnl_info_t    *chnl_info,
                                                coreotn_int_framer_chnl_t  *int_en_table_ptr,
                                                coreotn_int_pid_chnl_t     *pid_int_en_table_ptr,
                                                coreotn_int_prbs_chnl_t    *prbs_en_table_ptr,
                                                odu_ohp_int_chnl_t        **ohp_en_table_pptr,
                                                odu_ri_rcp_int_chnl_t      *ri_rcp_en_table_ptr,
                                                BOOL                       *int_found_ptr)
{
    PMC_ERROR                    result = PMC_SUCCESS;
    odu_rfrm_handle_t           *rfrm_handle = NULL;
    odu_tfrm_handle_t           *tfrm_handle = NULL;
    UINT32                       prbs_chnl;
    coreotn_prbs_inst_t          prbs_inst;
    mpmo_handle_t              *mpmo_handle;
    mpma_handle_t              *mpma_handle;
    BOOL8                       internal_int_found = FALSE;
    odu_ohp_port_framer_t       port_framer = ODU_OHP_PORT_FRAMER_1;
    odu_ohp_inst_t              ohp;
    odu_ohp_port_t              ohp_port;
    odu_ohp_handle_t           *ohp_handle_ptr;

    PMC_ENTRY();

    PMC_ASSERT(int_en_table_ptr != NULL, COREOTN_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(int_found_ptr != NULL, COREOTN_ERR_INVALID_ARG, 0, 0);

    internal_int_found = UTIL_GLOBAL_BOOL_TO_BOOL8_CONVERT(*int_found_ptr);
    result = coreotn_int_validate(coreotn_handle, chnl_info, &internal_int_found);

    if (PMC_SUCCESS == result)
    {
        result = coreotn_rfrm_handle_get(coreotn_handle,
                                         chnl_info,
                                         &rfrm_handle);   
    }   

    if (PMC_SUCCESS == result)
    {
        result = coreotn_tfrm_handle_get(coreotn_handle,
                                         chnl_info,
                                         &tfrm_handle);   
    }   
    

    if ((NULL != rfrm_handle) &&
        (PMC_SUCCESS == result))
    {
        /* Checks both PM and PID enabled interrupts */
        result = odu_rfrm_int_chnl_enabled_check(rfrm_handle,
                                                 chnl_info->chnl_id,
                                                 &chnl_info->rfrm_int_summary,
                                                 &int_en_table_ptr->rfrm,
                                                 &internal_int_found);
    }
   
    /* TFRM */
    if ((NULL != tfrm_handle) &&
        (PMC_SUCCESS == result) &&
        (FALSE == internal_int_found))
    {
        result = odu_tfrm_int_chnl_enabled_check(tfrm_handle,
                                                 chnl_info->chnl_id,
                                                 &int_en_table_ptr->tfrm,
                                                 &internal_int_found);
    }
    
    /* ODUKSC */
    if ((PMC_SUCCESS == result) &&
        (FALSE == internal_int_found))
    {
        result = coreotn_oduksc_int_chnl_enabled_check(coreotn_handle,
                                                       chnl_info,
                                                       int_en_table_ptr,
                                                       &internal_int_found);
    }
    
    /* ODUKJAT */
    if ((PMC_SUCCESS == result) &&
        (FALSE == internal_int_found))
    {
        result = coreotn_odujat_int_chnl_enabled_check(coreotn_handle,
                                                       chnl_info,
                                                       int_en_table_ptr,
                                                       &internal_int_found);
    }
    
    /* ODTU_MUX */
    if ((PMC_SUCCESS == result) &&
        (FALSE == internal_int_found))
    {
        result = coreotn_odtu_mux_int_chnl_enabled_check(coreotn_handle,
                                                       chnl_info,
                                                       int_en_table_ptr,
                                                       &internal_int_found);
    }    
    
    /* ODTU_DMX */
    if ((PMC_SUCCESS == result) &&
        (FALSE == internal_int_found))
    {
        result = coreotn_odtu_dmx_int_chnl_enabled_check(coreotn_handle,
                                                         chnl_info,
                                                         int_en_table_ptr,
                                                         &internal_int_found);
    }

    *int_found_ptr = UTIL_GLOBAL_BOOL8_TO_BOOL_CONVERT(internal_int_found);

    if ((PMC_SUCCESS == result) &&
        (FALSE == internal_int_found) &&
        (coreotn_is_prbs_prov(coreotn_handle, chnl_info, &prbs_chnl, &prbs_inst)))
    {
        result = coreotn_int_prbs_chnl_enabled_check(coreotn_handle,
                                                     prbs_chnl,
                                                     prbs_inst,
                                                     prbs_en_table_ptr,
                                                     int_found_ptr);
    }

    if (PMC_SUCCESS == result && FALSE == internal_int_found)
    {
        result = coreotn_mpma_mpmo_handle_get(coreotn_handle,
                                              chnl_info,
                                              &mpma_handle,
                                              &mpmo_handle);
        if (mpmo_handle != NULL && PMC_SUCCESS == result && FALSE == internal_int_found)
        {            
            result = mpmo_int_chnl_enabled_check(mpmo_handle,
                                                 chnl_info->chnl_id,
                                                 &int_en_table_ptr->mpmo,
                                                 &internal_int_found );
            *int_found_ptr = UTIL_GLOBAL_BOOL8_TO_BOOL_CONVERT(internal_int_found);
        }
        if (mpma_handle != NULL && PMC_SUCCESS == result && FALSE == internal_int_found)
        {
            result = mpma_int_chnl_enabled_check(mpma_handle,
                                                 chnl_info->chnl_id,
                                                 &int_en_table_ptr->mpma,
                                                 &internal_int_found );
            *int_found_ptr = UTIL_GLOBAL_BOOL8_TO_BOOL_CONVERT(internal_int_found);
        }
    }

    if (PMC_SUCCESS == result && FALSE == internal_int_found)
    {
        port_framer = coreotn_odu_ohp_port_framer_get(coreotn_handle, chnl_info);

        if (ODU_OHP_PORT_FRAMER_LAST > port_framer)
        {
            /* Find the port with the configured framer */
            for(ohp = ODU_OHP_1; ohp <= ODU_OHP_3 && FALSE == internal_int_found; ohp = (odu_ohp_inst_t)((UINT32)ohp + 1))
            {
                ohp_handle_ptr = coreotn_handle->odu_ohp_handle[ohp];
                for (ohp_port = ODU_OHP_PORT_A; ohp_port <= ODU_OHP_PORT_B && FALSE == internal_int_found; ohp_port = (odu_ohp_port_t)((UINT32)ohp_port + 1))
                {
                    if (ohp_handle_ptr->cfg.port_cfg[ohp_port].port_framer == port_framer) 
                    {
                        odu_ohp_int_chnl_enabled_check(ohp_handle_ptr, 
                                                       chnl_info->chnl_id,
                                                       &ohp_en_table_pptr[(UINT32)ohp][chnl_info->chnl_id],
                                                       &internal_int_found);
                        *int_found_ptr = UTIL_GLOBAL_BOOL8_TO_BOOL_CONVERT(internal_int_found);
                    }
                }
            }
        }
    }

    if (PMC_SUCCESS == result && FALSE == internal_int_found)
    {
        odu_ri_rcp_int_chnl_enabled_check(coreotn_handle->odu_rcp_handle, 
                                          chnl_info->chnl_id,
                                          ri_rcp_en_table_ptr,
                                          &internal_int_found);

        *int_found_ptr = UTIL_GLOBAL_BOOL8_TO_BOOL_CONVERT(internal_int_found);
    }
     

    PMC_RETURN(result);
} /* coreotn_int_chnl_enabled_check */


/*******************************************************************************
* FUNCTION: coreotn_int_top_enabled_check()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Checks the top level coreotn summary registers to determine
*   if there is active interrupt in the requested CoreOTN blocks (ODU or FO2).
*   
*
* INPUTS:
*   coreotn_handle  - Pointer to coreotn handle
*   int_type        - CoreOTN ODUKP or FO2 interrupt type
*
* OUTPUTS:
*   int_found_ptr   - Returns TRUE if an active interrupt is found
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_int_top_enabled_check(coreotn_handle_t        *coreotn_handle,
                                               coreotn_int_type_t       int_type,
                                               BOOL                    *int_found_ptr)
                                               
{
    PMC_ERROR       result = PMC_SUCCESS;
    UINT32          int_summary_1, int_summary_2;
    UINT32          int_summary_1_stg4_mask;

    PMC_ENTRY();

    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(int_found_ptr  != NULL, COREOTN_ERR_NULL_HANDLE, 0, 0);


    int_summary_1 = coreotn_ctl_reg_INT_STAT_REG_1_read(NULL, coreotn_handle);
    int_summary_2 = coreotn_ctl_reg_INT_STAT_REG_2_read(NULL, coreotn_handle);

    int_summary_1_stg4_mask = 0x00055000;

    switch (int_type)
    {
      case COREOTN_INT_TYPE_ODUKP:
        if ((int_summary_1 & ~int_summary_1_stg4_mask) ||
            (int_summary_2))
        {
            *int_found_ptr = TRUE;
        }
        break;
        
      case COREOTN_INT_TYPE_STG4:
        if (int_summary_1 & int_summary_1_stg4_mask)
        {
            *int_found_ptr = TRUE;
        }
        break;
        
      default:
        PMC_ASSERT(NULL, COREOTN_ERR_INVALID_ARG, 0, 0);
        break;
    } /* end switch */
    


    PMC_RETURN(result);
} /* coreotn_int_top_enabled_check */

/*******************************************************************************
* coreotn_adjust_dci_clock
* ______________________________________________________________________________
*                                                                               
* DESCRIPTION:
*   Performs MPMO/ODUKSC adjectments given an integer numerator and
*   denominator multiplier on the DCI clock frequency.
*                                                                              
* INPUTS:                                                                       
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   num_mult            - numerator to be applied to the DCI clock frequency
*   denom_mult          - denominator to be applied to the DCI clock frequency   
*                                                                               
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.                                  
*                                                                               
* NOTES:                                                                        
*                                                                               
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_adjust_dci_clock(coreotn_handle_t *coreotn_handle,
                                          UINT32 num_mult,
                                          UINT32 denom_mult)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();
    
    result = mpmo_adjust_dci_clk(coreotn_handle->mpmo_fo1_handle,
                                 num_mult,
                                 denom_mult);

    if(result == PMC_SUCCESS)
    {

        result = oduksc_adjust_dci_clk(coreotn_handle->oduksc2_handle,
                                       denom_mult,
                                       num_mult);
    }

    
    PMC_RETURN(result);
} /* coreotn_adjust_dci_clock  */

/*******************************************************************************
* coreotn_odtu_mux_lo_chnl_activate_only
* ______________________________________________________________________________
*                                                                               
* DESCRIPTION:
*   This function activates the LO ODU channel that has not been already provisioned.
*   This is a dummy LO channel that needs to be activated in absence of a 
*   real LO channel that uses the same channel ID as the MO channel.
*                                                                                  
*                                                                               
* INPUTS:                                                                       
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95                   
*                                                                               
* OUTPUTS:                                                                      
*   None.                                                                       
*                                                                               
* RETURNS:                                                                      
*   PMC_SUCCESS - on success, error otherwise.                                                                     
*                                                                               
* NOTES:                                                                        
*                                                                               
*******************************************************************************/                                     
PUBLIC PMC_ERROR coreotn_odtu_mux_lo_chnl_activate_only(coreotn_handle_t *coreotn_handle,
                                                        UINT32 chnl_id) 
{
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();
    
    result = odtu_mux_lo_chnl_activate_only(coreotn_handle->odtu_mux2_handle, 
                                            chnl_id);
                                            
    PMC_RETURN(result);                                            
}  /* coreotn_odtu_mux_lo_chnl_activate_only */     

/*******************************************************************************
* coreotn_odtu_mux_lo_chnl_deactivate_only
* ______________________________________________________________________________
*                                                                               
* DESCRIPTION:
*   This function is used to hold the LO ODU channel in reset while MO channel 
*   with the same channel ID is still provisioned.
*                                          
* INPUTS:                                                                       
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95               
*                                                                               
* OUTPUTS:                                                                      
*   None.                                                                       
*                                                                               
* RETURNS:                                                                      
*   PMC_SUCCESS - on success, error otherwise.                                                                    
*                                                                               
* NOTES:                                                                        
*                                                                               
*******************************************************************************/                                     
PUBLIC PMC_ERROR coreotn_odtu_mux_lo_chnl_deactivate_only(coreotn_handle_t *coreotn_handle, 
                                                          UINT32 chnl_id) 
{        
    
    /* variable declaration */
    PMC_ERROR result = PMC_SUCCESS;
    BOOL8 dummy_ch = FALSE;
    
    PMC_ENTRY();
    
    result = odtu_mux_lo_chnl_deactivate_only(coreotn_handle->odtu_mux2_handle, 
                                              chnl_id, 
                                              &dummy_ch);                
    
    PMC_RETURN(result);                                            
}  /* coreotn_odtu_mux_lo_chnl_deactivate_only */                                                                             

/*******************************************************************************
*  coreotn_odtu_dmx_dummy_schd_prov_num_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns the number of dummy calendar that has been scheduled
*   for MO ODU3 channels in the DMX. 
*
* INPUTS:
*   *coreotn_handle     - handle to the COREOTN instance to be operated on
*
* OUTPUTS:
*   *num_dummy_schd     - number of scheduled dummy calendar for MO ODU3
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_odtu_dmx_dummy_schd_prov_num_get(coreotn_handle_t *coreotn_handle,
                                                          UINT32 *num_dummy_schd)
{    
    PMC_ENTRY();
    
    PMC_ERROR result = PMC_SUCCESS;
    
    result = odtu_dmx_dummy_schd_prov_num_get(coreotn_handle->odtu_dmx2_handle,
                                              num_dummy_schd);
                                              
    PMC_RETURN(result);
} /* coreotn_odtu_dmx_dummy_schd_prov_num_get */  

/*******************************************************************************
*  coreotn_odtu_dmx_first_valid_dummy_find
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function initialize ODU_RFRM var_t variables. Elements in TCM POOL ID
*   context structure are also initialized in this function.
*
* INPUTS:
*   coreotn_handle      - handle to the ODU_RFRM instance to be operated on
*   first_cycle         - tributary slot number
*
* OUTPUTS:
*   *valid_null_cycle   - first valid null cycle  
*   *dummy_idx          - index for dummy schedule
*
* RETURNS:
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_odtu_dmx_first_valid_dummy_find(coreotn_handle_t *coreotn_handle,
                                                         UINT32 first_cycle, 
                                                         UINT32 *valid_null_cycle,
                                                         UINT32 *dummy_idx)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();
    

    result = odtu_dmx_first_valid_dummy_find(coreotn_handle->odtu_dmx2_handle,
                                             first_cycle, 
                                             valid_null_cycle, dummy_idx);
    
   
    
    PMC_RETURN(PMC_SUCCESS);
} /* coreotn_odtu_dmx_first_valid_dummy_find */       

/*******************************************************************************
*  coreotn_mpmo_scbs3_all_chnls_activate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Activates all provisioned channel.
*   This function writes the calculated parameters for the provisioned channel
*   to hardware.
*
* INPUTS:
*   coreotn_handle    - COREOTN handle to be operated on
*   mpmo_inst         - MPMO instance. See coreotn_mpmo_inst_t
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_mpmo_scbs3_all_chnls_activate(coreotn_handle_t *coreotn_handle,
                                                       coreotn_mpmo_inst_t mpmo_inst)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    mpmo_handle_t *mpmo_handle;
    
    PMC_ENTRY();
     
    switch (mpmo_inst)
    {
        case COREOTN_MPMO_TO_COREOTN:
            mpmo_handle = coreotn_handle->mpmo_fo1_handle;
            break;           
        case COREOTN_MPMO_TO_MAPOTN:
            mpmo_handle = coreotn_handle->mpmo_fo2_handle;
            break;
        case COREOTN_MPMO_CORECTL:
            mpmo_handle = coreotn_handle->mpmo_core_ctl_handle;
            break;
        default:
            ret_val = COREOTN_ERR_INVALID_ARG;
            break;
    }
    
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = mpmo_scbs3_all_chnls_activate(mpmo_handle);   
    }
    
    PMC_RETURN(ret_val);
} /* coreotn_mpmo_scbs3_all_chnls_activate */          


/*******************************************************************************
*  coreotn_mpmo_scbs3_all_chnls_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Deactivates all provisioned channel in SCBS3 calendar of a specified 
*   COREOTN MPMO instance.
*   This function writes the calculated parameters for the provisioned channel
*   to hardware.
*
* INPUTS:
*   coreotn_handle    - COREOTN handle to be operated on
*   mpmo_inst         - MPMO instance. See coreotn_mpmo_inst_t
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_mpmo_scbs3_all_chnls_deactivate(coreotn_handle_t *coreotn_handle,
                                                         coreotn_mpmo_inst_t mpmo_inst)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    mpmo_handle_t *mpmo_handle;
    
    PMC_ENTRY();
     
    switch (mpmo_inst)
    {
        case COREOTN_MPMO_TO_COREOTN:
            mpmo_handle = coreotn_handle->mpmo_fo1_handle;
            break;           
        case COREOTN_MPMO_TO_MAPOTN:
            mpmo_handle = coreotn_handle->mpmo_fo2_handle;
            break;
        case COREOTN_MPMO_CORECTL:
            mpmo_handle = coreotn_handle->mpmo_core_ctl_handle;
            break;
        default:
            ret_val = COREOTN_ERR_INVALID_ARG;
            break;
    }
    
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = mpmo_scbs3_all_chnls_deactivate(mpmo_handle);  
    }
    
    PMC_RETURN(ret_val);
} /* coreotn_mpmo_scbs3_all_chnls_deactivate */


/*******************************************************************************
*  coreotn_mpma_scbs3_all_chnls_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Activates all provisioned channel.
*   This function writes the calculated parameters for the provisioned channel
*   to hardware.
*
* INPUTS:
*   coreotn_handle    - COREOTN handle to be operated on
*   mpma_inst         - MPMA instance in COREOTN SS
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_mpma_scbs3_all_chnls_deactivate(coreotn_handle_t *coreotn_handle,
                                                         coreotn_mpma_inst_t mpma_inst)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    mpma_handle_t *mpma_handle;
    
    
    PMC_ENTRY();
    
    switch (mpma_inst)
    {
        case COREOTN_MPMA_TO_COREOTN:
            mpma_handle = coreotn_handle->mpma_fo1_handle;
            break;           
        case COREOTN_MPMA_FROM_MAPOTN:
            mpma_handle = coreotn_handle->mpma_fo2_handle;
            break;
        case COREOTN_MPMA_CORECTL:
            mpma_handle = coreotn_handle->mpma_core_ctl_handle;
            break;
        default:
            ret_val = COREOTN_ERR_INVALID_ARG;
            break;
    }
    
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = mpma_scbs3_all_chnls_deactivate(mpma_handle);   
    }
    
    PMC_RETURN(ret_val);
} /* coreotn_mpma_scbs3_all_chnls_deactivate */    


/*******************************************************************************
*  coreotn_mpma_scbs3_all_chnls_activate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Activates all provisioned channel.
*   This function writes the calculated parameters for the provisioned channel
*   to hardware.
*
* INPUTS:
*   coreotn_handle    - COREOTN handle to be operated on
*   mpma_inst         - MPMA instance in COREOTN SS
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_mpma_scbs3_all_chnls_activate(coreotn_handle_t *coreotn_handle,
                                                       coreotn_mpma_inst_t mpma_inst)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    mpma_handle_t *mpma_handle;
    
    
    PMC_ENTRY();
    
    switch (mpma_inst)
    {
        case COREOTN_MPMA_TO_COREOTN:
            mpma_handle = coreotn_handle->mpma_fo1_handle;
            break;           
        case COREOTN_MPMA_FROM_MAPOTN:
            mpma_handle = coreotn_handle->mpma_fo2_handle;
            break;
        case COREOTN_MPMA_CORECTL:
            mpma_handle = coreotn_handle->mpma_core_ctl_handle;
            break;
        default:
            ret_val = COREOTN_ERR_INVALID_ARG;
            break;
    }
    
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = mpma_scbs3_all_chnls_activate(mpma_handle);   
    }
    
    PMC_RETURN(ret_val);
} /* coreotn_mpma_scbs3_all_chnls_activate */    
                   
                   
/*******************************************************************************
*  coreotn_oduksw_dcs_swap_and_update_all
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Activates all provisioned channel.
*   This function activates all provisioned channel in ODUKSW:DCS by swapping
*   the page and updates the offline page with the same data in the active page
*   to maintain synchronization in the hardware.
*
* INPUTS:
*   coreotn_handle    - COREOTN handle to be operated on
*   dcs_inst            - DCS instance where the ODU channel will be destined to.
*
* OUTPUTS:
*   is_dcs_updated_ptr          - TRUE : DCS was update, FALSE : DCS was not updated
*   is_channel_idx_updated_arr  - array of 96 booleans that indicates which channel IDs were updated.
*                                 Can be NULL only if "is_cal_updated_ptr" equals NULL too.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_dcs_swap_and_update_all(coreotn_handle_t *coreotn_handle,
                                                        UINT32 dcs_inst,
                                                        BOOL8* is_dcs_updated_ptr,
                                                        BOOL8 is_channel_idx_updated_arr[])
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    
    PMC_ENTRY();
    
    ret_val = cpb_dcs_page_swap_and_offline_update(coreotn_handle->oduksw_handle,
                                                   dcs_inst,
                                                   is_dcs_updated_ptr,
                                                   is_channel_idx_updated_arr);
    
    
    PMC_RETURN(ret_val);
} /* coreotn_oduksw_dcs_swap_and_update_all */                        

/*******************************************************************************
* FUNCTION: coreotn_int_init()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Initializes/deinitializes interrupt and status support.
*   
*
* INPUTS:
*   coreotn_handle  - Pointer to coreotn handle
*   enable          - Enables/disables interrupt and status support.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_int_init(coreotn_handle_t    *coreotn_handle,
                                   BOOL                 enable)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();


    /* PCIE interrupts */
    coreotn_ctl_reg_UPPER_INT_EN_REG_2_write(NULL, coreotn_handle, 0xFFFFFFFF * enable);
    coreotn_ctl_reg_LOWER_INT_EN_REG_2_write(NULL, coreotn_handle, 0xFFFFFFFF * enable);

    
    /* Device Pin interrupts */
    coreotn_ctl_reg_UPPER_INT_EN_REG_3_write(NULL, coreotn_handle, 0xFFFFFFFF * enable);
    coreotn_ctl_reg_LOWER_INT_EN_REG_3_write(NULL, coreotn_handle, 0xFFFFFFFF * enable);
    

    PMC_RETURN(result);
} /* coreotn_int_init */

/*******************************************************************************
*  coreotn_sysapp_line_chnl_state_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API is used when the ODU channel is deprovisioned for the 
*   ODUKSW <-> LINEOTN segment for SYSOTN applications.  This API needs to:
*       1) take TFRM12/RFRM12 into/out of passthru to allow monitoring
*          of ODU layer from the line interface
*       2) take TFRM96/RFRM96 into/out of passthru to allow for TCM monitoring
*          over the switch fabric (will likely only be used in complex
*          applications).
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   state               - operating state of the framer channel
*                         COREOTN_CHNL_START -- disabled
*                         COREOTN_CHNL_OPERATIONAL -- enabled; out of passthru
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_sysapp_line_chnl_state_set(coreotn_handle_t *coreotn_handle,
                                                     UINT32 chnl_id,
                                                     coreotn_chnl_state_t state)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    BOOL enable = (state == COREOTN_CHNL_OPERATIONAL)?TRUE:FALSE;

    PMC_ENTRY();

    /* validate parameters */
    if( chnl_id > 11 ) 
    {
        ret_val = COREOTN_ERR_INVALID_ARG; 
    } else if (state == coreotn_handle->var.sysapp_line_state[chnl_id])
    {
        ret_val = COREOTN_ERR_INVALID_ARG; 
    }  

    /*
     * Added explicit call to odu_rfrm_chnl_init which was decoupled from
     * odu_rfrm_chnl_prov.
     */
    if(ret_val == PMC_SUCCESS) 
    { 
        ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stg1_handle, chnl_id, enable, 0);

    }


    
    /* provision RFRM12 (do not provision PM layer, do not enable FAU) */
    if(ret_val == PMC_SUCCESS) 
    { 
        ret_val = odu_rfrm_chnl_prov(coreotn_handle->odu_rfrm_stg1_handle, 
                                     chnl_id, FALSE, enable, 0, TRUE); 

    }

    /* provision TFRM12 (do not provision PM layer */                            
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = odu_tfrm_chnl_init(coreotn_handle->odu_tfrm_stg1_handle,
                                     chnl_id,enable);
    }

    /* provision TFRM96 (do not provision PM layer).
    OK to activate here as traffic is present from LINEOTN*/                            
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = odu_tfrm_chnl_init(coreotn_handle->odu_tfrm_stg2_handle,
                                     chnl_id,
                                     enable);
    }


    /* these calls are required to deprovision run time configuration (eg. TCMSs)*/
    if (PMC_SUCCESS == ret_val)
    {
        if(enable == 0)
        {
            ret_val = odu_rfrm_chnl_prov(coreotn_handle->odu_rfrm_stg2_handle, 
                                         chnl_id, FALSE, enable, 0, TRUE);
         
            /*clear dummy maintenance signal context at same time as clearing RFRM
            configuration*/
            coreotn_handle->var.prev_fmf1_sysotn_rfrm_maint_sig[chnl_id] = 0;
            coreotn_handle->var.dummy_fmf1_sysotn_maint_sig[chnl_id] = 0;


            ret_val = odu_tfrm_chnl_prov(coreotn_handle->odu_tfrm_stg2_handle,chnl_id,
                                         ODU_TFRM_MESSAGE_DONT_CARE,ODU_TFRM_MESSAGE_DONT_CARE,ODU_TFRM_PM_TCM_START,
                                         FALSE);   

            ret_val = odu_tfrm_chnl_prov(coreotn_handle->odu_tfrm_stg1_handle,chnl_id,
                                         ODU_TFRM_MESSAGE_DONT_CARE,ODU_TFRM_MESSAGE_DONT_CARE,ODU_TFRM_PM_TCM_START,
                                         FALSE);
        }
    }

    /* take both FRM_RCP CFC FIFO out of reset as by default RCP_EN = 1 */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle,
                                           COREOTN_FMF1_FRM_RCP12,
                                           chnl_id, 
                                           enable);
    }

    if (PMC_SUCCESS == ret_val)
    {
        ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle,
                                           COREOTN_FMF1_FRM_RCP96,
                                           chnl_id, 
                                           enable);
    }

    if (PMC_SUCCESS == ret_val)
    {
        coreotn_handle->var.sysapp_line_state[chnl_id] = state;
    }    
    
    PMC_RETURN(ret_val);
} /* coreotn_sysapp_line_chnl_state_set */

/*******************************************************************************
*  coreotn_rx_ho_chnl_mux_none_prov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_ho_chnl_prov for the 
*   mux_stage == COREOTN_MUX_STAGE_NONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   odu_container       - ODUk type. See odukp_type_enum.
*                         Valid range: ODU2 to ODU4
*   payload_format      - payload format of the ODUk traffic carried by this HO
*                         channel. See odu_line_payload_t.
*   prov_rfrm_tfrm_cfg  - TRUE : Provision RFRM configs
*                         FALSE : preserve current RFRM configs
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_none_prov(coreotn_handle_t *coreotn_handle,
                                                   UINT32 chnl_id,
                                                   coreotn_mux_stage_t mux_stage,
                                                   util_global_odukp_type_t odu_container,
                                                   util_global_odu_line_payload_t payload_format,
                                                   BOOL prov_rfrm_tfrm_cfg)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    odujat_chnl_mode_t odujat_enable;
    PMC_ENTRY();

    if (coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START) {

        ret_val = COREOTN_ERR_CHNL_STATE_NOT_START;

    } else if (coreotn_handle->var.init_operation == COREOTN_SS_BYPASS_MODE ) {

        /* FMF1 RFRM 12 */
        if (PMC_SUCCESS == ret_val)
        {
            /* configure stage 1 RFRM to pass PM transparently (PM_NIM) for no muxing */

            if(prov_rfrm_tfrm_cfg)
            {
                ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stg1_handle, chnl_id, 1, 0);
            }
  
            /* Activate HO channel DB entries in order to make them visible for FO1:MPMPA */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = coreotn_db_ho_entry_activate(coreotn_handle,UTIL_GEN_DB_LINE_CORE_OTN_RX_DB,chnl_id);
            }

        }
    }

    if ((coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)) {

        /* program FMF1 blocks for passthru */

        if (PMC_SUCCESS == ret_val &&
            prov_rfrm_tfrm_cfg) 
        {
            /* configure stage 1 RFRM to pass PM transparently (PM_NIM) for no muxing */
            
            ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stg1_handle, chnl_id, 1, 0);                                                    
        }

        if (PMC_SUCCESS == ret_val)
        {       
            /* channel in passthru through stage 2 framer */
            ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stg2_handle,
                                         chnl_id, 0, 0);
        } 

        if (PMC_SUCCESS == ret_val)
        {
            /* put unchannelized channel in passthru in first stage DMX */
            ret_val = odtu_dmx_chnl_init(coreotn_handle->odtu_dmx1_handle,
                                         chnl_id,
                                         ODTU_DMX_CHNL_UNCHANNELIZED);
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* configure unchannelized channel in first stage DMX */
            ret_val = odtu_dmx_ho_chnl_prov(coreotn_handle->odtu_dmx1_handle, 
                                            ODTU_DMX_STG_NONE,
                                            chnl_id,
                                            odu_container,
                                            payload_format);
        }

        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_switch_cfg(coreotn_handle->odtu_dmx1_handle,
                                                  chnl_id, FALSE);
        }
        
        if (TRUE == pmc_coreotn_enable_odujat_revision(&coreotn_handle->base))
        {
            /* In no muxing, keep ODUJAT in FMF1 in bypass */
            if (PMC_SUCCESS == ret_val)
            {
                odujat_enable = ODUJAT_CHNL_ENABLED;
            }
        }
        else
        {
            /* In no muxing, keep ODUJAT in FMF1 in bypass */
            if (PMC_SUCCESS == ret_val)
            {
                odujat_enable = ODUJAT_CHNL_IN_BYPASS;
            }
        }

        /* ODUJAT1 */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odujat_chnl_prov(coreotn_handle->odujat1_handle, 
                                       chnl_id, mux_stage, DO_NOT_USE_KEY,
                                       odu_container, odu_container, 0, 0, 
                                       odujat_enable,
                                       FALSE);
        }


        /* ODUKSC_1 */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = oduksc_chnl_prov(coreotn_handle->oduksc1_handle, chnl_id,
                                       odu_container, odu_container, 0,
                                       UTIL_GLOBAL_NO_MAP, 0);
        }

        if (PMC_SUCCESS == ret_val)
        {
            ret_val = oduksc_chnl_update(coreotn_handle->oduksc1_handle, chnl_id, TRUE);
        }
    }

    if (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) {

        /* program FMF2 blocks for passthru mode */
        if (PMC_SUCCESS == ret_val)
        {
            /* channel in passthru through stage 3A framer */
            ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stg3a_handle, 
                                         chnl_id, 0, 0);
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* put unchannlized channel in passthru in second stage DMX */
            ret_val = odtu_dmx_chnl_init(coreotn_handle->odtu_dmx2_handle,
                                         chnl_id,
                                         ODTU_DMX_CHNL_UNCHANNELIZED );
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* configure unchannlized channel in second stage DMX */
            ret_val = odtu_dmx_ho_chnl_prov(coreotn_handle->odtu_dmx2_handle, 
                                            (odtu_dmx_stage_instance_t)0,
                                            chnl_id, 
                                            odu_container,
                                            payload_format);
        }

        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_switch_cfg(coreotn_handle->odtu_dmx2_handle,
                                                  chnl_id, FALSE);
        }
        
        if (TRUE == pmc_coreotn_enable_odujat_revision(&coreotn_handle->base))
        {
            /* In no muxing, keep ODUJAT in FMF2 in bypass */
            if (PMC_SUCCESS == ret_val)
            {
                odujat_enable = ODUJAT_CHNL_ENABLED;
            }
        }
        else
        {
            /* In no muxing, keep ODUJAT in FMF2 in bypass */
            if (PMC_SUCCESS == ret_val)
            {
                odujat_enable = ODUJAT_CHNL_IN_BYPASS;
            }
        }

        /* ODUJAT_2 */
        if (PMC_SUCCESS == ret_val)
        {                                     
            ret_val = odujat_chnl_prov(coreotn_handle->odujat2_handle, chnl_id,
                                       mux_stage, DO_NOT_USE_KEY, odu_container, 
                                       odu_container, 0, 0, odujat_enable, FALSE);
        }

        /* ODUKSC_2 */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = oduksc_chnl_prov(coreotn_handle->oduksc2_handle, chnl_id, 
                                       odu_container, odu_container, 0, 
                                       UTIL_GLOBAL_NO_MAP, 0);
        }

        if (PMC_SUCCESS == ret_val)
        {
            ret_val = oduksc_chnl_update(coreotn_handle->oduksc2_handle, chnl_id, TRUE);
        }

    }

    if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE) {
        
        /* SN RFRM */
        if (PMC_SUCCESS == ret_val)
        {
            /* configure stage 1 RFRM to pass PM transparently (PM_NIM) for no muxing */
            
            ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stgN_handle, chnl_id, 1, 0);            
            
            /* Activate HO channel DB entries in order to make them visible for FO1:MPMPA */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = coreotn_db_ho_entry_activate(coreotn_handle,UTIL_GEN_DB_LINE_CORE_OTN_RX_DB,chnl_id);
            }
        }
    }

    if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE) {

        /* SN RFRM and FMF2 blocks in passthru */
        if (PMC_SUCCESS == ret_val)
        {
            /* configure stage 1 RFRM to pass PM transparently (PM_NIM) for no muxing */
            
            ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stgN_handle, 
                                         chnl_id, 1, 0);
        }

        if (PMC_SUCCESS == ret_val)
        {       
            /* channel in passthru through stage 2 framer */
            ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stg3a_handle, 
                                         chnl_id, 0, 0);
        } 

        if (PMC_SUCCESS == ret_val)
        {
            /* put unchannelized channel in passthru in first stage DMX */
            ret_val = odtu_dmx_chnl_init(coreotn_handle->odtu_dmx2_handle,
                                         chnl_id,
                                         ODTU_DMX_CHNL_UNCHANNELIZED);
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* configure unchannelized channel in first stage DMX */
            ret_val = odtu_dmx_ho_chnl_prov(coreotn_handle->odtu_dmx2_handle,
                                            ODTU_DMX_STG_NONE,
                                            chnl_id,
                                            odu_container,
                                            payload_format);
        }
        
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_switch_cfg(coreotn_handle->odtu_dmx2_handle,
                                                  chnl_id, FALSE);
        }

        /* ODUJAT1 */
        /* In no muxing, keep ODUJAT in FMF1 in bypass */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odujat_chnl_prov(coreotn_handle->odujat2_handle, 
                                       chnl_id, mux_stage, DO_NOT_USE_KEY,
                                       odu_container, odu_container, 0, 0,
                                       ODUJAT_CHNL_IN_BYPASS, FALSE);
        }

        /* ODUKSC_2 */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = oduksc_chnl_prov(coreotn_handle->oduksc2_handle, chnl_id, 
                                       odu_container, odu_container, 0, 
                                       UTIL_GLOBAL_NO_MAP, 0);
        }       
                                        
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = oduksc_chnl_update(coreotn_handle->oduksc2_handle, chnl_id, TRUE);
        }
    } 

    /* take FRM_RCP CFC FIFO out of reset as by default RCP_EN = 1 */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle, COREOTN_FO1_FRM_RCP,
                                           chnl_id, 1);
    }

    if (PMC_SUCCESS == ret_val)
    {
        /* update the channel state */
        coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_IN_PASSTHRU;
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_IN_PASSTHRU;
        coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_IN_PASSTHRU;

        /* update the payload format */
        coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].payload_format = payload_format;
        coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].odu_container = odu_container;

        /* update the number of provisioned channel */
        coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnls_prov_cnt++;
        coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].sub_chnls_prov_cnt = 0;
    }

    PMC_RETURN(ret_val);
} /* coreotn_rx_ho_chnl_mux_none_prov */

/*******************************************************************************
*  coreotn_rx_ho_chnl_mux_one_prov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_ho_chnl_prov for the 
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   odu_container       - ODUk type. See odukp_type_enum.
*                         Valid range: ODU2 to ODU4
*   payload_format      - payload format of the ODUk traffic carried by this HO
*                         channel. See odu_line_payload_t.
*   prov_rfrm_tfrm_cfg  - TRUE : Provision RFRM configs
*                         FALSE : Do not provision RFRM configs 
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_one_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t odu_container,
                                                  util_global_odu_line_payload_t payload_format,
                                                  BOOL prov_rfrm_tfrm_cfg)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    odtu_dmx_chnl_mode_t dmx_chnl_mode;
    util_global_odu_line_payload_t sysotn_payload;
    PMC_ENTRY();

    if (coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START) 
    {

        ret_val = COREOTN_ERR_CHNL_STATE_NOT_START;

        /* If performing muxing (eg. mux_stage == COREOTN_MUX_STAGE_ONE || mux_stage == COREOTN_MUX_STAGE_TWO)
           then the second stage blocks will be set-up when the LO is provisioned
           MUX_STAGE_ONE and BYPASS is an invalid mode (considered in error checking */
    } else if ((coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE) ||
               (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)) {


        if(prov_rfrm_tfrm_cfg)
        {
            if (PMC_SUCCESS == ret_val)
            {   
                /* configure stage 1 RFRM to terminate PM in one stage muxing */
                ret_val = odu_rfrm_chnl_prov(coreotn_handle->odu_rfrm_stg1_handle,
                                             chnl_id,
                                             TRUE, 
                                             1, 0, TRUE);
            }

            /* we can activate stage 1 RFRM here because we have LINEOTN generating upstream calendar */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stg1_handle, 
                                             chnl_id, 1, 0);
            }
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* Initialize demux... either CHANNELIZED (muxing) or NULL frame mode (terminating)
            ** This is for HO channel
            */ 
            if (payload_format == UTIL_GLOBAL_ODU_NULL)
            {
                ret_val = odtu_dmx_chnl_init(coreotn_handle->odtu_dmx1_handle,
                                             chnl_id,
                                             ODTU_DMX_CHNL_NULL_FRAME_MODE);
            } else {
                ret_val = odtu_dmx_chnl_init(coreotn_handle->odtu_dmx1_handle,
                                             chnl_id,
                                             ODTU_DMX_CHNL_CHANNELIZED);
            }
        }                                                                                 

        if (PMC_SUCCESS == ret_val)
        {
            
            if ( payload_format != UTIL_GLOBAL_ODU_NULL) 
            {
                ret_val = odtu_dmx_ho_chnl_prov(coreotn_handle->odtu_dmx1_handle,
                                                ODTU_DMX_STG_ONE,
                                                chnl_id, odu_container,
                                                payload_format);
            } else {
                ret_val = odtu_dmx_ho_chnl_prov(coreotn_handle->odtu_dmx1_handle, 
                                                ODTU_DMX_STG_ONE,
                                                chnl_id, odu_container,
                                                UTIL_GLOBAL_ODU_TS_1G25);

            }
        }

    } 
    else if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE) 
    {

        /* SN framer, FMF2 blocks for 1x muxing */

        /* Initialize demux... either CHANNELIZED (muxing) or NULL frame mode (terminating)*/ 
        if ( payload_format == UTIL_GLOBAL_ODU_NULL) {

            dmx_chnl_mode = ODTU_DMX_CHNL_NULL_FRAME_MODE;
            /*in NULL frame mode, the payload_format is a don't care */
            sysotn_payload = UTIL_GLOBAL_ODU_TS_1G25;

        } else {

            dmx_chnl_mode = ODTU_DMX_CHNL_CHANNELIZED;
            sysotn_payload = payload_format;
        }

        if(prov_rfrm_tfrm_cfg)
        {
            if (PMC_SUCCESS == ret_val) 
            { 
                /* configure stage 1 RFRM to terminate PM in one stage muxing */
                ret_val = odu_rfrm_chnl_prov(coreotn_handle->odu_rfrm_stgN_handle,
                                             chnl_id,
                                             TRUE, 
                                             1, 0, TRUE);                                             
            }

            /* enable ODU_RFRM channel because SYSOTN is generating upstream calendar */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stgN_handle, 
                                             chnl_id, 1, 0);    
            }
        }
        
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_chnl_init(coreotn_handle->odtu_dmx2_handle,
                                         chnl_id,
                                         dmx_chnl_mode);
        }                                                                                 

        if (PMC_SUCCESS == ret_val)
        {

            ret_val = odtu_dmx_ho_chnl_prov(coreotn_handle->odtu_dmx2_handle,
                                            ODTU_DMX_STG_ONE,
                                            chnl_id, odu_container,
                                            sysotn_payload);
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        /* update channel state */
        coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
        
        /* update the payload format */
        coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].payload_format = payload_format;
        coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].odu_container = odu_container;
      
        /* update the number of provisioned channels */
        coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnls_prov_cnt++;
       
    }

    PMC_RETURN(ret_val);
} /* coreotn_rx_ho_chnl_mux_one_prov */

/*******************************************************************************
*  coreotn_rx_ho_chnl_mux_two_prov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_ho_chnl_prov for the 
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   odu_container       - ODUk type. See odukp_type_enum.
*                         Valid range: ODU2 to ODU4
*   payload_format      - payload format of the ODUk traffic carried by this HO
*                         channel. See odu_line_payload_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_two_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t odu_container,
                                                  util_global_odu_line_payload_t payload_format)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    odtu_dmx_chnl_mode_t mode;
    
    PMC_ENTRY();

    if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_START);
    }  

    if (PMC_SUCCESS == ret_val)
    {
        if (payload_format != UTIL_GLOBAL_ODU_NULL) 
        {
            if (TRUE == pmc_coreotn_dmx_two_stage_proxy_mo_chnl_prov_revision(&coreotn_handle->base)
                && coreotn_handle->var.prov_mode != COREOTN_ODU_CHNL_PROV_ALL
                && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format != UTIL_GLOBAL_ODU_UNCHANNELIZED
                && coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
            {
                mode = ODTU_DMX_CHNL_NULL_FRAME_MODE;
            }
            else if (TRUE == pmc_coreotn_dmx_two_stage_proxy_mo_chnl_prov_revision(&coreotn_handle->base)
                     && coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL
                     && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format != UTIL_GLOBAL_ODU_UNCHANNELIZED)
            {
                mode = ODTU_DMX_CHNL_NULL_FRAME_MODE;
            }
            else {
                mode = ODTU_DMX_CHNL_CHANNELIZED;
            }
                    
            /* put unchannelized channel in passthru in second stage DMX */
            ret_val = odtu_dmx_chnl_init(coreotn_handle->odtu_dmx2_handle,
                                         chnl_id, mode);
        }
        else {
            /* This is for MO channel */
            /* NULL frame mode */
            ret_val = odtu_dmx_chnl_init(coreotn_handle->odtu_dmx2_handle,
                                         chnl_id, ODTU_DMX_CHNL_NULL_FRAME_MODE);
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        if (payload_format != UTIL_GLOBAL_ODU_NULL)
        {
            ret_val = odtu_dmx_ho_chnl_prov(coreotn_handle->odtu_dmx2_handle, 
                                            (odtu_dmx_stage_instance_t)ODTU_DMX_STG_TWO,
                                            chnl_id, odu_container, payload_format);
        }
        else {
            /* This is for MO channel */
            /*in NULL frame mode, the payload_format is a don't care */
            ret_val = odtu_dmx_ho_chnl_prov(coreotn_handle->odtu_dmx2_handle, 
                                            ODTU_DMX_STG_TWO,
                                            chnl_id, odu_container,
                                            UTIL_GLOBAL_ODU_TS_1G25);
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        /* update the channel state */  
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
        
        if (payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
        {
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_IN_PASSTHRU;
        }
        
        /* update the payload format */
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format = payload_format;
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].odu_container = odu_container;
    }

    PMC_RETURN(ret_val);
} /* coreotn_rx_ho_chnl_mux_two_prov */

/*******************************************************************************
*  coreotn_tx_ho_chnl_mux_none_prov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_ho_chnl_prov for the 
*   mux_stage == COREOTN_MUX_STAGE_NONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   odu_container       - ODUk type. See odukp_type_enum.
*                         Valid range: ODU2 to ODU4
*   payload_format      - payload format of the ODUk traffic carried by this HO
*                         channel. See odu_line_payload_t.
*   prov_rfrm_tfrm_cfg  - TRUE : provision HO TFRM configuration
*                         FALSE : preserve current HO TFRM configuration
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_none_prov(coreotn_handle_t *coreotn_handle,
                                                   UINT32 chnl_id,
                                                   coreotn_mux_stage_t mux_stage,
                                                   util_global_odukp_type_t odu_container,
                                                   util_global_odu_line_payload_t payload_format,
                                                   BOOL prov_rfrm_tfrm_cfg)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    odu_tfrm_handle_t* tfrm_handle_ptr = NULL;
    odtu_mux_handle_t* mux_handle_ptr = NULL;
    coreotn_frm_rcp_inst_t frm_rcp_inst;
    PMC_ENTRY();

    /* check the current channel state */
    if (coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START
        && coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START
        && coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_START);
    }

    if ((coreotn_handle->var.init_operation == COREOTN_SS_BYPASS_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE) || 
        (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)) 
    {
    
        tfrm_handle_ptr = coreotn_handle->odu_tfrm_stg1_handle;
        mux_handle_ptr = coreotn_handle->odtu_mux1_handle;
        frm_rcp_inst = COREOTN_FMF1_FRM_RCP12;

    } 
    else if ((coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE) ||  
               (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)) 
    {

        tfrm_handle_ptr = coreotn_handle->odu_tfrm_stgN_handle;
        mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
        frm_rcp_inst = COREOTN_FMF2_FRM_RCP12;
    }

    if ((coreotn_handle->var.init_operation == COREOTN_SS_BYPASS_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE) || 
        (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE) ||  
        (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)) 
    {



        if(prov_rfrm_tfrm_cfg)
        {
            /*first stage TFRM */
            /*Take out of passthru.  Do not provision PM layer */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odu_tfrm_chnl_init(tfrm_handle_ptr, chnl_id, 1);
            }        

            /* Take FRM_RCP CFC FIFO out of reset */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle, frm_rcp_inst,
                                                   chnl_id, 1);
            }
        }

        if (coreotn_handle->var.init_operation == COREOTN_SS_BYPASS_MODE ||
            coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE )
        {
            /* Activate HO channel DB entries in order to make them visible for FO1:MPMO */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = coreotn_db_ho_entry_activate(coreotn_handle,UTIL_GEN_DB_LINE_CORE_OTN_TX_DB,chnl_id);
            }
        } 
        else 
        {
            /* MUX1 stage in PASSTHRU */
            if (PMC_SUCCESS == ret_val)
            {
                /* put unchannelized channel in passthru in first stage MUX */
                ret_val = odtu_mux_chnl_init(mux_handle_ptr,
                                             chnl_id, 
                                             ODTU_MUX_CHNL_UNCHANNELIZED);
            }
            
            if (PMC_SUCCESS == ret_val)
            {
                /* accesses the first MUX for the HO channel based configuration */
                ret_val = odtu_mux_ho_chnl_prov(mux_handle_ptr, 0,
                                                chnl_id, odu_container,
                                                payload_format, FALSE);
            }
        }
      
    }

    if (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) 
    {
        if (PMC_SUCCESS == ret_val)
        {
            /* put unchannlized channel in passthru in second stage DMX */
            ret_val = odtu_mux_chnl_init(coreotn_handle->odtu_mux2_handle,
                                         chnl_id,
                                         ODTU_MUX_CHNL_UNCHANNELIZED);
        }
        
        if (PMC_SUCCESS == ret_val)
        {
            /* accesses the first MUX for the HO channel based configuration */
            ret_val = odtu_mux_ho_chnl_prov(coreotn_handle->odtu_mux2_handle, 0,
                                            chnl_id, odu_container,
                                            payload_format, FALSE);
        }

    }

    if (PMC_SUCCESS == ret_val)
    {
        /* update channel state */
        coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_IN_PASSTHRU;
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_IN_PASSTHRU;
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_IN_PASSTHRU;

        /* update payload format */
        coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].payload_format = payload_format;
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].payload_format = payload_format;
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].payload_format = payload_format;

        /* update HO ODU rate */
        coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].odu_container = odu_container;
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].odu_container = odu_container;
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].odu_container = odu_container;

        /* update the number of provisioned channel */
        coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnls_prov_cnt++;
        coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].sub_chnls_prov_cnt = 0;
    }

    PMC_RETURN(ret_val);
} /* coreotn_tx_ho_chnl_mux_none_prov */

/*******************************************************************************
*  coreotn_tx_ho_chnl_mux_one_prov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_ho_chnl_prov for the 
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   odu_container       - ODUk type. See odukp_type_enum.
*                         Valid range: ODU2 to ODU4
*   payload_format      - payload format of the ODUk traffic carried by this HO
*                         channel. See odu_line_payload_t.
*   prov_rfrm_tfrm_cfg  - TRUE : provision HO TFRM
*                         FALSE : preserve current HO TFRM configuration
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_one_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t odu_container,
                                                  util_global_odu_line_payload_t payload_format,
                                                  BOOL prov_rfrm_tfrm_cfg)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    odu_tfrm_inst_t tfrm_type;
    odu_tfrm_handle_t* odu_tfrm_ptr = NULL;
    odtu_mux_handle_t* mux_handle_ptr = NULL;
    odtu_mux_chnl_mode_t mux_chnl_mode;
    util_global_odu_line_payload_t new_payload = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
    BOOL8 frame_enable;
    BOOL prbs_null_chan = FALSE;
    PMC_ENTRY();

    /* check the current channel state */
    if (coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)
    {
        ret_val = COREOTN_ERR_CHNL_STATE_NOT_START;

    } 
    else if ((coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE) ||
               (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)) 
    {
        tfrm_type = ODU_TFRM_STG1;
        odu_tfrm_ptr = coreotn_handle->odu_tfrm_stg1_handle;
        mux_handle_ptr = coreotn_handle->odtu_mux1_handle;

    } 
    else if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE) 
    {
        tfrm_type = ODU_TFRM_STGN;
        odu_tfrm_ptr = coreotn_handle->odu_tfrm_stgN_handle;
        mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
    }

    if ((coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)) 
    {

        if(ret_val == PMC_SUCCESS)
        {
            ret_val = coreotn_prbs_null_chan_en_get(coreotn_handle,
                                                    mux_stage,
                                                    chnl_id,
                                                    &prbs_null_chan);
        }



        if (payload_format == UTIL_GLOBAL_ODU_NULL) 
        {
            mux_chnl_mode = ODTU_MUX_NULL_FRAME_MODE;
            new_payload = UTIL_GLOBAL_ODU_TS_1G25;
            frame_enable = TRUE;

        } 

        else {

            mux_chnl_mode = ODTU_MUX_CHNL_CHANNELIZED;
            new_payload = payload_format;
            frame_enable = prbs_null_chan;
        }

        if(prov_rfrm_tfrm_cfg)
        {
            if (PMC_SUCCESS == ret_val)
            {
                /* This is for HO channel */
                /* configure the first STG framer */
                /* provision the PM layer */
                ret_val = coreotn_odu_tfrm_chnl_init(coreotn_handle, 
                                                     (odu_tfrm_inst_t)tfrm_type,
                                                     chnl_id, 1);
            }
            
            /* take the channel out of passthru */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odu_tfrm_chnl_init(odu_tfrm_ptr, chnl_id, 1);
            }
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* This is for HO channel */
            /* MUX is either MUXing (CHANNELIZED) or sourcing (NULL_FRAME_MODE) */
            ret_val = odtu_mux_chnl_init(mux_handle_ptr,
                                         chnl_id, 
                                         mux_chnl_mode);
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* this is needed separate from chnl_init since 
            ** this is HO based config
            */
            ret_val = odtu_mux_null_chnl_cfg(mux_handle_ptr,
                                             chnl_id,
                                             frame_enable);
        }

        if (PMC_SUCCESS == ret_val)
        {

            /* accesses the first MUX for the HO channel based configuration */ 
            ret_val = odtu_mux_ho_chnl_prov(mux_handle_ptr, 1,
                                            chnl_id, odu_container,
                                            new_payload, FALSE); 

        } 

        /* avoid frame slip in an empty HO */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_dbg_mask_somf_sync_set(mux_handle_ptr,
                                                      chnl_id, 1);
        }

    }

    if (PMC_SUCCESS == ret_val)
    {
        /* update channel state */
        coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
  
        coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].payload_format = payload_format;

        /* update HO ODU rate */
        coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].odu_container = odu_container;

        /* update the number of provisioned channels */
        coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnls_prov_cnt++;
    }

    PMC_RETURN(ret_val);
} /* coreotn_tx_ho_chnl_mux_one_prov */

/*******************************************************************************
*  coreotn_tx_ho_chnl_mux_two_prov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_ho_chnl_prov for the 
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   odu_container       - ODUk type. See odukp_type_enum.
*                         Valid range: ODU2 to ODU4
*   payload_format      - payload format of the ODUk traffic carried by this HO
*                         channel. See odu_line_payload_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_two_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t odu_container,
                                                  util_global_odu_line_payload_t payload_format)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    BOOL prbs_null_chan;
    PMC_ENTRY();

    /* check the current channel state */
    if (coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED);
    }    
    
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle, COREOTN_FMF2_FRM_RCP96,
                                           chnl_id, 1);
    }

    
    if(ret_val == PMC_SUCCESS)
    {
        ret_val = coreotn_prbs_null_chan_en_get(coreotn_handle,
                                                mux_stage,
                                                chnl_id,
                                                &prbs_null_chan);
    }



    if (PMC_SUCCESS == ret_val)
    {
        if (payload_format == UTIL_GLOBAL_ODU_NULL ||
            prbs_null_chan) 
        {
            /* this is needed separate from chnl_init since 
            ** this is HO/MO based config
            */
            ret_val = odtu_mux_null_chnl_cfg(coreotn_handle->odtu_mux2_handle,
                                             chnl_id, 1);

        } else {

            /* this is needed separate from chnl_init since 
            ** this is HO based config
            */
            ret_val = odtu_mux_null_chnl_cfg(coreotn_handle->odtu_mux2_handle,
                                             chnl_id, 0); 
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        if (payload_format == UTIL_GLOBAL_ODU_NULL) 
        {
            /* For NULL FRAME mode, ts_type is a don't care */
            ret_val = odtu_mux_ho_chnl_prov(coreotn_handle->odtu_mux2_handle, 2,
                                            chnl_id, odu_container,
                                            UTIL_GLOBAL_ODU_TS_1G25, FALSE);
        } 
        else 
        {

            /* clear PASSTHRU bit for the HO channel */
            ret_val = odtu_mux_chnl_init(coreotn_handle->odtu_mux2_handle,
                                         chnl_id, ODTU_MUX_CHNL_CHANNELIZED);
            
            if (PMC_SUCCESS == ret_val)
            {
            
                /* if two stage muxing, connect the second stage DMX */
                ret_val = odtu_mux_ho_chnl_prov(coreotn_handle->odtu_mux2_handle, 2,
                                                chnl_id, odu_container, payload_format, FALSE);
            }
            
            /* if MO ODU3e2 or MO ODU3e1, store the calendar entry info in the context
            ** to be used in deprovisioning
            */
            if (PMC_SUCCESS == ret_val
                && (odu_container == UTIL_GLOBAL_ODU3E1 
                    || odu_container == UTIL_GLOBAL_ODU3E2))
            {
                if (coreotn_handle->var.extra_entry_ctxt[0].entry_state == FALSE)
                {
                    if (coreotn_handle->odtu_mux2_handle->var.dummy_schd_entry[0].dummy_mo_ch_id == chnl_id)
                    {
                        coreotn_handle->var.extra_entry_ctxt[0].entry_state = TRUE;
                        coreotn_handle->var.extra_entry_ctxt[0].chnl_id = chnl_id;
                        coreotn_handle->var.extra_entry_ctxt[0].cycle = coreotn_handle->odtu_mux2_handle->var.dummy_schd_entry[0].dummy_cal_entry;
                    }
                }
                else if (coreotn_handle->var.extra_entry_ctxt[1].entry_state == FALSE)
                {
                    if (coreotn_handle->odtu_mux2_handle->var.dummy_schd_entry[1].dummy_mo_ch_id == chnl_id)
                    {
                        coreotn_handle->var.extra_entry_ctxt[1].entry_state = TRUE;
                        coreotn_handle->var.extra_entry_ctxt[1].chnl_id = chnl_id;
                        coreotn_handle->var.extra_entry_ctxt[1].cycle = coreotn_handle->odtu_mux2_handle->var.dummy_schd_entry[1].dummy_cal_entry;
                    }
                }
            }                                                                  
        }
    }

    /* avoid frame slip in an empty HO */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = odtu_mux_dbg_mask_somf_sync_set(coreotn_handle->odtu_mux2_handle, 
                                                  chnl_id, 1);
    }

    if (PMC_SUCCESS == ret_val)
    {
        /* update channel state */
        if (payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
        {    
            coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_IN_PASSTHRU;
        }
        
        /* update channel state */
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].payload_format = payload_format;

        /* update HO ODU rate */
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].odu_container = odu_container;
    }

    PMC_RETURN(ret_val);
} /* coreotn_tx_ho_chnl_mux_two_prov */

/*******************************************************************************
*  coreotn_rx_lo_chnl_mux_one_prov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_lo_chnl_prov for the 
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   lo_odu_type         - LO ODUj type. See odukp_type_enum.
*                         Valid range: all available oduk types.
*   odu_flex_rate       - number of ODU0's in ODUFlex client if lo_odu_type is 
*                         ODUFLEX_GFP. For all other lo_odu_type, set to 0.
*   client_rate         - ODUFlex client bitrate in kbps if lo_odu_type is set 
*                         to ODUFLEX_CBR. For all other lo_odu_type, set to 0.
*   mapping_mode        - mapping type used. See coreotn_mapping_type_t.
*   tribslot_mask       - 3 x 32 bit mask to represent the tributary slot
*                         assignment for this LO channel.\n
*                         Valid range: 0 - 0x4F\n
*                         Bit 0 -- Tributary slot 1\n
*                         Bit 1 -- Tributary slot 2\n
*                         Bit 2 -- Tributary slot 3\n
*                                ...\n
*                         Bit 79 -- Tributary slot 80\n
*                         NOTE : This is a "normalized" view of the server (so, if
*                                adding a client to an ODU2 server, only bits 0-7
*                                of tribslot_mask[0] can get set.
*                                In the event of 2.5G TS ODU2, only bits 0-3 can
*                                get set.
*        
*   trib_port           - a tributary port number for all tributary slot
*                         locations for the LO channel. This data is used for
*                         MSI coding.\n
*                         For the following payload types with fixed MSI
*                         assignment, this argument is ignored and MSI data is
*                         assigned internally as per G.709 standards:\n
*                         -- ODTU01\n
*                         -- ODTU12 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU2)\n
*                         -- ODTU13 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU3)
*   payload_format      - tributary slot size. See util_global_odu_line_payload_t.
*   ho_odu_type         - HO ODU container type that the LO ODU belongs to
*   ho_chnl_id          - HO channel ID that this LO belongs to.
*                         Valid range: 0 - 95
*   client_bitrate      - The client bitrate based on the client_rate.
*   prov_rfrm           - TRUE : provision RFRM
*                         FALSE : preserve current RFRM configuration
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_one_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t lo_odu_type,
                                                  UINT32 odu_flex_rate,
                                                  DOUBLE client_rate,
                                                  coreotn_mapping_type_t mapping_mode,
                                                  UINT32 tribslot_mask[COREOTN_TRIB_WRD_CNT],
                                                  UINT32 trib_port,
                                                  util_global_odu_line_payload_t payload_format,
                                                  util_global_odukp_type_t ho_odu_type,
                                                  UINT32 ho_chnl_id,
                                                  UINT32 client_bitrate,
                                                  BOOL prov_rfrm)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 i;
    util_global_odu_line_payload_t ho_payload_format;
    odujat_chnl_mode_t odujat_enable = ODUJAT_CHNL_IN_BYPASS;
    coreotn_odu_chnl_prov_mode_t prov_mode;
    BOOL8 super_prov = FALSE;

    PMC_ENTRY();

    /* check the channel state */
    if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_INVALID_STATE);
    }
    

    PMC_LOG_TRACE("mux_stage = COREOTN_MUX_STAGE_ONE = %u\n", mux_stage);

    ho_payload_format = coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].payload_format;
    
    /* retreive coreotn provision mode */
    ret_val = coreotn_odu_chnl_prov_mode_get(coreotn_handle, &prov_mode);
           
    if (PMC_SUCCESS == ret_val)
    {
        super_prov = (prov_mode == COREOTN_ODU_CHNL_PROV_ALL)? TRUE:FALSE;
    }

    if ((coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE) || 
        (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)) 
    {
        /*
        ** Check if this is the first LO channel being provisioned in DMX
        ** Put HO channel in reset
        */
        if (TRUE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base))
        {
            if (coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 0)
            {
                /* this is the first LO channel */
                /* Channel is in reset by configuring HO_CH_RSTB to '0' */
                ret_val = odtu_dmx_ho_chnl_reset_cfg(coreotn_handle->odtu_dmx1_handle, ho_chnl_id, FALSE);          
            }
        }
        
        if (PMC_SUCCESS == ret_val)
        {
            PMC_LOG_TRACE("before calling odtu_dmx_lo_chnl_prov() first time, mux stage = %u\n", COREOTN_MUX_STAGE_ONE);
            /* access the first DMX for the LO channel configuration */
            ret_val = odtu_dmx_lo_chnl_prov(coreotn_handle->odtu_dmx1_handle,
                                            chnl_id, 
                                            (odtu_dmx_stage_instance_t)COREOTN_MUX_STAGE_ONE,
                                            lo_odu_type, 
                                            odu_flex_rate, 
                                            (UINT32)client_bitrate, 
                                            ho_odu_type,
                                            (util_global_mapping_mode_t)mapping_mode, 
                                            tribslot_mask,
                                            trib_port, 
                                            payload_format,
                                            ho_chnl_id, FALSE, FALSE);
        }

        /* for two stage muxing, enable ODUJAT in FMF1 */
        /* In one stage muxing, we want to keep this ODUJAT in bypass */
        if (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE)
        {
            odujat_enable = ODUJAT_CHNL_IN_BYPASS;
        }
        else 
        {
            if (payload_format != UTIL_GLOBAL_ODU_UNCHANNELIZED)
            {
                /* this is going to be 2-stage muxing */
                odujat_enable = ODUJAT_CHNL_ENABLED;
            }
        }

        if (TRUE == pmc_coreotn_enable_odujat_revision(&coreotn_handle->base))
        {
            odujat_enable = ODUJAT_CHNL_ENABLED;
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* ODUJAT1 */
            ret_val = odujat_chnl_prov(coreotn_handle->odujat1_handle, chnl_id,
                                       mux_stage, ho_chnl_id, ho_odu_type, lo_odu_type, 
                                       odu_flex_rate, client_bitrate,
                                       odujat_enable, super_prov);
        }                                          

        /* ODUKSC_1 */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = oduksc_chnl_prov(coreotn_handle->oduksc1_handle, chnl_id,
                                       ho_odu_type, lo_odu_type, client_bitrate,
                                       (util_global_mapping_mode_t)mapping_mode, odu_flex_rate);
        }
            
        /* in normal prov mode, configure the standby page of ODUKSC and
        ** swap the page
        */
        if (prov_mode != COREOTN_ODU_CHNL_PROV_ALL)
        {
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = oduksc_chnl_update(coreotn_handle->oduksc1_handle, chnl_id, TRUE);
            }
        }

        if (payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
        {
            /* set up FMF2 for passthru if COREOTN set up for 2x muxing*/
            if (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)
            {
                if (PMC_SUCCESS == ret_val)
                {
                    /* Initialize demux for passthru */
                    ret_val = odtu_dmx_chnl_init(coreotn_handle->odtu_dmx2_handle,
                                                 chnl_id,
                                                 ODTU_DMX_CHNL_UNCHANNELIZED);
                }

                if (PMC_SUCCESS == ret_val)
                {

                    ret_val = odtu_dmx_ho_chnl_prov(coreotn_handle->odtu_dmx2_handle, 
                                                    ODTU_DMX_STG_TWO,
                                                    chnl_id, lo_odu_type,
                                                    payload_format);
                }
                 
                if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
                {
                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = odtu_dmx_ho_chnl_switch_cfg(coreotn_handle->odtu_dmx2_handle,
                                                              chnl_id, FALSE);
                    }
                }
                
                if (TRUE == pmc_coreotn_enable_odujat_revision(&coreotn_handle->base))
                {
                    if (PMC_SUCCESS == ret_val)
                    {
                        odujat_enable = ODUJAT_CHNL_ENABLED;
                    }
                }
                else
                {
                    /* In one muxing, keep ODUJAT in FMF2 in bypass */
                    if (PMC_SUCCESS == ret_val)
                    {
                        odujat_enable = ODUJAT_CHNL_IN_BYPASS;
                    }
                }

                /* ODUJAT_2 */
                if (PMC_SUCCESS == ret_val) 
                {    
                    ret_val = odujat_chnl_prov(coreotn_handle->odujat2_handle, chnl_id,
                                               1, DO_NOT_USE_KEY, 
                                               lo_odu_type, lo_odu_type, 
                                               odu_flex_rate, client_bitrate,
                                               odujat_enable, super_prov);
                }                                             

                /* ODUKSC_2 */
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = oduksc_chnl_prov(coreotn_handle->oduksc2_handle, chnl_id, 
                                               lo_odu_type, lo_odu_type, client_bitrate, 
                                               UTIL_GLOBAL_NO_MAP, odu_flex_rate);
                }
                            
                if (PMC_SUCCESS == ret_val)
                {
                    if (prov_mode != COREOTN_ODU_CHNL_PROV_ALL)
                    {
                        ret_val = oduksc_chnl_update(coreotn_handle->oduksc2_handle, chnl_id, TRUE);
                    } 
                }                                  
            } /* end of if (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) */


            if(prov_rfrm)
            {
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stg2_handle, 
                                                 chnl_id, 1, 1);
                }
            }

            /* take FRM_RCP CFC FIFO out of reset as by default RCP_EN = 1 */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle, COREOTN_FO1_FRM_RCP,
                                                   chnl_id, 1);
            }


        }  /* end of if(payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED ) */
        else {

            if(prov_rfrm)
            {
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stg2_handle, 
                                                 chnl_id, 1, 1);
                }     
                  
                if (PMC_SUCCESS == ret_val)
                {
                    /* provision PM layer in the RFRM (2x muxing) */
                    ret_val = odu_rfrm_chnl_prov(coreotn_handle->odu_rfrm_stg2_handle,
                                                 chnl_id,
                                                 TRUE, 
                                                 1, 1, TRUE);
                }
            }
           
        }

        /* end of if init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE || COREOTN_SS_OPERATIONAL_MODE */ 

    } 
    else if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE) 
    {
        /*perform LO prov for the SYSOTN mode (FMF2)*/
        /*
        ** Check if this is the first LO channel being provisioned in DMX
        ** Put HO channel in reset
        */
        if (TRUE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base))
        {
            if (coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 0)
            {
                /* this is the first LO channel */
                /* Channel is in reset by configuring HO_CH_RSTB to '0' */
                ret_val = odtu_dmx_ho_chnl_reset_cfg(coreotn_handle->odtu_dmx2_handle, ho_chnl_id, FALSE); 
            
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = odtu_dmx_ho_chnl_prov(coreotn_handle->odtu_dmx2_handle, (odtu_dmx_stage_instance_t)1,
                                                    ho_chnl_id, ho_odu_type,
                                                    ho_payload_format);
                }
                
                if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
                {
                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = odtu_dmx_ho_chnl_switch_cfg(coreotn_handle->odtu_dmx2_handle,
                                                              ho_chnl_id, FALSE);
                    }
                }
            }
        }
        
        if (PMC_SUCCESS == ret_val)
        {
            PMC_LOG_TRACE("before calling odtu_dmx_lo_chnl_prov() first time, mux stage = %u\n", COREOTN_MUX_STAGE_ONE);
            /* access the first DMX for the LO channel configuration */
            ret_val = odtu_dmx_lo_chnl_prov(coreotn_handle->odtu_dmx2_handle,
                                            chnl_id, 
                                            (odtu_dmx_stage_instance_t)COREOTN_MUX_STAGE_ONE,
                                            lo_odu_type, 
                                            odu_flex_rate, 
                                            (UINT32)client_bitrate, 
                                            ho_odu_type,
                                            (util_global_mapping_mode_t)mapping_mode, 
                                            tribslot_mask,
                                            trib_port,
                                            payload_format,
                                            ho_chnl_id, FALSE, FALSE);
        }
          
        /* for two stage muxing, enable ODUJAT in FMF1 */
        /* In one stage muxing, we want to keep this ODUJAT in bypass */
        if (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE)
        {
            odujat_enable = ODUJAT_CHNL_IN_BYPASS;
        } 
        else 
        {
            if (payload_format != UTIL_GLOBAL_ODU_UNCHANNELIZED)
            {
                /* this is going to be 2-stage muxing */
                odujat_enable = ODUJAT_CHNL_ENABLED;
            }
        }

        /* ODUJAT1 */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odujat_chnl_prov(coreotn_handle->odujat2_handle, chnl_id,
                                       mux_stage, ho_chnl_id, ho_odu_type, lo_odu_type, 
                                       odu_flex_rate, client_bitrate,
                                       odujat_enable, super_prov);
        }

        /* ODUKSC_2 */
        if (PMC_SUCCESS == ret_val)
        {
            /* 
            ** ODUKSC2 performs a database lookup to get the calendar
            ** need to make sure this is working properly
            */
            ret_val = oduksc_chnl_prov(coreotn_handle->oduksc2_handle, chnl_id,
                                       ho_odu_type, lo_odu_type, client_bitrate,
                                       (util_global_mapping_mode_t)mapping_mode, odu_flex_rate);
        }

        if (PMC_SUCCESS == ret_val)
        {
            ret_val = oduksc_chnl_update(coreotn_handle->oduksc2_handle, chnl_id, TRUE);
        }

        /* this is the lowest ODU_RFRM in SYSOTN 1 stage muxing datapath */  
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stg3a_handle, 
                                         chnl_id, 1, 1);
        }

        /* take FRM_RCP CFC FIFO out of reset as by default RCP_EN = 1 */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle, COREOTN_FO1_FRM_RCP,
                                               chnl_id, 1);
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        /* update channel state */
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
        
        if (payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
        {
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_IN_PASSTHRU;
        }    

        /* update the payload format */
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format = payload_format;
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].odu_container = ho_odu_type;
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].lo_odu_rate = lo_odu_type;
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].odu_flex_rate = odu_flex_rate;
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].cbr_flex_rate = client_rate;
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].mapping_mode = mapping_mode;
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].trib_port = trib_port;

        for (i = 0; i < COREOTN_TRIB_WRD_CNT; i++)
        {
            coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].tribslot_mask[i] = tribslot_mask[i];

        }

        /* update the number of provisioned channels */
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnls_prov_cnt++;
        
        /* update the number of MO channels going into the HO */
        coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt++;
       
    }

    PMC_RETURN(ret_val);
} /* coreotn_rx_lo_chnl_mux_one_prov */

/*******************************************************************************
*  coreotn_rx_lo_chnl_mux_two_prov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_lo_chnl_prov for the 
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   lo_odu_type         - LO ODUj type. See odukp_type_enum.
*                         Valid range: all available oduk types.
*   odu_flex_rate       - number of ODU0's in ODUFlex client if lo_odu_type is 
*                         ODUFLEX_GFP. For all other lo_odu_type, set to 0.
*   client_rate         - ODUFlex client bitrate in kbps if lo_odu_type is set 
*                         to ODUFLEX_CBR. For all other lo_odu_type, set to 0.
*   mapping_mode        - mapping type used. See coreotn_mapping_type_t.
*   tribslot_mask       - 3 x 32 bit mask to represent the tributary slot
*                         assignment for this LO channel.\n
*                         Valid range: 0 - 0x4F\n
*                         Bit 0 -- Tributary slot 1\n
*                         Bit 1 -- Tributary slot 2\n
*                         Bit 2 -- Tributary slot 3\n
*                                ...\n
*                         Bit 79 -- Tributary slot 80\n
*                         NOTE : This is a "normalized" view of the server (so, if
*                                adding a client to an ODU2 server, only bits 0-7
*                                of tribslot_mask[0] can get set.
*                                In the event of 2.5G TS ODU2, only bits 0-3 can
*                                get set.
*        
*   trib_port           - a tributary port number for all tributary slot
*                         locations for the LO channel. This data is used for
*                         MSI coding.\n
*                         For the following payload types with fixed MSI
*                         assignment, this argument is ignored and MSI data is
*                         assigned internally as per G.709 standards:\n
*                         -- ODTU01\n
*                         -- ODTU12 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU2)\n
*                         -- ODTU13 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU3)
*   payload_format      - tributary slot size. See util_global_odu_line_payload_t.
*   ho_odu_type         - HO ODU container type that the LO ODU belongs to
*   ho_chnl_id          - HO channel ID that this LO belongs to.
*                         Valid range: 0 - 95
*   client_bitrate      - The client bitrate based on the client_rate.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_two_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t lo_odu_type,
                                                  UINT32 odu_flex_rate,
                                                  DOUBLE client_rate,
                                                  coreotn_mapping_type_t mapping_mode,
                                                  UINT32 tribslot_mask[COREOTN_TRIB_WRD_CNT],
                                                  UINT32 trib_port,
                                                  util_global_odu_line_payload_t payload_format,
                                                  util_global_odukp_type_t ho_odu_type,
                                                  UINT32 ho_chnl_id,
                                                  UINT32 client_bitrate)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 i;
    util_global_odu_line_payload_t ho_payload_format;
    coreotn_odu_chnl_prov_mode_t prov_mode;
    odujat_chnl_mode_t odujat_enable;
    BOOL8 super_prov = FALSE;

    PMC_ENTRY();

    /* check the current channel state */
    /*if ((coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_IN_PASSTHRU) && 
        (coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)) {*/

    if (coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)
    {
        ret_val = COREOTN_ERR_CHNL_INVALID_STATE;

    } 
    else 
    {
     
        ho_payload_format = coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].payload_format;
        
        ret_val = coreotn_odu_chnl_prov_mode_get(coreotn_handle, &prov_mode);
        
        if (PMC_SUCCESS == ret_val)
        {
            super_prov = (prov_mode == COREOTN_ODU_CHNL_PROV_ALL)? TRUE:FALSE;    
        }
        
        PMC_LOG_TRACE("mux_stage = COREOTN_MUX_STAGE_TWO\n");    

        /* Take FRM_RCP FIFO out of reset as by default RCP_EN = 1 */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle, COREOTN_FO1_FRM_RCP,
                                               chnl_id, 1);
        }

        if (TRUE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base))
        {
            if (coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 0)
            {
                /* this is the first LO channel */
                /* Channel is in reset by configuring HO_CH_RSTB to '0' */
                ret_val = odtu_dmx_ho_chnl_reset_cfg(coreotn_handle->odtu_dmx2_handle, ho_chnl_id, FALSE); 
                
            }
        }
        if (TRUE == pmc_coreotn_dmx_two_stage_proxy_mo_chnl_prov_revision(&coreotn_handle->base))
        {
            if (super_prov == FALSE)
            {
                if (coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 0
                    && coreotn_handle->var.rx_lo_chnl_ctxt[ho_chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL
                    && coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
                {
                     if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                                      coreotn_handle->odtu_dmx2_handle, 
                                                                      ho_chnl_id);
                    } 
                 }
            }
            else {
                if (coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 0)
                {
                     if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                                      coreotn_handle->odtu_dmx2_handle, 
                                                                      ho_chnl_id);
                    } 
                 }

            }
        }
        
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_lo_chnl_prov(coreotn_handle->odtu_dmx2_handle,
                                            chnl_id, (odtu_dmx_stage_instance_t)COREOTN_MUX_STAGE_TWO,
                                            lo_odu_type, odu_flex_rate, client_bitrate,
                                            ho_odu_type, (util_global_mapping_mode_t)mapping_mode, tribslot_mask,
                                            trib_port, payload_format, 
                                            ho_chnl_id, FALSE, FALSE);
        }

        if (TRUE == pmc_coreotn_enable_odujat_revision(&coreotn_handle->base))
        {
            if (PMC_SUCCESS == ret_val)
            {
                odujat_enable = ODUJAT_CHNL_ENABLED;
            }
        }
        else
        {
            /* In two stage muxing, keep ODUJAT in FMF2 in bypass 
            ** MPMO will perform JAT 
            */
            if (PMC_SUCCESS == ret_val)
            {
                odujat_enable = ODUJAT_CHNL_IN_BYPASS;
            }
        }
           
        /* ODUJAT_2 */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odujat_chnl_prov(coreotn_handle->odujat2_handle, chnl_id,
                                       mux_stage, ho_chnl_id, ho_odu_type, lo_odu_type, 
                                       odu_flex_rate, client_bitrate,
                                       odujat_enable, super_prov);
        }

        /* ODUKSC_2 */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = oduksc_chnl_prov(coreotn_handle->oduksc2_handle, chnl_id,
                                       ho_odu_type, lo_odu_type, client_bitrate,
                                       (util_global_mapping_mode_t)mapping_mode, odu_flex_rate);
        }
                 
        if (PMC_SUCCESS == ret_val)
        {
            if (prov_mode != COREOTN_ODU_CHNL_PROV_ALL)
            {
                ret_val = oduksc_chnl_update(coreotn_handle->oduksc2_handle, chnl_id, TRUE);
            } 
        }                
        
        /* this is the lowest ODU_RFRM channel, activate after DMX2 has been activated */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stg3a_handle, 
                                         chnl_id, 1, 1);
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* update channel state */
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;

            /* update the payload format */
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].payload_format = payload_format;
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].odu_container = ho_odu_type;
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].lo_odu_rate = lo_odu_type;
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].odu_flex_rate = odu_flex_rate;
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].cbr_flex_rate = client_rate;
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].payload_format = payload_format;
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].mapping_mode = mapping_mode;
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].trib_port = trib_port;

            for (i = 0; i < COREOTN_TRIB_WRD_CNT; i++)
            {
                coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].tribslot_mask[i] = tribslot_mask[i];
            }

            /* update the number of provisioned channels */
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnls_prov_cnt++;
            
            /* update the number of LO going into the MO */
            coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt++;
        }
    }

    PMC_RETURN(ret_val);
} /* coreotn_rx_lo_chnl_mux_two_prov */

/*******************************************************************************
*  coreotn_tx_lo_chnl_mux_one_prov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_lo_chnl_prov for the 
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - instance of multiplexing stage\n
*                          0 -- MO to HO multiplexing (LO to HO multiplexing for
*                               1 stage multiplexing)\n
*                          1 -- LO to MO multiplexing\n
*   lo_odu_type         - LO ODUj type. See util_global_odukp_type_t.
*   odu_flex_rate       - HO ODUk type. See util_global_odukp_type_t. 
*                         If two stage is used, this argument refers to MO odu type. 
*                         If one stage is used, this argument refers to HO odu type.
*   mapping_mode        - mapping type used. See coreotn_mapping_type_t.
*   tribslot_mask       - 3 x 32 bit mask to represent the tributary slot
*                         assignment for this LO channel.
*                         Valid range: 0 - 0x4F\n
*                           Bit 0 -- Tributary slot 1\n
*                           Bit 1 -- Tributary slot 2\n
*                           Bit 2 -- Tributary slot 3\n
*                               ...\n
*                           Bit 79 -- Tributary slot 80\n
*   trib_port           - a tributary port number for all tributary slot
*                         locations for the LO channel. This data is used for
*                         MSI coding.
*                         For the following payload types with fixed MSI
*                         assignment, this argument is ignored and MSI data is
*                         assigned internally as per G.709 standards:\n
*                         -- ODTU01\n
*                         -- ODTU12 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU2)\n
*                         -- ODTU13 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU3)
*   payload_format      - tributary slot size. See util_global_odu_line_payload_t.
*                         Valid values:\n
*                          -- For 1.25G TS, set to ODU_TS_1G25\n
*                          -- For 2.5G TS, set to ODU_TS_2G5\n
*   ho_odu_type         - HO ODU container type that the LO ODU channel belongs
*                         to. See util_global_odukp_type_t.
*   ho_chnl_id          - HO channel ID that this LO belongs to.
*                         Valid range: 0 -- 95
*   client_rate         - Client rate in kb/sec (only
*                         used for CBR flex clients)
*   prov_tfrm           - TRUE : provision TFRM configs
*                         FALSE : preserve current configuration
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_one_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t lo_odu_type,
                                                  UINT32 odu_flex_rate,
                                                  coreotn_mapping_type_t mapping_mode,
                                                  UINT32 tribslot_mask[COREOTN_TRIB_WRD_CNT],
                                                  UINT32 trib_port,
                                                  util_global_odu_line_payload_t payload_format,
                                                  util_global_odukp_type_t ho_odu_type,
                                                  UINT32 ho_chnl_id,
                                                  DOUBLE client_rate,
                                                  BOOL prov_tfrm)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 i;
    util_global_odu_line_payload_t ho_payload_format;
    UINT32 client_bitrate = 0;
    BOOL8 use_float32_mode = digi_use_float32_get();

    PMC_ENTRY();

    if (!use_float32_mode) {
        client_bitrate = (UINT32)(client_rate / 1000);
    } else {
        client_bitrate = (UINT32)((FLOAT)client_rate / 1000);
    }
    
    if (coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_INVALID_STATE);
    }

    ho_payload_format = coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].payload_format;
    PMC_LOG_TRACE("mux_stage = COREOTN_MUX_STAGE_ONE = %u\n", mux_stage);

    if (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE 
        || coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)
    {    
        if (PMC_SUCCESS == ret_val)
        {
            PMC_LOG_TRACE("before calling odtu_mux_lo_chnl_prov() first time, mux stage = %u\n", COREOTN_MUX_STAGE_ONE);
            /* access the first DMX for the LO channel configuration */
            ret_val = odtu_mux_lo_chnl_prov(coreotn_handle->odtu_mux1_handle,
                                            chnl_id, (odtu_mux_stage_instance_t)COREOTN_MUX_STAGE_ONE,
                                            lo_odu_type, odu_flex_rate, (util_global_mapping_mode_t)mapping_mode,
                                            tribslot_mask, trib_port, payload_format,
                                            ho_odu_type, ho_chnl_id, 0, client_bitrate, FALSE);
        }

        if (payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
        {
            if (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)
            {

                if (PMC_SUCCESS == ret_val)
                {
                    /* put unchannlized channel in passthru in second stage DMX */
                    ret_val = odtu_mux_chnl_init(coreotn_handle->odtu_mux2_handle, chnl_id, (odtu_mux_chnl_mode_t)0);
                }

                if (PMC_SUCCESS == ret_val)
                {
                    /* accesses the first MUX for the HO channel based configuration */
                    ret_val = odtu_mux_ho_chnl_prov(coreotn_handle->odtu_mux2_handle, 2,
                                                    chnl_id, lo_odu_type,
                                                    UTIL_GLOBAL_ODU_UNCHANNELIZED, FALSE);
                }

                if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
                {
                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = odtu_mux_ho_chnl_switch_cfg(coreotn_handle->odtu_mux2_handle,
                                                              chnl_id, FALSE);
                    }
                }
                
            } /* end of (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) */


            if(prov_tfrm)
            {
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = odu_tfrm_chnl_init(coreotn_handle->odu_tfrm_stg2_handle,
                                                 chnl_id, 1);
                }

                /* take FRM_RCP FIFO out of reset as by default RCP_EN = 1 */
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle,
                                                       COREOTN_FMF1_FRM_RCP96,
                                                       chnl_id, 1);
                }
            }          

        } /* end of if(payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED) */
        else {
            
            if(prov_tfrm)
            {
                if (PMC_SUCCESS == ret_val)
                {
                    /* take TFRM out of passtru */
                    /* need to provision PM layer as it's 2x muxing */
                    ret_val = coreotn_odu_tfrm_chnl_init(coreotn_handle, 
                                                         (odu_tfrm_inst_t)ODU_TFRM_STG2,
                                                         chnl_id, 1);
                }
                
                /* take the channel out of passthru */
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = odu_tfrm_chnl_init(coreotn_handle->odu_tfrm_stg2_handle, chnl_id, 1);
                }
            }
        }
    }

    if( coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
    {
        if (PMC_SUCCESS == ret_val)
        {
            PMC_LOG_TRACE("before calling odtu_mux_lo_chnl_prov() first time, mux stage = %u\n", COREOTN_MUX_STAGE_ONE);
            /* access the first DMX for the LO channel configuration */
            ret_val = odtu_mux_lo_chnl_prov(coreotn_handle->odtu_mux2_handle,
                                            chnl_id, (odtu_mux_stage_instance_t)COREOTN_MUX_STAGE_ONE,
                                            lo_odu_type, odu_flex_rate, (util_global_mapping_mode_t)mapping_mode,
                                            tribslot_mask, trib_port, payload_format,
                                            ho_odu_type, ho_chnl_id, 0, client_bitrate, FALSE);
        }


        /* take TFRM out of passtru */
        /* Do not provision PM layer */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odu_tfrm_chnl_init(coreotn_handle->odu_tfrm_stg3a_handle,
                                         chnl_id, 1);
        }

        /* take FRM_RCP FIFO out of reset as by default RCP_EN = 1 */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle,
                                               COREOTN_FMF2_FRM_RCP96,
                                               chnl_id, 1);
        } 
     
    }

    if (PMC_SUCCESS == ret_val)
    {
        /* update channel state */
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
        
        if (payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
        {
            coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_IN_PASSTHRU;
        }
        
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].odu_container = ho_odu_type;
        /* update payload_format */
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].payload_format = payload_format;
        /* update LO rate */
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].lo_odu_rate = lo_odu_type;
        /* update mapping mode */
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].mapping_mode = mapping_mode;
        /* update mapping mode */
        for (i = 0; i < COREOTN_TRIB_WRD_CNT; i++)
        {
            coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].tribslot_mask[i] = tribslot_mask[i];
        }

        /* update tributary port data */
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].trib_port = trib_port;
        /* update tributary port data */
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].odu_flex_rate = odu_flex_rate;
        /* store cbr_flex_rate */
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].cbr_flex_rate = client_bitrate;
        
        /* update the number of provisioned channels */
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnls_prov_cnt++;
        
        /* update the number of MO channels going into the HO */
        coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt++;
    }

    PMC_RETURN(ret_val);
} /* coreotn_tx_lo_chnl_mux_one_prov */

/*******************************************************************************
*  coreotn_tx_lo_chnl_mux_two_prov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_lo_chnl_prov for the 
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - instance of multiplexing stage\n
*                         - 0 -- MO to HO multiplexing (LO to HO multiplexing for
*                                1 stage multiplexing)\n
*                         - 1 -- LO to MO multiplexing\n
*   lo_odu_type         - LO ODUj type. See util_global_odukp_type_t.
*   odu_flex_rate       - HO ODUk type. See util_global_odukp_type_t. 
*                         If two stage is used, this argument refers to MO odu type. 
*                         If one stage is used, this argument refers to HO odu type.
*   mapping_mode        - mapping type used. See coreotn_mapping_type_t.
*   tribslot_mask       - 3 x 32 bit mask to represent the tributary slot
*                         assignment for this LO channel.
*                         Valid range: 0 - 0x4F\n
*                          - Bit 0 - Tributary slot 1\n
*                          - Bit 1 - Tributary slot 2\n
*                          - Bit 2 - Tributary slot 3\n
*                               ...\n
*                          - Bit 79 - Tributary slot 80\n
*   trib_port           - a tributary port number for all tributary slot
*                         locations for the LO channel. This data is used for
*                         MSI coding.
*                         For the following payload types with fixed MSI
*                         assignment, this argument is ignored and MSI data is
*                         assigned internally as per G.709 standards:\n
*                         -- ODTU01\n
*                         -- ODTU12 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU2)\n
*                         -- ODTU13 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU3)
*   payload_format      - tributary slot size. See util_global_odu_line_payload_t.
*                         Valid values:\n
*                          -- For 1.25G TS, set to ODU_TS_1G25\n
*                          -- For 2.5G TS, set to ODU_TS_2G5\n
*   ho_odu_type         - HO ODU container type that the LO ODU channel belongs
*                         to. See util_global_odukp_type_t.
*   ho_chnl_id          - HO channel ID that this LO belongs to.
*                         Valid range: 0 - 95
*   client_rate         - Client rate in kb/sec (only
*                         used for CBR flex clients)
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_two_prov(coreotn_handle_t *coreotn_handle,
                                                  UINT32 chnl_id,
                                                  coreotn_mux_stage_t mux_stage,
                                                  util_global_odukp_type_t lo_odu_type,
                                                  UINT32 odu_flex_rate,
                                                  coreotn_mapping_type_t mapping_mode,
                                                  UINT32 tribslot_mask[COREOTN_TRIB_WRD_CNT],
                                                  UINT32 trib_port,
                                                  util_global_odu_line_payload_t payload_format,
                                                  util_global_odukp_type_t ho_odu_type,
                                                  UINT32 ho_chnl_id,
                                                  DOUBLE client_rate)
{
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 i;
    util_global_odu_line_payload_t ho_payload_format;

    PMC_ENTRY();

    /* check the current channel state 
    if (coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_IN_PASSTHRU
        && coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_INVALID_STATE);
    }*/
    
    if (coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_INVALID_STATE);
    }
    

    ho_payload_format = coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].payload_format;

    PMC_LOG_TRACE("mux_stage = COREOTN_MUX_STAGE_TWO\n");



    if (PMC_SUCCESS == ret_val)
    {
        ret_val = odu_tfrm_chnl_init(coreotn_handle->odu_tfrm_stg3a_handle,
                                     chnl_id, 1);
    }


    /* Take FRM_RCP fifo out of reset as by default RCP_EN = 1 */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle,
                                           COREOTN_FMF2_FRM_RCP96,
                                           chnl_id, 1);
    }
    
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = odtu_mux_lo_chnl_prov(coreotn_handle->odtu_mux2_handle,
                                        chnl_id, (odtu_mux_stage_instance_t)COREOTN_MUX_STAGE_TWO,
                                        lo_odu_type, odu_flex_rate,
                                        (util_global_mapping_mode_t)mapping_mode, tribslot_mask, trib_port,
                                        payload_format, ho_odu_type, ho_chnl_id, 0, (UINT32)(client_rate/1000), FALSE);
    }

    if (PMC_SUCCESS == ret_val)
    {
        /* update channel state */
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].odu_container = ho_odu_type;
        /* update payload_format */
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].payload_format = payload_format;
        /* update LO rate */
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].lo_odu_rate = lo_odu_type;
        /* update mapping mode */
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].mapping_mode = mapping_mode;

        /* update tribslot mask */
        for (i = 0; i < COREOTN_TRIB_WRD_CNT; i++)
        {
            coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].tribslot_mask[i] = tribslot_mask[i];
        }
        /* update tributary port data */
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].trib_port = trib_port;
        /* update odu flex data */
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].odu_flex_rate = odu_flex_rate;
        /* store cbr_flex_rate here */
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].cbr_flex_rate = (UINT32)(client_rate/1000);
        
        /* update the number of provisioned channels */
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnls_prov_cnt++;
        
        /* update the number of LO going into the MO */
        coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt++;
    }

    PMC_RETURN(ret_val);
} /* coreotn_tx_lo_chnl_mux_two_prov */

/*******************************************************************************
*  coreotn_rx_ho_chnl_mux_none_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_ho_chnl_activate for the 
*   mux_stage == COREOTN_MUX_STAGE_NONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - tributary slot number
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_none_activate(coreotn_handle_t *coreotn_handle,
                                                       UINT32 chnl_id,
                                                       coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    /* update the channel state */
    if (coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_IN_PASSTHRU
        && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_IN_PASSTHRU
        && coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_IN_PASSTHRU
        && coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED
        && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED
        && coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_INVALID_STATE);
    }

    if ((coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE))
    {
        ret_val = odujat_chnl_activate(coreotn_handle->odujat1_handle, chnl_id, FALSE);

        if (PMC_SUCCESS == ret_val)
        {
            ret_val = oduksc_chnl_activate(coreotn_handle->oduksc1_handle, chnl_id);
        }

        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_activate(coreotn_handle->odtu_dmx1_handle,
                                                chnl_id);
        }

        /* activate lo channel in passthru */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_lo_chnl_activate(coreotn_handle->odtu_dmx1_handle,
                                                chnl_id, chnl_id,
                                                (odtu_dmx_stage_instance_t)mux_stage);
        }
    }

    if ((coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)) 
    {

        ret_val = odujat_chnl_activate(coreotn_handle->odujat2_handle, chnl_id, FALSE);

        if (PMC_SUCCESS == ret_val)
        {
            ret_val = oduksc_chnl_activate(coreotn_handle->oduksc2_handle, chnl_id);
        }

        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_activate(coreotn_handle->odtu_dmx2_handle,
                                                chnl_id);
        }

        /* activate lo channel in passthru */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_lo_chnl_activate(coreotn_handle->odtu_dmx2_handle,
                                                chnl_id, chnl_id,
                                                (odtu_dmx_stage_instance_t)mux_stage);
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        /* update the channel state */
        coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_OPERATIONAL;
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_OPERATIONAL;
        coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_OPERATIONAL;
    }

    PMC_RETURN(ret_val);

} /* coreotn_rx_ho_chnl_mux_none_activate */

/*******************************************************************************
*  coreotn_rx_ho_chnl_mux_one_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_ho_chnl_activate for the 
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - tributary slot number
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_one_activate(coreotn_handle_t *coreotn_handle,
                                                      UINT32 chnl_id,
                                                      coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    odtu_dmx_handle_t *ho_dmx_handle_ptr;
    PMC_ENTRY();

    /* check the current ho channel state */
    if (coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED);
    }

    if ((coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE))
    {
        ho_dmx_handle_ptr = coreotn_handle->odtu_dmx1_handle;

    } 
    else if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
    {
        ho_dmx_handle_ptr = coreotn_handle->odtu_dmx2_handle;
    }

    if ((coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)) 
    {   
        if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
        {
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odtu_dmx_ho_chnl_switch_cfg(ho_dmx_handle_ptr,
                                                      chnl_id, FALSE);
            }
        
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odtu_dmx_ho_chnl_activate(ho_dmx_handle_ptr,
                                                    chnl_id);
            }
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        /* update the channel state */
        coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_OPERATIONAL;
    }

    PMC_RETURN(ret_val);

} /* coreotn_rx_ho_chnl_mux_one_activate */

/*******************************************************************************
*  coreotn_rx_ho_chnl_mux_two_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_ho_chnl_activate for the 
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - tributary slot number
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_two_activate(coreotn_handle_t *coreotn_handle,
                                                      UINT32 chnl_id,
                                                      coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    /* check the current mo channel state */
    if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED);
    }

    /*
    ** ADDED 
    */  
    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_switch_cfg(coreotn_handle->odtu_dmx2_handle,
                                                  chnl_id, FALSE);
        }
 
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_activate(coreotn_handle->odtu_dmx2_handle,
                                                chnl_id);
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_OPERATIONAL;
    }

    PMC_RETURN(ret_val);

} /* coreotn_rx_ho_chnl_mux_two_activate */

/*******************************************************************************
*  coreotn_tx_ho_chnl_mux_none_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_ho_chnl_activate for the 
*   mux_stage == COREOTN_MUX_STAGE_NONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - tributary slot number
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_none_activate(coreotn_handle_t *coreotn_handle,
                                                       UINT32 chnl_id,
                                                       coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    /* check the current ho channel state */
    if (coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_IN_PASSTHRU
        && coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_IN_PASSTHRU
        && coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_IN_PASSTHRU
        && coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED
        && coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED
        && coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_INVALID_STATE);
    }

    if (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE 
        || coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) 
    {
        if (pmc_is_digi_rev_a_revision(&coreotn_handle->base) == TRUE)
        {
            ret_val = odtu_mux_ohfs_insert_cfc_fifo_deactivate(coreotn_handle->odtu_mux1_handle, chnl_id);
            
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odtu_mux_ho_chnl_activate(coreotn_handle->odtu_mux1_handle, chnl_id);
            }
                                             
            if (PMC_SUCCESS == ret_val)
            {
                /* take OHFS_INSERT CFC out of reset after HO has been activated */
                ret_val = odtu_mux_ohfs_insert_cfc_fifo_activate(coreotn_handle->odtu_mux1_handle, chnl_id);  
            } 
        }
        else {
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odtu_mux_ho_chnl_activate(coreotn_handle->odtu_mux1_handle, chnl_id);
            }
        }            
                                                    
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_lo_chnl_activate(coreotn_handle->odtu_mux1_handle, 
                                                chnl_id, chnl_id);
        }
    }

    if ((coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) ||        
        (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)) 
    {
        if (pmc_is_digi_rev_a_revision(&coreotn_handle->base) == TRUE)
        {
            ret_val = odtu_mux_ohfs_insert_cfc_fifo_deactivate(coreotn_handle->odtu_mux2_handle, chnl_id);
            
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odtu_mux_ho_chnl_activate(coreotn_handle->odtu_mux2_handle,
                                                    chnl_id);
            }
            
            if (PMC_SUCCESS == ret_val)
            {
                /* take OHFS_INSERT CFC out of reset after HO has been activated */
                ret_val = odtu_mux_ohfs_insert_cfc_fifo_activate(coreotn_handle->odtu_mux2_handle, chnl_id);  
            }
        }
        else 
        {
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odtu_mux_ho_chnl_activate(coreotn_handle->odtu_mux2_handle,
                                                    chnl_id);
            }
        }
                    
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_lo_chnl_activate(coreotn_handle->odtu_mux2_handle, 
                                                chnl_id, chnl_id);
        }
    }

    /* update ho channel state */
    if (PMC_SUCCESS == ret_val)
    {
        coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_OPERATIONAL;
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_OPERATIONAL;
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_OPERATIONAL;
    }

    PMC_RETURN(ret_val);

} /* coreotn_tx_ho_chnl_mux_none_activate */

/*******************************************************************************
*  coreotn_tx_ho_chnl_mux_one_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_ho_chnl_activate for the 
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - tributary slot number
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_one_activate(coreotn_handle_t *coreotn_handle,
                                                      UINT32 chnl_id,
                                                      coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    odtu_mux_handle_t *mux_handle_ptr = NULL;
    UINT32 maint_sig;

    PMC_ENTRY();

    if (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE 
        || coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) 
    {
        /* check the current ho channel state */
        if (coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
        {
            PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED);
        }

        mux_handle_ptr = coreotn_handle->odtu_mux1_handle;
    }
    else if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)
    {

        /*acitvate mux for sysotn muxing */
        /* check the current ho channel state */
        if (coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
        {
            PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED);
        }

        mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
    }
    else {
        ret_val = COREOTN_ERR_INVALID_ARG;
    }
    
    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_ho_chnl_switch_cfg(mux_handle_ptr,
                                                  chnl_id, FALSE);
        }
    }
    
    if (pmc_is_digi_rev_a_revision(&coreotn_handle->base) == TRUE)
    {
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_ohfs_insert_cfc_fifo_deactivate(mux_handle_ptr, chnl_id);
        }
        
        if (PMC_SUCCESS == ret_val)
        {
        
            ret_val = odtu_mux_ho_chnl_activate(mux_handle_ptr, chnl_id);
        }
        
        if (PMC_SUCCESS == ret_val)
        {
            /* take OHFS_INSERT CFC out of reset after HO has been activated */
            ret_val = odtu_mux_ohfs_insert_cfc_fifo_activate(mux_handle_ptr, chnl_id);  
        }
    }
    else 
    {
        if (PMC_SUCCESS == ret_val)
        {
            if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
            {
                ret_val = odtu_mux_ho_chnl_activate(mux_handle_ptr, chnl_id);
                PMC_Q_USLEEP(coreotn_handle, 1);
            }
            else {
                (void)odu_tfrm_odukp_pck_maint_sig_get(coreotn_handle->odu_tfrm_stg1_handle,
                                                       chnl_id, 
                                                       &maint_sig);

                if (maint_sig == (UINT32)CORE_OTN_ODUK_OCI)
                {
                    
                    ret_val = odtu_mux_ho_chnl_switch_cfg(mux_handle_ptr, chnl_id, FALSE);

                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = odtu_mux_ho_chnl_activate(mux_handle_ptr, chnl_id);
                    
                        PMC_Q_USLEEP(coreotn_handle, 1);
                    }

                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = coreotn_tx_ho_chnl_offline_update(coreotn_handle, chnl_id, mux_stage,
                                                                    coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].odu_container,
                                                                    coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].payload_format);
                    }

                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = odtu_mux_ho_chnl_switch_cfg(mux_handle_ptr, chnl_id, FALSE);
                    }
                }
            }
        }
    }                
   
    if (PMC_SUCCESS == ret_val)
    {
        /* update the channel state */
        coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_OPERATIONAL;
    }
     
    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {   
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_tx_ho_chnl_offline_update(coreotn_handle, chnl_id, mux_stage,
                                                        coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].odu_container,
                                                        coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].payload_format);
        }
    }

    /* configure switch on the offline page */
    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_ho_chnl_switch_cfg(mux_handle_ptr, chnl_id, FALSE);
        }
    }
    
    PMC_RETURN(ret_val);

} /* coreotn_tx_ho_chnl_mux_one_activate */

/*******************************************************************************
*  coreotn_tx_ho_chnl_mux_two_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_ho_chnl_activate for the 
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   mux_stage           - tributary slot number
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_two_activate(coreotn_handle_t *coreotn_handle,
                                                      UINT32 chnl_id,
                                                      coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    /* check the current mo channel state */
    if (coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED);
    }

    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_ho_chnl_switch_cfg(coreotn_handle->odtu_mux2_handle,
                                                  chnl_id, FALSE);
        }
    }
    
    if (pmc_is_digi_rev_a_revision(&coreotn_handle->base) == TRUE)
    {
        if (PMC_SUCCESS == ret_val)
        {
            /* take OHFS_INSERT CFC out of reset after HO has been activated */
            ret_val = odtu_mux_ohfs_insert_cfc_fifo_deactivate(coreotn_handle->odtu_mux2_handle, chnl_id);  
        }
        
        /* take the HO channel out of reset */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_ho_chnl_activate(coreotn_handle->odtu_mux2_handle,
                                                chnl_id);
        }
        
        if (PMC_SUCCESS == ret_val)
        {
            /* take OHFS_INSERT CFC out of reset after HO has been activated */
            ret_val = odtu_mux_ohfs_insert_cfc_fifo_activate(coreotn_handle->odtu_mux2_handle, chnl_id);  
        }
    }
    else 
    {
        /* take the HO channel out of reset */
        if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
        {
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odtu_mux_ho_chnl_activate(coreotn_handle->odtu_mux2_handle,
                                                    chnl_id);

                PMC_Q_USLEEP(coreotn_handle, 1);
            }
        }
    }                

    /*if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {*/
        if (PMC_SUCCESS == ret_val)
        {
            /* update the mo channel state */
            coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_OPERATIONAL;
        }
    /*}*/
    
    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_tx_ho_chnl_offline_update(coreotn_handle, chnl_id, mux_stage,
                                                        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].odu_container,
                                                        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].payload_format);
        }
    }
    
    /* added to configure the offline page of the MO channel */
    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_ho_chnl_switch_cfg(coreotn_handle->odtu_mux2_handle,
                                                  chnl_id, FALSE);
        }
    }
    
    PMC_RETURN(ret_val);

} /* coreotn_tx_ho_chnl_mux_two_activate */

/*******************************************************************************
*  coreotn_rx_lo_chnl_mux_none_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_lo_chnl_activate for the 
*   mux_stage == COREOTN_MUX_STAGE_NONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   ho_chnl_id          - HO ODU channel ID that the current LO belongs to.
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_none_activate(coreotn_handle_t *coreotn_handle,
                                                       UINT32 chnl_id,
                                                       UINT32 ho_chnl_id)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    /* check the current mo channel state */
    if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_IN_PASSTHRU)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_INVALID_STATE);
    }
    
    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT) 
    {
        ret_val = odtu_dmx_lo_chnl_activate(coreotn_handle->odtu_dmx1_handle,
                                            chnl_id, ho_chnl_id, ODTU_DMX_STG_NONE);
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_lo_chnl_activate(coreotn_handle->odtu_dmx2_handle,
                                                chnl_id, ho_chnl_id, ODTU_DMX_STG_NONE);
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* update the channel state */
            coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_OPERATIONAL;
        }
    }
    
    PMC_RETURN(ret_val);

} /* coreotn_rx_lo_chnl_mux_none_activate */

/*******************************************************************************
*  coreotn_rx_lo_chnl_mux_one_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_lo_chnl_activate for the 
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   ho_chnl_id          - HO ODU channel ID that the current LO belongs to.
*                         Valid range: 0 - 95
*   mux_stage           - Enum for mux stage. See coreotn_mux_stage_t.
*   *lo_dmx_handle_ptr  - pointer to the lo_dmx handle instance.
*   *lo_odujat_handle_ptr - pointer to the odujat handle instance.
*   *lo_oduksc_handle_ptr - pointer to the oduksc handle instance.
*   activate_rfrm        - TRUE : activate RFRM
*                          FALSE : do no activate RFRM   
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_one_activate(coreotn_handle_t *coreotn_handle,
                                                      UINT32 chnl_id,
                                                      UINT32 ho_chnl_id,
                                                      coreotn_mux_stage_t mux_stage,
                                                      odtu_dmx_handle_t *lo_dmx_handle_ptr,
                                                      odujat_handle_t *lo_odujat_handle_ptr,
                                                      oduksc_handle_t *lo_oduksc_handle_ptr,
                                                      BOOL activate_rfrm)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    util_global_odukp_type_t ho_odu_rate = UTIL_GLOBAL_LAST_ODUK;
    util_global_odukp_type_t lo_odu_rate = UTIL_GLOBAL_LAST_ODUK;
    UINT32 odu_flex_rate = 0;
    DOUBLE cbr_flex_rate = 0;
    util_global_odu_line_payload_t payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
    util_global_odu_line_payload_t ho_payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
    coreotn_mapping_type_t mapping_mode = (coreotn_mapping_type_t)UTIL_GLOBAL_NO_MAP;
    UINT32 tribslot_mask[COREOTN_TRIB_WRD_CNT];
    UINT32 trib_port = 0;
    UINT32 i;
    coreotn_odu_chnl_prov_mode_t prov_mode = LAST_COREOTN_CHNL_PROV_MODE; 
    UINT32 new_lo_chnl_ids[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    UINT32 num_new_lo = 0;

    PMC_ENTRY();

    /* check the current mo channel state */
    if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED);
    }

    /* extract information for MO channel */ 
    ho_odu_rate = coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].odu_container;
    payload_format = coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format;
    lo_odu_rate = coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].lo_odu_rate;
    mapping_mode = coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].mapping_mode;
    ho_payload_format = coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].payload_format;

    for (i = 0; i < COREOTN_TRIB_WRD_CNT; i++)
    {
        tribslot_mask[i] = coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].tribslot_mask[i];
    }
    trib_port = coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].trib_port;
    odu_flex_rate = coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].odu_flex_rate; 
    cbr_flex_rate = coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].cbr_flex_rate;

    
    /* 
    ** If this is the first LO channel in the HO, activate HO first and then
    ** activate LO
    */ 
    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if (TRUE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base))
        {
            if (coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt > 1)
            {
                /* lo channel out of reset */
                ret_val = odtu_dmx_lo_chnl_activate(lo_dmx_handle_ptr,
                                                    chnl_id, ho_chnl_id,
                                                    (odtu_dmx_stage_instance_t)mux_stage);
            }
        }                                                    
            
        /* offline update */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_rx_lo_chnl_offline_update(coreotn_handle, chnl_id,
                                                        mux_stage,
                                                        lo_odu_rate,
                                                        odu_flex_rate,
                                                        cbr_flex_rate,
                                                        mapping_mode,
                                                        tribslot_mask,
                                                        trib_port,
                                                        ho_payload_format,
                                                        ho_odu_rate,
                                                        ho_chnl_id);
        }

        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_switch_cfg(lo_dmx_handle_ptr,
                                                  ho_chnl_id, FALSE);
        }              
    }
    else {

        if (coreotn_handle->var.mux_profile[ho_chnl_id].num_mo_chnls != 0xFF
            && coreotn_handle->var.mux_profile[ho_chnl_id].num_lo_chnls != 0xFF)
        {
            
            for (i = 0; i < UTIL_GLOBAL_MAX_NUM_ODU_CHNL; i++)
            {
                new_lo_chnl_ids[i] = 0x7F;
            }

            /* get all LO channel IDs */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = coreotn_rx_lo_chnl_ids_get(coreotn_handle, 
                                                     mux_stage, 
                                                     ho_chnl_id, 
                                                     new_lo_chnl_ids, 
                                                     &num_new_lo);
            }

            /* this function is called for MUX_STAGE_ONE thus we check MO channel state */
            /* if this is the last LO ODU then configure STS_SW, swap and configure offline_page */
            if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_cfg_state == COREOTN_LO_ODU_CHNL_CFG_END)
            {
                /* 1) configure STS_SW */
                ret_val = odtu_dmx_ho_chnl_switch_cfg(lo_dmx_handle_ptr,
                                                      ho_chnl_id, FALSE);                                                 
                
                /* 2) swap the page */
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                                  lo_dmx_handle_ptr,
                                                                  ho_chnl_id);
                }
                
                /* 3) configure offline page */
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = coreotn_rx_lo_chnl_offline_update_all(coreotn_handle,
                                                                    mux_stage,
                                                                    ho_chnl_id,
                                                                    new_lo_chnl_ids, 
                                                                    num_new_lo);
                }
                
                /* 4) configure STS_SW */
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = odtu_dmx_ho_chnl_switch_cfg(lo_dmx_handle_ptr,
                                                          ho_chnl_id, FALSE);                                                  
                }   
            }  
        }        
    }                           
    
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = coreotn_odu_chnl_prov_mode_get(coreotn_handle, &prov_mode);
    }

    if (PMC_SUCCESS == ret_val)
    {
        if (prov_mode != COREOTN_ODU_CHNL_PROV_ALL)
        {
            ret_val = odujat_chnl_activate(lo_odujat_handle_ptr, chnl_id, FALSE);
                                                      
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = oduksc_chnl_activate(lo_oduksc_handle_ptr, chnl_id);
            }
        }
    }
    

    
    if(activate_rfrm)
    {
        if (coreotn_handle->var.init_operation != COREOTN_SS_SYSOTN_MODE) {
            
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odu_rfrm_chnl_init(coreotn_handle->odu_rfrm_stg2_handle, chnl_id, 1, 1);
            }                   
        }
    }


    if (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)
    {
        if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
        {
            if (PMC_SUCCESS == ret_val)
            {
                if (prov_mode != COREOTN_ODU_CHNL_PROV_ALL)
                {
                    ret_val = odujat_chnl_activate(coreotn_handle->odujat2_handle, chnl_id, FALSE);
                
            
                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = oduksc_chnl_activate(coreotn_handle->oduksc2_handle, chnl_id);
                    }
                }
            }

            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odtu_dmx_ho_chnl_activate(coreotn_handle->odtu_dmx2_handle,
                                                    chnl_id); 
            }

            /* activate lo channel in passthru */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odtu_dmx_lo_chnl_activate(coreotn_handle->odtu_dmx2_handle,
                                                    chnl_id, chnl_id, 
                                                    (odtu_dmx_stage_instance_t)mux_stage); 
            }
        }
    }

    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if (PMC_SUCCESS == ret_val)
        {
            /* update the channel state */
            coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_OPERATIONAL;
        }
    }
    
    PMC_RETURN(ret_val);

} /* coreotn_rx_lo_chnl_mux_one_activate */

/*******************************************************************************
*  coreotn_rx_lo_chnl_mux_two_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_lo_chnl_activate for the 
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   ho_chnl_id          - HO ODU channel ID that the current LO belongs to.
*                         Valid range: 0 - 95
*   mux_stage           - Enum for mux stage. See coreotn_mux_stage_t.
*   *lo_dmx_handle_ptr  - pointer to the lo_dmx handle instance.
*   *lo_odujat_handle_ptr - pointer to the odujat handle instance.
*   *lo_oduksc_handle_ptr - pointer to the oduksc handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_two_activate(coreotn_handle_t *coreotn_handle,
                                                      UINT32 chnl_id,
                                                      UINT32 ho_chnl_id,
                                                      coreotn_mux_stage_t mux_stage,
                                                      odtu_dmx_handle_t *lo_dmx_handle_ptr,
                                                      odujat_handle_t *lo_odujat_handle_ptr,
                                                      oduksc_handle_t *lo_oduksc_handle_ptr)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    util_global_odukp_type_t ho_odu_rate = UTIL_GLOBAL_LAST_ODUK;
    util_global_odukp_type_t lo_odu_rate = UTIL_GLOBAL_LAST_ODUK;
    UINT32 odu_flex_rate = 0;
    DOUBLE cbr_flex_rate = 0;
    util_global_odu_line_payload_t payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
    util_global_odu_line_payload_t ho_payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
    coreotn_mapping_type_t mapping_mode = (coreotn_mapping_type_t)UTIL_GLOBAL_NO_MAP;
    UINT32 tribslot_mask[COREOTN_TRIB_WRD_CNT];
    UINT32 trib_port = 0;
    UINT32 i;
    UINT32 ultimate_ho_chnl_id = 0;  
    coreotn_odu_chnl_prov_mode_t  prov_mode;
    UINT32 new_lo_chnl_ids[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    UINT32 num_new_lo = 0;

    PMC_ENTRY();

    /* check the current mo channel state */
    if (coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED);
    }

    /* extract information for prov mode */
    prov_mode = coreotn_handle->var.prov_mode; 
    
    /* extract information for MO channel */ 
    ho_odu_rate = coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].odu_container;
    payload_format = coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].payload_format;
    lo_odu_rate = coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].lo_odu_rate;
    mapping_mode = coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].mapping_mode;
    ho_payload_format = coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].payload_format;

    for (i = 0; i < COREOTN_TRIB_WRD_CNT; i++)
    {
        tribslot_mask[i] = coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].tribslot_mask[i];
    }
    trib_port = coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].trib_port;
    odu_flex_rate = coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].odu_flex_rate; 
    cbr_flex_rate = coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].cbr_flex_rate;  

    /* 
    ** If this is the first LO channel in the HO, hold the reset until after
    ** offline update is done
    */
    if (prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT) 
    {
        if (TRUE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base))
        {
            if (coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt > 1)
            {
                /* lo channel out of reset */
                ret_val = odtu_dmx_lo_chnl_activate(coreotn_handle->odtu_dmx2_handle,
                                                    chnl_id, ho_chnl_id,
                                                    (odtu_dmx_stage_instance_t)mux_stage);
            }
        }
        
        /* offline update */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_rx_lo_chnl_offline_update(coreotn_handle, 
                                                        chnl_id,
                                                        mux_stage,
                                                        lo_odu_rate,
                                                        odu_flex_rate,
                                                        cbr_flex_rate,
                                                        mapping_mode,
                                                        tribslot_mask,
                                                        trib_port,
                                                        ho_payload_format,
                                                        ho_odu_rate,
                                                        ho_chnl_id);
        
        }
        
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_switch_cfg(coreotn_handle->odtu_dmx2_handle,
                                                  ho_chnl_id, FALSE);
        }
    }
    else 
    {
        odtu_dmx_ho_ch_id_get(coreotn_handle->odtu_dmx1_handle,
                              ho_chnl_id,
                              &ultimate_ho_chnl_id);
                              
        if( ultimate_ho_chnl_id < (sizeof(coreotn_handle->var.mux_profile)/sizeof(coreotn_handle->var.mux_profile[0])) )
        {
            if (coreotn_handle->var.mux_profile[ultimate_ho_chnl_id].num_mo_chnls != 0xFF
                && coreotn_handle->var.mux_profile[ultimate_ho_chnl_id].num_lo_chnls != 0xFF)
            {
                for (i = 0; i < UTIL_GLOBAL_MAX_NUM_ODU_CHNL; i++)
                {
                    new_lo_chnl_ids[i] = 0x7F;
                }

                /* get all LO channel IDs */
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = coreotn_rx_lo_chnl_ids_get(coreotn_handle, 
                                                         mux_stage, 
                                                         ho_chnl_id, 
                                                         new_lo_chnl_ids, 
                                                         &num_new_lo);
                }

                /* this function is called for MUX_STAGE_ONE thus we check MO channel state */
                /* if this is the last LO ODU then configure STS_SW, swap and configure offline_page */
                if (coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_cfg_state == COREOTN_LO_ODU_CHNL_CFG_END)
                {
                    /* 1) configure STS_SW */
                    ret_val = odtu_dmx_ho_chnl_switch_cfg(coreotn_handle->odtu_dmx2_handle,
                                                          ho_chnl_id, FALSE);                                                 
                    
                    /* 2) swap the page */
                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                                      coreotn_handle->odtu_dmx2_handle,
                                                                      ho_chnl_id);
                    }
                    
                    /* 3) configure offline page */
                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = coreotn_rx_lo_chnl_offline_update_all(coreotn_handle,
                                                                        mux_stage,
                                                                        ho_chnl_id,
                                                                        new_lo_chnl_ids, 
                                                                        num_new_lo);
                    }
                    
                    /* 4) configure STS_SW */
                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = odtu_dmx_ho_chnl_switch_cfg(coreotn_handle->odtu_dmx2_handle,
                                                              ho_chnl_id, FALSE);                                                  
                    }   
                }
            }
        }
        else
        {
            ret_val = COREOTN_ERR_INVALID_ARG;
        }
    } 
    
    if (prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odujat_chnl_activate(coreotn_handle->odujat2_handle, chnl_id, FALSE);
        }
        
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = oduksc_chnl_activate(coreotn_handle->oduksc2_handle, chnl_id);
        }
              
        if (PMC_SUCCESS == ret_val)
        {
            /* update the channel state */
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_OPERATIONAL;
        }
    }
    
    PMC_RETURN(ret_val);

} /* coreotn_rx_lo_chnl_mux_two_activate */


/*******************************************************************************
*  coreotn_rx_lo_chnl_offline_deactivate_all
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API is used to perform a page swap and configure all currently pending
*   LO channels into the offline page upon the issuance of the last channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   ho_chnl_id          - HO ODU channel ID that the current LO belongs to.
*                         Valid range: 0 - 95
*   mux_stage           - Enum for mux stage. See coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_lo_chnl_offline_deactivate_all(coreotn_handle_t *coreotn_handle,
                                                           UINT32 ho_chnl_id,
                                                           coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 i;
    UINT32 lo_chnl_ids[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    UINT32 local_lo_chnl_ids[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    UINT32 num_lo_deprov = 0;
    odtu_dmx_handle_t *odtu_dmx_handle_ptr = NULL;
    
    PMC_ENTRY();
    
    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE
            || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
        {
            odtu_dmx_handle_ptr = coreotn_handle->odtu_dmx2_handle;
        }
        else {
            odtu_dmx_handle_ptr = coreotn_handle->odtu_dmx1_handle;
        }

        /* HO-MO */
        ret_val = sts_sw_lo_chnl_ids_get(odtu_dmx_handle_ptr->sts_sw_handle, 
                                         ho_chnl_id, lo_chnl_ids);

        if (PMC_SUCCESS == ret_val)   
        {
            for (i = 0; i < UTIL_GLOBAL_MAX_NUM_ODU_CHNL; i++)
            {    
                if (lo_chnl_ids[i] != 0x7F
                    && coreotn_handle->var.rx_mo_chnl_ctxt[lo_chnl_ids[i]].chnl_state == COREOTN_CHNL_DEPROV_PENDING)
                {
                    local_lo_chnl_ids[num_lo_deprov] = lo_chnl_ids[i];
                    num_lo_deprov++;
                }   
            }
        } 

        for (i = 0; i < num_lo_deprov && PMC_SUCCESS == ret_val; i++)
        {
            ret_val = sts_sw_lo_chnl_ids_ptr_ctxt_reset(odtu_dmx_handle_ptr->sts_sw_handle, 
                                                        ho_chnl_id, local_lo_chnl_ids[i]);
        }


        /* 2) swap the page */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                          odtu_dmx_handle_ptr,
                                                          ho_chnl_id);
        }
        PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
        /* 3) configure offline page */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_rx_lo_chnl_offline_deprov_all(coreotn_handle,
                                                            mux_stage,
                                                            ho_chnl_id,
                                                            local_lo_chnl_ids,
                                                            num_lo_deprov);
        }
        PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);

        /* 4) configure STS_SW */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_switch_cfg(odtu_dmx_handle_ptr,
                                                  ho_chnl_id, TRUE);                                                  
        } 
    }
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        /* this function is called for MUX_STAGE_ONE thus we check MO channel state */
        /* if this is the last LO ODU then configure STS_SW, swap and configure offline_page */
        /* MO-LO */
        ret_val = sts_sw_lo_chnl_ids_get(coreotn_handle->odtu_dmx2_handle->sts_sw_handle, 
                                        ho_chnl_id, lo_chnl_ids);
 
        if (PMC_SUCCESS == ret_val)   
        {
            for (i = 0; i < UTIL_GLOBAL_MAX_NUM_ODU_CHNL; i++)
            {     
                /* 1) configure offline page */
                if (lo_chnl_ids[i] != 0x7F
                    && coreotn_handle->var.rx_lo_chnl_ctxt[lo_chnl_ids[i]].chnl_state == COREOTN_CHNL_DEPROV_PENDING)
                {
                    local_lo_chnl_ids[num_lo_deprov] = lo_chnl_ids[i];
                    num_lo_deprov++;
                }   
            }
        }

        for (i = 0; i < num_lo_deprov && PMC_SUCCESS == ret_val; i++)
        {
            ret_val = sts_sw_lo_chnl_ids_ptr_ctxt_reset(coreotn_handle->odtu_dmx2_handle->sts_sw_handle, 
                                                        ho_chnl_id, local_lo_chnl_ids[i]);
        }


        /* 2) swap the page */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                          coreotn_handle->odtu_dmx2_handle,
                                                          ho_chnl_id);
        }
        PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
        /* 3) configure offline page */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_rx_lo_chnl_offline_deprov_all(coreotn_handle,
                                                            mux_stage,
                                                            ho_chnl_id,
                                                            local_lo_chnl_ids,
                                                            num_lo_deprov);
        }
        PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);

        /* 4) configure STS_SW */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_switch_cfg(coreotn_handle->odtu_dmx2_handle,
                                                  ho_chnl_id, TRUE);                                                  
        }   

    }
    
    PMC_RETURN(ret_val);
    
} /* coreotn_rx_lo_chnl_offline_deactivate_all */


/*******************************************************************************
*  coreotn_rx_lo_chnl_offline_activate_all
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This API is used to perform a page swap and configure all currently pending
*   LO channels into the offline page upon the issuance of the last channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   ho_chnl_id          - HO ODU channel ID that the current LO belongs to.
*                         Valid range: 0 - 95
*   mux_stage           - Enum for mux stage. See coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_rx_lo_chnl_offline_activate_all(coreotn_handle_t *coreotn_handle,
                                                         UINT32 ho_chnl_id,
                                                         coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 i;
    UINT32 lo_chnl_ids[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    UINT32 new_lo_chnl_ids[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    UINT32 new_unchan_lo_chnl_ids[UTIL_GLOBAL_MAX_NUM_ODU_CHNL];
    UINT32 new_lo_chnl_num = 0;
    UINT32 unchan_cnt = 0;
    odtu_dmx_handle_t *odtu_dmx_handle_ptr = NULL;
    odujat_handle_t *odujat_handle_ptr = NULL;
    oduksc_handle_t *oduksc_handle_ptr = NULL;
    
    PMC_ENTRY();
    
    /* initialize the output array */
    for (i = 0; i < UTIL_GLOBAL_MAX_NUM_ODU_CHNL; i++)
    {
        lo_chnl_ids[i] = 0x7F;
        new_lo_chnl_ids[i] = 0x7F;
        new_unchan_lo_chnl_ids[i] = 0x7F;
    }
    
    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE
            || coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
        {
            odtu_dmx_handle_ptr = coreotn_handle->odtu_dmx2_handle;
            odujat_handle_ptr = coreotn_handle->odujat2_handle;
            oduksc_handle_ptr = coreotn_handle->oduksc2_handle;

        }
        else {
            odtu_dmx_handle_ptr = coreotn_handle->odtu_dmx1_handle;
            odujat_handle_ptr = coreotn_handle->odujat1_handle;
            oduksc_handle_ptr = coreotn_handle->oduksc1_handle;
        }
        /* this function is called for MUX_STAGE_ONE thus we check MO channel state */
        /* if this is the last LO ODU then configure STS_SW, swap and configure offline_page */
              
        
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_rx_lo_chnl_ids_get(coreotn_handle,
                                                 mux_stage,
                                                 ho_chnl_id,
                                                 new_lo_chnl_ids,
                                                 &new_lo_chnl_num);                                                
        }

        if (PMC_SUCCESS == ret_val)
        {
            if (coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == new_lo_chnl_num)
            {
                ret_val = odtu_dmx_ho_chnl_activate(odtu_dmx_handle_ptr,
                                                    ho_chnl_id);

                if (ret_val == (UINT32)ODTU_DMX_CHNL_OPERATIONAL)
                {
                    ret_val = coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                                  odtu_dmx_handle_ptr,
                                                                  ho_chnl_id);
                }
                else {
                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = coreotn_rx_ho_chnl_offline_update(coreotn_handle,
                                                                    ho_chnl_id,
                                                                    mux_stage,
                                                                    coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].odu_container,
                                                                    coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].payload_format);

                    }
                }
            }
            else {
                /* 2) swap the page */
                ret_val = coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                            odtu_dmx_handle_ptr,
                                                            ho_chnl_id);
            }
        }

        /* 3) configure offline page */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_rx_lo_chnl_offline_update_all(coreotn_handle,
                                                            mux_stage,
                                                            ho_chnl_id,
                                                            new_lo_chnl_ids,
                                                            new_lo_chnl_num);
        }
              
        /* 4) configure STS_SW */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_switch_cfg(odtu_dmx_handle_ptr,
                                                  ho_chnl_id, TRUE);                                                  
        } 
           
        if (PMC_SUCCESS == ret_val)   
        {  
            /* 7) provisiong ODUJAT including the credit generator.
            ** only one offline page is provisioned** 
            */ 
            
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odujat_oduksc_page_swap(odujat_handle_ptr,
                                                  new_lo_chnl_ids,
                                                  new_lo_chnl_num,
                                                  FALSE);
            }

            /* 8) activate ODUJAT channel */ 
            for (i = 0; i < new_lo_chnl_num && PMC_SUCCESS == ret_val; i++)
            {
                ret_val = odujat_chnl_activate(odujat_handle_ptr, new_lo_chnl_ids[i], TRUE);
            }                                        

            /* 9) provision all channels in ODUKSC and swap the page.
            ** Only one offline page is configured
            */
            if (PMC_SUCCESS == ret_val)
            {            
                ret_val = oduksc_all_chnls_update(oduksc_handle_ptr,
                                                  new_lo_chnl_ids,
                                                  new_lo_chnl_num,
                                                  TRUE);
            }
            
            /* 10) activate the newly provisioned ODUKSC channels */
            for (i = 0; i < new_lo_chnl_num && PMC_SUCCESS == ret_val; i++)
            {
                ret_val = oduksc_chnl_activate_super_prov(oduksc_handle_ptr, new_lo_chnl_ids[i]);

            }                    
        }
                
        /* if COREOTN is in full operational */
        if (PMC_SUCCESS == ret_val)
        {
            if (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)
            {
                /* 1) get all channels being added */
                for (i = 0; i < new_lo_chnl_num && PMC_SUCCESS == ret_val; i++)
                {
                    if (coreotn_handle->var.rx_mo_chnl_ctxt[new_lo_chnl_ids[i]].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
                    {
                        new_unchan_lo_chnl_ids[unchan_cnt] = new_lo_chnl_ids[i];
                        unchan_cnt++;
                    }
                }

                /* 2) configure ODUKSC in ODUJAT and swap the page */
                ret_val = odujat_oduksc_page_swap(coreotn_handle->odujat2_handle,
                                                  new_unchan_lo_chnl_ids,
                                                  unchan_cnt,
                                                  FALSE);
            
                /* 3) configure ODUKSC and swap the page */
                if (PMC_SUCCESS == ret_val)
                {           
                    ret_val = oduksc_all_chnls_update(coreotn_handle->oduksc2_handle,
                                                      new_unchan_lo_chnl_ids,
                                                      unchan_cnt,
                                                      TRUE);
                }
                     
                for (i = 0; i < unchan_cnt && PMC_SUCCESS == ret_val; i++)
                {
                    ret_val = odujat_chnl_activate(coreotn_handle->odujat2_handle, new_unchan_lo_chnl_ids[i], TRUE);   

                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = oduksc_chnl_activate_super_prov(coreotn_handle->oduksc2_handle, new_unchan_lo_chnl_ids[i]);
                    }
                }
                 
            } /* end of coreotn_ss_operational */
        }
        
        /* update the channel state */      
        for (i = 0; i < new_lo_chnl_num; i++)
        {
           coreotn_handle->var.rx_mo_chnl_ctxt[new_lo_chnl_ids[i]].chnl_state = COREOTN_CHNL_OPERATIONAL;
        }
    }
    else if (mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        /* this function is called for MUX_STAGE_ONE thus we check MO channel state */
        /* if this is the last LO ODU then configure STS_SW, swap and configure offline_page */
       
        
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_rx_lo_chnl_ids_get(coreotn_handle,
                                                 mux_stage,
                                                 ho_chnl_id,
                                                 new_lo_chnl_ids,
                                                 &new_lo_chnl_num);                                                
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* when adding LO channels to an empty MO and the proxy MO is not provisioned */
            /*if (coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == new_lo_chnl_num
                && (TRUE == pmc_coreotn_dmx_two_stage_proxy_mo_chnl_prov_revision(&coreotn_handle->base)
                    && !(coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].payload_format != UTIL_GLOBAL_ODU_UNCHANNELIZED
                         && coreotn_handle->var.rx_lo_chnl_ctxt[ho_chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)))
            {*/
            /* this is not to swap the page. This is to configure STS_SW non-algo regs
            ** do no call this again if MO is already active with LO channels** 
            */
            if (coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == new_lo_chnl_num)
            { 
                ret_val = odtu_dmx_ho_chnl_activate(coreotn_handle->odtu_dmx2_handle,
                                                    ho_chnl_id);
            }

            if (ret_val == (UINT32)ODTU_DMX_CHNL_OPERATIONAL)
            {
                ret_val = PMC_SUCCESS;

                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                                  coreotn_handle->odtu_dmx2_handle,
                                                                  ho_chnl_id);
                 }
            }
            else {
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                                  coreotn_handle->odtu_dmx2_handle,
                                                                  ho_chnl_id);
                }

                if (coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == new_lo_chnl_num)
                {
                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = coreotn_rx_ho_chnl_offline_update(coreotn_handle,
                                                                    ho_chnl_id,
                                                                    mux_stage,
                                                                    coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].odu_container,
                                                                    coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].payload_format);

                    }
                }
            }
        }
        
        /* 3) configure offline page */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_rx_lo_chnl_offline_update_all(coreotn_handle,
                                                            mux_stage,
                                                            ho_chnl_id,
                                                            new_lo_chnl_ids,
                                                            new_lo_chnl_num);
        }
        
        /* 4) configure STS_SW */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_switch_cfg(coreotn_handle->odtu_dmx2_handle,
                                                  ho_chnl_id, TRUE);                                                  
        }   

        if (PMC_SUCCESS == ret_val)   
        {       
            /* 7) provision ODUJAT including credit generator and swap the page
            ** Only one offline page is configured
            */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odujat_oduksc_page_swap(coreotn_handle->odujat2_handle,
                                                  new_lo_chnl_ids,
                                                  new_lo_chnl_num,
                                                  FALSE);
            }

            /* 8) activate ODUJAT channels */
            for (i = 0; i < new_lo_chnl_num && PMC_SUCCESS == ret_val; i++)
            {
                ret_val = odujat_chnl_activate(coreotn_handle->odujat2_handle, new_lo_chnl_ids[i], TRUE);
                
            }                                         

            /* 9) configure ODUKSC and swap the page. Only one offling page is configured */
            if (PMC_SUCCESS == ret_val)
            {            
                ret_val = oduksc_all_chnls_update(coreotn_handle->oduksc2_handle,
                                                  new_lo_chnl_ids,
                                                  new_lo_chnl_num,
                                                  TRUE);
            }
            
            /* 10) activate the newly provisioned ODUKSC channels */
            for (i = 0; i < new_lo_chnl_num && PMC_SUCCESS == ret_val; i++)
            {
                ret_val = oduksc_chnl_activate_super_prov(coreotn_handle->oduksc2_handle, new_lo_chnl_ids[i]);

            }                   
        }

        /* update the channel state */      
        for (i = 0; i < new_lo_chnl_num; i++)
        {
           coreotn_handle->var.rx_lo_chnl_ctxt[new_lo_chnl_ids[i]].chnl_state = COREOTN_CHNL_OPERATIONAL;
        }
    }
    
    PMC_RETURN(ret_val);
    
} /* coreotn_rx_lo_chnl_offline_activate_all */


/*******************************************************************************
*  coreotn_tx_lo_chnl_mux_none_or_one_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_lo_chnl_activate for the 
*   mux_stage == COREOTN_MUX_STAGE_NONE or
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   ho_chnl_id          - HO ODU channel ID that the current LO belongs to.
*                         Valid range: 0 - 95
*   *lo_mux_handle_ptr  - pointer to the lo_mux_handle instance
*
* OUTPUTS:
*   *lo_odu_rate        - LO ODUj type. See util_global_odukp_type_t.
*   *odu_flex_rate      - HO ODUk type. See util_global_odukp_type_t. 
*                         If two stage is used, this argument refers to MO odu type. 
*                         If one stage is used, this argument refers to HO odu type.
*   *mapping_mode       - mapping type used. See coreotn_mapping_type_t.
*   *tribslot_mask      - 3 x 32 bit mask to represent the tributary slot
*                         assignment for this LO channel.
*                         Valid range: 0 - 0x4F\n
*                          - Bit 0 - Tributary slot 1\n
*                          - Bit 1 - Tributary slot 2\n
*                          - Bit 2 - Tributary slot 3\n
*                               ...\n
*                          - Bit 79 - Tributary slot 80\n
*   *trib_port          - a tributary port number for all tributary slot
*                         locations for the LO channel. This data is used for
*                         MSI coding.
*                         For the following payload types with fixed MSI
*                         assignment, this argument is ignored and MSI data is
*                         assigned internally as per G.709 standards:\n
*                         -- ODTU01\n
*                         -- ODTU12 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU2)\n
*                         -- ODTU13 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU3)
*   *ho_payload_format  - tributary slot size. See util_global_odu_line_payload_t.
*                         Valid values:\n
*                          -- For 1.25G TS, set to ODU_TS_1G25\n
*                          -- For 2.5G TS, set to ODU_TS_2G5\n
*   *ho_odu_rate        - HO ODU container type that the LO ODU channel belongs
*                         to. See util_global_odukp_type_t.
*   *cbr_flex_rate      - The client rate in kb/sec
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_none_or_one_activate(coreotn_handle_t *coreotn_handle,
                                                              UINT32 chnl_id,
                                                              UINT32 ho_chnl_id,
                                                              odtu_mux_handle_t *lo_mux_handle_ptr,
                                                              util_global_odukp_type_t* lo_odu_rate,
                                                              UINT32* odu_flex_rate,
                                                              coreotn_mapping_type_t* mapping_mode,
                                                              UINT32 tribslot_mask[COREOTN_TRIB_WRD_CNT],
                                                              UINT32* trib_port,
                                                              util_global_odu_line_payload_t* ho_payload_format,
                                                              util_global_odukp_type_t* ho_odu_rate,
                                                              UINT32* cbr_flex_rate)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;

    UINT32 i;
    PMC_ENTRY();

    PMC_ASSERT(NULL != lo_mux_handle_ptr, COREOTN_ERR_NULL_HANDLE, 0, 0);

    /* check the current mo channel state */
    if (coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED);
    }

    /* if this is MO that needs to be channelized then we want to activate this here */
    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)  
    {
        ret_val = odtu_mux_lo_chnl_activate(lo_mux_handle_ptr,
                                            chnl_id, ho_chnl_id);
    }

    if (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)
    {
        if (coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
        {
            if (pmc_is_digi_rev_a_revision(&coreotn_handle->base) == TRUE)
            {
                if (PMC_SUCCESS == ret_val)
                {
                    /* take OHFS_INSERT CFC out of reset after HO has been activated */
                    ret_val = odtu_mux_ohfs_insert_cfc_fifo_deactivate(coreotn_handle->odtu_mux2_handle, chnl_id);  
                }
                
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = odtu_mux_ho_chnl_activate(coreotn_handle->odtu_mux2_handle,
                                                        chnl_id);
                }
                
                if (PMC_SUCCESS == ret_val)
                {
                    /* take OHFS_INSERT CFC out of reset after HO has been activated */
                    ret_val = odtu_mux_ohfs_insert_cfc_fifo_activate(coreotn_handle->odtu_mux2_handle, chnl_id);  
                } 
            }
            else {
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = odtu_mux_ho_chnl_activate(coreotn_handle->odtu_mux2_handle,
                                                        chnl_id);
                }
            }                                
    
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odtu_mux_lo_chnl_activate(coreotn_handle->odtu_mux2_handle,
                                                    chnl_id, chnl_id);
            }
        }
    }

    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT  
        && PMC_SUCCESS == ret_val)
    {
        /* update the channel state */
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_OPERATIONAL;
    }

    /* extract information for MO channel */ 
    *ho_odu_rate = coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].odu_container;
    *lo_odu_rate = coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].lo_odu_rate;
    *mapping_mode = coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].mapping_mode;
    *ho_payload_format = coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].payload_format;

    for (i = 0; i < COREOTN_TRIB_WRD_CNT; i++)
    {
        tribslot_mask[i] = coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].tribslot_mask[i];
    }

    *trib_port = coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].trib_port;
    *odu_flex_rate = coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].odu_flex_rate;
    *cbr_flex_rate = coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].cbr_flex_rate;

    PMC_RETURN(ret_val);

} /* coreotn_tx_lo_chnl_mux_none_or_one_activate */

/*******************************************************************************
*  coreotn_tx_lo_chnl_mux_none_or_two_activate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_lo_chnl_activate for the 
*   mux_stage == COREOTN_MUX_STAGE_NONE or
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   ho_chnl_id          - HO ODU channel ID that the current LO belongs to.
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   *lo_odu_rate        - LO ODUj type. See util_global_odukp_type_t.
*   *odu_flex_rate      - HO ODUk type. See util_global_odukp_type_t. 
*                         If two stage is used, this argument refers to MO odu type. 
*                         If one stage is used, this argument refers to HO odu type.
*   *mapping_mode       - mapping type used. See coreotn_mapping_type_t.
*   *tribslot_mask      - 3 x 32 bit mask to represent the tributary slot
*                         assignment for this LO channel.
*                         Valid range: 0 - 0x4F\n
*                          - Bit 0 - Tributary slot 1\n
*                          - Bit 1 - Tributary slot 2\n
*                          - Bit 2 - Tributary slot 3\n
*                               ...\n
*                          - Bit 79 - Tributary slot 80\n
*   *trib_port          - a tributary port number for all tributary slot
*                         locations for the LO channel. This data is used for
*                         MSI coding.
*                         For the following payload types with fixed MSI
*                         assignment, this argument is ignored and MSI data is
*                         assigned internally as per G.709 standards:\n
*                         -- ODTU01\n
*                         -- ODTU12 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU2)\n
*                         -- ODTU13 with tribslot_type = UTIL_GLOBAL_ODU_TS_2G5\n
*                            (i.e. lo_odu_type = ODU1 and ho_odu_type = ODU3)
*   *ho_payload_format  - tributary slot size. See util_global_odu_line_payload_t.
*                         Valid values:\n
*                          -- For 1.25G TS, set to ODU_TS_1G25\n
*                          -- For 2.5G TS, set to ODU_TS_2G5\n
*   *ho_odu_rate        - HO ODU container type that the LO ODU channel belongs
*                         to. See util_global_odukp_type_t.
*   *cbr_flex_rate      - The client rate in kb/sec
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_none_or_two_activate(coreotn_handle_t *coreotn_handle,
                                                              UINT32 chnl_id,
                                                              UINT32 ho_chnl_id,
                                                              util_global_odukp_type_t* lo_odu_rate,
                                                              UINT32* odu_flex_rate,
                                                              coreotn_mapping_type_t* mapping_mode,
                                                              UINT32 tribslot_mask[COREOTN_TRIB_WRD_CNT],
                                                              UINT32* trib_port,
                                                              util_global_odu_line_payload_t* ho_payload_format,
                                                              util_global_odukp_type_t* ho_odu_rate,
                                                              UINT32* cbr_flex_rate)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;

    UINT32 i;
    PMC_ENTRY();

    /* check the current lo channel state */
    if (coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED);
    }
 
    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_lo_chnl_activate(coreotn_handle->odtu_mux2_handle,
                                                chnl_id, ho_chnl_id);
        }
                                            
        if (PMC_SUCCESS == ret_val)
        {
            /* update the channel state */
            coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_OPERATIONAL;
        }
    }
    
    /* extract information for MO channel */ 
    *ho_odu_rate = coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].odu_container;
    *lo_odu_rate = coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].lo_odu_rate;
    *mapping_mode = coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].mapping_mode;
    *ho_payload_format = coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].payload_format;

    for (i = 0; i < COREOTN_TRIB_WRD_CNT; i++)
    {
        tribslot_mask[i] = coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].tribslot_mask[i];
    }

    *trib_port = coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].trib_port;
    *odu_flex_rate = coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].odu_flex_rate;
    *cbr_flex_rate = coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].cbr_flex_rate;

    PMC_RETURN(ret_val);

} /* coreotn_tx_lo_chnl_mux_none_or_two_activate */

/*******************************************************************************
*  coreotn_rx_ho_chnl_mux_none_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_ho_chnl_deactivate for the 
*   mux_stage == COREOTN_MUX_STAGE_NONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_none_deactivate(coreotn_handle_t *coreotn_handle,
                                                         UINT32 chnl_id,
                                                         coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    /* update the channel state */
    if ((coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL
         && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL
         && coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL)
        && (coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START
            && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START
            && coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START))
    {
        PMC_RETURN(COREOTN_ERR_CHNL_INVALID_STATE);
    }

    if (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE
        || coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)
    {
        ret_val = odtu_dmx_ho_chnl_deactivate(coreotn_handle->odtu_dmx1_handle,
                                              chnl_id);

        /* put lo channel in reset */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_lo_chnl_deactivate(coreotn_handle->odtu_dmx1_handle,
                                                  chnl_id, chnl_id);
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        /* if true deactivation, deactivate odujat */
        if ((coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL) &&
            (coreotn_handle->var.init_operation != COREOTN_SS_SYSOTN_MODE)) 
        {            
            if (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE
                || coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)
            {
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = odujat_chnl_deactivate(coreotn_handle->odujat1_handle, chnl_id);
                }

                /* deactivate oduksc */
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = oduksc_chnl_deactivate(coreotn_handle->oduksc1_handle, chnl_id);
                }
            }
        }
    }

    if ((coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)) 
    {
       
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_deactivate(coreotn_handle->odtu_dmx2_handle,
                                                  chnl_id);
        }

        /* put lo channel in reset */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_lo_chnl_deactivate(coreotn_handle->odtu_dmx2_handle,
                                                  chnl_id, chnl_id);
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* if true deactivation, deactivate odujat */
            if (coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
            {
                ret_val = odujat_chnl_deactivate(coreotn_handle->odujat2_handle, chnl_id);

                /* deactivate oduksc */
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = oduksc_chnl_deactivate(coreotn_handle->oduksc2_handle, chnl_id);
                }
            }
        }
    }

    /* update the channel state */
    if (PMC_SUCCESS == ret_val)
    {
        if (coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL
            && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL
            && coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
        {
            coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
            coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
        }
    }

    PMC_RETURN(ret_val);

} /* coreotn_rx_ho_chnl_mux_none_deactivate */

/*******************************************************************************
*  coreotn_rx_ho_chnl_mux_one_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_ho_chnl_deactivate for the 
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_one_deactivate(coreotn_handle_t *coreotn_handle,
                                                        UINT32 chnl_id,
                                                        coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    odtu_dmx_handle_t *ho_dmx_handle_ptr;
    PMC_ENTRY();

    /* check the current ho channel state */
    if (coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL
        && coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_INVALID_STATE);
    }

    if (coreotn_handle->var.init_operation != COREOTN_SS_SYSOTN_MODE) 
    {
        ho_dmx_handle_ptr = coreotn_handle->odtu_dmx1_handle;

    } 
    else 
    {
        ho_dmx_handle_ptr = coreotn_handle->odtu_dmx2_handle;
    }

    if ((coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)) 
    {
        ret_val = odtu_dmx_ho_chnl_deactivate(ho_dmx_handle_ptr, chnl_id);
    }

    /* update the ho channel state */
    if (PMC_SUCCESS == ret_val)
    {
        if (coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
        {
            if (PMC_SUCCESS == ret_val)
            {
                coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
            }
        }
    }

    PMC_RETURN(ret_val);

} /* coreotn_rx_ho_chnl_mux_one_deactivate */

/*******************************************************************************
*  coreotn_rx_ho_chnl_mux_two_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_ho_chnl_deactivate for the 
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_two_deactivate(coreotn_handle_t *coreotn_handle,
                                                        UINT32 chnl_id,
                                                        coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    if (coreotn_handle->var.init_operation != COREOTN_SS_ONE_STAGE_MUXING_MODE)
    {
        /* check the current mo channel state */
        if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
        {
            if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL
                && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)
            {
                PMC_RETURN(COREOTN_ERR_CHNL_INVALID_STATE);
            }
        }

        /* test to see if DUMMY channel used for this HO and if so reset it 
        ** code will only be able to reset dummy channels for channels that
        ** have been set. Only applies to the second stage DMX 
        */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_dummy_schd_entry_reset(coreotn_handle->odtu_dmx2_handle,
                                                      chnl_id);
        }
        
        if (PMC_SUCCESS == ret_val)
        {        
            if (coreotn_handle->var.prov_mode != COREOTN_ODU_CHNL_PROV_ALL
                && (FALSE == pmc_coreotn_dmx_two_stage_proxy_mo_chnl_prov_revision(&coreotn_handle->base)
                    || (TRUE == pmc_coreotn_dmx_two_stage_proxy_mo_chnl_prov_revision(&coreotn_handle->base)
                        && !(coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL
                         && coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL))))
            {                 
                ret_val = odtu_dmx_ho_chnl_deactivate(coreotn_handle->odtu_dmx2_handle,
                                                      chnl_id);
            }     
            else if ((coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL)
                    && (TRUE == pmc_coreotn_dmx_two_stage_proxy_mo_chnl_prov_revision(&coreotn_handle->base))
                    && (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_DEPROV_PENDING
                         && coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL))
            {
                ret_val = odtu_dmx_ho_chnl_deactivate(coreotn_handle->odtu_dmx2_handle,
                                                      chnl_id);

            }
        }
                                                          
        /* update the ho channel state */
        if (PMC_SUCCESS == ret_val)
        {
            if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
            {
                coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
            }
        }
    }
    PMC_RETURN(ret_val);

} /* coreotn_rx_ho_chnl_mux_two_deactivate */

/*******************************************************************************
*  coreotn_tx_ho_chnl_mux_none_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_ho_chnl_deactivate for the 
*   mux_stage == COREOTN_MUX_STAGE_NONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_none_deactivate(coreotn_handle_t *coreotn_handle,
                                                         UINT32 chnl_id,
                                                         coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    /* check the current channel state */
    if ((coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL
         && coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL
         && coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL)
        && (coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START
            && coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START
            && coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START))
    {
        PMC_RETURN(COREOTN_ERR_CHNL_INVALID_STATE);
    }

    if (coreotn_handle->var.init_operation == COREOTN_SS_ONE_STAGE_MUXING_MODE 
        || coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) 
    {
        ret_val = odtu_mux_ho_chnl_deactivate(coreotn_handle->odtu_mux1_handle,
                                              chnl_id);

        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_lo_chnl_deactivate(coreotn_handle->odtu_mux1_handle,
                                                  chnl_id, chnl_id);
        }
    }
   
    if ((coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)) {

        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_ho_chnl_deactivate(coreotn_handle->odtu_mux2_handle,
                                                  chnl_id);
        }

        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_lo_chnl_deactivate(coreotn_handle->odtu_mux2_handle,
                                                  chnl_id, chnl_id);
        }
    }

    /* update the channel state */
    if (coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL
        && coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL
        && coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
    {
        if (PMC_SUCCESS == ret_val)
        {
            coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
            coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
            coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
        }
    }

    PMC_RETURN(ret_val);

} /* coreotn_tx_ho_chnl_mux_none_deactivate */

/*******************************************************************************
*  coreotn_tx_ho_chnl_mux_one_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_ho_chnl_deactivate for the 
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_one_deactivate(coreotn_handle_t *coreotn_handle,
                                                        UINT32 chnl_id,
                                                        coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    /* check the current channel state */
    if (coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL
        && coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_INVALID_STATE);
    }

    if(coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE )
    {
        ret_val = odtu_mux_ho_chnl_deactivate(coreotn_handle->odtu_mux2_handle,
                                              chnl_id);
    }
    else
    {
        ret_val = odtu_mux_ho_chnl_deactivate(coreotn_handle->odtu_mux1_handle,
                                              chnl_id);
    }

    /* update the channel state */
    if (PMC_SUCCESS == ret_val)
    {
        if (coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
        {
            if (PMC_SUCCESS == ret_val)
            {
                coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
            }
        }
    }

    PMC_RETURN(ret_val);

} /* coreotn_tx_ho_chnl_mux_one_deactivate */

/*******************************************************************************
*  coreotn_tx_ho_chnl_mux_two_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_ho_chnl_deactivate for the 
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_two_deactivate(coreotn_handle_t *coreotn_handle,
                                                        UINT32 chnl_id,
                                                        coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    if (coreotn_handle->var.init_operation != COREOTN_SS_ONE_STAGE_MUXING_MODE)
    {
        /* check the current channel state */
        if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
        {
            if (coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_OPERATIONAL
                && coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_START)
            {
                PMC_RETURN(COREOTN_ERR_CHNL_INVALID_STATE);
            }
        }

        ret_val = odtu_mux_ho_chnl_deactivate(coreotn_handle->odtu_mux2_handle,
                                              chnl_id);

        if (TRUE == pmc_coreotn_schd_extra_channel_revision(&coreotn_handle->base))
        {
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = coreotn_fo1_mpmo_scbs3_dummy_cycle_remove(coreotn_handle, chnl_id);
            }
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* update the channel state */
            if (coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
            {
                if (PMC_SUCCESS == ret_val)
                {
                    coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
                }
            }
        }
    }

    PMC_RETURN(ret_val);

} /* coreotn_tx_ho_chnl_mux_two_deactivate */

/*******************************************************************************
*  coreotn_rx_lo_chnl_mux_none_or_one_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_lo_chnl_deactivate for the 
*   mux_stage == COREOTN_MUX_STAGE_NONE or
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   ho_chnl_id          - HO ODU channel ID that the current LO belongs to.
*                         Valid range: 0 - 95
*   *lo_dmx_handle_ptr  - pointer to the lo_dmx handle instance.
*   *lo_odujat_handle_ptr - pointer to the odujat handle instance.
*   *lo_oduksc_handle_ptr - pointer to the oduksc handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_none_or_one_deactivate(coreotn_handle_t *coreotn_handle,
                                                                UINT32 chnl_id,
                                                                UINT32 ho_chnl_id,
                                                                odtu_dmx_handle_t *lo_dmx_handle_ptr,
                                                                odujat_handle_t *lo_odujat_handle_ptr,
                                                                oduksc_handle_t *lo_oduksc_handle_ptr)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    BOOL8 super_prov = FALSE;
    PMC_ENTRY();
 
    /* This is removing the last MO from the HO. HO will become empty.
    ** here set OHFS_REMOVE NULL_FRAME_MODE = '1'. Do this only for true deprovisioning
    ** this gets called when provisioning as well to place the LO_CH_RSTB = 0.
    */
    if (TRUE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base))
    {
        if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
        {
            if (coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 1)
            {
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = odtu_dmx_ho_null_frame_cfg(lo_dmx_handle_ptr,
                                                         ho_chnl_id, 1);
                }
            } 
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        ret_val = odtu_dmx_lo_chnl_deactivate(lo_dmx_handle_ptr, chnl_id, ho_chnl_id);
    }

    if (PMC_SUCCESS == ret_val)
    {
        /* deactivate odujat */
        if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
        {
            /* retrieve super-prov mode */
            super_prov = (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL)? TRUE:FALSE;


            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odujat_chnl_deactivate(lo_odujat_handle_ptr, chnl_id);

                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = oduksc_chnl_deactivate(lo_oduksc_handle_ptr, chnl_id);
                }                 
            }

            if (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)
            {
                if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
                {
                    if (PMC_SUCCESS == ret_val)
                    {
                        if (super_prov == TRUE)
                        {
                            ret_val = odujat_chnl_deactivate_super_deprov(coreotn_handle->odujat2_handle, chnl_id);

                            if (PMC_SUCCESS == ret_val)
                            {
                                ret_val = oduksc_chnl_deactivate_super_deprov(coreotn_handle->oduksc2_handle, chnl_id);
                            }
                        }
                        else{
                            ret_val = odujat_chnl_deactivate(coreotn_handle->odujat2_handle, chnl_id);

                            if (PMC_SUCCESS == ret_val)
                            {
                                ret_val = oduksc_chnl_deactivate(coreotn_handle->oduksc2_handle, chnl_id);
                            }
                        }
                    }

                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = odtu_dmx_ho_chnl_deactivate(coreotn_handle->odtu_dmx2_handle,
                                                              chnl_id);
                    }

                    /* activate lo channel in passthru */
                    if (PMC_SUCCESS == ret_val)
                    {
                        ret_val = odtu_dmx_lo_chnl_deactivate(coreotn_handle->odtu_dmx2_handle,
                                                              chnl_id, chnl_id);
                    }
                }
            }

            if (PMC_SUCCESS == ret_val)
            {
                /* update the channel state */
                coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
            }
        }
    }

    PMC_RETURN(ret_val);

} /* coreotn_rx_lo_chnl_mux_none_or_one_deactivate */

/*******************************************************************************
*  coreotn_rx_lo_chnl_mux_none_or_two_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_lo_chnl_deactivate for the 
*   mux_stage == COREOTN_MUX_STAGE_NONE or
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   ho_chnl_id          - HO ODU channel ID that the current LO belongs to.
*                         Valid range: 0 - 95
*   *lo_dmx_handle_ptr  - pointer to the lo_dmx handle instance.
*   *lo_odujat_handle_ptr - pointer to the odujat handle instance.
*   *lo_oduksc_handle_ptr - pointer to the oduksc handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_none_or_two_deactivate(coreotn_handle_t *coreotn_handle,
                                                                UINT32 chnl_id,
                                                                UINT32 ho_chnl_id,
                                                                odtu_dmx_handle_t *lo_dmx_handle_ptr,
                                                                odujat_handle_t *lo_odujat_handle_ptr,
                                                                oduksc_handle_t *lo_oduksc_handle_ptr)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    BOOL8 super_prov = FALSE;
    PMC_ENTRY();

    /* check the current lo channel state */
    if (coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_EQUIPPED)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_INVALID_STATE);
    }

    if (TRUE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base)
        || TRUE == pmc_coreotn_dmx_two_stage_proxy_mo_chnl_prov_revision(&coreotn_handle->base))
    {
        /* moving to here as new sequence */
        /* This is removing the last LO from the MO. MO will become empty.
        ** here set OHFS_REMOVE NULL_FRAME_MODE = '1'. Only call this when the channel
        ** is being deprovisioned. This function is called prior to provisioning as well
        ** to place the channel in reset. So qualify with channel state that this
        ** is truly deprovisioning.
        */
        if (coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
        {
            if (coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 1)
            {
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = odtu_dmx_ho_null_frame_cfg(coreotn_handle->odtu_dmx2_handle,
                                                         ho_chnl_id, 1);
                }
            }
        } 
    }
    ret_val = odtu_dmx_lo_chnl_deactivate(coreotn_handle->odtu_dmx2_handle,
                                          chnl_id, ho_chnl_id);

    if (coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
    {
        super_prov = (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL)? TRUE:FALSE;
        /* this is a LO channel with its unique channel ID
        ** framer channel can be shut off for this LO channel
        */
        ret_val = odu_rfrm_chnl_prov(coreotn_handle->odu_rfrm_stg3a_handle,
                                     chnl_id, FALSE, 0, 0, TRUE);

        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odujat_chnl_deactivate(coreotn_handle->odujat2_handle, chnl_id);

            if (PMC_SUCCESS == ret_val)
            {
                ret_val = oduksc_chnl_deactivate(coreotn_handle->oduksc2_handle, chnl_id);
            }
        }

        if (PMC_SUCCESS == ret_val)
        {
            /* update the channel state */
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
        }
    }

    PMC_RETURN(ret_val);

} /* coreotn_rx_lo_chnl_mux_none_or_two_deactivate */

/*******************************************************************************
*  coreotn_tx_lo_chnl_mux_none_or_one_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_lo_chnl_deactivate for the 
*   mux_stage == COREOTN_MUX_STAGE_NONE or
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   ho_chnl_id          - HO ODU channel ID that the current LO belongs to.
*                         Valid range: 0 - 95
*   *lo_mux_handle_ptr  - pointer to the lo_mux_handle instance
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_none_or_one_deactivate(coreotn_handle_t *coreotn_handle,
                                                                UINT32 chnl_id,
                                                                UINT32 ho_chnl_id,
                                                                odtu_mux_handle_t *lo_mux_handle_ptr)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();


    if (PMC_SUCCESS == ret_val )
    {
        ret_val = odtu_mux_lo_chnl_deactivate(lo_mux_handle_ptr,
                                              chnl_id, ho_chnl_id);
    }

    /* update the channel state */
    if (PMC_SUCCESS == ret_val)
    {
        if (coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
        {
            coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        /* For passthru MO channel */
        if (coreotn_handle->var.init_operation == COREOTN_SS_OPERATIONAL_MODE)
        {
            if (coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
            {
                ret_val = odtu_mux_ho_chnl_deactivate(coreotn_handle->odtu_mux2_handle, chnl_id);
                
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = odtu_mux_lo_chnl_deactivate(coreotn_handle->odtu_mux2_handle, chnl_id, ho_chnl_id);
                }
            }
        }
    }

    PMC_RETURN(ret_val);

} /* coreotn_tx_lo_chnl_mux_none_or_one_deactivate */

/*******************************************************************************
*  coreotn_tx_lo_chnl_mux_none_or_two_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_lo_chnl_deactivate for the 
*   mux_stage == COREOTN_MUX_STAGE_NONE or
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - LO ODU channel ID to be configured
*                         Valid range: 0 - 95
*   ho_chnl_id          - HO ODU channel ID that the current LO belongs to.
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_none_or_two_deactivate(coreotn_handle_t *coreotn_handle,
                                                                UINT32 chnl_id,
                                                                UINT32 ho_chnl_id)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    /* check the current mo channel state */
    if (coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_EQUIPPED)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_INVALID_STATE);
    }

    if (TRUE == pmc_coreotn_mux_empty_ho_order_revision(&coreotn_handle->base))
    {
    
        UINT32 lo_first_calendar;
        UINT32 mo_first_calendar;
        
        if (coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
        {
            ret_val = coreotn_db_first_cal_entry_get(coreotn_handle,
                                                     COREOTN_CHNL_ORDER_LO,
                                                     0,
                                                     chnl_id,
                                                     &lo_first_calendar);
            
            if (PMC_SUCCESS == ret_val)
            {        
                ret_val = coreotn_db_first_cal_entry_get(coreotn_handle,
                                                         COREOTN_CHNL_ORDER_MO,
                                                         0,
                                                         ho_chnl_id,
                                                         &mo_first_calendar);   
            }    
            
            if (PMC_SUCCESS == ret_val)
            {
                if (lo_first_calendar == mo_first_calendar)
                {   
                    /* this LO channel occupies the first calendar slot of the MO */
                    ret_val = odtu_mux_lo_chnl_deactivate_ch_state_chk_only(coreotn_handle->odtu_mux2_handle, 
                                                                            chnl_id, ho_chnl_id); 
                }
                else {
                    ret_val = odtu_mux_lo_chnl_deactivate(coreotn_handle->odtu_mux2_handle,
                                                          chnl_id, ho_chnl_id);
                }
            }
        }
    }
    else
    {
        ret_val = odtu_mux_lo_chnl_deactivate(coreotn_handle->odtu_mux2_handle,
                                              chnl_id, ho_chnl_id);
    }
                                              
    /* update the channel state */
    if (PMC_SUCCESS == ret_val)
    {
        if (coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
        {

            if (PMC_SUCCESS == ret_val)
            {
                coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state = COREOTN_CHNL_EQUIPPED;
            }
        }
    }

    PMC_RETURN(ret_val);

} /* coreotn_tx_lo_chnl_mux_none_or_two_deactivate */

/*******************************************************************************
*  coreotn_rx_ho_chnl_mux_none_deprov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_ho_chnl_deprov for the 
*   mux_stage == COREOTN_MUX_STAGE_NONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   deprov_rfrm_tfrm_cfg - TRUE : provision HO RFRM
*                          FALSE : preserve current RFRM configuration
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_none_deprov(coreotn_handle_t *coreotn_handle,
                                                     UINT32 chnl_id,
                                                     coreotn_mux_stage_t mux_stage,
                                                     BOOL deprov_rfrm_tfrm_cfg)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    if ((coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)) 
    {
            

        
        if(deprov_rfrm_tfrm_cfg)
        {
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odu_rfrm_chnl_prov(coreotn_handle->odu_rfrm_stgN_handle,
                                             chnl_id, FALSE, 0, 0, TRUE);
            }
        }
    } 
    else 
    {
        /* disable ODU_RFRM channel while calendar is in tact */

        if(deprov_rfrm_tfrm_cfg)
        {
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odu_rfrm_chnl_prov(coreotn_handle->odu_rfrm_stg1_handle,
                                             chnl_id, FALSE, 0, 0, TRUE);
            }
        }

        if (coreotn_handle->var.init_operation != COREOTN_SS_BYPASS_MODE)
        {
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odtu_dmx_ho_chnl_deprov(coreotn_handle->odtu_dmx1_handle,
                                                  (odtu_dmx_stage_instance_t)mux_stage, 
                                                  chnl_id, FALSE);
            }

            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odujat_chnl_deprov(coreotn_handle->odujat1_handle, chnl_id, mux_stage, FALSE, FALSE);
            }
                
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = oduksc_chnl_deprov(coreotn_handle->oduksc1_handle, chnl_id);
            }

            if (PMC_SUCCESS == ret_val)
            {
                ret_val = oduksc_chnl_update(coreotn_handle->oduksc1_handle, chnl_id, TRUE);
            }
        }
    }

    if (coreotn_handle->var.init_operation != COREOTN_SS_ONE_STAGE_MUXING_MODE)
    {    
        if (PMC_SUCCESS == ret_val && 
            coreotn_handle->var.init_operation != COREOTN_SS_SYSOTN_BYPASS_MODE)
        {
            ret_val = odtu_dmx_ho_chnl_deprov(coreotn_handle->odtu_dmx2_handle,
                                              (odtu_dmx_stage_instance_t)mux_stage, 
                                              chnl_id, FALSE);
        }
        
        if ((coreotn_handle->var.init_operation != COREOTN_SS_BYPASS_MODE) &&
            (coreotn_handle->var.init_operation != COREOTN_SS_SYSOTN_BYPASS_MODE)) 
        {
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odujat_chnl_deprov(coreotn_handle->odujat2_handle, chnl_id, mux_stage, FALSE, FALSE);
            }
            
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = oduksc_chnl_deprov(coreotn_handle->oduksc2_handle, chnl_id);
            }

            if (PMC_SUCCESS == ret_val)
            {
                ret_val = oduksc_chnl_update(coreotn_handle->oduksc2_handle, chnl_id, TRUE);
            }
        }
    }
    
    /* take FRM_RCP CFC FIFO out of reset as by default RCP_EN = 1 */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle, COREOTN_FO1_FRM_RCP,
                                           chnl_id, 0);
    }

    PMC_RETURN(ret_val);

} /* coreotn_rx_ho_chnl_mux_none_deprov */

/*******************************************************************************
*  coreotn_rx_ho_chnl_mux_one_deprov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_ho_chnl_deprov for the 
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   deprov_rfrm_tfrm_cfg - TRUE : deprov RFRM configuration
*                          FALSE : do no deprov RFRM configuration
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_one_deprov(coreotn_handle_t *coreotn_handle,
                                                    UINT32 chnl_id,
                                                    coreotn_mux_stage_t mux_stage,
                                                    BOOL deprov_rfrm_tfrm_cfg)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    odtu_dmx_handle_t *ho_dmx_handle_ptr;
    PMC_ENTRY();

    if ((coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE) ||
        (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)) 
    {
        ho_dmx_handle_ptr = coreotn_handle->odtu_dmx2_handle;
        
        if(deprov_rfrm_tfrm_cfg)
        {
            ret_val = odu_rfrm_chnl_prov(coreotn_handle->odu_rfrm_stgN_handle,
                                         chnl_id, FALSE, 0, 0, TRUE);
        }

    } 
    else 
    {
        ho_dmx_handle_ptr = coreotn_handle->odtu_dmx1_handle;

        if(deprov_rfrm_tfrm_cfg)
        {
            ret_val = odu_rfrm_chnl_prov(coreotn_handle->odu_rfrm_stg1_handle,
                                         chnl_id, FALSE, 0, 0, TRUE);
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        ret_val = odtu_dmx_ho_chnl_deprov(ho_dmx_handle_ptr,
                                          (odtu_dmx_stage_instance_t)mux_stage, 
                                          chnl_id, FALSE);
    }        

    if (TRUE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base))
    {
        /* This is removing HO. 
        ** here set OHFS_REMOVE NULL_FRAME_MODE = '0'. Start sending data to the switch
        */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_null_frame_cfg(ho_dmx_handle_ptr, chnl_id, 0);
        }
    } 

    PMC_RETURN(ret_val);

} /* coreotn_rx_ho_chnl_mux_one_deprov */

/*******************************************************************************
*  coreotn_rx_ho_chnl_mux_two_deprov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_ho_chnl_deprov for the 
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_ho_chnl_mux_two_deprov(coreotn_handle_t *coreotn_handle,
                                                    UINT32 chnl_id,
                                                    coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    /* second stage muxing */  
    if (coreotn_handle->var.init_operation != COREOTN_SS_ONE_STAGE_MUXING_MODE)
    {
        ret_val = odtu_dmx_ho_chnl_deprov(coreotn_handle->odtu_dmx2_handle,
                                          (odtu_dmx_stage_instance_t)mux_stage, 
                                          chnl_id, FALSE);
    }

    if (TRUE == pmc_coreotn_dmx_empty_ho_order_revision(&coreotn_handle->base))
    {
        /* This is removing MO from the HO. 
        ** here set OHFS_REMOVE NULL_FRAME_MODE = '0'. Start sending data to the switch
        */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_null_frame_cfg(coreotn_handle->odtu_dmx2_handle, chnl_id, 0);
        }   
    }

    PMC_RETURN(ret_val);

} /* coreotn_rx_ho_chnl_mux_two_deprov */

/*******************************************************************************
*  coreotn_tx_ho_chnl_mux_none_deprov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_ho_chnl_deprov for the 
*   mux_stage == COREOTN_MUX_STAGE_NONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   deprov_ho_cfg       - TRUE : deprovision HO TFRM configuration
*                         FALSE : preserve current TFRM configuration
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_none_deprov(coreotn_handle_t *coreotn_handle,
                                                     UINT32 chnl_id,
                                                     coreotn_mux_stage_t mux_stage,
                                                     BOOL deprov_ho_cfg)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();


    if ((coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE) ||  
        (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE)) 
    {

        if(deprov_ho_cfg)
        {
            /* Put STG1 TFRM in passthru */
            ret_val = odu_tfrm_chnl_prov(coreotn_handle->odu_tfrm_stgN_handle,chnl_id,
                                         ODU_TFRM_MESSAGE_DONT_CARE,
                                         ODU_TFRM_MESSAGE_DONT_CARE,
                                         ODU_TFRM_PM_TCM_START,
                                         FALSE);                    

                                         
            /* put FRM_RCP CFC FIFO in reset as by default RCP_EN = 1 */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle, 
                                                   COREOTN_FMF2_FRM_RCP12,
                                                   chnl_id, 0);
            }
        }

        if (PMC_SUCCESS == ret_val &&
            coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE ) 
        {
            ret_val = odtu_mux_ho_chnl_deprov(coreotn_handle->odtu_mux2_handle,
                                              (odtu_mux_stage_instance_t)mux_stage, 
                                              chnl_id, 0);
        }

    } 
    else 
    {

        if(deprov_ho_cfg)
        {
            /* Put STG1 TFRM in passthru */
            ret_val = odu_tfrm_chnl_prov(coreotn_handle->odu_tfrm_stg1_handle,chnl_id,
                                         ODU_TFRM_MESSAGE_DONT_CARE,
                                         ODU_TFRM_MESSAGE_DONT_CARE,
                                         ODU_TFRM_PM_TCM_START,
                                         FALSE);        
                                         
            /* put FRM_RCP CFC FIFO in reset as by default RCP_EN = 1 */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle, COREOTN_FMF1_FRM_RCP12,
                                                   chnl_id, 0);
            }
        }

        /* deprovisiong HO in the second MUX for NONE or ONE stage muxing cases*/ 
        if ((coreotn_handle->var.init_operation != COREOTN_SS_ONE_STAGE_MUXING_MODE) &&
            (coreotn_handle->var.init_operation != COREOTN_SS_BYPASS_MODE)) 
        {
            if (PMC_SUCCESS == ret_val) 
            {
                ret_val = odtu_mux_ho_chnl_deprov(coreotn_handle->odtu_mux2_handle,
                                                  (odtu_mux_stage_instance_t)mux_stage, 
                                                  chnl_id, 0);
            }
        }

        if (coreotn_handle->var.init_operation != COREOTN_SS_BYPASS_MODE)
        {
            if (PMC_SUCCESS == ret_val)
            {
                /* deprovisions HO in the first MUX for the HO channel based configuration */
                ret_val = odtu_mux_ho_chnl_deprov(coreotn_handle->odtu_mux1_handle,
                                                  (odtu_mux_stage_instance_t)mux_stage, 
                                                  chnl_id, 0);  
            }
        }
    }

    PMC_RETURN(ret_val);

} /* coreotn_tx_ho_chnl_mux_none_deprov */

/*******************************************************************************
*  coreotn_tx_ho_chnl_mux_one_deprov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_ho_chnl_deprov for the 
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*   deprov_tfrm_rfrm_cfg  - TRUE : remove the HO TFRM/RFRM configuration
*                           FALSE : preserve the HO TFRM/RFRM configuration
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_one_deprov(coreotn_handle_t *coreotn_handle,
                                                    UINT32 chnl_id,
                                                    coreotn_mux_stage_t mux_stage,
                                                    BOOL deprov_tfrm_rfrm_cfg)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    odtu_mux_handle_t* mux_handle_ptr;
    odu_tfrm_handle_t* tfrm_handle_ptr;
    odu_tfrm_inst_t tfrm_type; 
    PMC_ENTRY();


    if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE) 
    {
        tfrm_handle_ptr = coreotn_handle->odu_tfrm_stgN_handle;
        mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
        tfrm_type = ODU_TFRM_STG2;

    } 
    else 
    {
        tfrm_handle_ptr = coreotn_handle->odu_tfrm_stg1_handle;
        mux_handle_ptr = coreotn_handle->odtu_mux1_handle;
        tfrm_type = ODU_TFRM_STG1;
    }


    if(deprov_tfrm_rfrm_cfg)
    {
        /* Put TFRM in passthru */
        ret_val = odu_tfrm_chnl_prov(tfrm_handle_ptr,chnl_id,
                                     ODU_TFRM_MESSAGE_DONT_CARE,
                                     ODU_TFRM_MESSAGE_DONT_CARE,
                                     ODU_TFRM_PM_TCM_START,
                                     FALSE);
        
        if (PMC_SUCCESS == ret_val)
        {
            /* This is for HO channel */
            /* configure the first STG framer */
            /* provision the PM layer */
            ret_val = coreotn_odu_tfrm_chnl_init(coreotn_handle, 
                                                 (odu_tfrm_inst_t)tfrm_type,
                                                 chnl_id, 0);
        }
    }

    if (PMC_SUCCESS == ret_val)
    {
        /* deprovisions HO in the first MUX for the HO channel based configuration */
        ret_val = odtu_mux_ho_chnl_deprov(mux_handle_ptr,
                                          (odtu_mux_stage_instance_t)mux_stage,
                                          chnl_id, 0);
    }

    PMC_RETURN(ret_val);

} /* coreotn_tx_ho_chnl_mux_one_deprov */

/*******************************************************************************
*  coreotn_tx_ho_chnl_mux_two_deprov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_ho_chnl_deprov for the 
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - channel ID to be configured.
*                         Valid range: 0 - 11
*   mux_stage           - processing stage mode for data inside HO ODU channel.
*                         See coreotn_mux_stage_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_ho_chnl_mux_two_deprov(coreotn_handle_t *coreotn_handle,
                                                    UINT32 chnl_id,
                                                    coreotn_mux_stage_t mux_stage)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    if (coreotn_handle->var.init_operation != COREOTN_SS_ONE_STAGE_MUXING_MODE)
    {
        /* accesses the first DMX for the HO channel based configuration */
        ret_val = odtu_mux_ho_chnl_deprov(coreotn_handle->odtu_mux2_handle,
                                          (odtu_mux_stage_instance_t)mux_stage,
                                          chnl_id, 0);
                                          
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle, COREOTN_FMF2_FRM_RCP96,
                                               chnl_id, 0);
        }                                          
    }

    PMC_RETURN(ret_val);

} /* coreotn_tx_ho_chnl_mux_two_deprov */

/*******************************************************************************
*  coreotn_rx_lo_chnl_mux_one_deprov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_lo_chnl_deprov for the 
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   ho_chnl_id          - HO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   deprov_rfrm         - TRUE : deprovision the RFRM
*                         FALSE : do not deprovision the RFRM
*   deprov_rfrm         - TRUE : deprovision the RFRM
*                         FALSE : do not deprovision the RFRM
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_one_deprov(coreotn_handle_t *coreotn_handle,
                                                    coreotn_mux_stage_t mux_stage,
                                                    UINT32 chnl_id,
                                                    UINT32 ho_chnl_id,
                                                    BOOL deprov_rfrm)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    odtu_dmx_handle_t *lo_dmx_handle_ptr;
    odujat_handle_t *lo_odujat_handle_ptr;
    oduksc_handle_t *lo_oduksc_handle_ptr;
    odu_rfrm_handle_t *lo_rfrm_handle_ptr;
    BOOL8 super_prov;
    
    PMC_ENTRY();

    /* check the current MO channel state */
    if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
    {
        ret_val = COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED;

    } 
    else if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].sub_chnls_prov_cnt != 0)
    {
        /* there are lo channels still active in the mo channel */
        ret_val = COREOTN_ERR_CHNL_DEPROV;
    }

    PMC_LOG_TRACE("mux_stage = COREOTN_MUX_STAGE_ONE = %u\n", mux_stage);
    
    super_prov = (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)? FALSE:TRUE;

    if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE) 
    {
        lo_dmx_handle_ptr = coreotn_handle->odtu_dmx2_handle;
        lo_odujat_handle_ptr = coreotn_handle->odujat2_handle;
        lo_oduksc_handle_ptr = coreotn_handle->oduksc2_handle;
        lo_rfrm_handle_ptr = coreotn_handle->odu_rfrm_stg3a_handle;

    } 
    else 
    {
        lo_dmx_handle_ptr = coreotn_handle->odtu_dmx1_handle;
        lo_odujat_handle_ptr = coreotn_handle->odujat1_handle;
        lo_oduksc_handle_ptr = coreotn_handle->oduksc1_handle;
        lo_rfrm_handle_ptr = coreotn_handle->odu_rfrm_stg2_handle;
    }

    if (PMC_SUCCESS == ret_val)
    {

        PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
        ret_val = coreotn_rx_lo_chnl_mux_one_deprov_helper(coreotn_handle,
                                                           mux_stage,
                                                           chnl_id,
                                                           ho_chnl_id,
                                                           lo_dmx_handle_ptr,
                                                           lo_odujat_handle_ptr,
                                                           lo_oduksc_handle_ptr,
                                                           lo_rfrm_handle_ptr,
                                                           deprov_rfrm);
    }

    /* remove HO channel from FMF2 if only one stage muxing */
    if (coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
    { 
        if ((coreotn_handle->var.init_operation != COREOTN_SS_ONE_STAGE_MUXING_MODE) 
             && (coreotn_handle->var.init_operation != COREOTN_SS_SYSOTN_MODE)) 
        {
            if (PMC_SUCCESS == ret_val)
            {
                /* configure unchannlized channel in second stage DMX */
                ret_val = odtu_dmx_ho_chnl_deprov(coreotn_handle->odtu_dmx2_handle, 
                                                  (odtu_dmx_stage_instance_t)2,
                                                  chnl_id, FALSE);
            }
            
            if (super_prov == FALSE)
            {
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = odtu_dmx_ho_chnl_switch_cfg(coreotn_handle->odtu_dmx2_handle,
                                                          chnl_id, FALSE);
                } 
            }
       
            /* ODUJAT_2 */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = odujat_chnl_deprov(coreotn_handle->odujat2_handle, chnl_id, mux_stage, FALSE, super_prov);
            }

            if (super_prov == TRUE && PMC_SUCCESS == ret_val)
            {
                ret_val = odujat_oduksc_chnl_state_set(coreotn_handle->odujat2_handle,
                                                       chnl_id,
                                                       ODUKSC_CHNL_START);
            }

            /* ODUKSC_2 */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = oduksc_chnl_deprov(coreotn_handle->oduksc2_handle, chnl_id);
            }

            if (PMC_SUCCESS == ret_val)
            {
                ret_val = oduksc_chnl_update(coreotn_handle->oduksc2_handle, chnl_id, TRUE);
            }
            
            /* put FRM_RCP CFC FIFO in reset as by default RCP_EN = 1 */
            if (PMC_SUCCESS == ret_val)
            {
                ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle, COREOTN_FO1_FRM_RCP,
                                                   chnl_id, 0);
            }
        }
    }

    /* update channel context */
    if (PMC_SUCCESS == ret_val)
    {
        /* update the channel state */
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnl_state = (super_prov)? COREOTN_CHNL_DEPROV_PENDING:COREOTN_CHNL_START;
        
        if ((coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
             && (coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_IN_PASSTHRU))
        {
            coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state = (super_prov)? COREOTN_CHNL_DEPROV_PENDING:COREOTN_CHNL_START;
        }

        /* update the number of provisioned mo channels */
        coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].chnls_prov_cnt--;
        /* update the number of sub-channels in ho channel */
        coreotn_handle->var.rx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt--;
        /* update the payload format of the MO channel only in normal deprov */
        if (super_prov == FALSE)
        {
            coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD; 
        }
    }

    PMC_RETURN(ret_val);

} /* coreotn_rx_lo_chnl_mux_one_deprov */

/*******************************************************************************
*  coreotn_rx_lo_chnl_mux_one_deprov_helper
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is an additional helper function for coreotn_rx_lo_chnl_mux_one_deprov 
*   function.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   ho_chnl_id          - HO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   deprov_rfrm         - TRUE : deprovision the RFRM
*                         FALSE : do not deprovision the RFRM
*   *lo_dmx_handle_ptr  - A pointer to the dmx handle to deprovision.
*   *lo_odujat_handle_ptr - A pointer to the odujat handle to deprovision.
*   *lo_oduksc_handle_ptr - A pointer to the oduksc handle to deprovision.
*   *lo_rfrm_handle_ptr - A pointer to the rfrm handle to deprovision.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_one_deprov_helper(coreotn_handle_t *coreotn_handle,
                                                           coreotn_mux_stage_t mux_stage,
                                                           UINT32 chnl_id,
                                                           UINT32 ho_chnl_id,
                                                           odtu_dmx_handle_t *lo_dmx_handle_ptr,
                                                           odujat_handle_t *lo_odujat_handle_ptr,
                                                           oduksc_handle_t *lo_oduksc_handle_ptr,
                                                           odu_rfrm_handle_t *lo_rfrm_handle_ptr,
                                                           BOOL deprov_rfrm)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    BOOL8 mo_odu3e2_odu3e1 = FALSE;
    UINT8 extra_cycle = 0x7F;   
   /* UINT32 ultimate_ho_chnl_id;*/
    BOOL8 super_prov = FALSE;

    PMC_ENTRY();
    
  
    if ((coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].odu_container == UTIL_GLOBAL_ODU3E1
         || coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].odu_container == UTIL_GLOBAL_ODU3E2)
        && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format != UTIL_GLOBAL_ODU_UNCHANNELIZED)
    {
        mo_odu3e2_odu3e1 = TRUE;  
        
        if (coreotn_handle->var.extra_entry_ctxt[0].chnl_id == chnl_id)
        {
            extra_cycle = coreotn_handle->var.extra_entry_ctxt[0].cycle;
        }
        else if (coreotn_handle->var.extra_entry_ctxt[1].chnl_id == chnl_id)
        {
            extra_cycle = coreotn_handle->var.extra_entry_ctxt[1].cycle;
        } 
         
    }
    
    /* check the current MO channel state */
    if (PMC_SUCCESS == ret_val)
    {
        /* access the first DMX for the LO channel configuration */
        ret_val = odtu_dmx_lo_chnl_deprov(lo_dmx_handle_ptr,
                                          (odtu_dmx_stage_instance_t)mux_stage, 
                                          chnl_id, ho_chnl_id, 0, 
                                          mo_odu3e2_odu3e1, extra_cycle);
    }


    /* rerun scheduling */ 
    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_switch_cfg(lo_dmx_handle_ptr,
                                                  ho_chnl_id, FALSE);
        }
        
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                          lo_dmx_handle_ptr,
                                                          ho_chnl_id);
        }

        /*
        ** update offline page 
        */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_lo_chnl_offline_deprov(lo_dmx_handle_ptr,
                                                      (odtu_dmx_stage_instance_t)mux_stage, 
                                                      chnl_id, ho_chnl_id,
                                                      mo_odu3e2_odu3e1, extra_cycle);
        }     
    }
    else {
        super_prov = TRUE;
    }
            
    /* deprov ODUJAT1 */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = odujat_chnl_deprov(lo_odujat_handle_ptr, 
                                     chnl_id, 
                                     mux_stage, 
                                     mo_odu3e2_odu3e1, 
                                     super_prov);
    }                                                                     
       
    /* deprov ODUKSC1 */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = oduksc_chnl_deprov(lo_oduksc_handle_ptr, chnl_id);
    }
    
    if (PMC_SUCCESS == ret_val)
    {
        if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
        {
            ret_val = oduksc_chnl_update(lo_oduksc_handle_ptr, chnl_id, TRUE);
        }
    }        
       
    /* This is the lowest ODU RFRM in one stage muxing either STG2 rfrm or 3B in SYSOTN mode. */
    if (PMC_SUCCESS == ret_val &&
        deprov_rfrm)
    {
        /* channel in passthru through stage 2 framer */
        ret_val = odu_rfrm_chnl_prov(lo_rfrm_handle_ptr, chnl_id, FALSE, 0, 0, TRUE);
    }

    /* put FRM_RCP CFC FIFO in reset as by default RCP_EN = 1 */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle, COREOTN_FO1_FRM_RCP,
                                           chnl_id, 0);
    }

    PMC_RETURN(ret_val);

} /* coreotn_rx_lo_chnl_mux_one_deprov_helper */


/*******************************************************************************
*  coreotn_rx_lo_chnl_mux_two_deprov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_rx_lo_chnl_deprov for the 
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   ho_chnl_id          - HO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rx_lo_chnl_mux_two_deprov(coreotn_handle_t *coreotn_handle,
                                                    coreotn_mux_stage_t mux_stage,
                                                    UINT32 chnl_id,
                                                    UINT32 ho_chnl_id)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    BOOL8 super_prov = FALSE;
    
    PMC_ENTRY();

    /* check the current lo channel state */
    if (coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
    {
        PMC_RETURN(COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED);
    }

    /* retrieve super prov mode */
    if (PMC_SUCCESS == ret_val)
    {
        super_prov = (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL)? TRUE:FALSE;
    }

    PMC_LOG_TRACE("mux_stage = COREOTN_MUX_STAGE_TWO\n");

    if (PMC_SUCCESS == ret_val)
    {
        /* if two stage muxing, connect the second stage DMX */
        ret_val = odtu_dmx_lo_chnl_deprov(coreotn_handle->odtu_dmx2_handle,
                                          (odtu_dmx_stage_instance_t)mux_stage, 
                                          chnl_id, ho_chnl_id, 0,
                                          FALSE, 0x7F);
    }

    /* rerun scheduling */
    if (super_prov == FALSE)
    {                                                           
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_ho_chnl_switch_cfg(coreotn_handle->odtu_dmx2_handle,
                                                  ho_chnl_id, FALSE);
        }

        /* perform page swap */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_rx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                          coreotn_handle->odtu_dmx2_handle,
                                                          ho_chnl_id);               
        }

        /*
        ** update offline page
        */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_dmx_lo_chnl_offline_deprov(coreotn_handle->odtu_dmx2_handle,
                                                      (odtu_dmx_stage_instance_t)mux_stage, 
                                                      chnl_id, ho_chnl_id,
                                                      FALSE, 0x7F);
        }
    }
    
    /* ODUJAT_2 */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = odujat_chnl_deprov(coreotn_handle->odujat2_handle, 
                                     chnl_id, 
                                     mux_stage, 
                                     FALSE, 
                                     super_prov);
    }

    /* deprov ODUKSC_2 */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = oduksc_chnl_deprov(coreotn_handle->oduksc2_handle, chnl_id);
    }

    if (PMC_SUCCESS == ret_val)
    {
        if (super_prov == FALSE)
        {
            ret_val = oduksc_chnl_update(coreotn_handle->oduksc2_handle, chnl_id, TRUE);
        }
    }
    
    /* put FRM_RCP FIFO in reset as by default RCP_EN = 1 */
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle, COREOTN_FO1_FRM_RCP,
                                           chnl_id, 0);
    }

    if (PMC_SUCCESS == ret_val)
    {
        ret_val = odu_rfrm_chnl_prov(coreotn_handle->odu_rfrm_stg3a_handle,
                                     chnl_id, FALSE,0, 0, TRUE);
    }

    if (PMC_SUCCESS == ret_val)
    {
        /* update the channel state */
        coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnl_state = (super_prov)? COREOTN_CHNL_DEPROV_PENDING:COREOTN_CHNL_START;
        /* update the number of provisioned lo channels */
        coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].chnls_prov_cnt--;
        /* update the number of sub-channels in ho channel */
        coreotn_handle->var.rx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt--;
    }

    PMC_RETURN(ret_val);

} /* coreotn_rx_lo_chnl_mux_two_deprov */

/*******************************************************************************
*  coreotn_tx_lo_chnl_mux_one_deprov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_lo_chnl_deprov for the 
*   mux_stage == COREOTN_MUX_STAGE_ONE case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   ho_chnl_id          - HO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   deprov_tfrm         - TRUE : deprovision HO TFRM configuration
*                         FALSE : preserve current TFRM configuration
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_one_deprov(coreotn_handle_t *coreotn_handle,
                                                    coreotn_mux_stage_t mux_stage,
                                                    UINT32 chnl_id,
                                                    UINT32 ho_chnl_id,
                                                    BOOL deprov_tfrm)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    odtu_mux_handle_t *lo_mux_handle_ptr;
    odu_tfrm_handle_t *lo_tfrm_handle_ptr = NULL;
    coreotn_frm_rcp_inst_t frm_rcp_inst = LAST_COREOTN_FRM_RCP;
    
    PMC_ENTRY();

    /* check the current MO channel state */
    if (coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
    {
        ret_val = COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED;

    } 
    else if (coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].sub_chnls_prov_cnt != 0) 
    {
        /* there are still active lo channels in the mo channel */
        ret_val = COREOTN_ERR_CHNL_DEPROV;

    } 
    else if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE) 
    {
        lo_mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
        lo_tfrm_handle_ptr = coreotn_handle->odu_tfrm_stg3a_handle;  
        frm_rcp_inst = COREOTN_FMF2_FRM_RCP96;

    } 
    else 
    {
        lo_mux_handle_ptr = coreotn_handle->odtu_mux1_handle;
        lo_tfrm_handle_ptr = coreotn_handle->odu_tfrm_stg2_handle;
        frm_rcp_inst = COREOTN_FMF1_FRM_RCP96;
    }


    if (PMC_SUCCESS == ret_val)
    {
        PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
        ret_val = coreotn_tx_lo_chnl_mux_one_deprov_helper(coreotn_handle,
                                                           mux_stage,
                                                           chnl_id,
                                                           ho_chnl_id,
                                                           lo_mux_handle_ptr);
    }

    /* remove HO channel from FMF2 if only one stage muxing */
    if (coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
    {
        if ((coreotn_handle->var.init_operation != COREOTN_SS_ONE_STAGE_MUXING_MODE) &&
            (coreotn_handle->var.init_operation != COREOTN_SS_SYSOTN_MODE))
        {

            if (PMC_SUCCESS == ret_val)
            {
                /* deprov, clear passthru  */
                ret_val = odtu_mux_chnl_init(coreotn_handle->odtu_mux2_handle, chnl_id, (odtu_mux_chnl_mode_t)1);
            }
            
            if (PMC_SUCCESS == ret_val)
            {
                PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
                ret_val = odtu_mux_ho_chnl_deprov(coreotn_handle->odtu_mux2_handle, (odtu_mux_stage_instance_t)2, chnl_id, 0);
            }
    
            if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
            {
                if (PMC_SUCCESS == ret_val)
                {
                    ret_val = odtu_mux_ho_chnl_switch_cfg(coreotn_handle->odtu_mux2_handle, chnl_id, FALSE);
                }
            }
        }
       
        /* take FRM_RCP FIFO out of reset as by default RCP_EN = 1 */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle,
                                               COREOTN_FMF1_FRM_RCP96,
                                               chnl_id, 0);
        }
    }
    else 
    {
        if (PMC_SUCCESS == ret_val && 
            coreotn_handle->var.init_operation != COREOTN_SS_SYSOTN_MODE &&
            deprov_tfrm)
        {
            /* take TFRM out of passtru */
            /* need to provision PM layer as it's 2x muxing */
            ret_val = coreotn_odu_tfrm_chnl_init(coreotn_handle, 
                                                 (odu_tfrm_inst_t)ODU_TFRM_STG2,
                                                 chnl_id, 0);
        }
    }


    if(deprov_tfrm)
    {
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odu_tfrm_chnl_prov(lo_tfrm_handle_ptr,chnl_id,
                                         ODU_TFRM_MESSAGE_DONT_CARE,
                                         ODU_TFRM_MESSAGE_DONT_CARE,
                                         ODU_TFRM_PM_TCM_START,
                                         FALSE);           
        }
        
        /* take FRM_RCP FIFO out of reset as by default RCP_EN = 1 */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle,
                                               frm_rcp_inst,
                                               chnl_id, 0);
        }
    }

    /* update channel context */
    if (PMC_SUCCESS == ret_val)
    {
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnl_state 
        = (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL)?
        COREOTN_CHNL_DEPROV_PENDING:COREOTN_CHNL_START;
        
        if ((coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED)
            && (coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state == COREOTN_CHNL_IN_PASSTHRU))
        {
            coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state 
            = (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL)?
            COREOTN_CHNL_DEPROV_PENDING:COREOTN_CHNL_START;
        }

        /* update the number of provisioned mo channels */
        coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].chnls_prov_cnt--;
        /* update the number of provisioned sub channels in the HO */
        coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt--;

        /* update the MO channel payload type to default only in normal deprov */
        if (coreotn_handle->var.prov_mode != COREOTN_ODU_CHNL_PROV_ALL)
        {
            coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;

            /* remove extra entry context */
            if (coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].odu_container == UTIL_GLOBAL_ODU3E1
                || coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].odu_container == UTIL_GLOBAL_ODU3E2)
            {
                if (coreotn_handle->var.extra_entry_ctxt[0].chnl_id == chnl_id)
                {
                    coreotn_handle->var.extra_entry_ctxt[0].cycle = 0x7F;
                    coreotn_handle->var.extra_entry_ctxt[0].chnl_id = 0x7F;
                    coreotn_handle->var.extra_entry_ctxt[0].entry_state = FALSE;
                }
                else if (coreotn_handle->var.extra_entry_ctxt[1].chnl_id == chnl_id)
                {
                    coreotn_handle->var.extra_entry_ctxt[1].cycle = 0x7F;
                    coreotn_handle->var.extra_entry_ctxt[1].chnl_id = 0x7F;
                    coreotn_handle->var.extra_entry_ctxt[1].entry_state = FALSE;
                }
            }
        }
    }

    PMC_RETURN(ret_val);

} /* coreotn_tx_lo_chnl_mux_one_deprov */

/*******************************************************************************
*  coreotn_tx_lo_chnl_mux_one_deprov_helper
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is an additional helper function for coreotn_tx_lo_chnl_mux_one_deprov 
*   function.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   ho_chnl_id          - HO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   *lo_mux_handle_ptr  - A pointer to the mux handle to deprovision.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_one_deprov_helper(coreotn_handle_t *coreotn_handle,
                                                           coreotn_mux_stage_t mux_stage,
                                                           UINT32 chnl_id,
                                                           UINT32 ho_chnl_id,
                                                           odtu_mux_handle_t *lo_mux_handle_ptr)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    BOOL8 mo_odu3e2_odu3e1 = FALSE;
    UINT8 extra_cycle = 0x7F; 
    
    PMC_ENTRY();

    /*
     * Moved the check for empty ho revision to the 
     * coreotn_rev_a_somf_sync_patch function
     */
    if (coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 1)
    {
        ret_val = coreotn_rev_a_somf_sync_patch(coreotn_handle,
                                                lo_mux_handle_ptr,
                                                coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].odu_container, 
                                                ho_chnl_id,
                                                TRUE); 
    }

    PMC_LOG_TRACE("mux_stage = COREOTN_MUX_STAGE_ONE = %u\n", mux_stage);
    
    
    if ((coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].odu_container == UTIL_GLOBAL_ODU3E1
         || coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].odu_container == UTIL_GLOBAL_ODU3E2)
        && coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format != UTIL_GLOBAL_ODU_UNCHANNELIZED) 
    {
        mo_odu3e2_odu3e1 = TRUE;  
        
        if (coreotn_handle->var.extra_entry_ctxt[0].chnl_id == chnl_id)
        {
            extra_cycle = coreotn_handle->var.extra_entry_ctxt[0].cycle;
        }
        else if (coreotn_handle->var.extra_entry_ctxt[1].chnl_id == chnl_id)
        {
            extra_cycle = coreotn_handle->var.extra_entry_ctxt[1].cycle;
        } 
         
    }

    PMC_ATOMIC_YIELD(coreotn_handle->base.parent_handle,0);
    if (PMC_SUCCESS == ret_val)
    {
        /* access the first MUX for the LO channel configuration */
        ret_val = odtu_mux_lo_chnl_deprov(lo_mux_handle_ptr,
                                          (odtu_mux_stage_instance_t)mux_stage, 
                                          chnl_id, ho_chnl_id, 0,
                                          mo_odu3e2_odu3e1, extra_cycle);
    }

    if (TRUE == pmc_coreotn_mux_empty_ho_order_revision(&coreotn_handle->base))
    {
        if (PMC_SUCCESS == ret_val)
        {
            if (coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 1)
            {
                /* this is the last LO channel of the offline page in the HO */
                ret_val = odtu_mux_dbg_mask_somf_sync_set(lo_mux_handle_ptr,
                                                          ho_chnl_id, 1);
            }
        }
    }

    /* configure the STS_SW for the HO */
    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {  
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_ho_chnl_switch_cfg(lo_mux_handle_ptr,
                                                  ho_chnl_id, FALSE);
        }
    
        /* perform page swap */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_config_update(lo_mux_handle_ptr,
                                             ho_chnl_id, 0, 0, 1);
        }
        
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_config_update_poll(lo_mux_handle_ptr, 
                                                  ho_chnl_id, 
                                                  COREOTN_POLL_COUNT_MAX);
        }
    
        /* deprov the same LO channel from the swapped page */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_lo_chnl_offline_deprov(lo_mux_handle_ptr,
                                                      (odtu_mux_stage_instance_t)mux_stage, 
                                                      chnl_id, ho_chnl_id,
                                                      mo_odu3e2_odu3e1, extra_cycle);
        }

        /* configure the STS_SW for the HO */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_ho_chnl_switch_cfg(lo_mux_handle_ptr,
                                                  ho_chnl_id, FALSE);
        }
    }  
      
    PMC_RETURN(ret_val);

} /* coreotn_tx_lo_chnl_mux_one_deprov_helper */

/*******************************************************************************
*  coreotn_tx_lo_chnl_mux_two_deprov
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This is a helper function for coreotn_tx_lo_chnl_deprov for the 
*   mux_stage == COREOTN_MUX_STAGE_TWO case.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*   chnl_id             - LO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*   mux_stage           - multiplexing stage.\n
*                         0 -- HO to MO de-multiplexing (HO to LO
*                              demultiplexing for 1-stage multiplexing)\n
*                         1 -- MO to LO de-multiplexing
*   ho_chnl_id          - HO (MO) channel ID to be configured.
*                         Valid range: 0 - 95
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS, or specific error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_tx_lo_chnl_mux_two_deprov(coreotn_handle_t *coreotn_handle,
                                                    coreotn_mux_stage_t mux_stage,
                                                    UINT32 chnl_id,
                                                    UINT32 ho_chnl_id)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    /*
     * Moved the check for the empty ho revision to the 
     * oreotn_rev_a_somf_sync_patch function.
     */
    if (coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state != COREOTN_CHNL_EQUIPPED)
    {
        ret_val = COREOTN_ERR_CHNL_STATE_NOT_EQUIPPED;
    }

    if (coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 1)
    {        
        if (TRUE == pmc_coreotn_mux_empty_ho_order_revision(&coreotn_handle->base))
        {
            ret_val = coreotn_rev_a_somf_sync_patch(coreotn_handle,
                                                    coreotn_handle->odtu_mux2_handle,
                                                    coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].odu_container,
                                                    ho_chnl_id,
                                                    TRUE);      
        } 
    }

    PMC_LOG_TRACE("mux_stage = COREOTN_MUX_STAGE_TWO\n");

    if (PMC_SUCCESS == ret_val)
    {
        /* if two stage muxing, connect the second stage DMX */
        ret_val = odtu_mux_lo_chnl_deprov(coreotn_handle->odtu_mux2_handle,
                                          (odtu_mux_stage_instance_t)mux_stage, 
                                          chnl_id, ho_chnl_id, 0,
                                          FALSE, 0x7F);
    }


    if (TRUE == pmc_coreotn_mux_empty_ho_order_revision(&coreotn_handle->base))
    {    
        if (PMC_SUCCESS == ret_val)
        {
            if (coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt == 1)
            {
                /* write SOMF_SYNC = 1 for the offline page */
                ret_val = odtu_mux_dbg_mask_somf_sync_set(coreotn_handle->odtu_mux2_handle, 
                                                          ho_chnl_id, 1);
            }
        }
    }

    /* configure the STS_SW for the HO */
    if (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_IN_INCREMENT)
    {
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_ho_chnl_switch_cfg(coreotn_handle->odtu_mux2_handle,
                                                  ho_chnl_id, FALSE);
        }

        /* perform page swap */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_config_update(coreotn_handle->odtu_mux2_handle,
                                             ho_chnl_id, 0, 0, 1);
        }
        
        /* poll config_update */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_config_update_poll(coreotn_handle->odtu_mux2_handle, 
                                                  ho_chnl_id, 
                                                  COREOTN_POLL_COUNT_MAX);
        }
        
        /* deprov the same LO channel from the swapped page */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_lo_chnl_offline_deprov(coreotn_handle->odtu_mux2_handle,
                                                      (odtu_mux_stage_instance_t)mux_stage, 
                                                      chnl_id, ho_chnl_id,
                                                      FALSE, 0x7F);
        }
        
        /* configure the STS_SW for the HO */
        if (PMC_SUCCESS == ret_val)
        {
            ret_val = odtu_mux_ho_chnl_switch_cfg(coreotn_handle->odtu_mux2_handle,
                                                  ho_chnl_id, FALSE);
        }  
    }
    
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = coreotn_frm_rcp_fifo_cfg(coreotn_handle,
                                           COREOTN_FMF2_FRM_RCP96,
                                           chnl_id, 0);
    }

    if (PMC_SUCCESS == ret_val)
    {
        ret_val = odu_tfrm_chnl_prov(coreotn_handle->odu_tfrm_stg3a_handle,chnl_id,
                                     ODU_TFRM_MESSAGE_DONT_CARE,ODU_TFRM_MESSAGE_DONT_CARE,ODU_TFRM_PM_TCM_START,
                                     FALSE);           
    }

    /* update the channel context */
    if (PMC_SUCCESS == ret_val)
    {
        /* update the channel state */
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnl_state 
        = (coreotn_handle->var.prov_mode == COREOTN_ODU_CHNL_PROV_ALL)?
        COREOTN_CHNL_DEPROV_PENDING:COREOTN_CHNL_START;
        
        /* update the number of provisioned lo channels */
        coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].chnls_prov_cnt--;
        /* update the number of sub-channels in mo channel */
        coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].sub_chnls_prov_cnt--;
    }

    PMC_RETURN(ret_val);

} /* coreotn_tx_lo_chnl_mux_two_deprov */


/*******************************************************************************
* coreotn_rev_a_somf_sync_patch
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function is used in Rev A devices only.
* 
*   This function is used to avoid a frame slip in HO when the last LO is removed
*   from the HO.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle
*   *lo_mux_handle_ptr  - pointer the a MUX instance
*   ho_odu_container    - HO ODU container type 
*   ho_chnl_id          - HO channel ID 
*   enable              - TRUE : enable SOMF sync
*                         FALSE : disable SOMF sync
*
* OUTPUTS:
*   None
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_rev_a_somf_sync_patch(coreotn_handle_t  *coreotn_handle,
                                                odtu_mux_handle_t *lo_mux_handle_ptr,
                                                util_global_odukp_type_t ho_odu_container,
                                                UINT32 ho_chnl_id,
                                                BOOL8 enable)
{
    PMC_ERROR rc = PMC_SUCCESS;
    PMC_ENTRY();

    if (FALSE == pmc_coreotn_mux_empty_ho_order_revision(&coreotn_handle->base)) 
    {
        /*
         * This is a REV A only function. If it is not that revision then
         * return success.
         */
        PMC_RETURN(PMC_SUCCESS);
    }
    
    /* this is the last LO channel in the HO */
    rc = odtu_mux_dbg_mask_somf_sync_set(lo_mux_handle_ptr,ho_chnl_id, enable);
    
    /* swap the page */
    if (PMC_SUCCESS == rc)
    {
        rc = odtu_mux_config_update(lo_mux_handle_ptr, ho_chnl_id, 0, 0, 1);
    }
    
    if (PMC_SUCCESS == rc)
    {
        rc = odtu_mux_config_update_poll(lo_mux_handle_ptr, 
                                         ho_chnl_id, 
                                         COREOTN_POLL_COUNT_MAX);
    }
    
    /* wait until sync takes effect */
    if (PMC_SUCCESS == rc)
    {
        if (ho_odu_container == UTIL_GLOBAL_ODU4)
        {
            /* wait for 3*1280 frame period */
            PMC_Q_USLEEP(coreotn_handle,COREOTN_ODU4_FRAME_CNT_WAIT_MAX);
            
        } else {
            /* wait for 3*256 frame period */
            PMC_Q_USLEEP(coreotn_handle,COREOTN_OTHER_FRAME_CNT_WAIT_MAX);
        }
    }

    PMC_RETURN(rc);
} /* coreotn_rev_a_somf_sync_patch */

/*******************************************************************************
* coreotn_ddeg_mode_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function is retrieve the current dDEG reporting mode used by FW. 
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle
*   ddeg_mode           - See coreotn_ddeg_mode_t                       
*
* OUTPUTS:
*   *ddeg_enabled       - Ddeg configuration status: enabled (TRUE)
*                         disabled (FALSE)
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ddeg_mode_get(coreotn_handle_t     *coreotn_handle,
                                       coreotn_ddeg_mode_t   ddeg_mode,
                                       BOOL8                *ddeg_enabled)
{

    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    if (LAST_COREOTN_DDEG_MODE > ddeg_mode)
    {
        *ddeg_enabled = coreotn_handle->var.ddeg_mon[(UINT32)ddeg_mode].ddeg_mode == ddeg_mode ? TRUE : FALSE;
    }
    else
    {
        result = COREOTN_ERR_INVALID_ARG; 
    }
    
    PMC_RETURN(result);
} /* coreotn_ddeg_mode_get */

/*******************************************************************************
* coreotn_ddeg_status_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function saves in context DDEG monitor status: activated or deactivated. 
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle
*   ddeg_mode           - See dcoreotn_ddeg_mode_t   
*   activate            - Ddeg monitor is activated otherwise it is deactivated
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ddeg_status_set(coreotn_handle_t     *coreotn_handle,
                                         coreotn_ddeg_mode_t   ddeg_mode,
                                         BOOL8                 activate)
{

    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();
        
    if (LAST_COREOTN_DDEG_MODE > ddeg_mode)
    {
        coreotn_handle->var.ddeg_mon[(UINT32)ddeg_mode].mon_status = activate;
    }
    else
    {
        result = COREOTN_ERR_INVALID_ARG; 
    }
    
    PMC_RETURN(result);
} /* coreotn_ddeg_status_set */

/*******************************************************************************
* coreotn_is_ddeg_hw_mode
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function return TRUE when the dDEG HW mode is enabled
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle
*
* OUTPUTS:
*
* RETURNS:
*   TRUE when HW is enabled
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 coreotn_is_ddeg_hw_mode(coreotn_handle_t  *coreotn_handle) 
{
    BOOL8 fw_g806, fw_enhanced, hw_g806;
    PMC_ENTRY();
    
    (void) coreotn_ddeg_mode_get(coreotn_handle, COREOTN_ENH_BURSTY_DDEG, &fw_g806);
    (void) coreotn_ddeg_mode_get(coreotn_handle, COREOTN_ENHANCED_DDEG, &fw_enhanced);
    hw_g806 = (fw_g806 == FALSE) && (fw_enhanced == FALSE);

    PMC_RETURN(hw_g806);
} /* coreotn_is_ddeg_hw_mode */

/*******************************************************************************
* coreotn_ddeg_mon_segment_set
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function is used to set context for the enhanced dDEG monitoring 
*   segment. 
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle
*   mon_seg             - enum for dDEG monitoring segment. 
*                         See coreotn_ddeg_mon_seg_t.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ddeg_mon_segment_set(coreotn_handle_t *coreotn_handle,
                                              coreotn_ddeg_mon_seg_t mon_seg)
{

    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();

    coreotn_handle->var.ddeg_mon_seg = mon_seg;
    
    PMC_RETURN(result);
} /* coreotn_ddeg_mon_segment_set */

/*******************************************************************************
* coreotn_ddeg_mon_segment_get
* ______________________________________________________________________________
*
* DESCRIPTION: 
*   This function is retreive the segment being monitored for enhanced dDEG. 
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle
*
* OUTPUTS:
*   *mon_seg            - enum for dDEG monitoring segment. 
*                         See coreotn_ddeg_mon_seg_t.
*
* RETURNS:
*   PMC_SUCCESS - on success
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_ddeg_mon_segment_get(coreotn_handle_t *coreotn_handle,
                                              coreotn_ddeg_mon_seg_t *mon_seg)
{

    PMC_ERROR result = PMC_SUCCESS;
    
    PMC_ENTRY();

    *mon_seg = coreotn_handle->var.ddeg_mon_seg;
    
    PMC_RETURN(result);
} /* coreotn_ddeg_mon_segment_get */




/*******************************************************************************
* FUNCTION: coreotn_mpmo_debug_data_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the PKT_AGE from debug registers.  If the channel handle is invalid
*   for this feature an error will be returned.
*   
*
* INPUTS:
*   coreotn_handle  - Pointer to coreotn handle
*   mpmo_type       - MPMO instance type
*   chnl            - MPMO channel
*
* OUTPUTS:
*   debug_latency_ptr  - Pointer to the recovered packet age for the channel.
*                        Units 3.125 nsecond ticks.
*   debug_ramp_state_ptr - Pointer to ramp state for the channel
*   debug_curr_csi_ptr   - Pointer to current CSI for the channel
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_mpmo_debug_data_get(coreotn_handle_t *coreotn_handle,
                                             mpmo_type_id_t mpmo_type,
                                             UINT32 chnl,
                                             UINT32 *debug_latency_ptr,
                                             UINT32 *debug_ramp_state_ptr,
                                             UINT32 *debug_curr_csi_ptr)
{

    UINT32 ramp_state =0, curr_csi = 0, debug_latency = 0;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE,0,0);

   
    switch(mpmo_type)
    {
    case MPMO_COREOTN_CTL:
        result = mpmo_debug_data_get(coreotn_handle->mpmo_core_ctl_handle,
                                     chnl,
                                     &debug_latency,
                                     &ramp_state,
                                     &curr_csi);
        break;
    case MPMO_COREOTN_MUX_FRAMER:
        result = mpmo_debug_data_get(coreotn_handle->mpmo_fo1_handle,
                                     chnl,
                                     &debug_latency,
                                     &ramp_state,
                                     &curr_csi);
        break;
    case MPMO_COREOTN_TO_MAPOTN:
        result = mpmo_debug_data_get(coreotn_handle->mpmo_fo2_handle,
                                     chnl,
                                     &debug_latency,
                                     &ramp_state,
                                     &curr_csi);
        break;
    default:
        /* If not FO1, FO2 or CTL, return an error */
        result = COREOTN_ERR_INVALID_ARG;
        break;
    }

    if(PMC_SUCCESS==result)
    {
        *debug_latency_ptr = debug_latency;
    *debug_ramp_state_ptr = ramp_state;
    *debug_curr_csi_ptr = curr_csi;
    }

    PMC_RETURN(result);
} /* coreotn_mpmo_debug_data_get */

/*******************************************************************************
* FUNCTION: coreotn_mpmo_raw_latency_get()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the PKT_AGE using a raw retieval mechanism.  If the channel handle is 
*   invalid for this feature an error will be returned.\n\n
*
*   The raw retrieval mechanism is destructive to the flow of traffic on the
*   channel.  This API should be used for development purposes only.  It
*   should not be used for operational paths in fielded systems.
*   
*
* INPUTS:
*   coreotn_handle  - Pointer to coreotn handle
*   mpmo_type       - MPMO instance type
*   chnl            - MPMO channel
*
* OUTPUTS:
*   minimum_raw_latency  - Pointer to the recovered packet age for the channel.
*                          Units are equal to 3.125 nseconds each
*   maximum_raw_latency  - Pointer to the recovered packet age for the channel.
*                          Units are equal to 3.125 nseconds each
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_mpmo_raw_latency_get(coreotn_handle_t *coreotn_handle,
                                              mpmo_type_id_t mpmo_type,
                                              UINT32 chnl,
                                              UINT32 *minimum_raw_latency,
                                              UINT32 *maximum_raw_latency)
{

    UINT32 min_latency = 0, max_latency = 0;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(coreotn_handle != NULL, COREOTN_ERR_NULL_HANDLE,0,0);



    switch(mpmo_type)
    {
    case MPMO_COREOTN_CTL:
        result = mpmo_raw_latency_get(coreotn_handle->mpmo_core_ctl_handle,
                                      chnl,
                                      &min_latency,
                                      &max_latency);
        break;
    case MPMO_COREOTN_MUX_FRAMER:
        result = mpmo_raw_latency_get(coreotn_handle->mpmo_fo1_handle,
                                      chnl,
                                      &min_latency,
                                      &max_latency);
        break;
    case MPMO_COREOTN_TO_MAPOTN:
        result = mpmo_raw_latency_get(coreotn_handle->mpmo_fo2_handle,
                                      chnl,
                                      &min_latency,
                                      &max_latency);
        break;
    default:
        /* If not FO1, FO2 or CTL, return an error */
        result = COREOTN_ERR_INVALID_ARG;
        break;
    }

    if(PMC_SUCCESS==result)
    {
        *minimum_raw_latency = min_latency;
        *maximum_raw_latency = max_latency;
    }

    PMC_RETURN(result);
} /* coreotn_mpmo_raw_latency_get */


/*******************************************************************************
* coreotn_mux_dmx_ho_rst_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the ODUk switch handle
*
*
* INPUTS:
*   *coreotn_handle   - pointer to COREOTN handle instance
*   fmf_inst          - enum for FMF instance. See coreotn_fmf_inst_t.
*   chnl_id           - channel ID of the HO
*   enable            - boolean value to determine if the channel will be put
*                       put in reset or taken out of reset.
*                       TRUE: channel will be taken out of reset
*                       FALSE: channel will be put in reset.
*   
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_mux_dmx_ho_rst_cfg(coreotn_handle_t* coreotn_handle,
                                            coreotn_fmf_inst_t fmf_inst,
                                            UINT32 chnl_id,
                                            BOOL8 enable)
{   
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();

    /* take HO channel out of reset in both MUX and DMX */
    if (fmf_inst == COREOTN_FMF_INST_1)
    {
        result = odtu_dmx_ho_chnl_reset_cfg(coreotn_handle->odtu_dmx1_handle,
                                            chnl_id, enable);
                                            
        if (PMC_SUCCESS == result)
        {
            result = odtu_mux_ho_chnl_reset_set(coreotn_handle->odtu_mux1_handle,
                                                chnl_id, enable);
        }
        
        /* put OHFS and EXPAND_IBUF CFC FIFO in reset */
        if (PMC_SUCCESS == result)
        {
            result = odtu_mux_ohfs_insert_cfc_fifo_deactivate(coreotn_handle->odtu_mux1_handle,
                                                              chnl_id);
        }  
        
        if (PMC_SUCCESS == result)
        {
            result = odtu_mux_expand_ibuf_chnl_deactivate(coreotn_handle->odtu_mux1_handle, 
                                                          chnl_id);  
        }                                                                                                                    
    }
    else if (fmf_inst == COREOTN_FMF_INST_2)
    {
        result = odtu_dmx_ho_chnl_reset_cfg(coreotn_handle->odtu_dmx2_handle,
                                            chnl_id, enable);
                                            
        if (PMC_SUCCESS == result)
        {
            result = odtu_mux_ho_chnl_reset_set(coreotn_handle->odtu_mux2_handle,
                                                chnl_id, enable);
        }
        
        /* put OHFS and EXPAND_IBUF CFC FIFO in reset */
        if (PMC_SUCCESS == result)
        {
            result = odtu_mux_ohfs_insert_cfc_fifo_deactivate(coreotn_handle->odtu_mux2_handle,
                                                              chnl_id);
        } 
        
        if (PMC_SUCCESS == result)
        {
            result = odtu_mux_expand_ibuf_chnl_deactivate(coreotn_handle->odtu_mux2_handle, 
                                                          chnl_id);  
        }  
    }
            
    PMC_RETURN(result);
}


/*******************************************************************************
* ccoreotn_odu_ohp_port_framer_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Returns OHP port framer associated to given channel.
*              
* INPUTS:
*  *coreotn_handle       - coreotn handle instance
*   chnl_info            - structure describing the channel: chnl id, odu level
*                          lineotn/sysotn
*                            
* OUTPUTS:
*  NONE.
*
* RETURNS:
*  OHP port framer associated to given channel.
*
* NOTES:
*
*******************************************************************************/
PRIVATE odu_ohp_port_framer_t coreotn_odu_ohp_port_framer_get(coreotn_handle_t        *coreotn_handle,
                                                              coreotn_int_chnl_info_t *chnl_info)
{
    odu_ohp_port_framer_t port_framer = ODU_OHP_PORT_FRAMER_LAST;

    PMC_ENTRY();

    if (COREOTN_INT_SOURCE_LINE == chnl_info->source)
    {
        switch(chnl_info->odu_level) 
        {
        case ODU_STRUCT_LEVEL_HO_ODU: port_framer = ODU_OHP_PORT_FRAMER_1;  break;
        case ODU_STRUCT_LEVEL_MO_ODU: port_framer = ODU_OHP_PORT_FRAMER_2;  break;
        case ODU_STRUCT_LEVEL_LO_ODU: port_framer = ODU_OHP_PORT_FRAMER_3A; break;
        case ODU_STRUCT_LEVEL_3B_ODU: port_framer = ODU_OHP_PORT_FRAMER_3B; break;
        case ODU_STRUCT_LEVEL_4_ODU:  port_framer = ODU_OHP_PORT_FRAMER_4;  break;
        default: 
            break;
        }
    }
    else
    {
        switch(chnl_info->odu_level) 
        {
        case ODU_STRUCT_LEVEL_HO_ODU: port_framer = ODU_OHP_PORT_FRAMER_N;  break;
        case ODU_STRUCT_LEVEL_MO_ODU: port_framer = ODU_OHP_PORT_FRAMER_3A;  break;
        case ODU_STRUCT_LEVEL_LO_ODU: port_framer = ODU_OHP_PORT_FRAMER_1; break;
        case ODU_STRUCT_LEVEL_3B_ODU: port_framer = ODU_OHP_PORT_FRAMER_3B; break;
        case ODU_STRUCT_LEVEL_4_ODU:  port_framer = ODU_OHP_PORT_FRAMER_4;  break;
        case ODU_STRUCT_LEVEL_SYSOTN_TCM_MON_LINE_TO_FABRIC:  port_framer = ODU_OHP_PORT_FRAMER_2;  break;
        default: 
            break;
        }
    }
    
    PMC_RETURN(port_framer);
}/* coreotn_odu_ohp_port_framer_get */


/*******************************************************************************
* coreotn_db_ho_cal_entries_mo_lo_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a HO channel that is operating in
*   database content generation mode to have its scheduling database content
*   retrieved.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - Channel ID
*                         Valid range: 0 - 95
*   db_inst             - O : TX DB
*                         1 : RX DB
*
* OUTPUTS:
*   *cal_entry_ptr      - storage for an array of calendar entries occupied by
*                         the HO channel.
*   *num_cal_entries    - number of calendar entries in the current HO
*   *ho_chnl_id         - List of MO channel ids associated with HO
*   *mo_chnl_id         - List of MO channel ids associated with HO
*   *lo_chnl_id         - List of LO channel ids associated with HO
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_ho_cal_entries_mo_lo_chnl_get(coreotn_handle_t *coreotn_handle,
                                                          UINT32 chnl_id,
                                                          BOOL   db_inst,
                                                          UINT32 *cal_entry_ptr,
                                                          UINT32 *num_cal_entries,
                                                          UINT32 *ho_chnl_id,
                                                          UINT32 *mo_chnl_id,
                                                          UINT32 *lo_chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;
    line_core_otn_db_key       key;
    UINT32 num_of_recs, num_of_result;
    line_core_otn_db_query_res *q_result = NULL;
    UINT32 i ;
    UINT32 db_handle = 0; 
    util_gen_db_id_t db_id;
    UINT8 extra_mo_chnl_id = 0x7F;
    UINT8 calendar_entry = 0x7F;

    PMC_ENTRY();

    db_id = (db_inst == 0)? UTIL_GEN_DB_LINE_CORE_OTN_TX_DB:UTIL_GEN_DB_LINE_CORE_OTN_RX_DB;     
    db_handle = (db_inst == 0)? coreotn_handle->cfg.tx_db_handle:coreotn_handle->cfg.rx_db_handle;
    

    
    key.calendar_entry = DO_NOT_USE_KEY;
    key.ho_channel = chnl_id;
    key.mo_channel = DO_NOT_USE_KEY;
    key.lo_channel = DO_NOT_USE_KEY;
    key.trib_slot = DO_NOT_USE_KEY;

    num_of_recs = gen_db_query(&(coreotn_handle->base),
                               db_id,
                               db_handle,
                               (void *)&key,
                               (void **)&q_result);

    if (num_of_recs == 0)
    {
        PMC_RETURN(COREOTN_ERR_DB_ENTRY_NOT_FOUND);
    }

    for (i = 0; i < num_of_recs; i++)
    {
        cal_entry_ptr[i] = q_result->p_recs[i]->calendar_entry;
        ho_chnl_id[i] = q_result->p_recs[i]->ho_channel;
        mo_chnl_id[i] =  q_result->p_recs[i]->mo_channel;
        lo_chnl_id[i] =  q_result->p_recs[i]->lo_channel;
        PMC_LOG_TRACE("cal_entry[%u] = %u\n", i, cal_entry_ptr[i]);
    }  
    
    
    /* if MO is ODU3, then we need to collect the calendar cycles for the dummy entries
    ** and add to the HO calendar entry set. 
    */
    if (PMC_SUCCESS == result)
    {
        for (i = 0; i < 2; i++)
        {
            result = coreotn_odtu_dmx_dummy_schd_get(coreotn_handle,
                                                     i,
                                                     &extra_mo_chnl_id,
                                                     &calendar_entry);
                                                     
            if (extra_mo_chnl_id != 0x7F && calendar_entry != 0x7F)
            {
                cal_entry_ptr[num_of_recs] = calendar_entry;
                mo_chnl_id[num_of_recs] = extra_mo_chnl_id;
                
                key.calendar_entry = calendar_entry;
                key.ho_channel = DO_NOT_USE_KEY;
                key.mo_channel = DO_NOT_USE_KEY;
                key.lo_channel = DO_NOT_USE_KEY;
                key.trib_slot = DO_NOT_USE_KEY;
                
                num_of_result = gen_db_query(&(coreotn_handle->base),
                                           db_id,
                                           db_handle,
                                           ( void *)&key,
                                           (void **)&q_result);
                
                lo_chnl_id[num_of_recs] = q_result->p_recs[0]->lo_channel;
                
                num_of_recs++;

            }                                                     
        }                                                     
    }

    *num_cal_entries = num_of_recs;
    
    
    PMC_RETURN(result);

} /* coreotn_db_ho_cal_entries_mo_lo_chnl_get */

/*******************************************************************************
* coreotn_db_mo_cal_entries_lo_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for a MO channel that is operating in
*   database content generation mode to have its scheduling database content
*   retrieved.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   chnl_id             - Channel ID
*                         Valid range: 0 - 95
*   db_inst             - O : TX DB
*                         1 : RX DB
*
* OUTPUTS:
*   *cal_entry_ptr      - storage for an array of calendar entries occupied by
*                         the HO channel.
*   *num_cal_entries    - number of calendar entries in the current MO
*   *mo_chnl_id         - List of MO channel ids associated with HO
*   *lo_chnl_id         - List of LO channel ids associated with MO
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_db_mo_cal_entries_lo_chnl_get(coreotn_handle_t *coreotn_handle,
                                                       UINT32 chnl_id,
                                                       BOOL   db_inst,
                                                       UINT32 *cal_entry_ptr,
                                                       UINT32 *num_cal_entries,
                                                       UINT32 *mo_chnl_id,
                                                       UINT32 *lo_chnl_id)
{
    PMC_ERROR result = PMC_SUCCESS;
    line_core_otn_db_key       key;
    UINT32 num_of_recs;
    line_core_otn_db_query_res *q_result = NULL;
    UINT32 i ;
    UINT32 db_handle = 0; 
    util_gen_db_id_t db_id;

    PMC_ENTRY();

    db_id = (db_inst == 0)? UTIL_GEN_DB_LINE_CORE_OTN_TX_DB:UTIL_GEN_DB_LINE_CORE_OTN_RX_DB;     
    db_handle = (db_inst == 0)? coreotn_handle->cfg.tx_db_handle:coreotn_handle->cfg.rx_db_handle;
   
    key.calendar_entry = DO_NOT_USE_KEY;
    key.ho_channel = DO_NOT_USE_KEY;
    key.mo_channel = chnl_id;
    key.lo_channel = DO_NOT_USE_KEY;
    key.trib_slot = DO_NOT_USE_KEY;

    num_of_recs = gen_db_query(&(coreotn_handle->base),
                               db_id,
                               db_handle,
                               (void *)&key,
                               (void **)&q_result);

    if (num_of_recs == 0)
    {
        PMC_RETURN(COREOTN_ERR_DB_ENTRY_NOT_FOUND);
    }

    for (i = 0; i < num_of_recs; i++)
    {
        cal_entry_ptr[i] = q_result->p_recs[i]->calendar_entry;
        mo_chnl_id[i] =  q_result->p_recs[i]->mo_channel;
        lo_chnl_id[i] =  q_result->p_recs[i]->lo_channel;
    }  
        
    *num_cal_entries = num_of_recs;
    
    PMC_RETURN(result);

} /* coreotn_db_mo_cal_entries_lo_chnl_get */

/*******************************************************************************
* coreotn_payload_format_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Accesses the payload format of a previously provisioned channel.
*              
* INPUTS:
*  *coreotn_handle       - coreotn handle instance
*  chnl_level             - see util_global_odu_level_t
*  direction             - 0 : TX
*                          1 : RX
*  chnl_id               - Channel id
*                            
* OUTPUTS:
*  *payload_format       - Payload format of the channel at that ODU level
*
* RETURNS:
*   None.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_payload_format_get(coreotn_handle_t        *coreotn_handle,
                                       util_global_odu_level_t chnl_level,
                                       BOOL direction,
                                       UINT32 chnl_id,
                                       util_global_odu_line_payload_t *payload_format)
{
    PMC_ENTRY();

  
    if(direction == 0)
    {
        switch(chnl_level)
        {
        case UTIL_GLOBAL_LEVEL_HO_ODU:
            *payload_format = (util_global_odu_line_payload_t)coreotn_handle->var.tx_ho_chnl_ctxt[chnl_id].payload_format;
            break;
        case UTIL_GLOBAL_LEVEL_MO_ODU:
            *payload_format = (util_global_odu_line_payload_t)coreotn_handle->var.tx_mo_chnl_ctxt[chnl_id].payload_format;
            break;
        case UTIL_GLOBAL_LEVEL_LO_ODU:
            *payload_format = (util_global_odu_line_payload_t)coreotn_handle->var.tx_lo_chnl_ctxt[chnl_id].payload_format;
            break;
        default: 
            break;
        }
    }
    else
    {
        switch(chnl_level)
        {
        case UTIL_GLOBAL_LEVEL_HO_ODU:
            *payload_format = (util_global_odu_line_payload_t)coreotn_handle->var.rx_ho_chnl_ctxt[chnl_id].payload_format;
            break;
        case UTIL_GLOBAL_LEVEL_MO_ODU:
            *payload_format = (util_global_odu_line_payload_t)coreotn_handle->var.rx_mo_chnl_ctxt[chnl_id].payload_format;
            break;
        case UTIL_GLOBAL_LEVEL_LO_ODU:
            *payload_format = (util_global_odu_line_payload_t)coreotn_handle->var.rx_lo_chnl_ctxt[chnl_id].payload_format;
            break;
        default: 
            break;
        }

    }
   
    PMC_RETURN();
}/* coreotn_payload_format_get */

/*******************************************************************************
* coreotn_odu4_calendar_pinch_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Applies or disables calendar pinch at ODUKSW ODU4s.
*              
* INPUTS:
*  *coreotn_handle       - coreotn handle instance
*  output_port           - See coreotn_oduksw_output_port_type_t
*                          (only valid to provide, COREOTN_ODUKSW_OUTPUT_COREOTN
*                           or COREOTN_ODUKSW_OUTPUT_SIFD1 in SYSOTN mode)
*  cal_pinch_enable      - TRUE : Enable calendar pinching on DCI and DPI
*                                 interface at port 2 of the ODUKSW.  This
*                                 should be enabled only for ILKN -> COREOTN
*                                 for 128B fabric applications.
*                          FALSE : disable calendar pinching
*                            
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_odu4_calendar_pinch_set(coreotn_handle_t *coreotn_handle,
                                                 coreotn_oduksw_output_port_type_t output_port,
                                                 BOOL cal_pinch_enable)
{
    PMC_ERROR result;

    mpmo_handle_t* mpmo_handle;

    PMC_ENTRY();

    if( (output_port != COREOTN_ODUKSW_OUTPUT_SIFD1 && 
         (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE ||
         coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)) &&
         (output_port != COREOTN_ODUKSW_OUTPUT_COREOTN))
    {
       PMC_RETURN(COREOTN_ERR_INVALID_ARG); 
    }
    
    switch (output_port)
    {
      case COREOTN_ODUKSW_OUTPUT_SIFD1: /* to SIFD1 */
          mpmo_handle = coreotn_handle->mpmo_core_ctl_handle;
          break;
      case COREOTN_ODUKSW_OUTPUT_COREOTN: /* to COREOTN */
          mpmo_handle = coreotn_handle->mpmo_fo1_handle;
          break;
      default:
          PMC_RETURN(COREOTN_ERR_INVALID_ARG); 
    }


    if(cal_pinch_enable)
    {
        result = mpmo_calendar_pinch_mode_set(mpmo_handle,
                                              UTIL_GLOBAL_CAL_PINCH_ODU4_ODUKSW_TX_DCI);

        if(result == PMC_SUCCESS)
        {
            result = cpb_dsc_calendar_pinch_mode_set(coreotn_handle->oduksw_handle,
                                                     output_port,
                                                     UTIL_GLOBAL_CAL_PINCH_ODU4_ODUKSW_TX_DPI);
        }
    }
    else
    {
        result = mpmo_calendar_pinch_mode_set(mpmo_handle,
                                              UTIL_GLOBAL_CAL_PINCH_NONE);

        if(result == PMC_SUCCESS)
        {
            result = cpb_dsc_calendar_pinch_mode_set(coreotn_handle->oduksw_handle,
                                                     output_port,
                                                     UTIL_GLOBAL_CAL_PINCH_NONE);
        }
    }
    
    PMC_RETURN(result);
}/* coreotn_odu4_calendar_pinch_set */

/*******************************************************************************
*  coreotn_oduksw_reprov_pkt_size_configs
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This API is used to perform a reprovisioning of configurations relating
*  to an OPSA packet size change.  This superceeds performing
*  and ODUKSW deprov and reprov for applications where only packet size
*  configurations need to change.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*                         Valid range: 0 - 95
*   output_port         - destination of the data.
*                         See coreotn_oduk_sw_output_port_t.\
*   odu_level           - ODU level
*   output_chnl_id      - output channel ID from ODUk Switch
*   pkt_size            - desired packet size to be made by packet maker (= B)
*   pkt_per_int         - integer portion of desired packet period.
*   pkt_per_n           - numerator of desired packet period.
*   pkt_per_d           - denominator of desired packet period.
*   hys_buffer_en       - custom hysteresis buffer size mode:\n
*                         TRUE : custom hysteresis buffer size mode is enable 
*                         FALSE : custom hysteresis buffer size mode is disabled
*   hys_buffer          - hysteresis buffer size in refclk cycles
*   latency_s           - latency to control data flow from ODUKSW to paket
*                         monitor towards COREOTN.  In units of 3.125 usecond
*                         ticks.
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_oduksw_reprov_pkt_size_configs(coreotn_handle_t *coreotn_handle,
                                                        coreotn_oduksw_output_port_type_t output_port,
                                                        util_global_odu_level_t odu_level,
                                                        UINT32 output_chnl_id,
                                                        UINT32 pkt_size,
                                                        UINT32 pkt_per_int,
                                                        UINT32 pkt_per_n,
                                                        UINT32 pkt_per_d,
                                                        BOOL   hys_buffer_en,
                                                        UINT32 hys_buffer,
                                                        UINT32 latency_s)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 blocks_wo_halt_buffer = 0;
    UINT32 egress_mux_input_port;
    UINT32 rd_channel_id;
    UINT32 rd_queue_id;
    UINT32 wr_queue_id;
    UINT32 ingress_mux_input_port;
    UINT32 ingress_mux_input_port_chnl;
    DOUBLE loc_client_rate;
    UINT32 fifo_depth;
    util_global_odukp_type_t odu_countainer = UTIL_GLOBAL_LAST_ODUK;
    BOOL odu_flex_client = FALSE;
    UINT32 odu_flex_rate = 0;
  

    PMC_ENTRY();  
    
    PMC_LOG_TRACE("output_port = %u\n", output_port);

    /* Check arguments */
    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != coreotn_handle->oduksw_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);


    switch(odu_level)
    {
        case UTIL_GLOBAL_LEVEL_HO_ODU:
            odu_countainer = coreotn_handle->var.tx_ho_chnl_ctxt[output_chnl_id].odu_container;
            break;
        case UTIL_GLOBAL_LEVEL_MO_ODU:
            odu_countainer = coreotn_handle->var.tx_mo_chnl_ctxt[output_chnl_id].odu_container;
            odu_flex_rate = coreotn_handle->var.tx_mo_chnl_ctxt[output_chnl_id].odu_flex_rate;
            break;
        case UTIL_GLOBAL_LEVEL_LO_ODU:
            odu_countainer = coreotn_handle->var.tx_lo_chnl_ctxt[output_chnl_id].odu_container;
            odu_flex_rate = coreotn_handle->var.tx_lo_chnl_ctxt[output_chnl_id].odu_flex_rate;
            break;
        default: 
            break;
    }

    
    if(odu_countainer == UTIL_GLOBAL_ODUFLEX_GFP)
    {
        odu_flex_client = TRUE;
    }
    else
    {
        odu_flex_client = FALSE;
    }


    if (ret_val == PMC_SUCCESS)
    {
        ret_val = cpb_dcs_egress_dpi_chnl_source_get(coreotn_handle->oduksw_handle,
                                                     output_port,
                                                     output_chnl_id,
                                                     &egress_mux_input_port,
                                                     &rd_channel_id,
                                                     &rd_queue_id);
    }
    if (ret_val == PMC_SUCCESS)
    {
        ret_val = cpb_ingress_mux_input_port_data_get(coreotn_handle->oduksw_handle,
                                                      egress_mux_input_port,
                                                      rd_queue_id,
                                                      &wr_queue_id,
                                                      &ingress_mux_input_port,
                                                      &ingress_mux_input_port_chnl);
    }



    if(PMC_SUCCESS == ret_val)
    {

        ret_val = cpb_determine_num_blocks(coreotn_handle->oduksw_handle,
                                           egress_mux_input_port,
                                           ingress_mux_input_port,
                                           rd_channel_id,
                                           0, /*rate parameter not used for OCPB*/
                                           0,
                                           0,
                                           TRUE,
                                           &blocks_wo_halt_buffer);
    }

    if (PMC_SUCCESS == ret_val)
    {                          
        /* convert number of blocks in number of bytes */
        fifo_depth = blocks_wo_halt_buffer * 16;
                         
        /* MPMO configuration */                                 
        switch (output_port)
        {
        case COREOTN_ODUKSW_OUTPUT_SIFD1: /* to SIFD1 */
      
            if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE ||
                coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
            {
                if (PMC_SUCCESS == ret_val)
                {   
                    ret_val = mpmo_reprov_pkt_size_configs(coreotn_handle->mpmo_core_ctl_handle,
                                                           output_chnl_id,
                                                           pkt_size,
                                                           pkt_per_int,
                                                           pkt_per_n,
                                                           pkt_per_d);
                }

                loc_client_rate = mpmo_client_bitrate_get(coreotn_handle->mpmo_core_ctl_handle,
                                                          output_chnl_id);
                
                if (PMC_SUCCESS == ret_val) 
                {
                    ret_val = mpmo_ch_latency_cfg(coreotn_handle->mpmo_core_ctl_handle, 
                                                  output_chnl_id, loc_client_rate, pkt_size, 
                                                  fifo_depth, hys_buffer_en, hys_buffer, latency_s, 
                                                  S_OLD_RATIO,
                                                  odu_flex_client,
                                                  odu_flex_rate);
                }

            }          
            break;
        case COREOTN_ODUKSW_OUTPUT_COREOTN: /* to COREOTN */

            if (PMC_SUCCESS == ret_val)
            {   
                    ret_val = mpmo_reprov_pkt_size_configs(coreotn_handle->mpmo_fo1_handle,
                                                           output_chnl_id,
                                                           pkt_size,
                                                           pkt_per_int,
                                                           pkt_per_n,
                                                           pkt_per_d);
            }      

            loc_client_rate = mpmo_client_bitrate_get(coreotn_handle->mpmo_fo1_handle,
                                                      output_chnl_id);
                
            if (PMC_SUCCESS == ret_val) 
            {
                ret_val = mpmo_ch_latency_cfg(coreotn_handle->mpmo_fo1_handle, 
                                              output_chnl_id, loc_client_rate, pkt_size, 
                                              fifo_depth, hys_buffer_en, hys_buffer, latency_s, 
                                              S_OLD_RATIO,
                                              odu_flex_client,
                                              odu_flex_rate);
            }


            break;            
        case COREOTN_ODUKSW_OUTPUT_MAPOTN: /* to MAPOTN */ 
            /* MPMO in FO2 */

            if (PMC_SUCCESS == ret_val)
            {   
                    ret_val = mpmo_reprov_pkt_size_configs(coreotn_handle->mpmo_fo2_handle,
                                                           output_chnl_id,
                                                           pkt_size,
                                                           pkt_per_int,
                                                           pkt_per_n,
                                                           pkt_per_d);
            }   

            loc_client_rate = mpmo_client_bitrate_get(coreotn_handle->mpmo_fo2_handle,
                                                      output_chnl_id);
                
            if (PMC_SUCCESS == ret_val) 
            {
                ret_val = mpmo_ch_latency_cfg(coreotn_handle->mpmo_fo2_handle, 
                                              output_chnl_id, loc_client_rate, pkt_size, 
                                              fifo_depth, hys_buffer_en, hys_buffer, latency_s, 
                                              S_OLD_RATIO,
                                              odu_flex_client,
                                              odu_flex_rate);
            }


            break; 
        default:
            PMC_RETURN(COREOTN_ERR_INVALID_ARG);
        }
    }


    PMC_RETURN(ret_val);
} /* coreotn_oduksw_reprov_pkt_size_configs */


/*******************************************************************************
* coreotn_dcs_to_mapotn_pinch_entry_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Accesses the payload format of a previously provisioned channel.
*              
* INPUTS:
*  *coreotn_handle       - coreotn handle instance
*  calendar_entry        - The calendar entry to pinch/unpinch
*  pinch_enable          - TRUE : pinch the calendat entry
*                          FALSE : don't pinch the calendar entry
*                            
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_dcs_to_mapotn_pinch_entry_set(coreotn_handle_t        *coreotn_handle,
                                                       UINT32 calendar_entry,
                                                       BOOL8 pinch_enable)
{

    PMC_ENTRY();

    coreotn_handle->var.dcs_to_mapotn_pinch_entry[calendar_entry] = pinch_enable;
    
    PMC_RETURN(PMC_SUCCESS);
}/* coreotn_dcs_to_mapotn_pinch_entry_set */


/*******************************************************************************
* coreotn_dcs_to_mapotn_pinch_entry_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Accesses the payload format of a previously provisioned channel.
*              
* INPUTS:
*  *coreotn_handle       - coreotn handle instance
*  calendar_entry        - The calendar entry to extract pinch context for
*                            
* OUTPUTS:
*  pinch_enable          - TRUE : calendar entry is pinched
*                          FALSE : calendar entry is not pinched
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
* 
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_dcs_to_mapotn_pinch_entry_get(coreotn_handle_t        *coreotn_handle,
                                                       UINT32 calendar_entry,
                                                       BOOL8 *pinch_enable)
{

    PMC_ENTRY();

    *pinch_enable = coreotn_handle->var.dcs_to_mapotn_pinch_entry[calendar_entry];
    
    PMC_RETURN(PMC_SUCCESS);
}/* coreotn_dcs_to_mapotn_pinch_entry_get */


/*******************************************************************************
* coreotn_lo_chnl_get_tx
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method to retrieve the list of MO or LO 
*   channels asscoaited to their respective HO or MO channel.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance
*   line_side           - TRUE means line side, FALSE means system side
*   ho_odu_level        - ODU level of the container
*   ho_chnl_id          - HO or MO Channel ID
*
* OUTPUTS:
*   *ch_ptr             - storage for an array of channel provisionned under 
*                         specied HO channel (shall be at least sizeof(UINT3232)*80
*                         the HO channel.
*   *num_ch             - number of channel in the current HO 
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void coreotn_lo_chnl_get_tx(coreotn_handle_t *coreotn_handle,
                                         BOOL8  line_side,
                                         coreotn_chnl_order_t ho_odu_level,
                                         UINT32 ho_chnl_id,
                                         UINT32 *ch_ptr,
                                         UINT32 *num_ch)
{
    BOOL8 is_sysotn_mode =  (coreotn_handle->var.init_operation  == COREOTN_SS_SYSOTN_MODE || 
                             coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE) ?TRUE:FALSE;
    util_global_odu_line_payload_t ho_payload_format  = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;
    odtu_mux_handle_t *odtu_mux_handle = NULL;
    PMC_ENTRY();
    
    *num_ch = 0;            
    
    if (is_sysotn_mode == TRUE)
    {
        if (TRUE == line_side)
        {
            PMC_ASSERT(ho_chnl_id<COREOTN_MAX_NUM_HO_CHNL,COREOTN_ERR_INVALID_ARG,0,0);
            PMC_ASSERT(ho_odu_level == COREOTN_CHNL_ORDER_HO,COREOTN_ERR_INVALID_ARG,0,0);            
            *num_ch = 0;            
        } else 
        {
            PMC_ASSERT((ho_odu_level == COREOTN_CHNL_ORDER_HO && ho_chnl_id == 0) ||
                       (ho_odu_level == COREOTN_CHNL_ORDER_MO && ho_chnl_id<COREOTN_MAX_NUM_MO_CHNL),
                       COREOTN_ERR_INVALID_ARG,0,0);
            if (ho_odu_level == COREOTN_CHNL_ORDER_MO)
            {
                *num_ch = 0;            
            } else if (coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
            {
                ho_payload_format = coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].payload_format;
                odtu_mux_handle   = coreotn_handle->odtu_mux2_handle;
            }
        }        
    } else 
    {
        PMC_ASSERT((ho_odu_level == COREOTN_CHNL_ORDER_HO && ho_chnl_id<COREOTN_MAX_NUM_HO_CHNL) ||
                   (ho_odu_level == COREOTN_CHNL_ORDER_MO && ho_chnl_id<COREOTN_MAX_NUM_MO_CHNL) ||
                   (ho_odu_level == COREOTN_CHNL_ORDER_LO && ho_chnl_id<COREOTN_MAX_NUM_LO_CHNL),
                   COREOTN_ERR_INVALID_ARG,0,0);
        if (ho_odu_level == COREOTN_CHNL_ORDER_LO)
        {
            *num_ch = 0;            
        } else if (ho_odu_level == COREOTN_CHNL_ORDER_HO && 
                   coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
        {
            ho_payload_format = coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].payload_format;
            odtu_mux_handle   = coreotn_handle->odtu_mux1_handle;
        } else if (ho_odu_level == COREOTN_CHNL_ORDER_MO  &&
                   coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].chnl_state == COREOTN_CHNL_OPERATIONAL)
        {
            ho_payload_format = coreotn_handle->var.tx_mo_chnl_ctxt[ho_chnl_id].payload_format;
            odtu_mux_handle   = coreotn_handle->odtu_mux2_handle;
        }        
    }
    if (ho_payload_format == UTIL_GLOBAL_ODU_TS_1G25 || ho_payload_format == UTIL_GLOBAL_ODU_TS_2G5)
    {
        /* get LOW channel from odtu_mux context */
        odtu_mux_lo_chnl_get(odtu_mux_handle,
                                      ho_chnl_id,
                                      ch_ptr,
                                      num_ch);

    }

    PMC_RETURN();

} /* coreotn_lo_chnl_get_tx */


/*******************************************************************************
*  coreotn_hys_latency_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This API gets the default hysteresis buffer size in refclk cycles. 
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*                         Valid range: 0 - 95
*   output_port         - destination of the data.
*                         See coreotn_oduk_sw_output_port_t.\n
*   output_chnl_id      - output channel ID from ODUk Switch
*   client_rate         - Client bit rate.
*
* OUTPUTS:
*   hys_latency         - latency in reference clock cycles
* 
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_hys_latency_get(coreotn_handle_t *coreotn_handle,
                                         coreotn_oduksw_output_port_type_t output_port,
                                         UINT32 output_chnl_id,
                                         DOUBLE client_rate,
                                         UINT32 *hys_latency)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 blocks_wo_halt_buffer = 0;
    UINT32 egress_mux_input_port;
    UINT32 rd_channel_id;
    UINT32 rd_queue_id;
    UINT32 wr_queue_id;
    UINT32 ingress_mux_input_port;
    UINT32 ingress_mux_input_port_chnl;
    UINT32 fifo_depth = 0;
    UINT32 pkt_size = 0;
    UINT32 pkt_per_int = 0;
    UINT32 pkt_per_n = 0;
    UINT32 pkt_per_d = 0;
    DOUBLE local_rate = 0;

    PMC_ENTRY();  
    
    PMC_LOG_TRACE("output_port = %u, output_chnl_id= %u \n", output_port, output_chnl_id);

    /* Check arguments */
    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != coreotn_handle->oduksw_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);

    if (ret_val == PMC_SUCCESS)
    {
        ret_val = cpb_dcs_egress_dpi_chnl_source_get(coreotn_handle->oduksw_handle,
                                                     output_port,
                                                     output_chnl_id,
                                                     &egress_mux_input_port,
                                                     &rd_channel_id,
                                                     &rd_queue_id);
    }
    if (ret_val == PMC_SUCCESS)
    {
        ret_val = cpb_ingress_mux_input_port_data_get(coreotn_handle->oduksw_handle,
                                                      egress_mux_input_port,
                                                      rd_queue_id,
                                                      &wr_queue_id,
                                                      &ingress_mux_input_port,
                                                      &ingress_mux_input_port_chnl);
    }



    if(PMC_SUCCESS == ret_val)
    {

        ret_val = cpb_determine_num_blocks(coreotn_handle->oduksw_handle,
                                           egress_mux_input_port,
                                           ingress_mux_input_port,
                                           rd_channel_id,
                                           0, /*rate parameter not used for OCPB*/
                                           0,
                                           0,
                                           TRUE,
                                           &blocks_wo_halt_buffer);
    }

    if (PMC_SUCCESS == ret_val)
    {                          
        /* convert number of blocks in number of bytes */
        fifo_depth = blocks_wo_halt_buffer * 16;                                                 
        switch (output_port)
        {
        case COREOTN_ODUKSW_OUTPUT_SIFD1: /* to SIFD1 */
      
            if (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE ||
                coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE)
            {
                if (PMC_SUCCESS == ret_val)
                {                                         
                    ret_val = mpmo_pkt_period_var_get(coreotn_handle->mpmo_core_ctl_handle,
                                                     output_chnl_id, 
                                                     &pkt_size,
                                                     &pkt_per_int,
                                                     &pkt_per_n, 
                                                     &pkt_per_d);
                }
                local_rate = mpmo_client_bitrate_get(coreotn_handle->mpmo_core_ctl_handle,
                                                     output_chnl_id); 

            }          
            break;
        case COREOTN_ODUKSW_OUTPUT_COREOTN: /* to COREOTN */

            if (PMC_SUCCESS == ret_val)
            {   
                   ret_val = mpmo_pkt_period_var_get(coreotn_handle->mpmo_fo1_handle,
                                                     output_chnl_id, 
                                                     &pkt_size,
                                                     &pkt_per_int,
                                                     &pkt_per_n, 
                                                     &pkt_per_d);
            }      
            local_rate = mpmo_client_bitrate_get(coreotn_handle->mpmo_fo1_handle,
                                                 output_chnl_id);

            break;            
        case COREOTN_ODUKSW_OUTPUT_MAPOTN: /* to MAPOTN */ 
            /* MPMO in FO2 */

            if (PMC_SUCCESS == ret_val)
            {   
                  ret_val = mpmo_pkt_period_var_get(coreotn_handle->mpmo_fo2_handle,
                                                    output_chnl_id, 
                                                    &pkt_size,
                                                    &pkt_per_int,
                                                    &pkt_per_n, 
                                                    &pkt_per_d);
            }   
            local_rate = mpmo_client_bitrate_get(coreotn_handle->mpmo_fo2_handle,
                                                 output_chnl_id);

            break; 
        default:
            PMC_RETURN(COREOTN_ERR_INVALID_ARG);
        }
    }

    if (PMC_SUCCESS == ret_val) 
    {

        if (local_rate > 0)
        {
            client_rate = local_rate;
        }

        ret_val = util_opsa_mpmo_latency_calc(client_rate, pkt_size, 
                                              fifo_depth, hys_latency); 
    }


    PMC_RETURN(ret_val);
    
} /* coreotn_hys_latency_get */

/*******************************************************************************
*  coreotn_hys_latency_range_chk
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This API checks if the programmable hysteresis buffer latency is with in the 
*  desired range. The programmable hysteresis buffer MUST be less than the default 
*  hysteresis buffer and greater than the latency of one packet.
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*                         Valid range: 0 - 95
*   output_port         - destination of the data.
*                         See coreotn_oduk_sw_output_port_t.\n
*   output_chnl_id      - output channel ID from ODUk Switch
*   client_bitrate      - client bit rate in bps if lo_odu_type is ODUFLEX_CBR.
*                         For other LO ODU types, set to 0.
*   pkt_size            - desired packet size to be made by packet maker (= B)
*   hys_buffer          - hysteresis buffer size in refclk cycles
*
* OUTPUTS:
*   
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_hys_latency_range_chk(coreotn_handle_t *coreotn_handle,
                                               coreotn_oduksw_output_port_type_t output_port,
                                               UINT32 output_chnl_id,
                                               DOUBLE client_bitrate,
                                               UINT32 pkt_size,
                                               UINT32 hys_buffer)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 hys_latency;
    DOUBLE words_per_pkt;
    UINT32 one_pkt_latency;
   
    PMC_ENTRY();

    /*check that the specified latency is less than the default hysteresis buffer latency. */

    ret_val = coreotn_hys_latency_get(coreotn_handle,output_port,
                                      output_chnl_id,
                                      client_bitrate, &hys_latency);

    if(PMC_SUCCESS == ret_val)
    {
        
        words_per_pkt = PMC_CEIL ( (DOUBLE)((pkt_size + UTIL_OPSA_HEADER_SIZE) / (DOUBLE)UTIL_OPSA_DPI_WORD_SIZE/1.0) );
        ret_val = util_opsa_mpmo_latency_calc(client_bitrate, pkt_size,
                                              (UINT32) words_per_pkt,
                                               &one_pkt_latency);
                                               
        PMC_LOG_TRACE("one_pkt_latency = %u\n", one_pkt_latency);                                       
        
        /*check that the specified latency is greater than the latency of one packet*/ 
        if(PMC_SUCCESS == ret_val)
        {
            if(hys_buffer <= one_pkt_latency) 
            {
                ret_val = COREOTN_ERR_INTERNAL_LATENCY_LESS_ONE_PKT_LATENCY;
            }
        }
    }
    
    PMC_RETURN(ret_val);
    
} /* coreotn_hys_latency_range_chk */

/*******************************************************************************
*  coreotn_mpmo_csi_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API enables or disables masking of the lower two bits of the ingress 5 
*   bit CSI value. When mask in enabled, only the upper 3 bits will be considered 
*   in signalling an interrupt for a change in CSI value via the CSI_CHG_I 
*   interrupt. When mask is disabled, all 5 bits will be considered in signalling
*   an interrupt for a change is CSI value via the CSI_CHG_I interrupt.
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*                         Valid range: 0 - 95
*   mpmo_inst           - the MPMO instance to configure see coreotn_mpmo_inst_t    
*   csi_squelch_en      - enables/disables masking of the lower two bits of the 
*                         ingress 5 bit CSI value: \n
*                         TRUE:  CSI bits 5:2 are used for comparison \n
*                         FALSE: CSI bits 5:0 are used for comparison \n
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_mpmo_csi_cfg(coreotn_handle_t *coreotn_handle,
                                      coreotn_mpmo_inst_t mpmo_inst,
                                      BOOL csi_squelch_en)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    mpmo_handle_t *mpmo_handle;
    
    PMC_ENTRY();
     
    switch (mpmo_inst)
    {
        case COREOTN_MPMO_TO_COREOTN:
            mpmo_handle = coreotn_handle->mpmo_fo1_handle;
            break;           
        case COREOTN_MPMO_TO_MAPOTN:
            mpmo_handle = coreotn_handle->mpmo_fo2_handle;
            break;
        case COREOTN_MPMO_CORECTL:
            mpmo_handle = coreotn_handle->mpmo_core_ctl_handle;
            break;
        default:
            ret_val = COREOTN_ERR_INVALID_ARG;
            break;
    }
    
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = mpmo_csi_normal_cfg(mpmo_handle, MPMO_CSI_NORMAL_DEFAULT, csi_squelch_en);   
    }
    
    PMC_RETURN(ret_val);
    
} /* coreotn_mpmo_csi_cfg */

/*******************************************************************************
*  coreotn_mpma_csi_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This API configures the configurable client status indication in the CSI 
*   field of each outgoing packet header.  Three DCI signal failures 
*   (SSF, SD, SF), and two manual force registers (FORCE_TO and FORCE_AWAY) are
*   associated with configurable CSI values. In the event that there are multiple 
*   signal failures/forces, only the highest priority will be signalled via the 
*   CSI field according to the following priority:\n
*   1. Force Away (User Force, default 5'b11100)\n
*   2. SSF (DCI Signal failure, default 5'b10000)\n
*   3. SF (DCI Signal failure, default 5'b01100)\n
*   4. SD (DCI Signal failure, default 5'b01000)\n
*   5. Normal (DCI Signal failure, default 5'b00100)\n
*   6. Force to (User Force, default 5'b00000)\n
*
*
* INPUTS:
*   *coreotn_handle     - pointer to COREOTN handle instance to be operated on
*                         Valid range: 0 - 95
*   mpma_inst           - the MPMO instance to configure see coreotn_mpma_inst_t    
*   cfg_csi_type        - the cofigurable CSI values see mpma_csi_type_t
*   csi_val             - CSI value to use
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_mpma_csi_cfg(coreotn_handle_t *coreotn_handle,
                                      coreotn_mpma_inst_t mpma_inst,
                                      mpma_csi_type_t cfg_csi_type,
                                      UINT32 csi_val)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    mpma_handle_t *mpma_handle;
    
    PMC_ENTRY();
     
    switch (mpma_inst)
    {
        case COREOTN_MPMA_TO_COREOTN:
            mpma_handle = coreotn_handle->mpma_fo1_handle;
            break;           
        case COREOTN_MPMA_FROM_MAPOTN:
            mpma_handle = coreotn_handle->mpma_fo2_handle;
            break;
        case COREOTN_MPMA_CORECTL:
            mpma_handle = coreotn_handle->mpma_core_ctl_handle;
            break;
        default:
            ret_val = COREOTN_ERR_INVALID_ARG;
            break;
    }
    
    if (PMC_SUCCESS == ret_val)
    {
        ret_val = mpma_csi_cfg(mpma_handle, cfg_csi_type, csi_val);
    }
    
    PMC_RETURN(ret_val);
    
} /* coreotn_mpma_csi_cfg */


/*******************************************************************************
* coreotn_prbs_null_chan_en_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves a section of unused context for prbs_null_chan_en context
*
* INPUTS:
*   *coreotn_handle   - pointer to COREOTN handle instance to be operated on
*   mux_stage         - See coreotn_mux_stage_t
*   dci_chnl          - The DCI channel ID
*
* OUTPUTS:
*   *prbs_null_chan_en - TRUE : null chan en for PRBS work-around is enabled
*                       FALSE : null chan en for PRBS work-around is not enabled
*
* RETURNS:
*   PMC_ERROR
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_prbs_null_chan_en_get(coreotn_handle_t *coreotn_handle,
                                                coreotn_mux_stage_t mux_stage,
                                                UINT32 dci_chnl,
                                                BOOL *prbs_null_chan_en)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 *prbs_null_chan_en_ptr;
    
    PMC_ENTRY();

    /* there are a maximum of 12 HO channels, but the MUX/DMX have 96 channels
    worth of context instantiated */
    prbs_null_chan_en_ptr = (UINT32 *)(&(coreotn_handle->odtu_mux1_handle->var.ho_chnl_cfg[13]));

    if(mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        *prbs_null_chan_en = (prbs_null_chan_en_ptr[dci_chnl/32] >> dci_chnl%32) & 0x1;
    }
    else if(mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        *prbs_null_chan_en = (prbs_null_chan_en_ptr[3+(dci_chnl/32)] >> dci_chnl%32) & 0x1;
    }
    else
    {
         ret_val = COREOTN_ERR_INVALID_ARG;
    }


     
    PMC_RETURN(ret_val);
    
} /* coreotn_prbs_null_chan_en_get */


/*******************************************************************************
* coreotn_prbs_null_chan_en_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves a section of unused context for prbs_null_chan_en context
*
* INPUTS:
*   *coreotn_handle   - pointer to COREOTN handle instance to be operated on
*   mux_stage         - See coreotn_mux_stage_t
*   dci_chnl          - The DCI channel ID
*   prbs_null_chan_en - TRUE : Enable null chan en for PRBS work-around
*                       FALSE : Diable null chan en for PRBS work-around
*   ho_chnl_id        - Channel id used for state one muxing.
*
* OUTPUTS:
*   
*
* RETURNS:
*   PMC_ERROR
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR coreotn_prbs_null_chan_en_set(coreotn_handle_t *coreotn_handle,
                                                coreotn_mux_stage_t mux_stage,
                                                UINT32 dci_chnl,
                                                BOOL prbs_null_chan_en,
                                                UINT32 ho_chnl_id)
{
    /* variable declaration */
    PMC_ERROR ret_val = PMC_SUCCESS; 
    UINT32 *prbs_null_chan_en_ptr;
    odtu_mux_handle_t *mux_handle_ptr;
    util_global_odu_line_payload_t payload_format = LAST_UTIL_GLOBAL_ODU_LINE_PAYLOAD;;

    PMC_ENTRY();

    /* there are a maximum of 12 HO channels, but the MUX/DMX have 96 channels
    worth of context instantiated */
    prbs_null_chan_en_ptr = (UINT32*)(&(coreotn_handle->odtu_mux1_handle->var.ho_chnl_cfg[13]));

    if(mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if(prbs_null_chan_en)
        {
            prbs_null_chan_en_ptr[dci_chnl/32] = prbs_null_chan_en_ptr[dci_chnl/32] | (1<<(dci_chnl%32));
        }
        else
        {
            prbs_null_chan_en_ptr[dci_chnl/32] = prbs_null_chan_en_ptr[dci_chnl/32] & ~(1<<(dci_chnl%32));
        }
    }
    else if(mux_stage == COREOTN_MUX_STAGE_TWO)
    {
        if(prbs_null_chan_en)
        {
            prbs_null_chan_en_ptr[3+(dci_chnl/32)] = prbs_null_chan_en_ptr[3+(dci_chnl/32)] | (1<<(dci_chnl%32));
        }
        else
        {
            prbs_null_chan_en_ptr[3+(dci_chnl/32)] = prbs_null_chan_en_ptr[3+(dci_chnl/32)] & ~(1<<(dci_chnl%32));
        }
    }
    else
    {
         ret_val = COREOTN_ERR_INVALID_ARG;
    }


    if (mux_stage == COREOTN_MUX_STAGE_ONE)
    {
        if(coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE ||
           coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE )
        {
            mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
        }
        else 
        {
            mux_handle_ptr = coreotn_handle->odtu_mux1_handle;

        }

        if (ho_chnl_id < COREOTN_PRBS_NUM_CHNL)
        {
            payload_format = coreotn_handle->var.tx_ho_chnl_ctxt[ho_chnl_id].payload_format;
        }
    }
    else 
    {
        mux_handle_ptr = coreotn_handle->odtu_mux2_handle;
        payload_format = coreotn_handle->var.tx_mo_chnl_ctxt[dci_chnl].payload_format;
    }


    /*hack should only be applied for 1G25 or 2G5 payload format*/
    if (payload_format == UTIL_GLOBAL_ODU_TS_1G25 ||
       payload_format == UTIL_GLOBAL_ODU_TS_2G5)
    {
        if(ret_val == PMC_SUCCESS)
        {
            ret_val = odtu_mux_null_chnl_cfg(mux_handle_ptr, dci_chnl, prbs_null_chan_en);
        }

        if(ret_val == PMC_SUCCESS)
        {
              ret_val = coreotn_tx_lo_chnl_add_ho_page_swap(coreotn_handle,
                                                            mux_handle_ptr,
                                                            dci_chnl); 
        }
        
        if(ret_val == PMC_SUCCESS)
        {
            ret_val = odtu_mux_null_chnl_cfg(mux_handle_ptr, dci_chnl, prbs_null_chan_en);
        }

    }
     
    PMC_RETURN(ret_val);
    
} /* coreotn_prbs_null_chan_en_set */





/*******************************************************************************
* coreotn_mapotn_null_frame_mode_ptr_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves a section of unused context for prbs_null_chan_en context
*
* INPUTS:
*   *coreotn_handle   - pointer to COREOTN handle instance to be operated on

*
* OUTPUTS:
*   *prbs_null_chan_en - bit mask of size UINT32[3] that contains PRBS null channel
*                        enabled context
*   *null_chan_en      - bit mask of size UINT32[3] that contains null channel
*                        enabled context
*
* RETURNS:
*   PMC_ERROR
*
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_mapotn_null_frame_mode_ptr_get(coreotn_handle_t *coreotn_handle,
                                                        UINT32 **null_chan_en,
                                                        UINT32 **prbs_null_chan_en)
{
    
    PMC_ENTRY();

    /* there are a maximum of 12 HO channels, but the MUX/DMX have 96 channels
    worth of context instantiated */
    *null_chan_en = (UINT32 *)(&(coreotn_handle->odtu_mux1_handle->var.ho_chnl_cfg[16]));
    *prbs_null_chan_en = (UINT32 *)(&(coreotn_handle->odtu_mux1_handle->var.ho_chnl_cfg[18]));

     
    PMC_RETURN();
    
} /* coreotn_mapotn_null_frame_mode_ptr_get */



/*******************************************************************************
* coreotn_prev_rfrm_maint_sig_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves previously provisioned (not dummy maintenance signal) provisioned
*   at RFRMs at the egress of the ODUKSW towards LINEOTN/SYSOTN.
*
* INPUTS:
*   *coreotn_handle   - pointer to COREOTN handle instance to be operated on
*   chnl_id           - Channel id
*   fo1_rfrm          - TRUE : FO1 RFRM
*                       FALSE : SYSOTN - stage 2 RFRM
*
* OUTPUTS:
*   *prev_maint_sig   - The previously provisioned maintenance signal (not
*                       the dummy maintenance signal)
*
* RETURNS:
*   PMC_ERROR
*
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_prev_rfrm_maint_sig_get(coreotn_handle_t *coreotn_handle,
                                            UINT32 chnl_id,
                                            BOOL fo1_rfrm,
                                            coreotn_maint_sig_type_t *prev_maint_sig)
{
    
    PMC_ENTRY();

    if(fo1_rfrm == FALSE)
    {
        *prev_maint_sig = (coreotn_maint_sig_type_t)coreotn_handle->var.prev_fmf1_sysotn_rfrm_maint_sig[chnl_id];
    }
    else
    {
        *prev_maint_sig = (coreotn_maint_sig_type_t)coreotn_handle->var.prev_fo1_rfrm_maint_sig[chnl_id];
    }

     
    PMC_RETURN();
    
} /* coreotn_prev_rfrm_maint_sig_get */

/*******************************************************************************
* coreotn_cm_status_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves previously provisioned (not dummy maintenance signal) provisioned
*   at RFRMs at the egress of the ODUKSW towards LINEOTN/SYSOTN.
*
* INPUTS:
*   *coreotn_handle   - pointer to COREOTN handle instance to be operated on
*   fmf_instance      - Whether this is called from the perspective of FMF1
*                       or FMF2.
*   chnl_id           - Channel id
*
* OUTPUTS:
*   value             - The contents of the CM_STAT_REG register.
*
* RETURNS:
*   PMC_ERROR
*
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_cm_status_get(coreotn_handle_t *coreotn_handle,
                                  coreotn_fmf_inst_t fmf_instance,
                                  UINT32 chnl_id,
                                  UINT32 *value)
{
    odtu_dmx_handle_t *odtu_hndl = NULL;

    PMC_ENTRY();

    PMC_ASSERT(fmf_instance < LAST_COREOTN_FMF_INST, COREOTN_ERR_INVALID_ARG,
               0, 0);

    if (COREOTN_FMF_INST_1 == fmf_instance)
    {
        odtu_hndl = coreotn_handle->odtu_dmx1_handle;
    }
    else
    {
        odtu_hndl = coreotn_handle->odtu_dmx2_handle;
    }
    odtu_dmx_cm_status_get(odtu_hndl, chnl_id, value);

    PMC_RETURN();
} /* coreotn_cm_status_get */

/*******************************************************************************
* coreotn_pm_status_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Retrieves the PM/TCM status values. Reads the data held in memory
*  assigns them to the corresponding array value.
*
* INPUTS:
*  *coreotn_handle   - pointer to COREOTN handle instance to be operated on
*
*  chnl_info_ptr     - Defines the source and odu_level to be collected.
*
* OUTPUTS:
*  pm_table_ptr      - Reference to the PM/TCM status table.
*
* RETURNS:
*  PMC_SUCCESS      - Table was successfully generated
*  PMC_ERROR        - Otherwise
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_pm_status_get(coreotn_handle_t *coreotn_handle,
                                       coreotn_int_chnl_info_t *chnl_info_ptr,
                                       util_global_otn_pm_status_t *pm_table_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    odu_rfrm_handle_t *rfrm_handle = NULL;

    PMC_ENTRY();

    result = coreotn_int_validate(coreotn_handle, chnl_info_ptr, chnl_info_ptr);


    if (PMC_SUCCESS == result)
    {
        result = coreotn_rfrm_handle_get(coreotn_handle,
                                         chnl_info_ptr,
                                         &rfrm_handle);   
    }   

    if (PMC_SUCCESS == result && NULL != rfrm_handle)
    {
        odu_rfrm_pm_status_get(rfrm_handle,
                               pm_table_ptr);
    }    

    PMC_RETURN(result);
}

/*******************************************************************************
* coreotn_mpmo_fifo_clear
* ______________________________________________________________________________
*
* DESCRIPTION:
*  API empties fo1 or CTL mpmo FIFO for unchannelized HO odu struct channel.
*
* INPUTS:
*  *coreotn_handle   - pointer to COREOTN handle instance to be operated on
*  clear_set         - 0 pass FALSE, 1 TRUE and anything else toggles 
*                      between TRUE and FALSE.
*  *odu_struct_ptr   - pointer to odu struct to be operated on.
*
* OUTPUTS:
*  None.
*
* RETURNS:
*  PMC_SUCCESS      - Table was successfully generated
*  PMC_ERROR        - Otherwise
*
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_mpmo_fifo_clear(coreotn_handle_t *coreotn_handle,
                                        UINT32 clear_set,
                                        odu_struct_t     *odu_struct_ptr)
{
    UINT32 chnl_id;
    mpmo_handle_t              *mpmo_handle = NULL;

    PMC_ENTRY();
    /* argument checking */
    PMC_ASSERT(NULL != coreotn_handle, COREOTN_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(NULL != odu_struct_ptr, COREOTN_ERR_INVALID_ARG, 0, 0);

    chnl_id = odu_struct_ptr->switch_data.oduk_data.channel;

    if (odu_struct_ptr->mem_ptr->odu_level == ODU_STRUCT_LEVEL_LO_ODU && 
        (coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_MODE ||
         coreotn_handle->var.init_operation == COREOTN_SS_SYSOTN_BYPASS_MODE))
    {
        mpmo_handle = coreotn_handle->mpmo_core_ctl_handle;
    }
    else if (odu_struct_ptr->mem_ptr->payload_format == UTIL_GLOBAL_ODU_UNCHANNELIZED &&
             odu_struct_ptr->switch_data.oduk_data.odu_level == UTIL_GLOBAL_LEVEL_HO_ODU)
    {
        mpmo_handle = coreotn_handle->mpmo_fo1_handle;
    }

    if (NULL != mpmo_handle &&
        chnl_id < COREOTN_12_FRM_CHNL)
    {

        if (0 == clear_set)
        {
            l5sys_wait_queue_done(coreotn_handle);
            PMC_OS_USLEEP(1000);
            mpmo_ch_fifo_clear_set(mpmo_handle, chnl_id, FALSE);
        }
        else if (1 == clear_set)
        {
            mpmo_ch_fifo_clear_set(mpmo_handle, chnl_id, TRUE);
        }
        else
        {
            mpmo_ch_fifo_clear_set(mpmo_handle, chnl_id, TRUE);
            l5sys_wait_queue_done(coreotn_handle);
            PMC_OS_USLEEP(100);
            mpmo_ch_fifo_clear_set(mpmo_handle, chnl_id, FALSE);
        }
    }


    PMC_RETURN();
}

/*******************************************************************************
* coreotn_resest_mux
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Reset the FMF1 muxes after HO switch from UNCHANNELIZED to CHANNELIZED.
*
* INPUTS:
*  coreotn_handle  - pointer to COREOTN handle instance to be operated on
*  ho_chnl_id      - High order channel being operated on.
*  is_sysotn       - Whether this reset is applied to SYSOTN HO or a 
*                    LINEOTN HO.
*
* OUTPUTS:
*  None.
*
* RETURNS:
*  PMC_SUCCESS      - Table was successfully generated
*  PMC_ERROR        - Otherwise
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR coreotn_reset_mux(coreotn_handle_t *coreotn_handle,
                                   UINT32 ho_chnl_id,
                                   BOOL8 is_sysotn)
{
    PMC_ERROR result = PMC_SUCCESS;
    odtu_mux_handle_t *odtu_mux_handle = coreotn_handle->odtu_mux1_handle;
    PMC_ENTRY();
    
    if (TRUE == is_sysotn)
    {
        odtu_mux_handle = coreotn_handle->odtu_mux2_handle;
    }

    result = odtu_mux_ho_chnl_reset_set(odtu_mux_handle, 
                                        ho_chnl_id, 0);
    
    if (PMC_SUCCESS == result)
    {
        result = odtu_mux_ohfs_insert_cfc_fifo_deactivate(odtu_mux_handle,
                                                          ho_chnl_id);
    }

    if (PMC_SUCCESS == result)
    {
        result = odtu_mux_ohfs_insert_cfc_fifo_activate(odtu_mux_handle,
                                                        ho_chnl_id);
    }

    if (PMC_SUCCESS == result)
    {
        result = odtu_mux_ho_chnl_reset_set(odtu_mux_handle, 
                                            ho_chnl_id, 1);
    }

    PMC_RETURN(result);
}

/*******************************************************************************
* coreotn_oduksw_port_bulk_update_req_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function initialize the update indication array to it's default value.
*
* INPUTS:
*   *coreotn_handle     - pointer to CoreOTN handle instance
*
* RETURNS:
*   TRUE: if the update is needed.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void coreotn_oduksw_port_bulk_update_req_init(coreotn_handle_t *coreotn_handle)
{
    PMC_ENTRY();

    cpb_oduksw_port_bulk_update_req_init(coreotn_handle->oduksw_handle);

    PMC_RETURN();
} /* coreotn_oduksw_port_bulk_update_req_init */

/*
** End of file
*/
