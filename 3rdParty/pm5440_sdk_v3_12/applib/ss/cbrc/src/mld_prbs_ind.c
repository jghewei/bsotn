/*******************************************************************************
*   COPYRIGHT (C) 2011 PMC-SIERRA, INC. ALL RIGHTS RESERVED.
* --------------------------------------------------------------------------
*  This software embodies materials and concepts which are proprietary and
*  confidential to PMC-Sierra, Inc.
*  PMC-Sierra distributes this software to its customers pursuant to the
*  terms and conditions of the Software License Agreement
*  contained in the text file software.lic that is distributed along with
*  the software. This software can only be utilized if all
*  terms and conditions of the Software License Agreement are
*  accepted. If there are any questions, concerns, or if the
*  Software License Agreement text file, software.lic, is missing please
*  contact PMC-Sierra for assistance.
* --------------------------------------------------------------------------
*   DESCRIPTION :
*       Implements the indirect access functions for each indirect register
*       within the MLD_PRBS.
* 
*   NOTES:
*       This file is auto generated. Do not edit this file.
*
*******************************************************************************/

/*
** Include Files
*/
#include "mld_prbs_ind.h"

/*
** Local Enumerated Types
*/

/*
** Local Constants
*/
/* PRGM indirect memory constants */
#define PRGM_IADDR_MAX               PMC_CONFIG_AND_STATUS_REG_GENERATOR_B1_E1_VAL

#define PRGM_IND_READ               1
#define PRGM_IND_WRITE              0
#define PRGM_IND_BUSY_COMPLETE      0
#define PRGM_POLL_ITERATIONS        250
#define PRGM_USEC_DELAY_TICKS       1



/* SHPI indirect memory constants */
#define SHPI_SLICE_MAX_NUM          3
#define SHPI_IADDR_MAX              PMC_SHPI_INDIRECT_REG_POINTER_VAL

#define SHPI_IND_READ               1
#define SHPI_IND_WRITE              0
#define SHPI_IND_BUSY_COMPLETE      0
#define SHPI_POLL_ITERATIONS        250
#define SHPI_USEC_DELAY_TICKS       1






/*
** Local Macro Definitions
*/
/*
** Local Structures and Unions
*/

/*
** Local Variables
*/


/*******************************************************************************
* _config_and_status_access
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Performs an indirect access command for CONFIG_AND_STATUS indirect memory
*
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   iaddr        - indirect memory address to access
*   access_type  - indirect access type
*                    PRGM_IND_WRITE: Write
*                    PRGM_IND_READ:  Read
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR _config_and_status_access(cbrc_handle_t *h,
                                            UINT32 index_a,
                                            UINT32 path,
                                            UINT32 iaddr,
                                            UINT32 access_type)
{
    /* declare buffer */
    prgm_buffer_t b[1];

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (iaddr > PRGM_IADDR_MAX) ||
        ((access_type != PRGM_IND_WRITE) && 
         (access_type != PRGM_IND_READ)))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }
    
    /* init buffer */
    prgm_buffer_init(b, h, index_a);

    /* update fields */
    prgm_field_IADDR_set(b, h, index_a, iaddr);
    prgm_field_PATH_set(b, h, index_a, path);

    /* indicate read or write operation */
    prgm_field_RWB_set(b, h, index_a, access_type);

    /* flush buffer */
    prgm_buffer_flush( b );

    PMC_RETURN(PMC_SUCCESS);
} /* _config_and_status_access */


/*******************************************************************************
* _config_and_status_read
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Performs an indirect read access for CONFIG_AND_STATUS indirect memory
*
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   iaddr        - indirect memory address to access
*   *b           - pointer to buffer containing read data
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR _config_and_status_read(cbrc_handle_t *h,
                                          UINT32 index_a,
                                          UINT32 path,
                                          UINT32 iaddr,
                                          config_and_status_buffer_t *b)
{
    UINT32 result;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (b == NULL) || 
        (index_a > 15) ||
        (iaddr > PRGM_IADDR_MAX))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* poll BUSY bit to ensure register is ready indirect access */
    result = prgm_field_BUSY_poll(NULL, 
                                  h, index_a, 
                                  PRGM_IND_BUSY_COMPLETE, 
                                  PMC_POLL_EQUAL,
                                  PRGM_POLL_ITERATIONS, 
                                  NULL, 
                                  PRGM_USEC_DELAY_TICKS);

    if (result != PMC_SUCCESS) 
    {
        LOG("prgm_field_BUSY_poll failed...");
        PMC_RETURN(result);
    }

    /* initiate the indirect read access */
    result = _config_and_status_access(h, index_a, path, iaddr, PRGM_IND_READ);   
    
    if (result != PMC_SUCCESS) PMC_RETURN(result);

    /* poll BUSY bit to ensure data is ready to be read */
    result = prgm_field_BUSY_poll(NULL,
                                  h, index_a,
                                  PRGM_IND_BUSY_COMPLETE,
                                  PMC_POLL_EQUAL,
                                  PRGM_POLL_ITERATIONS,
                                  NULL,
                                  PRGM_USEC_DELAY_TICKS);

    if (result != PMC_SUCCESS) 
    {
        LOG("prgm_field_BUSY_poll failed...");
        PMC_RETURN(result);
    }

    /* read indirect access data from indirect data registers */
    b->data[0] = prgm_field_DATA_get(NULL, h, index_a);
    b->mask[0] = PRGM_REG_IND_DATA_BIT_DATA_MSK;

    PMC_RETURN(PMC_SUCCESS);
} /* _config_and_status_read */


/*******************************************************************************
* _config_and_status_read_modify_write
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Performs an indirect read/modify/write access for CONFIG_AND_STATUS indirect memory
*
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   iaddr        - indirect memory address to access
*   *b           - pointer to buffer for data to be written
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR _config_and_status_read_modify_write(cbrc_handle_t *h,
                                                       UINT32 index_a,
                                                       UINT32 path,
                                                       UINT32 iaddr,
                                                       config_and_status_buffer_t *b)
{
    config_and_status_buffer_t tmp_b;
    UINT32 access_data;
    UINT32 result;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (b == NULL) || 
        (index_a > 15) ||
        (iaddr > PRGM_IADDR_MAX))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* read and update the data of indirect data registers */
    result = _config_and_status_read(h, index_a, path, iaddr, (config_and_status_buffer_t *)&tmp_b);
    if (result != PMC_SUCCESS) {
        PMC_RETURN(result);
    }

    access_data = tmp_b.data[0];


    access_data = (access_data & ~(b->mask[0])) | (b->data[0]);

    /* write indirect access data to indirect data registers */
    prgm_field_DATA_set(NULL, h, index_a, access_data);

    /* initiate the indirect write access */
    result = _config_and_status_access(h, index_a, path, iaddr, PRGM_IND_WRITE);

    if (result != PMC_SUCCESS)
    {
        PMC_RETURN(result);
    }

    /* poll BUSY bit to ensure indirect write access completes */
    result = prgm_field_BUSY_poll(NULL, 
                                  h, index_a, 
                                  PRGM_IND_BUSY_COMPLETE, 
                                  PMC_POLL_EQUAL,
                                  PRGM_POLL_ITERATIONS, 
                                  NULL, 
                                  PRGM_USEC_DELAY_TICKS);

    if (result != PMC_SUCCESS) 
    {
        LOG("prgm_field_BUSY_poll failed...");
        PMC_RETURN(result);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* _config_and_status_read_modify_write */



/*******************************************************************************
* config_and_status_MON_STS_1_PATH_CFG_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies MON_STS_1_PATH_CFG data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   *b           - pointer to CONFIG_AND_STATUS data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR config_and_status_MON_STS_1_PATH_CFG_buffer_apply(cbrc_handle_t * h,  
                                                                   UINT32 index_a,
                                                                   UINT32 path,
                                                                   config_and_status_MON_STS_1_PATH_CFG_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_CONFIG_AND_STATUS_REG_MON_STS_1_PATH_CFG;

    result = _config_and_status_read_modify_write(h, index_a, path, iaddr, (config_and_status_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* config_and_status_MON_STS_1_PATH_CFG_buffer_apply */




/*******************************************************************************
* config_and_status_MON_STS_1_PATH_CFG_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves MON_STS_1_PATH_CFG data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   *b           - pointer to CONFIG_AND_STATUS data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR config_and_status_MON_STS_1_PATH_CFG_buffer_retrieve(cbrc_handle_t * h,  
                                                                      UINT32 index_a,
                                                                      UINT32 path,
                                                                      config_and_status_MON_STS_1_PATH_CFG_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_CONFIG_AND_STATUS_REG_MON_STS_1_PATH_CFG;

    /*
      PMC_OS_MUTEX_LOCK(config_and_status_lock);
    */
    result = _config_and_status_read(h, index_a, path, iaddr, (config_and_status_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
          PMC_OS_MUTEX_UNLOCK(config_and_status_lock);
        */
        PMC_RETURN(result);
    }
    /*
      PMC_OS_MUTEX_UNLOCK(config_and_status_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* config_and_status_MON_STS_1_PATH_CFG_buffer_apply */




/*******************************************************************************
* config_and_status_MON_PRBS_22_7_ACCUMULATOR_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies MON_PRBS_22_7_ACCUMULATOR data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   *b           - pointer to CONFIG_AND_STATUS data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR config_and_status_MON_PRBS_22_7_ACCUMULATOR_buffer_apply(cbrc_handle_t * h,  
                                                                          UINT32 index_a,
                                                                          UINT32 path,
                                                                          config_and_status_MON_PRBS_22_7_ACCUMULATOR_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_CONFIG_AND_STATUS_REG_MON_PRBS_22_7_ACCUMULATOR;

    result = _config_and_status_read_modify_write(h, index_a, path, iaddr, (config_and_status_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* config_and_status_MON_PRBS_22_7_ACCUMULATOR_buffer_apply */



/*******************************************************************************
* config_and_status_MON_PRBS_22_7_ACCUMULATOR_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves MON_PRBS_22_7_ACCUMULATOR data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   *b           - pointer to CONFIG_AND_STATUS data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR config_and_status_MON_PRBS_22_7_ACCUMULATOR_buffer_retrieve(cbrc_handle_t * h,  
                                                                             UINT32 index_a,
                                                                             UINT32 path,
                                                                             config_and_status_MON_PRBS_22_7_ACCUMULATOR_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_CONFIG_AND_STATUS_REG_MON_PRBS_22_7_ACCUMULATOR;

    /*
      PMC_OS_MUTEX_LOCK(config_and_status_lock);
    */
    result = _config_and_status_read(h, index_a, path, iaddr, (config_and_status_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
          PMC_OS_MUTEX_UNLOCK(config_and_status_lock);
        */
        PMC_RETURN(result);
    }
    /*
      PMC_OS_MUTEX_UNLOCK(config_and_status_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* config_and_status_MON_PRBS_22_7_ACCUMULATOR_buffer_apply */




/*******************************************************************************
* config_and_status_MON_PRBS_6_0_ACCUMULATOR_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies MON_PRBS_6_0_ACCUMULATOR data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   *b           - pointer to CONFIG_AND_STATUS data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR config_and_status_MON_PRBS_6_0_ACCUMULATOR_buffer_apply(cbrc_handle_t * h,  
                                                                         UINT32 index_a,
                                                                         UINT32 path,
                                                                         config_and_status_MON_PRBS_6_0_ACCUMULATOR_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_CONFIG_AND_STATUS_REG_MON_PRBS_6_0_ACCUMULATOR;

    result = _config_and_status_read_modify_write(h, index_a, path, iaddr, (config_and_status_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* config_and_status_MON_PRBS_6_0_ACCUMULATOR_buffer_apply */



/*******************************************************************************
* config_and_status_MON_PRBS_6_0_ACCUMULATOR_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves MON_PRBS_6_0_ACCUMULATOR data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS path ID [1..12].
*   *b           - pointer to CONFIG_AND_STATUS data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR config_and_status_MON_PRBS_6_0_ACCUMULATOR_buffer_retrieve(cbrc_handle_t * h,  
                                                                            UINT32 index_a,
                                                                            UINT32 path,
                                                                            config_and_status_MON_PRBS_6_0_ACCUMULATOR_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_CONFIG_AND_STATUS_REG_MON_PRBS_6_0_ACCUMULATOR;

    /*
      PMC_OS_MUTEX_LOCK(config_and_status_lock);
    */
    result = _config_and_status_read(h, index_a, path, iaddr, (config_and_status_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
          PMC_OS_MUTEX_UNLOCK(config_and_status_lock);
        */
        PMC_RETURN(result);
    }
    /*
      PMC_OS_MUTEX_UNLOCK(config_and_status_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* config_and_status_MON_PRBS_6_0_ACCUMULATOR_buffer_apply */




/*******************************************************************************
* config_and_status_MON_ERR_CNT_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies MON_ERR_CNT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   *b           - pointer to CONFIG_AND_STATUS data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR config_and_status_MON_ERR_CNT_buffer_apply(cbrc_handle_t * h,  
                                                            UINT32 index_a,
                                                            UINT32 path,
                                                            config_and_status_MON_ERR_CNT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_CONFIG_AND_STATUS_REG_MON_ERR_CNT;

    result = _config_and_status_read_modify_write(h, index_a, path, iaddr, (config_and_status_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* config_and_status_MON_ERR_CNT_buffer_apply */



/*******************************************************************************
* config_and_status_MON_ERR_CNT_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves MON_ERR_CNT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   *b           - pointer to CONFIG_AND_STATUS data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR config_and_status_MON_ERR_CNT_buffer_retrieve(cbrc_handle_t * h,  
                                                               UINT32 index_a,
                                                               UINT32 path,
                                                               config_and_status_MON_ERR_CNT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_CONFIG_AND_STATUS_REG_MON_ERR_CNT;

    /*
      PMC_OS_MUTEX_LOCK(config_and_status_lock);
    */
    result = _config_and_status_read(h, index_a, path, iaddr, (config_and_status_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
          PMC_OS_MUTEX_UNLOCK(config_and_status_lock);
        */
        PMC_RETURN(result);
    }
    /*
      PMC_OS_MUTEX_UNLOCK(config_and_status_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* config_and_status_MON_ERR_CNT_buffer_apply */




/*******************************************************************************
* config_and_status_GENERATOR_STS_1_PATH_CFG_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies GENERATOR_STS_1_PATH_CFG data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   *b           - pointer to CONFIG_AND_STATUS data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR config_and_status_GENERATOR_STS_1_PATH_CFG_buffer_apply(cbrc_handle_t * h,  
                                                                         UINT32 index_a,
                                                                         UINT32 path,
                                                                         config_and_status_GENERATOR_STS_1_PATH_CFG_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_CONFIG_AND_STATUS_REG_GENERATOR_STS_1_PATH_CFG;

    result = _config_and_status_read_modify_write(h, index_a, path, iaddr, (config_and_status_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* config_and_status_GENERATOR_STS_1_PATH_CFG_buffer_apply */


/*******************************************************************************
* config_and_status_GENERATOR_B1_E1_VAL_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies GENERATOR_B1_E1_VAL data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   *b           - pointer to CONFIG_AND_STATUS data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR config_and_status_GENERATOR_B1_E1_VAL_buffer_apply(cbrc_handle_t * h,  
                                                                    UINT32 index_a,
                                                                    UINT32 path,
                                                                    config_and_status_GENERATOR_B1_E1_VAL_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_CONFIG_AND_STATUS_REG_GENERATOR_B1_E1_VAL;

    result = _config_and_status_read_modify_write(h, index_a, path, iaddr, (config_and_status_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* config_and_status_GENERATOR_B1_E1_VAL_buffer_apply */



/*******************************************************************************
* config_and_status_GENERATOR_STS_1_PATH_CFG_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves GENERATOR_STS_1_PATH_CFG data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   *b           - pointer to CONFIG_AND_STATUS data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR config_and_status_GENERATOR_STS_1_PATH_CFG_buffer_retrieve(cbrc_handle_t * h,  
                                                                            UINT32 index_a,
                                                                            UINT32 path,
                                                                            config_and_status_GENERATOR_STS_1_PATH_CFG_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_CONFIG_AND_STATUS_REG_GENERATOR_STS_1_PATH_CFG;

    /*
      PMC_OS_MUTEX_LOCK(config_and_status_lock);
    */
    result = _config_and_status_read(h, index_a, path, iaddr, (config_and_status_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
          PMC_OS_MUTEX_UNLOCK(config_and_status_lock);
        */
        PMC_RETURN(result);
    }
    /*
      PMC_OS_MUTEX_UNLOCK(config_and_status_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* config_and_status_GENERATOR_STS_1_PATH_CFG_buffer_apply */




/*******************************************************************************
* config_and_status_GENERATOR_PRBS_22_7_ACCUMULATOR_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies GENERATOR_PRBS_22_7_ACCUMULATOR data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   *b           - pointer to CONFIG_AND_STATUS data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR config_and_status_GENERATOR_PRBS_22_7_ACCUMULATOR_buffer_apply(cbrc_handle_t * h,  
                                                                                UINT32 index_a,
                                                                                UINT32 path,
                                                                                config_and_status_GENERATOR_PRBS_22_7_ACCUMULATOR_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_CONFIG_AND_STATUS_REG_GENERATOR_PRBS_22_7_ACCUMULATOR;

    result = _config_and_status_read_modify_write(h, index_a, path, iaddr, (config_and_status_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* config_and_status_GENERATOR_PRBS_22_7_ACCUMULATOR_buffer_apply */



/*******************************************************************************
* config_and_status_GENERATOR_PRBS_22_7_ACCUMULATOR_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves GENERATOR_PRBS_22_7_ACCUMULATOR data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   *b           - pointer to CONFIG_AND_STATUS data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR config_and_status_GENERATOR_PRBS_22_7_ACCUMULATOR_buffer_retrieve(cbrc_handle_t * h,  
                                                                                   UINT32 index_a,
                                                                                   UINT32 path,
                                                                                   config_and_status_GENERATOR_PRBS_22_7_ACCUMULATOR_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_CONFIG_AND_STATUS_REG_GENERATOR_PRBS_22_7_ACCUMULATOR;

    /*
      PMC_OS_MUTEX_LOCK(config_and_status_lock);
    */
    result = _config_and_status_read(h, index_a, path, iaddr, (config_and_status_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
          PMC_OS_MUTEX_UNLOCK(config_and_status_lock);
        */
        PMC_RETURN(result);
    }
    /*
      PMC_OS_MUTEX_UNLOCK(config_and_status_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* config_and_status_GENERATOR_PRBS_22_7_ACCUMULATOR_buffer_apply */




/*******************************************************************************
* config_and_status_GENERATOR_PRBS_6_0_ACCUMULATOR_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies GENERATOR_PRBS_6_0_ACCUMULATOR data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   *b           - pointer to CONFIG_AND_STATUS data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR config_and_status_GENERATOR_PRBS_6_0_ACCUMULATOR_buffer_apply(cbrc_handle_t * h,  
                                                                               UINT32 index_a,
                                                                               UINT32 path,
                                                                               config_and_status_GENERATOR_PRBS_6_0_ACCUMULATOR_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_CONFIG_AND_STATUS_REG_GENERATOR_PRBS_6_0_ACCUMULATOR;

    result = _config_and_status_read_modify_write(h, index_a, path, iaddr, (config_and_status_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* config_and_status_GENERATOR_PRBS_6_0_ACCUMULATOR_buffer_apply */



/*******************************************************************************
* config_and_status_GENERATOR_PRBS_6_0_ACCUMULATOR_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves GENERATOR_PRBS_6_0_ACCUMULATOR data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - PRGM slice instance index_a=0:15 to access
*   path         - STS-1 path id
*   *b           - pointer to CONFIG_AND_STATUS data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR config_and_status_GENERATOR_PRBS_6_0_ACCUMULATOR_buffer_retrieve(cbrc_handle_t * h,  
                                                                                  UINT32 index_a,
                                                                                  UINT32 path,
                                                                                  config_and_status_GENERATOR_PRBS_6_0_ACCUMULATOR_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 15) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_CONFIG_AND_STATUS_REG_GENERATOR_PRBS_6_0_ACCUMULATOR;

    /*
      PMC_OS_MUTEX_LOCK(config_and_status_lock);
    */
    result = _config_and_status_read(h, index_a, path, iaddr, (config_and_status_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
          PMC_OS_MUTEX_UNLOCK(config_and_status_lock);
        */
        PMC_RETURN(result);
    }
    /*
      PMC_OS_MUTEX_UNLOCK(config_and_status_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* config_and_status_GENERATOR_PRBS_6_0_ACCUMULATOR_buffer_apply */





/*******************************************************************************
* _shpi_indirect_access
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Performs an indirect access command for SHPI_INDIRECT indirect memory
*
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - SHPI slice instance index_a=0:3 to access
*   iaddr        - indirect memory address to access
*   access_type  - indirect access type
*                    SHPI_IND_WRITE: Write
*                    SHPI_IND_READ:  Read
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR _shpi_indirect_access(cbrc_handle_t *h,
                                        UINT32 index_a,
                                        UINT32 iaddr,
                                        UINT32 access_type)
{
    /* declare buffer */
    shpi_buffer_t b[1];

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (iaddr > SHPI_IADDR_MAX) ||
        ((access_type != SHPI_IND_WRITE) && 
         (access_type != SHPI_IND_READ)))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }
    
    /* init buffer */
    shpi_buffer_init(b, h, index_a);

    /* update fields */
    shpi_field_IADDR_set(b, h, index_a, iaddr);

    /* indicate read or write operation */
    shpi_field_RWB_set(b, h, index_a, access_type);

    /* flush buffer */
    shpi_buffer_flush( b );

    PMC_RETURN(PMC_SUCCESS);
} /* _shpi_indirect_access */


/*******************************************************************************
* _shpi_indirect_read
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Performs an indirect read access for SHPI_INDIRECT indirect memory
*
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - SHPI slice instance index_a=0:3 to access
*   iaddr        - indirect memory address to access
*   *b           - pointer to buffer containing read data
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR _shpi_indirect_read(cbrc_handle_t *h,
                                      UINT32 index_a,
                                      UINT32 iaddr,
                                      shpi_indirect_buffer_t *b)
{
    UINT32 result;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (b == NULL) || 
        (index_a > 3) ||
        (iaddr > SHPI_IADDR_MAX))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* poll BUSY bit to ensure register is ready indirect access */
    result = shpi_field_BUSY_poll(NULL, 
                                  h, index_a, 
                                  SHPI_IND_BUSY_COMPLETE, 
                                  PMC_POLL_EQUAL,
                                  SHPI_POLL_ITERATIONS, 
                                  NULL, 
                                  SHPI_USEC_DELAY_TICKS);
    
    if (result != PMC_SUCCESS) 
    {
        LOG("shpi_field_BUSY_poll failed...");
        PMC_RETURN(result);
    }
    
    /* initiate the indirect read access */
    result = _shpi_indirect_access(h, index_a, iaddr, SHPI_IND_READ);
    if (result != PMC_SUCCESS) PMC_RETURN(result);

    /* poll BUSY bit to ensure data is ready to be read */
    result = shpi_field_BUSY_poll(NULL, 
                                  h, index_a, 
                                  SHPI_IND_BUSY_COMPLETE, 
                                  PMC_POLL_EQUAL,
                                  SHPI_POLL_ITERATIONS, 
                                  NULL, 
                                  SHPI_USEC_DELAY_TICKS);
    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }

    /* read indirect access data from indirect data registers */
    b->data[0] = shpi_field_DATA_get(NULL, h, index_a);
    b->mask[0] = SHPI_REG_IND_DATA_BIT_DATA_MSK;

    PMC_RETURN(PMC_SUCCESS);
} /* _shpi_indirect_read */


/*******************************************************************************
* _shpi_indirect_read_modify_write
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Performs an indirect read/modify/write access for SHPI_INDIRECT indirect memory
*
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - SHPI slice instance index_a=0:3 to access
*   iaddr        - indirect memory address to access
*   *b           - pointer to buffer for data to be written
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR _shpi_indirect_read_modify_write(cbrc_handle_t *h,
                                                   UINT32 index_a,
                                                   UINT32 iaddr,
                                                   shpi_indirect_buffer_t *b)
{
    shpi_indirect_buffer_t tmp_b;
    UINT32 access_data;
    UINT32 result;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (b == NULL) || 
        (index_a > 3) ||
        (iaddr > SHPI_IADDR_MAX))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* read and update the data of indirect data registers */
    result = _shpi_indirect_read(h, index_a, iaddr, (shpi_indirect_buffer_t *)&tmp_b);
    if (result != PMC_SUCCESS) PMC_RETURN(result);

    access_data = tmp_b.data[0];

    access_data = (access_data & ~(b->mask[0])) | (b->data[0]);

    /* write indirect access data to indirect data registers */
    shpi_field_DATA_set(NULL, h, index_a, access_data);

    /* initiate the indirect write access */
    result = _shpi_indirect_access(h, index_a, iaddr, SHPI_IND_WRITE);
    if (result != PMC_SUCCESS) PMC_RETURN(result);

    /* poll BUSY bit to ensure indirect write access completes */
    result = shpi_field_BUSY_poll(NULL, 
                                  h, index_a, 
                                  SHPI_IND_BUSY_COMPLETE, 
                                  PMC_POLL_EQUAL,
                                  SHPI_POLL_ITERATIONS, 
                                  NULL, 
                                  SHPI_USEC_DELAY_TICKS);
    if (result != PMC_SUCCESS) 
    {
        LOG("shpi_field_BUSY_poll failed...");
        PMC_RETURN(result);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* _shpi_indirect_read_modify_write */



/*******************************************************************************
* shpi_indirect_IND_INT_VAL_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies IND_INT_VAL data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - SHPI slice instance index_a=0:3 to access
*   *b           - pointer to SHPI_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR shpi_indirect_IND_INT_VAL_buffer_apply(cbrc_handle_t * h,  
                                                        UINT32 index_a,
                                                        shpi_indirect_IND_INT_VAL_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SHPI_INDIRECT_REG_IND_INT_VAL;

    result = _shpi_indirect_read_modify_write(h, index_a, iaddr, (shpi_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* shpi_indirect_IND_INT_VAL_buffer_apply */



/*******************************************************************************
* shpi_indirect_IND_INT_VAL_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves IND_INT_VAL data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - SHPI slice instance index_a=0:3 to access
*   *b           - pointer to SHPI_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR shpi_indirect_IND_INT_VAL_buffer_retrieve(cbrc_handle_t * h,  
                                                           UINT32 index_a,
                                                           shpi_indirect_IND_INT_VAL_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SHPI_INDIRECT_REG_IND_INT_VAL;

    /*
      PMC_OS_MUTEX_LOCK(shpi_indirect_lock);
    */
    result = _shpi_indirect_read(h, index_a, iaddr, (shpi_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
          PMC_OS_MUTEX_UNLOCK(shpi_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
      PMC_OS_MUTEX_UNLOCK(shpi_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* shpi_indirect_IND_INT_VAL_buffer_apply */




/*******************************************************************************
* shpi_indirect_IND_INT_STAT_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies IND_INT_STAT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - SHPI slice instance index_a=0:3 to access
*   *b           - pointer to SHPI_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR shpi_indirect_IND_INT_STAT_buffer_apply(cbrc_handle_t * h,  
                                                         UINT32 index_a,
                                                         shpi_indirect_IND_INT_STAT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SHPI_INDIRECT_REG_IND_INT_STAT;

    result = _shpi_indirect_read_modify_write(h, index_a, iaddr, (shpi_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* shpi_indirect_IND_INT_STAT_buffer_apply */



/*******************************************************************************
* shpi_indirect_IND_INT_STAT_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves IND_INT_STAT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - SHPI slice instance index_a=0:3 to access
*   *b           - pointer to SHPI_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR shpi_indirect_IND_INT_STAT_buffer_retrieve(cbrc_handle_t * h,  
                                                            UINT32 index_a,
                                                            shpi_indirect_IND_INT_STAT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SHPI_INDIRECT_REG_IND_INT_STAT;

    /*
      PMC_OS_MUTEX_LOCK(shpi_indirect_lock);
    */
    result = _shpi_indirect_read(h, index_a, iaddr, (shpi_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
          PMC_OS_MUTEX_UNLOCK(shpi_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
      PMC_OS_MUTEX_UNLOCK(shpi_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* shpi_indirect_IND_INT_STAT_buffer_apply */




/*******************************************************************************
* shpi_indirect_CFG_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies CFG data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - SHPI slice instance index_a=0:3 to access
*   *b           - pointer to SHPI_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR shpi_indirect_CFG_buffer_apply(cbrc_handle_t * h,  
                                                UINT32 index_a,
                                                shpi_indirect_CFG_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SHPI_INDIRECT_REG_CFG;

    result = _shpi_indirect_read_modify_write(h, index_a, iaddr, (shpi_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* shpi_indirect_CFG_buffer_apply */



/*******************************************************************************
* shpi_indirect_CFG_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves CFG data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - SHPI slice instance index_a=0:3 to access
*   *b           - pointer to SHPI_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR shpi_indirect_CFG_buffer_retrieve(cbrc_handle_t * h,  
                                                   UINT32 index_a,
                                                   shpi_indirect_CFG_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SHPI_INDIRECT_REG_CFG;

    /*
      PMC_OS_MUTEX_LOCK(shpi_indirect_lock);
    */
    result = _shpi_indirect_read(h, index_a, iaddr, (shpi_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
          PMC_OS_MUTEX_UNLOCK(shpi_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
      PMC_OS_MUTEX_UNLOCK(shpi_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* shpi_indirect_CFG_buffer_apply */




/*******************************************************************************
* shpi_indirect_PATH_NEGATIVE_JUSTIFICATION_EVENT_CNT_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies PATH_NEGATIVE_JUSTIFICATION_EVENT_CNT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - SHPI slice instance index_a=0:3 to access
*   *b           - pointer to SHPI_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR shpi_indirect_PATH_NEGATIVE_JUSTIFICATION_EVENT_CNT_buffer_apply(cbrc_handle_t * h,  
                                                                                  UINT32 index_a,
                                                                                  shpi_indirect_PATH_NEGATIVE_JUSTIFICATION_EVENT_CNT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SHPI_INDIRECT_REG_PATH_NEGATIVE_JUSTIFICATION_EVENT_CNT;

    result = _shpi_indirect_read_modify_write(h, index_a, iaddr, (shpi_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* shpi_indirect_PATH_NEGATIVE_JUSTIFICATION_EVENT_CNT_buffer_apply */



/*******************************************************************************
* shpi_indirect_PATH_NEGATIVE_JUSTIFICATION_EVENT_CNT_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves PATH_NEGATIVE_JUSTIFICATION_EVENT_CNT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - SHPI slice instance index_a=0:3 to access
*   *b           - pointer to SHPI_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR shpi_indirect_PATH_NEGATIVE_JUSTIFICATION_EVENT_CNT_buffer_retrieve(cbrc_handle_t * h,  
                                                                                     UINT32 index_a,
                                                                                     shpi_indirect_PATH_NEGATIVE_JUSTIFICATION_EVENT_CNT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SHPI_INDIRECT_REG_PATH_NEGATIVE_JUSTIFICATION_EVENT_CNT;

    /*
      PMC_OS_MUTEX_LOCK(shpi_indirect_lock);
    */
    result = _shpi_indirect_read(h, index_a, iaddr, (shpi_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
          PMC_OS_MUTEX_UNLOCK(shpi_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
      PMC_OS_MUTEX_UNLOCK(shpi_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* shpi_indirect_PATH_NEGATIVE_JUSTIFICATION_EVENT_CNT_buffer_apply */




/*******************************************************************************
* shpi_indirect_PATH_POSITIVE_JUSTIFICATION_EVENT_CNT_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies PATH_POSITIVE_JUSTIFICATION_EVENT_CNT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - SHPI slice instance index_a=0:3 to access
*   *b           - pointer to SHPI_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR shpi_indirect_PATH_POSITIVE_JUSTIFICATION_EVENT_CNT_buffer_apply(cbrc_handle_t * h,  
                                                                                  UINT32 index_a,
                                                                                  shpi_indirect_PATH_POSITIVE_JUSTIFICATION_EVENT_CNT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SHPI_INDIRECT_REG_PATH_POSITIVE_JUSTIFICATION_EVENT_CNT;

    result = _shpi_indirect_read_modify_write(h, index_a, iaddr, (shpi_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* shpi_indirect_PATH_POSITIVE_JUSTIFICATION_EVENT_CNT_buffer_apply */



/*******************************************************************************
* shpi_indirect_PATH_POSITIVE_JUSTIFICATION_EVENT_CNT_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves PATH_POSITIVE_JUSTIFICATION_EVENT_CNT data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - SHPI slice instance index_a=0:3 to access
*   *b           - pointer to SHPI_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR shpi_indirect_PATH_POSITIVE_JUSTIFICATION_EVENT_CNT_buffer_retrieve(cbrc_handle_t * h,  
                                                                                     UINT32 index_a,
                                                                                     shpi_indirect_PATH_POSITIVE_JUSTIFICATION_EVENT_CNT_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SHPI_INDIRECT_REG_PATH_POSITIVE_JUSTIFICATION_EVENT_CNT;

    /*
      PMC_OS_MUTEX_LOCK(shpi_indirect_lock);
    */
    result = _shpi_indirect_read(h, index_a, iaddr, (shpi_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
          PMC_OS_MUTEX_UNLOCK(shpi_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
      PMC_OS_MUTEX_UNLOCK(shpi_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* shpi_indirect_PATH_POSITIVE_JUSTIFICATION_EVENT_CNT_buffer_apply */




/*******************************************************************************
* shpi_indirect_POINTER_VAL_buffer_apply
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Applies POINTER_VAL data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - SHPI slice instance index_a=0:3 to access
*   *b           - pointer to SHPI_INDIRECT data buffer
*                  containing data and masks to be applied to the indirect memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR shpi_indirect_POINTER_VAL_buffer_apply(cbrc_handle_t * h,  
                                                        UINT32 index_a,
                                                        shpi_indirect_POINTER_VAL_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SHPI_INDIRECT_REG_POINTER_VAL;

    result = _shpi_indirect_read_modify_write(h, index_a, iaddr, (shpi_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }


    PMC_RETURN(PMC_SUCCESS);
} /* shpi_indirect_POINTER_VAL_buffer_apply */



/*******************************************************************************
* shpi_indirect_POINTER_VAL_buffer_retrieve
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves POINTER_VAL data buffer to the device.
*
* INPUTS:
*   *h           - pointer to CBRC handle instance to be operated on
*   index_a      - SHPI slice instance index_a=0:3 to access
*   *b           - pointer to SHPI_INDIRECT data buffer
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_ERR_INVALID_PARAMETERS
*   PMC_ERR_POLL_TIMEOUT
*   PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR shpi_indirect_POINTER_VAL_buffer_retrieve(cbrc_handle_t * h,  
                                                           UINT32 index_a,
                                                           shpi_indirect_POINTER_VAL_buffer_t *b) 
{
    UINT32 result;
    UINT32 iaddr;

    PMC_ENTRY();

    /* check the inputs */
    if ((h == NULL) || 
        (index_a > 3) ||
        (b == NULL))
    {
        LOG("Input invalid parameter...");
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    /* setting iaddr */
    iaddr = PMC_SHPI_INDIRECT_REG_POINTER_VAL;

    /*
      PMC_OS_MUTEX_LOCK(shpi_indirect_lock);
    */
    result = _shpi_indirect_read(h, index_a, iaddr, (shpi_indirect_buffer_t *)b);

    if (result != PMC_SUCCESS) 
    {
        /*
          PMC_OS_MUTEX_UNLOCK(shpi_indirect_lock);
        */
        PMC_RETURN(result);
    }
    /*
      PMC_OS_MUTEX_UNLOCK(shpi_indirect_lock);
    */

    PMC_RETURN(PMC_SUCCESS);
} /* shpi_indirect_POINTER_VAL_buffer_apply */




