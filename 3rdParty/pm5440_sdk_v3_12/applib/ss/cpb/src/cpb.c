/*******************************************************************************
*   COPYRIGHT (C) 2011 PMC-SIERRA, INC. ALL RIGHTS RESERVED.
* --------------------------------------------------------------------------
*  This software embodies materials and concepts which are proprietary and
*  confidential to PMC-Sierra, Inc.
*  PMC-Sierra distributes this software to its customers pursuant to the
*  terms and conditions of the Software License Agreement
*  contained in the text file software.lic that is distributed along with
*  the software. This software can only be utilized if all
*  terms and conditions of the Software License Agreement are
*  accepted. If there are any questions, concerns, or if the
*  Software License Agreement text file, software.lic, is missing please
*  contact PMC-Sierra for assistance.
* --------------------------------------------------------------------------
*   DESCRIPTION :  This file contains functions for the operations of the CPB
*                  subsystem. It provides instantiation aware operations for
*                  DCPB, OCPB, MCPB and internal emulation testing.
*
*   NOTES:
*
*******************************************************************************/
/*
** Include Files
*/
#include "cpb_loc.h"

/*
** Local Enumerated Types
*/
#define CPB_PORT_NIL    0xFF
#define CPB_CHNL_NIL    0xFF

/*
** Local Constants
*/

/*
** Local Macro Definitions
*/

/*
** Local Structures and Unions
*/

/*
** Local Variables
*/

/* Only include the strings if logging with text  */
#ifdef PMC_LOG_STRINGS

/*
 * The following creates the LOG/ERR strings from above by pulling out the text
 * portion of the LOG_ERR_TABLE above
 */
#define PMC_LOG_ERR_PAIR_ENTRY_CREATE( enum, str ) str,
const char CPB_LOG_ERR_STRINGS[][PMC_LOG_STRING_SIZEOF] =
{
    "Start of log string list",
    CPB_LOG_ERR_TABLE
};
#undef PMC_LOG_ERR_PAIR_ENTRY_CREATE

#else  /* no strings */

const char CPB_LOG_ERR_STRINGS[1][1] = {};

#endif /* PMC_SW_SIMULATION */

/*
** Forward References
*/
extern PUBLIC void digi_cpb_ilkn_dcs_swap_force(void *digi_handle_ptr,
                                         void *cpb_handle, 
                                         UINT32 ilkn_inst);
/*
** Public Functions
*/
PRIVATE UINT32 cpb_num_calendar_entries_get(cpb_handle_t *cpb_handle, UINT32 dcs_inst);
PRIVATE UINT32 cpb_num_sched_chans_get(cpb_handle_t *cpb_handle, UINT32 dcs_inst);
PRIVATE PMC_ERROR cpb_chnl_deprov_internal( cpb_handle_t *cpb_handle,
                                            UINT32 egress_mux_output_port,
                                            UINT32 egress_mux_output_port_chnl,
                                            BOOL8 super_deprov,
                                            BOOL8 backup_mode);
PRIVATE PMC_ERROR cpb_chnl_deactivate_internal( cpb_handle_t *cpb_handle,
                                                UINT32 egress_mux_output_port,
                                                UINT32 egress_mux_output_port_chnl,
                                                BOOL8 super_deprov );
PRIVATE PMC_ERROR cpb_chnl_activate_internal( cpb_handle_t *cpb_handle,
                                              UINT32 egress_mux_output_port,
                                              UINT32 egress_mux_output_port_chnl,
                                              BOOL8 super_prov );
PRIVATE PMC_ERROR cpb_chnl_switch_internal( cpb_handle_t *cpb_handle,
                                            UINT32 egress_mux_output_port,
                                            UINT32 egress_mux_output_port_chnl);
PRIVATE PMC_ERROR cpb_fifo_end_addr_cfg(cpb_handle_t *cpb_handle,
                                        UINT32 push_port_id,
                                        UINT32 queue_system_id,
                                        UINT32 write_qid,
                                        UINT32 read_qid,
                                        UINT32 end_address,
                                        BOOL8 cfg_mode,
                                        BOOL8 multicast);
PRIVATE PMC_ERROR cpb_fifo_end_addr_get(cpb_handle_t *cpb_handle,
                                        UINT32 queue_system_id,
                                        UINT32 read_qid,
                                        UINT32 *end_addr_ptr);
PRIVATE PMC_ERROR cpb_fifo_reset_cfg(cpb_handle_t *cpb_handle,
                                     UINT32 push_port_id,
                                     UINT32 queue_system_id,
                                     BOOL8 scope,
                                     UINT32 write_qid,
                                     UINT32 read_qid,
                                     UINT32 reset_value);
PRIVATE PMC_ERROR cpb_fifo_reset_rd_cfg(cpb_handle_t *cpb_handle,
                                        UINT32 queue_system_id,
                                        UINT32 read_qid,
                                        UINT32 reset_value);
PRIVATE PMC_ERROR cpb_fifo_reset_wr_cfg(cpb_handle_t *cpb_handle,
                                        UINT32 push_port_id,
                                        UINT32 queue_system_id,
                                        UINT32 write_qid,
                                        UINT32 reset_value);
PRIVATE PMC_ERROR cpb_fifo_reset_access_cfg(cpb_handle_t *cpb_handle,
                                            UINT32 queue_system_id,
                                            BOOL8 action);
PRIVATE PMC_ERROR cpb_chnl_inst_mapping( cpb_handle_t *cpb_handle,
                                         UINT32 egress_mux_input_port,
                                         UINT32 rd_channel_id,
                                         UINT32 *egress_mux_output_port,
                                         UINT32 *egress_mux_output_port_chnl );
PRIVATE PMC_ERROR cpb_chnl_prov_arg_check( cpb_handle_t *cpb_handle,
                                           UINT32 ingress_mux_input_port,
                                           UINT32 ingress_mux_input_port_chnl,
                                           UINT32 ingress_mux_egress_port,
                                           UINT32 egress_mux_input_port,
                                           UINT32 egress_mux_output_port,
                                           UINT32 egress_mux_output_port_chnl,
                                           UINT32 *wr_channel_id,
                                           UINT32 *rd_channel_id,
                                           UINT32 *wr_queue_id,
                                           UINT32 *rd_queue_id );
PRIVATE PMC_ERROR cpb_qs_current_pages_get(cpb_handle_t *cpb_handle,
                                           UINT32 push_port_id,
                                           UINT32 pop_port_id,
                                           UINT32 *num_current_pages_ptr,
                                           UINT32 *current_pages_array);
PRIVATE PMC_ERROR cpb_pmpm_queue_system_page_assign( cpb_handle_t *cpb_handle,
                                                     UINT32 push_port_id,
                                                     UINT32 pop_port_id,
                                                     UINT32 mfege_pop_port_id,
                                                     UINT32 num_pages );
PRIVATE PMC_ERROR cpb_pmpm_queue_system_page_release( cpb_handle_t *cpb_handle,
                                                      UINT32 push_port_id,
                                                      UINT32 pop_port_id );
PRIVATE PMC_ERROR cpb_current_avail_blocks_get( cpb_handle_t *cpb_handle,
                                                UINT32 num_pages,
                                                UINT32 *page_array,
                                                UINT32 *p_num_avail_blocks );
PRIVATE PMC_ERROR cpb_connect_data_set_default( cpb_handle_t *cpb_handle );
PRIVATE PMC_ERROR cpb_connect_data_add( cpb_handle_t *cpb_handle,
                                        UINT32 ingress_mux_input_port,
                                        UINT32 ingress_mux_input_port_chnl,
                                        UINT32 egress_mux_output_port,
                                        UINT32 egress_mux_output_port_chnl,
                                        UINT32 isbroadcast, UINT32 ismulticast,
                                        UINT32 dcs_inst, UINT32 rd_queue_id );
PRIVATE PMC_ERROR cpb_connect_backup_chnl_data_add( cpb_handle_t *cpb_handle,
                                                    UINT32 ingress_mux_input_port,
                                                    UINT32 ingress_mux_input_port_chnl,
                                                    UINT32 egress_mux_output_port,
                                                    UINT32 egress_mux_output_port_chnl,
                                                    UINT32 isbroadcast, UINT32 ismulticast,
                                                    UINT32 dcs_inst, UINT32 rd_queue_id );
PRIVATE PMC_ERROR cpb_connect_backup_chnl_data_delete( cpb_handle_t *cpb_handle,
                                                       UINT32 ingress_mux_input_port,
                                                       UINT32 ingress_mux_input_port_chnl);
PRIVATE PMC_ERROR cpb_chnl_source_and_type_test_recovery(cpb_handle_t *cpb_handle,
                                                         UINT32 egress_mux_output_port,
                                                         UINT32 egress_mux_output_port_chnl,
                                                         UINT32 *ingress_mux_input_port,
                                                         UINT32 *ingress_mux_input_port_chnl,
                                                         BOOL8 *is_broadcast,
                                                         BOOL8 *is_multicast);
PRIVATE PMC_ERROR cpb_chnl_source_type_and_primary_test_recovery(cpb_handle_t *cpb_handle,
                                                                 UINT32 egress_mux_output_port,
                                                                 UINT32 egress_mux_output_port_chnl,
                                                                 UINT32 *ingress_mux_input_port,
                                                                 UINT32 *ingress_mux_input_port_chnl,
                                                                 BOOL8 *is_broadcast,
                                                                 BOOL8 *is_multicast,
                                                                 BOOL8 *is_reader_primary,
                                                                 BOOL8 *is_slave_zone_primary);
PRIVATE PMC_ERROR cpb_dcs_egress_dpi_chnl_source_get_recovery( cpb_handle_t *cpb_handle,
                                                               UINT32 egress_mux_output_port,
                                                               UINT32 egress_mux_output_port_chnl,
                                                               UINT32 *p_egress_mux_input_port,
                                                               UINT32 *p_rd_channel_id,
                                                               UINT32 *p_rd_queue_id );
PRIVATE PMC_ERROR cpb_queue_build( cpb_handle_t *cpb_handle,
                                   UINT32 push_port_id,
                                   UINT32 pop_port_id,                                
                                   UINT32 write_qid,
                                   UINT32 read_qid,
                                   UINT32 num_blocks );
PRIVATE PMC_ERROR cpb_dcs_ch_and_qid_get(cpb_handle_t *cpb_handle,
                                         UINT32 dcs_inst,
                                         UINT32 egress_mux_output_port_chnl,
                                         UINT32 offset,
                                         UINT32 *p_rd_channel_id,
                                         UINT32 *p_rd_queue_id);
PRIVATE void cpb_port_burst_element_get(cpb_xfer_mode_t cpb_xfer_mode, cpb_xfer_mode_type_t *p_xfer_mode_type, cpb_burst_mode_t *p_burst_mode);
PRIVATE void cpb_var_t_ram_data_element_ptr_cfg(cpb_handle_t *cpb_handle);
PUBLIC PMC_ERROR cpb_dcs_wrr_init( cpb_handle_t *cpb_handle, UINT32 dcs_inst);
PRIVATE PMC_ERROR cpb_dcs_wrr_entry_set( cpb_handle_t *cpb_handle,
                                         UINT32 dcs_inst,
                                         UINT32 entry_offset,
                                         UINT32 c_ram_sf1,
                                         UINT32 c_ram_sf2,
                                         UINT32 c_ram_channel,
                                         UINT32 c_ram_identifier);
PRIVATE PMC_ERROR cpb_queue_num_current_blocks_get( cpb_handle_t *cpb_handle,
                                                    UINT32 wqid,
                                                    UINT32 num_pages,
                                                    UINT32 *page_array,
                                                    UINT32 *num_current_blocks_ptr);
PUBLIC PMC_ERROR cpb_var_t_reg_data_update(cpb_handle_t *cpb_handle, cpb_var_t *var_ptr);
PRIVATE PMC_ERROR cpb_var_t_ram_data_pointer_set(cpb_handle_t *cpb_handle,
                                                 void *p_backup,
                                                 UINT32 size);
PRIVATE PMC_ERROR cpb_var_t_ram_data_default_set(cpb_handle_t *cpb_handle, cpb_var_t *var_ptr);
PRIVATE PMC_ERROR cpb_queue_current_blocks_get(cpb_handle_t *cpb_handle,
                                               UINT32 wqid,
                                               UINT32 num_pages,
                                               UINT32 *page_array,
                                               UINT32 *current_blocks_array);
PRIVATE PMC_ERROR cpb_qs_empty_block_get(cpb_handle_t *cpb_handle,
                                         UINT32 push_port_id,
                                         UINT32 pop_port_id,
                                         UINT32 num_blocks,
                                         UINT32 *available_block_array);
PRIVATE PMC_ERROR cpb_queue_memory_allocate(cpb_handle_t *cpb_handle,
                                            UINT32 queue_id,
                                            UINT32 num_current_blocks,
                                            UINT32 num_blocks_requested,
                                            UINT32 *available_block_array);
PRIVATE PMC_ERROR cpb_fifo_end_addr_cal( cpb_handle_t *cpb_handle,
                                         UINT32 read_qid,
                                         UINT32 num_blocks,
                                         UINT32 *end_addr_ptr );
PRIVATE PMC_ERROR cpb_queue_memory_deallocate( cpb_handle_t *cpb_handle,
                                               UINT32 push_port_id,
                                               UINT32 write_qid,
                                               UINT32 num_current_blocks,
                                               UINT32 num_blocks_requested,
                                               UINT32 *excess_block_array );
PRIVATE void cpb_block_table_cfg( cpb_handle_t *cpb_handle,
                                  BOOL8  basic_execute,
                                  UINT32 page_index,
                                  UINT32 block_index,
                                  UINT32 block_valid,
                                  UINT32 queue_id,
                                  UINT32 lba );
PRIVATE PMC_ERROR cpb_page_table_cfg( cpb_handle_t *cpb_handle,
                                      UINT32 index,
                                      BOOL8   page_valid,
                                      UINT32 push_port_id,
                                      UINT32 pop_port_id,
                                      UINT32 mfege_pop_port_id);
PRIVATE PMC_ERROR cpb_queue_destroy( cpb_handle_t *cpb_handle,
                                     UINT32 pop_port_id,
                                     UINT32 mfege_pop_port_id,
                                     UINT32 read_qid,
                                     BOOL8 super_deprov );
PRIVATE PMC_ERROR cpb_dcs_chnl_prov( cpb_handle_t *cpb_handle, UINT32 dcs_inst,
                                     UINT32 rd_queue_id, UINT32 rd_channel_id,
                                     UINT32 wr_queue_id, UINT32 push_port_id,
                                     UINT32 rate,
                                     util_schd_chnl_rate_exp_t rate_units,
                                     BOOL8 backup_mode );
PRIVATE PMC_ERROR cpb_dcs_chnl_deprov( cpb_handle_t *cpb_handle,
                                       UINT32 dcs_inst,
                                       UINT32 rd_queue_id );
PRIVATE PMC_ERROR cpb_dcs_chnl_activate(cpb_handle_t *cpb_handle, UINT32 dcs_inst, UINT32 chnl);
PRIVATE PMC_ERROR cpb_dcs_chnl_deactivate(cpb_handle_t *cpb_handle, UINT32 dcs_inst, UINT32 chnl );
PRIVATE UINT32 cpb_dcs_page_update_and_swap(cpb_handle_t *cpb_handle, UINT32 dcs_inst);
PRIVATE PMC_ERROR cpb_dcs_page_update_and_swap_with_chnl_enbl(cpb_handle_t *cpb_handle, UINT32 dcs_inst,
                                                              BOOL8 ch_enbl_ctrl, UINT32 off_port, 
                                                              UINT32 off_chnl, UINT32 off_rd_queue_id, 
                                                              UINT32 on_port, UINT32 on_chnl, UINT32 on_rd_queue_id);
PRIVATE PMC_ERROR cpb_dcs_gen_calendar_and_write_offline_page( cpb_handle_t *cpb_handle,
                                                               UINT32 dcs_inst,
                                                               UINT32 dist_entries[],
                                                               BOOL8* is_cal_updated_ptr,
                                                               BOOL8 is_cal_chnl_updated_arr[]);
PRIVATE PMC_ERROR cpb_dcs_common_state_check( cpb_handle_t *cpb_handle,
                                              UINT32 dcs_inst,
                                              BOOL8 *match );
PRIVATE PMC_ERROR cpb_util_chnl_prov( cpb_handle_t *cpb_handle,
                                      UINT32 ingress_mux_input_port,
                                      UINT32 ingress_mux_input_port_chnl,
                                      UINT32 ingress_mux_egress_port,
                                      UINT32 egress_mux_input_port,
                                      UINT32 egress_mux_output_port,
                                      UINT32 egress_mux_output_port_chnl,
                                      UINT32 rate,
                                      util_schd_chnl_rate_exp_t rate_units,
                                      UINT32 cpb_data,
                                      UINT32 halt_buffer,
                                      UINT32 hdr_en,
                                      BOOL8 backup_mode );
PRIVATE PMC_ERROR cpb_dpi_slave_port_chnl_zone_source_get( cpb_handle_t *h,
                                                          UINT32 port,
                                                          UINT32 chnl,
                                                          UINT32 *zone_source );
PRIVATE PMC_ERROR cpb_rd_queue_id_to_dest_chnl_get( cpb_handle_t *cpb_handle,
                                                    UINT32 dcs_inst,
                                                    UINT32 rd_queue_id,
                                                    UINT32 *egress_mux_output_port,
                                                    UINT32 *egress_mux_output_port_chnl );
PRIVATE PMC_ERROR cpb_secondary_reader_chnl_deprov( cpb_handle_t *cpb_handle,
                                                    UINT32 egress_mux_output_port,
                                                    UINT32 egress_mux_output_port_chnl,
                                                    UINT32 dcs_inst,
                                                    UINT32 rd_queue_id,
                                                    BOOL8 super_deprov );
PRIVATE UINT32* cpb_mem_pool_assign(cpb_handle_t *h, UINT8 pool_id);
PRIVATE void cpb_mem_pool_release(cpb_handle_t *h, UINT8 pool_id);
PRIVATE void cpb_mem_pool_alloc(cpb_handle_t *h);
PRIVATE PMC_ERROR cpb_chnl_state_verify(cpb_handle_t *cpb_handle, UINT32 dcs_inst, UINT32 read_qid, util_schd_chnl_state_t test_state);
PRIVATE PMC_ERROR cpb_dcpb_check_output_not_provisioned(cpb_handle_t *cpb_handle,
                                                        UINT32 dcs_inst,
                                                        UINT32 read_qid,
                                                        UINT32 output_port,
                                                        UINT32 output_channel);
PRIVATE PMC_ERROR cpb_ocpb_check_output_not_provisioned(cpb_handle_t *cpb_handle,
                                                        UINT32 dcs_inst,
                                                        UINT32 read_qid,
                                                        UINT32 output_port,
                                                        UINT32 output_channel);
PRIVATE PMC_ERROR cpb_mcpb_check_output_not_provisioned(cpb_handle_t *cpb_handle,
                                                        UINT32 dcs_inst,
                                                        UINT32 read_qid,
                                                        UINT32 output_port,
                                                        UINT32 output_channel);
PRIVATE PMC_ERROR cpb_pmon_cfg(cpb_handle_t *cpb_handle,
                               UINT32 port,
                               UINT32 counter_num,
                               cpb_pmon_mode pmon_mode,
                               BOOL8 count_drop_packets,
                               BOOL8 count_err_packets,
                               BOOL8 count_oversize_packets,
                               BOOL8 count_good_packets);
PRIVATE PMC_ERROR cpb_dpi_slave_port_chnl_min_max_num_block_get(cpb_handle_t *h,
                                                                UINT32 port,
                                                                UINT32 chnl,
                                                                UINT32 *min_num_blocks,
                                                                UINT32 *max_num_blocks);
PRIVATE PMC_ERROR cpb_dcs_wrr_entry_get( cpb_handle_t *cpb_handle,
                                         UINT32 dcs_inst,
                                         UINT32 entry_offset,
                                         UINT32 *c_ram_sf1_ptr,
                                         UINT32 *c_ram_sf2_ptr,
                                         UINT32 *c_ram_channel_ptr,
                                         UINT32 *c_ram_identifier_ptr);
PRIVATE PMC_ERROR cpb_slv_dpi_qs_ch_en_get(cpb_handle_t *cpb_handle,
                                           UINT32 slv_port,
                                           UINT32 chnl,
                                           UINT32 *qs0_ch_en_ptr,
                                           UINT32 *qs1_ch_en_ptr,
                                           UINT32 *qs2_ch_en_ptr,
                                           UINT32 *qs3_ch_en_ptr);
PRIVATE PMC_ERROR cpb_slv_dpi_qs_ch_mst_get(cpb_handle_t *cpb_handle,
                                            UINT32 slv_port,
                                            UINT32 chnl,
                                            UINT32 *qs0_ch_mst_ptr,
                                            UINT32 *qs1_ch_mst_ptr,
                                            UINT32 *qs2_ch_mst_ptr,
                                            UINT32 *qs3_ch_mst_ptr);
PRIVATE PMC_ERROR cpb_slv_dpi_qs_pop_qid_get(cpb_handle_t *cpb_handle,
                                             UINT32 slv_port,
                                             UINT32 chnl,
                                             UINT32 *qs0_pop_qid_ptr,
                                             UINT32 *qs1_pop_qid_ptr,
                                             UINT32 *qs2_pop_qid_ptr,
                                             UINT32 *qs3_pop_qid_ptr);
PRIVATE PMC_ERROR cpb_dcs_enable_get( cpb_handle_t *h,
                                      UINT32 slice,
                                      BOOL8 *enable_ptr );
PRIVATE UINT32 cpb_mux_cpbd_src_sel_cfg_get(cpb_handle_t *h,
                                            UINT32 port);
PRIVATE PMC_ERROR cpb_audit_slv_dpi_register_get(cpb_handle_t *cpb_handle,
                                                 cpb_slv_data_t *slv_data_ptr);
PRIVATE PMC_ERROR cpb_audit_var_data_register_get(cpb_handle_t *h,
                                                  cpb_slv_data_t *slv_data_ptr,
                                                  BOOL8 warm_restart,
                                                  cpb_var_t *var_ptr);
PRIVATE void cpb_audit_fifo_var_data_get(cpb_handle_t *h,
                                         cpb_slv_data_t *slv_data_ptr,
                                         BOOL8 warm_restart,
                                         cpb_var_t *var_ptr);
PRIVATE PMC_ERROR cpb_audit_var_intf_state_get(cpb_handle_t *cpb_handle,
                                               cpb_slv_data_t *slv_data_ptr,
                                               cpb_var_t *var_ptr);
PRIVATE PMC_ERROR cpb_audit_ctxt_register_compare(cpb_handle_t *cpb_handle,
                                                  cpb_var_t *ctxt_var_ptr,
                                                  cpb_var_t *register_var_ptr,
                                                  BOOL8 *mismatch_page_table_ptr,
                                                  BOOL8 *mismatch_block_table_ptr,
                                                  BOOL8 *mismatch_intf_switch_ptr,
                                                  BOOL8 *mismatch_dcs_active_ptr,
                                                  BOOL8 *mismatch_dcs_calendar_ptr,
                                                  BOOL8 *mismatch_fifo_var_data_ptr);
PRIVATE BOOL8 cpb_rd_queue_id_data_get(cpb_handle_t *cpb_handle, UINT32 dcs_inst, UINT32 rd_queue_id,
                                       util_schd_chnl_state_t *chnl_state_ptr,
                                       UINT32 *egress_port_ptr, UINT32 *egress_chnl_ptr,
                                       UINT32 *rd_channel_id_ptr,
                                       UINT32 *push_port_ptr, UINT32 *wr_queue_id,
                                       UINT32 *ingress_port_ptr, UINT32 *ingress_chnl_ptr,
                                       BOOL8 *is_broadcast,
                                       BOOL8 *is_multicast,
                                       BOOL8 *is_reader_primary,
                                       BOOL8 *is_slave_zone_primary);
PRIVATE void cpb_egress_mux_port_chnl_get(cpb_handle_t *cpb_handle, UINT32 dcs_inst, UINT32 rid, UINT32 *dcs_rd_channel,
                                          UINT32 *egress_port_ptr, UINT32 *egress_chnl_ptr);
PRIVATE void cpb_mcpb_egress_mux_port_chnl_get(cpb_handle_t *cpb_handle,
                                               UINT32 dcs_inst,
                                               UINT32 rid,
                                               UINT32 *dcs_rd_channel,
                                               UINT32 *egress_port_ptr,
                                               UINT32 *egress_chnl_ptr);
PRIVATE void cpb_ingress_mux_port_chnl_get(cpb_handle_t *cpb_handle,
                                           UINT32 push_port,
                                           UINT32 wid,
                                           UINT32 *ingress_port_ptr,
                                           UINT32 *ingress_chnl_ptr);
PRIVATE void cpb_rd_queue_id_and_state_get(cpb_handle_t *cpb_handle,
                                           UINT32 push_port,
                                           UINT32 pop_port,
                                           UINT32 wid,
                                           UINT32 *rd_queue_id_ptr,
                                           util_global_chnl_state_t *output_state_ptr);

PRIVATE void cpb_mcpb_ingress_mux_port_chnl_get(cpb_handle_t *cpb_handle,
                                                UINT32 push_port,
                                                UINT32 wid,
                                                UINT32 dcs_inst,
                                                UINT32 *ingress_port_ptr,
                                                UINT32 *ingress_chnl_ptr);
PRIVATE UINT32 cpb_slave_channel_get(cpb_handle_t * cpb_handle, UINT32 push_port, UINT32 wid);
PRIVATE UINT32 cpb_slave_port_get(cpb_handle_t * cpb_handle, UINT32 push_port, UINT32 wid);
PRIVATE UINT32 cpb_master_channel_get(cpb_handle_t * cpb_handle, UINT32 master_port, UINT32 dcs_channel);
PRIVATE UINT32 cpb_master_port_get(cpb_handle_t * cpb_handle, UINT32 dcs_inst, UINT32 dcs_channel);
PRIVATE PMC_ERROR cpb_audit_ctxt_register_clean(cpb_handle_t *cpb_handle,
                                                util_global_restart_init_cfg_t *restart_init_cfg_ptr,
                                                cpb_var_t *ctxt_var_ptr,
                                                cpb_var_t *register_var_ptr,
                                                cpb_slv_data_t *slv_data_ptr,
                                                pmc_energy_state_t energy_state);
PRIVATE PMC_ERROR cpb_audit_fifo_block_clean(cpb_handle_t *cpb_handle,
                                             cpb_var_t *ctxt_var_ptr,
                                             cpb_var_t *register_var_ptr,
                                             cpb_slv_data_t *slv_data_ptr);
PRIVATE PMC_ERROR cpb_audit_block_ctxt_reg_clean(cpb_handle_t *cpb_handle,
                                                 cpb_var_t *ctxt_var_ptr,
                                                 cpb_var_t *register_var_ptr,
                                                 BOOL8 *no_valid_blocks);
PRIVATE PMC_ERROR cpb_audit_dcs_ctxt_reg_clean(cpb_handle_t *cpb_handle,
                                               cpb_var_t *ctxt_var_ptr,
                                               cpb_var_t *register_var_ptr);
PRIVATE PMC_ERROR cpb_audit_dcs_util_schd_clean(cpb_handle_t *cpb_handle,
                                                cpb_var_t *register_var_ptr);
PRIVATE PMC_ERROR cpb_audit_fifo_ctxt_reg_clean(cpb_handle_t *cpb_handle,
                                               cpb_var_t *ctxt_var_ptr,
                                               cpb_var_t *register_var_ptr);
PRIVATE PMC_ERROR cpb_audit_fifo_var_slv_ch_en_clean(cpb_handle_t *cpb_handle,
                                                     cpb_var_t *register_var_ptr,
                                                     cpb_slv_data_t *slv_data_ptr);
PRIVATE PMC_ERROR cpb_audit_slv_ch_en_fifo_var_clean(cpb_handle_t *cpb_handle,
                                                     cpb_var_t *register_var_ptr,
                                                     cpb_slv_data_t *slv_data_ptr);
PRIVATE PMC_ERROR cpb_audit_util_schd_fifo_var_clean(cpb_handle_t *cpb_handle,
                                                     cpb_var_t *register_var_ptr);
PRIVATE PMC_ERROR cpb_audit_blocks_fifo_var_clean(cpb_handle_t *cpb_handle,
                                                     cpb_var_t *register_var_ptr);
PRIVATE PMC_ERROR cpb_audit_fifo_var_util_schd_clean(cpb_handle_t *cpb_handle,
                                                     cpb_var_t *register_var_ptr);
PRIVATE void cpb_slv_port_chnl_pop_port_data_get(cpb_handle_t *h,
                                                 UINT32 slave_port,
                                                 UINT32 slave_chnl,
                                                 UINT32 *pop_port_ptr,
                                                 UINT32 *pop_rd_qid_ptr);
#ifndef CPB_UNIT_TEST
PRIVATE PMC_ERROR cpb_fw_slv_dpi_qs_ch_en_get(cpb_handle_t *cpb_handle,
                                              UINT32          slv_port,
                                              UINT32         slv_chnl,
                                              cpb_slv_data_t *slv_data_ptr);
PRIVATE PMC_ERROR cpb_fw_slv_dpi_qs_ch_en_clear(cpb_handle_t *cpb_handle,
                                                UINT32 slv_port,
                                                UINT32 slv_chnl,
                                                UINT32 queue_system);
#endif /* CPB_UNIT_TEST */
PRIVATE PMC_ERROR cpb_pmpm_usage_summary_get(cpb_handle_t *cpb_handle,
                                            cpb_pmpm_use_summary_t *page_summary);
PRIVATE PMC_ERROR cpb_queue_relative_resize(cpb_handle_t *cpb_handle,
                                            UINT32 pop_port_id,
                                            UINT32 read_qid,
                                            BOOL8  page_management_en,
                                            UINT32 increase_blocks,
                                            UINT32 decrease_blocks);
PRIVATE void cpb_port_pair_block_use_array_clean(cpb_handle_t *cpb_handle,
                                                 UINT32 *port_pair_block_use);
PRIVATE BOOL cpb_page_indexes_to_consolidate(cpb_handle_t *cpb_handle,
                                             UINT32 *port_pair_block_use,
                                             UINT32 *page_with_space_mask,
                                             UINT32 *page_with_least_entries);
PRIVATE PMC_ERROR cpb_remap_block_cfg(cpb_handle_t *cpb_handle,
                                      UINT32 old_page_addr,
                                      UINT32 old_block_addr,
                                      UINT32 new_page_addr,
                                      UINT32 new_block_addr);
PRIVATE PMC_ERROR cpb_remap_req_poll_success(cpb_handle_t *cpb_handle);
PRIVATE PMC_ERROR cpb_remap_block_abort(cpb_handle_t *cpb_handle);
PRIVATE PMC_ERROR cpb_db_empty_rec_get(cpb_handle_t *cpb_handle,
                                       UINT32 num_cal_entries,
                                       util_gen_db_id_t db_id,
                                       UINT32 db_handle,
                                       UINT32 *available_rec_array);
PRIVATE cpb_fifo_status_t cpb_fifo_var_data_status_get(cpb_handle_t * cpb_handle,
                                                       UINT32 dcs_inst,
                                                       UINT32 read_id);
PRIVATE UINT32 cpb_fifo_var_data_queue_index_get(cpb_handle_t *cpb_handle,
                                                 UINT32        egress_mux_input_port,
                                                 UINT32        rd_queue_id);
PRIVATE void cpb_connect_data_state_get_recovery(cpb_handle_t *cpb_handle, 
                                                 util_global_restart_init_cfg_t *restart_init_cfg_ptr,
                                                 cpb_slv_data_t * slv_data_ptr,
                                                 util_global_cpb_connect_t *conn_ptr);
#ifndef DOXYGEN_PUBLIC_ONLY
#ifdef CPB_BLOCK_LIST
PUBLIC PMC_ERROR cpb_queue_block_check(cpb_handle_t *cpb_handle);
PUBLIC PMC_ERROR cpb_queue_block_dump(cpb_handle_t *cpb_handle);
#endif
#endif

/*
 *  Exported Interface Functions - Start
 */
/*******************************************************************************
* cpb_ctxt_create
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Creates and initializes a handle for an CPB block instance.
*
*
* INPUTS:
*   *parent               - pointer to parent handle.  If no parent pass in
*                           NULL
*   base_address          - base address of the CPB subsystem relative to
*                           the device memory space
*   *sys_handle           - pointer to user system handle
*   *tsb_name             - string name for tsb
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   cpb_handle_t       - pointer to created handle
*
* NOTES:
*
*******************************************************************************/
PUBLIC cpb_handle_t *cpb_ctxt_create(pmc_handle_t *parent, UINT32 base_address, pmc_sys_handle_t *sys_handle, const char *tsb_name)
{
    cpb_handle_t *cpb_handle;

    PMC_ENTRY();

#ifdef USE_PMC_CTXT_CALLOC
        if (parent == NULL) {
            void *c = NULL;
            c = pmc_ctxt_mem_create(sys_handle, FALSE);
            pmc_ctxt_mem_init(c);
            cpb_handle = (cpb_handle_t*)(((pmc_ctxt_mgmt_ctxt_t*)c)->header.digi_hdl);
            cpb_handle->base.ctxt = c;
            cpb_handle = (cpb_handle_t*)PMC_CTXT_CALLOC(sizeof(cpb_handle_t), cpb_handle);
        } else {
            cpb_handle = (cpb_handle_t*)PMC_CTXT_CALLOC(sizeof(cpb_handle_t), parent);
        };
#else
        cpb_handle = (cpb_handle_t*)PMC_CTXT_CALLOC(sizeof(cpb_handle_t), parent);
#endif

    pmc_handle_init(parent, cpb_handle, sys_handle, PMC_MID_DIGI_CPB, tsb_name, base_address);


    /* Register log strings. */
    pmc_log_block_strings_register(CPB_LOG_ERR_STRINGS[0], CPB_LOG_ERR_TABLE_BASE, CPB_LOG_ERR_COUNT);

    cpb_handle->util_schd_handle[0] = util_schd_ctxt_create((pmc_handle_t*)cpb_handle, base_address, sys_handle, "UTIL_SCHD_0");
    PMC_CTXT_REGISTER_PTR(&cpb_handle->util_schd_handle[0], cpb_handle);
    cpb_handle->util_schd_handle[1] = util_schd_ctxt_create((pmc_handle_t*)cpb_handle, base_address, sys_handle, "UTIL_SCHD_1");
    PMC_CTXT_REGISTER_PTR(&cpb_handle->util_schd_handle[1], cpb_handle);
    cpb_handle->util_schd_handle[2] = util_schd_ctxt_create((pmc_handle_t*)cpb_handle, base_address, sys_handle, "UTIL_SCHD_2");
    PMC_CTXT_REGISTER_PTR(&cpb_handle->util_schd_handle[2], cpb_handle);
    cpb_handle->util_schd_handle[3] = util_schd_ctxt_create((pmc_handle_t*)cpb_handle, base_address, sys_handle, "UTIL_SCHD_3");
    PMC_CTXT_REGISTER_PTR(&cpb_handle->util_schd_handle[3], cpb_handle);

    /* Enable cache so that RMW operations become W operations */

    PMC_RETURN(cpb_handle);
} /* cpb_ctxt_create */


/*******************************************************************************
* cpb_ctxt_destroy
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Destroys a handle for an CPB block instance.
*
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_ctxt_destroy(cpb_handle_t *cpb_handle)
{
    UINT32 i;
    PMC_ERROR ret_val;
    PMC_ENTRY();

    pmc_handle_mid_verify(cpb_handle, PMC_MID_DIGI_CPB);

    cpb_handle->base.tsb_mid = PMC_MID_INVALID;

    PMC_CTXT_FREE(&(cpb_handle->var.block_inverted_page_table), cpb_handle);
    PMC_CTXT_FREE(&(cpb_handle->var.page_inverted_page_table), cpb_handle);
    PMC_FREE(&(cpb_handle->var.cpb_mem_pool[0]));
    PMC_FREE(&(cpb_handle->var.cpb_mem_pool[1]));
    PMC_FREE(&(cpb_handle->var.cpb_mem_pool[2]));
    PMC_FREE(&(cpb_handle->var.cpb_mem_pool[3]));
    PMC_CTXT_FREE(&(cpb_handle->var.p_var_t_ram_data), cpb_handle);

    for(i = 0; i < cpb_handle->cfg.num_dcs; i++)
    {
        util_schd_ctxt_destroy(cpb_handle->util_schd_handle[i]);

        if(cpb_handle->cfg.dcs_use_ctxt[i].alloc_mode == UTIL_SCHD_ALLOC_METHOD_CPB_DCS)
        {
            ret_val = gen_db_detach(&(cpb_handle->base),
                                    cpb_handle->cfg.dcs_use_ctxt[i].db_id,
                                    cpb_handle->cfg.dcs_use_ctxt[i].db_client_handle);
            PMC_ASSERT(ret_val == 0, CPB_ERR_DB_ATTACH_FAIL, 0, 0);
        }

    }

    if (cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB) {
        PMC_FREE(&(cpb_handle->var.cpb_connect_data));
    }

    PMC_CTXT_FREE(&cpb_handle, cpb_handle);
    PMC_RETURN();
} /* cpb_ctxt_destroy */

/*******************************************************************************
* cpb_handle_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Initializes an CPB block handle instance.
*
*
* INPUTS:
*   *cpb_handle         - pointer to CPB handle instance
*   cpb_type            - Enum defining CPB instantiation type
*   schd_populate_mode  - Array of enum defining DCS scheduler generation mode.
*                         Array index is DCS instance number.
*   parent_energy_state - parent energy state applied to subsystem from higher
*                         level
*   *p_var_t_ram_data   - Pointer to backup memory for warm restart bring up, if
*                         non warm restart, set to NULL.
*   var_t_ram_data_size - Size of backup memory if present.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_handle_init( cpb_handle_t *cpb_handle,
                             cpb_instance_type_t cpb_type,
                             cpb_schd_populate_t schd_populate_mode[4],
                             pmc_block_energy_state_enum parent_energy_state,
                             void *p_var_t_ram_data,
                             UINT32 var_t_ram_data_size )
{
    util_schd_block_const_ctxt_t const_ctxt;
    UINT32 size;
    UINT32 i;
    PMC_ENTRY();

    cpb_handle->cfg.cpb_type = cpb_type;

    /* confirm that elements of schd_populate_mode[] are valid settings */
    for (i = 0; i < NUM_OF_DCS; i++)
    {
        PMC_ASSERT( schd_populate_mode[i] < LAST_CPB_SCHD_POPULATE, CPB_ERR_INVALID_ARG, 0 , 0);
    }
    /* confirm cpb_type is valid */
    PMC_ASSERT(cpb_type < LAST_CPB_INSTANCE, CPB_ERR_INVALID_ARG, 0 , 0);


    const_ctxt.base_chnl_num = 0;
    const_ctxt.num_schd_chnl = CPB_NUM_SCHED_ENTRIES;  /* number of unique qids available for scheduling */
    const_ctxt.chnl_num_step = 1;
    const_ctxt.num_schd_grp = 1;

    const_ctxt.max_entries = CPB_NUM_SCHED_ENTRIES;  /*number of calendar entries for each dcs */
    const_ctxt.entry_null_value = CPB_NULL_CHANNEL_ENTRY;
    const_ctxt.total_rate = DCPB_TOTAL_RATE_GBPS;

    const_ctxt.total_rate_units = UTIL_SCHD_1G_BIT_SEC;
    const_ctxt.cal_entries_alloc_method = UTIL_SCHD_ALLOC_METHOD_GENERAL_LOCAL;

    /* Process the schd_populate_mode argument */
    PMC_MEMSET(cpb_handle->cfg.dcs_use_ctxt, 0, sizeof(dcs_use_ctxt_t) * 4);
    if ( CPB_INSTANCE_DCPB == cpb_type )
    {
        cpb_handle->cfg.dcs_use_ctxt[0].db_id = UTIL_GEN_DB_DCPB_DCS_0;
        cpb_handle->cfg.dcs_use_ctxt[1].db_id = UTIL_GEN_DB_DCPB_DCS_1;
        cpb_handle->cfg.dcs_use_ctxt[2].db_id = UTIL_GEN_DB_DCPB_DCS_2;
        cpb_handle->cfg.dcs_use_ctxt[3].db_id = UTIL_GEN_DB_DCPB_DCS_3;

    }
    else if ( CPB_INSTANCE_OCPB == cpb_type )
    {

        cpb_handle->cfg.dcs_use_ctxt[0].db_id = UTIL_GEN_DB_OCPB_DCS_0;
        cpb_handle->cfg.dcs_use_ctxt[1].db_id = UTIL_GEN_DB_OCPB_DCS_1;
        cpb_handle->cfg.dcs_use_ctxt[2].db_id = UTIL_GEN_DB_OCPB_DCS_2;
        cpb_handle->cfg.dcs_use_ctxt[3].db_id = UTIL_GEN_DB_OCPB_DCS_3;

    }
    else
    {
        cpb_handle->cfg.dcs_use_ctxt[0].db_id = LAST_UTIL_GEN_DB;
        cpb_handle->cfg.dcs_use_ctxt[1].db_id = LAST_UTIL_GEN_DB;
        cpb_handle->cfg.dcs_use_ctxt[2].db_id = LAST_UTIL_GEN_DB;
        cpb_handle->cfg.dcs_use_ctxt[3].db_id = LAST_UTIL_GEN_DB;

    }

    for (i = 0; i < NUM_OF_DCS; i++)
    {
        if(CPB_SCHD_POPULATE_LOCAL == schd_populate_mode[i])
        {
            cpb_handle->cfg.dcs_use_ctxt[i].alloc_mode = UTIL_SCHD_ALLOC_METHOD_GENERAL_LOCAL;
        }
        else if(CPB_SCHD_POPULATE_DB == schd_populate_mode[i])
        {
            cpb_handle->cfg.dcs_use_ctxt[i].alloc_mode = UTIL_SCHD_ALLOC_METHOD_CPB_DCS;
            /* only proceed if the cpb_type is DCPB or OCPB */
            if( CPB_INSTANCE_DCPB != cpb_type && CPB_INSTANCE_OCPB != cpb_type )
            {
                PMC_ASSERT(TRUE, CPB_ERR_INVALID_ARG, 0, 0);
            }

        } else {
            /* unspecified case */
            PMC_ASSERT(FALSE,CPB_ERR_INVALID_DB_MODE,0,0);

        }
    }


    switch(cpb_type)
    {
        case CPB_INSTANCE_DCPB:
            cpb_handle->cfg.num_pages =  DCPB_NUM_PAGES;
            cpb_handle->cfg.blocks_per_page = DCPB_BLOCKS_PER_PAGE;
            cpb_handle->cfg.block_size = DCPB_BLOCK_SIZE;  /* DCPB_BLOCK_SIZE */
            cpb_handle->cfg.mtu_size = DCPB_MTU_SIZE;
            cpb_handle->cfg.max_dpi_mst_chnl_id[0] = DCPB_MAX_CHANNEL_PORT0; /* DCPB_SIFD_MAX_MST_CHNL_ID DCPB_<PORT_NAME_>_MST_MAX_CHNL_ID */
            cpb_handle->cfg.max_dpi_mst_chnl_id[1] = DCPB_MAX_CHANNEL_PORT1;
            cpb_handle->cfg.max_dpi_mst_chnl_id[2] = DCPB_MAX_CHANNEL_PORT2;
            cpb_handle->cfg.max_dpi_mst_chnl_id[3] = DCPB_MAX_CHANNEL_PORT3;
            cpb_handle->cfg.max_dpi_mst_chnl_id[4] = DCPB_MAX_CHANNEL_PORT4;
            cpb_handle->cfg.max_dpi_mst_chnl_id[5] = DCPB_MAX_CHANNEL_PORT5;
            cpb_handle->cfg.max_dpi_slv_chnl_id[0] = DCPB_MAX_CHANNEL_PORT0; /* DCPB_<PORT_NAME_>_MAX_SLV_CHNL_ID */
            cpb_handle->cfg.max_dpi_slv_chnl_id[1] = DCPB_MAX_CHANNEL_PORT1;
            cpb_handle->cfg.max_dpi_slv_chnl_id[2] = DCPB_MAX_CHANNEL_PORT2;
            cpb_handle->cfg.max_dpi_slv_chnl_id[3] = DCPB_MAX_CHANNEL_PORT3;
            cpb_handle->cfg.max_dpi_slv_chnl_id[4] = DCPB_MAX_CHANNEL_PORT4;
            cpb_handle->cfg.max_dpi_slv_chnl_id[5] = DCPB_MAX_CHANNEL_PORT5;
            cpb_handle->cfg.max_slv_dpi_port = DCPB_MAX_DPI_PORT; /* DCPB_MAX_SLV_PORTS */
            cpb_handle->cfg.max_mst_dpi_port = DCPB_MAX_DPI_PORT; /* DCPB_MAX_MST_PORTS */
            cpb_handle->cfg.push_port_num = DCPB_NUM_PUSH_PORTS; /* DCPB_PUSH_PORT_NUM */
            cpb_handle->cfg.pop_port_num = DCPB_NUM_QUEUE_SYSTEMS; /* DCPB_POP_PORT_NUM */
            cpb_handle->cfg.num_queue_systems = DCPB_NUM_QUEUE_SYSTEMS;
            cpb_handle->cfg.num_dcs = DCPB_NUM_QUEUE_SYSTEMS; /* DCPB_NUM_DCS */
            break;
        case CPB_INSTANCE_OCPB:
            cpb_handle->cfg.num_pages =  OCPB_NUM_PAGES;
            cpb_handle->cfg.blocks_per_page = OCPB_BLOCKS_PER_PAGE;
            cpb_handle->cfg.block_size = OCPB_BLOCK_SIZE;
            cpb_handle->cfg.mtu_size = OCPB_MTU_SIZE;
            cpb_handle->cfg.max_dpi_slv_chnl_id[0] = OCPB_MAX_CHANNEL_PORT0;
            cpb_handle->cfg.max_dpi_slv_chnl_id[1] = OCPB_MAX_CHANNEL_PORT1;
            cpb_handle->cfg.max_dpi_slv_chnl_id[2] = OCPB_MAX_CHANNEL_PORT2;
            cpb_handle->cfg.max_dpi_slv_chnl_id[3] = OCPB_MAX_CHANNEL_PORT3;
            cpb_handle->cfg.max_dpi_mst_chnl_id[0] = OCPB_MAX_CHANNEL_PORT0;
            cpb_handle->cfg.max_dpi_mst_chnl_id[1] = OCPB_MAX_CHANNEL_PORT1;
            cpb_handle->cfg.max_dpi_mst_chnl_id[2] = OCPB_MAX_CHANNEL_PORT2;
            cpb_handle->cfg.max_dpi_mst_chnl_id[3] = OCPB_MAX_CHANNEL_PORT3;
            cpb_handle->cfg.max_slv_dpi_port = OCPB_MAX_DPI_PORT;
            cpb_handle->cfg.max_mst_dpi_port = OCPB_MAX_DPI_PORT;
            cpb_handle->cfg.push_port_num = OCPB_NUM_PUSH_PORTS;
            cpb_handle->cfg.pop_port_num = OCPB_NUM_QUEUE_SYSTEMS;
            cpb_handle->cfg.num_queue_systems = OCPB_NUM_QUEUE_SYSTEMS;
            cpb_handle->cfg.num_dcs = OCPB_NUM_QUEUE_SYSTEMS;
            break;
        case CPB_INSTANCE_MCPB:
            cpb_handle->cfg.num_pages =  MCPB_NUM_PAGES;
            cpb_handle->cfg.blocks_per_page = MCPB_BLOCKS_PER_PAGE;
            cpb_handle->cfg.block_size = MCPB_BLOCK_SIZE;
            cpb_handle->cfg.mtu_size = MCPB_MTU_SIZE;
            cpb_handle->cfg.max_dpi_slv_chnl_id[0] = MCPB_MAX_SLAVE_CHANNEL_PORT0;
            cpb_handle->cfg.max_dpi_slv_chnl_id[1] = MCPB_MAX_SLAVE_CHANNEL_PORT1;
            cpb_handle->cfg.max_dpi_slv_chnl_id[2] = MCPB_MAX_SLAVE_CHANNEL_PORT2;
            cpb_handle->cfg.max_dpi_slv_chnl_id[3] = MCPB_MAX_SLAVE_CHANNEL_PORT3;
            cpb_handle->cfg.max_dpi_slv_chnl_id[4] = MCPB_MAX_SLAVE_CHANNEL_PORT4;
            cpb_handle->cfg.max_dpi_slv_chnl_id[5] = MCPB_MAX_SLAVE_CHANNEL_PORT5;
            cpb_handle->cfg.max_dpi_slv_chnl_id[6] = MCPB_MAX_SLAVE_CHANNEL_PORT6;
            cpb_handle->cfg.max_dpi_slv_chnl_id[7] = MCPB_MAX_SLAVE_CHANNEL_PORT7;
            cpb_handle->cfg.max_dpi_mst_chnl_id[0] = MCPB_MAX_MASTER_CHANNEL_PORT0;
            cpb_handle->cfg.max_dpi_mst_chnl_id[1] = MCPB_MAX_MASTER_CHANNEL_PORT1;
            cpb_handle->cfg.max_dpi_mst_chnl_id[2] = MCPB_MAX_MASTER_CHANNEL_PORT2;
            cpb_handle->cfg.max_dpi_mst_chnl_id[3] = MCPB_MAX_MASTER_CHANNEL_PORT3;
            cpb_handle->cfg.max_dpi_mst_chnl_id[4] = MCPB_MAX_MASTER_CHANNEL_PORT4;
            cpb_handle->cfg.max_dpi_mst_chnl_id[5] = MCPB_MAX_MASTER_CHANNEL_PORT5;
            cpb_handle->cfg.max_slv_dpi_port = MCPB_MAX_SLAVE_DPI_PORT;
            cpb_handle->cfg.max_mst_dpi_port = MCPB_MAX_MASTER_DPI_PORT;
            cpb_handle->cfg.push_port_num = MCPB_NUM_PUSH_PORTS;
            cpb_handle->cfg.pop_port_num = MCPB_NUM_POP_PORTS;
            cpb_handle->cfg.num_queue_systems = MCPB_NUM_QUEUE_SYSTEMS;
            cpb_handle->cfg.num_dcs = MCPB_NUM_QUEUE_SYSTEMS;
            break;
        default:
            PMC_ASSERT(FALSE,CPB_ERR_INVALID_ARG,0,0);
    }

    cpb_handle->cfg.bursts_per_block = cpb_handle->cfg.block_size / CPB_BUS_WIDTH_BYTES;
    cpb_handle->cfg.max_fifo_num = CPB_MAX_FIFO_NUM;

    cpb_handle->cfg.num_calendar_entries = CPB_NUM_SCHED_ENTRIES;
    cpb_handle->cfg.page_size = cpb_handle->cfg.blocks_per_page * cpb_handle->cfg.block_size;
    cpb_handle->cfg.fifo_null_entry = (cpb_handle->cfg.max_fifo_num)*2;
    cpb_handle->cfg.bus_width = CPB_BUS_WIDTH_BYTES*8;
    cpb_handle->cfg.page_null_entry = cpb_handle->cfg.num_pages*2;

    cpb_handle->var.page_inverted_page_table =
    (page_inverted_page_table_t*)PMC_CTXT_CALLOC((cpb_handle->cfg.num_pages)*sizeof(page_inverted_page_table_t), cpb_handle);
    PMC_ASSERT(cpb_handle->var.page_inverted_page_table != NULL, CPB_ERR_CODE_ASSERT, 0 , 0);
    PMC_CTXT_REGISTER_PTR(&cpb_handle->var.page_inverted_page_table, cpb_handle);
    cpb_handle->var.block_inverted_page_table =
    (block_inverted_page_table_t*)PMC_CTXT_CALLOC(cpb_handle->cfg.num_pages*cpb_handle->cfg.blocks_per_page*sizeof(block_inverted_page_table_t), cpb_handle);
    PMC_ASSERT(cpb_handle->var.block_inverted_page_table != NULL, CPB_ERR_CODE_ASSERT, 0 , 0);
    PMC_CTXT_REGISTER_PTR(&cpb_handle->var.block_inverted_page_table, cpb_handle);

    /* Allocate Memory for Usage by Functions to Avoid Excess Stack Data */
    cpb_mem_pool_alloc(cpb_handle);

    /* Initialize the flags for Memory Usage by Functions to Avoid Excess Stack Data */
    cpb_handle->var.cpb_mem_pool_in_use[0] = FALSE;
    cpb_handle->var.cpb_mem_pool_in_use[1] = FALSE;
    cpb_handle->var.cpb_mem_pool_in_use[2] = FALSE;
    cpb_handle->var.cpb_mem_pool_in_use[3] = FALSE;
    cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE;

    if (cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB) {
        cpb_handle->var.cpb_connect_data =
            (util_global_cpb_connect_t *)PMC_CALLOC(sizeof(util_global_cpb_connect_t));
        PMC_ASSERT(cpb_handle->var.cpb_connect_data != NULL, CPB_ERR_CODE_ASSERT, 0 , 0);
        cpb_connect_data_set_default(cpb_handle);
    }

    /* initialize parent_energy_state */
    cpb_handle->var.parent_energy_state = parent_energy_state;


    /* for var_t ram data initalization, use passed in data or freshly create */
    size = cpb_handle->cfg.num_queue_systems*cpb_handle->cfg.max_fifo_num*sizeof(cpb_fifo_var_t) +
           cpb_handle->cfg.num_calendar_entries * cpb_handle->cfg.num_dcs * sizeof(util_schd_dcs_calendar_entry_t) +
           cpb_handle->cfg.num_calendar_entries * cpb_handle->cfg.num_dcs * sizeof(util_schd_dcs_calendar_entry_t) +
           cpb_handle->cfg.num_calendar_entries * sizeof(util_schd_dcs_calendar_entry_t); /* 1 extra temp calendar for copying */

    if (NULL != p_var_t_ram_data) /* use passed in data */
    {
        PMC_ASSERT(var_t_ram_data_size == size,CPB_ERR_INVALID_VAR_T_RAM_DATA_SIZE,0,0);
        cpb_var_t_ram_data_pointer_set(cpb_handle, p_var_t_ram_data, var_t_ram_data_size);
        cpb_var_t_ram_data_element_ptr_cfg(cpb_handle);
    } else { /* freshly create */

        cpb_handle->var.p_var_t_ram_data = PMC_CTXT_CALLOC(size, cpb_handle);
        PMC_CTXT_REGISTER_PTR(&cpb_handle->var.p_var_t_ram_data, cpb_handle);

        cpb_handle->var.var_t_ram_data_size = size;
        cpb_var_t_ram_data_element_ptr_cfg(cpb_handle);

        cpb_var_t_ram_data_default_set(cpb_handle, &(cpb_handle->var));

    }

    cpb_var_t_reg_data_update(cpb_handle, &(cpb_handle->var));

    /* call *_handle_init for child modules */
    /* update to a for loop */
    for(i = 0;i < cpb_handle->cfg.num_dcs; i++)
    {
        if(CPB_INSTANCE_MCPB == cpb_type)
        {/* number of unique qids and number of calendar entries */
            switch(i)
            {
             case 0:
             case 1:
                const_ctxt.num_schd_chnl = MCPB_NUM_SCHED_CHANS_DCS0_1;
                const_ctxt.max_entries = MCPB_MAX_SCHED_ENTRIES_DCS0_1;
                const_ctxt.total_rate = MCPB_TOTAL_RATE_ENET_GBPS;
                const_ctxt.total_rate_units = UTIL_SCHD_1G_BIT_SEC;
                break;
             case 2:
                const_ctxt.num_schd_chnl = MCPB_NUM_SCHED_CHANS_DCS2;
                const_ctxt.max_entries = MCPB_MAX_SCHED_ENTRIES_DCS2;
                const_ctxt.total_rate = MCPB_TOTAL_RATE_DCS2_GBPS;
                const_ctxt.total_rate_units = UTIL_SCHD_1G_BIT_SEC;
                break;
             case 3:
                const_ctxt.num_schd_chnl = MCPB_NUM_SCHED_CHANS_DCS3;
                const_ctxt.max_entries = MCPB_MAX_SCHED_ENTRIES_DCS3;
                const_ctxt.total_rate = MCPB_TOTAL_RATE_DCS3_GBPS;
                const_ctxt.total_rate_units = UTIL_SCHD_1G_BIT_SEC;
                break;
             default:
                PMC_ASSERT(FALSE,CPB_ERR_INVALID_ARG,0,0);
            }
        }


        /* set the cal_entries_alloc_method and db_id as a function of
            schd_populate_mode determined earlier */
        const_ctxt.cal_entries_alloc_method = cpb_handle->cfg.dcs_use_ctxt[i].alloc_mode;
        const_ctxt.db_id = cpb_handle->cfg.dcs_use_ctxt[i].db_id;
        const_ctxt.max_dcs_rd_channel_id = cpb_handle->cfg.num_calendar_entries * cpb_handle->cfg.num_dcs;

        if(CPB_SCHD_POPULATE_DB == schd_populate_mode[i])
        {
            cpb_handle->cfg.dcs_use_ctxt[i].db_client_handle = gen_db_attach(&(cpb_handle->base),cpb_handle->cfg.dcs_use_ctxt[i].db_id);
            PMC_ASSERT(cpb_handle->cfg.dcs_use_ctxt[i].db_client_handle != 0, CPB_ERR_DB_ATTACH_FAIL, 0, 0);  /* failure if data base attach failed */

        }


        util_schd_handle_init(cpb_handle->util_schd_handle[i], &const_ctxt);
    }


    cpb_handle->cfg.sysotn_mode = FALSE;

    cpb_handle->var.block_leak.leak_exists = FALSE;
    cpb_handle->var.block_leak.pop_port = CPB_INVALID_REMAP_VALUE;
    cpb_handle->var.block_leak.rid = CPB_INVALID_REMAP_VALUE;


    PMC_RETURN();

} /* cpb_handle_init */

/*******************************************************************************
* cpb_alloc_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*  Handles the allocation of the CPB memory pools as part of the restart
*  procedure
*
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_alloc_init(cpb_handle_t *cpb_handle)
{
    UINT32 i;

    PMC_ENTRY();

    for(i = 0; i < cpb_handle->cfg.num_dcs; i++)
    {
        util_schd_alloc_init(cpb_handle->util_schd_handle[i]);
    }
    cpb_mem_pool_alloc(cpb_handle);

    if (cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB) {
        cpb_handle->var.cpb_connect_data =
            (util_global_cpb_connect_t *)PMC_CALLOC(sizeof(util_global_cpb_connect_t));
        PMC_ASSERT(cpb_handle->var.cpb_connect_data != NULL, CPB_ERR_CODE_ASSERT, 0 , 0);
        cpb_connect_data_set_default(cpb_handle);
    }

    PMC_RETURN();
} /* cpb_alloc_init */

/*******************************************************************************
* cpb_handle_restart_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*
*   Performs warm or crash restart processing on CPB SS handle instance.
*
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance
*   *restart_init_cfg_ptr       - pointer to restart init config
*   energy_state                - energy state of the block relative to parent.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_handle_restart_init(cpb_handle_t *cpb_handle,
                                         util_global_restart_init_cfg_t *restart_init_cfg_ptr,
                                         pmc_energy_state_t energy_state)
{
    UINT32 i, size;
    util_schd_dcs_calendar_entry_t * ptr = NULL;
    cpb_var_t * register_var = NULL;
    cpb_slv_data_t * slv_data_ptr = NULL;

    cpb_full_path_t * context_channel_state = NULL;
    cpb_full_path_t * device_channel_state = NULL;

    UINT32 num_master_ports = cpb_handle->cfg.max_mst_dpi_port+1;
    UINT32 num_master_channels = cpb_handle->cfg.max_dpi_mst_chnl_id[0]+1;

    BOOL8 mismatch_page_table    = TRUE;
    BOOL8 mismatch_block_table   = TRUE;
    BOOL8 mismatch_intf_switch   = TRUE;
    BOOL8 mismatch_dcs_active    = TRUE;
    BOOL8 mismatch_dcs_calendar  = TRUE;
    BOOL8 mismatch_fifo_var_data = TRUE;


    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

   
    if (restart_init_cfg_ptr->phase == UTIL_GLOBAL_RESTART_INIT_PHASE_FIRST)
    {
        pmc_log_block_strings_register(CPB_LOG_ERR_STRINGS[0], CPB_LOG_ERR_TABLE_BASE, CPB_LOG_ERR_COUNT);
    }
    
    /* memory allocation for register based context generation */
    register_var = (cpb_var_t*)PMC_CALLOC(sizeof(cpb_var_t));
    PMC_ASSERT(register_var != NULL, CPB_ERR_CODE_ASSERT, 0 , 0);

    register_var->page_inverted_page_table =
    (page_inverted_page_table_t*)PMC_CALLOC((cpb_handle->cfg.num_pages)*sizeof(page_inverted_page_table_t));
    PMC_ASSERT(register_var->page_inverted_page_table != NULL, CPB_ERR_CODE_ASSERT, 0 , 0);

    register_var->block_inverted_page_table =
    (block_inverted_page_table_t*)PMC_CALLOC(cpb_handle->cfg.num_pages*cpb_handle->cfg.blocks_per_page*sizeof(block_inverted_page_table_t));
    PMC_ASSERT(register_var->block_inverted_page_table != NULL, CPB_ERR_CODE_ASSERT, 0 , 0);


    size = cpb_handle->cfg.num_queue_systems*cpb_handle->cfg.max_fifo_num*sizeof(cpb_fifo_var_t) +
           cpb_handle->cfg.num_calendar_entries * cpb_handle->cfg.num_dcs * sizeof(util_schd_dcs_calendar_entry_t) +
           cpb_handle->cfg.num_calendar_entries * cpb_handle->cfg.num_dcs * sizeof(util_schd_dcs_calendar_entry_t);

    register_var->p_var_t_ram_data = PMC_CALLOC(size);
    PMC_ASSERT(register_var->p_var_t_ram_data != NULL, CPB_ERR_CODE_ASSERT, 0 , 0);

    register_var->fifo_var_data = (cpb_fifo_var_t *)(register_var->p_var_t_ram_data);

    slv_data_ptr = (cpb_slv_data_t*)PMC_CALLOC(sizeof(cpb_slv_data_t));
    PMC_ASSERT(slv_data_ptr != NULL, CPB_ERR_CODE_ASSERT, 0 , 0);

    ptr = (util_schd_dcs_calendar_entry_t *)(register_var->fifo_var_data + cpb_handle->cfg.num_queue_systems*cpb_handle->cfg.max_fifo_num);
    for(i = 0;i < cpb_handle->cfg.num_dcs; i++)
    {
        register_var->dcs_offline_calendars[i] = ptr;
        ptr = ptr + cpb_handle->cfg.num_calendar_entries;
    }
    for(i = 0;i < cpb_handle->cfg.num_dcs; i++)
    {
        register_var->dcs_online_calendars[i] = ptr;
        ptr = ptr + cpb_handle->cfg.num_calendar_entries;
    }

    /* memory allocation for tracking coherency state */
    context_channel_state = (cpb_full_path_t *) PMC_CALLOC(num_master_ports*num_master_channels*sizeof(cpb_full_path_t));
    PMC_ASSERT(context_channel_state != NULL, CPB_ERR_CODE_ASSERT, 0 , 0);
    device_channel_state = (cpb_full_path_t *) PMC_CALLOC(num_master_ports*num_master_channels*sizeof(cpb_full_path_t));
    PMC_ASSERT(device_channel_state != NULL, CPB_ERR_CODE_ASSERT, 0 , 0);

    if(pmc_cpb_pmpm_block_remap(&cpb_handle->base) && energy_state != PMC_ENERGY_STATE_RESET)
    {
        cpb_remap_block_abort(cpb_handle);
    }

    /* child block *_handle_restart_init() calls */
    for(i = 0; i < cpb_handle->cfg.num_dcs; i++)
    {
        if(result == PMC_SUCCESS)
            result = util_schd_handle_restart_init(cpb_handle->util_schd_handle[i],
                                               cpb_handle->cfg.dcs_use_ctxt[i].db_id,
                                               restart_init_cfg_ptr, energy_state,FALSE);
    }

    /* Test to see if the block matches the digi layer lowpwr and reset bit states.
       If DIGI thinks the CPB is in reset and it is not in start state, then we need
       to provide an error for warm restart.*/
    if(restart_init_cfg_ptr->is_warm_restart && energy_state == PMC_ENERGY_STATE_RESET && result == PMC_SUCCESS)
    {
        /* Confirm block cotext in starting state */
        if(cpb_start_state_test(cpb_handle) == FALSE)
        {
            result = CPB_ERR_CONTEXT_INCOHERENT;
        }
    }
    else if (restart_init_cfg_ptr->is_warm_restart == FALSE && energy_state == PMC_ENERGY_STATE_RESET && result == PMC_SUCCESS)
    {
        /* If we are in crash restart and the energy state is reset, simply
         * re-initialize the context to default and exit */
        cpb_init(cpb_handle, energy_state);
    }
    else if (result == PMC_SUCCESS)
    {
        /* memory pool usage check */
        for(i = 0; i < LAST_CPB_MEM_POOL_ID; i++)
        {
            if(cpb_handle->var.cpb_mem_pool_in_use[i] == TRUE && restart_init_cfg_ptr->is_warm_restart == TRUE)
            {


                result = CPB_ERR_CONTEXT_INCOHERENT;
                break;
            } else {
                /* unconditionally free the pool resources */
                cpb_handle->var.cpb_mem_pool_in_use[i] = FALSE;
            }
        }
        /* recover DPI Slave Port Channel configuration data from register space */
        if(result==PMC_SUCCESS || !restart_init_cfg_ptr->is_warm_restart)
        {
            result = cpb_audit_slv_dpi_register_get(cpb_handle, slv_data_ptr);
        }

        /* Recover var data from register space. Slave data must be recovered
         * prior to this call */
        if(result==PMC_SUCCESS || !restart_init_cfg_ptr->is_warm_restart)
        {
            result = cpb_audit_var_data_register_get(cpb_handle, slv_data_ptr,restart_init_cfg_ptr->is_warm_restart,register_var);
        }

        /* recover slv_dpi_port_init_flag[8] and mst_dpi_port_init_flag[8] */
        if(result == PMC_SUCCESS || !restart_init_cfg_ptr->is_warm_restart)
        {
            result = cpb_audit_var_intf_state_get(cpb_handle,
                                                  slv_data_ptr,
                                                  register_var);
        }

        if(restart_init_cfg_ptr->is_warm_restart && result==PMC_SUCCESS)
        {
            /* Compare Context with Register Data for Coherency */
            result = cpb_audit_ctxt_register_compare(cpb_handle, &(cpb_handle->var), register_var,
                                                     &mismatch_page_table,
                                                     &mismatch_block_table,
                                                     &mismatch_intf_switch,
                                                     &mismatch_dcs_active,
                                                     &mismatch_dcs_calendar,
                                                     &mismatch_fifo_var_data);
        }
        else if(restart_init_cfg_ptr->is_warm_restart == FALSE)
        {
            if (restart_init_cfg_ptr->phase == UTIL_GLOBAL_RESTART_INIT_PHASE_SECOND)
            {

                if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB)
                {
                    result = cpb_audit_ctxt_register_compare(cpb_handle, &(cpb_handle->var), register_var,
                                                             &mismatch_page_table,
                                                             &mismatch_block_table,
                                                             &mismatch_intf_switch,
                                                             &mismatch_dcs_active,
                                                             &mismatch_dcs_calendar,
                                                             &mismatch_fifo_var_data);
                    PMC_ASSERT(result==PMC_SUCCESS, CPB_ERR_CODE_ASSERT, 0, 0);
                }
                /* Modify the context and register data so only the union is kept */
                result = cpb_audit_ctxt_register_clean(cpb_handle,
                                                       restart_init_cfg_ptr,
                                                       &(cpb_handle->var),
                                                       register_var,
                                                       slv_data_ptr,
                                                       energy_state);
            }
        }
    } /* end if else restart_init_cfg_ptr->is_warm_restart && energy_state */


    /* update the cpb connection state tracking context to reflect the connection information
       stored in other context.  */
    if(result == PMC_SUCCESS && cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB)
    {
        cpb_connect_data_state_get_recovery(cpb_handle, 
                                            restart_init_cfg_ptr,
                                            slv_data_ptr,
                                            cpb_handle->var.cpb_connect_data);
    }

#ifdef CPB_BLOCK_LIST
    if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_OCPB) {
        UINT32 page_index, block_index;
        UINT32 p,b;
        UINT32 wp_id, wqid, lba;
        UINT32 num_pages, blocks_per_page;

        /* The goal is to restore three things:
         * 1) queue_block[][] array
         * 2) page struct fields: .first_free_block_in_page, .free_block_num
         * 3) block struct fields: .queue_next, .queue_prev (both used and free blocks)
         */
        num_pages = cpb_handle->cfg.num_pages;
        blocks_per_page = cpb_handle->cfg.blocks_per_page;

        /* Set default values to some page and block fields */
        for (page_index=0; page_index < num_pages; page_index++) {
            cpb_handle->var.page_inverted_page_table[page_index].first_free_block = CPB_NULL_BLOCK_ID;
            cpb_handle->var.page_inverted_page_table[page_index].free_block_num = 0;
            for (block_index=0; block_index < blocks_per_page; block_index++) {
                cpb_handle->var.block_inverted_page_table[page_index*blocks_per_page+block_index].ipt_queue_prev = CPB_NULL_BLOCK_ID;
                cpb_handle->var.block_inverted_page_table[page_index*blocks_per_page+block_index].ipt_queue_next = CPB_NULL_BLOCK_ID;
            }
        }

        /* Set default values to queue_block */
        {
            UINT32 i,j;
            for (i=0;i<4;i++) {
                for (j=0; j<UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_CHNLS_PER_PORT; j++) {
                    cpb_handle->var.cpb_connect_data->queue_block[i][j].queue_length = 0;
                    cpb_handle->var.cpb_connect_data->queue_block[i][j].head_block = CPB_NULL_BLOCK_ID;
                    cpb_handle->var.cpb_connect_data->queue_block[i][j].tail_block = CPB_NULL_BLOCK_ID;
                }
            }
        }

        /* iterate through each block to set up lists */
        for (page_index=0; page_index < num_pages; page_index++) {

            if (!cpb_handle->var.page_inverted_page_table[page_index].ctrl_page_valid) {
                /* all blocks are free, and connect them together */
                cpb_handle->var.page_inverted_page_table[page_index].free_block_num = blocks_per_page;
                cpb_handle->var.page_inverted_page_table[page_index].first_free_block = blocks_per_page*page_index;

                for (block_index=0; block_index < blocks_per_page; block_index++) {
                    UINT32 block_id;
                    block_id = page_index * blocks_per_page + block_index;

                    if (block_index != cpb_handle->cfg.blocks_per_page - 1) {
                        cpb_handle->var.block_inverted_page_table[block_id].ipt_queue_next = block_id+1;
                    } else {
                        cpb_handle->var.block_inverted_page_table[block_id].ipt_queue_next = CPB_NULL_BLOCK_ID;
                    }

                    if (block_index) {
                        cpb_handle->var.block_inverted_page_table[block_id].ipt_queue_prev = block_id-1;
                    } else {
                        cpb_handle->var.block_inverted_page_table[block_id].ipt_queue_prev = CPB_NULL_BLOCK_ID;
                    }
                }

                continue;
            }

            wp_id = cpb_handle->var.page_inverted_page_table[page_index].ctrl_ipt_wp_id;

            for (block_index=0; block_index < blocks_per_page; block_index++) {

                if (!cpb_handle->var.block_inverted_page_table[page_index*blocks_per_page+block_index].ipt_valid) {
                    /* Be a free block, therefore insert it to the free blocks list at head */

                    if (cpb_handle->var.page_inverted_page_table[page_index].free_block_num) {
                        /* Not the first free block in the page */

                        cpb_handle->var.block_inverted_page_table[page_index*blocks_per_page+block_index].ipt_queue_next = 
                            cpb_handle->var.page_inverted_page_table[page_index].first_free_block;
                        cpb_handle->var.block_inverted_page_table[cpb_handle->var.page_inverted_page_table[page_index].first_free_block].ipt_queue_prev = 
                            page_index*blocks_per_page+block_index;
                    }
                    cpb_handle->var.page_inverted_page_table[page_index].first_free_block = page_index*blocks_per_page+block_index;
                    cpb_handle->var.page_inverted_page_table[page_index].free_block_num++;

                    continue;
                }

                /* be a used block */

                lba = cpb_handle->var.block_inverted_page_table[page_index*blocks_per_page+block_index].ipt_lba;
                wqid = cpb_handle->var.block_inverted_page_table[page_index*blocks_per_page+block_index].ipt_wqid;

                /* assign queue_block[][] */
                cpb_handle->var.cpb_connect_data->queue_block[wp_id][wqid].queue_length++;
                if (CPB_NULL_BLOCK_ID == cpb_handle->var.cpb_connect_data->queue_block[wp_id][wqid].tail_block ||
                    lba > cpb_handle->var.block_inverted_page_table[cpb_handle->var.cpb_connect_data->queue_block[wp_id][wqid].tail_block].ipt_lba) {
                    cpb_handle->var.cpb_connect_data->queue_block[wp_id][wqid].tail_block = page_index*blocks_per_page+block_index;
                }
                if (CPB_NULL_BLOCK_ID == cpb_handle->var.cpb_connect_data->queue_block[wp_id][wqid].head_block ||
                    lba < cpb_handle->var.block_inverted_page_table[cpb_handle->var.cpb_connect_data->queue_block[wp_id][wqid].head_block].ipt_lba) {
                    cpb_handle->var.cpb_connect_data->queue_block[wp_id][wqid].head_block = page_index*blocks_per_page+block_index;
                }

                /* Search for the logically next and prev block.
                 * 1) search the left blocks in the same page
                 * 2) search all left pages
                 */
                for (p=page_index; p<num_pages; p++) {

                    /* skip invalid pages and pages assigend to other write port */
                    if (!cpb_handle->var.page_inverted_page_table[p].ctrl_page_valid ||
                        cpb_handle->var.page_inverted_page_table[p].ctrl_ipt_wp_id != wp_id) {
                        continue;
                    }

                    for (b=(p==page_index)?(block_index+1):0; b<blocks_per_page; b++) {

                        if (cpb_handle->var.block_inverted_page_table[p*blocks_per_page+b].ipt_valid &&
                            cpb_handle->var.block_inverted_page_table[p*blocks_per_page+b].ipt_wqid == wqid) {
                            if (cpb_handle->var.block_inverted_page_table[p*blocks_per_page+b].ipt_lba == lba+1) {
                                /* got the next */
                                PMC_ASSERT(cpb_handle->var.block_inverted_page_table[page_index*blocks_per_page+block_index].ipt_queue_next == CPB_NULL_BLOCK_ID, CPB_ERR_CODE_ASSERT, 0, 0);
                                PMC_ASSERT(cpb_handle->var.block_inverted_page_table[p*blocks_per_page+b].ipt_queue_prev == CPB_NULL_BLOCK_ID, CPB_ERR_CODE_ASSERT, 0, 0);
                                cpb_handle->var.block_inverted_page_table[page_index*blocks_per_page+block_index].ipt_queue_next = p*blocks_per_page+b;
                                cpb_handle->var.block_inverted_page_table[p*blocks_per_page+b].ipt_queue_prev = page_index*blocks_per_page+block_index;
                            } else if (lba && cpb_handle->var.block_inverted_page_table[p*blocks_per_page+b].ipt_lba == lba-1) {
                                /* got the prev */
                                PMC_ASSERT(cpb_handle->var.block_inverted_page_table[page_index*blocks_per_page+block_index].ipt_queue_prev == CPB_NULL_BLOCK_ID, CPB_ERR_CODE_ASSERT, 0, 0);
                                PMC_ASSERT(cpb_handle->var.block_inverted_page_table[p*blocks_per_page+b].ipt_queue_next == CPB_NULL_BLOCK_ID, CPB_ERR_CODE_ASSERT, 0, 0);
                                cpb_handle->var.block_inverted_page_table[page_index*blocks_per_page+block_index].ipt_queue_prev = p*blocks_per_page+b;
                                cpb_handle->var.block_inverted_page_table[p*blocks_per_page+b].ipt_queue_next = page_index*blocks_per_page+block_index;
                            } else {
                                /* do nothing */
                            }
                        }
                    } /* b */
                } /* p */
            } /* block */
        } /* page */
    }
#endif

    /* recover memory used for the restart process */
    PMC_FREE(&(register_var->p_var_t_ram_data));
    PMC_FREE(&(register_var->block_inverted_page_table));
    PMC_FREE(&(register_var->page_inverted_page_table));
    PMC_FREE(&(register_var));

    PMC_FREE(&(slv_data_ptr));

    PMC_FREE(&(context_channel_state));
    PMC_FREE(&(device_channel_state));

    PMC_RETURN(result);
} /* cpb_handle_restart_init */

/*******************************************************************************
* cpb_connect_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function retreives the interconnection and connection functional state
*  for resources within the CPB subystem using the CPB context.
*
*
* INPUTS:
*   *cpb_handle         - pointer to cpb handle instance
*
* OUTPUTS:
*   *conn_ptr           - util_global_cpb_connect_t type data structure, updated
*                         to reflect connection data within CPB
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_connect_state_get(cpb_handle_t *cpb_handle, util_global_cpb_connect_t *conn_ptr)
{
    BOOL8 first_slave_set = FALSE;
    util_schd_chnl_state_t util_schd_state = LAST_UTIL_SCHD_CHNL;
    util_global_chnl_state_t util_global_state;
    UINT32 i,j,
    slave_port,
    slave_channel,
    push_port,
    wid,
    master_port,
    master_channel,
    dest_mst_port,
    dest_mst_chnl,
    non_primary_master_port,
    non_primary_master_channel,
    temp_dest_master_port,
    temp_dest_master_channel,
    dcs_channel,
    pointing_to_primary_port,
    pointing_to_primary_channel;
    UINT32 last_slave_port = 0;
    UINT32 last_slave_channel = 0;
    BOOL8 valid_rid = FALSE;
    BOOL8 is_broadcast,is_multicast,is_reader_primary,is_slave_zone_primary;

    PMC_ENTRY();

    /* Initialize all slave states to unused */
    for(i=0;i<UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_PORTS;i++)
    {
        for(j=0;j<UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_CHNLS_PER_PORT;j++)
        {
            conn_ptr->chnl[i][j].slv.state = UTIL_GLOBAL_CHNL_START;
            conn_ptr->chnl[i][j].slv.dest_mst_port = CPB_INDEX_LAST;
            conn_ptr->chnl[i][j].slv.dest_mst_chnl = CPB_INDEX_LAST;
            conn_ptr->chnl[i][j].mst.next_dest_mst_port = CPB_INDEX_LAST;
            conn_ptr->chnl[i][j].mst.next_dest_mst_chnl = CPB_INDEX_LAST;
            conn_ptr->chnl[i][j].mst.source_slv_port = CPB_INDEX_LAST;
            conn_ptr->chnl[i][j].mst.source_slv_chnl = CPB_INDEX_LAST;
        }
    }
    switch(cpb_handle->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
        case CPB_INSTANCE_OCPB:
            for(i=0;i<cpb_handle->cfg.num_dcs;i++)
            {
                for(j=0;j<cpb_handle->cfg.num_calendar_entries;j++)
                {
                    valid_rid = cpb_rd_queue_id_data_get(cpb_handle,
                                                         i, /* dcs inst */
                                                         j, /* read queue id */
                                                         &util_schd_state,
                                                         &master_port,
                                                         &master_channel,
                                                         &dcs_channel,
                                                         &push_port,
                                                         &wid,
                                                         &slave_port,
                                                         &slave_channel,
                                                         &is_broadcast,
                                                         &is_multicast,
                                                         &is_reader_primary,
                                                         &is_slave_zone_primary);


                    switch (util_schd_state)
                    {
                        case UTIL_SCHD_CHNL_START:
                            util_global_state = UTIL_GLOBAL_CHNL_START;
                            break;
                        case UTIL_SCHD_CHNL_EQUIPPED:
                            util_global_state = UTIL_GLOBAL_CHNL_EQUIPPED;
                            break;
                        case UTIL_SCHD_CHNL_OPERATIONAL:
                            util_global_state = UTIL_GLOBAL_CHNL_OPERATIONAL;
                            break;
                        default:
                            util_global_state = UTIL_GLOBAL_CHNL_PASSTHRU;
                            break;
                    }

                    if(valid_rid && slave_port < UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_PORTS)
                    {
                        if(conn_ptr->chnl[slave_port][slave_channel].slv.state == UTIL_GLOBAL_CHNL_START)
                        {
                            conn_ptr->chnl[slave_port][slave_channel].slv.next_slv_port = CPB_INDEX_LAST;
                            conn_ptr->chnl[slave_port][slave_channel].slv.next_slv_chnl = CPB_INDEX_LAST;
                        }
                        if(!first_slave_set)
                        {
                            first_slave_set = TRUE;
                        }
                        else
                        {
                            if(conn_ptr->chnl[slave_port][slave_channel].slv.state == UTIL_GLOBAL_CHNL_START)
                            {
                                conn_ptr->chnl[last_slave_port][last_slave_channel].slv.next_slv_port = slave_port;
                                conn_ptr->chnl[last_slave_port][last_slave_channel].slv.next_slv_chnl = slave_channel;
                            }
                        }

                        if(conn_ptr->chnl[slave_port][slave_channel].slv.state == UTIL_GLOBAL_CHNL_START)
                        {
                            last_slave_port = slave_port;
                            last_slave_channel = slave_channel;

                        }

                        if(conn_ptr->chnl[slave_port][slave_channel].slv.state == UTIL_GLOBAL_CHNL_START)
                        {
                            conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_port = master_port;
                            conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_chnl = master_channel;


                            conn_ptr->chnl[master_port][master_channel].mst.state = util_global_state;
                            conn_ptr->chnl[master_port][master_channel].mst.is_reader_primary = is_reader_primary;
                            conn_ptr->chnl[master_port][master_channel].mst.is_slave_zone_primary = is_slave_zone_primary;
                            conn_ptr->chnl[master_port][master_channel].mst.next_dest_mst_port = CPB_INDEX_LAST;
                            conn_ptr->chnl[master_port][master_channel].mst.next_dest_mst_chnl = CPB_INDEX_LAST;
                            conn_ptr->chnl[master_port][master_channel].mst.source_slv_port = slave_port;
                            conn_ptr->chnl[master_port][master_channel].mst.source_slv_chnl = slave_channel;
                        }
                        else
                        {
                            dest_mst_port = conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_port;
                            dest_mst_chnl = conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_chnl;

                            /* Find the master port where the next destination
                             * is CPB_INDEX_LAST */
                            while(conn_ptr->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_port != CPB_INDEX_LAST)
                            {
                                temp_dest_master_port = conn_ptr->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_port;
                                temp_dest_master_channel = conn_ptr->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_chnl;
                                dest_mst_port = temp_dest_master_port;
                                dest_mst_chnl = temp_dest_master_channel;

                            }

                            conn_ptr->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_port = master_port;
                            conn_ptr->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_chnl = master_channel;
                            conn_ptr->chnl[master_port][master_channel].mst.next_dest_mst_port = CPB_INDEX_LAST;
                            conn_ptr->chnl[master_port][master_channel].mst.next_dest_mst_chnl = CPB_INDEX_LAST;
                            conn_ptr->chnl[master_port][master_channel].mst.state = util_global_state;
                            conn_ptr->chnl[master_port][master_channel].mst.is_reader_primary = is_reader_primary;
                            conn_ptr->chnl[master_port][master_channel].mst.is_slave_zone_primary = is_slave_zone_primary;
                            conn_ptr->chnl[master_port][master_channel].mst.source_slv_port = slave_port;
                            conn_ptr->chnl[master_port][master_channel].mst.source_slv_chnl = slave_channel;
                        }

                        /* If the current master port and channel is a broadcast slave zone primary, or a multicast reader
                         * primary, it needs to be at the top of the master port list */
                        if( (is_broadcast && is_slave_zone_primary) ||
                            (is_multicast && is_reader_primary) )
                        {
                            if( (conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_port != master_port) &&
                                (conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_chnl != master_channel) )
                            {
                                /* This is the port that slave was pointing to
                                 * */
                                non_primary_master_port = conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_port;
                                non_primary_master_channel = conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_chnl;

                                /* Find the port thats pointing to the primary
                                 * port */
                                pointing_to_primary_port = conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_port;
                                pointing_to_primary_channel = conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_chnl;

                                while( (conn_ptr->chnl[pointing_to_primary_port][pointing_to_primary_channel].mst.next_dest_mst_port != master_port) &&
                                       (conn_ptr->chnl[pointing_to_primary_port][pointing_to_primary_channel].mst.next_dest_mst_chnl != master_channel) )
                                {
                                    temp_dest_master_port = conn_ptr->chnl[pointing_to_primary_port][pointing_to_primary_channel].mst.next_dest_mst_port;
                                    temp_dest_master_channel = conn_ptr->chnl[pointing_to_primary_port][pointing_to_primary_channel].mst.next_dest_mst_chnl;
                                    pointing_to_primary_port = temp_dest_master_port;
                                    pointing_to_primary_channel = temp_dest_master_channel;
                                }

                                /* 1. Set slave port/channel to point to the
                                 * primary master */
                                conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_port = master_port;
                                conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_chnl = master_channel;

                                /* 2. Set the master that previously pointed to
                                 * primary to point to what the primary used
                                 * to point to */
                                conn_ptr->chnl[pointing_to_primary_port][pointing_to_primary_channel].mst.next_dest_mst_port =
                                    conn_ptr->chnl[master_port][master_channel].mst.next_dest_mst_port;
                                conn_ptr->chnl[pointing_to_primary_port][pointing_to_primary_channel].mst.next_dest_mst_chnl =
                                    conn_ptr->chnl[master_port][master_channel].mst.next_dest_mst_chnl;

                                /* 3. Set the primary master port to point to the
                                 * master that the slave previously pointed to
                                 * */
                                conn_ptr->chnl[master_port][master_channel].mst.next_dest_mst_port = non_primary_master_port;
                                conn_ptr->chnl[master_port][master_channel].mst.next_dest_mst_chnl = non_primary_master_channel;

                            } /* end if the slave destination is not the master port */

                        } /* end if is_broadcast ...etc. */

                        /* Base the slave information on the master primary channel */
                        if( (is_broadcast && is_slave_zone_primary) ||
                            (is_multicast && is_reader_primary) ||
                            (is_broadcast ==0 && is_multicast == 0) ||
                            conn_ptr->chnl[slave_port][slave_channel].slv.state == UTIL_GLOBAL_CHNL_START)
                        {
                            conn_ptr->chnl[slave_port][slave_channel].slv.state = util_global_state;
                            conn_ptr->chnl[slave_port][slave_channel].slv.is_broadcast = is_broadcast;
                            conn_ptr->chnl[slave_port][slave_channel].slv.is_multicast = is_multicast;
                        }

                    } /* end if valid_rid */
                } /* end for j (read queue id) */
            } /* end for i (dcs inst) */

            break;
        case CPB_INSTANCE_MCPB:
        case LAST_CPB_INSTANCE:
            PMC_ASSERT(FALSE,CPB_ERR_NO_SW_CONTENT, 0, 0);
            break;
    }

    PMC_RETURN();

} /* cpb_connect_state_get */

/*******************************************************************************
* cpb_connect_data_state_get_recovery
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function retreives the interconnection and connection functional state
*  for resources within the CPB subystem using the CPB context.
*
*
* INPUTS:
*   *cpb_handle            - pointer to cpb handle instance
*   *restart_init_cfg_ptr  - pointer to restart init config
*   *slv_data_ptr          - pointer to DPI slave port channel data
*
* OUTPUTS:
*   *conn_ptr           - cpb_connect_data_t type data structure, updated
*                         to reflect connection data within CPB
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void cpb_connect_data_state_get_recovery(cpb_handle_t *cpb_handle, 
                                                 util_global_restart_init_cfg_t *restart_init_cfg_ptr,
                                                 cpb_slv_data_t * slv_data_ptr,
                                                 util_global_cpb_connect_t *conn_ptr)
{
    BOOL8 first_slave_set = FALSE;
    util_schd_chnl_state_t util_schd_state = LAST_UTIL_SCHD_CHNL;
    util_global_chnl_state_t util_global_state;
    UINT32 i,j,
    slave_port,
    slave_channel,
    push_port,
    wid,
    master_port,
    master_channel,
    dest_mst_port,
    dest_mst_chnl,
    non_primary_master_port,
    non_primary_master_channel,
    temp_dest_master_port,
    temp_dest_master_channel,
    dcs_channel,
    pointing_to_primary_port,
    pointing_to_primary_channel;
    UINT32 last_slave_port = 0;
    UINT32 last_slave_channel = 0;
    BOOL8 valid_rid = FALSE;
    BOOL8 is_broadcast = FALSE;
    BOOL8 is_multicast = FALSE;
    BOOL8 is_reader_primary = FALSE;
    BOOL8 is_slave_zone_primary = FALSE;

    PMC_ENTRY();

    /* Initialize all slave states to unused */
    for(i=0;i<6;i++)
    {
        for(j=0;j<150;j++)
        {
            conn_ptr->chnl[i][j].slv.state = UTIL_GLOBAL_CHNL_START;
            conn_ptr->chnl[i][j].slv.dest_mst_port = CPB_INDEX_LAST;
            conn_ptr->chnl[i][j].slv.dest_mst_chnl = CPB_INDEX_LAST;
            conn_ptr->chnl[i][j].slv.is_broadcast = FALSE;
            conn_ptr->chnl[i][j].slv.is_multicast = FALSE;
            conn_ptr->chnl[i][j].mst.state = UTIL_GLOBAL_CHNL_START;
            conn_ptr->chnl[i][j].mst.is_reader_primary = 0;
            conn_ptr->chnl[i][j].mst.is_slave_zone_primary = 0;
            conn_ptr->chnl[i][j].mst.next_dest_mst_port = CPB_INDEX_LAST;
            conn_ptr->chnl[i][j].mst.next_dest_mst_chnl = CPB_INDEX_LAST;
            conn_ptr->chnl[i][j].mst.source_slv_port = CPB_INDEX_LAST;
            conn_ptr->chnl[i][j].mst.source_slv_chnl = CPB_INDEX_LAST;
            conn_ptr->chnl[i][j].mst.dcs_inst = CPB_INDEX_LAST;
            conn_ptr->chnl[i][j].mst.rd_queue_id = CPB_INDEX_LAST;


        }
    }
    switch(cpb_handle->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
        case CPB_INSTANCE_OCPB:
            for(i=0;i<cpb_handle->cfg.num_dcs;i++)
            {
                for(j=0;j<cpb_handle->cfg.num_calendar_entries;j++)
                {
                    valid_rid = cpb_rd_queue_id_data_get(cpb_handle,
                                                         i, /* dcs inst */
                                                         j, /* read queue id */
                                                         &util_schd_state,
                                                         &master_port,
                                                         &master_channel,
                                                         &dcs_channel,
                                                         &push_port,
                                                         &wid,
                                                         &slave_port,
                                                         &slave_channel,
                                                         &is_broadcast,
                                                         &is_multicast,
                                                         &is_reader_primary,
                                                         &is_slave_zone_primary);

                    if (valid_rid == 1 && 
                        restart_init_cfg_ptr->is_warm_restart == FALSE && 
                        restart_init_cfg_ptr->phase == UTIL_GLOBAL_RESTART_INIT_PHASE_FIRST) 
                    {                        
                        if(slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_en[0] == 0 &&
                           slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_en[1] == 0 &&
                           slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_en[2] == 0 &&
                           slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_en[3] == 0)
                        {
                            if (util_schd_state == UTIL_SCHD_CHNL_OPERATIONAL)
                            {
                                util_schd_state = UTIL_SCHD_CHNL_EQUIPPED;
                            } 
                            else if(util_schd_state == UTIL_SCHD_CHNL_BACKUP)
                            {
                                util_schd_state = UTIL_SCHD_CHNL_BACKUP;
                            }
                            else 
                            {
                                util_schd_state = UTIL_SCHD_CHNL_START;
                            }
                        }
                    }
                        
                    switch (util_schd_state)
                    {
                        case UTIL_SCHD_CHNL_START:
                            util_global_state = UTIL_GLOBAL_CHNL_START;
                            break;
                        case UTIL_SCHD_CHNL_EQUIPPED:
                            util_global_state = UTIL_GLOBAL_CHNL_EQUIPPED;
                            break;
                        case UTIL_SCHD_CHNL_OPERATIONAL:
                            util_global_state = UTIL_GLOBAL_CHNL_OPERATIONAL;
                            break;
                        case UTIL_SCHD_CHNL_BACKUP:
                            util_global_state = UTIL_GLOBAL_CHNL_BACKUP;
                            break;
                        default:
                            util_global_state = UTIL_GLOBAL_CHNL_PASSTHRU;
                            break;
                    }

                    if(valid_rid && slave_port < 6)
                    {
                        if(conn_ptr->chnl[slave_port][slave_channel].slv.state == UTIL_GLOBAL_CHNL_START)
                        {
                            conn_ptr->chnl[slave_port][slave_channel].slv.next_slv_port = CPB_INDEX_LAST;
                            conn_ptr->chnl[slave_port][slave_channel].slv.next_slv_chnl = CPB_INDEX_LAST;
                        }
                        if(!first_slave_set)
                        {
                            first_slave_set = TRUE;
                        }
                        else
                        {
                            if(conn_ptr->chnl[slave_port][slave_channel].slv.state == UTIL_GLOBAL_CHNL_START)
                            {
                                conn_ptr->chnl[last_slave_port][last_slave_channel].slv.next_slv_port = slave_port;
                                conn_ptr->chnl[last_slave_port][last_slave_channel].slv.next_slv_chnl = slave_channel;
                            }
                        }

                        if(conn_ptr->chnl[slave_port][slave_channel].slv.state == UTIL_GLOBAL_CHNL_START)
                        {
                            last_slave_port = slave_port;
                            last_slave_channel = slave_channel;
                        }

                        if(conn_ptr->chnl[slave_port][slave_channel].slv.state == UTIL_GLOBAL_CHNL_START)
                        {
                            conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_port = master_port;
                            conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_chnl = master_channel;

                            if(!(util_global_state == UTIL_GLOBAL_CHNL_BACKUP && slave_port == (UINT32)UTIL_GLOBAL_CPB_PORT_CBRC))
                            {
                                conn_ptr->chnl[master_port][master_channel].mst.state = (util_global_state==UTIL_GLOBAL_CHNL_BACKUP ? UTIL_GLOBAL_CHNL_OPERATIONAL:util_global_state);
                                conn_ptr->chnl[master_port][master_channel].mst.is_reader_primary = is_reader_primary;
                                conn_ptr->chnl[master_port][master_channel].mst.is_slave_zone_primary = is_slave_zone_primary;
                                conn_ptr->chnl[master_port][master_channel].mst.next_dest_mst_port = CPB_INDEX_LAST;
                                conn_ptr->chnl[master_port][master_channel].mst.next_dest_mst_chnl = CPB_INDEX_LAST;
                                conn_ptr->chnl[master_port][master_channel].mst.dcs_inst = i;

                                if(i == 3 && cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB && 
                                   slave_port == (UINT32)UTIL_GLOBAL_CPB_PORT_CBRC &&
                                   util_global_state == UTIL_GLOBAL_CHNL_OPERATIONAL)
                                {
                                    UINT32 k, wr_queue_id = 0, input_port = 0, input_chnl = 0;
                                    BOOL8 backup_exists = FALSE;
                                    for(k = 0; k < cpb_handle->cfg.num_calendar_entries; k++)
                                    {
                                        if(k != j && 
                                           cpb_handle->util_schd_handle[i]->var.schd_ctxt->chnl_ctxt[k].state == UTIL_SCHD_CHNL_BACKUP &&
                                           cpb_handle->util_schd_handle[i]->var.schd_ctxt->chnl_ctxt[k].dcs_rd_channel_id ==
                                           cpb_handle->util_schd_handle[i]->var.schd_ctxt->chnl_ctxt[j].dcs_rd_channel_id)
                                        {
                                            PMC_ERROR result = PMC_SUCCESS;
                                            result = cpb_ingress_mux_input_port_data_get(cpb_handle,
                                                                                         i,
                                                                                         k,
                                                                                         &wr_queue_id,
                                                                                         &input_port,
                                                                                         &input_chnl);
                                            PMC_ASSERT(result == PMC_SUCCESS, CPB_ERR_CODE_ASSERT, 0, 0);                                            
                                            PMC_ASSERT(wr_queue_id == cpb_handle->util_schd_handle[i]->var.schd_ctxt->chnl_ctxt[k].dcs_sf2_wr_queue_id, CPB_ERR_CODE_ASSERT, 0, 0);
                                            PMC_ASSERT((input_port == UTIL_GLOBAL_CPB_PORT_ENET_LINE || input_port == UTIL_GLOBAL_CPB_PORT_ENET_SYS), CPB_ERR_CODE_ASSERT, 0, 0);

                                            backup_exists = TRUE;

                                            conn_ptr->chnl[master_port][master_channel].mst.source_slv_port = input_port;
                                            conn_ptr->chnl[master_port][master_channel].mst.source_slv_chnl = input_chnl;
                                            conn_ptr->chnl[master_port][master_channel].mst.rd_queue_id = k;
                                            break;
                                        }
                                    }
                                    if(backup_exists == FALSE)
                                    {
                                        conn_ptr->chnl[master_port][master_channel].mst.source_slv_port = slave_port;
                                        conn_ptr->chnl[master_port][master_channel].mst.source_slv_chnl = slave_channel;
                                        conn_ptr->chnl[master_port][master_channel].mst.rd_queue_id = j;
                                    }
                                }
                                else
                                {
                                    conn_ptr->chnl[master_port][master_channel].mst.source_slv_port = slave_port;
                                    conn_ptr->chnl[master_port][master_channel].mst.source_slv_chnl = slave_channel;
                                    conn_ptr->chnl[master_port][master_channel].mst.rd_queue_id = j;
                                }
                            }
                        }
                        else
                        {
                            dest_mst_port = conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_port;
                            dest_mst_chnl = conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_chnl;

                            /* Find the master port where the next destination
                             * is CPB_INDEX_LAST */
                            while(conn_ptr->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_port != CPB_INDEX_LAST)
                            {
                                temp_dest_master_port = conn_ptr->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_port;
                                temp_dest_master_channel = conn_ptr->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_chnl;
                                dest_mst_port = temp_dest_master_port;
                                dest_mst_chnl = temp_dest_master_channel;

                            }
                            
                            if(!(util_global_state == UTIL_GLOBAL_CHNL_BACKUP && slave_port == (UINT32)UTIL_GLOBAL_CPB_PORT_CBRC))
                            {
                                conn_ptr->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_port = master_port;
                                conn_ptr->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_chnl = master_channel;
                                conn_ptr->chnl[master_port][master_channel].mst.state = (util_global_state==UTIL_GLOBAL_CHNL_BACKUP ? UTIL_GLOBAL_CHNL_OPERATIONAL:util_global_state);
                                conn_ptr->chnl[master_port][master_channel].mst.is_reader_primary = is_reader_primary;
                                conn_ptr->chnl[master_port][master_channel].mst.is_slave_zone_primary = is_slave_zone_primary;
                                conn_ptr->chnl[master_port][master_channel].mst.dcs_inst = i;

                                if(i == 3 && cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB && 
                                   slave_port == (UINT32)UTIL_GLOBAL_CPB_PORT_CBRC &&
                                   util_global_state == UTIL_GLOBAL_CHNL_OPERATIONAL)
                                {
                                    UINT32 k, wr_queue_id = 0, input_port = 0, input_chnl = 0;
                                    BOOL8 backup_exists = FALSE;
                                    for(k = 0; k < cpb_handle->cfg.num_calendar_entries; k++)
                                    {
                                        if(k != j && 
                                           cpb_handle->util_schd_handle[i]->var.schd_ctxt->chnl_ctxt[k].state == UTIL_SCHD_CHNL_BACKUP &&
                                           cpb_handle->util_schd_handle[i]->var.schd_ctxt->chnl_ctxt[k].dcs_rd_channel_id ==
                                           cpb_handle->util_schd_handle[i]->var.schd_ctxt->chnl_ctxt[j].dcs_rd_channel_id)
                                        {
                                            PMC_ERROR result = PMC_SUCCESS;
                                            result = cpb_ingress_mux_input_port_data_get(cpb_handle,
                                                                                         i,
                                                                                         k,
                                                                                         &wr_queue_id,
                                                                                         &input_port,
                                                                                         &input_chnl);
                                            PMC_ASSERT(result == PMC_SUCCESS, CPB_ERR_CODE_ASSERT, 0, 0);                                            
                                            PMC_ASSERT(wr_queue_id == cpb_handle->util_schd_handle[i]->var.schd_ctxt->chnl_ctxt[k].dcs_sf2_wr_queue_id, CPB_ERR_CODE_ASSERT, 0, 0);
                                            PMC_ASSERT((input_port == UTIL_GLOBAL_CPB_PORT_ENET_LINE || input_port == UTIL_GLOBAL_CPB_PORT_ENET_SYS), CPB_ERR_CODE_ASSERT, 0, 0);

                                            backup_exists = TRUE;

                                            conn_ptr->chnl[master_port][master_channel].mst.source_slv_port = input_port;
                                            conn_ptr->chnl[master_port][master_channel].mst.source_slv_chnl = input_chnl;
                                            conn_ptr->chnl[master_port][master_channel].mst.rd_queue_id = k;
                                            break;
                                        }
                                    }
                                    if(backup_exists == FALSE)
                                    {
                                        conn_ptr->chnl[master_port][master_channel].mst.source_slv_port = slave_port;
                                        conn_ptr->chnl[master_port][master_channel].mst.source_slv_chnl = slave_channel;
                                        conn_ptr->chnl[master_port][master_channel].mst.rd_queue_id = j;
                                    }
                                }
                                else
                                {
                                    conn_ptr->chnl[master_port][master_channel].mst.source_slv_port = slave_port;
                                    conn_ptr->chnl[master_port][master_channel].mst.source_slv_chnl = slave_channel;
                                    conn_ptr->chnl[master_port][master_channel].mst.rd_queue_id = j;
                                }
                            }
                        }

                        /* If the current master port and channel is a broadcast slave zone primary, or a multicast reader
                         * primary, it needs to be at the top of the master port list */
                        if( (is_broadcast && is_slave_zone_primary) ||
                            (is_multicast && is_reader_primary) )
                        {
                            if( (conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_port != master_port) &&
                                (conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_chnl != master_channel) )
                            {
                                /* This is the port that slave was pointing to
                                 * */
                                non_primary_master_port = conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_port;
                                non_primary_master_channel = conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_chnl;

                                /* Find the port thats pointing to the primary
                                 * port */
                                pointing_to_primary_port = conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_port;
                                pointing_to_primary_channel = conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_chnl;

                                while( (conn_ptr->chnl[pointing_to_primary_port][pointing_to_primary_channel].mst.next_dest_mst_port != master_port) &&
                                       (conn_ptr->chnl[pointing_to_primary_port][pointing_to_primary_channel].mst.next_dest_mst_chnl != master_channel) )
                                {
                                    temp_dest_master_port = conn_ptr->chnl[pointing_to_primary_port][pointing_to_primary_channel].mst.next_dest_mst_port;
                                    temp_dest_master_channel = conn_ptr->chnl[pointing_to_primary_port][pointing_to_primary_channel].mst.next_dest_mst_chnl;
                                    pointing_to_primary_port = temp_dest_master_port;
                                    pointing_to_primary_channel = temp_dest_master_channel;
                                }

                                /* 1. Set slave port/channel to point to the
                                 * primary master */
                                conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_port = master_port;
                                conn_ptr->chnl[slave_port][slave_channel].slv.dest_mst_chnl = master_channel;

                                /* 2. Set the master that previously pointed to
                                 * primary to point to what the primary used
                                 * to point to */
                                conn_ptr->chnl[pointing_to_primary_port][pointing_to_primary_channel].mst.next_dest_mst_port =
                                    conn_ptr->chnl[master_port][master_channel].mst.next_dest_mst_port;
                                conn_ptr->chnl[pointing_to_primary_port][pointing_to_primary_channel].mst.next_dest_mst_chnl =
                                    conn_ptr->chnl[master_port][master_channel].mst.next_dest_mst_chnl;

                                /* 3. Set the primary master port to point to the
                                 * master that the slave previously pointed to
                                 * */
                                conn_ptr->chnl[master_port][master_channel].mst.next_dest_mst_port = non_primary_master_port;
                                conn_ptr->chnl[master_port][master_channel].mst.next_dest_mst_chnl = non_primary_master_channel;

                            } /* end if the slave destination is not the master port */

                        } /* end if is_broadcast ...etc. */

                        /* Base the slave information on the master primary channel */
                        if( (is_broadcast && is_slave_zone_primary) ||
                            (is_multicast && is_reader_primary) ||
                            (is_broadcast ==0 && is_multicast == 0) ||
                            conn_ptr->chnl[slave_port][slave_channel].slv.state == UTIL_GLOBAL_CHNL_START)
                        {
                            conn_ptr->chnl[slave_port][slave_channel].slv.state = util_global_state;
                            conn_ptr->chnl[slave_port][slave_channel].slv.is_broadcast = is_broadcast;
                            conn_ptr->chnl[slave_port][slave_channel].slv.is_multicast = is_multicast;
                        }

                    } /* end if valid_rid */
                } /* end for j (read queue id) */
            } /* end for i (dcs inst) */
            break;
        case CPB_INSTANCE_MCPB:
        case LAST_CPB_INSTANCE:
            PMC_ASSERT(FALSE,CPB_ERR_NO_SW_CONTENT, 0, 0);
            break;
    }


    if (CPB_INSTANCE_OCPB == cpb_handle->cfg.cpb_type ||
        CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type)
    {
        /*
         * Iterate over the connect array to determine if there is any
         * mis-alignment with respect to the dest_mst_port and the 
         * next_dest_mst_port. The algorithm above works from lowest to
         * highest. If the higher port type is the slave zone primary in
         * a broadcast case then the configuration of these fields will be
         * incorrect.
         */
        for (i = 0; i < 6; i++)
        {
            for(j=0;j<150;j++)
            {
                if (TRUE == conn_ptr->chnl[i][j].slv.is_broadcast ||
                    TRUE == conn_ptr->chnl[i][j].slv.is_multicast)
                {
                    UINT32 dest_port = conn_ptr->chnl[i][j].slv.dest_mst_port;
                    UINT32 dest_chnl = conn_ptr->chnl[i][j].slv.dest_mst_chnl;
                    
                    if (CPB_INDEX_LAST != dest_port &&
                        CPB_INDEX_LAST != dest_chnl &&
                        FALSE == conn_ptr->chnl[dest_port][dest_chnl].mst.is_slave_zone_primary)
                    {
                        /*
                         * If the slave_zone_primary is FALSE then want to
                         * have this hanging off the slave_zone_primary
                         * connected to the broadcast/multicast port. 
                         * Need to swap the dest_mst_port/chnnl of the 
                         * broadcast port with the next_dest_mst_port and
                         * then swap the next_port and the dest_port to
                         * correctly represent the configuration.
                         */
                        UINT32 next_port = conn_ptr->chnl[dest_port][dest_chnl].mst.next_dest_mst_port;
                        UINT32 next_chnl = conn_ptr->chnl[dest_port][dest_chnl].mst.next_dest_mst_chnl;
                        
                        if (CPB_INDEX_LAST != next_port && CPB_INDEX_LAST != next_chnl &&
                            TRUE == conn_ptr->chnl[next_port][next_chnl].mst.is_slave_zone_primary)
                        {
                            conn_ptr->chnl[i][j].slv.dest_mst_port = next_port;
                            conn_ptr->chnl[i][j].slv.dest_mst_chnl = next_chnl;
                            conn_ptr->chnl[next_port][next_chnl].mst.next_dest_mst_port = dest_port;
                            conn_ptr->chnl[next_port][next_chnl].mst.next_dest_mst_chnl = dest_chnl;
                            conn_ptr->chnl[dest_port][dest_chnl].mst.next_dest_mst_port = CPB_INDEX_LAST;
                            conn_ptr->chnl[dest_port][dest_chnl].mst.next_dest_mst_chnl = CPB_INDEX_LAST;
                        }
                    }
                }
            }
        }
    }
    /*initialize the bulk reprov indication variables*/
    cpb_oduksw_port_bulk_update_req_init(cpb_handle);

    PMC_RETURN();

} /* cpb_connect_data_state_get_recovery */

/*******************************************************************************
* cpb_connect_data_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function outputs the address of cpb_connect_data_t so the caller can 
*  store this pointer and make continuous reference to the cpb_connect_data_t.
*
*
* INPUTS:
*   *cpb_handle         - pointer to cpb handle instance
*
* OUTPUTS:
*   *conn_pptr          - the address of cpb_connect_data_t
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_connect_data_state_get(cpb_handle_t *cpb_handle, util_global_cpb_connect_t **conn_pptr)
{
    PMC_ENTRY();
    PMC_ASSERT(conn_pptr != NULL, CPB_ERR_INVALID_ARG, 0 , 0);

    *conn_pptr = cpb_handle->var.cpb_connect_data;
    PMC_RETURN();
} /* cpb_connect_data_state_get */

/*******************************************************************************
* cpb_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   For energy_state PMC_ENERGY_STATE_RUNNING:\n\n
*
*   This function sets all register space in the CPB subsystem that cannot be
*   reset to a default value to a default starting point value.\n\n
*
*   This operation is not idempotent.  In the event that any field initialized
*   by this function is modified by another function, this operation will
*   corrupt the expected state configured by the other function.\n\n
*
*   It is required to call this API once after bringing the subsystem out of
*   reset.\n\n
*
*   For energy_state PMC_ENERGY_STATE_RESET:\n\n
*
*   This function configures the CPB instance to the starting state for all
*   dynamic context.  All dynamic context will be returned to the initialization
*   values that were generate during the call to cpb_handle_init().\n\n
*
*   This function is for use by parent module layer.  As this function resets
*   dynamic context to starting state values, the parent module must only call
*   this function after externally resetting the CPB module using the device
*   level reset fields.\n\n
*
*
* INPUTS:
*   *h                          - pointer to cpb handle instance
*   energy_state                - enum defining state to set the CPB module to
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_init(cpb_handle_t *h, pmc_energy_state_t energy_state)
{
    UINT32 i;
    PMC_ENTRY();

    PMC_ASSERT(h!=NULL, UTIL_SCHD_ERR_INVALID_ARG, 0, 0);

    if(energy_state == PMC_ENERGY_STATE_RUNNING)
    {
        PMC_ATOMIC_YIELD(h->base.parent_handle,0);
        cpb_x_default_register_start_set(h);

        for(i=0; i < h->cfg.num_pages; i++)
        {
            pmpm_field_PWR_MODE_set(NULL, h, CPB_PMPM_INST_PMPM, i, 3);
            pmpm_field_PWR_MODE_set(NULL, h, CPB_PMPM_INST_PMPM_PL, i, 3);
            pmpm_field_PWR_MODE_set(NULL, h, CPB_PMPM_INST_PMPM_EOP, i, 3);
        }
    }
    else if(energy_state == PMC_ENERGY_STATE_RESET)
    {
        /* set dynamic memory to default values */
        cpb_var_t_ram_data_default_set(h, &(h->var));
        cpb_var_t_reg_data_update(h, &(h->var));
        /* Initialize the flags for Memory Usage by Functions */
        h->var.cpb_mem_pool_in_use[0] = FALSE;
        h->var.cpb_mem_pool_in_use[1] = FALSE;
        h->var.cpb_mem_pool_in_use[2] = FALSE;
        h->var.cpb_mem_pool_in_use[3] = FALSE;

        /* return all child modules to starting state */
        for(i=0; i < h->cfg.num_dcs; i++)
        {
            util_schd_init(h->util_schd_handle[i], energy_state);
        }
        cpb_connect_data_set_default(h);
    }
    else
    {
        PMC_ASSERT(FALSE, UTIL_SCHD_ERR_INVALID_ARG, 0, 0);
    }

    PMC_RETURN();

} /* cpb_init */


/*******************************************************************************
* cpb_start_state_test
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function identifies if any resources are provisioned against the
*   cpb instance.  It will test the channel state for all resources within
*   the cpb instance if any are not in UTIL_SCHD_CHNL_START state then
*   TRUE is returned, else FALSE.  Should TRUE be returned it can be assumed that
*   no resources are provisioned against the CPB instance and it would be
*   possible for the higher layer module to put the scheduler in lowpower standby
*   mode of operation.
*
*
* INPUTS:
*   *h                          - pointer to cpb handle instance
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   BOOL8                       - FALSE:  Resource(s) not in start state \n
*                                 TRUE:   Resources all in start state
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 cpb_start_state_test(cpb_handle_t *h)
{
    UINT32 i, page_index, block_index, index;
    PMC_ENTRY();
    PMC_ASSERT(h!=NULL, UTIL_SCHD_ERR_INVALID_ARG, 0, 0);

    /* confirm no entries provisioned against DCS */
    for(i=0; i < h->cfg.num_dcs; i++)
    {
        if(util_schd_start_state_test(h->util_schd_handle[i]) == FALSE)
            PMC_RETURN(FALSE);
    }

    /* confirm all PMPM pages and Blocks are available */
    for( page_index = 0; page_index < h->cfg.num_pages; page_index++)
    {
        if(h->var.page_inverted_page_table[page_index].ctrl_page_valid == 1)
            PMC_RETURN(FALSE);

        for(block_index = 0; block_index < h->cfg.blocks_per_page; block_index++)
        {
            index = page_index * h->cfg.blocks_per_page + block_index;
            if(h->var.block_inverted_page_table[index].ipt_valid == 1)
                PMC_RETURN(FALSE);
        }
    }

    PMC_RETURN(TRUE);

} /* cpb_start_state_test */

/*******************************************************************************
* cpb_dcs_db_entry_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for DCS instances that are
*   operating in data base content generation mode to have the database content
*   driven.\n\n
*
*   When operating in scheduler generation database mode, this API must be called
*   before cpb_chnl_prov() or cpb_ocpb_chnl_prov API so that resource allocation
*   checking can be performed.
*
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance
*   dcs_instance           - DCS block instance 1:1 mapped with egress_mux_input_port
*                            Valid values dcs_instances/egress_mux_input_port: 0 to 3
*   schd_addr              - DCS calendar offset to be set for egress_mux_output_port 
*                            and egress_mux_output_chnl data. \n
*                            Valid values 0 to 95.
*   egress_mux_output_port - Egress Mux Output Port.  Defines the subsystem
*                            that is to receive the data stream from CPB. In
*                            most cases this is 1:1 mapping with the egress
*                            mux input port.  The exception is DCPB in
*                            which case there are various mappings supported.
*   egress_mux_output_chnl - Egress Mux Output Port Channel.  Defines the
*                            DPI channel that will be used to transfer the
*                            channel data to downstream subsystem.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_db_entry_set( cpb_handle_t *cpb_handle,
                                       UINT32 dcs_instance,
                                       UINT32 schd_addr,
                                       UINT32 egress_mux_output_port,
                                       UINT32 egress_mux_output_chnl )
{
    UINT32 dummy, dcs_rd_channel_id;
    mapotn_db_rec rec;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* if data base does not exist return an error */
    if(cpb_handle->cfg.dcs_use_ctxt[dcs_instance].alloc_mode != UTIL_SCHD_ALLOC_METHOD_CPB_DCS)
    {
        result = CPB_ERR_UNSUPPORTED_SCHD_MODE;
    }

    /* retrieve dcs_rd_channel_id or C_RAM_CHANNEL value for the specified
       output channel. Note: Dummy values passed to write port related data
       in the following API call and output values ignored.
       For DCPB, non-cared about parameters may take a value of 3, 0, 3,
       other instantiations 0,0,0 is always correct */
    if(result == PMC_SUCCESS) {
        if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB)
        {
            result = cpb_chnl_prov_arg_check( cpb_handle,
                                              3,
                                              0,
                                              3,
                                              dcs_instance,
                                              egress_mux_output_port,
                                              egress_mux_output_chnl,
                                              &dummy,
                                              &dcs_rd_channel_id,
                                              &dummy,
                                              &dummy );
        }
        else
        {
            result = cpb_chnl_prov_arg_check( cpb_handle,
                                              0,
                                              0,
                                              0,
                                              dcs_instance,
                                              egress_mux_output_port,
                                              egress_mux_output_chnl,
                                              &dummy,
                                              &dcs_rd_channel_id,
                                              &dummy,
                                              &dummy );
        }
    }

    if(result == PMC_SUCCESS)
    {
        UINT32 test_egress_mux_output_port = 0;
        UINT32 test_egress_mux_output_port_chnl = 0;
        result = cpb_chnl_inst_mapping( cpb_handle,
                                        dcs_instance,
                                        dcs_rd_channel_id,
                                        &test_egress_mux_output_port,
                                        &test_egress_mux_output_port_chnl);
        PMC_LOG_TRACE("dcs_rd_channel_id=%u\n",dcs_rd_channel_id);
        PMC_LOG_TRACE("dcs_instance=%u\n",dcs_instance);
        PMC_LOG_TRACE("test_egress_mux_output_port=%u\n",test_egress_mux_output_port);
        PMC_LOG_TRACE("test_egress_mux_output_port_chnl=%u\n",test_egress_mux_output_port_chnl);
    }

    if(result == PMC_SUCCESS)
    {
        /* write schd_addr and dcs_rd_channel_id to the data base for
           the specified dcs_inst */
        PMC_MEMSET((void *)&rec, 0, sizeof(mapotn_db_rec));
        rec.channel_num = dcs_rd_channel_id;
        rec.calendar_entry = schd_addr;

        result = gen_db_add_record(&(cpb_handle->base),
                                   cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_id,
                                   cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_client_handle,
                                   (void *)&rec);

    }

    PMC_RETURN(result);

} /* cpb_dcs_db_entry_set */

/*******************************************************************************
* cpb_dcs_db_entry_set_all
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for DCS instances that are
*   operating in data base content generation mode to have the database content
*   driven.\n\n
*
*   This function allocates the requested number of calendar entries to the
*   specified channel.
*
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance
*   dcs_instance           - DCS block instance 1:1 mapped with egress_mux_input_port
*                            Valid values dcs_instances/egress_mux_input_port: 0 to 3
*   egress_mux_output_port - Egress Mux Output Port.  Defines the subsystem
*                            that is to receive the data stream from CPB. In
*                            most cases this is 1:1 mapping with the egress
*                            mux input port.  The exception is DCPB in
*                            which case there are various mappings supported.
*   egress_mux_output_chnl - Egress Mux Output Port Channel.  Defines the
*                            DPI channel that will be used to transfer the
*                            channel data to downstream subsystem.
*   num_cal_entries        - Number of calendar entries to allocate.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_db_entry_set_all( cpb_handle_t *cpb_handle,
                                           UINT32 dcs_instance,
                                           UINT32 egress_mux_output_port,
                                           UINT32 egress_mux_output_chnl,
                                           UINT32 num_cal_entries )
{
    UINT32 dummy, dcs_rd_channel_id;
    UINT32 *available_rec_array;
    mapotn_db_rec rec;
    UINT32 j;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* if data base does not exist return an error */
    if(cpb_handle->cfg.dcs_use_ctxt[dcs_instance].alloc_mode != UTIL_SCHD_ALLOC_METHOD_CPB_DCS)
    {
        result = CPB_ERR_UNSUPPORTED_SCHD_MODE;
    }

    PMC_LOG_TRACE("Call cpb_dcs_db_entry_set_all(): dcs_instance=%d, egress_mux_output_port=%d, egress_mux_output_chnl=%d, num_cal_entries=%d\n",
              dcs_instance,
              egress_mux_output_port,
              egress_mux_output_chnl,
              num_cal_entries);

    /* retrieve dcs_rd_channel_id or C_RAM_CHANNEL value for the specified
       output channel. Note: Dummy values passed to write port related data
       in the following API call and output values ignored.
       For DCPB, non-cared about parameters may take a value of 3, 0, 3,
       other instantiations 0,0,0 is always correct */
    if(result == PMC_SUCCESS) {
        if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB)
        {
            result = cpb_chnl_prov_arg_check( cpb_handle,
                                              3,
                                              0,
                                              3,
                                              dcs_instance,
                                              egress_mux_output_port,
                                              egress_mux_output_chnl,
                                              &dummy,
                                              &dcs_rd_channel_id,
                                              &dummy,
                                              &dummy );
        }
        else
        {
            result = cpb_chnl_prov_arg_check( cpb_handle,
                                              0,
                                              0,
                                              0,
                                              dcs_instance,
                                              egress_mux_output_port,
                                              egress_mux_output_chnl,
                                              &dummy,
                                              &dcs_rd_channel_id,
                                              &dummy,
                                              &dummy );
        }
    }

    if(result == PMC_SUCCESS)
    {
        UINT32 test_egress_mux_output_port = 0;
        UINT32 test_egress_mux_output_port_chnl = 0;
        result = cpb_chnl_inst_mapping( cpb_handle,
                                        dcs_instance,
                                                  dcs_rd_channel_id,
                                        &test_egress_mux_output_port,
                                        &test_egress_mux_output_port_chnl);
        PMC_LOG_TRACE("dcs_rd_channel_id=%u\n",dcs_rd_channel_id);
        PMC_LOG_TRACE("dcs_instance=%u\n",dcs_instance);
        PMC_LOG_TRACE("test_egress_mux_output_port=%u\n",test_egress_mux_output_port);
        PMC_LOG_TRACE("test_egress_mux_output_port_chnl=%u\n",test_egress_mux_output_port_chnl);
    }

    if(result == PMC_SUCCESS)
    {
        /* Get available locations */
        available_rec_array = (UINT32*)PMC_CALLOC(sizeof(UINT32)*96);
        PMC_ASSERT(available_rec_array != NULL, CPB_ERR_CODE_ASSERT, 0, 0);


        result = cpb_db_empty_rec_get(cpb_handle,
                                      num_cal_entries,
                                      cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_id,
                                      cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_client_handle,
                                      available_rec_array);
        if (result != PMC_SUCCESS) {
            PMC_FREE(&available_rec_array);
            PMC_RETURN(result);  /* if not enough available records return an error */
        }


        PMC_LOG_TRACE("cpb_dcs_db_entry_set_all(): num_cal_entries_empty=%d\n", num_cal_entries);

        /* write schd_addr and dcs_rd_channel_id to the data base for
           the specified dcs_inst */
        for(j=0; j<num_cal_entries; j++)
        {
            rec.channel_num = dcs_rd_channel_id;
            rec.calendar_entry = available_rec_array[j];

            PMC_LOG_TRACE("cpb_dcs_db_entry_set_all(): Allocate cal_slot: dcs_instance=%d, egress_mux_output_port=%d, channel_num=%d->%d, calendar_entry=%d\n",
                      dcs_instance,
                      egress_mux_output_port,
                      rec.channel_num,
                      egress_mux_output_chnl,
                      rec.calendar_entry);

            result = gen_db_add_record(&(cpb_handle->base),
                                       cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_id,
                                       cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_client_handle,
                                       (void *)&rec);
            if (result != PMC_SUCCESS) {
                PMC_FREE(&available_rec_array);
                PMC_RETURN(result);
            }
        }

        PMC_FREE(&available_rec_array);
    }




    PMC_RETURN(result);

} /* cpb_dcs_db_entry_set_all */

/*******************************************************************************
* cpb_dcs_db_entry_clear
* ______________________________________________________________________________
*
* DESCRIPTION:
*   PRELIMINARY API:  This function provides a method for DCS instances that are
*   operating in data base content generation mode to have the database content
*   driven to a value representing unused.\n\n
*
*   When operating in scheduler generation database mode, this API must be called
*   after cpb_chnl_deprov().
*
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance
*   dcs_instance           - DCS block instance 1:1 mapped with egress_mux_input_port
*                            Valid values dcs_instances/egress_mux_input_port: 0 to 3
*   egress_mux_output_port - Egress Mux Output Port.  Defines the subsystem
*                            that is to receive the data stream from CPB. In
*                            most cases this is 1:1 mapping with the egress
*                            mux input port.  The exception is DCPB in
*                            which case there are various mappings supported.
*   egress_mux_output_chnl - Egress Mux Output Port Channel.  Defines the
*                            DPI channel that will be used to transfer the
*                            channel data to downstream subsystem.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_db_entry_clear( cpb_handle_t *cpb_handle,
                                         UINT32 dcs_instance,
                                         UINT32 egress_mux_output_port,
                                         UINT32 egress_mux_output_chnl )
{
    UINT32 dummy, dcs_rd_channel_id;
    mapotn_db_rec rec;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* if data base does not exist return an error */
    if(cpb_handle->cfg.dcs_use_ctxt[dcs_instance].alloc_mode != UTIL_SCHD_ALLOC_METHOD_CPB_DCS)
    {
        result = CPB_ERR_UNSUPPORTED_SCHD_MODE;
    }

    /* retrieve dcs_rd_channel_id or C_RAM_CHANNEL value for the specified
       output channel. Note: Dummy values passed to write port related data
       in the following API call and output values ignored.
       For DCPB, non-cared about parameters may take a value of 3, 0, 3,
       other instantiations 0,0,0 is always correct       */
    if(result == PMC_SUCCESS) {
        if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB)
        {
            result = cpb_chnl_prov_arg_check( cpb_handle,
                                                  3,
                                                  0,
                                                  3,
                                                  dcs_instance,
                                                  egress_mux_output_port,
                                                  egress_mux_output_chnl,
                                                  &dummy,
                                                  &dcs_rd_channel_id,
                                                  &dummy,
                                                  &dummy );
        }
        else
        {
            result = cpb_chnl_prov_arg_check( cpb_handle,
                                                  0,
                                                  0,
                                                  0,
                                                  dcs_instance,
                                                  egress_mux_output_port,
                                                  egress_mux_output_chnl,
                                                  &dummy,
                                                  &dcs_rd_channel_id,
                                                  &dummy,
                                                  &dummy );
        }
    }

    if(result == PMC_SUCCESS)
    {
        /* clear the database entry for the rd_channel ID supplied */
        rec.channel_num = dcs_rd_channel_id;
        rec.calendar_entry = DO_NOT_USE_KEY;

        result = gen_db_rem_record(&(cpb_handle->base),
                                   cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_id,
                                   cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_client_handle,
                                   (void *)&rec);

    }

    PMC_RETURN(result);

} /* cpb_dcs_db_entry_clear */


/*******************************************************************************
* cpb_dcs_db_entry_clear
* ______________________________________________________________________________
*
* DESCRIPTION:
*   PRELIMINARY API:  This function provides a method for DCS instances that are
*   operating in data base content generation mode to have the database content
*   driven to a value representing unused.\n\n
*
*   When operating in scheduler generation database mode, this API must be called
*   after cpb_chnl_deprov().
*
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance
*   dcs_instance           - DCS block instance 1:1 mapped with egress_mux_input_port
*                            Valid values dcs_instances/egress_mux_input_port: 0 to 3
*   egress_mux_output_port - Egress Mux Output Port.  Defines the subsystem
*                            that is to receive the data stream from CPB. In
*                            most cases this is 1:1 mapping with the egress
*                            mux input port.  The exception is DCPB in
*                            which case there are various mappings supported.
*   egress_mux_output_chnl - Egress Mux Output Port Channel.  Defines the
*                            DPI channel that will be used to transfer the
*                            channel data to downstream subsystem.
*   calendar_entry         - calendar entry to remove
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_db_calendar_entry_clear( cpb_handle_t *cpb_handle,
                                                  UINT32 dcs_instance,
                                                  UINT32 egress_mux_output_port,
                                                  UINT32 egress_mux_output_chnl,
                                                  UINT32 calendar_entry)
{
    UINT32 dummy, dcs_rd_channel_id;
    mapotn_db_rec rec;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* if data base does not exist return an error */
    if(cpb_handle->cfg.dcs_use_ctxt[dcs_instance].alloc_mode != UTIL_SCHD_ALLOC_METHOD_CPB_DCS)
    {
        result = CPB_ERR_UNSUPPORTED_SCHD_MODE;
    }

    /* retrieve dcs_rd_channel_id or C_RAM_CHANNEL value for the specified
       output channel. Note: Dummy values passed to write port related data
       in the following API call and output values ignored.
       For DCPB, non-cared about parameters may take a value of 3, 0, 3,
       other instantiations 0,0,0 is always correct       */
    if(result == PMC_SUCCESS) {
        if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB)
        {
            result = cpb_chnl_prov_arg_check( cpb_handle,
                                                  3,
                                                  0,
                                                  3,
                                                  dcs_instance,
                                                  egress_mux_output_port,
                                                  egress_mux_output_chnl,
                                                  &dummy,
                                                  &dcs_rd_channel_id,
                                                  &dummy,
                                                  &dummy );
        }
        else
        {
            result = cpb_chnl_prov_arg_check( cpb_handle,
                                                  0,
                                                  0,
                                                  0,
                                                  dcs_instance,
                                                  egress_mux_output_port,
                                                  egress_mux_output_chnl,
                                                  &dummy,
                                                  &dcs_rd_channel_id,
                                                  &dummy,
                                                  &dummy );
        }
    }

    if(result == PMC_SUCCESS)
    {
        /* clear the database entry for the rd_channel ID supplied */
        rec.channel_num = dcs_rd_channel_id;
        rec.calendar_entry = calendar_entry;

        result = gen_db_rem_record(&(cpb_handle->base),
                                   cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_id,
                                   cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_client_handle,
                                   (void *)&rec);

    }

    PMC_RETURN(result);

} /* cpb_dcs_db_entry_clear_entry */

/*******************************************************************************
* cpb_dcs_db_num_entry_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for DCS instances that are
*   operating in data base content generation mode to have the database content
*   retrieved.
*
*
* INPUTS:
*   *cpb_handle             - pointer to CPB handle instance
*   dcs_instance            - DCS block instance 1:1 mapped with egress_mux_input_port
*                             Valid values dcs_instances/egress_mux_input_port: 0 to 3
*   egress_mux_output_port  - Egress Mux Output Port.  Defines the subsystem
*                             that is to receive the data stream from ODUKSW. In
*                             most cases this is 1:1 mapping with the egress
*                             mux input port.  The exception is DCPB in
*                             which case there are various mappings supported.
*   egress_mux_output_chnl  - Egress Mux Output Port Channel.  Defines the
*                             DPI channel that will be used to transfer the
*                             channel data to downstream subsystem.
*
* OUTPUTS:
*   *num_entries            - number of dcs entries provisioned for the channel
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_db_num_entry_get(cpb_handle_t *cpb_handle,
                                          UINT32 dcs_instance,
                                          UINT32 egress_mux_output_port,
                                          UINT32 egress_mux_output_chnl,
                                          UINT32 *num_entries)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 num_of_recs = 0;
    mapotn_db_key key;
    UINT32 dummy, dcs_rd_channel_id;

    PMC_ENTRY();

    /* if data base does not exist return an error */
    if(cpb_handle->cfg.dcs_use_ctxt[dcs_instance].alloc_mode != UTIL_SCHD_ALLOC_METHOD_CPB_DCS)
    {
        result = CPB_ERR_UNSUPPORTED_SCHD_MODE;
    }

    /* retrieve dcs_rd_channel_id or C_RAM_CHANNEL value for the specified
       output channel. Note: Dummy values passed to write port related data
       in the following API call and output values ignored.
       For DCPB, non-cared about parameters may take a value of 3, 0, 3,
       other instantiations 0,0,0 is always correct */
    if(result == PMC_SUCCESS) {
        if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB)
        {
            result = cpb_chnl_prov_arg_check( cpb_handle,
                                              3,
                                              0,
                                              3,
                                              dcs_instance,
                                              egress_mux_output_port,
                                              egress_mux_output_chnl,
                                              &dummy,
                                              &dcs_rd_channel_id,
                                              &dummy,
                                              &dummy );
        }
        else
        {
            result = cpb_chnl_prov_arg_check( cpb_handle,
                                              0,
                                              0,
                                              0,
                                              dcs_instance,
                                              egress_mux_output_port,
                                              egress_mux_output_chnl,
                                              &dummy,
                                              &dcs_rd_channel_id,
                                              &dummy,
                                              &dummy );
        }
    }

    if(result == PMC_SUCCESS)
    {
        /* query rd_channel_id data for the schd_addr */
        key.calendar_entry = DO_NOT_USE_KEY;
        key.channel_num = dcs_rd_channel_id;
        num_of_recs = gen_db_query_count(&(cpb_handle->base),
                                   cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_id,
                                   cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_client_handle,
                                   (void *)&key);


        if(num_of_recs == 0)
            PMC_LOG_TRACE("CPB DB Element: No records/entries found.\n");

        *num_entries = num_of_recs;


    }

    PMC_RETURN(result);

} /* cpb_dcs_db_num_entry_get */

/*******************************************************************************
* cpb_dcs_db_num_entry_by_rd_chnl_id_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for DCS instances that are
*   operating in data base content generation mode to have the database content
*   retrieved.
*
*
* INPUTS:
*   *cpb_handle             - pointer to CPB handle instance
*   dcs_instance            - DCS block instance 1:1 mapped with egress_mux_input_port
*                             Valid values dcs_instances/egress_mux_input_port: 0 to 3
*   rd_channel_id           - Read channel ID used in DCS
*
* OUTPUTS:
*   *num_entries            - number of dcs entries provisioned for the channel
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_db_num_entry_by_rd_chnl_id_get(cpb_handle_t *cpb_handle,
                                                        UINT32 dcs_instance,
                                                        UINT32 rd_channel_id,
                                                        UINT32 *num_entries)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 num_of_recs = 0;
    mapotn_db_key key;

    PMC_ENTRY();

    /* if data base does not exist return an error */
    if(cpb_handle->cfg.dcs_use_ctxt[dcs_instance].alloc_mode != UTIL_SCHD_ALLOC_METHOD_CPB_DCS)
    {
        result = CPB_ERR_UNSUPPORTED_SCHD_MODE;
    }

    if(result == PMC_SUCCESS)
    {
        /* query rd_channel_id data for the schd_addr */
        key.calendar_entry = DO_NOT_USE_KEY;
        key.channel_num = rd_channel_id;
        num_of_recs = gen_db_query_count(&(cpb_handle->base),
                                   cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_id,
                                   cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_client_handle,
                                   (void *)&key);


        if(num_of_recs == 0)
            PMC_LOG_TRACE("CPB DB Element: No records/entries found.\n");

        *num_entries = num_of_recs;


    }

    PMC_RETURN(result);

} /* cpb_dcs_db_num_entry_by_rd_chnl_id_get */

/*******************************************************************************
* cpb_dcs_db_entry_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for DCS instances that are
*   operating in data base content generation mode to have the database content
*   retrieved.
*
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance
*   dcs_instance           - DCS block instance 1:1 mapped with egress_mux_input_port
*                            Valid values dcs_instances/egress_mux_input_port: 0 to 3
*   schd_addr              - DCS calendar offset to be set for egress_mux_output_port 
*                            and egress_mux_output_chnl data. \n
*                            Valid values 0 to 95.
*
* OUTPUTS:
*   *egress_mux_output_port_ptr - Egress Mux Output Port.  Defines the subsystem
*                            that is to receive the data stream from CPB. In
*                            most cases this is 1:1 mapping with the egress
*                            mux input port.  The exception is DCPB in
*                            which case there are various mappings supported.
*   *egress_mux_output_chnl_ptr - Egress Mux Output Port Channel.  Defines the
*                                 DPI channel that will be used to transfer the
*                                 channel data to downstream subsystem.
*   rd_channel_id_ptr          - rd_channel_id / C_RAM_CHANNEL_ID data for the
*                                specified DCS instance.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_db_entry_get( cpb_handle_t *cpb_handle,
                                       UINT32 dcs_instance,
                                       UINT32 schd_addr,
                                       UINT32 *egress_mux_output_port_ptr,
                                       UINT32 *egress_mux_output_chnl_ptr,
                                       UINT32 *rd_channel_id_ptr )
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 num_of_recs = 0;
    mapotn_db_key    key;
    mapotn_db_query_res *q_result;

    PMC_ENTRY();

    /* confirm database associated with DCS instance */
    /* if data base does not exist return an error */
    if(cpb_handle->cfg.dcs_use_ctxt[dcs_instance].alloc_mode != UTIL_SCHD_ALLOC_METHOD_CPB_DCS)
    {
        result = CPB_ERR_UNSUPPORTED_SCHD_MODE;
    }

    if(result == PMC_SUCCESS)
    {
    /* query rd_channel_id data for the schd_addr */
        key.calendar_entry = schd_addr;
        key.channel_num = DO_NOT_USE_KEY;
        num_of_recs = gen_db_query(&(cpb_handle->base),
                                   cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_id,
                                   cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_client_handle,
                                   (void *)&key,
                                   (void **)&q_result);

        if(num_of_recs == 0)
        {
            PMC_RETURN(CPB_ERR_DB_ENTRY_NOT_FOUND);
        }

        PMC_LOG_TRACE("CPB DB Element: schd_addr=0x%x,cal rd_channel_id=0x%x,\n",
                   q_result->p_recs[0]->calendar_entry, q_result->p_recs[0]->channel_num);

        *rd_channel_id_ptr = q_result->p_recs[0]->channel_num;

        if(*rd_channel_id_ptr == DEFAULT_32BIT_INVALID) {
            *egress_mux_output_port_ptr = DEFAULT_32BIT_INVALID;
            *egress_mux_output_chnl_ptr = DEFAULT_32BIT_INVALID;
        } else {
            result = cpb_chnl_inst_mapping( cpb_handle,
                                            dcs_instance,
                                            *rd_channel_id_ptr,
                                            egress_mux_output_port_ptr,
                                            egress_mux_output_chnl_ptr);
        }
    }

    PMC_RETURN(result);

} /* cpb_dcs_db_entry_get */

/*******************************************************************************
* cpb_dcs_db_entry_all_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides a method for DCS instances that are
*   operating in data base content generation mode to have all database content
*   retrieved in the raw rd_channel_id C_RAM_CHANNEL_ID format.
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance
*   dcs_instance           - DCS block instance 1:1 mapped with egress_mux_input_port
*                            Valid values dcs_instances/egress_mux_input_port: 0 to 3
*
* OUTPUTS:
*   *rd_channel_id_ptr     - 96 element array that function will populate with
*                            rd_channel_id / C_RAM_CHANNEL_ID data for the
*                            specified DCS instance.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_db_entry_all_get( cpb_handle_t *cpb_handle,
                                       UINT32 dcs_instance,
                                       UINT32 *rd_channel_id_ptr )
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 i, num_of_recs;
    mapotn_db_key    key;
    mapotn_db_query_res *q_result;

    PMC_ENTRY();

    /* confirm database associated with DCS instance */
    /* if data base does not exist return an error */
    if(cpb_handle->cfg.dcs_use_ctxt[dcs_instance].alloc_mode != UTIL_SCHD_ALLOC_METHOD_CPB_DCS)
    {
        result = CPB_ERR_UNSUPPORTED_SCHD_MODE;
    }

    if(result == PMC_SUCCESS)
    {
        key.calendar_entry = CALENDAR_ENTRIES_NUM;
        key.channel_num = DO_NOT_USE_KEY;
        num_of_recs = gen_db_query(&(cpb_handle->base),
                                   cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_id,
                                   cpb_handle->cfg.dcs_use_ctxt[dcs_instance].db_client_handle,
                                   (void *)&key,
                                   (void **)&q_result);

        if(num_of_recs == 0)
        {
            PMC_RETURN(CPB_ERR_DB_ENTRY_NOT_FOUND);
        }

        for(i=0; i < 96; i++)
        {
            rd_channel_id_ptr[i] = q_result->p_recs[i]->channel_num;
        }
    }

    PMC_RETURN(result);

} /* cpb_dcs_db_entry_all_get */

/*******************************************************************************
*  cpb_db_empty_rec_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns an array of indices of empty records and checks if
*   there is enough empty records left for the num calendar entries.
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance
*   num_cal_entries       - number of calendar enrties required by the channel
*   db_id                 - database ID to access
*   db_handle             - handle to the database
*   *available_rec_array  - a pointer to array of empty indices in the DB
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_db_empty_rec_get(cpb_handle_t *cpb_handle,
                                       UINT32 num_cal_entries,
                                       util_gen_db_id_t db_id,
                                       UINT32 db_handle,
                                       UINT32 *available_rec_array)
{
    /* Variable declaration */
    UINT32 i;
    UINT32 available_rec_count;
    mapotn_db_key   key;
    UINT32          num_of_recs;
    mapotn_db_query_res *q_result;

    PMC_ENTRY();

    /* argument checking */
    PMC_ASSERT(cpb_handle != NULL, CPB_ERR_INVALID_ARG, 0, 0);

    /* initialize the array*/
    for(i = 0; i < 96; i++)
    {
        available_rec_array[i]= CPB_NULL_DB_REC;
    }

    /* get the list of all empty indices and store them in the array */
    available_rec_count = 0;
    for(i = 0; i < 96; i++)
    {
        key.calendar_entry = i;
        key.channel_num = DO_NOT_USE_KEY;
        num_of_recs = gen_db_query(&(cpb_handle->base),
                                 db_id,db_handle,
                                 (void *)&key,
                                 (void **)&q_result);

        if(num_of_recs == 0)
        {
            PMC_RETURN(CPB_ERR_DB_ENTRY_NOT_FOUND);
        }

        PMC_LOG_TRACE("1:n query result: i= %d, channel=0x%x,cal entry=0x%x, %s\n",
            i,q_result->p_recs[0]->channel_num,q_result->p_recs[0]->calendar_entry,  __FILE__);

        if(q_result->p_recs[0]->channel_num == 0xffffffff)
        {
            available_rec_array[available_rec_count] = i;
            available_rec_count++;
        }
    }

    PMC_LOG_TRACE( "available_rec_count = %u \n", available_rec_count);

    /* check if enough number of pages are available */
    if(num_cal_entries > available_rec_count)
    {
        /* return error the not enough pages available */
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_db_empty_rec_get */


/*******************************************************************************
* cpb_port_init_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function gets the initialization state of the slave DPI port, master
*   DPI port or the DCS instance.
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   port_type             - See cpb_port_type_t
*   port_id               - port id that needs to be tested
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   BOOL8                 - Port initialized state\n
*                           TRUE: initialized\n
*                           FALSE: not initialized
*
* NOTES:
*******************************************************************************/
PUBLIC BOOL8 cpb_port_init_state_get(cpb_handle_t *cpb_handle,
                                     cpb_port_type_t port_type,
                                     UINT32 port_id )
{
    PMC_ENTRY();

    PMC_ASSERT(port_type < LAST_CPB_PORT_TYPE, CPB_ERR_INVALID_ARG, 0 , 0);
    if(CPB_PORT_TYPE_DPI_SLAVE == port_type)/* slave port is initialized? */
    {
        PMC_ASSERT(port_id <= cpb_handle->cfg.max_slv_dpi_port, CPB_ERR_INVALID_ARG, 0 , 0);
        PMC_RETURN(cpb_handle->var.slv_dpi_port_init_flag[port_id]);
    } else if(CPB_PORT_TYPE_DPI_MASTER == port_type) { /* master port is initialized? */
        PMC_ASSERT(port_id <= cpb_handle->cfg.max_mst_dpi_port, CPB_ERR_INVALID_ARG, 0 , 0);
        PMC_RETURN(cpb_handle->var.mst_dpi_port_init_flag[port_id]);
    } else if(CPB_PORT_TYPE_DCS == port_type) { /* DCS initialized ? */
        PMC_ASSERT(port_id < cpb_handle->cfg.pop_port_num, CPB_ERR_INVALID_ARG, 0 , 0);
        PMC_RETURN(cpb_handle->var.dcs_inst_init_flag[port_id]);
    }
    PMC_RETURN(FALSE);
} /* cpb_port_init_state_get */

/*******************************************************************************
* cpb_dcpb_ingress_mux_output_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function initializes the SW driver to identify the data source for
*   Ingress Mux Output Port 0 and 1.  These ports provide the ability to
*   source data from either SIFD or CBRC/ENET_SYS.\n\n
*
*   The source specified in this function will be used to evaluate the
*   ability to transfer channels from an ingress mux input port, this data
*   will be used to reject channels upon a provisioning attempt.\n\n
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*   output_port           - Ingress Mux Output Port:\n
*                           0: Egress Mux Output Port 0 (from SIFD1)\n
*                           1: Egress Mux Output Port 1 (from SIFD2)
*   source                - Enum, data source for output_port\n
*                           1: SIFD1/SIFD2\n
*                           0: CBRC/ENET_SYS\n
*                           Where SIFD1 selected for output_port 0 and
*                           SIFD2 selected for output_port 1
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcpb_ingress_mux_output_init( cpb_handle_t *cpb_handle,
                                                   UINT32 output_port,
                                                   cpb_dcpb_igr_sifd_sel_t source )
{

    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(source < LAST_CPB_DCPB_IGR_SIFD_SEL, CPB_ERR_INVALID_ARG, 0 , 0);
    PMC_ASSERT(output_port <= CPB_DCPB_DPI_PORT_SIFD2, CPB_ERR_INVALID_ARG, 0 , 0);

    if (CPB_INSTANCE_DCPB != cpb_handle->cfg.cpb_type)
    {
        result = CPB_ERR_INVALID_CPB_TYPE;
    }

    if ( PMC_SUCCESS == result )
    {

        /* apply SIFD1_SEL and SIFD2_SEL for DCPB instantiation */
        result = cpb_mux_cpbd_src_sel_cfg(cpb_handle, output_port, source);
        if(result) PMC_RETURN(result);
    }

    PMC_RETURN(result);

} /* cpb_dcpb_ingress_mux_output_init */


/*******************************************************************************
* cpb_egress_mux_output_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function initializes resources associated with an egress mux
*   output port.  The function puts the port in reset/lowest energy
*   state or enables the port so that it may transfer channel data to
*   the downstream subsystem.\n\n
*
*   The sifd_xfer argument provides addition interface configuration for SIFD
*   connected ports.  This is only valid for DCPB and OCPB instantiations of CPB.\n\n
*
*   Note: for emulation CPB, it also enables the DCS
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   output_port           - Egress Mux Output Port
*   sifd_xfer             - SIFD Interlaken Interface Transfer Format, see
*                           cpb_xfer_mode_t.
*   mode                  - State of Egress Mux Output Port\n
*                           0: Disabled\n
*                           1: Enabled
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_egress_mux_output_init( cpb_handle_t *h,
                                             UINT32 output_port,
                                             cpb_xfer_mode_t sifd_xfer,
                                             UINT32 mode )
{

    cpb_burst_mode_t burst_mode;
    cpb_xfer_mode_type_t xfer_mode;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* argument checking */
    PMC_ASSERT(mode < 2, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(h->cfg.cpb_type < LAST_CPB_INSTANCE, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(sifd_xfer < LAST_CPB_BURST_XFER, CPB_ERR_INVALID_ARG, 0, 0);

    /* provide base settings for xfer_mode and burst_mode */
    xfer_mode = CPB_XFER_MODE_TYPE_SEGMENT;
    burst_mode = CPB_BURST_WORD;

    /* modify base settings for SIFD ports */
    if( ( CPB_INSTANCE_MCPB != h->cfg.cpb_type) &&
        ( 0 == output_port || 1 == output_port ) )
    {
        /* extract transfer type and burst size settings from input arguments */
        cpb_port_burst_element_get(sifd_xfer, &xfer_mode, &burst_mode);
    }

    result = cpb_dpi_mstr_port_zone_cfg(h, output_port, mode);
    if(result) PMC_RETURN(result);

    if(mode == 1)
    {
        h->var.mst_dpi_port_init_flag[output_port] = TRUE;
    } else {
        h->var.mst_dpi_port_init_flag[output_port] = FALSE;
    }

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_egress_mux_output_init */

/*******************************************************************************
* cpb_ingress_mux_input_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function initializes an input port of the CPB Ingress Mux.  This
*   function will perform CPB instantiation specific configuration of the
*   respective port.
*
*
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   input_port            - Ingress Mux Input Port, identifies the subsystem
*                           associated port to be enabled
*   cpb_xfer_mode         - Enum, defining the output interface type.  Only
*                           valid for SIFD ports.  Otherwise transfer modes
*                           internally set.\n
*                           Only valid DCPB/OCPB instantiations for input_port
*                           0 and 1.
*   hdr_removal_size      - header size for header removal config
*                           supported values : 0-6 bytes\n
*                           set to 0 for the port not supporting header removal
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_ingress_mux_input_init( cpb_handle_t *h,
                                             UINT32 input_port,
                                             cpb_xfer_mode_t cpb_xfer_mode,
                                             UINT32 hdr_removal_size)
{

    cpb_burst_mode_t burst_mode = (cpb_burst_mode_t)0;
    cpb_xfer_mode_type_t xfer_mode;
    UINT32 i, j;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* argument checking */
    PMC_ASSERT(h->cfg.cpb_type < LAST_CPB_INSTANCE, CPB_ERR_INVALID_ARG, 0, 0);

    PMC_ASSERT(input_port <= h->cfg.max_slv_dpi_port, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(cpb_xfer_mode < LAST_CPB_BURST_XFER, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(hdr_removal_size <= CPB_MAX_HDR_SIZE, CPB_ERR_INVALID_ARG, 0, 0);

    if(hdr_removal_size > 0)
    {
        PMC_ASSERT(h->cfg.cpb_type != CPB_INSTANCE_MCPB, CPB_ERR_INVALID_ARG, 0, 0);
        PMC_ASSERT(input_port <= CPB_DCPB_DPI_PORT_SIFD2, CPB_ERR_INVALID_ARG, 0, 0);
        PMC_ASSERT(cpb_xfer_mode != CPB_SEGMENT && cpb_xfer_mode != CPB_PACKET, CPB_ERR_INVALID_ARG, 0, 0);
    }

    /* provide base settings for xfer_mode and burst_mode */
    xfer_mode = CPB_XFER_MODE_TYPE_SEGMENT;
    burst_mode = CPB_BURST_WORD;

    /* modify base settings for SIFD ports */
    if( ( CPB_INSTANCE_MCPB != h->cfg.cpb_type ) &&
        ( CPB_DCPB_DPI_PORT_SIFD1 == input_port || CPB_DCPB_DPI_PORT_SIFD2 == input_port ) )
    {
        /* extract transfer type and burst size settings from input arguments */
        cpb_port_burst_element_get(cpb_xfer_mode, &xfer_mode, &burst_mode);
    }

    /*  ZONE configuration for the slave port */
    /*  Overide value unconditionally set to 3 */
    result = cpb_dpi_slave_port_zone_cfg(h, input_port,
                        h->cfg.max_dpi_slv_chnl_id[input_port], CPB_SLV_DPI_DROP_ZONE_3, burst_mode);

    if (result) PMC_RETURN(result);

    result = cpb_dpi_slave_port_burst_cfg(h, input_port, burst_mode);
    if (result) PMC_RETURN(result);

    /* configure the header removal for SIFD port */
    result = cpb_dpi_slave_port_hdr_remove_cfg(h, input_port, hdr_removal_size);

    if(result == PMC_SUCCESS){

        /* For DCPB SIFD1/SIFD2 Ports force XOFF backpressure towards SIFD for all channels */
        if(CPB_INSTANCE_DCPB == h->cfg.cpb_type &&
           (input_port == CPB_DCPB_DPI_PORT_SIFD1 ||
            input_port == CPB_DCPB_DPI_PORT_SIFD2))
            {
                i = (input_port==CPB_DCPB_DPI_PORT_SIFD1 ? 0:1);
                for(j = 0; j <= h->cfg.max_dpi_mst_chnl_id[i]; j++)
                {
                    result = cpb_dpi_slave_port_chnl_zone_ovrd_cfg(h, input_port, j, CPB_SLV_CHNL_ZONE_FORCE,0,0);
                    if(result != PMC_SUCCESS)
                    {
                        break; /* exit loop on error */
                    }
                }
            }
    }

    h->var.slv_dpi_port_init_flag[input_port] = TRUE;

    PMC_RETURN(result);
} /* cpb_ingress_mux_input_init */

/*******************************************************************************
* cpb_mcpb_mux_mode_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function initializes the ingress mux and the egress mux to select between
*   system side and line side.
*
* INPUTS:
*   *h            - pointer to CPB handle instance.
*   mux_mode      - See cpb_mcpb_mux_mode_t
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_mcpb_mux_mode_init(cpb_handle_t *h,
                                        cpb_mcpb_mux_mode_t mux_mode)
{
    UINT32 ingress_sel = 1;
    UINT32 egress_sel = 0;
    PMC_ERROR result;
    PMC_ENTRY();

    /* argument checking */
    PMC_ASSERT(CPB_INSTANCE_MCPB == h->cfg.cpb_type, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(mux_mode < LAST_CPB_MCPB_MUX_MODE, CPB_ERR_INVALID_ARG, 0, 0);

    if(CPB_MCPB_MUX_MODE_DISABLED == mux_mode) PMC_RETURN(PMC_SUCCESS);
    if(CPB_MCPB_MUX_MODE_ENET_SYS == mux_mode) /*system side*/
    {
        ingress_sel = 1;
        egress_sel = 1;
    } else { /*line side*/
        ingress_sel = 0;
        egress_sel = 0;
    }
    /*configuring the ingress mux*/
    result = cpb_mux_mgmt_src_sel_cfg(h, ingress_sel);
    if(result) PMC_RETURN(result);

    /*configuring the egress mux*/
    result = cpb_mux_mgmt_dest_sel_cfg(h, egress_sel);
    if(result) PMC_RETURN(result);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_mcpb_mux_mode_init */

/*******************************************************************************
* cpb_mcpb_mux_mode_init_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function retrieves the MCPB mux configuration that selects MCPB
*  interconnection between ENET_LINE or ENET_SYS subsystems.\n\n
*
*  Will assert if configuation is incoherent.
*
* INPUTS:
*   *h             - pointer to CPB handle instance
*
* OUTPUTS:
*  None.
*
* RETURNS:
*   cpb_mcpb_mux_mode_t - either CPB_MCPB_MUX_MODE_ENET_SYS,  
*                         CPB_MCPB_MUX_MODE_ENET_LINE or LAST_UTIL_GLOBAL_MCPB_PORT
*                         should the register settings be incoherent.
*
* NOTES:
*
*******************************************************************************/
PUBLIC cpb_mcpb_mux_mode_t cpb_mcpb_mux_mode_init_get(cpb_handle_t *h)
{
    cpb_mcpb_mux_mode_t rc;

    PMC_ENTRY();
    
    PMC_ASSERT(CPB_INSTANCE_MCPB == h->cfg.cpb_type, CPB_ERR_INVALID_CPB_TYPE, 0, 0);

    if(1 == h->var.mcpb_im_sel.igr_ext_sel &&
       1 == h->var.mcpb_im_sel.egr_ext_sel &&
       1 == h->var.mcpb_im_sel.reflect_sel &&
       1 == h->var.mcpb_em_sel.em_egr_ext_sel &&
       1 == h->var.mcpb_em_sel.em_igr_ext_sel)
    {
        rc = CPB_MCPB_MUX_MODE_ENET_SYS;
    }
    else if(0 == h->var.mcpb_im_sel.igr_ext_sel &&   
            0 == h->var.mcpb_im_sel.egr_ext_sel &&   
            0 == h->var.mcpb_im_sel.reflect_sel &&   
            0 == h->var.mcpb_em_sel.em_egr_ext_sel &&
            0 == h->var.mcpb_em_sel.em_igr_ext_sel)  
    {
        rc = CPB_MCPB_MUX_MODE_ENET_LINE;
    }
    else
    {
        rc = LAST_CPB_MCPB_MUX_MODE;
    }
    PMC_RETURN(rc);
} /* cpb_mcpb_mux_mode_init_get() */

/*******************************************************************************
* cpb_chnl_range_check
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function checks the input and output channel range.
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   input_port            - ingress mux input port id
*   input_port_chnl       - ingress mux input port chnl id
*   output_port           - egress mux output port id
*   output_port_chnl      - egress mux output port chnl id
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_chnl_range_check( cpb_handle_t *h,
                                       UINT32 input_port,
                                       UINT32 input_port_chnl,
                                       UINT32 output_port,
                                       UINT32 output_port_chnl)
{
    PMC_ENTRY();

    /* argument checking */
    PMC_ASSERT(input_port <= h->cfg.max_slv_dpi_port, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(output_port <= h->cfg.max_mst_dpi_port, CPB_ERR_INVALID_ARG, 0, 0);

    if(input_port_chnl > h->cfg.max_dpi_slv_chnl_id[input_port])
        PMC_RETURN(CPB_ERR_CHNL_OUT_RANGE);
    if(output_port_chnl > h->cfg.max_dpi_mst_chnl_id[output_port])
        PMC_RETURN(CPB_ERR_CHNL_OUT_RANGE);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_chnl_range_check */

/*******************************************************************************
* cpb_egress_mux_input_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function initializes resources associated with an egress mux input
*   port for the CPB subsystem.\n\n
*
*   The function performs initialization of the DCS
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   input_port            - Egress Mux Input Port:\n
*                           0: Egress Mux Input Port 0\n
*                           1: Egress Mux Input Port 1\n
*                           2: Egress Mux Input Port 2\n
*                           3: Egress Mux Input Port 3
*   cpb_xfer_mode         - Enum, defining the output interface type.  Only
*                           valid for SIFD ports.  Otherwise transfer modes
*                           internally set.\n
*                           Only valid when mode is set to 2.
*   mode                  - See cpb_dcs_instance_mode_t, mode set to 2 only valid 
*                           for input_port set to 0 or 1
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_egress_mux_input_init( cpb_handle_t *cpb_handle,
                                            UINT32 input_port,
                                            cpb_xfer_mode_t cpb_xfer_mode,
                                            cpb_dcs_instance_mode_t mode )
{
    cpb_burst_mode_t burst_mode;
    cpb_xfer_mode_type_t xfer_mode;
    UINT32 ch_xoff_mode;
    UINT32 link_xoff_mode;
    UINT32 burst_credit_mode;
    UINT32 packet_credit_mode;
    UINT32 dest;
    UINT32 enable;
    PMC_ERROR result = PMC_SUCCESS;
    BOOL8 match;

    PMC_ENTRY();

    /* argument checking */
    PMC_ASSERT(cpb_handle->cfg.cpb_type < LAST_CPB_INSTANCE, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(cpb_xfer_mode < LAST_CPB_BURST_XFER, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(mode < LAST_CPB_DCS_MODE, CPB_ERR_INVALID_ARG, 0, 0);


    /* provide base settings for xfer_mode and burst_mode */
    xfer_mode = CPB_XFER_MODE_TYPE_SEGMENT;
    burst_mode = CPB_BURST_WORD;

    /* modify base settings for SIFD ports */
    if( ( CPB_INSTANCE_MCPB != cpb_handle->cfg.cpb_type ) &&
        ( CPB_DCPB_DPI_PORT_SIFD1 == input_port || CPB_DCPB_DPI_PORT_SIFD2 == input_port ))
    {
        /* extract transfer type and burst size settings from input arguments */
        if ( (CPB_INSTANCE_OCPB == cpb_handle->cfg.cpb_type &&  CPB_DCS_EN_SIFD == mode)
             || (CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type && CPB_DCS_EN_SIFD == mode) )
        {
            cpb_port_burst_element_get(cpb_xfer_mode, &xfer_mode, &burst_mode);
        }
    }

    /* Apply xfer_mode and burst_mode settings */
    if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type)
    {
        if(CPB_MCPB_POP_PORT_2 == input_port || CPB_MCPB_POP_PORT_3 == input_port)
            xfer_mode = CPB_XFER_MODE_TYPE_PACKET;
    }
    result = cpb_dcs_burst_xfer_mode_cfg(cpb_handle, input_port, xfer_mode, burst_mode);
    if (result) PMC_RETURN(result);


    /* set channel and link xoff behavior as a function of CPB type and port properties */
    link_xoff_mode = CPB_XOFF_SEG_BOUNDARY;
    ch_xoff_mode = CPB_XOFF_SEG_BOUNDARY;

    /* Set credit/quantum modes as a function of CPB type and port properties */
    burst_credit_mode = 0;
    packet_credit_mode = 0;

    /* modify base settings for DCPB & OCPB SIFD ports */
    if( ( CPB_INSTANCE_MCPB != cpb_handle->cfg.cpb_type) &&
        ( CPB_DCPB_DPI_PORT_SIFD1 == input_port || CPB_DCPB_DPI_PORT_SIFD2 == input_port ))
    {
        if ( (CPB_INSTANCE_OCPB == cpb_handle->cfg.cpb_type && CPB_DCS_EN_SIFD == mode)
             || (CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type && CPB_DCS_EN_SIFD == mode))
        {
            link_xoff_mode = CPB_XOFF_BRST_BOUNDARY;

            if ( CPB_XFER_MODE_TYPE_PACKET == xfer_mode )
            {
                /* SIFD Channel behavior for Packet Transfers */
                ch_xoff_mode = CPB_XOFF_PKT_BOUNDARY;
                packet_credit_mode = 1;
            } else {
                if (burst_mode == CPB_BURST_WORD)
                {
                    ch_xoff_mode = CPB_XOFF_SEG_BOUNDARY;
                } else
                {
                /* SIFD Channel behavior for Segment Transfers */
                ch_xoff_mode = CPB_XOFF_BRST_BOUNDARY;
                burst_credit_mode = 1;
                }
            }
        }
    }
    /* modify base settings for all MCPB ports */
    else if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type)
    {
        ch_xoff_mode =  CPB_XOFF_SEG_BOUNDARY;
    }

    /* apply xoff response behavior configuration */
    result = cpb_dcs_xoff_cfg( cpb_handle, input_port,
                               CPB_XOFF_TYPE_LINK,
                               (cpb_xoff_mode_t)link_xoff_mode );
    if(result) PMC_RETURN(result);
    result = cpb_dcs_xoff_cfg( cpb_handle, input_port,
                               CPB_XOFF_TYPE_CHANNEL,
                               (cpb_xoff_mode_t)ch_xoff_mode );
    if(result) PMC_RETURN(result);

    /* apply credit behavior configuration */
    result = cpb_dcs_credit_cfg( cpb_handle, input_port,
                               CPB_CREDIT_TYPE_BURST,
                               burst_credit_mode);
    if(result) PMC_RETURN(result);
    result = cpb_dcs_credit_cfg( cpb_handle, input_port,
                                 CPB_CREDIT_TYPE_PACKET,
                                 packet_credit_mode);
    if(result) PMC_RETURN(result);

    /* apply SIFD1_SEL and SIFD2_SEL for DCPB instantiation */
    if( CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type  &&
        ( CPB_DCPB_DPI_PORT_SIFD1 == input_port || CPB_DCPB_DPI_PORT_SIFD2 == input_port ))
    {
        dest = (CPB_DCS_EN_SIFD == mode)? 1:0;
        result = cpb_mux_cpbd_dest_sel_cfg(cpb_handle, input_port, dest);
        if(result) PMC_RETURN(result);
        if(CPB_DCPB_DPI_PORT_SIFD1 == input_port) cpb_handle->var.dcpb_em_sifd1_sel = dest;
        if(CPB_DCPB_DPI_PORT_SIFD2 == input_port) cpb_handle->var.dcpb_em_sifd2_sel = dest;
        PMC_LOG_TRACE("cpb_handle->var.dcpb_em_sifd1_sel = %u\n",cpb_handle->var.dcpb_em_sifd1_sel);
    }

    /* for MCPB, configure the alternate queue mode for DCS 0 and 1 */
    if( CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type  && input_port < CPB_MCPB_POP_PORT_2 )
    {
        dcs_field_DCS_QUEUE_OFFSET_set( NULL, cpb_handle, input_port, 1 );
    } else {
        dcs_field_DCS_QUEUE_OFFSET_set( NULL, cpb_handle, input_port, 0 );
    }

    /* DCS Top of Calendar Configuration */
    if( CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type  &&
        (input_port == CPB_DCPB_POP_PORT_2 || input_port == CPB_DCPB_POP_PORT_3))

    {
        cpb_dcs_page_ctrl_cfg(cpb_handle, input_port, 1, 0 );
    }

    /* DCS Initialization */


    if (mode)
    {
        /* test channel state to ensure all channels are in the
           START state */
        result = cpb_dcs_common_state_check( cpb_handle, input_port,
                                             &match);
        if(result) PMC_RETURN(result);
        if(FALSE == match) PMC_RETURN(CPB_ERR_CHANNEL_ALLOC_AGAINST_DCS);

        /* scheduler online and offline pages with starting state
           data */
        result = cpb_dcs_page_update_and_swap(cpb_handle, input_port);
        if(result) PMC_RETURN(result);

    } else {
        /* uninitialize the WRR scheduler */
        /* Note, no operation as no power savings associated with scheduler */

    }

    enable = (mode != CPB_DCS_DISABLED)? 1:0;
    result = cpb_dcs_enable(cpb_handle, input_port, enable);
    if(enable == 1)
    {
        cpb_handle->var.dcs_inst_init_flag[input_port] = TRUE;
    } else {
        cpb_handle->var.dcs_inst_init_flag[input_port] = FALSE;
    }

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_egress_mux_input_init */

/*******************************************************************************
* cpb_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function processes the requested data path and evaluates if device
*   resources are available.  If not available an error is returned, otherwise
*   channel provisioning operations are performed against the device.  It is
*   testing to ensure:\n
*        The block is a DCPB instantiation of CPB\n
*        Specified resources are not provisioned against another channel.\n
*        CFC FIFO resources are available\n
*        WRR scheduler entries are available\n
*        Ingress and Egress Mux Input/Output pairs are valid for the hardware\n
*        The first added channel will be the zone master\n\n
*
*   The requested data is processed as a function of the CPB instantiation
*   type.\n\n
*
*   This function provisions a queue within a queue system for usage by a
*   channel.\n\n
*
*   It stores the user input data in SW context for use by subsequent function
*   calls.
*
*
* INPUTS:
*   *cpb_handle                 - pointer to CPB handle instance.
*   ingress_mux_input_port      - Ingress Mux Input Port.  Defines the subsystem
*                                 CPB channel data to be received from.
*   ingress_mux_input_port_chnl - Ingress Mux Input Port Channel.  Defines the
*                                 DPI channel from the Ingress Mux Input Port to be
*                                 transferred through CPB.
*   ingress_mux_egress_port     - Ingress Mux Egress Port.  Defines the set of queue
*                                 systems that will transfer the channel data.  In
*                                 most cases this is a 1:1 mapping with
*                                 ingress_mux_input_port.  The exception is DCPB
*                                 where CBRC, MAPOTN and ENET_LINE have options as
*                                 to which ingress mux egress port they may use.
*   egress_mux_input_port       - Egress Mux Input Port.  Defines the DCS instance
*                                 to process the outbound data stream.
*   egress_mux_output_port      - Egress Mux Output Port.  Defines the subsystem
*                                 that is to receive the data stream from CPB. In
*                                 most cases this is 1:1 mapping with the egress
*                                 mux input port.  The exception is DCPB in
*                                 which case there are various mappings supported.
*   egress_mux_output_port_chnl - Egress Mux Output Port Channel.  Defines the
*                                 DPI channel that will be used to transer the
*                                 channel data to downstream subsystem.
*   rate                        - Channel rate.  The channel rate is defined as:
*                                 rate * 10^(rate_units)
*   rate_units                  - Units of channel rate
*   cpb_data                    - CPB data format.  Used for internal calculations
*                                 of FIFO depth\n
*                                 0: CBR\n
*                                 1: Packet (assumes MTU/MRU of 9600 bytes)
*   halt_buffer                 - CPB FIFO buffer room to capture in flight data in
*                                 the event that CPB FIFO generates an upstream flow
*                                 control signal.  Used in cases where ENET utilizes
*                                 pause flow control and where a channel is fed from
*                                 SIFD and asserts XOFF flow control.  halt_buffer is
*                                 specified in units of blocks.  The block size is:
*                                 DCPB: 12288 bytes
*   hdr_en                      - Header removal enable\n
*                                 0: Disable header removal\n
*                                 1: Enable header removal
*   backup_mode                 - If TRUE for DCPB CBRC input port, will provision 
*                                 channel excluding DCS and DPI Master Port.
*                                 Intended for 10GE fault replacement application.
*                                 Otherwise set to FALSE.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_chnl_prov( cpb_handle_t *cpb_handle,
                                UINT32 ingress_mux_input_port,
                                UINT32 ingress_mux_input_port_chnl,
                                UINT32 ingress_mux_egress_port,
                                UINT32 egress_mux_input_port,
                                UINT32 egress_mux_output_port,
                                UINT32 egress_mux_output_port_chnl,
                                UINT32 rate,
                                util_schd_chnl_rate_exp_t rate_units,
                                UINT32 cpb_data,
                                UINT32 halt_buffer,
                                UINT32 hdr_en,
                                BOOL8 backup_mode)
{
    PMC_ERROR result;
    PMC_ENTRY();
    /* test if DCPB instantiation, if not return error */
    if(cpb_handle->cfg.cpb_type != CPB_INSTANCE_DCPB)
       PMC_RETURN(CPB_ERR_INVALID_CPB_TYPE);

    /* call cpb_util_chnl_prov */
    result = cpb_util_chnl_prov(cpb_handle,
                                ingress_mux_input_port,
                                ingress_mux_input_port_chnl,
                                ingress_mux_egress_port,
                                egress_mux_input_port,
                                egress_mux_output_port,
                                egress_mux_output_port_chnl,
                                rate,
                                rate_units,
                                cpb_data,
                                halt_buffer,
                                hdr_en,
                                backup_mode);


    PMC_RETURN(result);

} /* cpb_chnl_prov */

/*******************************************************************************
* cpb_chnl_backup_swap
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs a swap between an inbound ENET stream and CBRC.\n\n
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance.
*   ingress_mux_input_port      - ENET_LINE or ENET_SYS interface
*   ingress_mux_input_port_chnl - ENET_LINE or ENET_SYS channel
*   use_backup                  - FALSE: ENET_LINE/ENET_SYS source of
*                                 inbound data, TRUE: CBRC source of
*                                 inbound data
*   
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_chnl_backup_swap(cpb_handle_t *cpb_handle, UINT32 ingress_mux_input_port, UINT32 ingress_mux_input_port_chnl, BOOL8 use_backup)
{
    UINT32 dcs_inst = 0, rd_channel_id = 0, rd_queue_id = 0, i;
    util_schd_chnl_state_t chnl_state = LAST_UTIL_SCHD_CHNL;
    UINT32 dcs_rd_channel_id, dcs_sf1_push_port_id, dcs_sf2_wr_queue_id;
    UINT32 cbrc_slv_dpi_channel_id = ~0, cbrc_rd_queue_id = ~0;

    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* retrieve the push port id for identifying QSn_CH_EN */
    result = cpb_dcs_egress_dpi_chnl_source_get(cpb_handle, 
                                                cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_port,
                                                cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_chnl,
                                                &dcs_inst, &rd_channel_id,
                                                &rd_queue_id);    

    if(result == PMC_SUCCESS)
    {
         result = util_schd_dcs_chnl_data_get(cpb_handle->util_schd_handle[dcs_inst],
                                              rd_queue_id,
                                              &chnl_state,
                                              &dcs_rd_channel_id,
                                              &dcs_sf1_push_port_id,
                                              &dcs_sf2_wr_queue_id);
        if(result == PMC_SUCCESS && chnl_state != UTIL_SCHD_CHNL_OPERATIONAL && chnl_state != UTIL_SCHD_CHNL_BACKUP)
            PMC_ASSERT(FALSE, CPB_ERR_CODE_ASSERT, 0, 0);
    }

    for(i = 0 ; i < cpb_handle->cfg.max_fifo_num && result == PMC_SUCCESS; i++)
    { 
        if(i != rd_queue_id)
        {
             result = util_schd_dcs_chnl_data_get(cpb_handle->util_schd_handle[dcs_inst],
                                                  i, /* read qid */
                                                  &chnl_state,
                                                  &dcs_rd_channel_id,
                                                  &dcs_sf1_push_port_id,
                                                  &dcs_sf2_wr_queue_id);
            if(dcs_rd_channel_id == rd_channel_id &&
               dcs_sf2_wr_queue_id >= DCPB_SLV_PORT_2_CH_OFFSET &&
               dcs_sf2_wr_queue_id < (DCPB_SLV_PORT_2_CH_OFFSET + 12) &&
               (chnl_state == UTIL_SCHD_CHNL_OPERATIONAL || chnl_state == UTIL_SCHD_CHNL_BACKUP))
            {
                cbrc_rd_queue_id = i;
                cbrc_slv_dpi_channel_id = dcs_sf2_wr_queue_id - DCPB_SLV_PORT_2_CH_OFFSET;
                break;
            }
        }
    }

    if(use_backup)
    {
        if(result == PMC_SUCCESS)
        {
            result = cpb_dcs_page_update_and_swap_with_chnl_enbl(cpb_handle, dcs_inst,
                                                                 TRUE, 
                                                                 ingress_mux_input_port, ingress_mux_input_port_chnl, rd_queue_id, 
                                                                 (UINT32)UTIL_GLOBAL_CPB_PORT_CBRC, cbrc_slv_dpi_channel_id, cbrc_rd_queue_id);
        }    
    }
    else
    {
        if(result == PMC_SUCCESS)
        {
            result = cpb_dcs_page_update_and_swap_with_chnl_enbl(cpb_handle, dcs_inst,
                                                                 TRUE, 
                                                                 (UINT32)UTIL_GLOBAL_CPB_PORT_CBRC, cbrc_slv_dpi_channel_id, cbrc_rd_queue_id,
                                                                 ingress_mux_input_port, ingress_mux_input_port_chnl, rd_queue_id);
        }
    }

    PMC_ASSERT(result==PMC_SUCCESS, CPB_ERR_CODE_ASSERT, 0, 0);

    PMC_RETURN();    

} /* cpb_chnl_backup_swap */

/*******************************************************************************
* cpb_chnl_backup_status
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function determines if the backup path (CBRC) or the ENET_LINE or
*   ENET_SYS channel is sourcing the inbound data stream.
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance.
*   ingress_mux_input_port      - ENET_LINE or ENET_SYS interface
*   ingress_mux_input_port_chnl - ENET_LINE or ENET_SYS channel
*
* OUTPUTS:
*   *use_backup_ptr             - TRUE: CBRC source inbound data, FALSE: ENET_LINE 
*                                 or ENET_SYS source of inbound data
*
* RETURNS:
*   PMC_ERROR         -  PMC_SUCCESS otherwise meaningful error code.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_chnl_backup_status(cpb_handle_t *cpb_handle, UINT32 ingress_mux_input_port, UINT32 ingress_mux_input_port_chnl, BOOL8 *use_backup_ptr)
{
/*
    - returns if the CBRC or ENET_LINE/SYS is the current data source to the MAPOTN
    - find the enet_line/sys context and cbrc context and determines who is OPERATIONAL vs BACKUP
*/

    UINT32 dcs_inst = 0, rd_channel_id = 0, rd_queue_id = 0, i;
    util_schd_chnl_state_t chnl_state = LAST_UTIL_SCHD_CHNL, enet_state = LAST_UTIL_SCHD_CHNL, cbrc_state = LAST_UTIL_SCHD_CHNL;
    UINT32 dcs_rd_channel_id, dcs_sf1_push_port_id, dcs_sf2_wr_queue_id;
    UINT32 cbrc_slv_dpi_channel_id, cbrc_rd_queue_id;
    UINT32 enet_qsn_ch_en_offset = 999, cbrc_qsn_ch_en_offset = 999;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    *use_backup_ptr = FALSE;

    /* Confirm the input port and channel is mapped and activted in DCPB */
    if(cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.state == UTIL_GLOBAL_CHNL_OPERATIONAL ||
       cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.state == UTIL_GLOBAL_CHNL_BACKUP)
    {
        /* retrieve the push port id for identifying QSn_CH_EN */
        result = cpb_dcs_egress_dpi_chnl_source_get(cpb_handle, 
                                                    cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_port,
                                                    cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_chnl,
                                                    &dcs_inst, &rd_channel_id,
                                                    &rd_queue_id);  
        if(result == PMC_SUCCESS)
        {
             result = util_schd_dcs_chnl_data_get(cpb_handle->util_schd_handle[dcs_inst],
                                                  rd_queue_id,
                                                  &enet_state,
                                                  &dcs_rd_channel_id,
                                                  &enet_qsn_ch_en_offset,
                                                  &dcs_sf2_wr_queue_id);
            if(result == PMC_SUCCESS && enet_state != UTIL_SCHD_CHNL_OPERATIONAL && enet_state != UTIL_SCHD_CHNL_BACKUP)
                PMC_ASSERT(FALSE, CPB_ERR_CODE_ASSERT, 0, 0);
        }

        for(i = 0 ; i < cpb_handle->cfg.max_fifo_num && result == PMC_SUCCESS; i++)
        { 
            if(i != rd_queue_id)
            {
                 result = util_schd_dcs_chnl_data_get(cpb_handle->util_schd_handle[dcs_inst],
                                                      i, /* read qid */
                                                      &chnl_state,
                                                      &dcs_rd_channel_id,
                                                      &dcs_sf1_push_port_id,
                                                      &dcs_sf2_wr_queue_id);
                if(dcs_rd_channel_id == rd_channel_id &&
                   dcs_sf2_wr_queue_id >= DCPB_SLV_PORT_2_CH_OFFSET &&
                   dcs_sf2_wr_queue_id < (DCPB_SLV_PORT_2_CH_OFFSET + 12) &&
                   (chnl_state == UTIL_SCHD_CHNL_OPERATIONAL || chnl_state == UTIL_SCHD_CHNL_BACKUP))
                {
                    cbrc_rd_queue_id = i;
                    cbrc_slv_dpi_channel_id = dcs_sf2_wr_queue_id - DCPB_SLV_PORT_2_CH_OFFSET;
                    cbrc_qsn_ch_en_offset = dcs_sf1_push_port_id;
                    cbrc_state = chnl_state;
                    break;
                }
            }
        }
        if(cbrc_qsn_ch_en_offset == 999) result = CPB_ERR_NO_BACKUP_SETUP;
        PMC_ASSERT(cbrc_state != enet_state, CPB_ERR_CODE_ASSERT, 0, 0);

        if(cbrc_state == UTIL_SCHD_CHNL_OPERATIONAL && enet_state == UTIL_SCHD_CHNL_BACKUP)
            *use_backup_ptr = TRUE;

    }
    else
    {
        result = CPB_ERR_NO_BACKUP_SETUP;
    }

    PMC_RETURN(result);

} /* cpb_chnl_backup_status */

/*******************************************************************************
* cpb_ocpb_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function processes the requested data path and evaluates if device
*   resources are available.  If not available an error is returned, otherwise
*   channel provisioning operations are performed against the device.  It is
*   testing to ensure:\n
*        The block is a OCPB instantiation of CPB\n
*        Specified resources are not provisioned against another channel.\n
*        CFC FIFO resources are available\n
*        WRR scheduler entries are available\n
*        Ingress and Egress Mux Input/Output pairs are valid for the hardware\n
*        The first added channel will be the zone master
*
*
*   This function provisions a queue within a queue system for usage by a
*   channel.\n\n
*
*   It stores the user input data in SW context for use by subsequent function
*   calls.
*
*
* INPUTS:
*
*   *cpb_handle       - pointer to CPB handle instance.
*   input_port        - Source slave DPI port.
*   input_port_chnl   - Source slave DPI port channel id.
*   output_port       - Destination master DPI port.
*   output_port_chnl  - Destination master DPI port channel id.
*   rate              - Channel rate. The channel rate is defined as:
*                       rate * 10^(rate_units)
*   rate_units        - Units of channel rate
*   halt_buffer       - CPB FIFO buffer room to capture in flight data in
*                       the event that CPB FIFO generates an upstream flow
*                       control signal.  Used in cases where ENET utilizes
*                       pause flow control and where a channel is fed from
*                       SIFD and asserts XOFF flow control.  halt_buffer is
*                       specified in units of blocks.  The block size is:
*                       OCPB: 768 bytes
*   hdr_en            - Header removal enable\n
*                           0: Disable header removal\n
*                           1: Enable header removal
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_ocpb_chnl_prov( cpb_handle_t *cpb_handle,
                                     UINT32 input_port,
                                     UINT32 input_port_chnl,
                                     UINT32 output_port,
                                     UINT32 output_port_chnl,
                                     UINT32 rate,
                                     util_schd_chnl_rate_exp_t rate_units,
                                     UINT32 halt_buffer,
                                     UINT32 hdr_en )
{
    PMC_ERROR result;
    UINT32 cpb_data;

    PMC_ENTRY();

    /* test if OCPB instantiation, if not return error */
    if(cpb_handle->cfg.cpb_type != CPB_INSTANCE_OCPB)
       PMC_RETURN(CPB_ERR_INVALID_CPB_TYPE);

    cpb_data = 0;/* OCPB is all CBR data */
    
    PMC_ATOMIC_YIELD(cpb_handle->base.parent_handle,0);
    /* call cpb_util_chnl_prov */
    result = cpb_util_chnl_prov( cpb_handle,
                                 input_port,
                                 input_port_chnl,
                                 input_port,
                                 output_port,
                                 output_port,
                                 output_port_chnl,
                                 rate,
                                 rate_units,
                                 cpb_data,
                                 halt_buffer,
                                 hdr_en,
                                 FALSE );

    PMC_RETURN(result);

} /* cpb_ocpb_chnl_prov */

/*******************************************************************************
* cpb_util_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This is a utiity function that performs channel provisioning of an CPB
*   intstantiation type.  Intstatiation specific wrapper functions are exported
*   for other modules to access this API.\n\n
*
*   This function processes the requested data path and evaluates if device
*   resources are available.  If not available an error is returned, otherwise
*   channel provisioning operations are performed against the device.  It is
*   testing to ensure:\n
*        Specified resources are not provisioned against another channel.\n
*        CFC FIFO resources are available\n
*        WRR scheduler entries are available\n
*        Ingress and Egress Mux Input/Output pairs are valid for the hardware\n
*        The first added channel will be the zone master\n\n
*
*   The requested data is processed as a function of the CPB instantiation
*   type.\n\n
*
*   This function provisions a queue within a queue system for usage by a
*   channel.\n\n
*
*   It stores the user input data in SW context for use by subsequent function
*   calls.
*
*
* INPUTS:
*
*   *cpb_handle                 - pointer to CPB handle instance.
*   ingress_mux_input_port      - Ingress Mux Input Port.  Defines the subsystem
*                                 CPB channel data to be received from.
*   ingress_mux_input_port_chnl - Ingress Mux Input Port Channel.  Defines the
*                                 DPI channel from the Ingress Mux Input Port to be
*                                 transferred through CPB.
*   ingress_mux_egress_port     - Ingress Mux Egress Port.  Defines the set of queue
*                                 systems that will transfer the channel data.  In
*                                 most cases this is a 1:1 mapping with
*                                 ingress_mux_input_port.  The exception is DCPB
*                                 where CBRC, MAPOTN and ENET_LINE have options as
*                                 to which ingress mux egress port they may use.
*   egress_mux_input_port       - Egress Mux Input Port.  Defines the DCS instance
*                                 to process the outbound data stream.
*   egress_mux_output_port      - Egress Mux Output Port.  Defines the subsystem
*                                 that is to receive the data stream from CPB. In
*                                 most cases this is 1:1 mapping with the egress
*                                 mux input port.  The exception is DCPB in
*                                 which case there are various mappings supported.
*   egress_mux_output_port_chnl - Egress Mux Output Port Channel.  Defines the
*                                 DPI channel that will be used to transer the
*                                 channel data to downstream subsystem.
*   rate                        - Channel rate.  The channel rate is defined as:
*                                 rate * 10^(rate_units)
*   rate_units                  - Units of channel rate
*   cpb_data                    - CPB data format.  Used for internal calculations
*                                 of FIFO depth\n
*                                 0: CBR\n
*                                 1: Packet (assumes MTU/MRU of 9600 bytes)
*   halt_buffer                 - CPB FIFO buffer room to capture in flight data in
*                                 the event that CPB FIFO generates an upstream flow
*                                 control signal.  Used in cases where ENET utilizes
*                                 pause flow control and where a channel is fed from
*                                 SIFD and asserts XOFF flow control.  halt_buffer is
*                                 specified in units of blocks.  The block size for
*                                 each CPB instatiation is:\n
*                                 DCPB: 12288 bytes\n
*                                 MCPB: 384 bytes\n
*                                 OCPB: 768 bytes
*   hdr_en                      - Header removal enable\n
*                                   0: Disable header removal\n
*                                   1: Enable header removal
*   backup_mode                 - If TRUE for DCPB CBRC input port, will provision 
*                                 channel excluding DCS and DPI Master Port.
*                                 Intended for 10GE fault replacement application.
*                                 Otherwise set to FALSE.
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_util_chnl_prov( cpb_handle_t *cpb_handle,
                                      UINT32 ingress_mux_input_port,
                                      UINT32 ingress_mux_input_port_chnl,
                                      UINT32 ingress_mux_egress_port,
                                      UINT32 egress_mux_input_port,
                                      UINT32 egress_mux_output_port,
                                      UINT32 egress_mux_output_port_chnl,
                                      UINT32 rate,
                                      util_schd_chnl_rate_exp_t rate_units,
                                      UINT32 cpb_data,
                                      UINT32 halt_buffer,
                                      UINT32 hdr_en,
                                      BOOL8  backup_mode)
{
    UINT32 i, zone_bypass;
    UINT32 rd_channel_id, wr_channel_id;
    UINT32 num_blocks = 0;
    UINT32 *current_page_array;
    UINT32 read_qid = CPB_BLOCK_RQID_NIL, queue_index, write_qid;
    UINT32 num_current_pages, num_requested_pages, num_available_blocks, num_additional_blocks;
    PMC_ERROR ret_val = PMC_SUCCESS;
    UINT32 num_current_blocks;
    UINT32 isbroadcast = 0, ismulticast = 0; /* test if the connection is a broadcast or multicast connection */
    util_schd_chnl_ctxt_t *p_chnl_ctxt;
    UINT32 zone_source;
    UINT32 fifo_end_addr = 0;
    UINT32 pop_port_id;
    BOOL8 ilkn_source = FALSE;
    UINT32 block_leak_master_port, block_leak_master_channel;

    cpb_dpi_chnl_zone_mode_t zone_mode;

    PMC_ENTRY();

    PMC_ASSERT(cpb_handle != NULL, CPB_ERR_CTXT_NOT_INITIALIZED, 0,0);
    /* for backup mode ensure that only CBRC -> MAPOTN paths in DCPB are supported */
    if(backup_mode == TRUE) PMC_ASSERT(cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB, CPB_ERR_CODE_ASSERT, 0, 0);
    if(backup_mode == TRUE) PMC_ASSERT(ingress_mux_input_port == (UINT32)UTIL_GLOBAL_CPB_PORT_CBRC, CPB_ERR_CODE_ASSERT, 0, 0);
    if(backup_mode == TRUE) PMC_ASSERT(egress_mux_output_port == (UINT32)UTIL_GLOBAL_CPB_PORT_MAPOTN, CPB_ERR_CODE_ASSERT, 0, 0);

    cpb_handle->var.cpb_mem_pool_in_use[4] = TRUE; /* This indicates we are inside this API */

    if (0 == rate)
    {
        ret_val = CPB_ERR_INVALID_ARG;
    }

    if(PMC_SUCCESS == ret_val)
    {
        /* check if the connection is valid, and determine the write and read channel id */
        ret_val =  cpb_chnl_prov_arg_check( cpb_handle,
                                            ingress_mux_input_port,
                                            ingress_mux_input_port_chnl,
                                            ingress_mux_egress_port,
                                            egress_mux_input_port,
                                            egress_mux_output_port,
                                            egress_mux_output_port_chnl,
                                            &wr_channel_id,
                                            &rd_channel_id,
                                            &write_qid,
                                            &read_qid );
        PMC_LOG_TRACE("\nCPB Provisioning channel: \ninput port %u, \ninput port channel %u, \noutput port %u, \noutput port channel %u, \npush port id = %u \npop port id = %u\n", ingress_mux_input_port,
        ingress_mux_input_port_chnl,
        egress_mux_output_port,
        egress_mux_output_port_chnl,
        ingress_mux_egress_port,
        egress_mux_input_port);
    }


    if(pmc_cpb_pmpm_block_remap(&cpb_handle->base) && PMC_SUCCESS == ret_val)
    {
        /* If there is a block leak, caused during a block remap, then try to
        * release it */
        cpb_remap_clean(cpb_handle,
                        &block_leak_master_port,
                        &block_leak_master_channel);
    }

    /* test is channel is in valid state for provisioning operation */
    if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB && PMC_SUCCESS == ret_val)
    {
        ret_val = cpb_chnl_state_verify(cpb_handle, egress_mux_input_port, read_qid, UTIL_SCHD_CHNL_START);
    }

    /* function exit point for following clean up scope */
    if(PMC_SUCCESS != ret_val)
    {
        cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE;  
        PMC_RETURN(ret_val);
    }
    /* memory allocation */
    current_page_array = cpb_mem_pool_assign(cpb_handle, CPB_MEM_POOL_ID_0);
    PMC_ASSERT(current_page_array != NULL, CPB_ERR_CODE_ASSERT, 0, 0);

    /* MCPB Master Port 5 reads from QS2 */
    if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && egress_mux_output_port == CPB_MCPB_EGR_FEGE)
    {
        pop_port_id = CPB_MCPB_POP_PORT_2;
    } else {
        pop_port_id = egress_mux_input_port;
    }

    /* get the read queue id and checking broadcast and multicast if not MCPB , for MCPB it's done in
       cpb_chnl_prov_arg_check, and there is no multicast and broadcast */
    if(cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB && PMC_SUCCESS == ret_val)
    {
        /* determine the read queue id */
        read_qid = CPB_BLOCK_RQID_NIL;
        for(i = 0 ; i < cpb_handle->cfg.max_fifo_num; i++)
        { 
            queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, pop_port_id, i);
            if(CPB_FIFO_NOT_USED == cpb_handle->var.fifo_var_data[queue_index].status)
            {
                read_qid = i;
                break;
            }
        }
        if(CPB_BLOCK_RQID_NIL == read_qid)
        {
            ret_val = CPB_ERR_NO_RD_QID;
        }

        /* Check that the DPI output port and channel is not already provisioned. This check is more useful than
        * checking the read queue id state because for DCPB and OCPB, read queue id isn't a fixed mapping to
        * the DPI port and channel */
        if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB && PMC_SUCCESS == ret_val)
        {
            ret_val = cpb_dcpb_check_output_not_provisioned(cpb_handle,
                                                            egress_mux_input_port,
                                                            read_qid,
                                                            egress_mux_output_port,
                                                            egress_mux_output_port_chnl);
            if(backup_mode == TRUE)
            {
                PMC_ASSERT(ret_val == CPB_ERR_CHNL_ALREADY_EXISTS, CPB_ERR_CODE_ASSERT, 0, 0);
                ret_val = PMC_SUCCESS;
            }
        }
        else if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_OCPB && PMC_SUCCESS == ret_val)
        {
            ret_val = cpb_ocpb_check_output_not_provisioned(cpb_handle,
                                                            egress_mux_input_port,
                                                            read_qid,
                                                            egress_mux_output_port,
                                                            egress_mux_output_port_chnl);
        }

        if(PMC_SUCCESS == ret_val)
        {
            /* check if the connection is a multicast */
            ismulticast = 0;
            num_current_blocks = 0;
            ret_val = cpb_qs_current_pages_get(cpb_handle,ingress_mux_egress_port,pop_port_id,&num_current_pages,current_page_array);
        }

        if(PMC_SUCCESS == ret_val)
        {
            cpb_queue_num_current_blocks_get(cpb_handle, write_qid, num_current_pages, current_page_array, &num_current_blocks);
    
            if(0 != num_current_blocks)
            {
                PMC_LOG_TRACE("The requested connection is a multicast! \n");
                ismulticast = 1;
                PMC_ASSERT(backup_mode == FALSE, CPB_ERR_CODE_ASSERT, 0, 0);
            }
        }

        /* check if the connection is a broadcast, only when the chnl is not a multicast chnl */
        isbroadcast = 0;
        if(0 == ismulticast)
        {/* if the chnl is not a multicast chnl, then see if it is a broadcast chnl */
            for(i = 0; i < cpb_handle->cfg.pop_port_num && PMC_SUCCESS == ret_val; i++)
            {
                num_current_blocks = 0;
                if(pop_port_id != i)
                {
                    ret_val = cpb_qs_current_pages_get(cpb_handle,ingress_mux_egress_port,i,&num_current_pages,current_page_array);
                    if(PMC_SUCCESS == ret_val)
                    {
                        cpb_queue_num_current_blocks_get(cpb_handle, write_qid, num_current_pages, current_page_array, &num_current_blocks);
                    }
                }
                if(0 != num_current_blocks)
                {
                    PMC_LOG_TRACE("The requested connection is a broadcast! \n");
                    isbroadcast = 1;
                    PMC_ASSERT(backup_mode == FALSE, CPB_ERR_CODE_ASSERT, 0, 0);
                    break;
                }
            }
        }
    }

    /* test is channel is in valid state for provisioning operation */
    if(PMC_SUCCESS == ret_val)
    {
        ret_val = cpb_chnl_state_verify(cpb_handle, egress_mux_input_port, read_qid, UTIL_SCHD_CHNL_START);
    }

    /* rate checking, need to keep the same as the primary reader, only when BC or MC */
    if(1 == ismulticast && PMC_SUCCESS == ret_val)
    { /* if is a multicast chnl, look the DCS for the primary chnl and check the rate*/
        p_chnl_ctxt = cpb_handle->util_schd_handle[egress_mux_input_port]->var.schd_ctxt->chnl_ctxt;
        for(i = 0 ; i < cpb_handle->cfg.max_fifo_num && PMC_SUCCESS == ret_val; i++)
        {
            queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, i);
            if( cpb_handle->var.fifo_var_data[queue_index].push_port_id == ingress_mux_egress_port &&
                   cpb_handle->var.fifo_var_data[queue_index].write_id == write_qid)
            {
                if(p_chnl_ctxt[i].rate != rate || p_chnl_ctxt[i].rate_units != rate_units)
                {
                    ret_val = CPB_ERR_CHNL_RATE_INCORRECT;
                }
                break;
            }
        }
    } else if(1 == isbroadcast && PMC_SUCCESS == ret_val) {
        /* if the chnl is a broadcast, need to keep the same rate as the BC Primary the rate*/
        ret_val = cpb_dpi_slave_port_chnl_zone_source_get(cpb_handle, ingress_mux_input_port,
                                                          ingress_mux_input_port_chnl, &zone_source);

        p_chnl_ctxt = cpb_handle->util_schd_handle[zone_source]->var.schd_ctxt->chnl_ctxt;
        for(i = 0 ; i < cpb_handle->cfg.max_fifo_num && PMC_SUCCESS == ret_val; i++)
        {
            queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, zone_source, i);
            if(cpb_handle->var.fifo_var_data[queue_index].push_port_id == ingress_mux_egress_port &&
               cpb_handle->var.fifo_var_data[queue_index].write_id == write_qid)
            {
                if(p_chnl_ctxt[i].rate != rate || p_chnl_ctxt[i].rate_units != rate_units)
                {
                    ret_val = CPB_ERR_CHNL_RATE_INCORRECT;
                }
                break;
            }
        }
    }

    /* calculate the number of blocks based on the rate information */
    if(PMC_SUCCESS == ret_val)
    {
        if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type)
        {
            ret_val = cpb_determine_num_blocks(cpb_handle, pop_port_id, ingress_mux_input_port, read_qid, rate, rate_units, halt_buffer, FALSE, &num_blocks);
        }
        else
        {
            if(CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type &&
               (CPB_DCPB_DPI_PORT_SIFD1 == ingress_mux_input_port ||
                CPB_DCPB_DPI_PORT_SIFD2 == ingress_mux_input_port))
            {
                ilkn_source = TRUE;
            }
            ret_val = cpb_determine_num_blocks(cpb_handle, pop_port_id, ingress_mux_input_port, rd_channel_id, rate, rate_units, halt_buffer, ilkn_source, &num_blocks);
        }
        PMC_LOG_TRACE("\nnumber of requested blocks: %u\n", num_blocks );
    }

    if (PMC_SUCCESS == ret_val && CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type)
    {

        queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, read_qid);
        cpb_handle->var.fifo_var_data[queue_index].write_id = write_qid;
        cpb_handle->var.fifo_var_data[queue_index].status = CPB_FIFO_BEING_USED;

        cpb_handle->var.fifo_var_data[queue_index].push_port_id = ingress_mux_egress_port;
    }

    /* verify that physical pages and blocks assigned with push/pop pair are available,
       else assign, else error out */
    if(0 == ismulticast && PMC_SUCCESS == ret_val)
    {

        /*check if there is PMPM pages assigned to the push/pop pair */
        ret_val = cpb_qs_current_pages_get(cpb_handle,
                                           ingress_mux_egress_port,
                                           pop_port_id,
                                           &num_current_pages,
                                           current_page_array);

        if(0 == num_current_pages && PMC_SUCCESS == ret_val)
        { /* allocate pages if there is no PMPM page enough for the requested connection */
            PMC_ASSERT(cpb_handle->cfg.blocks_per_page != 0, CPB_ERR_DIVIDED_BY_ZERO,0,0);
            num_requested_pages = (num_blocks / (cpb_handle->cfg.blocks_per_page)) + ((num_blocks % cpb_handle->cfg.blocks_per_page == 0)?0:1);
            PMC_LOG_TRACE("\nnumber of requested pages: %u\n", num_requested_pages );
            ret_val = cpb_pmpm_queue_system_page_assign(cpb_handle,
                                                        ingress_mux_egress_port,
                                                        pop_port_id,
                                                        egress_mux_input_port,
                                                        num_requested_pages);
        } else {
            /*if there is not enough pages for the push/pop pair, allocate new PMPM pages*/
            if(PMC_SUCCESS == ret_val)
            {
                ret_val = cpb_current_avail_blocks_get(cpb_handle,
                                                       num_current_pages,
                                                       current_page_array,
                                                       &num_available_blocks);
                if(num_available_blocks < num_blocks && PMC_SUCCESS == ret_val)
                {
                    num_additional_blocks = num_blocks - num_available_blocks;
                    PMC_ASSERT(cpb_handle->cfg.blocks_per_page != 0,CPB_ERR_DIVIDED_BY_ZERO,0,0);
                    num_requested_pages = num_current_pages + num_additional_blocks / cpb_handle->cfg.blocks_per_page;
                    num_requested_pages = (num_additional_blocks % cpb_handle->cfg.blocks_per_page) ? num_requested_pages + 1: num_requested_pages;
                    ret_val = cpb_pmpm_queue_system_page_assign(cpb_handle,
                                                                ingress_mux_egress_port,
                                                                pop_port_id,
                                                                egress_mux_input_port,
                                                                num_requested_pages);
                }
            }
        }
    }

    /* perform DCS channel provisioning, always do regardless of BC or MC */
    if(PMC_SUCCESS == ret_val)
    {
        ret_val = cpb_dcs_chnl_prov( cpb_handle,
                                     egress_mux_input_port,
                                     read_qid,
                                     rd_channel_id,
                                     write_qid,
                                     ingress_mux_egress_port,
                                     rate,
                                     rate_units,
                                     (backup_mode == TRUE ? TRUE:FALSE));
    }

    /* allocate SCPB resource, port/channel configuration, based on different cases */
    if(0 == ismulticast && PMC_SUCCESS == ret_val)
    {
        /* build a fifo for the channel cuz it is a primary channel */
        ret_val = cpb_queue_build(cpb_handle,
                                  ingress_mux_egress_port,
                                  pop_port_id,                                 
                                  write_qid,
                                  read_qid,
                                  num_blocks);

        PMC_ATOMIC_YIELD(cpb_handle->base.parent_handle,0);
        /* configure the SLV DPI port channel to queue association to the first reader in QS */
        if(PMC_SUCCESS == ret_val)
        {
            ret_val = cpb_dpi_slave_port_chnl_rd_queue_map_cfg(cpb_handle, ingress_mux_input_port,
                                                               ingress_mux_input_port_chnl,
                                                               pop_port_id,
                                                               read_qid);
        }

        /* if this connection is neither a multicast nor a broadcast,
        this is a BC primary link, need to configure zone master*/
        if(0 == isbroadcast && PMC_SUCCESS == ret_val)
        {

            /* push port selection cfg only for DCPB */
            if(CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type)
            {
                PMC_ATOMIC_YIELD(cpb_handle->base.parent_handle,0);
                ret_val = cpb_dpi_slave_port_chnl_ing_mux_output_port_sel_cfg(cpb_handle,
                                                                        ingress_mux_input_port,
                                                                        ingress_mux_input_port_chnl,
                                                                        0,
                                                                        ingress_mux_egress_port);
            }


            if(PMC_SUCCESS == ret_val)
            {
                ret_val = cpb_dpi_slave_port_chnl_zone_thresh_cfg(cpb_handle,
                                                                  ingress_mux_input_port,
                                                                  ingress_mux_input_port_chnl,
                                                                  num_blocks*cpb_handle->cfg.bursts_per_block/4,
                                                                  num_blocks*cpb_handle->cfg.bursts_per_block/2,
                                                                  3*num_blocks*cpb_handle->cfg.bursts_per_block/4);
            }

            if(PMC_SUCCESS == ret_val)
            {
                cpb_dpi_slave_port_chnl_zone_source_cfg(cpb_handle,
                                                        ingress_mux_input_port,
                                                        ingress_mux_input_port_chnl,
                                                        0,
                                                        pop_port_id);
                /* if is not a multicast or a broadcast, mark the newly built chnl
                   as a primary chnl*/
                queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, read_qid);
                cpb_handle->var.fifo_var_data[queue_index].chnl_type = CPB_SLAVE_ZONE_PRIMARY;

                PMC_LOG_TRACE("\nMark the channel as primary channel...\nport = %u\nchnl = %u",egress_mux_output_port,egress_mux_output_port_chnl);

                /*set zone_mode as a function of the downstream block providing XON/XOFF status
                    need to investigate if the xon/xoff source from the downstream block will always return XON
                    if it is in a mode that does not toggle the XON/XOFF state */
                ret_val = cpb_dpi_slave_port_chnl_map_cfg(cpb_handle,
                                                          ingress_mux_input_port,
                                                          ingress_mux_input_port_chnl,
                                                          egress_mux_output_port,
                                                          egress_mux_output_port_chnl);
            }


            /* configure the DPI Slave Port ZONE override config */
            if(PMC_SUCCESS == ret_val && 
               (CPB_INSTANCE_DCPB != cpb_handle->cfg.cpb_type ||
               (CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type &&
                (egress_mux_output_port != CPB_DCPB_DPI_PORT_SIFD1 &&
                 egress_mux_output_port != CPB_DCPB_DPI_PORT_SIFD2))))
            {
                zone_mode = CPB_SLV_CHNL_ZONE_FIFO;
                ret_val = cpb_dpi_slave_port_chnl_zone_ovrd_cfg(cpb_handle,
                                                                ingress_mux_input_port,
                                                                ingress_mux_input_port_chnl,
                                                                zone_mode,0,0);
            }
            else
            {
                if(PMC_SUCCESS == ret_val)
                {
                    /* If the master is a DCPB SIFD channel, we might need to use
                     * zone bypass mode */
                    cpb_sifd_chnl_ctxt_get(cpb_handle, egress_mux_output_port, egress_mux_output_port_chnl, &zone_bypass);
                    switch(zone_bypass)
                    {
                            case 0:
                                zone_mode = CPB_SLV_CHNL_ZONE_FIFO;
                                break;
                            case 1:
                                zone_mode = CPB_SLV_CHNL_ZONE_FIFO_AND_MSTR_XOFF;
                                break;
                            default:
                                PMC_ASSERT(FALSE, CPB_ERR_CODE_ASSERT, 0, 0);
                                break;
                    }
                    ret_val = cpb_dpi_slave_port_chnl_zone_ovrd_cfg(cpb_handle,
                                                                    ingress_mux_input_port,
                                                                    ingress_mux_input_port_chnl,
                                                                    zone_mode,
                                                                    egress_mux_output_port,
                                                                    egress_mux_output_port_chnl);
                }

                if (ret_val == PMC_SUCCESS && zone_bypass == CPB_SLV_CHNL_ZONE_FIFO_AND_MSTR_XOFF && backup_mode == FALSE)
                {
                    /* Set the DCS XOFF mask */
                    ret_val = cpb_xoff_mask_set(cpb_handle,
                                               egress_mux_output_port,
                                               egress_mux_output_port,
                                               egress_mux_output_port_chnl,
                                               TRUE); /* TRUE -> set mask bit */
                }
            }

            if(PMC_SUCCESS == ret_val)
            {
                /* configure the slave port chnl hdr removal only when it's a primary chnl*/
                ret_val = cpb_dpi_slave_port_chnl_hdr_strip_cfg(cpb_handle,
                                                            ingress_mux_input_port,
                                                            ingress_mux_input_port_chnl,
                                                            hdr_en);
            }
        } /* end if broadcast == 0 */
        else if(PMC_SUCCESS == ret_val) /* This is a broadcast channel */
        {
            /* if is not a multicast, mark the newly built chnl as a reader primary chnl*/
            queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, read_qid);
            cpb_handle->var.fifo_var_data[queue_index].chnl_type = CPB_READER_PRIMARY;

            /* Clear the slave channel master because it's a broadcast
             * secondary channel */
            cpb_dpi_slave_port_chnl_zone_source_cfg(cpb_handle,
                                                    ingress_mux_input_port,
                                                    ingress_mux_input_port_chnl,
                                                    1, /* 1 means disable */
                                                    pop_port_id);
        }
    } /* end if ismulticast == 0 */
    else if(1 == ismulticast && PMC_SUCCESS == ret_val)
    {
        if(rate == 40000 && UTIL_SCHD_1M_BIT_SEC == rate_units)
        {
            cpb_fifo_reset_cfg(cpb_handle, ingress_mux_egress_port, pop_port_id, TRUE, write_qid, read_qid, 1);
        }
        /* calculate and configure the end address */
        cpb_fifo_end_addr_cal(cpb_handle, read_qid, num_blocks,  &fifo_end_addr);
        PMC_LOG_TRACE("\nFIFO end address setting: fifo_end_addr = %u \n",fifo_end_addr);
        ret_val = cpb_fifo_end_addr_cfg(cpb_handle, ingress_mux_egress_port,
                                        pop_port_id, write_qid, read_qid, fifo_end_addr, TRUE, TRUE);

        /* if this is a multicast, still have to configure the var.fifo_var_data */
        queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, read_qid);
        cpb_handle->var.fifo_var_data[queue_index].status = CPB_FIFO_BEING_USED;
        cpb_handle->var.fifo_var_data[queue_index].write_id = write_qid;
        cpb_handle->var.fifo_var_data[queue_index].push_port_id = ingress_mux_egress_port;
        cpb_handle->var.fifo_var_data[queue_index].chnl_type = CPB_FIFO_SECONDARY_CH;
    }

    if(PMC_SUCCESS == ret_val)
    {
        if(backup_mode == FALSE)
        {
            ret_val = cpb_connect_data_add( cpb_handle,
                                            ingress_mux_input_port,
                                            ingress_mux_input_port_chnl,
                                            egress_mux_output_port,
                                            egress_mux_output_port_chnl,
                                            isbroadcast, ismulticast, pop_port_id, read_qid);
        }
        else
        {
            ret_val = cpb_connect_backup_chnl_data_add( cpb_handle,
                                                        ingress_mux_input_port,
                                                        ingress_mux_input_port_chnl,
                                                        egress_mux_output_port,
                                                        egress_mux_output_port_chnl,
                                                        isbroadcast, ismulticast, pop_port_id, read_qid);
        }
    }

    if(PMC_SUCCESS == ret_val)
    {
        zone_mode = CPB_SLV_CHNL_ZONE_FIFO;
        ret_val = cpb_dpi_mstr_port_chnl_zone_mode_cfg(cpb_handle, egress_mux_output_port,
                                                       egress_mux_output_port_chnl, zone_mode);
    }

    if(PMC_SUCCESS == ret_val)
    {
        ret_val = cpb_dpi_mstr_port_chnl_zone_thresh_cfg(cpb_handle,
                                                   egress_mux_output_port,
                                                   egress_mux_output_port_chnl,
                                                   num_blocks*cpb_handle->cfg.bursts_per_block/CPB_ZONE0_1_DIVISOR,
                                                   num_blocks*cpb_handle->cfg.bursts_per_block/CPB_ZONE1_2_DIVISOR,
                                                   CPB_ZONE2_3_NUMERATOR*num_blocks*cpb_handle->cfg.bursts_per_block/CPB_ZONE2_3_DIVISOR);
    }

    if(backup_mode == TRUE)
    {
        if(PMC_SUCCESS == ret_val)
        {
            ret_val = cpb_fifo_reset_cfg(cpb_handle, ingress_mux_egress_port,
                                        pop_port_id, TRUE, write_qid, read_qid, 1);
        }
    
        /* perform DCS_Q_RESET */
        if(PMC_SUCCESS == ret_val)
        {
            ret_val = cpb_dcs_queue_reset(cpb_handle, egress_mux_input_port, read_qid);
        }
    
        if(PMC_SUCCESS == ret_val)
        {
            ret_val = cpb_fifo_reset_cfg(cpb_handle, ingress_mux_egress_port,
                                        pop_port_id, TRUE, write_qid, read_qid, 0);
        }
    }

    /* function exit point for following clean up scope */
    cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_0);
    cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */
    PMC_RETURN(ret_val);

} /* cpb_util_chnl_prov */

/*******************************************************************************
*  cpb_chnl_state_verify
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function checks the channel status for a specified DCS instance and
*   read channel ID.  Will return success if state matching, else return an
*   invalid state error.
*
*
* INPUTS:
*   *cpb_handle         - pointer to CPB handle instance.
*   dcs_inst            - the DCS instance index
*   read_qid            - read queue id within DCS instance to test
*   test_state          - the target status to be tested
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_chnl_state_verify(cpb_handle_t *cpb_handle,
                                        UINT32 dcs_inst,
                                        UINT32 read_qid,
                                        util_schd_chnl_state_t test_state)
{
    PMC_ERROR result = PMC_SUCCESS;
    util_schd_chnl_state_t current_state = LAST_UTIL_SCHD_CHNL;

    PMC_ENTRY();
    PMC_ASSERT(cpb_handle != NULL, CPB_ERR_INVALID_ARG, 0, 0);

    if(dcs_inst >= DCPB_NUM_QUEUE_SYSTEMS)
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(test_state >= LAST_UTIL_SCHD_CHNL)
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    result = util_schd_chnl_state_get(cpb_handle->util_schd_handle[dcs_inst],
                                                read_qid,
                                                &current_state);
    if(result != PMC_SUCCESS)
        PMC_RETURN(CPB_ERR_CODE_ASSERT);

    if(current_state != test_state) result = CPB_ERR_CHANNEL_INVALID_STATE;

    PMC_RETURN(result);

} /* cpb_chnl_state_verify */

/*******************************************************************************
*  cpb_dcpb_check_output_not_provisioned
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs a test to see if the DCPB output is provisioned
*   or not.
*
*
* INPUTS:
*   *cpb_handle         - Pointer to CPB handle instance.
*   dcs_inst            - The DCS instance index
*   read_qid            - Read queue ID within the DCS instance
*   output_port         - The master DPI output port number
*   output_channel      - The master DPI output channel number
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_dcpb_check_output_not_provisioned(cpb_handle_t *cpb_handle,
                                                        UINT32 dcs_inst,
                                                        UINT32 read_qid,
                                                        UINT32 output_port,
                                                        UINT32 output_channel)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 i;
    util_schd_handle_t *p0;
    util_schd_handle_t *p1;
    util_schd_handle_t *p2;
    util_schd_handle_t *p3;

    PMC_ENTRY();

    PMC_ASSERT(cpb_handle != NULL, CPB_ERR_INVALID_ARG, 0, 0);
    p0 = cpb_handle->util_schd_handle[0];
    p1 = cpb_handle->util_schd_handle[1];
    p2 = cpb_handle->util_schd_handle[2];
    p3 = cpb_handle->util_schd_handle[3];
    PMC_ASSERT(p0 != NULL, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(p1 != NULL, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(p2 != NULL, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(p3 != NULL, CPB_ERR_INVALID_ARG, 0, 0);

    /* Add offset to output channel and seach for same channel already provisioned */
    switch(output_port)
    {
        case 0:
            /* Check DCS 0 */
            for(i=0;i<CPB_NUM_SCHED_ENTRIES;i++)
            {
                if(p0->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                   p0->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                    PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);
            }
            break;
        case 1:
            /* Check DCS 1 */
            for(i=0;i<CPB_NUM_SCHED_ENTRIES;i++)
            {
                if(p1->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                   p1->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                    PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);
            }
            break;
        case 2:
            output_channel += DCPB_MST_PORT_2_CH_OFFSET;
            /* Check DCS 2 and if not SIFD mode, 0 and 1 */
            for(i=0;i<CPB_NUM_SCHED_ENTRIES;i++)
            {
                if(p2->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                   p2->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                    PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);

                if(cpb_handle->var.dcpb_em_sifd1_sel == 0)
                    if(p0->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                       p0->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                        PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);

                if(cpb_handle->var.dcpb_em_sifd2_sel == 0)
                    if(p1->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                       p1->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                        PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);
             }
            break;
        case 3:
        case 4:
            if(output_port == 3)
                output_channel += DCPB_MST_PORT_3_CH_OFFSET;
            /* Check DCS 2 and 3 */
            for(i=0;i<CPB_NUM_SCHED_ENTRIES;i++)
            {
                if(p2->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                   p2->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                    PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);
                if(p3->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                   p3->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                    PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);
            }
            break;
        case 5:
            for(i=0;i<CPB_NUM_SCHED_ENTRIES;i++)
            {
               if(cpb_handle->var.dcpb_em_sifd1_sel == 0)
                    if(p0->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                       p0->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                        PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);

                if(cpb_handle->var.dcpb_em_sifd2_sel == 0)
                    if(p1->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                       p1->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                        PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);
            }
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    PMC_RETURN(result);
} /* cpb_dcpb_check_output_not_provisioned */

/*******************************************************************************
*  cpb_ocpb_check_output_not_provisioned
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs a test to see if the OCPB output is provisioned
*   or not.
*
*
* INPUTS:
*   *cpb_handle         - Pointer to CPB handle instance.
*   dcs_inst            - The DCS instance index
*   read_qid            - Read queue ID within the DCS instance
*   output_port         - The master DPI output port number
*   output_channel      - The master DPI output channel number
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_ocpb_check_output_not_provisioned(cpb_handle_t *cpb_handle,
                                                        UINT32 dcs_inst,
                                                        UINT32 read_qid,
                                                        UINT32 output_port,
                                                        UINT32 output_channel)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 i;
    util_schd_handle_t *p0;
    util_schd_handle_t *p1;
    util_schd_handle_t *p2;
    util_schd_handle_t *p3;

    PMC_ENTRY();

    PMC_ASSERT(cpb_handle != NULL, CPB_ERR_INVALID_ARG, 0, 0);
    p0 = cpb_handle->util_schd_handle[0];
    p1 = cpb_handle->util_schd_handle[1];
    p2 = cpb_handle->util_schd_handle[2];
    p3 = cpb_handle->util_schd_handle[3];
    PMC_ASSERT(p0 != NULL, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(p1 != NULL, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(p2 != NULL, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(p3 != NULL, CPB_ERR_INVALID_ARG, 0, 0);

    /* Seach for same channel already provisioned */
    switch(output_port)
    {
        case 0:
            /* Check DCS 0 */
            for(i=0;i<CPB_NUM_SCHED_ENTRIES;i++)
            {
                if(p0->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                   p0->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                    PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);
            }
            break;
        case 1:
            /* Check DCS 1 */
            for(i=0;i<CPB_NUM_SCHED_ENTRIES;i++)
            {
                if(p1->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                   p1->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                    PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);
            }
            break;
        case 2:
            /* Check DCS 2  */
            for(i=0;i<CPB_NUM_SCHED_ENTRIES;i++)
            {
                if(p2->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                   p2->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                    PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);

            }
            break;
        case 3:
            /* Check DCS 3 */
            for(i=0;i<CPB_NUM_SCHED_ENTRIES;i++)
            {
                if(p3->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                   p3->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                    PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);
            }
            break;
         default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    PMC_RETURN(result);
} /* cpb_ocpb_check_output_not_provisioned */

/*******************************************************************************
*  cpb_mcpb_check_output_not_provisioned
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs a test to see if the MCPB output is provisioned
*   or not.
*
* INPUTS:
*   *cpb_handle         - Pointer to CPB handle instance.
*   dcs_inst            - The DCS instance index
*   read_qid            - Read queue ID within the DCS instance
*   output_port         - The master DPI output port number
*   output_channel      - The master DPI output channel number
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_mcpb_check_output_not_provisioned(cpb_handle_t *cpb_handle,
                                                        UINT32 dcs_inst,
                                                        UINT32 read_qid,
                                                        UINT32 output_port,
                                                        UINT32 output_channel)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 i;
    util_schd_handle_t *p0;
    util_schd_handle_t *p1;
    util_schd_handle_t *p2;
    util_schd_handle_t *p3;

    PMC_ENTRY();

    PMC_ASSERT(cpb_handle != NULL, CPB_ERR_INVALID_ARG, 0, 0);
    p0 = cpb_handle->util_schd_handle[0];
    p1 = cpb_handle->util_schd_handle[1];
    p2 = cpb_handle->util_schd_handle[2];
    p3 = cpb_handle->util_schd_handle[3];
    PMC_ASSERT(p0 != NULL, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(p1 != NULL, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(p2 != NULL, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(p3 != NULL, CPB_ERR_INVALID_ARG, 0, 0);

    /* Seach for same channel already provisioned */
    switch(dcs_inst)
    {
        case 0:
            /* Check DCS 0 */
            for(i=0;i<p0->cfg.block_ctxt.num_schd_chnl;i++)
            {
                if(p0->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                   p0->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                    PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);
            }
            break;
        case 1:
            /* Check DCS 1 */
            for(i=0;i<p1->cfg.block_ctxt.num_schd_chnl;i++)
            {
                if(p1->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                   p1->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                    PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);
            }
            break;
        case 2:
            /* Check DCS 2  */
            for(i=0;i<p2->cfg.block_ctxt.num_schd_chnl;i++)
            {
                if(p2->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                   p2->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == (output_channel + 0x40))
                    PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);

            }
            break;
        case 3:
            /* Check DCS 3 */
            for(i=0;i<p3->cfg.block_ctxt.num_schd_chnl;i++)
            {
                if(p3->var.schd_ctxt->chnl_ctxt[i].state != UTIL_SCHD_CHNL_START &&
                   p3->var.schd_ctxt->chnl_ctxt[i].dcs_rd_channel_id == output_channel)
                    PMC_RETURN(CPB_ERR_CHNL_ALREADY_EXISTS);
            }
            break;
         default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    PMC_RETURN(result);
} /* cpb_mcpb_check_output_not_provisioned */


/*******************************************************************************
*  cpb_mcpb_enet_connect_start_state_test
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs a test to see if the MCPB has any provisioned 
*   connections that are associated with ENET_LINE or ENET_SYS.
*
* INPUTS:
*   *cpb_handle         - Pointer to CPB handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    BOOL8 - TRUE if no connections to ENET_LINE or ENET_SYS, otherwise FALSE
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 cpb_mcpb_enet_connect_start_state_test(cpb_handle_t *cpb_handle)
{

    UINT32 i = 0, dcs_inst = 0;
    util_schd_handle_t *p0, *p1, *p2, *p3;

    /* read queue ID and number of read queues per DCS instance */
    UINT32 dcs_0_rid[]   = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22};
    UINT32 dcs_0_num     = 12;

    UINT32 dcs_1_rid[]   = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22};
    UINT32 dcs_1_num     = 12;

    UINT32 dcs_2_rid[]   = {37, 25, 49, 61, 38, 26, 50, 39, 36, 51, 40, 27, 52, 41, 28, 53, 42, 29, 54, 43, 30, 55, 44, 31, 56, 45, 32, 57, 46, 33, 58, 47, 34, 59, 48, 35, 60};
    UINT32 dcs_2_num     = 37;

    UINT32 dcs_3_rid[]   = {12, 0, 24, 13, 1, 14, 2, 15,  3, 16,  4, 17,  5, 18,  6, 19,  7, 20,  8, 21,  9, 22, 10, 23, 11};
    UINT32 dcs_3_num     = 25;

    PMC_ENTRY();
    PMC_ASSERT(cpb_handle != NULL, CPB_ERR_INVALID_ARG, 0, 0);

    p0 = cpb_handle->util_schd_handle[0];
    p1 = cpb_handle->util_schd_handle[1];
    p2 = cpb_handle->util_schd_handle[2];
    p3 = cpb_handle->util_schd_handle[3];

    /* Seach for same channel already provisioned */
    for(dcs_inst=0;dcs_inst<4;dcs_inst++)
    {
        switch(dcs_inst)
        {
            case 0:
                /* Check DCS 0 */
                for(i=0;i<dcs_0_num;i++)
                {
                    if(p0->var.schd_ctxt->chnl_ctxt[dcs_0_rid[i]].state != UTIL_SCHD_CHNL_START)
                        PMC_RETURN(FALSE);
                }
                break;
            case 1:
                /* Check DCS 1 */
                for(i=0;i<dcs_1_num;i++)
                {
                    if(p1->var.schd_ctxt->chnl_ctxt[dcs_1_rid[i]].state != UTIL_SCHD_CHNL_START)
                        PMC_RETURN(FALSE);
                }
                break;
            case 2:
                /* Check DCS 2  */
                for(i=0;i<dcs_2_num;i++)
                {
                    if(p2->var.schd_ctxt->chnl_ctxt[dcs_2_rid[i]].state != UTIL_SCHD_CHNL_START &&
                       dcs_2_rid[i] != 61)
                        PMC_RETURN(FALSE);
    
                }
                break;
            case 3:
                /* Check DCS 3 */
                for(i=0;i<dcs_3_num;i++)
                {
                    if(p3->var.schd_ctxt->chnl_ctxt[dcs_3_rid[i]].state != UTIL_SCHD_CHNL_START &&
                       dcs_3_rid[i] != 24)
                        PMC_RETURN(FALSE);
                }
                break;
             default:
                PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG, 0, 0);
        }
    }

    PMC_RETURN(TRUE);
} /* cpb_mcpb_enet_connect_start_state_test */

/*******************************************************************************
*  cpb_mcpb_enet_channel_start_state_test
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs a test to see if an ENET SS channel has all
*   associated MCPB channels in the start state.
*
* INPUTS:
*   *cpb_handle         - Pointer to CPB handle instance.
*    channel            - ENET link resource 0 to 11.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    BOOL8 - TRUE if no connections to ENET channel, otherwise FALSE
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 cpb_mcpb_enet_channel_start_state_test(cpb_handle_t *cpb_handle,
                                                    UINT32 channel)
{

    UINT32 dcs_inst = 0;
    util_schd_handle_t *p0, *p1, *p2, *p3;

    PMC_ENTRY();
    PMC_ASSERT(cpb_handle != NULL, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(channel < 12, CPB_ERR_INVALID_ARG, 0, 0);

    p0 = cpb_handle->util_schd_handle[0];
    p1 = cpb_handle->util_schd_handle[1];
    p2 = cpb_handle->util_schd_handle[2];
    p3 = cpb_handle->util_schd_handle[3];

    /* Seach for same channel already provisioned */
    for(dcs_inst=0;dcs_inst<4;dcs_inst++)
    {
        switch(dcs_inst)
        {
            case 0:
                /* Check DCS 0 */
                if(p0->var.schd_ctxt->chnl_ctxt[2*channel].state != UTIL_SCHD_CHNL_START)
                    PMC_RETURN(FALSE);
                break;
            case 1:
                /* Check DCS 1 */
                if(p1->var.schd_ctxt->chnl_ctxt[2*channel].state != UTIL_SCHD_CHNL_START)
                    PMC_RETURN(FALSE);
                break;
            case 2:
                /* Check DCS 2  */
                if(p2->var.schd_ctxt->chnl_ctxt[25+channel].state != UTIL_SCHD_CHNL_START)
                    PMC_RETURN(FALSE);
                if(p2->var.schd_ctxt->chnl_ctxt[37+channel].state != UTIL_SCHD_CHNL_START)
                    PMC_RETURN(FALSE);
                if(p2->var.schd_ctxt->chnl_ctxt[49+channel].state != UTIL_SCHD_CHNL_START)
                    PMC_RETURN(FALSE);
                break;
            case 3:
                /* Check DCS 3 */
                if(p3->var.schd_ctxt->chnl_ctxt[channel].state != UTIL_SCHD_CHNL_START)
                    PMC_RETURN(FALSE);
                if(p3->var.schd_ctxt->chnl_ctxt[12+channel].state != UTIL_SCHD_CHNL_START)
                    PMC_RETURN(FALSE);
                break;
             default:
                PMC_ASSERT(FALSE, CPB_ERR_CODE_ASSERT, 0, 0);
        }
    }

    PMC_RETURN(TRUE);
} /* cpb_mcpb_enet_channel_start_state_test */

/*******************************************************************************
*  cpb_mcpb_enet_channel_start_state_filtered_test
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs a test to see if an ENET SS channel has
*   associated MCPB channels in the start state relative to input search
*   criteria.
*
* INPUTS:
*   *cpb_handle         - Pointer to CPB handle instance.
*    channel            - ENET link resource 0 to 11.
*    dcs_mask           - 4 bits identifying DCS 0, 1, 2, 3 instance
*                         to test
*    target_mask        - 3 bit mask identifying ENET_EGRESS(0),
*                         ENET_INGRESS(1), and REFLECT(2) clarifying
*                         DCS2/3 target
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    BOOL8 - TRUE if no connections to ENET channel, otherwise FALSE
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 cpb_mcpb_enet_channel_start_state_filtered_test(cpb_handle_t *cpb_handle,
                                                             UINT32 channel,
                                                             UINT32 dcs_mask,
                                                             UINT32 target_mask)
{

    UINT32 dcs_inst = 0;
    util_schd_handle_t *p0, *p1, *p2, *p3;

    PMC_ENTRY();
    PMC_ASSERT(cpb_handle != NULL, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(channel < 12, CPB_ERR_INVALID_ARG, 0, 0);

    p0 = cpb_handle->util_schd_handle[0];
    p1 = cpb_handle->util_schd_handle[1];
    p2 = cpb_handle->util_schd_handle[2];
    p3 = cpb_handle->util_schd_handle[3];

    /* Seach for same channel already provisioned */
    for(dcs_inst=0;dcs_inst<4;dcs_inst++)
    {
        switch(dcs_inst)
        {
            case 0:
                /* Check DCS 0 */
                if((p0->var.schd_ctxt->chnl_ctxt[2*channel].state != UTIL_SCHD_CHNL_START) && (dcs_mask&0x1))
                    PMC_RETURN(FALSE);
                break;
            case 1:
                /* Check DCS 1 */
                if((p1->var.schd_ctxt->chnl_ctxt[2*channel].state != UTIL_SCHD_CHNL_START) && (dcs_mask&0x2))
                    PMC_RETURN(FALSE);
                break;
            case 2:
                /* Check DCS 2  */
                if((p2->var.schd_ctxt->chnl_ctxt[25+channel].state != UTIL_SCHD_CHNL_START) && (dcs_mask&0x4) && (target_mask&0x2))
                    PMC_RETURN(FALSE);
                if((p2->var.schd_ctxt->chnl_ctxt[37+channel].state != UTIL_SCHD_CHNL_START) && (dcs_mask&0x4) && (target_mask&0x1))
                    PMC_RETURN(FALSE);
                if((p2->var.schd_ctxt->chnl_ctxt[49+channel].state != UTIL_SCHD_CHNL_START) && (dcs_mask&0x4) && (target_mask&0x4))
                    PMC_RETURN(FALSE);
                break;
            case 3:
                /* Check DCS 3 */
                if((p3->var.schd_ctxt->chnl_ctxt[channel].state != UTIL_SCHD_CHNL_START) && (dcs_mask&0x8) && (target_mask&0x2))
                    PMC_RETURN(FALSE);
                if((p3->var.schd_ctxt->chnl_ctxt[12+channel].state != UTIL_SCHD_CHNL_START) && (dcs_mask&0x8) && (target_mask&0x1))
                    PMC_RETURN(FALSE);
                break;
             default:
                PMC_ASSERT(FALSE, CPB_ERR_CODE_ASSERT, 0, 0);
        }
    }

    PMC_RETURN(TRUE);
} /* cpb_mcpb_enet_channel_start_state_filtered_test */

/*******************************************************************************
*  cpb_mcpb_cpu_mgmt_start_state_test
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs a test to see if the CPU to MGMT_FEGE MCPB path
*   is in the start state (not configured) or not.
*
* INPUTS:
*   *cpb_handle         - Pointer to CPB handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    BOOL8 - TRUE if no CPU to MGMT_FEGE connection, otherwise FALSE
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 cpb_mcpb_cpu_mgmt_start_state_test(cpb_handle_t *cpb_handle)
{

    util_schd_handle_t *p3;

    PMC_ENTRY();
    PMC_ASSERT(cpb_handle != NULL, CPB_ERR_INVALID_ARG, 0, 0);

    p3 = cpb_handle->util_schd_handle[3];

    if(p3->var.schd_ctxt->chnl_ctxt[24].state != UTIL_SCHD_CHNL_START)
        PMC_RETURN(FALSE);

    PMC_RETURN(TRUE);
} /* cpb_mcpb_cpu_mgmt_start_state_test */

/*******************************************************************************
* cpb_chnl_hole_inst_head_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function configures the hole insertion head fields of the master port chnl
*   To be called immediately after the chnl prov function
*   The hole insertion feature only applies on SIFD ports and MAPOTN port, for
*   other port, this function just returns PMC_SUCCESS
*
* INPUTS:
*
*   h                            -  pointer to the cpb handle instance
*                                   destination subsystem.
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*   hole_inst_sop_size           -  size of the hole at the start of the packet
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_chnl_hole_inst_head_cfg( cpb_handle_t *h,
                                              UINT32 egress_mux_output_port,
                                              UINT32 egress_mux_output_port_chnl,
                                              UINT32 hole_inst_sop_size)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* check the range for SOP arg check the size of the hole*/
    PMC_ASSERT(hole_inst_sop_size <= CPB_MAX_SOP_HOLE_SIZE, CPB_ERR_INVALID_ARG,0,0);

    switch(h->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
        case CPB_INSTANCE_OCPB:
             master_dpi_field_SOP_HOLE_SIZE_set(NULL, h, egress_mux_output_port,
                                               egress_mux_output_port_chnl,
                                               hole_inst_sop_size);
             break;
        case CPB_INSTANCE_MCPB:
             break;
        default:
            result = CPB_ERR_INVALID_ARG;
    }

    PMC_RETURN(result);

} /* cpb_chnl_hole_inst_head_cfg */

/*******************************************************************************
* cpb_chnl_hole_inst_tail_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function configures the hole insertion tail fields of the master port chnl
*   To be called immediately after the chnl prov function
*   The hole insertion feature only applies on SIFD ports and MAPOTN port, for
*   other port, this function just returns PMC_SUCCESS
*
* INPUTS:
*
*   h                            -  pointer to the cpb handle instance
*                                   destination subsystem.
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*   hole_inst_eop                -  TRUE for a 4-byte hole at the end of the packet\n
*                                   FALSE for no hole at end of packet
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_chnl_hole_inst_tail_cfg( cpb_handle_t *h,
                                              UINT32 egress_mux_output_port,
                                              UINT32 egress_mux_output_port_chnl,
                                              BOOL8   hole_inst_eop)
{
    PMC_ENTRY();

    /* check the range for EOP arg check the size of the hole*/
    PMC_ASSERT(hole_inst_eop<= CPB_MAX_EOP_HOLE_SIZE, CPB_ERR_INVALID_ARG,0,0);
    PMC_ASSERT(egress_mux_output_port <= h->cfg.max_mst_dpi_port, CPB_ERR_INVALID_ARG,0,0);
    PMC_ASSERT(CPB_INSTANCE_DCPB == h->cfg.cpb_type, CPB_ERR_INVALID_ARG,0,0);
    PMC_ASSERT(CPB_DCPB_DPI_PORT_MAPOTN == egress_mux_output_port, CPB_ERR_INVALID_ARG,0,0);
    master_dpi_field_EOP_HOLE_SIZE_set(NULL, h, egress_mux_output_port,
                                       egress_mux_output_port_chnl,
                                       hole_inst_eop);
    PMC_RETURN(PMC_SUCCESS);

} /* cpb_chnl_hole_inst_tail_cfg */


/*******************************************************************************
* cpb_chnl_activate
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function activates a channel in the CPB subsystem as a function of the
*   read channel ID.\n\n
*
*   This function sets enable bits appropriately and performs any necessary
*   channel resets.
*
* INPUTS:
*
*   *cpb_handle                  - pointer to CPB handle instance.
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_chnl_activate( cpb_handle_t *cpb_handle,
                                    UINT32 egress_mux_output_port,
                                    UINT32 egress_mux_output_port_chnl )
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    result = cpb_chnl_activate_internal( cpb_handle,
                                         egress_mux_output_port,
                                         egress_mux_output_port_chnl,
                                         FALSE );

    PMC_RETURN(result);

} /* cpb_chnl_activate */

/*******************************************************************************
* cpb_chnl_activate_super_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function activates a channel in the CPB subsystem as a function of the
*   read channel ID.\n\n
*
*   This function sets enable bits appropriately and performs any necessary
*   channel resets.
*
* INPUTS:
*
*   *cpb_handle                  - pointer to CPB handle instance.
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_chnl_activate_super_prov( cpb_handle_t *cpb_handle,
                                               UINT32 egress_mux_output_port,
                                               UINT32 egress_mux_output_port_chnl )
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    result = cpb_chnl_activate_internal( cpb_handle,
                                         egress_mux_output_port,
                                         egress_mux_output_port_chnl,
                                         TRUE );

    PMC_RETURN(result);
} /* cpb_chnl_activate_super_prov */

/*******************************************************************************
* cpb_chnl_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deactivates a channel in the CPB subsystem as a function of the
*   master DPI port and master DPI port channel ID.\n\n
*
*   This function disables and enable bits appropriately and performs any necessary
*   channel resets.\n\n
*
*   If the channel to be deactivated is a primary channel, the function tests if
*   there is any other secondary channel in operational state, if yes, return warning
*   The only case to turn off the source channel is deactivating a primary channel
*   and there is no secondary channel in operational state. If deactivating a secondary
*   channel, only
*
*
* INPUTS:
*   *cpb_handle                  -  pointer to the cpb handle instance
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_chnl_deactivate( cpb_handle_t *cpb_handle,
                                      UINT32 egress_mux_output_port,
                                      UINT32 egress_mux_output_port_chnl )
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();

    result = cpb_chnl_deactivate_internal(cpb_handle,
                                          egress_mux_output_port,
                                          egress_mux_output_port_chnl,
                                          FALSE );

    PMC_RETURN(result);

} /* cpb_chnl_deactivate */

/*******************************************************************************
* cpb_chnl_switch
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function switches a channel in the CPB subsystem as a function of the
*   master DPI port and master DPI port channel ID.\n\n
*
*
*
* INPUTS:
*   *cpb_handle                  -  pointer to the cpb handle instance
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_chnl_switch( cpb_handle_t *cpb_handle,
                                  UINT32 egress_mux_output_port,
                                  UINT32 egress_mux_output_port_chnl )
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();

    result = cpb_chnl_switch_internal(cpb_handle,
                                      egress_mux_output_port,
                                      egress_mux_output_port_chnl);

    PMC_RETURN(result);

} /* cpb_chnl_switch */

/*******************************************************************************
* cpb_chnl_deactivate_super_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deactivates a channel in CPB/OCPB subsystem.
*   This function only writes the DCS scheduling data to the offline page and
*   delays swapping the page in a DCS instance until at a later time when
*   user indicates that all channels have been added to the DCS instance.\n\n
*
*   Swapping of the page and updating the offline page are performed in:\n
*   - cpb_dcs_page_update()\n
*   - cpb_dcs_page_swap()\n
*
*
* INPUTS:
*   *cpb_handle                  -  pointer to the cpb handle instance
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_chnl_deactivate_super_prov( cpb_handle_t *cpb_handle,
                                                 UINT32 egress_mux_output_port,
                                                 UINT32 egress_mux_output_port_chnl )
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();

    result = cpb_chnl_deactivate_internal(cpb_handle,
                                          egress_mux_output_port,
                                          egress_mux_output_port_chnl,
                                          TRUE );

    PMC_RETURN(result);

} /* cpb_chnl_deactivate_super_prov */



/*******************************************************************************
*  cpb_mcpb_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provision a unidirectional channel for an MCPB instance.
*   The MCPB channel mapping is fixed, that means given a destination port id and
*   channel id, the source port id, source channel id, write queue id, read queue id,
*   the write channel id, and the dcs read channel id are fixed.\n\n
*
*   The mapping is given as below\n
*\code
*   master port    mstr port chnl   slv port chnl   slv port\n
*       0           0,2,4,...,22 -- 0,2,4,...,22,      5\n
*                   1,3,5,...,23 -- 1,3,5,...,23,      4\n\n
*
*       1           0,2,4,...,22 -- 0,2,4,...,22,      5\n
*                   1,3,5,...,23 -- 1,3,5,...,23,      4\n\n
*
*       2           0,2,4,...,22 -- 0,2,4,...,22,      4\n
*                   1,3,5,...,23 -- 1,3,5,...,23,      5\n\n
*
*       3           0,2,4,...,22 -- 0,2,4,...,22,      4\n
*                   1,3,5,...,23 -- 1,3,5,...,23,      5\n\n
*
*       4       chnl_id[5:2] = 0 ~ 11\n
*               chnl_id[1:0] = 00\n
*                                -- 0,2,4,...,22,     2/3\n
*               chnl_id[5:2] = 0 ~ 11\n
*               chnl_id[1:0] = 01\n
*                                -- 0,2,4,...,22,     0/1\n
*               chnl_id[5:2] = 0 - 11\n
*               chnl_id[1:0] = 10\n
*                                -- 0 - 11,           6/7\n
*               chnl_id[5:2] = 0\n
*               chnl_id[1:0] = 11\n
*                                --  32                1\n\n
*
*       5       chnl_id[5:2] = 0 ~ 11\n
*               chnl_id[1:0] = 00\n
*                                -- 1,3,5,...,23,     2/3\n
*               chnl_id[5:2] = 0 ~ 11\n
*               chnl_id[1:0] = 01\n
*                                -- 1,3,5,...,23,     0/1\n
*               chnl_id[5:2] = 0\n
*               chnl_id[1:0] = 11\n
*                                --   32               0\n
*\endcode
*
* INPUTS:
*   *cpb_handle                   - pointer to CPB handle instance.
*   egress_mux_output_port        - the master dpi port id
*   egress_mux_output_port_chnl   - the master dpi port channel id
*   rate                          - Channel rate. The channel rate is defined as:
*                                   rate * 10^(rate_units)
*   rate_units                    - Units of channel rate
*   halt_buffer                   - CPB FIFO buffer room to capture in flight data in
*                                   the event that CPB FIFO generates an upstream flow
*                                   control signal.  Used in cases where ENET utilizes
*                                   pause flow control and where a channel is fed from
*                                   SIFD and asserts XOFF flow control.  halt_buffer is
*                                   specified in units of blocks.  The block size is:\n
*                                   MCPB: 384 bytes
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_mcpb_chnl_prov( cpb_handle_t *cpb_handle,
                                     UINT32 egress_mux_output_port,
                                     UINT32 egress_mux_output_port_chnl,
                                     UINT32 rate,
                                     util_schd_chnl_rate_exp_t rate_units,
                                     UINT32 halt_buffer)
{
    /* Variable declaration */
    UINT32 push_port_id = 999,queue_system_id = 999;
    UINT32 ingress_mux_input_port, ingress_mux_input_port_chnl;
    UINT32 alt_ingress_mux_input_port, alt_ingress_mux_input_port_chnl = 999;
    UINT32 rd_channel_id, wr_channel_id;
    UINT32 read_qid = CPB_BLOCK_RQID_NIL, write_qid;
    UINT32 alt_queue_mode = 0; /*alternate queue mode flag */
    PMC_ERROR result;
    UINT32 cpb_data = 1; /* MCPB has only packet data*/
    UINT32 hdr_en = 0; /* MCPB does not support header remmoval */
    UINT32 egress_mux_input_port = 999;

    PMC_ENTRY();

    /*argument check, check if the port id and chnl id is legal */

    PMC_ASSERT(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type, CPB_ERR_INVALID_CPB_TYPE, 0 , 0);
    if(egress_mux_output_port > cpb_handle->cfg.max_mst_dpi_port)
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(egress_mux_output_port_chnl > cpb_handle->cfg.max_dpi_mst_chnl_id[egress_mux_output_port])
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    /* determine the source port id and source port channel id, as well as the
       push port and pop port id */
    switch(egress_mux_output_port)
    {
        case CPB_MCPB_EGR_SYS_ING:
            if(cpb_handle->var.mcpb_em_sel.em_igr_ext_sel != 1)
                PMC_RETURN(CPB_ERR_INVALID_ARG);
            queue_system_id = 0;
            egress_mux_input_port = 0;
            push_port_id = 2;
            ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
            ingress_mux_input_port_chnl = egress_mux_output_port_chnl*2;
            alt_ingress_mux_input_port = CPB_MCPB_ING_CPU_INS;
            alt_ingress_mux_input_port_chnl = egress_mux_output_port_chnl*2 + 1;
            alt_queue_mode = 1;
            break;
        case CPB_MCPB_EGR_LINE_ING:
            if(cpb_handle->var.mcpb_em_sel.em_igr_ext_sel != 0)
                PMC_RETURN(CPB_ERR_INVALID_ARG);
            queue_system_id = 0;
            egress_mux_input_port = 0;
            push_port_id = 2;
            ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
            ingress_mux_input_port_chnl = egress_mux_output_port_chnl*2;
            alt_ingress_mux_input_port = CPB_MCPB_ING_CPU_INS;
            alt_ingress_mux_input_port_chnl = egress_mux_output_port_chnl*2 + 1;
            alt_queue_mode = 1;
            break;
        case CPB_MCPB_EGR_SYS_EG:
            if(cpb_handle->var.mcpb_em_sel.em_egr_ext_sel != 1)
                PMC_RETURN(CPB_ERR_INVALID_ARG);
            queue_system_id = 1;
            egress_mux_input_port = 1;
            push_port_id = 2;
            ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
            ingress_mux_input_port_chnl = egress_mux_output_port_chnl*2 + 1;
            alt_ingress_mux_input_port = CPB_MCPB_ING_CPU_INS;
            alt_ingress_mux_input_port_chnl = egress_mux_output_port_chnl*2;
            alt_queue_mode = 1;
            break;
        case CPB_MCPB_EGR_LINE_EG:
            if(cpb_handle->var.mcpb_em_sel.em_egr_ext_sel != 0)
                PMC_RETURN(CPB_ERR_INVALID_ARG);
            queue_system_id = 1;
            egress_mux_input_port = 1;
            push_port_id = 2;
            ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
            ingress_mux_input_port_chnl = egress_mux_output_port_chnl*2 + 1;
            alt_ingress_mux_input_port = CPB_MCPB_ING_CPU_INS;
            alt_ingress_mux_input_port_chnl = egress_mux_output_port_chnl*2;
            alt_queue_mode = 1;
            break;
        case CPB_MCPB_EGR_CPU:
            queue_system_id = 2;
            egress_mux_input_port = 2;
            switch(egress_mux_output_port_chnl % 4)
            {
                case 0:
                    push_port_id = 1;
                    ingress_mux_input_port = (0 == cpb_handle->var.mcpb_im_sel.egr_ext_sel) ? CPB_MCPB_ING_LINE_EM_EXT : CPB_MCPB_ING_SYS_EM_EXT;
                    ingress_mux_input_port_chnl = (egress_mux_output_port_chnl >> 2) << 1;
                    break;
                case 1:
                    push_port_id = 0;
                    ingress_mux_input_port = (0 == cpb_handle->var.mcpb_im_sel.igr_ext_sel) ? CPB_MCPB_ING_LINE_IM_EXT : CPB_MCPB_ING_SYS_IM_EXT;
                    ingress_mux_input_port_chnl = (egress_mux_output_port_chnl >> 2) << 1;
                    break;
                case 2:
                    push_port_id = 3;
                    ingress_mux_input_port = (0 == cpb_handle->var.mcpb_im_sel.reflect_sel) ? CPB_MCPB_ING_LINE_REF : CPB_MCPB_ING_SYS_REF;
                    ingress_mux_input_port_chnl = egress_mux_output_port_chnl >> 2;
                    break;
                case 3:
                    if((egress_mux_output_port_chnl / 4) != 0)
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    push_port_id = 2;
                    ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
                    ingress_mux_input_port_chnl = 24;
                    break;
                default:
                    PMC_RETURN(CPB_ERR_INVALID_ARG);
            }
            break;
        case CPB_MCPB_EGR_FEGE:
            queue_system_id = 2;
            egress_mux_input_port = 3;
            switch(egress_mux_output_port_chnl % 4)
            {
                case 0:
                    push_port_id = 1;
                    ingress_mux_input_port = (0 == cpb_handle->var.mcpb_im_sel.egr_ext_sel) ? CPB_MCPB_ING_LINE_EM_EXT : CPB_MCPB_ING_SYS_EM_EXT;
                    ingress_mux_input_port_chnl = ((egress_mux_output_port_chnl >> 2) << 1) + 1;
                    break;
                case 1:
                    push_port_id = 0;
                    ingress_mux_input_port = (0 == cpb_handle->var.mcpb_im_sel.igr_ext_sel) ? CPB_MCPB_ING_LINE_IM_EXT : CPB_MCPB_ING_SYS_IM_EXT;
                    ingress_mux_input_port_chnl = ((egress_mux_output_port_chnl >> 2) << 1) + 1;
                    break;
                case 3:
                    if((egress_mux_output_port_chnl / 4) != 0)
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    push_port_id = 2;
                    ingress_mux_input_port = CPB_MCPB_ING_CPU_INS;
                    ingress_mux_input_port_chnl = 24;
                    break;
                default:
                    PMC_RETURN(CPB_ERR_INVALID_ARG);
            }
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    /* check if the connection is previously configured */
    result =  cpb_chnl_prov_arg_check( cpb_handle,
                                       ingress_mux_input_port,
                                       ingress_mux_input_port_chnl,
                                       push_port_id,
                                       egress_mux_input_port,
                                       egress_mux_output_port,
                                       egress_mux_output_port_chnl,
                                       &wr_channel_id,
                                       &rd_channel_id,
                                       &write_qid,
                                       &read_qid );
    if(result) PMC_RETURN(result);

    result = cpb_mcpb_check_output_not_provisioned(cpb_handle,
                                                   egress_mux_input_port,
                                                   read_qid,
                                                   egress_mux_output_port,
                                                   egress_mux_output_port_chnl);
    if(result) PMC_RETURN(result);

    /* Perform initialization slave interfaces if required */
    if(cpb_handle->var.slv_dpi_port_init_flag[ingress_mux_input_port] != TRUE)
    {
        result = cpb_ingress_mux_input_init(cpb_handle, ingress_mux_input_port, CPB_PACKET, FALSE);
        if(result) PMC_RETURN(result);
    }

    /* perform master interface and DCS initialization if required */
    if(cpb_dcs_status_get(cpb_handle, egress_mux_input_port) == FALSE)
    {

        result = cpb_egress_mux_output_init(cpb_handle, egress_mux_output_port, CPB_PACKET, TRUE);
        if(result) PMC_RETURN(result);

        result = cpb_egress_mux_input_init(cpb_handle,
                                           egress_mux_input_port,
                                           CPB_SEGMENT_BURST_128,
                                           CPB_DCS_EN_N_SIFD);
        if(result) PMC_RETURN(result);
    }


    /* call cpb_util_chnl_prov */
    if(1 == alt_queue_mode)
    {
        result = cpb_util_chnl_prov( cpb_handle,
                                     ingress_mux_input_port,
                                     ingress_mux_input_port_chnl,
                                     push_port_id,
                                     queue_system_id,
                                     egress_mux_output_port,
                                     egress_mux_output_port_chnl,
                                     rate,
                                     rate_units,
                                     cpb_data,
                                     halt_buffer,
                                     hdr_en,
                                     FALSE );
        if(result) PMC_RETURN(result);
        if(cpb_handle->var.slv_dpi_port_init_flag[alt_ingress_mux_input_port] != TRUE)
        {
            result = cpb_ingress_mux_input_init(cpb_handle, alt_ingress_mux_input_port, CPB_PACKET, FALSE);
            if(result) PMC_RETURN(result);
        }

        result = cpb_util_chnl_prov( cpb_handle,
                                     alt_ingress_mux_input_port,
                                     alt_ingress_mux_input_port_chnl,
                                     push_port_id,
                                     queue_system_id,
                                     egress_mux_output_port,
                                     egress_mux_output_port_chnl,
                                     rate,
                                     rate_units,
                                     cpb_data,
                                     halt_buffer,
                                     hdr_en,
                                     FALSE );
        if(result) PMC_RETURN(result);
    } else {
        result = cpb_util_chnl_prov( cpb_handle,
                                     ingress_mux_input_port,
                                     ingress_mux_input_port_chnl,
                                     push_port_id,
                                     egress_mux_input_port,
                                     egress_mux_output_port,
                                     egress_mux_output_port_chnl,
                                     rate,
                                     rate_units,
                                     cpb_data,
                                     halt_buffer,
                                     hdr_en,
                                     FALSE );
        if(result) PMC_RETURN(result);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_mcpb_chnl_prov */

/*******************************************************************************
* cpb_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions a CPB channel and recovers resources for usage
*   of other channels. If the channel to be deproved is a primary reader, detect
*   if there is any. In the event of channel multiplexing should non-primary
*   readers be present, they will be forcibly torn down by this function.
*   Note: there are three cases:\n\n

*   NOTE: the QSx_CH_EN is shut down when activating.\n\n

*   When tearing down a multicast channel, deprov the DCS, clear the FIFO ram
*   data and reset the read pointer of the FIFO. All the master port chnl cfg
*   should be cleared, zone threshold, hole and zone overide cfg.\n\n
*
*   When tearing down a multicast primary channel, tear down all the channels
*   that are associated with the same input channel within the current QS,
*   besides clearing the master port chnl cfg, clear the channel-queue-assoc
*   in the slv port channel cfg as well.\n\n
*
*   When tearing down a broadcast primary channel, tear down all the channels
*   that are associated with the same input channel in all QSs, besides the
*   operations performed for the multicast primary channel tearing down, clear
*   the slv port chnl cfg as well, including channel configuration, zone threshold
*   for the input channel and zone ovrd for the input channel.
*
*
* INPUTS:
*   *cpb_handle                  -  The pointer to the CPB instance.
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*   backup_mode                  - If TRUE for DCPB CBRC input port, will provision 
*                                  channel excluding DCS and DPI Master Port.
*                                  Intended for 10GE fault replacement application.
*                                  Otherwise set to FALSE.
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_chnl_deprov( cpb_handle_t *cpb_handle,
                                  UINT32 egress_mux_output_port,
                                  UINT32 egress_mux_output_port_chnl,
                                  BOOL8  backup_mode)
{

    PMC_ERROR result = PMC_SUCCESS;
    UINT32 dcs_inst = 999;

    PMC_ENTRY();

    result = cpb_chnl_deprov_internal(cpb_handle,
                                      egress_mux_output_port,
                                      egress_mux_output_port_chnl,
                                      FALSE,
                                      backup_mode);

    /* For MCPB proxy shut off egress mux output port if required */
    if(result == PMC_SUCCESS && CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type)
    {
        switch(egress_mux_output_port)
        {
            case CPB_MCPB_EGR_SYS_ING:
            case CPB_MCPB_EGR_LINE_ING:
                dcs_inst = 0;
                break;
            case CPB_MCPB_EGR_SYS_EG:
            case CPB_MCPB_EGR_LINE_EG:
                dcs_inst = 1;
                break;
            case CPB_MCPB_EGR_CPU:
                dcs_inst = 2;
                break;
            case CPB_MCPB_EGR_FEGE:
                dcs_inst = 3;
                break;
            default:
                PMC_ASSERT(FALSE, CPB_ERR_CODE_ASSERT, 0, 0);
                break;
        }
   
        if(util_schd_start_state_test(cpb_handle->util_schd_handle[dcs_inst]) == TRUE)
        {
            result = cpb_egress_mux_input_init(cpb_handle,
                                               dcs_inst,
                                               CPB_SEGMENT_BURST_128,
                                               CPB_DCS_DISABLED);                       
            if(result == PMC_SUCCESS)
            {
                result = cpb_egress_mux_output_init(cpb_handle, egress_mux_output_port, CPB_PACKET, FALSE);
            }
        }
    }

    PMC_RETURN(result);
} /* cpb_chnl_deprov */


/*******************************************************************************
* cpb_chnl_deprov_super_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions a CPB channel and recovers resources for usage
*   of other channels. If the channel to be deproved is a primary reader, detect
*   if there is any. In the event of channel multiplexing should non-primary
*   readers be present, they will be forcibly torn down by this function.
*   Note: there are three cases:\n\n

*   NOTE: the QSx_CH_EN is shut down when activating.\n\n

*   When tearing down a multicast channel, deprov the DCS, clear the FIFO ram
*   data and reset the read pointer of the FIFO. All the master port chnl cfg
*   should be cleared, zone threshold, hole and zone overide cfg.\n\n
*
*   When tearing down a multicast primary channel, tear down all the channels
*   that are associated with the same input channel within the current QS,
*   besides clearing the master port chnl cfg, clear the channel-queue-assoc
*   in the slv port channel cfg as well.\n\n
*
*   When tearing down a broadcast primary channel, tear down all the channels
*   that are associated with the same input channel in all QSs, besides the
*   operations performed for the multicast primary channel tearing down, clear
*   the slv port chnl cfg as well, including channel configuration, zone threshold
*   for the input channel and zone ovrd for the input channel.
*
*
* INPUTS:
*   *cpb_handle                  -  The pointer to the CPB instance.
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_chnl_deprov_super_deprov( cpb_handle_t *cpb_handle,
                                               UINT32 egress_mux_output_port,
                                               UINT32 egress_mux_output_port_chnl )
{

    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    result = cpb_chnl_deprov_internal(cpb_handle,
                                      egress_mux_output_port,
                                      egress_mux_output_port_chnl,
                                      TRUE,
                                      FALSE);

    PMC_RETURN(result);
} /* cpb_chnl_deprov_super_prov */


/*******************************************************************************
* cpb_chnl_source_and_type_test
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function provides an interface to get the source port and channel id for
*   a given destination port and chnl id , also  tests if the given chnl is a
*   broadcast channel or a multicast channel.\n\n
*
*   This function retrieves channel configuration information that is stored
*   in SW driver memory.  Device accesses are not performed by this function.\n\n
*
*   In emulation mode this function retrieves the user assigned port ID and
*   not the emulation CPB port ID.
*
* INPUTS:
*   *cpb_handle                  -  The pointer to the CPB instance.
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
* OUTPUTS:
*   *ingress_mux_input_port       -  pointer to the source port
*   *ingress_mux_input_port_chnl  -  pointer to the source channel id
*   *is_broadcast                 -  Broadcast is defined as: DPI slave port
*                                    channel is processed by more than one queue
*                                    system (ie target more than one
*                                    egress_mux_output_port)
*                                    FALSE : is not a broadcast channel
*                                    TRUE  : is a broadcast channel
*   *is_multicast                   - Multicast is defined as: There are more than
*                                    one reader for the DPI Slave Port Channel
*                                    within the queue system associated with
*                                    egress_mux_output_port
*                                    FALSE : is not a multicast channel
*                                    TRUE  : is a multicast channel
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_chnl_source_and_type_test(cpb_handle_t *cpb_handle,
                                               UINT32 egress_mux_output_port,
                                               UINT32 egress_mux_output_port_chnl,
                                               UINT32 *ingress_mux_input_port,
                                               UINT32 *ingress_mux_input_port_chnl,
                                               BOOL8 *is_broadcast,
                                               BOOL8 *is_multicast)
{
    PMC_ENTRY();

    if (egress_mux_output_port >= 6 || egress_mux_output_port_chnl >= 150) {
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    if (ingress_mux_input_port == NULL || ingress_mux_input_port == NULL || is_broadcast == NULL || is_multicast == NULL) {
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB) {
        PMC_RETURN(PMC_SUCCESS);
    }

    if (CPB_INDEX_LAST == cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.source_slv_port)
    {
        PMC_RETURN(CPB_ERR_ZONE_SOURCE_NOT_FOUND);
    }

    *ingress_mux_input_port = cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.source_slv_port;
    *ingress_mux_input_port_chnl = cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.source_slv_chnl;

    *is_broadcast = cpb_handle->var.cpb_connect_data->chnl[*ingress_mux_input_port][*ingress_mux_input_port_chnl].slv.is_broadcast;
    *is_multicast = cpb_handle->var.cpb_connect_data->chnl[*ingress_mux_input_port][*ingress_mux_input_port_chnl].slv.is_multicast;

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_chnl_source_and_type_test */


/*******************************************************************************
* cpb_chnl_source_and_type_test_recovery
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function provides an interface to get the source port and channel id for
*   a given destination port and chnl id , also  tests if the given chnl is a
*   broadcast channel or a multicast channel.\n\n
*
*   This function retrieves channel configuration information that is stored
*   in SW driver memory.  Device accesses are not performed by this function.\n\n
*
*   In emulation mode this function retrieves the user assigned port ID and
*   not the emulation CPB port ID.\n\n
*
*   This function differs from cpb_chnl_source_and_type_test() in that it
*   makes the determination from accessing context that is maintained
*   during warm and crash restart.\n\n
*
* INPUTS:
*   *cpb_handle                  -  The pointer to the CPB instance.
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
* OUTPUTS:
*   *ingress_mux_input_port      -  pointer to the source port
*   *ingress_mux_input_port_chnl -  pointer to the source channel id
*   *is_broadcast                 -  Broadcast is defined as: DPI slave port
*                                    channel is processed by more than one queue
*                                    system (ie target more than one
*                                    egress_mux_output_port)\n
*                                    FALSE : is not a broadcast channel\n
*                                    TRUE  : is a broadcast channel
*   *is_multicast                   - Multicast is defined as: There are more than
*                                    one reader for the DPI Slave Port Channel
*                                    within the queue system associated with
*                                    egress_mux_output_port\n
*                                    FALSE : is not a multicast channel\n
*                                    TRUE  : is a multicast channel
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_chnl_source_and_type_test_recovery(cpb_handle_t *cpb_handle,
                                                         UINT32 egress_mux_output_port,
                                                         UINT32 egress_mux_output_port_chnl,
                                                         UINT32 *ingress_mux_input_port,
                                                         UINT32 *ingress_mux_input_port_chnl,
                                                         BOOL8 *is_broadcast,
                                                         BOOL8 *is_multicast)
{
    UINT32 i, num_current_blocks,num_current_pages;
    UINT32 *current_page_array;
    UINT32 egress_mux_input_port,rd_channel_id,rd_queue_id;
    UINT32 wr_queue_id;
    UINT32 push_port_id, queue_index;
    UINT32 temp_slave_port,temp_slave_chan;
    PMC_ERROR result;
    PMC_ENTRY();

    current_page_array = cpb_mem_pool_assign(cpb_handle, CPB_MEM_POOL_ID_0);
    PMC_ASSERT(current_page_array != NULL, CPB_ERR_CODE_ASSERT, 0, 0);

    /* Search each DCS to deterimine which DCS contains the rd_channel_id that is bound for the
       output port and output DPI channel */
    result = cpb_dcs_egress_dpi_chnl_source_get_recovery( cpb_handle, egress_mux_output_port,
                                                          egress_mux_output_port_chnl,
                                                          &egress_mux_input_port, &rd_channel_id,
                                                          &rd_queue_id );

    if(result){cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_0); PMC_RETURN(result);}

    /* retrieve ingress mux input port and channel for the egress mux port and channel */
    result = cpb_ingress_mux_input_port_data_get(cpb_handle, egress_mux_input_port, rd_queue_id,
                                                 &wr_queue_id, ingress_mux_input_port,
                                                 ingress_mux_input_port_chnl);

    if(result){cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_0); PMC_RETURN(result);}

    queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, rd_queue_id);
    push_port_id = cpb_handle->var.fifo_var_data[queue_index].push_port_id;

    /* Loop through all the DCSs. If a DCS other than this one has blocks assigned to this
     * push port and write queue id, then this is a broadcast */
    *is_broadcast = FALSE;
    for(i = 0; i < cpb_handle->cfg.pop_port_num; i++)
    {
        num_current_blocks = 0;
        if(egress_mux_input_port != i)
        {
            result = cpb_qs_current_pages_get(cpb_handle,push_port_id,i,&num_current_pages,current_page_array);
            if(result){ cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_0); PMC_RETURN(result);}
            cpb_queue_num_current_blocks_get(cpb_handle, wr_queue_id, num_current_pages, current_page_array, &num_current_blocks);
        }
        if(0 != num_current_blocks)
        {
            PMC_LOG_TRACE("This channel is part of a broadcast.\n");
            *is_broadcast = TRUE;
            break;
        }
    }

    *is_multicast = FALSE;

    /* Loop through all the read queue on this DCS. If there's another read queue with the same
     * DPI slave port and channel then this channel is part of of a multicast */
    for(i=0;i<CPB_NUM_SCHED_ENTRIES;i++)
    {
        temp_slave_port = CPB_NULL_CHANNEL_ENTRY;
        temp_slave_chan = CPB_NULL_CHANNEL_ENTRY;
        if (i != rd_queue_id)
        {
            (void) cpb_ingress_mux_input_port_data_get(cpb_handle, egress_mux_input_port, i,
                                                       &wr_queue_id, &temp_slave_port,
                                                       &temp_slave_chan);            
        }
        if(temp_slave_port == *ingress_mux_input_port  && temp_slave_chan == *ingress_mux_input_port_chnl)
        {
            PMC_LOG_TRACE("This channel is part of a multicast.\n");
            *is_multicast = TRUE;
            break;
        }

    }

    cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_0);
    PMC_RETURN(PMC_SUCCESS);

} /* cpb_chnl_source_and_type_test_recovery */


/*******************************************************************************
* cpb_chnl_source_type_and_primary_test
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function provides an interface to get the source port and channel id for
*   a given destination port and chnl id , also  tests if the given chnl is a
*   broadcast channel or a multicast channel by making use of
*   cpb_chnl_source_and_type_test. In addition this function determines if
*   the output port is the primary listener\n\n
*
*   This function retrieves channel configuration information that is stored
*   in SW driver memory.  Device accesses are not performed by this function.\n\n
*
*   In emulation mode this function retrieves the user assigned port ID and
*   not the emulation CPB port ID.
*
* INPUTS:
*   *cpb_handle                  - The pointer to the CPB instance.
*   egress_mux_output_port       - Egress Mux Output Port associated with
*                                  destination subsystem.
*   egress_mux_output_port_chnl  - Destination channel number relative to
*                                  egress_mux_output_port.  This is the DPI
*                                  channel that transfers data to downstream
*                                  subsystem
* OUTPUTS:
*   *ingress_mux_input_port      - Pointer to the source port
*   *ingress_mux_input_port_chnl - Pointer to the source channel id
*   *is_broadcast                - Broadcast is defined as: DPI slave port
*                                  channel is processed by more than one queue
*                                  system (ie target more than one
*                                  egress_mux_output_port)\n
*                                  FALSE : is not a broadcast channel\n
*                                  TRUE  : is a broadcast channel
*   *is_multicast                - Multicast is defined as: There are more than
*                                  one reader for the DPI Slave Port Channel
*                                  within the queue system associated with
*                                  egress_mux_output_port\n
*                                  FALSE : is not a multicast channel\n
*                                  TRUE  : is a multicast channel
*  *is_reader_primary            - The egress mux output port channel is the
*                                  primary reader for the queue system in which
*                                  it is configured.
*  *is_slave_zone_primary        - The egress mux output port channel is the DPI
*                                  slave port channel zone source for all channels
*                                  associated with the DPI slave port channel.
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_chnl_source_type_and_primary_test(cpb_handle_t *cpb_handle,
                                                       UINT32 egress_mux_output_port,
                                                       UINT32 egress_mux_output_port_chnl,
                                                       UINT32 *ingress_mux_input_port,
                                                       UINT32 *ingress_mux_input_port_chnl,
                                                       BOOL8 *is_broadcast,
                                                       BOOL8 *is_multicast,
                                                       BOOL8 *is_reader_primary,
                                                       BOOL8 *is_slave_zone_primary)
{
    PMC_ERROR rc = PMC_SUCCESS;

    PMC_ENTRY();

    if (egress_mux_output_port >= 6 || egress_mux_output_port_chnl >= 150)
    {
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    if (ingress_mux_input_port == NULL || ingress_mux_input_port == NULL || is_broadcast == NULL || is_multicast == NULL
        || is_reader_primary == NULL || is_slave_zone_primary == NULL) 
    {
        PMC_RETURN(PMC_ERR_INVALID_PARAMETERS);
    }

    if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB) 
    {
        rc = cpb_chnl_source_type_and_primary_test_recovery(cpb_handle,
                                                            egress_mux_output_port,
                                                            egress_mux_output_port_chnl,
                                                            ingress_mux_input_port,
                                                            ingress_mux_input_port_chnl,
                                                            is_broadcast,
                                                            is_multicast,
                                                            is_reader_primary,
                                                            is_slave_zone_primary);
    }
    else
    {
        /*
         * Check that the index is valid before proceeding. if not then
         * return an error.
         */
        if (CPB_INDEX_LAST == cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.source_slv_port)
        {
            PMC_RETURN(CPB_ERR_ZONE_SOURCE_NOT_FOUND);
        }
        
        *ingress_mux_input_port = cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.source_slv_port;
        *ingress_mux_input_port_chnl = cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.source_slv_chnl;
        
        *is_reader_primary = cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.is_reader_primary;
        *is_slave_zone_primary = cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.is_slave_zone_primary;
        
        *is_broadcast = cpb_handle->var.cpb_connect_data->chnl[*ingress_mux_input_port][*ingress_mux_input_port_chnl].slv.is_broadcast;
        *is_multicast = cpb_handle->var.cpb_connect_data->chnl[*ingress_mux_input_port][*ingress_mux_input_port_chnl].slv.is_multicast;
    }

    PMC_RETURN(rc);
    
} /* cpb_chnl_source_type_and_primary_test */

/*******************************************************************************
* cpb_chnl_source_type_and_primary_test_recovery
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function provides an interface to get the source port and channel id for
*   a given destination port and chnl id , also  tests if the given chnl is a
*   broadcast channel or a multicast channel by making use of
*   cpb_chnl_source_and_type_test. In addition this function determines if
*   the output port is the primary listener\n\n
*
*   This function retrieves channel configuration information that is stored
*   in SW driver memory.  Device accesses are not performed by this function.\n\n
*
*   In emulation mode this function retrieves the user assigned port ID and
*   not the emulation CPB port ID.\n\n
*
*   This function differs from cpb_chnl_source_type_and_primary_test() in that
*   it makes the determination from accessing context that is maintained
*   during warm and crash restart.\n\n
*
* INPUTS:
*   *cpb_handle                  - The pointer to the CPB instance.
*   egress_mux_output_port       - Egress Mux Output Port associated with
*                                  destination subsystem.
*   egress_mux_output_port_chnl  - Destination channel number relative to
*                                  egress_mux_output_port.  This is the DPI
*                                  channel that transfers data to downstream
*                                  subsystem
* OUTPUTS:
*   *ingress_mux_input_port      - Pointer to the source port
*   *ingress_mux_input_port_chnl - Pointer to the source channel id
*   *is_broadcast                - Broadcast is defined as: DPI slave port
*                                  channel is processed by more than one queue
*                                  system (ie target more than one
*                                  egress_mux_output_port)\n
*                                  FALSE : is not a broadcast channel\n
*                                  TRUE  : is a broadcast channel
*   *is_multicast                - Multicast is defined as: There are more than
*                                  one reader for the DPI Slave Port Channel
*                                  within the queue system associated with
*                                  egress_mux_output_port\n
*                                  FALSE : is not a multicast channel\n
*                                  TRUE  : is a multicast channel
*  *is_reader_primary            - The egress mux output port channel is the
*                                  primary reader for the queue system in which
*                                  it is configured.
*  *is_slave_zone_primary        - The egress mux output port channel is the DPI
*                                  slave port channel zone source for all channels
*                                  associated with the DPI slave port channel.
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_chnl_source_type_and_primary_test_recovery(cpb_handle_t *cpb_handle,
                                                                 UINT32 egress_mux_output_port,
                                                                 UINT32 egress_mux_output_port_chnl,
                                                                 UINT32 *ingress_mux_input_port,
                                                                 UINT32 *ingress_mux_input_port_chnl,
                                                                 BOOL8 *is_broadcast,
                                                                 BOOL8 *is_multicast,
                                                                 BOOL8 *is_reader_primary,
                                                                 BOOL8 *is_slave_zone_primary)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 egress_mux_input_port;
    UINT32 rd_channel_id;
    UINT32 rd_queue_id;
    UINT32 pop_port_id;
    UINT32 queue_index;
    cpb_dcpb_rd_chnl_t cpb_chnl_type = CPB_FIFO_INVALID_CH;

    PMC_ENTRY();

    /* The following helper should check all the other values */
    result = cpb_chnl_source_and_type_test_recovery(cpb_handle,
                                                    egress_mux_output_port,
                                                    egress_mux_output_port_chnl,
                                                    ingress_mux_input_port,
                                                    ingress_mux_input_port_chnl,
                                                    is_broadcast,
                                                    is_multicast);

    if (result != PMC_SUCCESS) 
    {
        PMC_RETURN(result);
    }

    /* Search each DCS to deterimine which DCS contains the rd_channel_id that is bound for the
       output port and output DPI channel */
    result = cpb_dcs_egress_dpi_chnl_source_get_recovery(cpb_handle,
                                                         egress_mux_output_port,
                                                         egress_mux_output_port_chnl,
                                                         &egress_mux_input_port,
                                                         &rd_channel_id,
                                                         &rd_queue_id);
    if (result != PMC_SUCCESS)
    {
        PMC_RETURN(result);
    }
    /* MCPB Master Port 5 reads from QS2 */
    if ((cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB) &&
        (egress_mux_output_port == CPB_MCPB_EGR_FEGE)) {

        pop_port_id = CPB_MCPB_POP_PORT_2;

    } else {

        pop_port_id = egress_mux_input_port;
    }

    queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, rd_queue_id);
    cpb_chnl_type = cpb_handle->var.fifo_var_data[queue_index].chnl_type;

    if (cpb_chnl_type == CPB_SLAVE_ZONE_PRIMARY)
    {
        *is_slave_zone_primary = TRUE;
        *is_reader_primary = TRUE;
    }
    else if (cpb_chnl_type == CPB_READER_PRIMARY)
    {
        *is_slave_zone_primary = FALSE;
        *is_reader_primary = TRUE;
    } else if (cpb_chnl_type == CPB_FIFO_SECONDARY_CH)
    {
        *is_slave_zone_primary = FALSE;
        *is_reader_primary = FALSE;
    } else
    {
        result = CPB_ERR_CHANNEL_INVALID_STATE;
    }

    PMC_RETURN(result);

} /* cpb_chnl_source_type_and_primary_test_recovery */

/*******************************************************************************
* cpb_queue_resize_wrapper
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function is a wrapper function to the cpb_queue_resize, taking the
*   destination port and channel as inputs.
*
* INPUTS:
*   *cpb_handle                 - pointer to CPB handle instance.
*   egress_mux_output_port      - master DPI port id
*   egress_mux_output_port_chnl - master DPI port channel id
*   num_blocks                  - requested number of blocks
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_queue_resize_wrapper ( cpb_handle_t *cpb_handle,
                                            UINT32 egress_mux_output_port,
                                            UINT32 egress_mux_output_port_chnl,
                                            UINT32 num_blocks)
{
    PMC_ERROR result;
    UINT32 egress_mux_input_port,rd_channel_id,rd_queue_id;
    UINT32 queue_index;
    PMC_ENTRY();
    result = cpb_dcs_egress_dpi_chnl_source_get( cpb_handle, egress_mux_output_port,
                                                 egress_mux_output_port_chnl,
                                                 &egress_mux_input_port,
                                                 &rd_channel_id,
                                                 &rd_queue_id);
    if(result) PMC_RETURN(result);

    queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, rd_queue_id);
    if(cpb_handle->var.fifo_var_data[queue_index].chnl_type != CPB_SLAVE_ZONE_PRIMARY &&
       cpb_handle->var.fifo_var_data[queue_index].chnl_type != CPB_READER_PRIMARY)
    {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    } else {
        result = cpb_queue_resize(cpb_handle,egress_mux_input_port,rd_queue_id, TRUE, num_blocks);
    }

    PMC_RETURN(result);

} /* cpb_queue_resize_wrapper */


/*******************************************************************************
* cpb_dcs_status_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns DCS queue status associated to a input port.
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   input_port            - Egress Mux Input Port:
*                           0: Egress Mux Input Port 0
*                           1: Egress Mux Input Port 1
*                           2: Egress Mux Input Port 2
*                           3: Egress Mux Input Port 3
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   TRUE when DCS mux is initialized, otherwise FALSE.
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 cpb_dcs_status_get(cpb_handle_t *cpb_handle,
                                UINT32        input_port)
{
    PMC_ENTRY();

    PMC_ASSERT(NULL != cpb_handle, CPB_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(4 > input_port, CPB_ERR_INVALID_ARG, 0, 0);


    PMC_RETURN(cpb_handle->var.dcs_inst_init_flag[input_port]);
}/* cpb_dcs_status_get */

/*******************************************************************************
* cpb_dcs_start_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns DCS instance start state status.  It determines
*   if all channels are in the START state.
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   input_port            - Egress Mux Input Port:
*                           0: Egress Mux Input Port 0
*                           1: Egress Mux Input Port 1
*                           2: Egress Mux Input Port 2
*                           3: Egress Mux Input Port 3
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   TRUE when all DCS channels are in the START state, otherwise FALSE.
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 cpb_dcs_start_state_get(cpb_handle_t *cpb_handle,
                                     UINT32        input_port)
{
    PMC_ENTRY();

    PMC_ASSERT(NULL != cpb_handle, CPB_ERR_NULL_HANDLE, 0, 0);
    PMC_ASSERT(4 > input_port, CPB_ERR_INVALID_ARG, 0, 0);

    PMC_RETURN(util_schd_start_state_test(cpb_handle->util_schd_handle[input_port]));

} /* cpb_dcs_start_state_get */


/*******************************************************************************
* cpb_sysotn_mode_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Sets sysotn_mode context.  Required for the OCPB because port 0 is not
*   provisioned as a SIFD port in the sysotn card application.
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*   sysotn_mode            - TRUE : provision for SYSOTN care application
*                          - FALSE : provision for normal operation
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_sysotn_mode_set( cpb_handle_t *cpb_handle,
                                      BOOL8 sysotn_mode)
{

    PMC_ENTRY();

    cpb_handle->cfg.sysotn_mode = sysotn_mode;

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_sysotn_mode_set */

/*******************************************************************************
* cpb_fifo_num_blocks_by_input_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function retrieves the FIFO size data for the primary zone master
*   of a slave DPI port channel.
*
*
* INPUTS:
*   *h                          - pointer to cpb handle instance
*                                 channel data
*   slave_port                  - DPI Slave Port
*   slave_chnl                  - DPI Slave Channel
* OUTPUTS:
*   *num_block_ptr              - number of blocks associated with the
*                                 primary reader
*   *num_burst_ptr              - number of 48 byte increments assocaited with
*                                 the primar reader
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_fifo_num_blocks_by_input_get(cpb_handle_t *h,
                                             UINT32 slave_port,
                                             UINT32 slave_chnl,
                                             UINT32 *num_block_ptr,
                                             UINT32 *num_burst_ptr)
{

    UINT32 pop_port = 999, pop_qid = 999;
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();

    /* assert if this is MCPB channel handle type */
    PMC_ASSERT(h->cfg.cpb_type != CPB_INSTANCE_MCPB, CPB_ERR_CODE_ASSERT, 0, 0);

    cpb_slv_port_chnl_pop_port_data_get(h, slave_port, slave_chnl,
                                        &pop_port, &pop_qid);

    result = cpb_queue_num_block_get(h, pop_port, pop_qid, num_block_ptr);
    PMC_ASSERT(result == PMC_SUCCESS, CPB_ERR_CODE_ASSERT, 0, 0);

    *num_burst_ptr = h->cfg.bursts_per_block * *num_block_ptr;

    PMC_RETURN();

} /* cpb_fifo_num_blocks_by_input_get */


/*******************************************************************************
* cpb_dcs_page_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Generates the calendar for active channels.
*   Updates the standby page.
*
* INPUTS:
*   *cpb_handle      - pointer to the CPB handle instance
*   dcs_inst         - DCS inst id, 1:1 to the pop port id
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 cpb_dcs_page_update(cpb_handle_t *cpb_handle, UINT32 dcs_inst)
{
    util_schd_handle_t *p = cpb_handle->util_schd_handle[dcs_inst];
    UINT32 max_entries = p->cfg.block_ctxt.max_entries;
    UINT32 dist_entries[CPB_NUM_SCHED_ENTRIES];

    PMC_ENTRY();

    /* Generate a distribution of read queue ids */
    util_schd_group_dist_gen(p, 0, max_entries,dist_entries);

    /* Copy the old offline page into a temp calendar to keep track of changes after a new offline page is generated */
    PMC_MEMCPY((void*)cpb_handle->var.dcs_temp_calendar,
               (void*)cpb_handle->var.dcs_offline_calendars[dcs_inst],
               cpb_handle->cfg.num_calendar_entries * sizeof(util_schd_dcs_calendar_entry_t));

    /* Generate a new offline page and write offline page registers */
    cpb_dcs_gen_calendar_and_write_offline_page(cpb_handle,dcs_inst,dist_entries,NULL,NULL);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dcs_page_update */

/*******************************************************************************
* cpb_dcs_page_swap_and_offline_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Generates the calendar for active channels.
*   Updates the standby page.
*
* INPUTS:
*   *cpb_handle      - pointer to the CPB handle instance
*   dcs_inst         - DCS inst id, 1:1 to the pop port id
*
* OUTPUTS:
*   is_dcs_updated_ptr          - Provide NULL if not required.
*                                 TRUE : DCS was update, FALSE, DCS was not updated
*   is_channel_idx_updated_arr  - array of 96 booleans that indicates which channel IDs were updated.
*                                 Can be NULL only if "is_cal_updated_ptr" equals NULL too.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC UINT32 cpb_dcs_page_swap_and_offline_update(cpb_handle_t *cpb_handle,
                                                   UINT32 dcs_inst,
                                                   BOOL8* is_dcs_updated_ptr,
                                                   BOOL8 is_channel_idx_updated_arr[])
{
    /*UINT32 i;*/
    util_schd_handle_t *p = cpb_handle->util_schd_handle[dcs_inst];
    PMC_ERROR ret_val;
    UINT32 max_entries = p->cfg.block_ctxt.max_entries;
    UINT32 dist_entries[CPB_NUM_SCHED_ENTRIES];

    PMC_ENTRY();

    /* Generate a distribution of read queue ids */
    util_schd_group_dist_gen(p, 0, max_entries,dist_entries);

    /* Swap device offline and online pages */
    cpb_dcs_page_swap( cpb_handle,dcs_inst );

    /* Poll for page swap success */
    ret_val = cpb_dcs_poll_swap_success( cpb_handle, dcs_inst );
    if(ret_val) /* return error if failure */
    {
        PMC_LOG_TRACE("Error: Page swap failed");
         PMC_RETURN(ret_val);
    }

    /* Swap context offline and online page to match device */
    PMC_MEMCPY((void*)cpb_handle->var.dcs_temp_calendar,
               (void*)cpb_handle->var.dcs_online_calendars[dcs_inst],
               cpb_handle->cfg.num_calendar_entries * sizeof(util_schd_dcs_calendar_entry_t));
    PMC_MEMCPY((void*)cpb_handle->var.dcs_online_calendars[dcs_inst],
               (void*)cpb_handle->var.dcs_offline_calendars[dcs_inst],
               cpb_handle->cfg.num_calendar_entries * sizeof(util_schd_dcs_calendar_entry_t));
    PMC_MEMCPY((void*)cpb_handle->var.dcs_offline_calendars[dcs_inst],
               (void*)cpb_handle->var.dcs_temp_calendar,
               cpb_handle->cfg.num_calendar_entries * sizeof(util_schd_dcs_calendar_entry_t));


    /* Write the offline calendar registers again so online and offline calendar pages contain
       the same data */
    cpb_dcs_gen_calendar_and_write_offline_page(cpb_handle,dcs_inst,dist_entries,is_dcs_updated_ptr,is_channel_idx_updated_arr);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dcs_page_swap_and_offline_update */


/*******************************************************************************
* cpb_queue_flush_and_ptr_reset
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function flushes a queue and performs a pointer reset on the queue.
*
*
* INPUTS:
*   *h                          - pointer to cpb handle instance
*                                 channel data
*   slave_port                  - DPI Slave Port
*   slave_chnl                  - DPI Slave Channel
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_queue_flush_and_ptr_reset(cpb_handle_t *h,
                                               UINT32 slave_port,
                                               UINT32 slave_chnl)
{

    UINT32 pop_port = 999, pop_qid = 999;
    UINT32 push_port = 999, push_qid = 999;
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();

    /* assert if this is MCPB or OCPB channel handle type */
    PMC_ASSERT(h->cfg.cpb_type != CPB_INSTANCE_MCPB, CPB_ERR_CODE_ASSERT, 0, 0);
    PMC_ASSERT(h->cfg.cpb_type != CPB_INSTANCE_OCPB, CPB_ERR_CODE_ASSERT, 0, 0);

    cpb_slv_port_chnl_pop_port_data_get(h, slave_port, slave_chnl,
                                        &pop_port, &pop_qid);

    push_port = h->var.fifo_var_data[pop_port*(h->cfg.max_fifo_num) + pop_qid].push_port_id;
    push_qid  = h->var.fifo_var_data[pop_port*(h->cfg.max_fifo_num) + pop_qid].write_id;


    /* set DCS channel state to EQUIPPED from operational */
    if(PMC_SUCCESS == result){
        result = cpb_dcs_chnl_deactivate(h, pop_port, pop_qid);
    }

    /* update the DCS to take channel out of scheduler */
    if(PMC_SUCCESS == result){
        result = cpb_dcs_page_update_and_swap(h, pop_port);
    }

    /* put the RPTR_RST and WPRT_RST into reset state in SCPB */
    if(PMC_SUCCESS == result && CPB_INSTANCE_MCPB != h->cfg.cpb_type)
    {
        result = cpb_fifo_reset_cfg(h, push_port,
                                    pop_port, TRUE, push_qid, pop_qid, 1);
    }

    /* reset scheduler queue with DCS_Q_RST */
    if(PMC_SUCCESS == result && CPB_INSTANCE_MCPB != h->cfg.cpb_type)
    {
        result = cpb_dcs_queue_reset(h, pop_port, pop_qid);
    }

    /* put the RPTR_RST and WPRT_RST out of reset state in SCPB */
    if(PMC_SUCCESS == result)
    {
        result = cpb_fifo_reset_cfg(h, push_port,
                                    pop_port, TRUE, push_qid, pop_qid, 0);
    }

    /* set DCS channel state to OPERATIONAL */
    if(PMC_SUCCESS == result){
        result = cpb_dcs_chnl_activate(h, pop_port, pop_qid);
    }

    /* update the DCS to put the channel back into the scheduler */
    if(PMC_SUCCESS == result){
        result = cpb_dcs_page_update_and_swap(h, pop_port);
    }

    PMC_RETURN(result);

} /* cpb_queue_flush_and_ptr_reset */

/*******************************************************************************
* cpb_fifo_var_data_and_chnl_state_reset
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function releases the fifo queue resource by resetting the fifo var
*   context for the queue index. This function also release the dcs channel
*   by setting its channel state to UTIL_SCHD_CHNL_START.
*
*   This function is only called in digi_otn_server_lo_deprov_end where the
*   the DCS scheduling data is updated only once per DCS instance.
*
* INPUTS:
*   *cpb_handle                   - pointer to CPB handle instance
*   egress_mux_input_port         - queue system id for the source zone master
*   rd_queue_id                   - read queue ID
*   queue_index                   - queue index
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_fifo_var_data_and_chnl_state_reset( cpb_handle_t *cpb_handle,
                                                         UINT32 egress_mux_input_port,
                                                         UINT32 rd_queue_id,
                                                         UINT32 queue_index )
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    cpb_handle->var.fifo_var_data[queue_index].fifo_end_addr = 0;
    cpb_handle->var.fifo_var_data[queue_index].write_id = CPB_BLOCK_WQID_NIL;
    cpb_handle->var.fifo_var_data[queue_index].status = CPB_FIFO_NOT_USED;
    cpb_handle->var.fifo_var_data[queue_index].push_port_id = CPB_FIFO_PUSHID_NIL;
    cpb_handle->var.fifo_var_data[queue_index].chnl_type = CPB_FIFO_INVALID_CH;

    cpb_dcs_chnl_deprov(cpb_handle, egress_mux_input_port, rd_queue_id );


    PMC_RETURN(result);

} /* cpb_fifo_var_data_and_chnl_state_reset */

/*******************************************************************************
* cpb_dcpb_pmon_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Enables or disables a PMON counter on a slave port of the DCPB depending on
*  the pmon_mode. If disable is set, then the inputs count_drop_packets,
*  count_err_packets, count_oversize_packets, and count_good_packets are ignored.
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*   port                   - ENUM defining the DCPB port
*   counter_num            - The counter number. There are 4 counters per port.
*   pmon_mode              - ENUM defining the PMON mode (byte, packet, or disable)
*   count_drop_packets     - Disable count packets marked as drop in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*   count_err_packets      - Disable count packets marked as error in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*   count_oversize_packets - Disable count oversized packets in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*   count_good_packets     - Disable count normal packets in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcpb_pmon_cfg( cpb_handle_t *cpb_handle,
                                  cpb_dcpb_dpi_port_type_t port,
                                  UINT32 counter_num,
                                  cpb_pmon_mode pmon_mode,
                                  BOOL8 count_drop_packets,
                                  BOOL8 count_err_packets,
                                  BOOL8 count_oversize_packets,
                                  BOOL8 count_good_packets)

{
    PMC_ENTRY();
    PMC_ERROR result;

    if(port > DCPB_MAX_DPI_PORT)
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(pmon_mode != CPB_PMON_MODE_PACKET &&
       pmon_mode != CPB_PMON_MODE_BYTE &&
       pmon_mode != CPB_PMON_MODE_DISABLE)
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(counter_num > CPB_MAX_PMON_COUNTER)
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    result = cpb_pmon_cfg(cpb_handle,
                 (UINT32) port,
                 counter_num,
                 pmon_mode,
                 count_drop_packets,
                 count_err_packets,
                 count_oversize_packets,
                 count_good_packets);

     PMC_RETURN(result);
} /* cpb_dcpb_pmon_cfg */

/*******************************************************************************
* cpb_ocpb_pmon_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Enables or disables a PMON counter on a slave port of the OCPB depending on
*  the pmon_mode. If disable is set, then the inputs count_drop_packets,
*  count_err_packets, count_oversize_packets, and count_good_packets are ignored.
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*   port                   - ENUM defining the OCPB port
*   counter_num            - The counter number. There are 4 counters per port.
*   pmon_mode              - ENUM defining the PMON mode (byte, packet, or disable)
*   count_drop_packets     - Disable count packets marked as drop in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*   count_err_packets      - Disable count packets marked as error in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*   count_oversize_packets - Disable count oversized packets in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*   count_good_packets     - Disable count normal packets in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_ocpb_pmon_cfg( cpb_handle_t *cpb_handle,
                                  cpb_ocpb_dpi_port_type_t port,
                                  UINT32 counter_num,
                                  cpb_pmon_mode pmon_mode,
                                  BOOL8 count_drop_packets,
                                  BOOL8 count_err_packets,
                                  BOOL8 count_oversize_packets,
                                  BOOL8 count_good_packets)

{
    PMC_ENTRY();
    PMC_ERROR result;

    if(port > OCPB_MAX_DPI_PORT)
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(pmon_mode != CPB_PMON_MODE_PACKET &&
       pmon_mode != CPB_PMON_MODE_BYTE &&
       pmon_mode != CPB_PMON_MODE_DISABLE)
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(counter_num > CPB_MAX_PMON_COUNTER)
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    result = cpb_pmon_cfg(cpb_handle,
                 (UINT32) port,
                 counter_num,
                 pmon_mode,
                 count_drop_packets,
                 count_err_packets,
                 count_oversize_packets,
                 count_good_packets);

     PMC_RETURN(result);
} /* cpb_ocpb_pmon_cfg */

/*******************************************************************************
* cpb_mcpb_pmon_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*  Enables or disables a PMON counter on a slave port of the MCPB depending on
*  the pmon_mode. If disable is set, then the inputs count_drop_packets,
*  count_err_packets, count_oversize_packets, and count_good_packets are ignored.
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*   port                   - ENUM defining the MCPB port
*   counter_num            - The counter number. There are 4 counters per port.
*   pmon_mode              - ENUM defining the PMON mode (byte, packet, or disable)
*   count_drop_packets     - Disable count packets marked as drop in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*   count_err_packets      - Disable count packets marked as error in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*   count_oversize_packets - Disable count oversized packets in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*   count_good_packets     - Disable count normal packets in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_mcpb_pmon_cfg (cpb_handle_t *cpb_handle,
                                    cpb_mcpb_ingr_input_port_type_t port,
                                    UINT32 counter_num,
                                    cpb_pmon_mode pmon_mode,
                                    BOOL8 count_drop_packets,
                                    BOOL8 count_err_packets,
                                    BOOL8 count_oversize_packets,
                                    BOOL8 count_good_packets)

{
    PMC_ENTRY();
    PMC_ERROR result;

    if(port >= LAST_CPB_MCPB_INGRESS_PORT)
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(pmon_mode != CPB_PMON_MODE_PACKET &&
       pmon_mode != CPB_PMON_MODE_BYTE &&
       pmon_mode != CPB_PMON_MODE_DISABLE)
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(counter_num > CPB_MAX_PMON_COUNTER)
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    result = cpb_pmon_cfg(cpb_handle,
                          (UINT32) port,
                          counter_num,
                          pmon_mode,
                          count_drop_packets,
                          count_err_packets,
                          count_oversize_packets,
                          count_good_packets);

     PMC_RETURN(result);
} /* cpb_mcpb_pmon_cfg */

/*******************************************************************************
* cpb_pmon_chnl_add_drop_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Add or drop a channel from a PMON counter
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*   port                   - UINT32 defining the port number
*   counter_num            - The counter number. There are 4 counters per port.
*   channel                - The DPI channel ID to add or drop
*   add_channel            - TRUE: Add this channel\n
*                            FALSE: Drop this channel
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_pmon_chnl_add_drop_cfg(cpb_handle_t *cpb_handle,
                                            UINT32 port,
                                            UINT32 counter_num,
                                            UINT32 channel,
                                            BOOL8 add_channel)
{
    PMC_ENTRY();

    /* Set the channel */
    switch (counter_num) {
        case 0:
            slave_dpi_field_PMON_CNT0_EN_set(NULL, cpb_handle, port, channel, (UINT32)add_channel);
            break;
        case 1:
            slave_dpi_field_PMON_CNT1_EN_set(NULL, cpb_handle, port, channel, (UINT32)add_channel);
            break;
        case 2:
            slave_dpi_field_PMON_CNT2_EN_set(NULL, cpb_handle, port, channel, (UINT32)add_channel);
            break;
        case 3:
            slave_dpi_field_PMON_CNT3_EN_set(NULL, cpb_handle, port, channel, (UINT32)add_channel);
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
            break;
    }

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_pmon_chnl_add_drop_cfg */

/*******************************************************************************
* cpb_pmon_latch_trig_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Transfer the current PMON count to a holding register and resets the PMON count.
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*   port                   - UINT32 defining the port number
*   counter_mask           - A counter mask where bits 0 to 3 represent counters
*                            0 to 3. Writing a 1 to a bit indicates that the counter
*                            should transfer the count and reset the count. Values
*                            greater than 0xF are considered invalid.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_pmon_latch_trig_set( cpb_handle_t *cpb_handle,
                                        UINT32 port,
                                        UINT32 counter_mask)
{
    PMC_ENTRY();
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 num_failed_polls = 0;

    if(counter_mask > 0xF)
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    if(counter_mask & 0x1)
    {
        slave_dpi_field_PMON_CNT0_TRIG_set(NULL, cpb_handle, port, 1);
        result = slave_dpi_field_PMON_CNT0_TRIG_poll (NULL, cpb_handle, port, 0, PMC_POLL_EQUAL , PMON_TRIG_POLL_ITERATIONS, &num_failed_polls, PMON_TRIG_POLL_DELAY);
    }
    if(result == PMC_SUCCESS && (counter_mask & 0x2))
    {
        slave_dpi_field_PMON_CNT1_TRIG_set(NULL, cpb_handle, port, 1);
        result = slave_dpi_field_PMON_CNT1_TRIG_poll (NULL, cpb_handle, port, 0, PMC_POLL_EQUAL , PMON_TRIG_POLL_ITERATIONS, &num_failed_polls, PMON_TRIG_POLL_DELAY);
    }
    if(result == PMC_SUCCESS && (counter_mask & 0x4))
    {
        slave_dpi_field_PMON_CNT2_TRIG_set(NULL, cpb_handle, port, 1);
        result = slave_dpi_field_PMON_CNT2_TRIG_poll (NULL, cpb_handle, port, 0, PMC_POLL_EQUAL , PMON_TRIG_POLL_ITERATIONS, &num_failed_polls, PMON_TRIG_POLL_DELAY);
    }
    if(result == PMC_SUCCESS && (counter_mask & 0x8))
    {
        slave_dpi_field_PMON_CNT3_TRIG_set(NULL, cpb_handle, port, 1);
        result = slave_dpi_field_PMON_CNT3_TRIG_poll (NULL, cpb_handle, port, 0, PMC_POLL_EQUAL , PMON_TRIG_POLL_ITERATIONS, &num_failed_polls, PMON_TRIG_POLL_DELAY);
    }

    PMC_RETURN(result);

} /* cpb_pmon_latch_trig_set */

/*******************************************************************************
* cpb_pmon_counter_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Read the count from the holding register.
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*   port                   - UINT32 defining the port number
*   counter_mask           - A counter mask where bits 0 to 3 represent counters
*                            0 to 3. Writing a 1 to a bit indicates a get request
*                            on that counter. Values greater than 0xF are considered
*                            invalid.
*
* OUTPUTS:
*   count0                  - The PMON count on counter 0.
*                             If the corresponding mask bit was not set it returns a 0.
*   count1                  - The PMON count on counter 1
*                             If the corresponding mask bit was not set it returns a 0.
*   count2                  - The PMON count on counter 2
*                             If the corresponding mask bit was not set it returns a 0.
*   count3                  - The PMON count on counter 3
*                             If the corresponding mask bit was not set it returns a 0.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_pmon_counter_get( cpb_handle_t *cpb_handle,
                                      UINT32 port,
                                      UINT32 counter_mask,
                                      UINT32 * count0,
                                      UINT32 * count1,
                                      UINT32 * count2,
                                      UINT32 * count3)
{

    PMC_ENTRY();

    if(counter_mask > 0xF)
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    if(counter_mask & 0x1)
        *count0 = slave_dpi_field_PMON_CNT0_VAL_get(NULL, cpb_handle, port);
    else
        *count0 = 0;

    if(counter_mask & 0x2)
        *count1 = slave_dpi_field_PMON_CNT1_VAL_get(NULL, cpb_handle, port);
    else
        *count1 = 0;

    if(counter_mask & 0x4)
        *count2 = slave_dpi_field_PMON_CNT2_VAL_get(NULL, cpb_handle, port);
    else
        *count2 = 0;

    if(counter_mask & 0x8)
        *count3 = slave_dpi_field_PMON_CNT3_VAL_get(NULL, cpb_handle, port);
    else
        *count3 = 0;


    PMC_RETURN(PMC_SUCCESS);

} /* cpb_pmon_counter_get */


/*******************************************************************************
* cpb_connect_data_delete_super_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function resets CPB connect data structure and the channel state
*   in DCS calender.
* 
*   This function is called only when bulk deprovisioning or release operator
*   is used. When the channel is a broadcast or multicast channel,
*   CPB mapping structure for all associated multicast readers and slave
*   channels will be reset.
*
*
* INPUTS:
*   *cpb_handle                  -  The pointer to the CPB instance.
*   ingress_mux_input_port       -  Ingress Mux Input Port associated with
*                                   destination subsystem.
*   ingress_mux_input_port_chnl  -  Source channel number relative to
*                                   inress_mux_input_port.  This is the DPI
*                                   channel that transfers data from upstream
*                                   subsystem into CPB.
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*   super_deprov                -   boolean to indicate that this function is
*                                   used in bulk deprovisioning mode.
*                                   TRUE: bulk deprovisioning
*                                   FALSE: normal deprovisioning
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_connect_data_delete_super_deprov( cpb_handle_t *cpb_handle,
                                                       UINT32 ingress_mux_input_port,
                                                       UINT32 ingress_mux_input_port_chnl,
                                                       UINT32 egress_mux_output_port,
                                                       UINT32 egress_mux_output_port_chnl,
                                                       BOOL8 super_deprov)
{
    UINT32 egress_mux_input_port;
    UINT32 rd_channel_id;
    UINT32 rd_queue_id;
    UINT32 wr_queue_id;
    UINT32 temp_output_port = 999, temp_output_port_chnl = 999;
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 queue_index, push_port_id, i, k;
    util_schd_chnl_ctxt_t *p_chnl_ctxt = NULL;
    util_schd_block_const_ctxt_t *p_block_ctxt = NULL;

    PMC_ENTRY();

    /* search each DCS to deterimine which DCS contains the rd_channel_id that is bound for the
       output port and output DPI channel */
    result = cpb_dcs_egress_dpi_chnl_source_get( cpb_handle, 
                                                 egress_mux_output_port,
                                                 egress_mux_output_port_chnl,
                                                 &egress_mux_input_port, 
                                                 &rd_channel_id,
                                                 &rd_queue_id);


    /* retrieve ingress mux input port and channel for the egress mux port and channel */
    if (PMC_SUCCESS == result)
    {
        result = cpb_ingress_mux_input_port_data_get(cpb_handle, 
                                                     egress_mux_input_port, 
                                                     rd_queue_id,
                                                     &wr_queue_id, 
                                                     &ingress_mux_input_port,
                                                     &ingress_mux_input_port_chnl);       
    }

    /* based on the channel type, there are 3 cases */
    p_chnl_ctxt = cpb_handle->util_schd_handle[egress_mux_input_port]->var.schd_ctxt->chnl_ctxt;
    p_block_ctxt = &(cpb_handle->util_schd_handle[egress_mux_input_port]->cfg.block_ctxt);
    push_port_id = p_chnl_ctxt[rd_queue_id].dcs_sf1_push_port_id;
    queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, rd_queue_id);

    if (p_chnl_ctxt[rd_queue_id].state != UTIL_SCHD_CHNL_EQUIPPED)
    {
        PMC_RETURN(CPB_ERR_CHANNEL_NOT_EQUIPPED);
    }

    if (PMC_SUCCESS == result)
    {
        if(CPB_FIFO_SECONDARY_CH == cpb_handle->var.fifo_var_data[queue_index].chnl_type)
        {
            /* the specified chnl to be torn down is a multicast chnl */
            result = cpb_connect_data_delete( cpb_handle, ingress_mux_input_port, ingress_mux_input_port_chnl,
                                              egress_mux_output_port, egress_mux_output_port_chnl );

            if (PMC_SUCCESS == result)
            {
                cpb_fifo_var_data_and_chnl_state_reset( cpb_handle,
                                                        egress_mux_input_port,
                                                        rd_queue_id,
                                                        queue_index );
            }
            
        }
        else if (CPB_READER_PRIMARY == cpb_handle->var.fifo_var_data[queue_index].chnl_type) 
        {
            /* the specified chnl to be torn down is a multicast primary chnl */
            PMC_LOG_TRACE("\n deprovisioning a multicast primary channel ... \n");
            /* deprove all the readers within the same QS in the DCS and FIFO ram data */
            for(i=0; i < p_block_ctxt->num_schd_chnl; i++)
            {
                if( p_chnl_ctxt[i].dcs_sf1_push_port_id == push_port_id &&
                    p_chnl_ctxt[i].dcs_sf2_wr_queue_id == wr_queue_id &&
                    p_chnl_ctxt[i].state == UTIL_SCHD_CHNL_EQUIPPED &&
                    i !=  rd_queue_id )
                {
                    result = cpb_rd_queue_id_to_dest_chnl_get( cpb_handle, egress_mux_input_port,
                                                               i,  &temp_output_port, &temp_output_port_chnl );
                   

                    if (PMC_SUCCESS == result)
                    {
                        result = cpb_connect_data_delete( cpb_handle, ingress_mux_input_port, ingress_mux_input_port_chnl,
                                                          temp_output_port, temp_output_port_chnl );
                    }

                    if (PMC_SUCCESS == result)
                    {
                        cpb_fifo_var_data_and_chnl_state_reset( cpb_handle,
                                                                egress_mux_input_port,
                                                                rd_queue_id,
                                                                queue_index );
                    }
                }
            }

            /* destroy the FIFO resource in the SCPB*/
            if (PMC_SUCCESS == result)
            {
                result = cpb_connect_data_delete( cpb_handle, ingress_mux_input_port, ingress_mux_input_port_chnl,
                                                  egress_mux_output_port, egress_mux_output_port_chnl );
            }

            if (PMC_SUCCESS == result)
            {
                cpb_fifo_var_data_and_chnl_state_reset( cpb_handle,
                                                        egress_mux_input_port,
                                                        rd_queue_id,
                                                        queue_index );
            }
        }
        else if (CPB_SLAVE_ZONE_PRIMARY == cpb_handle->var.fifo_var_data[queue_index].chnl_type) 
        {
            /* the specified chnl to be torn down is a broadcast primary chnl */
            PMC_LOG_TRACE("\n deprovisioning a broadcast primary channel ... \n");

            for(k = 0;k < cpb_handle->cfg.num_dcs; k++)
            {
                p_chnl_ctxt = cpb_handle->util_schd_handle[k]->var.schd_ctxt->chnl_ctxt;
                p_block_ctxt = &(cpb_handle->util_schd_handle[k]->cfg.block_ctxt);

                for(i=0; i < p_block_ctxt->num_schd_chnl; i++)
                {
                    if( p_chnl_ctxt[i].dcs_sf1_push_port_id == push_port_id &&
                        p_chnl_ctxt[i].dcs_sf2_wr_queue_id == wr_queue_id &&
                        p_chnl_ctxt[i].state == UTIL_SCHD_CHNL_EQUIPPED )
                    {
                        result = cpb_rd_queue_id_to_dest_chnl_get( cpb_handle, 
                                                                   k, i, 
                                                                   &temp_output_port,
                                                                   &temp_output_port_chnl );
                        if (PMC_SUCCESS == result) 
                        {
                            result = cpb_connect_data_delete( cpb_handle, 
                                                              ingress_mux_input_port, 
                                                              ingress_mux_input_port_chnl,
                                                              temp_output_port, 
                                                              temp_output_port_chnl );
                        }

                        queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, k, i);
   
                        if (PMC_SUCCESS == result)
                        {
                            cpb_fifo_var_data_and_chnl_state_reset( cpb_handle,
                                                                    k,
                                                                    i,
                                                                    queue_index );
                        }
                    }
                }
            }
        }
    }

    PMC_RETURN(result);
} /* cpb_connect_data_delete_super_deprov */




/*
 *  Exported Interface Functions - End
 */

/*
 *  Process Functions - Start
 */
/*******************************************************************************
* cpb_chnl_deprov_internal
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deprovisions a CPB channel and recovers resources for usage
*   of other channels. If the channel to be deproved is a primary reader, detect
*   if there is any. In the event of channel multiplexing should non-primary
*   readers be present, they will be forcibly torn down by this function.
*   Note: there are three cases:

*   NOTE: the QSx_CH_EN is shut down when activating.

*   When tearing down a multicast channel, deprov the DCS, clear the FIFO ram
*   data and reset the read pointer of the FIFO. All the master port chnl cfg
*   should be cleared, zone threshold, hole and zone overide cfg.
*
*   When tearing down a multicast primary channel, tear down all the channels
*   that are associated with the same input channel within the current QS,
*   besides clearing the master port chnl cfg, clear the channel-queue-assoc
*   in the slv port channel cfg as well.
*
*   When tearing down a broadcast primary channel, tear down all the channels
*   that are associated with the same input channel in all QSs, besides the
*   operations performed for the multicast primary channel tearing down, clear
*   the slv port chnl cfg as well, including channel configuration, zone threshold
*   for the input channel and zone ovrd for the input channel.
*
*
* INPUTS:
*   *cpb_handle                 - The pointer to the CPB instance.
*   egress_mux_output_port      - Egress Mux Output Port associated with
*                                 destination subsystem.
*   egress_mux_output_port_chnl - Destination channel number relative to
*                                 egress_mux_output_port.  This is the DPI
*                                 channel that transfers data to downstream
*                                 subsystem
*   super_deprov                - boolean to indicate that this function is
*                                 used in bulk deprovisioning mode.
*                                 TRUE: bulk deprovisioning
*                                 FALSE: normal deprovisioning
*   backup_mode                 - If TRUE for DCPB CBRC input port, will provision 
*                                 channel excluding DCS and DPI Master Port.
*                                 Intended for 10GE fault replacement application.
*                                 Otherwise set to FALSE.
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_chnl_deprov_internal( cpb_handle_t *cpb_handle,
                                            UINT32 egress_mux_output_port,
                                            UINT32 egress_mux_output_port_chnl,
                                            BOOL8 super_deprov,
                                            BOOL8 backup_mode)
{
    UINT32 egress_mux_input_port;
    UINT32 rd_channel_id;
    UINT32 rd_queue_id;
    UINT32 wr_queue_id;
    UINT32 ingress_mux_input_port, ingress_mux_input_port_chnl;
    UINT32 alt_ingress_mux_input_port = 999, alt_ingress_mux_input_port_chnl = 999;
    UINT32 temp_output_port = 999, temp_output_port_chnl = 999;
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 queue_index, push_port_id, i, k;
    util_schd_chnl_ctxt_t *p_chnl_ctxt = NULL;
    util_schd_block_const_ctxt_t *p_block_ctxt = NULL;
    BOOL8 complete = FALSE;
    UINT32 pop_port_id;
    util_schd_chnl_state_t chnl_state = LAST_UTIL_SCHD_CHNL;
    UINT32 dcs_rd_channel_id, dcs_sf1_push_port_id, dcs_sf2_wr_queue_id;
    UINT32 cbrc_slv_dpi_channel_id = ~0, cbrc_rd_queue_id = ~0;

    PMC_ENTRY();

    cpb_handle->var.cpb_mem_pool_in_use[4] = TRUE; /* This indicates we are inside this API */

    /* search each DCS to deterimine which DCS contains the rd_channel_id that is bound for the
       output port and output DPI channel */
    result = cpb_dcs_egress_dpi_chnl_source_get( cpb_handle, egress_mux_output_port,
                                                 egress_mux_output_port_chnl,
                                                 &egress_mux_input_port, &rd_channel_id,
                                                 &rd_queue_id);
    if(result)PMC_RETURN(result);

    /* for backup mode recover the backup channel data */
    if(backup_mode == TRUE)
    {
        if(result == PMC_SUCCESS)
        {
             result = util_schd_dcs_chnl_data_get(cpb_handle->util_schd_handle[egress_mux_input_port],
                                                  rd_queue_id,
                                                  &chnl_state,
                                                  &dcs_rd_channel_id,
                                                  &dcs_sf1_push_port_id,
                                                  &dcs_sf2_wr_queue_id);
            if(result == PMC_SUCCESS && chnl_state != UTIL_SCHD_CHNL_OPERATIONAL)
                PMC_ASSERT(FALSE, CPB_ERR_CODE_ASSERT, 0, 0);
        }

        for(i = 0 ; i < cpb_handle->cfg.max_fifo_num && result == PMC_SUCCESS; i++)
        { 
            if(i != rd_queue_id)
            {
                 result = util_schd_dcs_chnl_data_get(cpb_handle->util_schd_handle[egress_mux_input_port],
                                                      i, /* read qid */
                                                      &chnl_state,
                                                      &dcs_rd_channel_id,
                                                      &dcs_sf1_push_port_id,
                                                      &dcs_sf2_wr_queue_id);
                if(dcs_rd_channel_id == rd_channel_id &&
                   dcs_sf2_wr_queue_id >= DCPB_SLV_PORT_2_CH_OFFSET &&
                   dcs_sf2_wr_queue_id < (DCPB_SLV_PORT_2_CH_OFFSET + 12) &&
                   chnl_state == UTIL_SCHD_CHNL_BACKUP)
                {
                    cbrc_rd_queue_id = i;
                    cbrc_slv_dpi_channel_id = dcs_sf2_wr_queue_id - DCPB_SLV_PORT_2_CH_OFFSET;
                    break;
                }
            }
        }


        PMC_ASSERT(cbrc_slv_dpi_channel_id != 999, CPB_ERR_CODE_ASSERT, 0, 0);
        if(result != PMC_SUCCESS) PMC_RETURN(result);

        rd_queue_id = cbrc_rd_queue_id;

    }



    /* MCPB Master Port 5 reads from QS2 */
    if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && egress_mux_output_port == CPB_MCPB_EGR_FEGE)
    {
        pop_port_id = CPB_MCPB_POP_PORT_2;
    } else {
        pop_port_id = egress_mux_input_port;
    }

    /* retrieve ingress mux input port and channel for the egress mux port and channel */
    if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && egress_mux_output_port < CPB_MCPB_EGR_CPU)
    {
        if(CPB_MCPB_EGR_SYS_ING == egress_mux_output_port || CPB_MCPB_EGR_LINE_ING == egress_mux_output_port)
        {
            ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
            alt_ingress_mux_input_port = CPB_MCPB_ING_CPU_INS;
        } else if(CPB_MCPB_EGR_SYS_EG == egress_mux_output_port || CPB_MCPB_EGR_LINE_EG == egress_mux_output_port) {
            ingress_mux_input_port = CPB_MCPB_ING_CPU_INS;
            alt_ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
        }
        ingress_mux_input_port_chnl = egress_mux_output_port_chnl * 2;
        alt_ingress_mux_input_port_chnl = egress_mux_output_port_chnl * 2 + 1;
        wr_queue_id = rd_queue_id;
    } else {
        if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type)
        {
            result = cpb_ingress_mux_input_port_data_get(cpb_handle, egress_mux_input_port, rd_queue_id,
                                                         &wr_queue_id, &ingress_mux_input_port,
                                                         &ingress_mux_input_port_chnl);
        }
        else
        {
            result = cpb_ingress_mux_input_port_data_get(cpb_handle, pop_port_id, rd_queue_id,
                                                         &wr_queue_id, &ingress_mux_input_port,
                                                         &ingress_mux_input_port_chnl);
        }

        if(result) PMC_RETURN(result);
    }

    /* based on the channel type, there are 3 cases */
    PMC_ASSERT(egress_mux_input_port < ( sizeof(cpb_handle->util_schd_handle)/sizeof(cpb_handle->util_schd_handle[0]) ), CPB_ERR_INVALID_ARG, egress_mux_input_port, 0 );
    p_chnl_ctxt = cpb_handle->util_schd_handle[egress_mux_input_port]->var.schd_ctxt->chnl_ctxt;
    p_block_ctxt = &(cpb_handle->util_schd_handle[egress_mux_input_port]->cfg.block_ctxt);
    push_port_id = p_chnl_ctxt[rd_queue_id].dcs_sf1_push_port_id;
    queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, rd_queue_id);

    if(p_chnl_ctxt[rd_queue_id].state != UTIL_SCHD_CHNL_EQUIPPED && backup_mode == FALSE)
    {
        PMC_RETURN(CPB_ERR_CHANNEL_NOT_EQUIPPED);
    }

    if (result) PMC_RETURN(result);
    if(CPB_FIFO_SECONDARY_CH == cpb_handle->var.fifo_var_data[queue_index].chnl_type)
    {
        /* the specified chnl to be torn down is a multicast chnl */
        PMC_LOG_TRACE("\n deprovisioning a secondary channel ... \n");
        result = cpb_secondary_reader_chnl_deprov( cpb_handle, egress_mux_output_port,
                                                   egress_mux_output_port_chnl,
                                                   egress_mux_input_port,rd_queue_id,
                                                   super_deprov );
       if (result) PMC_RETURN(result);

        if (super_deprov == FALSE)
        {
            result = cpb_connect_data_delete( cpb_handle, ingress_mux_input_port, ingress_mux_input_port_chnl,
                                              egress_mux_output_port, egress_mux_output_port_chnl );
            if(result) PMC_RETURN(result);
        }

    } else if (CPB_READER_PRIMARY == cpb_handle->var.fifo_var_data[queue_index].chnl_type) {
        /* the specified chnl to be torn down is a multicast primary chnl */
        PMC_LOG_TRACE("\n deprovisioning a multicast primary channel ... \n");
        /* deprove all the readers within the same QS in the DCS and FIFO ram data */
        for(i=0; i < p_block_ctxt->num_schd_chnl; i++)
        {
            if( p_chnl_ctxt[i].dcs_sf1_push_port_id == push_port_id &&
                p_chnl_ctxt[i].dcs_sf2_wr_queue_id == wr_queue_id &&
                p_chnl_ctxt[i].state == UTIL_SCHD_CHNL_EQUIPPED &&
                i !=  rd_queue_id )
            {
                result = cpb_rd_queue_id_to_dest_chnl_get( cpb_handle, egress_mux_input_port,
                                                           i,  &temp_output_port, &temp_output_port_chnl );
               if (result) PMC_RETURN(result);
                result = cpb_secondary_reader_chnl_deprov( cpb_handle, temp_output_port,
                                                           temp_output_port_chnl,egress_mux_input_port,i,
                                                           super_deprov );
               if (result) PMC_RETURN(result);

                if (super_deprov == FALSE)
                {
                    result = cpb_connect_data_delete( cpb_handle, ingress_mux_input_port, ingress_mux_input_port_chnl,
                                                      temp_output_port, temp_output_port_chnl );
                    if(result) PMC_RETURN(result);
                }

            }
        }

        /* destroy the FIFO resource in the SCPB*/
        result = cpb_queue_destroy( cpb_handle, pop_port_id, egress_mux_input_port, rd_queue_id, super_deprov);
       if (result) PMC_RETURN(result);
        result = cpb_secondary_reader_chnl_deprov( cpb_handle, egress_mux_output_port,
                                                   egress_mux_output_port_chnl,
                                                   egress_mux_input_port,rd_queue_id,
                                                   super_deprov );
       if (result) PMC_RETURN(result);

        if (super_deprov == FALSE)
        {
            result = cpb_connect_data_delete( cpb_handle, ingress_mux_input_port, ingress_mux_input_port_chnl,
                                              egress_mux_output_port, egress_mux_output_port_chnl );
            if(result) PMC_RETURN(result);
        }

        /* clear the chnl-queue-association cfg for the slv port chnl */
        cpb_dpi_slave_port_chnl_rd_queue_map_cfg(cpb_handle, ingress_mux_input_port,
                                             ingress_mux_input_port_chnl, pop_port_id, 0);


    } else if (CPB_SLAVE_ZONE_PRIMARY == cpb_handle->var.fifo_var_data[queue_index].chnl_type) {
        /* the specified chnl to be torn down is a broadcast primary chnl */
        PMC_LOG_TRACE("\n deprovisioning a broadcast primary channel ... \n");
        for(k = 0;k < cpb_handle->cfg.num_dcs; k++)
        {

            p_chnl_ctxt = cpb_handle->util_schd_handle[k]->var.schd_ctxt->chnl_ctxt;
            p_block_ctxt = &(cpb_handle->util_schd_handle[k]->cfg.block_ctxt);
            for(i=0; i < p_block_ctxt->num_schd_chnl; i++)
            {

                if( p_chnl_ctxt[i].dcs_sf1_push_port_id == push_port_id &&
                    p_chnl_ctxt[i].dcs_sf2_wr_queue_id == wr_queue_id &&
                    ((p_chnl_ctxt[i].state == UTIL_SCHD_CHNL_EQUIPPED && backup_mode == FALSE)||
                     (p_chnl_ctxt[i].state == UTIL_SCHD_CHNL_BACKUP && backup_mode == TRUE)))
                {
                    if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && egress_mux_output_port == CPB_MCPB_EGR_FEGE)
                    {
                        pop_port_id = CPB_MCPB_POP_PORT_2;
                    } else {
                        pop_port_id = k;
                    }

                    queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, i);

                    if( CPB_READER_PRIMARY == cpb_handle->var.fifo_var_data[queue_index].chnl_type ||
                        CPB_SLAVE_ZONE_PRIMARY == cpb_handle->var.fifo_var_data[queue_index].chnl_type )
                    {

                        /* destroy the FIFO resource in the SCPB*/
                        result = cpb_queue_destroy( cpb_handle, pop_port_id, egress_mux_input_port, i, super_deprov);

                       if (result) 
                       {
                           PMC_RETURN(result);
                       }
                       complete = TRUE;
                        /* destroy the alternate FIFO resource in the SCPB if applicable */
                        if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB && egress_mux_output_port < CPB_MCPB_EGR_CPU)
                        {
                            result = cpb_queue_destroy( cpb_handle, pop_port_id, egress_mux_input_port, i+1, super_deprov);
                            if (result) 
                            {
                                PMC_RETURN(result);
                            }
                        }

                    }

                    if(backup_mode == FALSE)
                    {
                        result = cpb_rd_queue_id_to_dest_chnl_get( cpb_handle, k, i, &temp_output_port,
                                                                   &temp_output_port_chnl );
                        if (result) 
                        {
                            PMC_RETURN(result);
                        }
                        result = cpb_secondary_reader_chnl_deprov( cpb_handle, temp_output_port,
                                                                   temp_output_port_chnl,
                                                                   k, i, super_deprov );
                        if (result) 
                        {
                            PMC_RETURN(result);
                        }
                        if (super_deprov == FALSE)
                        {
                            result = cpb_connect_data_delete( cpb_handle, ingress_mux_input_port, ingress_mux_input_port_chnl,
                                                              temp_output_port, temp_output_port_chnl );
                            if(result) PMC_RETURN(result);
                        }
                    }
                    else
                    {
                        result = cpb_connect_backup_chnl_data_delete( cpb_handle,
                                                                      ingress_mux_input_port,
                                                                      ingress_mux_input_port_chnl );
                        if(result) PMC_RETURN(result);

                        result = util_schd_chnl_state_set(cpb_handle->util_schd_handle[egress_mux_input_port], rd_queue_id, UTIL_SCHD_CHNL_START);
                        if (result != PMC_SUCCESS) {
                            PMC_RETURN(result);
                        }
                    }
                }
            } /* for(i=0; i < p_block_ctxt->num_schd_chnl; i++) */
            /* clear the chnl-queue-association cfg for the slv port chnl */
            cpb_dpi_slave_port_chnl_rd_queue_map_cfg(cpb_handle, ingress_mux_input_port,
                                                     ingress_mux_input_port_chnl, k, 0);
            /* If MCPB egress ports 0, 1, 2, 3 then clean up the alternate queue resources */
            if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB && egress_mux_output_port < CPB_MCPB_EGR_CPU)
            {
                cpb_dpi_slave_port_chnl_rd_queue_map_cfg(cpb_handle, alt_ingress_mux_input_port,
                                                         alt_ingress_mux_input_port_chnl, k, 0);
            }

        } /* for(k = 0;k < cpb_handle->cfg.num_dcs; k++) */
        if(complete==FALSE)  if (result) PMC_RETURN(result);
        /* clear the input channel configuration */
        cpb_dpi_slave_port_chnl_zone_thresh_cfg(cpb_handle,ingress_mux_input_port,
                                                ingress_mux_input_port_chnl,0,0,0);
        if(CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type)
            cpb_dpi_slave_port_chnl_ing_mux_output_port_sel_cfg(cpb_handle,ingress_mux_input_port,
                                                                ingress_mux_input_port_chnl,1,0);
        cpb_dpi_slave_port_chnl_zone_ovrd_cfg(cpb_handle,
                                              ingress_mux_input_port,
                                              ingress_mux_input_port_chnl,
                                              CPB_SLV_CHNL_ZONE_FIFO,0,0);

        /* For DCPB SIFD1/SIFD2 clear DCS XOFF mask */
        if(CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type  &&
            (egress_mux_output_port == CPB_DCPB_DPI_PORT_SIFD1 ||
             egress_mux_output_port == CPB_DCPB_DPI_PORT_SIFD2))
        {
            cpb_xoff_mask_set(cpb_handle,
                              egress_mux_output_port,
                              egress_mux_output_port,
                              egress_mux_output_port_chnl,
                              FALSE); /* FALSE -> clear bit */
        }
        cpb_dpi_slave_port_chnl_map_cfg(cpb_handle,
                                        ingress_mux_input_port,
                                        ingress_mux_input_port_chnl,
                                        0,
                                        0);

        /* clear the ZONE MASTER setting for all queue systems on this channel */
        cpb_dpi_slave_port_chnl_zone_source_cfg(cpb_handle,
                                                ingress_mux_input_port,
                                                ingress_mux_input_port_chnl,
                                                1, /* 1 means disable */
                                                0); /* queue system */
        cpb_dpi_slave_port_chnl_zone_source_cfg(cpb_handle,
                                                ingress_mux_input_port,
                                                ingress_mux_input_port_chnl,
                                                1,
                                                1);
        cpb_dpi_slave_port_chnl_zone_source_cfg(cpb_handle,
                                                ingress_mux_input_port,
                                                ingress_mux_input_port_chnl,
                                                1,
                                                2);
        cpb_dpi_slave_port_chnl_zone_source_cfg(cpb_handle,
                                                ingress_mux_input_port,
                                                ingress_mux_input_port_chnl,
                                                1,
                                                3);

        /* If MCPB egress ports 0, 1, 2, 3 then clean up the alternate queue resources */
        if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB && egress_mux_output_port < CPB_MCPB_EGR_CPU)
        {
            /* clear the input channel configuration */
            cpb_dpi_slave_port_chnl_zone_thresh_cfg(cpb_handle,alt_ingress_mux_input_port,
                                                    alt_ingress_mux_input_port_chnl,0,0,0);
            if(CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type)
                cpb_dpi_slave_port_chnl_ing_mux_output_port_sel_cfg(cpb_handle,alt_ingress_mux_input_port,
                                                                    alt_ingress_mux_input_port_chnl,1,0);
            cpb_dpi_slave_port_chnl_zone_ovrd_cfg(cpb_handle,
                                                  ingress_mux_input_port,
                                                  ingress_mux_input_port_chnl,
                                                  CPB_SLV_CHNL_ZONE_FIFO,0,0);

            cpb_dpi_slave_port_chnl_map_cfg(cpb_handle,
                                            ingress_mux_input_port,
                                            ingress_mux_input_port_chnl,
                                            0,
                                            0);

            /* clear the ZONE MASTER setting for all queue systems on this
             * channel */
            cpb_dpi_slave_port_chnl_zone_source_cfg(cpb_handle,
                                                    alt_ingress_mux_input_port,
                                                    alt_ingress_mux_input_port_chnl,
                                                    1,
                                                    0);
            cpb_dpi_slave_port_chnl_zone_source_cfg(cpb_handle,
                                                    alt_ingress_mux_input_port,
                                                    alt_ingress_mux_input_port_chnl,
                                                    1,
                                                    1);
            cpb_dpi_slave_port_chnl_zone_source_cfg(cpb_handle,
                                                    alt_ingress_mux_input_port,
                                                    alt_ingress_mux_input_port_chnl,
                                                    1,
                                                    2);
            cpb_dpi_slave_port_chnl_zone_source_cfg(cpb_handle,
                                                    alt_ingress_mux_input_port,
                                                    alt_ingress_mux_input_port_chnl,
                                                    1,
                                                    3);

        }

    }
    else
    {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }


    cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */

    PMC_RETURN(result);
} /* cpb_chnl_deprov_internal */



/*******************************************************************************
* cpb_chnl_activate_internal
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function activates a channel in the CPB subsystem as a function of the
*   read channel ID.
*
*   This function sets enable bits appropriately and performs any necessary
*   channel resets.
*
* INPUTS:
*
*   *cpb_handle                  - pointer to CPB handle instance.
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*   super_prov                   - boolean value to indicate if the device is
*                                  to be configured in a high performance mode.
*                                  TRUE: high performance code
*                                  FALSE: normal performance code
*
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_chnl_activate_internal( cpb_handle_t *cpb_handle,
                                              UINT32 egress_mux_output_port,
                                              UINT32 egress_mux_output_port_chnl,
                                              BOOL8 super_prov )
{
    UINT32 egress_mux_input_port;
    UINT32 rd_channel_id;
    UINT32 rd_queue_id;
    UINT32 wr_queue_id;
    UINT32 ingress_mux_input_port = 999, ingress_mux_input_port_chnl = 999;
    UINT32 alt_ingress_mux_input_port = 999, alt_ingress_mux_input_port_chnl = 999;
    util_schd_chnl_ctxt_t *p_chnl_ctxt = NULL;
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 push_port_id = 999;
    UINT32 pop_port_id = 999;
    BOOL8 alt_queue_exists = FALSE;
    UINT32 alt_rd_queue_id = 999, alt_wr_queue_id = 999;
    BOOL8 bscope = FALSE;
    UINT32 queue_index;

    PMC_ENTRY();

    cpb_handle->var.cpb_mem_pool_in_use[4] = TRUE; /* This indicates we are inside this API */

    /* search each DCS to deterimine which DCS contains the rd_channel_id that is bound for the
       output port and output DPI channel */
    result = cpb_dcs_egress_dpi_chnl_source_get( cpb_handle, egress_mux_output_port,
                                                 egress_mux_output_port_chnl,
                                                 &egress_mux_input_port, &rd_channel_id,
                                                 &rd_queue_id);
    if(PMC_SUCCESS == result)
    {
        PMC_LOG_TRACE("cpb_dcs_egress_dpi_chnl_source_get results \n egress_mux_input_port: %u \n rd_channel_id: %u \n rd_queue_id: %u \n",
                egress_mux_input_port,
                rd_channel_id,
                rd_queue_id);

        if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && egress_mux_output_port == CPB_MCPB_EGR_FEGE)
        {
            pop_port_id = CPB_MCPB_POP_PORT_2;
        } else {
            pop_port_id = egress_mux_input_port;
        }


    }

    if(PMC_SUCCESS == result){
        /* retrieve ingress mux input port and channel for the egress mux port and channel */
        if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && egress_mux_output_port < CPB_MCPB_DPI_PORT_4)
        {

            if(CPB_MCPB_EGR_SYS_ING == egress_mux_output_port || CPB_MCPB_EGR_LINE_ING == egress_mux_output_port)
            {
                ingress_mux_input_port = MCPB_FEGE_PORT_NUM;
                ingress_mux_input_port_chnl = egress_mux_output_port_chnl * 2;
                alt_ingress_mux_input_port = MCPB_CPU_PORT_NUM;
                alt_ingress_mux_input_port_chnl = egress_mux_output_port_chnl * 2 + 1;
            } else if(CPB_MCPB_EGR_SYS_EG == egress_mux_output_port || CPB_MCPB_EGR_LINE_EG == egress_mux_output_port) {
                ingress_mux_input_port = MCPB_CPU_PORT_NUM;
                ingress_mux_input_port_chnl = egress_mux_output_port_chnl * 2;
                alt_ingress_mux_input_port = MCPB_FEGE_PORT_NUM;
                alt_ingress_mux_input_port_chnl = egress_mux_output_port_chnl * 2 + 1;
            }

            alt_queue_exists = TRUE;
            rd_queue_id = ingress_mux_input_port_chnl;
            wr_queue_id = ingress_mux_input_port_chnl;
            alt_rd_queue_id = alt_ingress_mux_input_port_chnl;
            alt_wr_queue_id = alt_ingress_mux_input_port_chnl;

            PMC_LOG_TRACE("cpb_alternate queue data results \n ingress_mux_input_port: %u \n ingress_mux_input_port_chnl: %u \n alt_ingress_mux_input_port: %u \n",
                    ingress_mux_input_port,
                    ingress_mux_input_port_chnl,
                    alt_ingress_mux_input_port);
            PMC_LOG_TRACE("alt_ingress_mux_input_port_chnl: %u \n rd_queue_id: %u \n wr_queue_id: %u \n",
                      alt_ingress_mux_input_port_chnl,
                      rd_queue_id,
                      wr_queue_id);
            PMC_LOG_TRACE("alt_rd_queue_id: %u \n alt_wr_queue_id: %u \n",
                      alt_rd_queue_id,
                      alt_wr_queue_id);

        } else {
            if ( CPB_INSTANCE_MCPB != cpb_handle->cfg.cpb_type)
            {
                result = cpb_ingress_mux_input_port_data_get(cpb_handle, pop_port_id, rd_queue_id,
                                                             &wr_queue_id, &ingress_mux_input_port,
                                                             &ingress_mux_input_port_chnl);
            }
            else
            {
                result = cpb_ingress_mux_input_port_data_get(cpb_handle, egress_mux_input_port, rd_queue_id,
                                                             &wr_queue_id, &ingress_mux_input_port,
                                                             &ingress_mux_input_port_chnl);
            }
        }
    }

    if(PMC_SUCCESS == result)
    {
        PMC_LOG_TRACE("cpb_ingress_mux_input_port_data_get results \n wr_queue_id: %u \n ingress_mux_input_port: %u \n ingress_mux_input_port_chnl: %u \n",
                wr_queue_id,
                ingress_mux_input_port,
                ingress_mux_input_port_chnl);

        /* take the FIFO pointer out of reset */
        PMC_ASSERT(egress_mux_input_port < ( sizeof(cpb_handle->util_schd_handle)/sizeof(cpb_handle->util_schd_handle[0]) ), CPB_ERR_INVALID_ARG, egress_mux_input_port, 0 );
        p_chnl_ctxt = cpb_handle->util_schd_handle[egress_mux_input_port]->var.schd_ctxt->chnl_ctxt;
        push_port_id = p_chnl_ctxt[rd_queue_id].dcs_sf1_push_port_id;

    }

    queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, rd_queue_id);
    bscope = (CPB_FIFO_SECONDARY_CH == cpb_handle->var.fifo_var_data[queue_index].chnl_type) ? FALSE : TRUE;

    if(bscope == FALSE && PMC_SUCCESS == result)
    {   
        p_chnl_ctxt = cpb_handle->util_schd_handle[egress_mux_input_port]->var.schd_ctxt->chnl_ctxt;
        if(p_chnl_ctxt[rd_queue_id].rate == 40000 && UTIL_SCHD_1M_BIT_SEC == p_chnl_ctxt[rd_queue_id].rate_units)
        {
            bscope = TRUE;
        }
    }

    if(PMC_SUCCESS == result && CPB_INSTANCE_MCPB != cpb_handle->cfg.cpb_type)
    {
        result = cpb_fifo_reset_cfg(cpb_handle, push_port_id,
                                    pop_port_id, bscope, wr_queue_id, rd_queue_id, 1);
    }

    /* perform DCS_Q_RESET */
    if(PMC_SUCCESS == result && CPB_INSTANCE_MCPB != cpb_handle->cfg.cpb_type)
    {
        result = cpb_dcs_queue_reset(cpb_handle, egress_mux_input_port, rd_queue_id);
    }

    if(PMC_SUCCESS == result)
    {
        result = cpb_fifo_reset_cfg(cpb_handle, push_port_id,
                                    pop_port_id, bscope, wr_queue_id, rd_queue_id, 0);
    }

    /* if present take the alternant FIFO pointer out of reset */
    if(PMC_SUCCESS == result && alt_queue_exists==TRUE)
    {
        /* alternate queue shares same push/port id as main channel */
        result = cpb_fifo_reset_cfg(cpb_handle, push_port_id,
                                    pop_port_id, TRUE, alt_wr_queue_id, alt_rd_queue_id, 0);
    }

    /* update the channel state for DCS WRR scheduling */
    if(PMC_SUCCESS == result){
        if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type
           && egress_mux_output_port < CPB_MCPB_EGR_CPU
           && 0 != (rd_channel_id & 0x0001))
        {
            rd_channel_id = rd_channel_id - 1;
        }

        if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type)
        {
            result = cpb_dcs_chnl_activate(cpb_handle, egress_mux_input_port, rd_queue_id);
        }
        else
        {
            result = cpb_dcs_chnl_activate(cpb_handle, pop_port_id, rd_queue_id);
        }
    }

    if (PMC_SUCCESS == result)
    {
        if (super_prov == FALSE)
        {
            /* called only when bulk provision is disabled (i.e., provision mode is COREOTN_ODU_CHNL_PROV_IN_INCREMENT) */
            /* update the DCS WRR scheduler */
            result = cpb_dcs_page_update_and_swap(cpb_handle, egress_mux_input_port);
        }
        else {
            if (CPB_INSTANCE_OCPB == cpb_handle->cfg.cpb_type)
            {
                result = cpb_dcs_page_update(cpb_handle, egress_mux_input_port);
            }
            else {
                result = cpb_dcs_page_update_and_swap(cpb_handle, egress_mux_input_port);
            }
        }
    }

    if(PMC_SUCCESS == result)
    {
        if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && egress_mux_output_port < CPB_MCPB_DPI_PORT_4)
        {
            result = cpb_dpi_slave_port_chnl_enbl(cpb_handle, ingress_mux_input_port,
                                                  ingress_mux_input_port_chnl, pop_port_id, 1);
            if(PMC_SUCCESS == result)
            {
                result = cpb_dpi_slave_port_chnl_enbl(cpb_handle, alt_ingress_mux_input_port,
                                                      alt_ingress_mux_input_port_chnl, pop_port_id, 1);
            }
        }
        else
        {
            result = cpb_dpi_slave_port_chnl_enbl(cpb_handle, ingress_mux_input_port, ingress_mux_input_port_chnl, pop_port_id, 1);
        }
    }

    cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */


    if (PMC_SUCCESS == result &&
        (cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB || cpb_handle->cfg.cpb_type == CPB_INSTANCE_OCPB)) {
        cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.state = UTIL_GLOBAL_CHNL_OPERATIONAL;
        cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.state = UTIL_GLOBAL_CHNL_OPERATIONAL;
    }


    PMC_RETURN(result);

} /* cpb_chnl_activate_internal */


/*******************************************************************************
* cpb_chnl_deactivate_internal
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function deactivates a channel in the CPB subsystem as a function of the
*   master DPI port and master DPI port channel ID.
*   This function disables and enable bits appropriately and performs any necessary
*   channel resets.
*   If the channel to be deactivated is a primary channel, the function tests if
*   there is any other secondary channel in operational state, if yes, return warning
*   The only case to turn off the source channel is deactivating a primary channel
*   and there is no secondary channel in operational state. If deactivating a secondary
*   channel, only
*
*
* INPUTS:
*   *cpb_handle                  -  pointer to the cpb handle instance
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*   super_deprov                 -  boolean value to indicate if the device is
*                                   to be configured in high performance mode.
*                                   TRUE: high performance code
*                                           When this option is used,
*                                           DCS instance in OCPB will be swapped
*                                           only once for all LO ODU channels
*                                           destined to a DCS instance.
*                                   FALSE: normal performance code
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_chnl_deactivate_internal( cpb_handle_t *cpb_handle,
                                                UINT32 egress_mux_output_port,
                                                UINT32 egress_mux_output_port_chnl,
                                                BOOL8 super_deprov )
{
    UINT32 egress_mux_input_port;
    UINT32 rd_channel_id;
    UINT32 rd_queue_id;
    UINT32 wr_queue_id;
    UINT32 ingress_mux_input_port = 999, ingress_mux_input_port_chnl = 999;
    UINT32 alt_ingress_mux_input_port = 999, alt_ingress_mux_input_port_chnl = 999;
    UINT32 alt_rd_queue_id = 999, alt_wr_queue_id = 999;
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 empty_word_index, empty_bit_index, num_failed_polls;
    UINT32 queue_index, num_readers = 0, push_port_id;
    util_schd_chnl_ctxt_t *p_chnl_ctxt = NULL;
    BOOL8 turn_off_source = TRUE;
    UINT32 pop_port_id;

    PMC_ENTRY();

    cpb_handle->var.cpb_mem_pool_in_use[4] = TRUE; /* This indicates we are inside this API */

    /* search each DCS to deterimine which DCS contains the rd_channel_id that is bound for the
       output port and output DPI channel */
    result = cpb_dcs_egress_dpi_chnl_source_get( cpb_handle, egress_mux_output_port,
                                                 egress_mux_output_port_chnl,
                                                 &egress_mux_input_port, &rd_channel_id,
                                                 &rd_queue_id);
    if(result != PMC_SUCCESS)
    {
        cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */
        PMC_RETURN(result);
    }
    /* MCPB Master Port 5 reads from QS2 */
    if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && egress_mux_output_port == CPB_MCPB_EGR_FEGE)
    {
        pop_port_id = CPB_MCPB_POP_PORT_2;
    } else {
        pop_port_id = egress_mux_input_port;
    }

    /* retrieve ingress mux input port and channel for the egress mux port and channel */
    if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && egress_mux_output_port < CPB_MCPB_DPI_PORT_4)
        {

            if(CPB_MCPB_EGR_SYS_ING == egress_mux_output_port || CPB_MCPB_EGR_LINE_ING == egress_mux_output_port)
            {
                ingress_mux_input_port = MCPB_FEGE_PORT_NUM;
                ingress_mux_input_port_chnl = egress_mux_output_port_chnl * 2;
                alt_ingress_mux_input_port = MCPB_CPU_PORT_NUM;
                alt_ingress_mux_input_port_chnl = egress_mux_output_port_chnl * 2 + 1;
            } else if(CPB_MCPB_EGR_SYS_EG == egress_mux_output_port || CPB_MCPB_EGR_LINE_EG == egress_mux_output_port) {
                ingress_mux_input_port = MCPB_CPU_PORT_NUM;
                ingress_mux_input_port_chnl = egress_mux_output_port_chnl * 2;
                alt_ingress_mux_input_port = MCPB_FEGE_PORT_NUM;
                alt_ingress_mux_input_port_chnl = egress_mux_output_port_chnl * 2 + 1;
            }

            rd_queue_id = ingress_mux_input_port_chnl;
            wr_queue_id = ingress_mux_input_port_chnl;
            alt_rd_queue_id = alt_ingress_mux_input_port_chnl;
            alt_wr_queue_id = alt_ingress_mux_input_port_chnl;

            PMC_LOG_TRACE("cpb_alternate queue data results \n ingress_mux_input_port: %u \n ingress_mux_input_port_chnl: %u \n alt_ingress_mux_input_port: %u \n",
                    ingress_mux_input_port,
                    ingress_mux_input_port_chnl,
                    alt_ingress_mux_input_port);
            PMC_LOG_TRACE("alt_ingress_mux_input_port_chnl: %u \n rd_queue_id: %u \n wr_queue_id: %u \n",
                      alt_ingress_mux_input_port_chnl,
                      rd_queue_id,
                      wr_queue_id);
            PMC_LOG_TRACE("alt_rd_queue_id: %u \n alt_wr_queue_id: %u \n",
                      alt_rd_queue_id,
                      alt_wr_queue_id);

        }
    else {
        if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type)
        {
            result = cpb_ingress_mux_input_port_data_get(cpb_handle, egress_mux_input_port, rd_queue_id,
                                                         &wr_queue_id, &ingress_mux_input_port,
                                                         &ingress_mux_input_port_chnl);
        }
        else
        {
            result = cpb_ingress_mux_input_port_data_get(cpb_handle, pop_port_id, rd_queue_id,
                                                         &wr_queue_id, &ingress_mux_input_port,
                                                         &ingress_mux_input_port_chnl);
        }
    }
    if(result)
    {
        cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */
        PMC_RETURN(result);
    }

    if(cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB)
    {
        /* identify if this is a primary channel, and it's illegal to
        deactivate the primary channel if there exists secondary channels in operational state*/
        p_chnl_ctxt = cpb_handle->util_schd_handle[egress_mux_input_port]->var.schd_ctxt->chnl_ctxt;
        queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, rd_queue_id);
        if(p_chnl_ctxt[rd_queue_id].state != UTIL_SCHD_CHNL_OPERATIONAL)
        {
            cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */
            PMC_RETURN(CPB_ERR_CHANNEL_NOT_OPERATIONAL);
        }

        if(CPB_SLAVE_ZONE_PRIMARY == cpb_handle->var.fifo_var_data[queue_index].chnl_type)
        {
            UINT8 test_port = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_port;
            UINT8 test_chnl = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_chnl;
            UINT8 old_test_port = test_port;
            PMC_LOG_TRACE("\n deactivating a broadcast primary channel ... \n");
            num_readers = 1;
            while(test_port != CPB_INDEX_LAST && num_readers == 1)
            {
                if(!(test_port == (UINT8)egress_mux_output_port && test_chnl == (UINT8)egress_mux_output_port_chnl) &&
                   (cpb_handle->var.cpb_connect_data->chnl[test_port][test_chnl].mst.state == UTIL_GLOBAL_CHNL_OPERATIONAL))
                {
                    num_readers++;
                }
                test_port = cpb_handle->var.cpb_connect_data->chnl[old_test_port][test_chnl].mst.next_dest_mst_port;
                test_chnl = cpb_handle->var.cpb_connect_data->chnl[old_test_port][test_chnl].mst.next_dest_mst_chnl; 
                old_test_port = test_port;
            }


            PMC_LOG_TRACE("\n num_readers = %u \n", num_readers);
            if(num_readers > 1)
            {
                cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */
                PMC_RETURN(CPB_ERR_DEACT_PRIMARY_WITH_SECONDARY);
            }

        } else if(CPB_READER_PRIMARY == cpb_handle->var.fifo_var_data[queue_index].chnl_type){

            UINT8 test_port = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_port;
            UINT8 test_chnl = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_chnl;
            UINT8 old_test_port = test_port;
            PMC_LOG_TRACE("\n deactivating a multicast primary channel ... \n");
            num_readers = 1;
            while(test_port != CPB_INDEX_LAST && num_readers == 1)
            {
                if(!(test_port == (UINT8)egress_mux_output_port && test_chnl == (UINT8)egress_mux_output_port_chnl) &&
                   (cpb_handle->var.cpb_connect_data->chnl[test_port][test_chnl].mst.dcs_inst == 
                    cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.dcs_inst) &&
                   (cpb_handle->var.cpb_connect_data->chnl[test_port][test_chnl].mst.state == UTIL_GLOBAL_CHNL_OPERATIONAL))
                {
                    if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB)
                    {
                        /* DCPB may have common slave port and channel use more than one push port to access a queue system pop port and dcs instance 
                           confirm the push port is common to both channels before confirming it is a multicast*/
                        UINT8 test_rqid = cpb_handle->var.cpb_connect_data->chnl[test_port][test_chnl].mst.rd_queue_id;
                        UINT8 egress_rqid = cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.rd_queue_id;
                        p_chnl_ctxt = cpb_handle->util_schd_handle[cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.dcs_inst]->var.schd_ctxt->chnl_ctxt;
                        if(p_chnl_ctxt[test_rqid].dcs_sf1_push_port_id == p_chnl_ctxt[egress_rqid].dcs_sf1_push_port_id)
                        {
                            num_readers++;
                        }
                    }
                    else
                    {
                        num_readers++;
                    }
                }
                test_port = cpb_handle->var.cpb_connect_data->chnl[old_test_port][test_chnl].mst.next_dest_mst_port;
                test_chnl = cpb_handle->var.cpb_connect_data->chnl[old_test_port][test_chnl].mst.next_dest_mst_chnl; 
                old_test_port = test_port;
            }

            PMC_LOG_TRACE("\n num_readers = %u \n", num_readers);
            if(num_readers > 1)
            {
                cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */ 
                PMC_RETURN(CPB_ERR_DEACT_PRIMARY_WITH_SECONDARY);
            }

        } else {
            turn_off_source = FALSE;
            PMC_LOG_TRACE("\n deactivating a secondary channel ... \n");
        }
    }

    /* turn off the source QS_CH_EN */
    if(PMC_SUCCESS == result && TRUE == turn_off_source){
        if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && egress_mux_output_port < CPB_MCPB_EGR_CPU)
        {
            result = cpb_dpi_slave_port_chnl_enbl(cpb_handle, ingress_mux_input_port,
                                                  ingress_mux_input_port_chnl, pop_port_id, 0);
            /* poll to see if the FIFO is empty, if empty then turn off the reader*/
            if(PMC_SUCCESS == result)
            {
                rd_queue_id = ingress_mux_input_port_chnl;
                empty_word_index = rd_queue_id / CPB_BITS_IN_32_BIT_WORD;
                empty_bit_index = rd_queue_id % CPB_BITS_IN_32_BIT_WORD;

                /* note: when the firmware Q is used,... this error check is ignored */
                l5sys_ignore_poll_errors(cpb_handle);
                result = qs_field_range_FIFO_PKT_EMPTY_poll ( NULL, cpb_handle, pop_port_id,
                                                              empty_word_index, empty_bit_index, empty_bit_index,
                                                              1, PMC_POLL_EQUAL, CPB_NUM_USEC_ITERATIONS,
                                                              &num_failed_polls, 1 );
                l5sys_abort_on_poll_errors(cpb_handle);
                if(result==PMC_SHARED_ERR_CODE_POLL_TIMEOUT)
                {
                    PMC_LOG(PMC_LOG_SEV_HIGHEST, PMC_SHARED_ERR_CODE_POLL_TIMEOUT, 0, 0);
                    PMC_LOG_TRACE("PMC_SHARED_ERR_CODE_POLL_TIMEOUT");
                    result = PMC_SUCCESS;
                }

            }

            result = cpb_dpi_slave_port_chnl_enbl(cpb_handle, alt_ingress_mux_input_port,
                                                  alt_ingress_mux_input_port_chnl, pop_port_id, 0);
            /* poll to see if the FIFO is empty, if empty then turn off the reader*/
            if(PMC_SUCCESS == result)
            {
                alt_rd_queue_id = alt_ingress_mux_input_port_chnl;
                empty_word_index = alt_rd_queue_id / CPB_BITS_IN_32_BIT_WORD;
                empty_bit_index = alt_rd_queue_id % CPB_BITS_IN_32_BIT_WORD;
                /* note: when the firmware Q is used,... this error check is ignored */
                l5sys_ignore_poll_errors(cpb_handle);
                result = qs_field_range_FIFO_PKT_EMPTY_poll ( NULL, cpb_handle, pop_port_id,
                                                              empty_word_index, empty_bit_index, empty_bit_index,
                                                              1, PMC_POLL_EQUAL, CPB_NUM_USEC_ITERATIONS,
                                                              &num_failed_polls, 1 );
                l5sys_abort_on_poll_errors(cpb_handle);
                if(result==PMC_SHARED_ERR_CODE_POLL_TIMEOUT)
                {
                    PMC_LOG(PMC_LOG_SEV_HIGHEST, PMC_SHARED_ERR_CODE_POLL_TIMEOUT, 0, 0);
                    PMC_LOG_TRACE("PMC_SHARED_ERR_CODE_POLL_TIMEOUT");
                    result = PMC_SUCCESS;
                }

            }

        } else {
            /* For DCPB SIFD1/SIFD2 Ports force XOFF backpressure towards SIFD */
            if(CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type &&
               (ingress_mux_input_port == CPB_DCPB_DPI_PORT_SIFD1 ||
                ingress_mux_input_port == CPB_DCPB_DPI_PORT_SIFD2))
            {
                result = cpb_dpi_slave_port_chnl_zone_ovrd_cfg(cpb_handle, ingress_mux_input_port, ingress_mux_input_port_chnl, CPB_SLV_CHNL_ZONE_FORCE,0,0);
            }

            if(PMC_SUCCESS == result)
            {
                result = cpb_dpi_slave_port_chnl_enbl(cpb_handle, ingress_mux_input_port,
                                                ingress_mux_input_port_chnl, pop_port_id, 0);
            }
            /* poll to see if the FIFO is empty, if empty then turn off the reader*/
            if(PMC_SUCCESS == result)
            {
                if (super_deprov == FALSE)
                {
                    empty_word_index = rd_queue_id / CPB_BITS_IN_32_BIT_WORD;
                    empty_bit_index = rd_queue_id % CPB_BITS_IN_32_BIT_WORD;
                    /* note: when the firmware Q is used,... this error check is ignored */
                    l5sys_ignore_poll_errors(cpb_handle);
                    result = qs_field_range_FIFO_PKT_EMPTY_poll ( NULL, cpb_handle, pop_port_id,
                                                                  empty_word_index, empty_bit_index, empty_bit_index,
                                                                  1, PMC_POLL_EQUAL, CPB_NUM_USEC_ITERATIONS,
                                                                  &num_failed_polls, 1 );
                    l5sys_abort_on_poll_errors(cpb_handle);
                    if(result==PMC_SHARED_ERR_CODE_POLL_TIMEOUT)
                    {
                        PMC_LOG(PMC_LOG_SEV_HIGHEST, PMC_SHARED_ERR_CODE_POLL_TIMEOUT, 0, 0);
                        PMC_LOG_TRACE("PMC_SHARED_ERR_CODE_POLL_TIMEOUT");
                        result = PMC_SUCCESS;
                    }
                }
            }
        }

    }/* turn off the source QS_CH_EN end*/

    /* update the channel state for DCS WRR scheduling into EQUIPPED */
    if(PMC_SUCCESS == result)
    {
        /* take the FIFO pointer into reset */
        p_chnl_ctxt = cpb_handle->util_schd_handle[egress_mux_input_port]->var.schd_ctxt->chnl_ctxt;
        push_port_id = p_chnl_ctxt[rd_queue_id].dcs_sf1_push_port_id;

        if(PMC_SUCCESS == result)
        {
            result = cpb_dcs_chnl_deactivate(cpb_handle, egress_mux_input_port, rd_queue_id);
        }

        if(PMC_SUCCESS == result)
        {
            /* update the DCS WRR scheduler to remove the read channel from DCS calendar */
            if (super_deprov == FALSE)
            {
                result = cpb_dcs_page_update_and_swap(cpb_handle, egress_mux_input_port);
                PMC_ATOMIC_YIELD(cpb_handle->base.parent_handle,0);

            }
            else {
                if (CPB_INSTANCE_OCPB == cpb_handle->cfg.cpb_type)
                {
                    result = cpb_dcs_page_update(cpb_handle, egress_mux_input_port);
                }
                else {
                    result = cpb_dcs_page_update_and_swap(cpb_handle, egress_mux_input_port);
                    PMC_ATOMIC_YIELD(cpb_handle->base.parent_handle,0);
                }
            }
        }

        /* Do not reset the write queue pointer for multicast channels */
        if (TRUE == turn_off_source) {

            cpb_fifo_reset_cfg(cpb_handle, push_port_id, pop_port_id, TRUE, wr_queue_id, rd_queue_id, 1);

            /* Reset the alternate queue as well */
            if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type  && egress_mux_output_port < CPB_MCPB_EGR_CPU)
            {
                cpb_fifo_reset_cfg(cpb_handle, push_port_id, pop_port_id, TRUE, alt_wr_queue_id, alt_rd_queue_id, 1);
            }
        } else {
            cpb_fifo_reset_cfg(cpb_handle, 0, pop_port_id, FALSE, 0, rd_queue_id, 1);
        }

        if(result == PMC_SUCCESS)
        {
            if (((CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type || CPB_INSTANCE_OCPB == cpb_handle->cfg.cpb_type)
                        &&  1 < egress_mux_output_port) ||
                    (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type &&  CPB_MCPB_DPI_PORT_2 > egress_mux_output_port))
            {
                result = cpb_dcs_queue_reset(cpb_handle, egress_mux_input_port, rd_queue_id);
            }
        }

    }

    cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */


    if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB || cpb_handle->cfg.cpb_type == CPB_INSTANCE_OCPB) {
        cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.state = UTIL_GLOBAL_CHNL_EQUIPPED;
        cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.state = UTIL_GLOBAL_CHNL_EQUIPPED;
    }


    PMC_RETURN(result);

} /* cpb_chnl_deactivate_internal */


/*******************************************************************************
* cpb_chnl_switch_internal
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function switches a primary and a secondary channel in the CPB subsystem.
*   If channel is PRIMARY, the function will auto-detect its 1st secondary channel and switch.
*   If channel is SECONDARY, the function will do nothing.
*
*
* INPUTS:
*   *cpb_handle                  -  pointer to the cpb handle instance
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_chnl_switch_internal( cpb_handle_t *cpb_handle,
                                            UINT32 egress_mux_output_port,
                                            UINT32 egress_mux_output_port_chnl)
{
    PMC_ERROR result = PMC_SUCCESS;
    BOOL8 is_broadcast = FALSE;
    BOOL8 is_multicast = FALSE;
    UINT32 egress_mux_input_port;
    UINT32 rd_channel_id;
    UINT32 rd_queue_id;
    UINT32 wr_queue_id;
    UINT32 ingress_mux_input_port = 999, ingress_mux_input_port_chnl = 999;
    UINT32 pop_port_id;
    UINT32 sec_q_index, sec_egress_port = 999, sec_egress_chnl = 999;
    UINT32 sec_egress_mux_input_port = 999, sec_rd_chnl_id, sec_rd_queue_id, sec_pop_port_id;    
    UINT32 queue_index, num_readers = 0;
    util_schd_chnl_ctxt_t *p_chnl_ctxt = NULL;

    PMC_ENTRY();

    cpb_handle->var.cpb_mem_pool_in_use[4] = TRUE; /* This indicates we are inside this API */

    /* search each DCS to deterimine which DCS contains the rd_channel_id that is bound for the
       output port and output DPI channel */
    result = cpb_dcs_egress_dpi_chnl_source_get( cpb_handle, egress_mux_output_port,
                                                 egress_mux_output_port_chnl,
                                                 &egress_mux_input_port, &rd_channel_id,
                                                 &rd_queue_id);
    if(result != PMC_SUCCESS)
    {
        cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */
        PMC_RETURN(result);
    }
    /* MCPB Master Port 5 reads from QS2 */
    if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type)
    {
        PMC_RETURN(CPB_ERR_INVALID_CPB_TYPE);
    } else {
        pop_port_id = egress_mux_input_port;
    }

    /* retrieve ingress mux input port and channel for the egress mux port and channel */ 
    result = cpb_ingress_mux_input_port_data_get(cpb_handle, pop_port_id, rd_queue_id,
                                                 &wr_queue_id, &ingress_mux_input_port,
                                                 &ingress_mux_input_port_chnl);

    if(result)
    {
        cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */
        PMC_RETURN(result);
    }

    is_broadcast = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_broadcast;
    is_multicast = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_multicast;
    p_chnl_ctxt = cpb_handle->util_schd_handle[egress_mux_input_port]->var.schd_ctxt->chnl_ctxt;
    queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, rd_queue_id);
    if(p_chnl_ctxt[rd_queue_id].state != UTIL_SCHD_CHNL_OPERATIONAL)
    {
        cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */
        PMC_RETURN(CPB_ERR_CHANNEL_NOT_OPERATIONAL);
    }

    if(CPB_SLAVE_ZONE_PRIMARY == cpb_handle->var.fifo_var_data[queue_index].chnl_type)
    {
        UINT8 test_port = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_port;
        UINT8 test_chnl = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_chnl;
        UINT8 old_test_port = test_port;
        num_readers = 1;

        if(is_broadcast && is_multicast)
        {
            cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */
            PMC_RETURN(CPB_ERR_DEACT_PRIMARY_WITH_SECONDARY);
        }
        else if (is_broadcast)
        {
            while(test_port != CPB_INDEX_LAST)
            {
                if(!(test_port == (UINT8)egress_mux_output_port && test_chnl == (UINT8)egress_mux_output_port_chnl) &&
                   (cpb_handle->var.cpb_connect_data->chnl[test_port][test_chnl].mst.state == UTIL_GLOBAL_CHNL_OPERATIONAL))
                {
                    num_readers++;
                    if(num_readers == 2)
                    {
                        sec_egress_port = test_port;
                        sec_egress_chnl = test_chnl;
                    }
                }
                test_port = cpb_handle->var.cpb_connect_data->chnl[old_test_port][test_chnl].mst.next_dest_mst_port;
                test_chnl = cpb_handle->var.cpb_connect_data->chnl[old_test_port][test_chnl].mst.next_dest_mst_chnl; 
                old_test_port = test_port;
            }
        }
        else if (is_multicast)
        {
            while(test_port != CPB_INDEX_LAST)
            {
                if(!(test_port == (UINT8)egress_mux_output_port && test_chnl == (UINT8)egress_mux_output_port_chnl) &&
                   (cpb_handle->var.cpb_connect_data->chnl[test_port][test_chnl].mst.dcs_inst == 
                    cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.dcs_inst) &&
                   (cpb_handle->var.cpb_connect_data->chnl[test_port][test_chnl].mst.state == UTIL_GLOBAL_CHNL_OPERATIONAL))
                {
                    if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB)
                    {
                        /* DCPB may have common slave port and channel use more than one push port to access a queue system pop port and dcs instance 
                           confirm the push port is common to both channels before confirming it is a multicast*/
                        UINT8 test_rqid = cpb_handle->var.cpb_connect_data->chnl[test_port][test_chnl].mst.rd_queue_id;
                        UINT8 egress_rqid = cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.rd_queue_id;
                        p_chnl_ctxt = cpb_handle->util_schd_handle[cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.dcs_inst]->var.schd_ctxt->chnl_ctxt;
                        if(p_chnl_ctxt[test_rqid].dcs_sf1_push_port_id == p_chnl_ctxt[egress_rqid].dcs_sf1_push_port_id)
                        {
                            num_readers++;
                            if (num_readers == 2)
                            {
                                sec_egress_port = test_port;
                                sec_egress_chnl = test_chnl;
                            }
                        }
                    }
                    else
                    {
                        num_readers++;
                        if (num_readers == 2)
                        {
                            sec_egress_port = test_port;
                            sec_egress_chnl = test_chnl;
                        }
                    }
                }
                test_port = cpb_handle->var.cpb_connect_data->chnl[old_test_port][test_chnl].mst.next_dest_mst_port;
                test_chnl = cpb_handle->var.cpb_connect_data->chnl[old_test_port][test_chnl].mst.next_dest_mst_chnl;  
                old_test_port = test_port;
            }
        }

        PMC_LOG_TRACE("\n num_readers = %u \n", num_readers);
        if(num_readers == 2)
        {
            result = cpb_dcs_egress_dpi_chnl_source_get( cpb_handle, sec_egress_port,
                                                         sec_egress_chnl,
                                                         &sec_egress_mux_input_port, &sec_rd_chnl_id,
                                                         &sec_rd_queue_id);

            if(result != PMC_SUCCESS)
            {
                cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */
                PMC_RETURN(result);
            }

            sec_pop_port_id = sec_egress_mux_input_port;
            sec_q_index = cpb_fifo_var_data_queue_index_get(cpb_handle, sec_egress_mux_input_port, sec_rd_queue_id);

            if(CPB_READER_PRIMARY == cpb_handle->var.fifo_var_data[sec_q_index].chnl_type)
            {
                PMC_LOG_TRACE("\n switch broadcast zone primary and secondary channel ... \n");
                result = cpb_dpi_slave_port_chnl_rd_queue_map_cfg(cpb_handle, ingress_mux_input_port,
                                                                  ingress_mux_input_port_chnl,
                                                                  sec_pop_port_id,
                                                                  sec_rd_queue_id);

                if (result == PMC_SUCCESS)
                {
                    cpb_dpi_slave_port_chnl_zone_source_cfg(cpb_handle,
                                                            ingress_mux_input_port,
                                                            ingress_mux_input_port_chnl,
                                                            0,
                                                            sec_pop_port_id);
                }
                
                cpb_handle->var.fifo_var_data[queue_index].chnl_type = CPB_READER_PRIMARY;
                cpb_handle->var.fifo_var_data[sec_q_index].chnl_type = CPB_SLAVE_ZONE_PRIMARY;

                cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_multicast = 0;
                cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_broadcast = 1;

                cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.is_reader_primary = 1;
                cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.is_slave_zone_primary = 0;

                cpb_handle->var.cpb_connect_data->chnl[sec_egress_port][sec_egress_chnl].mst.is_reader_primary = 1;
                cpb_handle->var.cpb_connect_data->chnl[sec_egress_port][sec_egress_chnl].mst.is_slave_zone_primary = 1;
            }
            else if(CPB_FIFO_SECONDARY_CH == cpb_handle->var.fifo_var_data[sec_q_index].chnl_type)
            {
                PMC_LOG_TRACE("\n switch multicast zone primary and secondary channel ... \n");
                result = cpb_dpi_slave_port_chnl_rd_queue_map_cfg(cpb_handle, ingress_mux_input_port,
                                                                  ingress_mux_input_port_chnl,
                                                                  sec_pop_port_id,
                                                                  sec_rd_queue_id);

                cpb_handle->var.fifo_var_data[queue_index].chnl_type = CPB_FIFO_SECONDARY_CH;
                cpb_handle->var.fifo_var_data[sec_q_index].chnl_type = CPB_SLAVE_ZONE_PRIMARY;

                cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_broadcast = 0;
                cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_multicast = 1;

                cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.is_reader_primary = 0;
                cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.is_slave_zone_primary = 0;

                cpb_handle->var.cpb_connect_data->chnl[sec_egress_port][sec_egress_chnl].mst.is_reader_primary = 1;
                cpb_handle->var.cpb_connect_data->chnl[sec_egress_port][sec_egress_chnl].mst.is_slave_zone_primary = 1;
            }
        }
        else if(num_readers > 2)
        {
            cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */
            PMC_RETURN(CPB_ERR_DEACT_PRIMARY_WITH_SECONDARY);
        }
    }
    else if(CPB_READER_PRIMARY == cpb_handle->var.fifo_var_data[queue_index].chnl_type)
    {
        UINT8 test_port = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_port;
        UINT8 test_chnl = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_chnl;
        UINT8 old_test_port = test_port;

        num_readers = 1;
        while(test_port != CPB_INDEX_LAST)
        {
            if(!(test_port == (UINT8)egress_mux_output_port && test_chnl == (UINT8)egress_mux_output_port_chnl) &&
               (cpb_handle->var.cpb_connect_data->chnl[test_port][test_chnl].mst.dcs_inst == 
                cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.dcs_inst) &&
               (cpb_handle->var.cpb_connect_data->chnl[test_port][test_chnl].mst.state == UTIL_GLOBAL_CHNL_OPERATIONAL))
            {
                if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB)
                {
                    /* DCPB may have common slave port and channel use more than one push port to access a queue system pop port and dcs instance 
                       confirm the push port is common to both channels before confirming it is a multicast*/
                    UINT8 test_rqid = cpb_handle->var.cpb_connect_data->chnl[test_port][test_chnl].mst.rd_queue_id;
                    UINT8 egress_rqid = cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.rd_queue_id;
                    p_chnl_ctxt = cpb_handle->util_schd_handle[cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.dcs_inst]->var.schd_ctxt->chnl_ctxt;
                    if(p_chnl_ctxt[test_rqid].dcs_sf1_push_port_id == p_chnl_ctxt[egress_rqid].dcs_sf1_push_port_id)
                    {
                        sec_egress_port = test_port;
                        sec_egress_chnl = test_chnl;
                        num_readers++;
                    }
                }
                else
                {
                    sec_egress_port = test_port;
                    sec_egress_chnl = test_chnl;
                    num_readers++;
                }
            }
            test_port = cpb_handle->var.cpb_connect_data->chnl[old_test_port][test_chnl].mst.next_dest_mst_port;
            test_chnl = cpb_handle->var.cpb_connect_data->chnl[old_test_port][test_chnl].mst.next_dest_mst_chnl; 
            old_test_port = test_port;
        }

        PMC_LOG_TRACE("\n num_readers = %u \n", num_readers);
        if(num_readers == 2)          
        {
            result = cpb_dcs_egress_dpi_chnl_source_get( cpb_handle, sec_egress_port,
                                                         sec_egress_chnl,
                                                         &sec_egress_mux_input_port, &sec_rd_chnl_id,
                                                         &sec_rd_queue_id);

            if(result != PMC_SUCCESS)
            {
                cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */
                PMC_RETURN(result);
            }

            sec_pop_port_id = sec_egress_mux_input_port;
            sec_q_index = cpb_fifo_var_data_queue_index_get(cpb_handle, sec_egress_mux_input_port, sec_rd_queue_id);

            if(CPB_FIFO_SECONDARY_CH == cpb_handle->var.fifo_var_data[sec_q_index].chnl_type)
            {
                PMC_LOG_TRACE("\n deactivating a primary and make secondary as primary channel ... \n");
                result = cpb_dpi_slave_port_chnl_rd_queue_map_cfg(cpb_handle, ingress_mux_input_port,
                                                                  ingress_mux_input_port_chnl,
                                                                  sec_pop_port_id,
                                                                  sec_rd_queue_id);
                cpb_handle->var.fifo_var_data[queue_index].chnl_type = CPB_FIFO_SECONDARY_CH;
                cpb_handle->var.fifo_var_data[sec_q_index].chnl_type = CPB_READER_PRIMARY;

                cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_broadcast = 0;
                cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_multicast = 1;

                cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.is_reader_primary = 0;
                cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.is_slave_zone_primary = 0;

                cpb_handle->var.cpb_connect_data->chnl[sec_egress_port][sec_egress_chnl].mst.is_reader_primary = 1;
                cpb_handle->var.cpb_connect_data->chnl[sec_egress_port][sec_egress_chnl].mst.is_slave_zone_primary = 0;
            }
        }
        else if(num_readers > 2)
        {
            cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */
            PMC_RETURN(CPB_ERR_DEACT_PRIMARY_WITH_SECONDARY);
        }
    }
    else
    {
        PMC_LOG_TRACE("\n this is a secondary channel, nothing to do ... \n");
    }

    cpb_handle->var.cpb_mem_pool_in_use[4] = FALSE; /* This indicates we are exiting this API */

    if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB || cpb_handle->cfg.cpb_type == CPB_INSTANCE_OCPB) {
        cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.state = UTIL_GLOBAL_CHNL_EQUIPPED;
        cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.state = UTIL_GLOBAL_CHNL_EQUIPPED;
    }

    PMC_RETURN(result);

} /* cpb_chnl_switch_internal */


/*******************************************************************************
* cpb_dcs_chnl_prov
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Evaluate if the channel can be provisioned with the specified rate.
*
* INPUTS:
*   *cpb_handle      - pointer to cpb handle instance.
*   dcs_inst         - DCS instance from 0 to 3
*   rd_queue_id      - read queue to provision (C_RAM_IDENTIFIER)
*   rd_channel_id    - output channel associated with this queue id
*   wr_queue_id      - write queue id
*   push_port_id     - push port id
*   rate             - desired rate in units of total_rate_units in dcs_cfg_t
*   rate_units       - 10^ exponent part of total_rate
*   backup_mode      - TRUE: if CBRC channel to shadow an existing 
*                      ENET_LINE/SYS to MAPOTN connection.  FALSE: Otherwise
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_dcs_chnl_prov( cpb_handle_t *cpb_handle, UINT32 dcs_inst,
                                     UINT32 rd_queue_id, UINT32 rd_channel_id,
                                     UINT32 wr_queue_id, UINT32 push_port_id,
                                     UINT32 rate,
                                     util_schd_chnl_rate_exp_t rate_units,
                                     BOOL8 backup_mode )
{
    PMC_ERROR ret_val;
    UINT32 dcs_rd_channel_id;
    util_schd_handle_t *p = cpb_handle->util_schd_handle[dcs_inst];

    PMC_ENTRY();

    /* check if inst is greater than 3, if so return an error */
    PMC_ASSERT(dcs_inst < cpb_handle->cfg.num_dcs, CPB_ERR_INVALID_ARG,0,0);

    dcs_rd_channel_id = rd_channel_id;

    /* check if the DCS is in alternate queue mode, if yes, only accept even
       rd queue id */
    if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && dcs_inst < CPB_MCPB_POP_PORT_2
       && 1 == (rd_queue_id & 0x0001))
       PMC_RETURN(PMC_SUCCESS);

    PMC_LOG_TRACE("DCS channel provisioning...\n");
    PMC_LOG_TRACE("dcs_inst = %u\n dcs_rd_channel_id = %u\n rd_queue_id=%u \n", dcs_inst,dcs_rd_channel_id, rd_queue_id);

    /* Configure the rate for the channel */
    util_schd_dcs_chnl_data_set( p, rd_queue_id, DCS_DEFAULT_GROUP_ID, rate, rate_units,
                                 DCS_UTIL_SCHD_CH_TYPE, dcs_rd_channel_id, push_port_id,
                                 wr_queue_id);

    if(backup_mode == FALSE)
    {    
        /* Move channel state to UTIL_SCHD_CHNL_EQUIPPED */
        ret_val = util_schd_chnl_state_set(p, rd_queue_id, UTIL_SCHD_CHNL_EQUIPPED);
        if (ret_val != PMC_SUCCESS) {
            PMC_RETURN(ret_val);
        }
    
        /* Evaluate if the channel can be provisioned */
        ret_val = util_schd_grp_entry_eval(p, DCS_DEFAULT_GROUP_ID,
                                           p->cfg.block_ctxt.max_entries);
    }
    else
    {
        /* Move channel state to UTIL_SCHD_CHNL_BACKUP */
        ret_val = util_schd_chnl_state_set(p, rd_queue_id, UTIL_SCHD_CHNL_BACKUP);
        if (ret_val != PMC_SUCCESS) {
            PMC_RETURN(ret_val);
        }
    }

    /* Return channel state to UTIL_SCHD_CHNL_START if provisioning failed */
    if (ret_val != PMC_SUCCESS) {
        util_schd_chnl_state_set(p, rd_queue_id, UTIL_SCHD_CHNL_START);
        PMC_RETURN(ret_val);
    }

    PMC_LOG_TRACE("dcs_chnl_prov result: success\n");
    PMC_RETURN(PMC_SUCCESS);


} /* cpb_dcs_chnl_prov */

/*******************************************************************************
* cpb_dcs_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function deprovisions a channel in a DCS instance. The channel to be
*   deproved should be in equipped state.
*
* INPUTS:
*   *cpb_handle      - pointer to cpb handle instance.
*   dcs_inst         - DCS instance id
*   rd_queue_id      - read queue to deprovision (C_RAM_IDENTIFIER)
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_dcs_chnl_deprov( cpb_handle_t *cpb_handle,
                                       UINT32 dcs_inst,
                                       UINT32 rd_queue_id )
{
    PMC_ERROR ret_val;
    util_schd_handle_t *p;
    PMC_ENTRY();

    /* check if inst is greater than 3, if so return an error */
    PMC_ASSERT(dcs_inst < cpb_handle->cfg.num_dcs, CPB_ERR_INVALID_ARG,0,0);

    /* check if the DCS is in alternate queue mode, if yes, only accept even
       rd queue id */
    if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && dcs_inst < CPB_MCPB_POP_PORT_2
       && 1 == (rd_queue_id & 0x0001))
       PMC_RETURN(PMC_SUCCESS);

    PMC_LOG_TRACE("DCS channel deprovisioning...\nread queue id: %u\n",rd_queue_id);

    p = cpb_handle->util_schd_handle[dcs_inst];

    ret_val = util_schd_chnl_state_set(p, rd_queue_id, UTIL_SCHD_CHNL_START);
    if(ret_val) PMC_RETURN(ret_val);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dcs_chnl_deprov */

/*******************************************************************************
* cpb_secondary_reader_chnl_deprov
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function deprovisions a secondary channel, which means it only performs
*   the DCS channel deprov, master port channel cfg clearance and the ram
*   data clearance. It is a helper function for cpb_chnl_deprov function.
*
* INPUTS:
*   *cpb_handle               - pointer to cpb handle instance.
*   egress_mux_output_port      - master DPI port id
*   egress_mux_output_port_chnl - output port chnl id
*   dcs_inst                    - DCS instance id that is associated with the
*                                 output channel
*   rd_queue_id                 - read queue id to deprovision
*   super_deprov                - boolean to indicate that this function is
*                                 used in bulk deprovisioning mode.
*                                 TRUE: bulk deprovisioing
*                                 FALSE: normal deprovisioning
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_secondary_reader_chnl_deprov( cpb_handle_t *cpb_handle,
                                                    UINT32 egress_mux_output_port,
                                                    UINT32 egress_mux_output_port_chnl,
                                                    UINT32 dcs_inst,
                                                    UINT32 rd_queue_id,
                                                    BOOL8 super_deprov )
{
    PMC_ERROR result;

    PMC_ENTRY();

    /* check if inst is greater than 3, if so return an error */
    PMC_ASSERT(dcs_inst < cpb_handle->cfg.num_dcs, CPB_ERR_INVALID_ARG,0,0);
    PMC_ASSERT(egress_mux_output_port <= cpb_handle->cfg.max_mst_dpi_port, CPB_ERR_INVALID_ARG,0,0);
    PMC_ASSERT(egress_mux_output_port_chnl <= cpb_handle->cfg.max_dpi_mst_chnl_id[egress_mux_output_port],
               CPB_ERR_INVALID_ARG,0,0);
    PMC_ASSERT(rd_queue_id < cpb_handle->cfg.max_fifo_num, CPB_ERR_INVALID_ARG,0,0);

    if (super_deprov == FALSE)
    {
        UINT32 queue_index;
        cpb_dcs_chnl_deprov(cpb_handle, dcs_inst, rd_queue_id);

        queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, dcs_inst, rd_queue_id);
        cpb_handle->var.fifo_var_data[queue_index].chnl_type = CPB_FIFO_INVALID_CH;
        cpb_handle->var.fifo_var_data[queue_index].fifo_end_addr = 0;
        cpb_handle->var.fifo_var_data[queue_index].status = CPB_FIFO_NOT_USED;
        cpb_handle->var.fifo_var_data[queue_index].write_id = CPB_BLOCK_WQID_NIL;
        cpb_handle->var.fifo_var_data[queue_index].push_port_id = CPB_FIFO_PUSHID_NIL;
    }

    /* clear the master port chnl zone threshold and ovrd settings */
    result = cpb_dpi_mstr_port_chnl_zone_mode_cfg(cpb_handle, egress_mux_output_port,
                                                egress_mux_output_port_chnl, CPB_SLV_CHNL_ZONE_FIFO);
    if(result) PMC_RETURN(result);

    result = cpb_chnl_hole_inst_head_cfg( cpb_handle, egress_mux_output_port,
                                          egress_mux_output_port_chnl, 0);
    if(result) PMC_RETURN(result);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_secondary_reader_chnl_deprov */

/*******************************************************************************
* cpb_dcs_chnl_activate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Activates the specified channel.
*
* INPUTS:
*   *cpb_handle    - pointer to CPB handle instance.
*   dcs_inst       - DCS instance
*   chnl             - channel to activate
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_dcs_chnl_activate( cpb_handle_t *cpb_handle, UINT32 dcs_inst,
                                         UINT32 chnl )
{
    PMC_ERROR result;

    PMC_ENTRY();

    /* Move channel state to UTIL_SCHD_CHNL_OPERATIONAL */
    result = util_schd_chnl_state_set(cpb_handle->util_schd_handle[dcs_inst], chnl, UTIL_SCHD_CHNL_OPERATIONAL);

    PMC_RETURN(result);
} /* cpb_dcs_chnl_activate */

/*******************************************************************************
* cpb_dcs_chnl_deactivate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Deactivate a channel in a DCS instance.
*
* INPUTS:
*   *cpb_handle      - pointer to cpb handle instance.
*   dcs_inst         - DCS inst id, 1:1 to the pop port id
*   chnl             - channel to activate
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_dcs_chnl_deactivate( cpb_handle_t *cpb_handle, UINT32 dcs_inst,
                                         UINT32 chnl )
{
    PMC_ERROR result;
    PMC_ENTRY();

    /* Move channel state to UTIL_SCHD_CHNL_OPERATIONAL */
    result = util_schd_chnl_state_set(cpb_handle->util_schd_handle[dcs_inst], chnl, UTIL_SCHD_CHNL_EQUIPPED);

    PMC_RETURN(result);
} /* cpb_dcs_chnl_deactivate */


/*******************************************************************************
* cpb_dcs_page_update_and_swap
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Generates the calendar for active channels.
*   Updates the standby page and swaps the scheduler active/standby pages.
*
* INPUTS:
*   *cpb_handle      - pointer to the CPB handle instance
*   dcs_inst         - DCS inst id, 1:1 to the pop port id
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32 cpb_dcs_page_update_and_swap(cpb_handle_t *cpb_handle, UINT32 dcs_inst)
{
    util_schd_handle_t *p = cpb_handle->util_schd_handle[dcs_inst];
    PMC_ERROR ret_val;
    UINT32 max_entries = p->cfg.block_ctxt.max_entries;
    UINT32 dist_entries[CPB_NUM_SCHED_ENTRIES];
    UINT32 entry_size = cpb_handle->cfg.num_calendar_entries * sizeof(util_schd_dcs_calendar_entry_t);

    PMC_ENTRY();

    /* Generate a distribution of read queue ids */
    util_schd_group_dist_gen(p, 0, max_entries,dist_entries);
#ifndef LOGGING_DISABLED
    {
        UINT32 i;
        for (i=0; i< max_entries;i++)
        {
            PMC_LOG_TRACE("dist_entries[%u] = %u\n",i,dist_entries[i]);
        }
    }
#endif
    /* Copy the old offline page into a temp calendar to keep track of changes after a new offline page is generated */
    PMC_MEMCPY((void*)cpb_handle->var.dcs_temp_calendar,
               (void*)cpb_handle->var.dcs_offline_calendars[dcs_inst],
               entry_size);

    
    PMC_ATOMIC_YIELD(cpb_handle->base.parent_handle,0);
    /* Generate a new offline page and write offline page registers */
    cpb_dcs_gen_calendar_and_write_offline_page(cpb_handle,dcs_inst,dist_entries,NULL,NULL);

    /* Swap device offline and online pages */
    cpb_dcs_page_swap( cpb_handle,dcs_inst );

    /* Poll for page swap success */
    ret_val = cpb_dcs_poll_swap_success( cpb_handle, dcs_inst );
    if(ret_val) /* return error if failure */
    {
        PMC_LOG_TRACE("Error: Page swap failed");
         PMC_RETURN(ret_val);
    }

    /* Swap context offline and online page to match device */
    PMC_MEMCPY((void*)cpb_handle->var.dcs_temp_calendar,
               (void*)cpb_handle->var.dcs_online_calendars[dcs_inst],
               entry_size);

    PMC_MEMCPY((void*)cpb_handle->var.dcs_online_calendars[dcs_inst],
               (void*)cpb_handle->var.dcs_offline_calendars[dcs_inst],
               entry_size);

    PMC_MEMCPY((void*)cpb_handle->var.dcs_offline_calendars[dcs_inst],
               (void*)cpb_handle->var.dcs_temp_calendar,
               entry_size);

    /* Write the offline calendar registers again so online and offline calendar pages contain
       the same data */
    PMC_ATOMIC_YIELD(cpb_handle->base.parent_handle,0);   
    cpb_dcs_gen_calendar_and_write_offline_page(cpb_handle,dcs_inst,dist_entries,NULL,NULL);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dcs_page_update_and_swap */


/*******************************************************************************
* cpb_dcs_page_update_and_swap_with_chnl_enbl
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Generates the calendar for active channels.\n
*   Updates the standby page and swaps the scheduler active/standby pages.\n\n
*
*   This API will additionally control QSn_CH_EN for channel in order to
*   perform change of DCS channel to a backup data source.   
*
* INPUTS:
*   *cpb_handle      - pointer to the CPB handle instance
*   dcs_inst         - DCS inst id, 1:1 to the pop port id
*   ch_enbl_ctrl     - FALSE: do not modify QSn_CH_EN, TRUE: modify QSn_CH_EN
*   off_port         - If ch_enbl_ctrl TRUE, port to turn QSn_CH_EN off
*   off_chnl         - If ch_enbl_ctrl TRUE, channel to turn QSn_CH_EN off
*   off_rd_queue_id  - If ch_enbl_ctrl TRUE, read queue ID to turn QSn_CH_EN off
*   on_port          - If ch_enbl_ctrl TRUE, port to turn QSn_CH_EN on
*   on_chnl          - If ch_enbl_ctrl TRUE, channel to turn QSn_CH_EN on
*   on_rd_queue_id   - If ch_enbl_ctrl TRUE, read queue ID to turn QSn_CH_EN on
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_dcs_page_update_and_swap_with_chnl_enbl(cpb_handle_t *cpb_handle, UINT32 dcs_inst,
                                                              BOOL8 ch_enbl_ctrl, UINT32 off_port, 
                                                              UINT32 off_chnl, UINT32 off_rd_queue_id, 
                                                              UINT32 on_port, UINT32 on_chnl, UINT32 on_rd_queue_id)
{
    util_schd_handle_t *p = cpb_handle->util_schd_handle[dcs_inst];
    PMC_ERROR ret_val;
    UINT32 max_entries = p->cfg.block_ctxt.max_entries;
    UINT32 dist_entries[CPB_NUM_SCHED_ENTRIES];

    PMC_ENTRY();

    /* if requested update context to perform backup swap between on and off channels */
    if(ch_enbl_ctrl == TRUE)
    {
        PMC_ERROR result = PMC_SUCCESS;
        result = util_schd_chnl_state_set(cpb_handle->util_schd_handle[dcs_inst], off_rd_queue_id, UTIL_SCHD_CHNL_BACKUP);        
        PMC_ASSERT(result==PMC_SUCCESS, CPB_ERR_CODE_ASSERT, 0, 0);
        result = util_schd_chnl_state_set(cpb_handle->util_schd_handle[dcs_inst], on_rd_queue_id, UTIL_SCHD_CHNL_OPERATIONAL);
        PMC_ASSERT(result==PMC_SUCCESS, CPB_ERR_CODE_ASSERT, 0, 0);
        /*
         * Swap the state of the connect array for the ingress port/chnl
         * and the CBRC handle. Namely the off port and on port values.
         */
        util_global_chnl_state_t slv_state = cpb_handle->var.cpb_connect_data->chnl[off_port][off_chnl].slv.state;
        cpb_handle->var.cpb_connect_data->chnl[off_port][off_chnl].slv.state = cpb_handle->var.cpb_connect_data->chnl[on_port][on_chnl].slv.state;
        cpb_handle->var.cpb_connect_data->chnl[on_port][on_chnl].slv.state = slv_state;
    }

    /* Generate a distribution of read queue ids */
    util_schd_group_dist_gen(p, 0, max_entries,dist_entries);

#ifndef LOGGING_DISABLED
    {
        UINT32 i;
        for (i=0; i< max_entries;i++)
        {
            PMC_LOG_TRACE("dist_entries[%u] = %u\n",i,dist_entries[i]);
        }
    }
#endif

    /* Copy the old offline page into a temp calendar to keep track of changes after a new offline page is generated */
    PMC_MEMCPY((void*)cpb_handle->var.dcs_temp_calendar,
               (void*)cpb_handle->var.dcs_offline_calendars[dcs_inst],
               cpb_handle->cfg.num_calendar_entries * sizeof(util_schd_dcs_calendar_entry_t));

    
    PMC_ATOMIC_YIELD(cpb_handle->base.parent_handle,0);

    /* Generate a new offline page and write offline page registers */
    cpb_dcs_gen_calendar_and_write_offline_page(cpb_handle,dcs_inst,dist_entries,NULL,NULL);

    /* if requested turn off data source */
    if(ch_enbl_ctrl == TRUE)
    {
        cpb_slv_chnl_qs_ch_en_set(cpb_handle,
                                  off_port,
                                  off_chnl,
                                  0);        
    }

    /* Swap device offline and online pages */
    cpb_dcs_page_swap( cpb_handle,dcs_inst );

    /* Poll for page swap success */
    ret_val = cpb_dcs_poll_swap_success( cpb_handle, dcs_inst );
    if(ret_val) /* return error if failure */
    {
        PMC_LOG_TRACE("Error: Page swap failed");
         PMC_RETURN(ret_val);
    }

    /* if requested turn on data source */
    if(ch_enbl_ctrl == TRUE)
    {
        cpb_slv_chnl_qs_ch_en_set(cpb_handle,
                                  on_port,
                                  on_chnl,
                                  (1 << dcs_inst));        
    }

    /* Swap context offline and online page to match device */
    PMC_MEMCPY((void*)cpb_handle->var.dcs_temp_calendar,
               (void*)cpb_handle->var.dcs_online_calendars[dcs_inst],
               cpb_handle->cfg.num_calendar_entries * sizeof(util_schd_dcs_calendar_entry_t));
    PMC_MEMCPY((void*)cpb_handle->var.dcs_online_calendars[dcs_inst],
               (void*)cpb_handle->var.dcs_offline_calendars[dcs_inst],
               cpb_handle->cfg.num_calendar_entries * sizeof(util_schd_dcs_calendar_entry_t));
    PMC_MEMCPY((void*)cpb_handle->var.dcs_offline_calendars[dcs_inst],
               (void*)cpb_handle->var.dcs_temp_calendar,
               cpb_handle->cfg.num_calendar_entries * sizeof(util_schd_dcs_calendar_entry_t));

    /* Write the offline calendar registers again so online and offline calendar pages contain
       the same data */
    PMC_ATOMIC_YIELD(cpb_handle->base.parent_handle,0);   
    cpb_dcs_gen_calendar_and_write_offline_page(cpb_handle,dcs_inst,dist_entries, NULL,NULL);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dcs_page_update_and_swap_with_chnl_enbl */

/*******************************************************************************
* cpb_dcs_gen_calendar_and_write_offline_page
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function generates the DCS calendar, writes to the offline calendar context
*   and sets the offline calendar entries in the device.
*
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*   dcs_inst               - DCS instance 0 to 3
*   dist_entries           - The distributed calendar entries array for the DCS instance
*   is_dcs_updated_ptr     - TRUE : DCS was update, FALSE : DCS was not updated
*   is_channel_idx_updated_arr  - array of 96 booleans that indicates which channel IDs were updated.
*                                 Can be NULL only if "is_cal_updated_ptr" equals NULL too.
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_dcs_gen_calendar_and_write_offline_page( cpb_handle_t *cpb_handle,
                                                               UINT32 dcs_inst,
                                                               UINT32 dist_entries[],
                                                               BOOL8* is_dcs_updated_ptr,
                                                               BOOL8  is_channel_idx_updated_arr[])
{
    util_schd_handle_t *p = cpb_handle->util_schd_handle[dcs_inst];
    UINT32 i;
    PMC_ERROR result;
    util_schd_dcs_calendar_entry_t* offline_calendar_inst;

    PMC_ENTRY();

    if (NULL != is_dcs_updated_ptr)
    {
        /* if is_dcs_updated_ptr isn't NULL then is_dcs_entry_updated_arr can't be NULL as well */
        PMC_ASSERT(NULL != is_channel_idx_updated_arr, CPB_ERR_CODE_ASSERT, 0, 0);

        /* Set default value. Will be set to TRUE if at least one entry was updated. */
        *is_dcs_updated_ptr = FALSE;

        for (i = 0; i < p->cfg.block_ctxt.max_entries; i++)
        {
            is_channel_idx_updated_arr[i] = FALSE;
        }
    }

    /* Use the distributed entries array to generate the offline page in
     * context in the correct format */
    util_schd_dcs_format_gen(p, p->cfg.block_ctxt.max_entries, dist_entries,
                             cpb_handle->var.dcs_offline_calendars[dcs_inst]);

    offline_calendar_inst = cpb_handle->var.dcs_offline_calendars[dcs_inst];


    /* Write the device offline page. If we're already initialized, only write the differences. */
    for (i=0; i < p->cfg.block_ctxt.max_entries ; i++)
    {
        util_schd_dcs_calendar_entry_t* dcs_temp_calendar_ptr = cpb_handle->var.dcs_temp_calendar;
        if(offline_calendar_inst[i].c_ram_identifier != dcs_temp_calendar_ptr[i].c_ram_identifier ||
           offline_calendar_inst[i].c_ram_channel != dcs_temp_calendar_ptr[i].c_ram_channel ||
           offline_calendar_inst[i].c_ram_sf1 != dcs_temp_calendar_ptr[i].c_ram_sf1 ||
           offline_calendar_inst[i].c_ram_sf2 != dcs_temp_calendar_ptr[i].c_ram_sf2 ||
           cpb_handle->var.dcs_inst_init_flag[dcs_inst] == FALSE)
        {
            /*
             * offline_calendar_inst - new
             * dcs_temp_calendar_ptr - old
             * deprov - take from dcs_temp_calendar_ptr[i].c_ram_channel
             * prov - take from offline_calendar_inst[i].c_ram_channel
             * */

            if (NULL != is_dcs_updated_ptr)
            {
                *is_dcs_updated_ptr = TRUE;
                is_channel_idx_updated_arr[offline_calendar_inst[i].c_ram_channel] = TRUE;
            }

            result = cpb_dcs_wrr_entry_set(cpb_handle,
                                           dcs_inst,
                                           i,
                                           offline_calendar_inst[i].c_ram_sf1,
                                           offline_calendar_inst[i].c_ram_sf2,
                                           offline_calendar_inst[i].c_ram_channel,
                                           offline_calendar_inst[i].c_ram_identifier);
            PMC_ASSERT(result==PMC_SUCCESS, CPB_ERR_CODE_ASSERT, 0, 0);

            PMC_LOG_NOTRACE("\nwrote dcs_inst: %u, i = %u, c_ram_identifier=%u\n",dcs_inst,i,offline_calendar_inst[i].c_ram_identifier);
            PMC_LOG_NOTRACE("\nwrote dcs_inst: %u, i = %u, c_ram_channel=%u\n",dcs_inst,i,offline_calendar_inst[i].c_ram_channel);
            PMC_LOG_NOTRACE("\nwrote dcs_inst: %u, i = %u, c_ram_sf1=%u\n",dcs_inst,i,offline_calendar_inst[i].c_ram_sf1);
            PMC_LOG_NOTRACE("\nwrote dcs_inst: %u, i = %u, c_ram_sf2=%u\n",dcs_inst,i,offline_calendar_inst[i].c_ram_sf2);
        }
    }

    /* Write end pointer */
    dcs_field_DCS_PAGE_END_PTR_set( NULL, cpb_handle, dcs_inst, p->cfg.block_ctxt.max_entries-1 );

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dcs_gen_calendar_and_write_offline_page */


/*******************************************************************************
*  cpb_connect_data_set_default
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function sets default values to cpb_handle.var.cpb_connect_data
*
*
* INPUTS:
*   *cpb_handle         - pointer to cpb handle instance.
*
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_connect_data_set_default( cpb_handle_t *cpb_handle )
{
    UINT32 port, chnl;
    UINT32 port_max = 6, chnl_max = 150;

    PMC_ENTRY();

    if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB) {
        PMC_RETURN(PMC_SUCCESS);
    }
    for (port=0; port<port_max; port++) {
        for (chnl=0; chnl<chnl_max; chnl++) {
            cpb_handle->var.cpb_connect_data->chnl[port][chnl].slv.state = UTIL_GLOBAL_CHNL_START;
            cpb_handle->var.cpb_connect_data->chnl[port][chnl].slv.is_broadcast = 0;
            cpb_handle->var.cpb_connect_data->chnl[port][chnl].slv.is_multicast = 0;
            cpb_handle->var.cpb_connect_data->chnl[port][chnl].slv.dest_mst_port = CPB_INDEX_LAST;
            cpb_handle->var.cpb_connect_data->chnl[port][chnl].slv.dest_mst_chnl = CPB_INDEX_LAST;
            cpb_handle->var.cpb_connect_data->chnl[port][chnl].slv.next_slv_port = CPB_INDEX_LAST;
            cpb_handle->var.cpb_connect_data->chnl[port][chnl].slv.next_slv_chnl = CPB_INDEX_LAST;

            cpb_handle->var.cpb_connect_data->chnl[port][chnl].mst.state = UTIL_GLOBAL_CHNL_START;
            cpb_handle->var.cpb_connect_data->chnl[port][chnl].mst.is_slave_zone_primary = 0;
            cpb_handle->var.cpb_connect_data->chnl[port][chnl].mst.is_reader_primary = 0;
            cpb_handle->var.cpb_connect_data->chnl[port][chnl].mst.dcs_inst = 0xFF;
            cpb_handle->var.cpb_connect_data->chnl[port][chnl].mst.rd_queue_id = 0xFF;
            cpb_handle->var.cpb_connect_data->chnl[port][chnl].mst.source_slv_port = CPB_INDEX_LAST;
            cpb_handle->var.cpb_connect_data->chnl[port][chnl].mst.source_slv_chnl = CPB_INDEX_LAST;

            cpb_handle->var.cpb_connect_data->chnl[port][chnl].mst.next_dest_mst_port = CPB_INDEX_LAST;
            cpb_handle->var.cpb_connect_data->chnl[port][chnl].mst.next_dest_mst_chnl = CPB_INDEX_LAST;

        }
    }

#ifdef CPB_BLOCK_LIST
    /* Initialize the page and block tables */
    if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_OCPB) {
        UINT32 page_index;
        UINT32 block_index;
        UINT32 block_id;

        for (page_index=0; page_index<cpb_handle->cfg.num_pages; page_index++) {
            cpb_handle->var.page_inverted_page_table[page_index].free_block_num = cpb_handle->cfg.blocks_per_page;
            cpb_handle->var.page_inverted_page_table[page_index].first_free_block = cpb_handle->cfg.blocks_per_page*page_index;

            for (block_index=0; block_index<cpb_handle->cfg.blocks_per_page; block_index++) {
                block_id = page_index*cpb_handle->cfg.blocks_per_page+block_index;

                if (block_index != cpb_handle->cfg.blocks_per_page - 1) {
                    cpb_handle->var.block_inverted_page_table[block_id].ipt_queue_next = block_id+1;
                } else {
                    cpb_handle->var.block_inverted_page_table[block_id].ipt_queue_next = CPB_NULL_BLOCK_ID;
                }

                if (block_index) {
                    cpb_handle->var.block_inverted_page_table[block_id].ipt_queue_prev = block_id-1;
                } else {
                    cpb_handle->var.block_inverted_page_table[block_id].ipt_queue_prev = CPB_NULL_BLOCK_ID;
                }
            }
        }
    }

    /* Set default values to queue_block */
    if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_OCPB) {
        UINT32 i,j;
        for (i=0;i<4;i++) {
            for (j=0; j<UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_CHNLS_PER_PORT; j++) {
                cpb_handle->var.cpb_connect_data->queue_block[i][j].queue_length = 0;
                cpb_handle->var.cpb_connect_data->queue_block[i][j].head_block = CPB_NULL_BLOCK_ID;
                cpb_handle->var.cpb_connect_data->queue_block[i][j].tail_block = CPB_NULL_BLOCK_ID;
            }
        }
    }

#endif

    /*initialize the bulk reprov indication variables*/
    cpb_oduksw_port_bulk_update_req_init(cpb_handle);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_connect_data_set_default */

/*******************************************************************************
*  cpb_connect_data_add
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function add a connect data mapping pair.
*
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance.
*   ingress_mux_input_port      - input port
*   ingress_mux_input_port_chnl - input channel
*   egress_mux_output_port      - ouput port
*   egress_mux_output_port_chnl - output channel
*   isbroadcast                 - is broadcast?
*   ismulticast                 - is multicast?
*   dcs_inst                    - dcs instance
*   rd_queue_id                 - read queue id
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_connect_data_add( cpb_handle_t *cpb_handle,
                                        UINT32 ingress_mux_input_port,
                                        UINT32 ingress_mux_input_port_chnl,
                                        UINT32 egress_mux_output_port,
                                        UINT32 egress_mux_output_port_chnl,
                                        UINT32 isbroadcast, UINT32 ismulticast,
                                        UINT32 dcs_inst, UINT32 rd_queue_id )
{
    UINT32 dest_mst_port, dest_mst_chnl;
    UINT32 last_dest_mst_port, last_dest_mst_chnl;
    UINT32 next_dest_mst_port, next_dest_mst_chnl;
    UINT32 local_is_broadcast=0;

    PMC_ENTRY();

    if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB)
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    dest_mst_port = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_port;
    dest_mst_chnl = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_chnl;
    if (CPB_INDEX_LAST != dest_mst_port && CPB_INDEX_LAST != dest_mst_chnl)
    {
        last_dest_mst_port = dest_mst_port;
        last_dest_mst_chnl = dest_mst_chnl;

        next_dest_mst_port = cpb_handle->var.cpb_connect_data->chnl[last_dest_mst_port][last_dest_mst_chnl].mst.next_dest_mst_port;
        next_dest_mst_chnl = cpb_handle->var.cpb_connect_data->chnl[last_dest_mst_port][last_dest_mst_chnl].mst.next_dest_mst_chnl;
        while (next_dest_mst_port != CPB_INDEX_LAST)
        {
            if (next_dest_mst_port != last_dest_mst_port)
            {
                local_is_broadcast = 1;
            }
            last_dest_mst_port = next_dest_mst_port;
            last_dest_mst_chnl = next_dest_mst_chnl;

            next_dest_mst_port = cpb_handle->var.cpb_connect_data->chnl[last_dest_mst_port][last_dest_mst_chnl].mst.next_dest_mst_port;
            next_dest_mst_chnl = cpb_handle->var.cpb_connect_data->chnl[last_dest_mst_port][last_dest_mst_chnl].mst.next_dest_mst_chnl;
        }
        cpb_handle->var.cpb_connect_data->chnl[last_dest_mst_port][last_dest_mst_chnl].mst.next_dest_mst_port = egress_mux_output_port;
        cpb_handle->var.cpb_connect_data->chnl[last_dest_mst_port][last_dest_mst_chnl].mst.next_dest_mst_chnl = egress_mux_output_port_chnl;

        if(last_dest_mst_port == egress_mux_output_port)
        {
            cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_multicast = 1;
        }
        else
        {
            cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_multicast = 0;
        }
    }
    else
    {
        cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_port = egress_mux_output_port;
        cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_chnl = egress_mux_output_port_chnl;
    }

    cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.source_slv_port = ingress_mux_input_port;
    cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.source_slv_chnl = ingress_mux_input_port_chnl;
    cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.dcs_inst = (UINT8)dcs_inst;
    cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.rd_queue_id = (UINT8)rd_queue_id;

    if (ismulticast)
    {
        cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_multicast = 1;
        cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.is_reader_primary = 0;
        cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.is_slave_zone_primary = 0;
    }
    else if (isbroadcast)
    {
        cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_broadcast = 1;
        cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.is_reader_primary = 1;
        cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.is_slave_zone_primary = 0;
    }
    else
    {
        cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_multicast = 0;
        cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_broadcast = 0;
        cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.is_reader_primary = 1;
        cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.is_slave_zone_primary = 1;
    }
    /* If slave port set to START move to EQUIPPED otherwise leave as is. */
    if(cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.state == UTIL_GLOBAL_CHNL_START)
        cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.state = UTIL_GLOBAL_CHNL_EQUIPPED;
    cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.state = UTIL_GLOBAL_CHNL_EQUIPPED;

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_connect_data_add */

/*******************************************************************************
*  cpb_connect_backup_chnl_data_add
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function adds a backup channel to the connect data structure.
*
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance.
*   ingress_mux_input_port      - input port
*   ingress_mux_input_port_chnl - input channel
*   egress_mux_output_port      - ouput port
*   egress_mux_output_port_chnl - output channel
*   isbroadcast                 - is broadcast?
*   ismulticast                 - is multicast?
*   dcs_inst                    - dcs instance
*   rd_queue_id                 - read queue id
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_connect_backup_chnl_data_add( cpb_handle_t *cpb_handle,
                                                    UINT32 ingress_mux_input_port,
                                                    UINT32 ingress_mux_input_port_chnl,
                                                    UINT32 egress_mux_output_port,
                                                    UINT32 egress_mux_output_port_chnl,
                                                    UINT32 isbroadcast, UINT32 ismulticast,
                                                    UINT32 dcs_inst, UINT32 rd_queue_id )
{
    UINT32 dest_mst_port, dest_mst_chnl;

    PMC_ENTRY();

    if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB)
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    dest_mst_port = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_port;
    dest_mst_chnl = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_chnl;
    if (CPB_INDEX_LAST != dest_mst_port && CPB_INDEX_LAST != dest_mst_chnl)
    {
        PMC_ASSERT(FALSE, CPB_ERR_CODE_ASSERT, 0, 0);
    }
    else
    {
        cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_port = egress_mux_output_port;
        cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_chnl = egress_mux_output_port_chnl;
    }

    cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_multicast = 0;
    cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_broadcast = 0;

    cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.state = UTIL_GLOBAL_CHNL_BACKUP;

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_connect_backup_chnl_data_add */

/*******************************************************************************
*  cpb_connect_backup_chnl_data_delete
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function removes a backup channel to the connect data structure.
*
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance.
*   ingress_mux_input_port      - input port
*   ingress_mux_input_port_chnl - input channel
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_connect_backup_chnl_data_delete( cpb_handle_t *cpb_handle,
                                                       UINT32 ingress_mux_input_port,
                                                       UINT32 ingress_mux_input_port_chnl)
{
    PMC_ENTRY();

    if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB)
    {
        PMC_RETURN(PMC_SUCCESS);
    }

    cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_port = CPB_INDEX_LAST;
    cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_chnl = CPB_INDEX_LAST;

    cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_multicast = 0;
    cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_broadcast = 0;

    cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.state = UTIL_GLOBAL_CHNL_START;

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_connect_backup_chnl_data_delete */

/*******************************************************************************
*  cpb_connect_data_delete
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function delete a connect data mapping pair.
*   It is used with cpb_secondary_reader_chnl_deprov.
*
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance.
*   ingress_mux_input_port      - input port
*   ingress_mux_input_port_chnl - input channel
*   egress_mux_output_port      - ouput port
*   egress_mux_output_port_chnl - output channel
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_connect_data_delete( cpb_handle_t *cpb_handle,
                                          UINT32 ingress_mux_input_port,
                                          UINT32 ingress_mux_input_port_chnl,
                                          UINT32 egress_mux_output_port,
                                          UINT32 egress_mux_output_port_chnl )
{
    UINT32 next_dest_mst_port, next_dest_mst_chnl;
    UINT32 dest_mst_port, dest_mst_chnl;

    PMC_ENTRY();

    if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB) {
        PMC_RETURN(PMC_SUCCESS);
    }

    PMC_ASSERT(ingress_mux_input_port < UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_PORTS, CPB_ERR_INVALID_ARG, ingress_mux_input_port, UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_PORTS);
    PMC_ASSERT(ingress_mux_input_port_chnl < UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_CHNLS_PER_PORT, CPB_ERR_INVALID_ARG, ingress_mux_input_port_chnl, UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_CHNLS_PER_PORT);

    dest_mst_port = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_port;
    dest_mst_chnl = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_chnl;

    PMC_ASSERT(dest_mst_port < UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_PORTS, CPB_ERR_INVALID_ARG, dest_mst_port, UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_PORTS);
    PMC_ASSERT(dest_mst_chnl < UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_CHNLS_PER_PORT, CPB_ERR_INVALID_ARG, dest_mst_chnl, UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_CHNLS_PER_PORT);

    if (dest_mst_port != egress_mux_output_port || dest_mst_chnl != egress_mux_output_port_chnl)
    {
        /* the deleted is not the first one in the list, then search the list for it */
        next_dest_mst_port = cpb_handle->var.cpb_connect_data->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_port;
        next_dest_mst_chnl = cpb_handle->var.cpb_connect_data->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_chnl;


        while (next_dest_mst_port != CPB_INDEX_LAST &&
            (next_dest_mst_port != egress_mux_output_port && next_dest_mst_chnl != egress_mux_output_port_chnl)) {
            dest_mst_port = next_dest_mst_port;
            dest_mst_chnl = next_dest_mst_chnl;

            PMC_ASSERT(dest_mst_port < UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_PORTS, CPB_ERR_INVALID_ARG, dest_mst_port, UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_PORTS);
            PMC_ASSERT(dest_mst_chnl < UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_CHNLS_PER_PORT, CPB_ERR_INVALID_ARG, dest_mst_chnl, UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_CHNLS_PER_PORT);

            next_dest_mst_port = cpb_handle->var.cpb_connect_data->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_port;
            next_dest_mst_chnl = cpb_handle->var.cpb_connect_data->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_chnl;
        }

        if (next_dest_mst_port == CPB_INDEX_LAST) {
            /* failed to find */
            PMC_RETURN(PMC_ERR_FAIL);
        }

        PMC_ASSERT(next_dest_mst_port < UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_PORTS, CPB_ERR_INVALID_ARG, next_dest_mst_port, UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_PORTS);
        PMC_ASSERT(next_dest_mst_chnl < UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_CHNLS_PER_PORT, CPB_ERR_INVALID_ARG, next_dest_mst_chnl, UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_CHNLS_PER_PORT);

        cpb_handle->var.cpb_connect_data->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_port =
            cpb_handle->var.cpb_connect_data->chnl[next_dest_mst_port][next_dest_mst_chnl].mst.next_dest_mst_port;
        cpb_handle->var.cpb_connect_data->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_chnl =
            cpb_handle->var.cpb_connect_data->chnl[next_dest_mst_port][next_dest_mst_chnl].mst.next_dest_mst_chnl;

        /* clean cpb_handle->var.cpb_connect_data->chnl[next_dest_mst_port][next_dest_mst_chnl].mst */
        cpb_handle->var.cpb_connect_data->chnl[next_dest_mst_port][next_dest_mst_chnl].mst.state = UTIL_GLOBAL_CHNL_START;
        cpb_handle->var.cpb_connect_data->chnl[next_dest_mst_port][next_dest_mst_chnl].mst.next_dest_mst_port = CPB_INDEX_LAST;
        cpb_handle->var.cpb_connect_data->chnl[next_dest_mst_port][next_dest_mst_chnl].mst.next_dest_mst_chnl = CPB_INDEX_LAST;
        cpb_handle->var.cpb_connect_data->chnl[next_dest_mst_port][next_dest_mst_chnl].mst.source_slv_port = CPB_INDEX_LAST;
        cpb_handle->var.cpb_connect_data->chnl[next_dest_mst_port][next_dest_mst_chnl].mst.source_slv_chnl = CPB_INDEX_LAST;
    }
    else 
    {
        PMC_ASSERT(dest_mst_port < UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_PORTS, CPB_ERR_INVALID_ARG, dest_mst_port, UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_PORTS);
        PMC_ASSERT(dest_mst_chnl < UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_CHNLS_PER_PORT, CPB_ERR_INVALID_ARG, dest_mst_chnl, UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_CHNLS_PER_PORT);

        /* the deleted is the first one in the list */
        cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_port =
            cpb_handle->var.cpb_connect_data->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_port;
        cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_chnl =
            cpb_handle->var.cpb_connect_data->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_chnl;

        /* clean */
        cpb_handle->var.cpb_connect_data->chnl[dest_mst_port][dest_mst_chnl].mst.state = UTIL_GLOBAL_CHNL_START;
        cpb_handle->var.cpb_connect_data->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_port = CPB_INDEX_LAST;
        cpb_handle->var.cpb_connect_data->chnl[dest_mst_port][dest_mst_chnl].mst.next_dest_mst_chnl = CPB_INDEX_LAST;
        cpb_handle->var.cpb_connect_data->chnl[dest_mst_port][dest_mst_chnl].mst.source_slv_port = CPB_INDEX_LAST;
        cpb_handle->var.cpb_connect_data->chnl[dest_mst_port][dest_mst_chnl].mst.source_slv_chnl = CPB_INDEX_LAST;

        /* if it's the last dest_mst_port, then remove the slv_port */
        if (cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_port == CPB_INDEX_LAST &&
            cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_chnl == CPB_INDEX_LAST) {
            /* delete cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv */
            cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.state = UTIL_GLOBAL_CHNL_START;
        }

    }

{   /* update slv.is_broadcast and slv.is_multicast */
    UINT32 pc_count=0; /* port channel count */
    UINT32 itr_dest_mst_port, itr_dest_mst_chnl;
    UINT32 tmp_dest_mst_port, tmp_dest_mst_chnl; /* previous */
    UINT32 first_dest_mst_port, first_dest_mst_chnl;
    UINT32 itr_dp_port, itr_dp_chnl; /* iterator to find duplicated ports */
    UINT32 found_same_ports=0, found_diff_ports=0;

    first_dest_mst_port = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_port;
    first_dest_mst_chnl = cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.dest_mst_chnl;
    itr_dest_mst_port = first_dest_mst_port;
    itr_dest_mst_chnl = first_dest_mst_chnl;

    while (itr_dest_mst_port != CPB_INDEX_LAST) {
        pc_count++;

        if (!found_same_ports || !found_diff_ports) {
            itr_dp_port = cpb_handle->var.cpb_connect_data->chnl[itr_dest_mst_port][itr_dest_mst_chnl].mst.next_dest_mst_port;
            itr_dp_chnl = cpb_handle->var.cpb_connect_data->chnl[itr_dest_mst_port][itr_dest_mst_chnl].mst.next_dest_mst_chnl;
            while (itr_dp_port != CPB_INDEX_LAST) {
                if (itr_dp_port == itr_dest_mst_port) {
                    found_same_ports = 1;
                } else {
                    found_diff_ports = 1;
                }
                /* next list element */
                tmp_dest_mst_port = itr_dp_port;
                tmp_dest_mst_chnl = itr_dp_chnl;
                itr_dp_port = cpb_handle->var.cpb_connect_data->chnl[tmp_dest_mst_port][tmp_dest_mst_chnl].mst.next_dest_mst_port;
                itr_dp_chnl = cpb_handle->var.cpb_connect_data->chnl[tmp_dest_mst_port][tmp_dest_mst_chnl].mst.next_dest_mst_chnl;
            }
        } else {
            break;
        }

        /* next list element */
        tmp_dest_mst_port = itr_dest_mst_port;
        tmp_dest_mst_chnl = itr_dest_mst_chnl;
        itr_dest_mst_port = cpb_handle->var.cpb_connect_data->chnl[tmp_dest_mst_port][tmp_dest_mst_chnl].mst.next_dest_mst_port;
        itr_dest_mst_chnl = cpb_handle->var.cpb_connect_data->chnl[tmp_dest_mst_port][tmp_dest_mst_chnl].mst.next_dest_mst_chnl;
    }

    cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_broadcast = found_diff_ports;
    cpb_handle->var.cpb_connect_data->chnl[ingress_mux_input_port][ingress_mux_input_port_chnl].slv.is_multicast = found_same_ports;
}

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_connect_data_delete */


/*******************************************************************************
*  cpb_queue_build
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function builds the queue based on the given parameters.
*
*
* INPUTS:
*   *cpb_handle         - pointer to cpb handle instance.
*   push_port_id        - push port that the queue is associated with
*   pop_port_id         - pop port that the queue is associated with
*   write_qid           - the write queue id of the queue
*   read_qid            - the read queue id of the queue
*   num_blocks          - the number of blocks requested by the queue
*
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_queue_build( cpb_handle_t *cpb_handle,
                                   UINT32 push_port_id,
                                   UINT32 pop_port_id,
                                   UINT32 write_qid,
                                   UINT32 read_qid,
                                   UINT32 num_blocks )
{
    /* Variable declaration */
    UINT32 num_current_blocks;
    UINT32 * temp_block_array;

    PMC_ERROR ret_val;
    UINT32 num_current_pages;
    UINT32 * current_page_array;
    UINT32 fifo_end_addr, queue_index;

    PMC_ENTRY();

    temp_block_array = cpb_mem_pool_assign(cpb_handle, CPB_MEM_POOL_ID_2);
    PMC_ASSERT(temp_block_array != NULL, CPB_ERR_CODE_ASSERT, 0, 0);
    current_page_array = temp_block_array + (cpb_handle->cfg.blocks_per_page*cpb_handle->cfg.num_pages);

    /* argument checking */
    if (push_port_id >= cpb_handle->cfg.push_port_num || pop_port_id >= cpb_handle->cfg.pop_port_num) {
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    if (read_qid >= CPB_NUM_SCHED_ENTRIES) {
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }
    PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "write_qid = %u, read_qid = %u, num_blocks = %u\n", write_qid, read_qid, num_blocks);

    /* Check if the queue already exists*/
    ret_val = cpb_qs_current_pages_get(cpb_handle,push_port_id,pop_port_id,&num_current_pages,&current_page_array[0]);
    if(ret_val){
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
        PMC_RETURN(ret_val);
    }
    cpb_queue_num_current_blocks_get(cpb_handle, write_qid, num_current_pages, current_page_array, &num_current_blocks);

    /* if FIFO already exist return error */
    if(num_current_blocks != 0)
    {
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
        PMC_RETURN(CPB_ERR_QUEUE_ALREADY_EXSITS);
    }


    /* get the available blocks from the IPT and check if there is
       enough available pages in the IPT for the num blocks to be added */
    ret_val = cpb_qs_empty_block_get(cpb_handle, push_port_id, pop_port_id, num_blocks, &temp_block_array[0]);
    if (ret_val != PMC_SUCCESS) {
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
        PMC_RETURN(ret_val);  /* if not enough available blocks return an error */
    }

    /* Build the fifo and update the page usage state in memory */
    cpb_queue_memory_allocate(cpb_handle, write_qid, num_current_blocks, num_blocks, &temp_block_array[0]);


    /* calculate the end address */
    PMC_LOG_TRACE("\nFIFO end address calculation: read_qid = %u, num_blocks = %u \n",read_qid,num_blocks);
    cpb_fifo_end_addr_cal(cpb_handle, read_qid, num_blocks,  &fifo_end_addr);

    PMC_LOG_TRACE("\nFIFO end address setting: fifo_end_addr = %u \n",fifo_end_addr);

    cpb_fifo_reset_cfg(cpb_handle, push_port_id, pop_port_id, TRUE, write_qid, read_qid, 1);

    /* configure the end address */
    ret_val = cpb_fifo_end_addr_cfg(cpb_handle, push_port_id, pop_port_id, write_qid, read_qid, fifo_end_addr, FALSE, FALSE);

    if (ret_val != PMC_SUCCESS) {
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
        PMC_RETURN(ret_val);
    }

    /* MCPB fifo status will be updated in upper function. */
    if (CPB_INSTANCE_MCPB != cpb_handle->cfg.cpb_type)
    {
        queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, pop_port_id, read_qid);
        cpb_handle->var.fifo_var_data[queue_index].status = CPB_FIFO_BEING_USED;
    }

    cpb_fifo_reset_cfg(cpb_handle, push_port_id, pop_port_id, TRUE, write_qid, read_qid, 0);

    cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
    PMC_RETURN(PMC_SUCCESS);

} /* cpb_queue_build */

/*******************************************************************************
*  cpb_queue_destroy
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function destroys the queue and deallocates the physical blocks that are
*   already allocated for the queue in the block inverted page table.
*
* INPUTS:
*   *cpb_handle         - pointer to the CPB handle instance
*   pop_port_id         - pop port id\n
*                         0:3
*   mfege_pop_port_id   - MGMGT FEGE pop port id.\n
*                         0:3
*   read_qid            - read queue ID of the queue
*   super_deprov        - boolean to indicate if this function is used in
*                         bulk deprovisioning mode.\n
*                         TRUE: bulk deprovisioning\n
*                         FALSE: normal deprovisioning
*
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_queue_destroy( cpb_handle_t *cpb_handle,
                                     UINT32 pop_port_id,
                                     UINT32 mfege_pop_port_id,
                                     UINT32 read_qid,
                                     BOOL8 super_deprov )
{
    /* Variable declaration */
    UINT32 num_current_pages,num_current_blocks;
    UINT32 *current_page_array, *current_block_array;
    UINT32 queue_index, write_qid, push_port_id = 0;
    PMC_ERROR ret_val;

    PMC_ENTRY();

    current_block_array = cpb_mem_pool_assign(cpb_handle, CPB_MEM_POOL_ID_2);
    PMC_ASSERT(current_block_array != NULL, CPB_ERR_CODE_ASSERT, 0, 0);
    current_page_array = current_block_array + (cpb_handle->cfg.blocks_per_page*cpb_handle->cfg.num_pages);

    /* argument checking */
    if (pop_port_id >= cpb_handle->cfg.pop_port_num) {
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    if (read_qid >= cpb_handle->cfg.max_fifo_num) {
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }
    if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type)
    {
        queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, mfege_pop_port_id, read_qid);
    }
    else
    {
        queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, pop_port_id, read_qid);
    }

    push_port_id = cpb_handle->var.fifo_var_data[queue_index].push_port_id;
    write_qid = cpb_handle->var.fifo_var_data[queue_index].write_id;

    /* Retrive number of blocks in IPT for queue_id to see if Queue is already
       created */
    ret_val = cpb_qs_current_pages_get(cpb_handle,push_port_id,pop_port_id,&num_current_pages,current_page_array);

    if(ret_val)
    { 
        cpb_mem_pool_release(cpb_handle, 2); 
        PMC_RETURN(ret_val);
    } 
    cpb_queue_num_current_blocks_get(cpb_handle, write_qid, num_current_pages, current_page_array, &num_current_blocks);

    /* if FIFO doesn't exist return error */
    if(0 == num_current_blocks)
    {
        if (FALSE == super_deprov)
        {
            cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
            PMC_RETURN(CPB_ERR_QUEUE_NOT_BUILT);
        }
    }
    PMC_LOG(PMC_LOG_SEV_LOWEST, 0, 0, 0,
            "Current number of blocks = %d\n", num_current_blocks);
    cpb_queue_current_blocks_get(cpb_handle, write_qid, num_current_pages, current_page_array, current_block_array);

    if (num_current_blocks > 0)
    {
        /* deallocate memory for the FIFO */
        cpb_queue_memory_deallocate(cpb_handle, push_port_id, write_qid, num_current_blocks, 0, current_block_array);
    }
    /* pages might be releasable after blocks released */
    cpb_pmpm_queue_system_page_release(cpb_handle, push_port_id, pop_port_id );


    if (super_deprov == FALSE)
    {
        cpb_handle->var.fifo_var_data[queue_index].fifo_end_addr = 0;
        cpb_handle->var.fifo_var_data[queue_index].write_id = CPB_BLOCK_WQID_NIL;
        cpb_handle->var.fifo_var_data[queue_index].status = CPB_FIFO_NOT_USED;
        cpb_handle->var.fifo_var_data[queue_index].push_port_id = CPB_FIFO_PUSHID_NIL;
        cpb_handle->var.fifo_var_data[queue_index].chnl_type = CPB_FIFO_INVALID_CH;
    }

    /* take the queue into reset*/
    cpb_fifo_reset_cfg(cpb_handle, push_port_id, pop_port_id, TRUE, write_qid, read_qid, 1);

    /* If a block leak existed but was just cleaned, update the context */
    if(pmc_cpb_pmpm_block_remap(&cpb_handle->base))
    {
        if(cpb_handle->var.block_leak.leak_exists == TRUE &&
           cpb_handle->var.block_leak.pop_port == pop_port_id &&
           cpb_handle->var.block_leak.rid == read_qid)
        {
            cpb_handle->var.block_leak.leak_exists = FALSE;
            cpb_handle->var.block_leak.pop_port = CPB_INVALID_REMAP_VALUE;
            cpb_handle->var.block_leak.rid = CPB_INVALID_REMAP_VALUE;
        }
    }

    cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_queue_destroy */

/*******************************************************************************
*  cpb_queue_num_blocks_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns the number of FIFO blocks for the specified pop port,
*   read queue id
*
*
* INPUTS:
*   *cpb_handle       - pointer to CPB handle instance.
*   pop_port_id       - pop port id of the queue
*   read_qid          - read queue id of the queue
*
*
* OUTPUTS:
*   *num_current_blocks_ptr    - number of blocks used in FIFO requested in this
*                                API call
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_queue_num_block_get( cpb_handle_t *cpb_handle,
                                          UINT32 pop_port_id,
                                          UINT32 read_qid,
                                          UINT32 *num_current_blocks_ptr )
{
    /* Variable declaration */
    UINT32 num_current_blocks;
    UINT32 *temp_block_array;
    UINT32 num_current_pages;
    UINT32 *current_page_array;
    PMC_ERROR ret_val;
    UINT32 queue_index;
    UINT32 push_port_id, write_qid;

    PMC_ENTRY();

    /*  argument checking */
    if (pop_port_id >= cpb_handle->cfg.pop_port_num) {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    if (read_qid >= cpb_handle->cfg.max_fifo_num) {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    temp_block_array = cpb_mem_pool_assign(cpb_handle, CPB_MEM_POOL_ID_2);
    PMC_ASSERT(temp_block_array != NULL, CPB_ERR_CODE_ASSERT, 0, 0);
    current_page_array = temp_block_array + (cpb_handle->cfg.blocks_per_page*cpb_handle->cfg.num_pages);


    queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, pop_port_id, read_qid);
    push_port_id = cpb_handle->var.fifo_var_data[queue_index].push_port_id;
    write_qid = cpb_handle->var.fifo_var_data[queue_index].write_id;
    /* Retrive number of pages in IPT for FIFO_ID to see if FIFO is already
    created */
    /*configure the MGMT port to insert/extract the packets with 9600 bytes*/
    if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type &&
        CPB_FIFO_NOT_USED == cpb_handle->var.fifo_var_data[queue_index].status) {
        *num_current_blocks_ptr = 0;
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2); PMC_RETURN(PMC_SUCCESS);
    }

    ret_val = cpb_qs_current_pages_get(cpb_handle,push_port_id,pop_port_id,&num_current_pages,current_page_array);
    if(ret_val){ cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2); PMC_RETURN(ret_val);}
    cpb_queue_num_current_blocks_get(cpb_handle, write_qid, num_current_pages, current_page_array, &num_current_blocks);

    *num_current_blocks_ptr = num_current_blocks;
    cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
    PMC_RETURN(PMC_SUCCESS);
} /* cpb_queue_num_block_get */

/*******************************************************************************
*  cpb_queue_resize
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function adjusts the number of pages used by an existing CPB queue.
*   Prior to calling a function must have been created using cpb_queue_build.\n\n
*
*   This function may terminate with CPB_ERR_END_ADDR_UPDATE_INCOMPLETE.  This
*   is a recoverable failure. The error occurs as data is not flowing through
*   fifo_id, for example if channel is backpressured by SIFD.  In such cases,
*   fifo_id is actively using the number of pages that was used at the time of
*   making this API call.\n\n
*
*   The function may be recalled to repeat the resize operation.  The function
*   may be called with num_pages as originally assigned to the fifo_id to
*   recover pages that were assigned to fifo_id by this API call.\n\n
*
*   Should calls to this API to modify the size of a FIFO pathologically fail,
*   a data path issue exists whereby data is not flowing through the FIFO.  At
*   the CFC level to force a resize of the FIFO call cfc_fifo_destroy followed
*   by cfc_fifo_build for the fifo_id.\n\n
*
* INPUTS:
*   *cpb_handle        - pointer to CPB handle instance.
*   pop_port_id        - pop port id
*   read_qid           - read queue id of the queue
*   page_management_en - TRUE: assign more or release PMPM pages if required
*                        FALSE: perform no PMPM page management
*   num_blocks         - desired number of blocks
*
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_queue_resize( cpb_handle_t *cpb_handle,
                                   UINT32 pop_port_id,
                                   UINT32 read_qid,
                                   BOOL8  page_management_en,
                                   UINT32 num_blocks )
{
    /* Variable declaration */
    UINT32 num_current_blocks;
    UINT32 num_available_blocks = 0;
    UINT32 num_additional_blocks;
    UINT32 num_requested_pages;
    UINT32 *temp_block_array;
    UINT32 num_current_pages;
    UINT32 *current_page_array;
    PMC_ERROR ret_val;
    UINT32 queue_index;
    UINT32 fifo_end_addr;
    UINT32 current_end_addr = 0;
    UINT32 push_port_id, write_qid, egress_mux_input_port = 0;

    PMC_ENTRY();

    /*  argument checking */
    if (pop_port_id >= cpb_handle->cfg.pop_port_num) {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    if (read_qid >= cpb_handle->cfg.max_fifo_num) {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    temp_block_array = cpb_mem_pool_assign(cpb_handle, CPB_MEM_POOL_ID_2);
    PMC_ASSERT(temp_block_array != NULL, CPB_ERR_CODE_ASSERT, 0, 0);
    current_page_array = temp_block_array + (cpb_handle->cfg.blocks_per_page*cpb_handle->cfg.num_pages);

    if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && CPB_MCPB_POP_PORT_2 == pop_port_id &&
       25 > read_qid)
    {
        egress_mux_input_port = 3;
        queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, read_qid);
    }
    else
    {
        egress_mux_input_port = pop_port_id;
        queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, pop_port_id, read_qid);
    }

    push_port_id = cpb_handle->var.fifo_var_data[queue_index].push_port_id;
    write_qid = cpb_handle->var.fifo_var_data[queue_index].write_id;

    /*configure the MGMT port to insert/extract the packets with 9600 bytes*/
    if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type &&
        CPB_FIFO_NOT_USED == cpb_handle->var.fifo_var_data[queue_index].status) {
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
        PMC_RETURN(CPB_ERR_QUEUE_NOT_BUILT);
    }
 
    /* Retrive number of pages in IPT for FIFO_ID to see if FIFO is already
       created */
    ret_val = cpb_qs_current_pages_get(cpb_handle,push_port_id,pop_port_id,&num_current_pages,current_page_array);
    if(ret_val){
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
        PMC_RETURN(ret_val);
    }
    cpb_queue_num_current_blocks_get(cpb_handle, write_qid, num_current_pages, current_page_array, &num_current_blocks);
    cpb_queue_current_blocks_get(cpb_handle, write_qid, num_current_pages, current_page_array, &temp_block_array[0]);

    /* if FIFO doesn't exist return error */
    if(0 == num_current_blocks )
    {
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
        PMC_RETURN(CPB_ERR_QUEUE_NOT_BUILT);
    }

    if(num_current_blocks != num_blocks){

        /* Retrieve end_address used by FIFO ID */
        cpb_fifo_end_addr_get(cpb_handle, pop_port_id, read_qid, &current_end_addr);

        cpb_current_avail_blocks_get(cpb_handle,
                                     num_current_pages,
                                     current_page_array,
                                     &num_available_blocks);

        /* calculate the new end address */
        cpb_fifo_end_addr_cal(cpb_handle, read_qid, num_blocks,  &fifo_end_addr);

    } else {
        /* the block size has not changed */
        PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "num_current_blocks = %u, num_blocks = %u\n", num_current_blocks, num_blocks);
    }

    if( num_current_blocks < num_blocks ) /* current size is smaller than requested, need to allocate more blocks*/
    {
        PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "num_current_blocks = %u, num_blocks = %u\n", num_current_blocks, num_blocks);


       /*if there is not enough pages for the push/pop pair, allocate new PMPM pages*/
        if(num_available_blocks < (num_blocks-num_current_blocks))
        {
            if(page_management_en == TRUE)
            {
                num_additional_blocks = num_blocks - num_current_blocks - num_available_blocks;
                PMC_ASSERT(cpb_handle->cfg.blocks_per_page != 0,CPB_ERR_DIVIDED_BY_ZERO,0,0);
                num_requested_pages = num_current_pages + num_additional_blocks / cpb_handle->cfg.blocks_per_page;
                num_requested_pages = (num_additional_blocks % cpb_handle->cfg.blocks_per_page) ? num_requested_pages + 1: num_requested_pages;
                ret_val = cpb_pmpm_queue_system_page_assign(cpb_handle,
                                                            push_port_id,
                                                            pop_port_id,
                                                            egress_mux_input_port,
                                                            num_requested_pages);
                if (ret_val){
                    cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
                    PMC_RETURN(ret_val);
                }
            }
            else
            {
                PMC_ASSERT(FALSE, CPB_ERR_CODE_ASSERT, 0, 0);
            }
        }

        /* get the available block addresses from the IPT and check if there is
           enough available blocks in the IPT for the num blocks to be added */
        ret_val = cpb_qs_empty_block_get(cpb_handle, push_port_id, pop_port_id, num_blocks-num_current_blocks, &temp_block_array[0]);
        if (ret_val) {cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2); /* PMC_FREE(&temp_block_array); */ PMC_RETURN(ret_val);}

        /* Build the fifo and update the block usage state in memory */
        cpb_queue_memory_allocate(cpb_handle, write_qid, num_current_blocks, num_blocks, &temp_block_array[0]);

        /* configure the end address */
        ret_val = cpb_fifo_end_addr_cfg(cpb_handle, push_port_id, pop_port_id, write_qid, read_qid, fifo_end_addr, TRUE, FALSE);
        if (ret_val) {
            cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
            PMC_RETURN(ret_val);
        }

    } else if( num_current_blocks > num_blocks ) {
        PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "num_current_blocks = %u, num_blocks = %u\n", num_current_blocks, num_blocks);

        /* configure the end address */
        ret_val = cpb_fifo_end_addr_cfg(cpb_handle, push_port_id, pop_port_id, write_qid, read_qid, fifo_end_addr, TRUE, FALSE);
        if (ret_val) {
            cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
            PMC_RETURN(ret_val);
        }

        /* deallocate memory for the queue */
        cpb_queue_memory_deallocate(cpb_handle, push_port_id, write_qid, num_current_blocks, num_blocks, temp_block_array);

        /* release PMPM pages if excess PMPM pages exist */
        if(page_management_en == TRUE)
        {
            cpb_pmpm_queue_system_page_release(cpb_handle, push_port_id, pop_port_id );
        }
    } else {
        /* the block size has not changed */
        PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "num_current_blocks = %u, num_blocks = %u\n", num_current_blocks, num_blocks);
    }

    cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
    PMC_RETURN(PMC_SUCCESS);

} /* cpb_queue_resize */

/*******************************************************************************
*  cpb_queue_relative_resize
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function is a wrapper for cpb_queue_resize and will
*   allow a queue size to be increased of decreased by a given
*   number of blocks.
*
* INPUTS:
*   *cpb_handle         - pointer to CPB handle instance.
*   pop_port_id         - pop port id
*   read_qid            - read queue id of the queue
*   page_management_en  - TRUE: assign more or release PMPM pages if required
*                         FALSE: perform no PMPM page management
*   increase_blocks     - number of blocks to increase
*   decrease_blocks     - number of blocks to decrease
*
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*   For the inputs increase_blocks and decrease_blocks, one must
*   be zero and one must be non-zero
*******************************************************************************/
PRIVATE PMC_ERROR cpb_queue_relative_resize(cpb_handle_t *cpb_handle,
                                            UINT32 pop_port_id,
                                            UINT32 read_qid,
                                            BOOL8  page_management_en,
                                            UINT32 increase_blocks,
                                            UINT32 decrease_blocks)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 num_current_blocks, num_blocks;
    UINT32 *temp_block_array;
    UINT32 num_current_pages;
    UINT32 *current_page_array;
    UINT32 queue_index;
    UINT32 push_port_id, write_qid;

    PMC_ENTRY();

    if(increase_blocks == 0 &&
       decrease_blocks == 0)
       PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(increase_blocks != 0 &&
       decrease_blocks != 0)
       PMC_RETURN(CPB_ERR_INVALID_ARG);

    temp_block_array = cpb_mem_pool_assign(cpb_handle, CPB_MEM_POOL_ID_2);
    PMC_ASSERT(temp_block_array != NULL, CPB_ERR_CODE_ASSERT, 0, 0);
    current_page_array = temp_block_array + (cpb_handle->cfg.blocks_per_page*cpb_handle->cfg.num_pages);

    queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, pop_port_id, read_qid);
    push_port_id = cpb_handle->var.fifo_var_data[queue_index].push_port_id;
    write_qid = cpb_handle->var.fifo_var_data[queue_index].write_id;
    /* Retrive number of pages in IPT for FIFO_ID to see if FIFO is already
       created */
    result = cpb_qs_current_pages_get(cpb_handle,push_port_id,pop_port_id,&num_current_pages,current_page_array);
    if(result){
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);
        PMC_RETURN(result);
    }
    cpb_queue_num_current_blocks_get(cpb_handle, write_qid, num_current_pages, current_page_array, &num_current_blocks);
    cpb_queue_current_blocks_get(cpb_handle, write_qid, num_current_pages, current_page_array, &temp_block_array[0]);
    cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_2);

    if(increase_blocks != 0)
    {
        num_blocks = num_current_blocks + increase_blocks;
        result = cpb_queue_resize(cpb_handle,
                                  pop_port_id,
                                  read_qid,
                                  page_management_en,
                                  num_blocks);

    }
    else if (num_current_blocks > decrease_blocks)
    {
        num_blocks = num_current_blocks - decrease_blocks;
        result = cpb_queue_resize(cpb_handle,
                                  pop_port_id,
                                  read_qid,
                                  page_management_en,
                                  num_blocks);
    }
    else
       PMC_RETURN(CPB_ERR_INVALID_ARG);

    PMC_RETURN(result);
} /* cpb_queue_relative_resize */

/*******************************************************************************
*  cpb_fifo_reset_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function takes the specified FIFO out of reset or
*   alternatively puts the specified FIFO into reset
*
*
* INPUTS:
*   *cpb_handle       - pointer to CPB handle instance.
*   push_port_id        - push port id
*   queue_system_id     - queue system id
*   scope               - BOOL, indicating scope of reset operation:\n
*                         TRUE: Operate on read and write pointer\n
*                         FALSE: Operate on read pointer only
*   write_qid           - write queue id
*   read_qid            - read queue id
*   reset_value         - 1: take the fifo into reset\n
*                         0: take the fifo out of reset
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_fifo_reset_cfg(cpb_handle_t *cpb_handle,
                                     UINT32 push_port_id,
                                     UINT32 queue_system_id,
                                     BOOL8 scope,
                                     UINT32 write_qid,
                                     UINT32 read_qid,
                                     UINT32 reset_value)
{
    /* Variable declaration */
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* Argument checking */
    PMC_ASSERT(reset_value <= 1, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(push_port_id <= 3, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(queue_system_id <= 3, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(write_qid <= 149, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(read_qid <= 95, CPB_ERR_INVALID_ARG, 0, 0);


    /* write DGB_RADDR to allow write access to pointers */
    result = cpb_fifo_reset_access_cfg(cpb_handle, queue_system_id, TRUE);
    if (PMC_SUCCESS != result) {

        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    if (reset_value == 0) {

        if(scope == TRUE)
        {
            result = cpb_fifo_reset_wr_cfg(cpb_handle, push_port_id, queue_system_id, write_qid, reset_value);

            if (PMC_SUCCESS != result) {

                PMC_RETURN(CPB_ERR_INVALID_ARG);
            }
        }
        result = cpb_fifo_reset_rd_cfg(cpb_handle, queue_system_id, read_qid, reset_value);

        if (PMC_SUCCESS != result) {

            PMC_RETURN(CPB_ERR_INVALID_ARG);
        }
    }

    else {

        result = cpb_fifo_reset_rd_cfg(cpb_handle, queue_system_id, read_qid, reset_value);

        if (PMC_SUCCESS != result) {

            PMC_RETURN(CPB_ERR_INVALID_ARG);
        }

        if(scope == TRUE)
        {
            result = cpb_fifo_reset_wr_cfg(cpb_handle, push_port_id, queue_system_id, write_qid, reset_value);

            if (PMC_SUCCESS != result) {

                PMC_RETURN(CPB_ERR_INVALID_ARG);
            }
        }
    }

    /* write DGB_RADDR to terminate write access to pointers */
    result = cpb_fifo_reset_access_cfg(cpb_handle, queue_system_id, FALSE);
    if (PMC_SUCCESS != result) {

        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_fifo_reset_cfg */

/*******************************************************************************
* cpb_audit_slv_dpi_register_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function retrieves CPB DPI Slave Port Channel data for usage with
*   Crash/Warm restart audit process.
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*
* OUTPUTS:
*   *slv_data_ptr         - pointer to DPI slave port channel data for all
*                           ports and channels.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_audit_slv_dpi_register_get(cpb_handle_t *cpb_handle,
                                                 cpb_slv_data_t *slv_data_ptr)
{
    UINT32 i, j;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();



    for(i = 0; i <= cpb_handle->cfg.max_slv_dpi_port; i++)
    {
        for(j = 0; j <= cpb_handle->cfg.max_dpi_slv_chnl_id[i]; j++)
        {
            if(result==PMC_SUCCESS)
            {
                result = cpb_slv_dpi_qs_ch_en_get(cpb_handle,
                                                  i,
                                                  j,
                                                  &(slv_data_ptr->slv_data[i][j].qs_ch_en[0]),
                                                  &(slv_data_ptr->slv_data[i][j].qs_ch_en[1]),
                                                  &(slv_data_ptr->slv_data[i][j].qs_ch_en[2]),
                                                  &(slv_data_ptr->slv_data[i][j].qs_ch_en[3]));
            }

#ifndef CPB_UNIT_TEST
            if(result==PMC_SUCCESS)
            {
                result = cpb_fw_slv_dpi_qs_ch_en_get(cpb_handle,
                                                     i,
                                                     j,
                                                     slv_data_ptr);
            }
#endif
            if(result==PMC_SUCCESS)
            {
                result = cpb_slv_dpi_qs_pop_qid_get(cpb_handle,
                                                    i,
                                                    j,
                                                    &(slv_data_ptr->slv_data[i][j].qs_pop_qid[0]),
                                                    &(slv_data_ptr->slv_data[i][j].qs_pop_qid[1]),
                                                    &(slv_data_ptr->slv_data[i][j].qs_pop_qid[2]),
                                                    &(slv_data_ptr->slv_data[i][j].qs_pop_qid[3]));
            }

            if(result==PMC_SUCCESS)
            {
                result = cpb_slv_dpi_qs_ch_mst_get(cpb_handle,
                                                   i,
                                                   j,
                                                   &(slv_data_ptr->slv_data[i][j].qs_ch_mst[0]),
                                                   &(slv_data_ptr->slv_data[i][j].qs_ch_mst[1]),
                                                   &(slv_data_ptr->slv_data[i][j].qs_ch_mst[2]),
                                                   &(slv_data_ptr->slv_data[i][j].qs_ch_mst[3]));
            }

        }
    }

    PMC_RETURN(result);

} /* cpb_audit_slv_dpi_register_get */

/*******************************************************************************
* cpb_audit_var_data_register_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Generates cpb_var_t structure data from reading device registe space.
*
*   Not all fields are updated.
*
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance
*   *slv_data_ptr               - pointer to DPI slave port channel data for all
*                                 ports and channels.
*    warm_restart               - restart mode
*
* OUTPUTS:
*   *var_ptr                    - pointer to cpb_var_t type structure with
*                                 subelements defined
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_audit_var_data_register_get(cpb_handle_t *cpb_handle,
                                                  cpb_slv_data_t *slv_data_ptr,
                                                  BOOL8 warm_restart,
                                                  cpb_var_t *var_ptr)
{

    UINT32 i, j;
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();

    /* This function covers: block_inverted_page_table, page_inverted_page_table,
       mcpb_im_sel, mcpb_em_sel, dcpb_em_sifd1_sel, dcpb_em_sifd2_sel */
    result = cpb_var_t_reg_data_update(cpb_handle, var_ptr);

    /* Initialize context not directly mapped to registers */
    if(result==PMC_SUCCESS)
    {
        result = cpb_var_t_ram_data_default_set(cpb_handle, var_ptr);
    }

    /* DCS offline and online page recovery */
    for(i=0;i < cpb_handle->cfg.num_dcs;i++)
    {
        /* recover enabled state */
        if(result == PMC_SUCCESS)
        {
            result = cpb_dcs_enable_get(cpb_handle, i, &(var_ptr->dcs_inst_init_flag[i]));
        }

        /* recover online and offline page if DCS is activated - else default values maintained
           from call to cpb_var_t_ram_data_default_set() */
        if(var_ptr->dcs_inst_init_flag[i] == TRUE){
            /* recover offline page */
            for(j=0;j< cpb_num_calendar_entries_get(cpb_handle,i);j++)
            {
                if(result == PMC_SUCCESS)
                {
                    result = cpb_dcs_wrr_entry_get(cpb_handle, i, j,
                                                   &(var_ptr->dcs_offline_calendars[i][j].c_ram_sf1),
                                                   &(var_ptr->dcs_offline_calendars[i][j].c_ram_sf2),
                                                   &(var_ptr->dcs_offline_calendars[i][j].c_ram_channel),
                                                   &(var_ptr->dcs_offline_calendars[i][j].c_ram_identifier));
                }
            }


            /* swap page */
            cpb_dcs_page_swap(cpb_handle, i);

            /* Poll for page swap success */
            result = cpb_dcs_poll_swap_success(cpb_handle, i);
            PMC_ASSERT(result==PMC_SUCCESS, CPB_ERR_CODE_ASSERT, 0, 0);

            /* recover online page */
            for(j=0;j< cpb_num_calendar_entries_get(cpb_handle,i);j++)
            {
                if(result == PMC_SUCCESS)
                {
                    result = cpb_dcs_wrr_entry_get(cpb_handle, i, j,
                                                   &(var_ptr->dcs_online_calendars[i][j].c_ram_sf1),
                                                   &(var_ptr->dcs_online_calendars[i][j].c_ram_sf2),
                                                   &(var_ptr->dcs_online_calendars[i][j].c_ram_channel),
                                                   &(var_ptr->dcs_online_calendars[i][j].c_ram_identifier));
                }
            }

            /* swap back */
            cpb_dcs_page_swap(cpb_handle, i);

            /* Poll for page swap success */
            if(result == PMC_SUCCESS)
            {
                result = cpb_dcs_poll_swap_success(cpb_handle, i);
                PMC_ASSERT(result==PMC_SUCCESS, CPB_ERR_CODE_ASSERT, 0, 0);
            }
        }
    }
    /* fifo_var_data recovery */
    cpb_audit_fifo_var_data_get(cpb_handle, slv_data_ptr, warm_restart, var_ptr);

    if(result == PMC_SUCCESS)
    {
        if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB)
        {
            var_ptr->dcpb_ingress_mux_output_source[0] = cpb_mux_cpbd_src_sel_cfg_get(cpb_handle, 0);
            var_ptr->dcpb_ingress_mux_output_source[1] = cpb_mux_cpbd_src_sel_cfg_get(cpb_handle, 1);
        }
    }


    PMC_RETURN(result);

} /* cpb_audit_var_data_register_get */

/*******************************************************************************
* cpb_fifo_var_data_status_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the fifo_var_data status for the passed in DCS and read queue ID.
*
* INPUTS:
*   *cpb_handle             - pointer to cpb handle instance
*   dcs_inst                - The DCS instance, 0-3
*   read_id                 - The read queue ID.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   The fifo_var_data status for the read queue id.
*
* NOTES:
*
*******************************************************************************/
PRIVATE cpb_fifo_status_t cpb_fifo_var_data_status_get(cpb_handle_t * cpb_handle,
                                                       UINT32 dcs_inst,
                                                       UINT32 read_id)
{
    cpb_fifo_status_t status;
    util_schd_chnl_ctxt_t *p_chnl_ctxt = NULL;

    PMC_ENTRY();

    p_chnl_ctxt = cpb_handle->util_schd_handle[dcs_inst]->var.schd_ctxt->chnl_ctxt;

    /* for MCPB DCS instance 0 and 1, the read queue id is always even for
       alternate queue mode, for example read queue id 0 and 1 share context
       stored in util schd for read queue id 0 */
    if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && 
       dcs_inst < 2 &&
       (read_id%2 == 1))
        read_id--;

    if(p_chnl_ctxt[read_id].state != UTIL_SCHD_CHNL_START)
        status = CPB_FIFO_BEING_USED;
    else
        status = CPB_FIFO_NOT_USED;

    PMC_RETURN(status);
} /* cpb_fifo_var_data_status_get */


/*******************************************************************************
* cpb_audit_fifo_var_data_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Generates cpb_var_t structure data for fifo_var data.  Performs
*   device read accesses.
*
*
* INPUTS:
*   *h                          - pointer to cpb handle instance
*   *slv_data_ptr               - pointer to register recovered DPI slave port
*                                 channel data
*   warm_restart                - warm restart mode
*
* OUTPUTS:
*   *var_ptr                    - pointer to cpb_var_t type structure with
*                                 subelements defined
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void cpb_audit_fifo_var_data_get(cpb_handle_t *h,
                                         cpb_slv_data_t *slv_data_ptr,
                                         BOOL8 warm_restart,
                                         cpb_var_t *var_ptr)
{
    UINT32 i, j, dcs_rd_channel_id, dcs_sf1_push_port_id, dcs_sf2_wr_queue_id,
    slave_port, slave_channel;
    util_schd_chnl_state_t chnl_state;
    PMC_ERROR result;
    UINT32 queue_index;
    PMC_ENTRY();


    /* fifo_var_data recovery */
    for(i=0;i<h->cfg.num_queue_systems;i++) /* i is the DCS number (also queue system) */
    {
        for(j=0;j<cpb_num_sched_chans_get(h,i);j++) /* j is the read queue id */
        {
            queue_index = cpb_fifo_var_data_queue_index_get(h, i, j);
            var_ptr->fifo_var_data[queue_index].status =
                cpb_fifo_var_data_status_get(h,
                                             i, /* dcs_inst */
                                             j); /*read queue id */
            /* If the FIFO is in use we need to get related information */
            if(var_ptr->fifo_var_data[queue_index].status == CPB_FIFO_BEING_USED)
            {
                /* only search the calendar for active DCS instances - else default values maintained
                   from call to cpb_var_t_ram_data_default_set() */
                if(var_ptr->dcs_inst_init_flag[i]==TRUE)
                {
                    UINT32 alt_queue_mod = 0;
                    /* For an alternate queue MCPB util_schd data is stored for read qid - 1 */
                    if(CPB_INSTANCE_MCPB == h->cfg.cpb_type && 
                       i < 2 &&
                       (j%2 == 1))
                       alt_queue_mod = 1;

                    dcs_sf1_push_port_id = CPB_FIFO_PUSHID_NIL;
                    dcs_sf2_wr_queue_id = CPB_FIFO_PUSHID_NIL;

                    /* Use util_schd to recover push_port, wid */
                    result = util_schd_dcs_chnl_data_get(h->util_schd_handle[i],
                                                         (j - alt_queue_mod), /* read qid */
                                                         &chnl_state,
                                                         &dcs_rd_channel_id,
                                                         &dcs_sf1_push_port_id,
                                                         &dcs_sf2_wr_queue_id);
                    if (!(UTIL_SCHD_CHNL_OPERATIONAL == chnl_state || UTIL_SCHD_CHNL_BACKUP == chnl_state) && warm_restart == FALSE)
                    {
                        var_ptr->fifo_var_data[queue_index].status = CPB_FIFO_NOT_USED;
                    } else
                    {
                        if (CPB_INSTANCE_MCPB == h->cfg.cpb_type &&
                            (CPB_FIFO_PUSHID_NIL == dcs_rd_channel_id || CPB_FIFO_PUSHID_NIL == dcs_sf1_push_port_id))
                        {
                            if (CPB_MCPB_POP_PORT_2 == i)
                            {
                                dcs_sf1_push_port_id = CPB_FIFO_PUSHID_NIL;
                                dcs_sf2_wr_queue_id = CPB_FIFO_PUSHID_NIL;
                                util_schd_dcs_chnl_data_get(h->util_schd_handle[3],
                                                            (j - alt_queue_mod), /* read qid */
                                                            &chnl_state,
                                                            &dcs_rd_channel_id,
                                                            &dcs_sf1_push_port_id,
                                                            &dcs_sf2_wr_queue_id);
                            }
                        }
                        var_ptr->fifo_var_data[queue_index].push_port_id = dcs_sf1_push_port_id;
                        var_ptr->fifo_var_data[queue_index].write_id = (dcs_sf2_wr_queue_id + alt_queue_mod);

                        /* Use slave port data to recover chnl_type. If the
                         * channel is provisioned but not activated we can't
                         * determine the chnl_type. */
                        if(h->cfg.cpb_type != CPB_INSTANCE_MCPB)
                        {
                            cpb_ingress_mux_port_chnl_get(h,
                                                          var_ptr->fifo_var_data[queue_index].push_port_id,
                                                          var_ptr->fifo_var_data[queue_index].write_id,
                                                          &slave_port,
                                                          &slave_channel);
                        }
                        else
                        {
                            cpb_mcpb_ingress_mux_port_chnl_get(h,
                                                               var_ptr->fifo_var_data[queue_index].push_port_id,
                                                               var_ptr->fifo_var_data[queue_index].write_id,
                                                               i, /* pop port id equivalent to DCS instance */
                                                               &slave_port,
                                                               &slave_channel);
                        }
                        if (slave_port < h->cfg.max_slv_dpi_port &&
                            (slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_mst[i] == 1) &&
                            slave_channel < h->cfg.max_dpi_slv_chnl_id[slave_port])
                        {
                            if( (slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_en[i] == 1) &&
                                (slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_mst[i] == 1) &&
                                (slv_data_ptr->slv_data[slave_port][slave_channel].qs_pop_qid[i] == j) )
                            {
                                var_ptr->fifo_var_data[queue_index].chnl_type = CPB_SLAVE_ZONE_PRIMARY;
                            }
                            else if((slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_en[i] == 1) &&
                                    (slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_mst[i] == 0) &&
                                    (slv_data_ptr->slv_data[slave_port][slave_channel].qs_pop_qid[i] == j) )
                            {
                                var_ptr->fifo_var_data[queue_index].chnl_type = CPB_READER_PRIMARY;
                            }
                            else if((slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_en[i] == 1) &&
                                    (slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_mst[i] == 0) &&
                                    (slv_data_ptr->slv_data[slave_port][slave_channel].qs_pop_qid[i] != j) )
                            {
                                var_ptr->fifo_var_data[queue_index].chnl_type = CPB_FIFO_SECONDARY_CH;
                            }
                            else if(UTIL_SCHD_CHNL_BACKUP == chnl_state)
                            {
                                var_ptr->fifo_var_data[queue_index].chnl_type = CPB_SLAVE_ZONE_PRIMARY;
                            }
                            else
                            {
                                /* The channel is provisioned but not active.*/
                                var_ptr->fifo_var_data[queue_index].chnl_type = LAST_CPB_RD_CHNL_TYPE;
                            }
                        }
                        else
                        {
                            /* The channel is provisioned but not active.*/
                            var_ptr->fifo_var_data[queue_index].chnl_type = LAST_CPB_RD_CHNL_TYPE;
                        }
                    }
                }
                else
                {
                    var_ptr->fifo_var_data[queue_index].status = CPB_FIFO_NOT_USED;
                }

                /* Note that end address is not recovered */
            } /* end if fifo var data status */
        } /* end for j max_fifo_num */
    } /* end for i queue systems */

    PMC_RETURN();

} /* cpb_audit_fifo_var_data_get */

/*******************************************************************************
* cpb_audit_var_intf_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Generates cpb_var_t structure data from reading device registe space for
*   the elements:\n
*       slv_dpi_port_init_flag \n
*       mst_dpi_port_init_flag \n\n
*
*   This API requires var_ptr data to have been update for DCS and slave port
*   channel data prior as it processes these fields.
*
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance
*   *slv_data_ptr               - pointer to register recovered DPI slave port
*                                 channel data
*
* OUTPUTS:
*   *var_ptr                    - pointer to cpb_var_t type structure with
*                                 subelements defined
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_audit_var_intf_state_get(cpb_handle_t *cpb_handle,
                                               cpb_slv_data_t *slv_data_ptr,
                                               cpb_var_t *var_ptr)
{

    UINT32 i, j, master_port, master_channel, dcs_rd_channel, slave_port,
           slave_channel, queue_index;
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();

    /* slv_dpi_port_init_flag[8] - recovery */
    for(i = 0; i <= cpb_handle->cfg.max_slv_dpi_port; i++)
    {
        var_ptr->slv_dpi_port_init_flag[i] = FALSE;
        var_ptr->mst_dpi_port_init_flag[i] = FALSE;
    }

    for(i = 0; i <= cpb_handle->cfg.max_slv_dpi_port; i++)
    {
        for(j = 0; j <= cpb_handle->cfg.max_dpi_slv_chnl_id[i]; j++)
        {
            /* This only identifies OPERATIONAL channels within an interface */
            if(slv_data_ptr->slv_data[i][j].qs_ch_en[0] == 1 ||
               slv_data_ptr->slv_data[i][j].qs_ch_en[1] == 1 ||
               slv_data_ptr->slv_data[i][j].qs_ch_en[2] == 1 ||
               slv_data_ptr->slv_data[i][j].qs_ch_en[3] == 1)
            {
                var_ptr->slv_dpi_port_init_flag[i] = TRUE;
            }
        }
    }

    /* Search fifo_var data for channels that are equipped but not
     * necessarily operational */
    for(i=0;i<cpb_handle->cfg.num_dcs;i++)
    {
        for(j=0;j<cpb_num_sched_chans_get(cpb_handle,i);j++)
        {
            queue_index = i * cpb_handle->cfg.max_fifo_num + j;
            if(var_ptr->fifo_var_data[queue_index].status == CPB_FIFO_BEING_USED)
            {
                
                if(cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB)
                {
                    cpb_ingress_mux_port_chnl_get(cpb_handle,
                                                  cpb_handle->var.fifo_var_data[queue_index].push_port_id,
                                                  cpb_handle->var.fifo_var_data[queue_index].write_id,
                                                  &slave_port,
                                                  &slave_channel);
                }
                else
                {
                    cpb_mcpb_ingress_mux_port_chnl_get(cpb_handle,
                                                       cpb_handle->var.fifo_var_data[queue_index].push_port_id,
                                                       cpb_handle->var.fifo_var_data[queue_index].write_id,
                                                       i, /* interpretted as pop port for MCPB instance */
                                                       &slave_port,
                                                       &slave_channel);
                }

                var_ptr->slv_dpi_port_init_flag[slave_port] = TRUE;
            }
        }
    }

    /* Search DCS online calendar to determine which master ports are
     * initialized */
    for(i=0;i<cpb_handle->cfg.num_dcs;i++)
    {
        for(j=0;j<cpb_num_calendar_entries_get(cpb_handle,i);j++)
        {
            if(var_ptr->dcs_online_calendars[i][j].c_ram_identifier != DCS_NULL_QUEUE_ID &&
               var_ptr->dcs_inst_init_flag[i] == TRUE)
            {
                cpb_egress_mux_port_chnl_get(cpb_handle,
                                             i,
                                             var_ptr->dcs_online_calendars[i][j].c_ram_identifier,
                                             &dcs_rd_channel,
                                             &master_port,
                                             &master_channel);

                var_ptr->mst_dpi_port_init_flag[master_port] = TRUE;
            }
        }
    }


    PMC_RETURN(result);

} /* cpb_audit_var_intf_state_get */

/*******************************************************************************
* cpb_audit_ctxt_register_compare
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function compared context with register space.  It will identify
*   if there is a mismatch.\n\n
*
*   Only recoverable fields from device registers are compared.\n\n
*
*   Results of comparison output with mismatch_*_ptr parameters.
*   Logical meaning:\n
*        TRUE:  Mismatch present\n
*        FALSE: No mismatch present
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   *ctxt_var_ptr         - pointer to Context view of device configuration
*   *register_var_ptr     - pointer to register space recovered view of context
*
* OUTPUTS:
*   *mismatch_page_table_ptr     - pointer to Page Table mismatch status
*   *mismatch_block_table_ptr    - pointer to Block Table mismatch status
*   *mismatch_intf_switch_ptr    - pointer to ING/EGR Mux Switching mismatch
*   *mismatch_dcs_active_ptr     - pointer to DCS Activation mismatch
*   *mismatch_dcs_calendar_ptr   - pointer to DCS Calendar mismatch
*   *mismatch_fifo_var_data_ptr  - pointer to fifo_var_data mismatch
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_audit_ctxt_register_compare(cpb_handle_t *cpb_handle,
                                                  cpb_var_t *ctxt_var_ptr,
                                                  cpb_var_t *register_var_ptr,
                                                  BOOL8 *mismatch_page_table_ptr,
                                                  BOOL8 *mismatch_block_table_ptr,
                                                  BOOL8 *mismatch_intf_switch_ptr,
                                                  BOOL8 *mismatch_dcs_active_ptr,
                                                  BOOL8 *mismatch_dcs_calendar_ptr,
                                                  BOOL8 *mismatch_fifo_var_data_ptr)
{
    UINT32 i, j, index;
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 queue_index;

    PMC_ENTRY();

    *mismatch_page_table_ptr    = FALSE;
    *mismatch_block_table_ptr   = FALSE;
    *mismatch_intf_switch_ptr   = FALSE;
    *mismatch_dcs_active_ptr    = FALSE;
    *mismatch_dcs_calendar_ptr  = FALSE;
    *mismatch_fifo_var_data_ptr = FALSE;


    /* Direct Register recovery Compare */
    for( i = 0; i < cpb_handle->cfg.num_pages; i++)
    {
        PMC_LOG_TRACE("\n comparing page index %u ... \n",i);
        if(ctxt_var_ptr->page_inverted_page_table[i].ctrl_page_valid != register_var_ptr->page_inverted_page_table[i].ctrl_page_valid ||
           ctxt_var_ptr->page_inverted_page_table[i].ctrl_ipt_qs_id  != register_var_ptr->page_inverted_page_table[i].ctrl_ipt_qs_id  ||
           ctxt_var_ptr->page_inverted_page_table[i].ctrl_ipt_wp_id  != register_var_ptr->page_inverted_page_table[i].ctrl_ipt_wp_id)
        {
            *mismatch_page_table_ptr = TRUE;
        }

        for(j = 0; j < cpb_handle->cfg.blocks_per_page; j++)
        {
            index = i * cpb_handle->cfg.blocks_per_page + j;
            if(ctxt_var_ptr->block_inverted_page_table[index].ipt_valid != register_var_ptr->block_inverted_page_table[index].ipt_valid ||
               ctxt_var_ptr->block_inverted_page_table[index].ipt_wqid  != register_var_ptr->block_inverted_page_table[index].ipt_wqid  ||
               ctxt_var_ptr->block_inverted_page_table[index].ipt_lba   != register_var_ptr->block_inverted_page_table[index].ipt_lba)
            {
                *mismatch_block_table_ptr = TRUE;

            }
        }
    }

    if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type)
    {
        if(ctxt_var_ptr->mcpb_im_sel.igr_ext_sel    != register_var_ptr->mcpb_im_sel.igr_ext_sel    ||
           ctxt_var_ptr->mcpb_im_sel.egr_ext_sel    != register_var_ptr->mcpb_im_sel.egr_ext_sel    ||
           ctxt_var_ptr->mcpb_im_sel.reflect_sel    != register_var_ptr->mcpb_im_sel.reflect_sel    ||
           ctxt_var_ptr->mcpb_em_sel.em_egr_ext_sel != register_var_ptr->mcpb_em_sel.em_egr_ext_sel ||
           ctxt_var_ptr->mcpb_em_sel.em_igr_ext_sel != register_var_ptr->mcpb_em_sel.em_igr_ext_sel)
        {
            *mismatch_intf_switch_ptr = TRUE;
        }
    } else if(CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type) {
        if(ctxt_var_ptr->dcpb_em_sifd1_sel != register_var_ptr->dcpb_em_sifd1_sel ||
           ctxt_var_ptr->dcpb_em_sifd2_sel != register_var_ptr->dcpb_em_sifd2_sel)

        {
            *mismatch_intf_switch_ptr = TRUE;
        }

        if(ctxt_var_ptr->dcpb_ingress_mux_output_source[0] != register_var_ptr->dcpb_ingress_mux_output_source[0] ||
           ctxt_var_ptr->dcpb_ingress_mux_output_source[1] != register_var_ptr->dcpb_ingress_mux_output_source[1])
        {
            *mismatch_intf_switch_ptr = TRUE;
        }
    }

    /* DCS Compare */
    for(i = 0; i < cpb_handle->cfg.num_dcs; i++)
    {
        /* Confirm DCS Enable State matches */
        if(ctxt_var_ptr->dcs_inst_init_flag[i] !=  register_var_ptr->dcs_inst_init_flag[i])
        {
            *mismatch_dcs_active_ptr = TRUE;
        }

        /* If DCS enabled, compare contents */
        if(register_var_ptr->dcs_inst_init_flag[i] == 1)
        {
            for(j = 0; j < cpb_num_calendar_entries_get(cpb_handle,i); j++)
            {
                /* offline page comparison */
                if(ctxt_var_ptr->dcs_offline_calendars[i][j].c_ram_channel != register_var_ptr->dcs_offline_calendars[i][j].c_ram_channel)
                {
                    *mismatch_dcs_calendar_ptr = TRUE;
                }
                if(0x7F != register_var_ptr->dcs_offline_calendars[i][j].c_ram_identifier)
                {
                    if(ctxt_var_ptr->dcs_offline_calendars[i][j].c_ram_sf1 != register_var_ptr->dcs_offline_calendars[i][j].c_ram_sf1 ||
                       ctxt_var_ptr->dcs_offline_calendars[i][j].c_ram_sf2 != register_var_ptr->dcs_offline_calendars[i][j].c_ram_sf2 ||
                       ctxt_var_ptr->dcs_offline_calendars[i][j].c_ram_channel != register_var_ptr->dcs_offline_calendars[i][j].c_ram_channel)
                    {
                        *mismatch_dcs_calendar_ptr = TRUE;
                    }
                }

                /* online page comparison */
                if(ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_channel != register_var_ptr->dcs_online_calendars[i][j].c_ram_channel)
                {
                    *mismatch_dcs_calendar_ptr = TRUE;
                }
                if(0x7F != register_var_ptr->dcs_online_calendars[i][j].c_ram_identifier)
                {
                    if(ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_sf1 != register_var_ptr->dcs_online_calendars[i][j].c_ram_sf1 ||
                       ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_sf2 != register_var_ptr->dcs_online_calendars[i][j].c_ram_sf2 ||
                       ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_channel != register_var_ptr->dcs_online_calendars[i][j].c_ram_channel)
                    {
                        *mismatch_dcs_calendar_ptr = TRUE;
                    }
                }
            }
        }
    }

    /* fifo_var_data Compare */
    for(i = 0; i < cpb_handle->cfg.num_queue_systems; i++) /* i is the DCS number */
    {
        for(j = 0; j < cpb_num_sched_chans_get(cpb_handle,i); j++) /* j is the read queue id */
        {
            queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, i, j);

            /* check if the DCS is in alternate queue mode, if yes, only accept even
               rd queue id */

            /* comparte .push_port_id and .write_id */
            if(ctxt_var_ptr->fifo_var_data[queue_index].status       != register_var_ptr->fifo_var_data[queue_index].status ||
               ctxt_var_ptr->fifo_var_data[queue_index].push_port_id != register_var_ptr->fifo_var_data[queue_index].push_port_id ||
               ctxt_var_ptr->fifo_var_data[queue_index].write_id     != register_var_ptr->fifo_var_data[queue_index].write_id)
            {
                PMC_LOG_TRACE("cpb warm restart - cpb_audit_ctxt_register_compare: fifo_var_data mismatch, pop_port: %u, rid: %u\n",i,j);
                PMC_LOG_TRACE("    Context: status: %u, push_port: %u, wid: %u, chnl_type: %u\n",
                              ctxt_var_ptr->fifo_var_data[queue_index].status,
                              ctxt_var_ptr->fifo_var_data[queue_index].push_port_id,
                              ctxt_var_ptr->fifo_var_data[queue_index].write_id,
                              ctxt_var_ptr->fifo_var_data[queue_index].chnl_type);
                PMC_LOG_TRACE("    Register: status: %u, push_port: %u, wid: %u, chnl_type: %u\n",
                              register_var_ptr->fifo_var_data[queue_index].status,
                              register_var_ptr->fifo_var_data[queue_index].push_port_id,
                              register_var_ptr->fifo_var_data[queue_index].write_id,
                              register_var_ptr->fifo_var_data[queue_index].chnl_type);



                *mismatch_fifo_var_data_ptr = TRUE;
            }
        } /* end for j max_fifo_num */
    } /* end for i queue systems */

    /* update return result for mismatch */
    if(*mismatch_page_table_ptr == TRUE ||
       *mismatch_block_table_ptr == TRUE ||
       *mismatch_intf_switch_ptr == TRUE ||
       *mismatch_dcs_calendar_ptr == TRUE ||
       *mismatch_fifo_var_data_ptr == TRUE)
    {
        PMC_LOG_TRACE("cpb warm restart - cpb_audit_ctxt_register_compare: mismatch_page_table_ptr = %u, mismatch_block_table_ptr = %u, mismatch_intf_switch_ptr = %u,"
                      "mismatch_dcs_calendar_ptr = %u, mismatch_fifo_var_data_ptr = %u\n",
                      *mismatch_page_table_ptr,
                      *mismatch_block_table_ptr,
                      *mismatch_intf_switch_ptr,
                      *mismatch_dcs_calendar_ptr,
                      *mismatch_fifo_var_data_ptr);

        result = CPB_ERR_CONTEXT_INCOHERENT;
    }

    PMC_RETURN(result);

} /* cpb_audit_ctxt_register_compare */

/*******************************************************************************
* cpb_audit_ctxt_register_clean
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs a clean up of register space and context so that
*   only resources fully identified as operational in context and register
*   space remain.  All other resources are driven to the available state.
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   *restart_init_cfg_ptr - pointer to restart init config
*   *ctxt_var_ptr         - pointer to Context view of device configuration
*   *register_var_ptr     - pointer to register space recovered view of context
*   *slv_data_ptr         - pointer to a structure containing slave channel
*                           information
*   energy_state          - energy state of the block relative to parent.
*
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_audit_ctxt_register_clean(cpb_handle_t *cpb_handle,
                                                util_global_restart_init_cfg_t *restart_init_cfg_ptr,
                                                cpb_var_t *ctxt_var_ptr,
                                                cpb_var_t *register_var_ptr,
                                                cpb_slv_data_t *slv_data_ptr,
                                                pmc_energy_state_t energy_state)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 i;
    BOOL8 no_valid_blocks;

    PMC_ENTRY();

    /* 1) Page/blocks context to register sync */
    cpb_audit_block_ctxt_reg_clean(cpb_handle,
                                   ctxt_var_ptr,
                                   register_var_ptr,
                                   &no_valid_blocks);

   
    if( (1 == no_valid_blocks && cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB) &&
        cpb_handle->var.dcpb_em_sifd1_sel == 0 &&
        cpb_handle->var.dcpb_em_sifd2_sel == 0)
    {
        if( energy_state == PMC_ENERGY_STATE_RESET &&
            cpb_handle->var.parent_energy_state != PMC_BLOCK_LOWPWR_ON_DEFAULT &&
            cpb_handle->var.parent_energy_state != PMC_BLOCK_LOWPWR_OFF_DEFAULT)
        {
            result = CPB_ERR_NEEDS_RESET;
        }
    } else
    {

        /* 2) DCS context to register sync */
        cpb_audit_dcs_ctxt_reg_clean(cpb_handle,
                                     ctxt_var_ptr,
                                     register_var_ptr);


        /* 3) Clean util_schd based on DCS calendar, then regenerage the DCS
           calendar from util_schd */
        cpb_audit_dcs_util_schd_clean(cpb_handle,
                                      register_var_ptr);

        /* 4) Recover latest register fifo_var from util_schd and QSn_CH_EN. Use
         * QSn_CH_EN to recover chnl_type */
        cpb_audit_fifo_var_data_get(cpb_handle, slv_data_ptr, FALSE, register_var_ptr);
        /* 5) fifo_var context to register sync */
        cpb_audit_fifo_ctxt_reg_clean(cpb_handle,
                                      ctxt_var_ptr,
                                      register_var_ptr);

        /* ------ At this point the context is in sync. with the registers ----- */
        /* --------------------- Need to keep it that way ---------------------- */


        /* 6) Clean QSn_CH_EN based on fifo_var */
        /* Slave zone primary and reader primary channels are taken out of
         * slave registers. Secondary channels don't matter because they are not
         * reflected in slave registers */
        cpb_audit_fifo_var_slv_ch_en_clean(cpb_handle,
                                           register_var_ptr,
                                           slv_data_ptr);

        /* 7) Clean fifo_var based on QSn_CH_EN. This will get rid of secondary
         * channels if they have no primary.
         * Also resets wid and rid in device. */
        cpb_audit_slv_ch_en_fifo_var_clean(cpb_handle,
                                           register_var_ptr,
                                           slv_data_ptr);


        /* 8) Clean fifo_var based on util_schd
         * Also resets wid and rid in device. */
        cpb_audit_util_schd_fifo_var_clean(cpb_handle,
                                           register_var_ptr);

        /* 9) Clean fifo_var based on blocks
         * Also resets wid and rid in device. */
        cpb_audit_blocks_fifo_var_clean(cpb_handle,
                                        register_var_ptr);

        /* 10) Repeat 6 */
        /*     Clean QSn_CH_EN based on fifo_var */
        cpb_audit_fifo_var_slv_ch_en_clean(cpb_handle,
                                           register_var_ptr,
                                           slv_data_ptr);

        /* 11) Clean util_schd based on fifo_var */
        cpb_audit_fifo_var_util_schd_clean(cpb_handle,
                                           register_var_ptr);

        /* 12) Clean blocks based on fifo_var or QSn_CH_EN */
        /*     Here we use QSn_CH_EN */
        cpb_audit_fifo_block_clean(cpb_handle,
                                   ctxt_var_ptr,
                                   register_var_ptr,
                                   slv_data_ptr);

        /* 13) Regenerate DCS calendars. Update and swap. */
        for(i=0;i<cpb_handle->cfg.num_dcs;i++)
            cpb_dcs_page_update_and_swap(cpb_handle,i);

    } /* end if else no valid blocks */

    PMC_RETURN(result);

} /* cpb_audit_ctxt_register_clean */

/*******************************************************************************
* cpb_audit_fifo_block_clean
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function ensures that FIFO blocks have a corresponding QSn_CH_EN
*   bit set.  If there is not a corresponding QSn_CH_EN bit set, then the
*   FIFO blocks are removed.\n\n
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   *ctxt_var_ptr         - pointer to Context view of device configuration
*   *register_var_ptr     - pointer to register space recovered view of context
*   *slv_data_ptr         - pointer to QSn_CH_EN data for slave ports
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_audit_fifo_block_clean(cpb_handle_t *cpb_handle,
                                             cpb_var_t *ctxt_var_ptr,
                                             cpb_var_t *register_var_ptr,
                                             cpb_slv_data_t *slv_data_ptr)
{
    UINT32 ingress_port, ingress_chnl, i, j, index;
    BOOL8 page_used;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();


    for( i = 0; i < cpb_handle->cfg.num_pages; i++)
    {
        for(j = 0; j < cpb_handle->cfg.blocks_per_page; j++)
        {
            index = i * cpb_handle->cfg.blocks_per_page + j;
            if(register_var_ptr->block_inverted_page_table[index].ipt_valid == 1)
            {
                BOOL8 suppress = FALSE;                

                /* If QSn_CH_EN set for the DPI slave port channel, retain the config, otherwise,
                   bring to start state */
                if(cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB)
                {
                    cpb_ingress_mux_port_chnl_get(cpb_handle,
                                                  register_var_ptr->page_inverted_page_table[i].ctrl_ipt_wp_id,
                                                  register_var_ptr->block_inverted_page_table[index].ipt_wqid,
                                                  &ingress_port, &ingress_chnl);
                }
                else
                {
    
                    cpb_mcpb_ingress_mux_port_chnl_get(cpb_handle,
                                                       register_var_ptr->page_inverted_page_table[i].ctrl_ipt_wp_id,
                                                       register_var_ptr->block_inverted_page_table[index].ipt_wqid,
                                                       register_var_ptr->page_inverted_page_table[i].ctrl_ipt_qs_id,
                                                       &ingress_port, &ingress_chnl);
                }

                if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB && ingress_port == (UINT32)UTIL_GLOBAL_CPB_PORT_CBRC &&
                   register_var_ptr->page_inverted_page_table[i].ctrl_ipt_qs_id == CPB_DCS_INST_3)
                {
                    UINT32 k;
                    UINT32 rd_queue_id = 0xFFFFFFFF;

                    for(k = 0; k < CPB_MAX_FIFO_NUM; k++)
                    {
                        if(cpb_handle->var.fifo_var_data[CPB_DCS_INST_3*CPB_MAX_FIFO_NUM + k].write_id == register_var_ptr->block_inverted_page_table[index].ipt_wqid)
                        {
                            rd_queue_id = k;
                            break;
                        }
                    }

                    if((rd_queue_id != 0xFFFFFFFF) &&
                       (cpb_handle->util_schd_handle[CPB_DCS_INST_3]->var.schd_ctxt->chnl_ctxt[rd_queue_id].state == UTIL_SCHD_CHNL_BACKUP))
                    {
                        suppress = TRUE;
                    }
                }

                if (ingress_port < cpb_handle->cfg.max_slv_dpi_port &&
                    ingress_chnl < cpb_handle->cfg.max_dpi_slv_chnl_id[ingress_port] &&
                    suppress == FALSE)
                {
                    if(slv_data_ptr->slv_data[ingress_port][ingress_chnl].qs_ch_en[register_var_ptr->page_inverted_page_table[i].ctrl_ipt_qs_id] == 0)
                    {
                        /* The channel is not OPERATIONAL, set the block back to starting
                           state. */
                        PMC_LOG_TRACE("cpb crash restart - cpb_audit_fifo_block_clean: invalidating block. cpb_type: %u, slv_port: %u, slv_chnl: %u\n",cpb_handle->cfg.cpb_type,ingress_port,ingress_chnl);
                        cpb_block_table_cfg(cpb_handle, FALSE, i, j, 0, 0, 0);
                        register_var_ptr->block_inverted_page_table[index].ipt_valid = 0;
                        register_var_ptr->block_inverted_page_table[index].ipt_wqid = 0;
                        register_var_ptr->block_inverted_page_table[index].ipt_lba = 0;
                    }
                }
            }
        }
    }

    /* If all blocks in a page were invalidated, invalidate the page */
    for( i = 0; i < cpb_handle->cfg.num_pages; i++)
    {
        page_used = FALSE;
        for(j = 0; j < cpb_handle->cfg.blocks_per_page; j++)
        {
            index = i * cpb_handle->cfg.blocks_per_page + j;
            if(register_var_ptr->block_inverted_page_table[index].ipt_valid == 1)
                page_used = TRUE;
        }

        if(!page_used)
        {
            cpb_page_table_cfg(cpb_handle, i, FALSE, 0, 0, 0);
            register_var_ptr->page_inverted_page_table[i].ctrl_page_valid = 0;
            register_var_ptr->page_inverted_page_table[i].ctrl_ipt_qs_id = 0;
            register_var_ptr->page_inverted_page_table[i].ctrl_ipt_wp_id = 0;
        }
    }

    PMC_RETURN(result);

} /* cpb_audit_fifo_block_clean */




/*******************************************************************************
* cpb_audit_block_ctxt_reg_clean
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs a clean up or register space and context associated
*   with PMPM blocks.\n\n
*
*   Only blocks that are identical in context and register space will be
*   maintained, otherwise they will be set to invalid state.\n\n
*
*   When complete the cpb_handle->var context associated with blocks is
*   coherent with the device.
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   *ctxt_var_ptr         - pointer to Context view of device configuration
*   *register_var_ptr     - pointer to register space recovered view of context
*
*
* OUTPUTS:
*   *no_valid_blocks      - Indicates that there are no blocks in use in the
*                           CPB.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_audit_block_ctxt_reg_clean(cpb_handle_t *cpb_handle,
                                                 cpb_var_t *ctxt_var_ptr,
                                                 cpb_var_t *register_var_ptr,
                                                 BOOL8 * no_valid_blocks)
{
    UINT32 i, j, index;
    PMC_ERROR result = PMC_SUCCESS;
    BOOL8 page_used, found_queue;
    UINT32 queue_index = 0, rd_queue_itr =0;
    PMC_ENTRY();

    *no_valid_blocks = TRUE;

    PMC_LOG_TRACE("cpb crash restart - cpb_audit_block_ctxt_reg_clean: entering\n function\n");

    /* compare register to context and set to union of matching configuration.  If not matching
       invalidate the block. If Page associated with block invalid, invalidate the block */
    for( i = 0; i < cpb_handle->cfg.num_pages; i++)
    {
        for(j = 0; j < cpb_handle->cfg.blocks_per_page; j++)
        {
            index = i * cpb_handle->cfg.blocks_per_page + j;

            if(ctxt_var_ptr->block_inverted_page_table[index].ipt_valid != register_var_ptr->block_inverted_page_table[index].ipt_valid ||
               ctxt_var_ptr->block_inverted_page_table[index].ipt_wqid  != register_var_ptr->block_inverted_page_table[index].ipt_wqid  ||
               ctxt_var_ptr->block_inverted_page_table[index].ipt_lba   != register_var_ptr->block_inverted_page_table[index].ipt_lba ||
               (register_var_ptr->page_inverted_page_table[i].ctrl_page_valid == 0 && register_var_ptr->block_inverted_page_table[index].ipt_valid == 1)||
               (ctxt_var_ptr->page_inverted_page_table[i].ctrl_page_valid     == 0 && ctxt_var_ptr->block_inverted_page_table[index].ipt_valid== 1)||
               ctxt_var_ptr->page_inverted_page_table[i].ctrl_page_valid != register_var_ptr->page_inverted_page_table[i].ctrl_page_valid ||
               ctxt_var_ptr->page_inverted_page_table[i].ctrl_ipt_qs_id  != register_var_ptr->page_inverted_page_table[i].ctrl_ipt_qs_id ||
               ctxt_var_ptr->page_inverted_page_table[i].ctrl_ipt_wp_id  != register_var_ptr->page_inverted_page_table[i].ctrl_ipt_wp_id)
            {

                /* some aspect of a block is different set it to the starting state.
                   Note: ctxt_var_ptr updated in below API call */
                if(register_var_ptr->page_inverted_page_table[i].ctrl_page_valid == 1 ||
                   ctxt_var_ptr->page_inverted_page_table[i].ctrl_page_valid     == 1)
                    PMC_LOG_TRACE("cpb crash restart - cpb_audit_block_ctxt_reg_clean: invalidating block, push_port: %u, wid: %u, pop_port: %u register block valid: %u, lba: %u context block valid: %u, lba: %u\n",
                    register_var_ptr->page_inverted_page_table[i].ctrl_ipt_wp_id,
                    register_var_ptr->block_inverted_page_table[index].ipt_wqid,
                    register_var_ptr->page_inverted_page_table[i].ctrl_ipt_qs_id,
                    register_var_ptr->block_inverted_page_table[index].ipt_valid,
                    register_var_ptr->block_inverted_page_table[index].ipt_lba,
                    ctxt_var_ptr->block_inverted_page_table[index].ipt_valid,
                    ctxt_var_ptr->block_inverted_page_table[index].ipt_lba);


                cpb_block_table_cfg(cpb_handle, FALSE, i, j, 0, 0, 0);
                register_var_ptr->block_inverted_page_table[index].ipt_valid = 0;
                register_var_ptr->block_inverted_page_table[index].ipt_wqid = 0;
                register_var_ptr->block_inverted_page_table[index].ipt_lba = 0;
            } else
            {
                if (ctxt_var_ptr->block_inverted_page_table[index].ipt_valid == 1)
                {
                    found_queue = FALSE;
                    for (rd_queue_itr = 0; rd_queue_itr < cpb_handle->cfg.max_fifo_num && found_queue == FALSE; rd_queue_itr ++)
                    {
                        if (rd_queue_itr < cpb_num_sched_chans_get(cpb_handle,register_var_ptr->page_inverted_page_table[i].ctrl_ipt_qs_id))
                        {
                            queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, register_var_ptr->page_inverted_page_table[i].ctrl_ipt_qs_id,rd_queue_itr);
                            if(cpb_handle->var.fifo_var_data[queue_index].push_port_id == register_var_ptr->page_inverted_page_table[i].ctrl_ipt_wp_id &&
                               cpb_handle->var.fifo_var_data[queue_index].write_id     == register_var_ptr->block_inverted_page_table[index].ipt_wqid &&
                               register_var_ptr->fifo_var_data[queue_index].status == CPB_FIFO_BEING_USED)
                            {
                                found_queue = TRUE;
                            }
                        }
                    }
                    if (FALSE == found_queue &&
                        ((CPB_INSTANCE_MCPB != cpb_handle->cfg.cpb_type) ||
                        ((queue_index < cpb_fifo_var_data_queue_index_get(cpb_handle,
                                                                          cpb_handle->cfg.num_queue_systems,
                                                                          cpb_handle->cfg.max_fifo_num)) &&
                          register_var_ptr->fifo_var_data[queue_index].status == CPB_FIFO_BEING_USED)))
                    {
                        cpb_block_table_cfg(cpb_handle, FALSE, i, j, 0, 0, 0);
                        register_var_ptr->block_inverted_page_table[index].ipt_valid = 0;
                        register_var_ptr->block_inverted_page_table[index].ipt_wqid = 0;
                        register_var_ptr->block_inverted_page_table[index].ipt_lba = 0;
                    }
                }
            }

        }
    }

    /* If all blocks in a page were invalidated, invalidate the page */
    for( i = 0; i < cpb_handle->cfg.num_pages; i++)
    {
        page_used = FALSE;
        for(j = 0; j < cpb_handle->cfg.blocks_per_page; j++)
        {
            index = i * cpb_handle->cfg.blocks_per_page + j;
            if(register_var_ptr->block_inverted_page_table[index].ipt_valid == 1)
            {
                page_used = TRUE;
                *no_valid_blocks = FALSE;
            }
        }

        if(!page_used)
        {
            /* PMC_LOG_TRACE("cpb crash restart - cpb_audit_block_ctxt_reg_clean: page is unused");*/
            cpb_page_table_cfg(cpb_handle,
                               i,
                               FALSE,
                               0,
                               0,
                               0);
            register_var_ptr->page_inverted_page_table[i].ctrl_page_valid = 0;
            register_var_ptr->page_inverted_page_table[i].ctrl_ipt_qs_id = 0;
            register_var_ptr->page_inverted_page_table[i].ctrl_ipt_wp_id = 0;
        }
    }

    PMC_RETURN(result);

} /* cpb_audit_block_ctxt_reg_clean */

/*******************************************************************************
* cpb_audit_dcs_ctxt_reg_clean
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function will ensure DCS online and offline pages are coherent and
*   the DCS contains entries for the union of same value set entries recovered
*   from register space and present in the context.\n\n
*
*   When complete the cpb_handle->var data associated with DCS online and
*   offline pages is coherent and existing operations for updating the
*   scheduler will operate as required.
*
*
* INPUTS:
*   *cpb_handle          - pointer to cpb handle instance
*   *ctxt_var_ptr        - pointer to Context view of device configuration
*   *register_var_ptr    - pointer to register space recovered view of context
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_audit_dcs_ctxt_reg_clean(cpb_handle_t *cpb_handle,
                                               cpb_var_t *ctxt_var_ptr,
                                               cpb_var_t *register_var_ptr)
{

    UINT32 i, j;
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();

    for(i = 0; i < cpb_handle->cfg.num_dcs; i++)
    {
        /* Confirm DCS Enable State matches */
        if(ctxt_var_ptr->dcs_inst_init_flag[i] !=  register_var_ptr->dcs_inst_init_flag[i])
        {
            /* Disable the DCS and set ctxt to indicate disabled */
            result = cpb_dcs_enable(cpb_handle, i, 0);
            ctxt_var_ptr->dcs_inst_init_flag[i] = 0;
            register_var_ptr->dcs_inst_init_flag[i] = 0;

        }

        /* If DCS enabled, compare contents */
        if(ctxt_var_ptr->dcs_inst_init_flag[i] == 1)
        {
            for(j = 0; j < cpb_num_calendar_entries_get(cpb_handle,i); j++)
            {
                /* write offline DCS page to match online DCS page */
                if(register_var_ptr->dcs_online_calendars[i][j].c_ram_sf1 != register_var_ptr->dcs_offline_calendars[i][j].c_ram_sf1 ||
                   (cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB && register_var_ptr->dcs_online_calendars[i][j].c_ram_sf2 != register_var_ptr->dcs_offline_calendars[i][j].c_ram_sf2) ||
                   register_var_ptr->dcs_online_calendars[i][j].c_ram_channel != register_var_ptr->dcs_offline_calendars[i][j].c_ram_channel ||
                   register_var_ptr->dcs_online_calendars[i][j].c_ram_identifier != register_var_ptr->dcs_offline_calendars[i][j].c_ram_identifier)
                {
                    register_var_ptr->dcs_offline_calendars[i][j].c_ram_sf1        = register_var_ptr->dcs_online_calendars[i][j].c_ram_sf1;
                    register_var_ptr->dcs_offline_calendars[i][j].c_ram_sf2        = register_var_ptr->dcs_online_calendars[i][j].c_ram_sf2;
                    register_var_ptr->dcs_offline_calendars[i][j].c_ram_channel    = register_var_ptr->dcs_online_calendars[i][j].c_ram_channel;
                    register_var_ptr->dcs_offline_calendars[i][j].c_ram_identifier = register_var_ptr->dcs_online_calendars[i][j].c_ram_identifier;

                    PMC_LOG_TRACE("cpb crash restart - cpb_audit_dcs_ctxt_reg_clean: register online page didn't match offline page\n");
                    result = cpb_dcs_wrr_entry_set(cpb_handle, i, j,
                                                   register_var_ptr->dcs_online_calendars[i][j].c_ram_sf1,
                                                   register_var_ptr->dcs_online_calendars[i][j].c_ram_sf2,
                                                   register_var_ptr->dcs_online_calendars[i][j].c_ram_channel,
                                                   register_var_ptr->dcs_online_calendars[i][j].c_ram_identifier);
                }
            }

            for(j = 0; j < cpb_num_calendar_entries_get(cpb_handle,i); j++)
            {

                /* if there is a difference with ctxt online page set the entry to NULL usage */
                if(ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_sf1 != register_var_ptr->dcs_offline_calendars[i][j].c_ram_sf1 ||
                   (ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_sf2 != register_var_ptr->dcs_offline_calendars[i][j].c_ram_sf2) ||
                   ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_channel != register_var_ptr->dcs_offline_calendars[i][j].c_ram_channel ||
                   ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_identifier != register_var_ptr->dcs_offline_calendars[i][j].c_ram_identifier)
                {
                    register_var_ptr->dcs_offline_calendars[i][j].c_ram_sf1        = 0;
                    register_var_ptr->dcs_offline_calendars[i][j].c_ram_sf2        = 0;
                    register_var_ptr->dcs_offline_calendars[i][j].c_ram_channel    = 0;
                    register_var_ptr->dcs_offline_calendars[i][j].c_ram_identifier = 0x7F;

                    PMC_LOG_TRACE("cpb crash restart - cpb_audit_dcs_ctxt_reg_clean: register online page didn't match context, before swap, push_port: %u, pop_port : %u, wid: %u, rid: %u\n",
                    register_var_ptr->dcs_online_calendars[i][j].c_ram_sf1,
                    i,
                    register_var_ptr->dcs_online_calendars[i][j].c_ram_sf2,
                    register_var_ptr->dcs_online_calendars[i][j].c_ram_identifier);

                    result = cpb_dcs_wrr_entry_set(cpb_handle, i, j, 0, 0, 0, 0x7F);
                }
            }

            /* swap page */
            cpb_dcs_page_swap(cpb_handle, i);

            /* Poll for page swap success */
            result = cpb_dcs_poll_swap_success(cpb_handle, i);
            PMC_ASSERT(result==PMC_SUCCESS, CPB_ERR_CODE_ASSERT, 0, 0);

            for(j = 0; j < cpb_num_calendar_entries_get(cpb_handle,i); j++)
            {
                /* if there is a difference with ctxt online page set the entry to NULL usage */
                if(ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_sf1 != register_var_ptr->dcs_online_calendars[i][j].c_ram_sf1 ||
                   (cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB && ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_sf2 != register_var_ptr->dcs_online_calendars[i][j].c_ram_sf2) ||
                   ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_channel != register_var_ptr->dcs_online_calendars[i][j].c_ram_channel ||
                   ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_identifier != register_var_ptr->dcs_online_calendars[i][j].c_ram_identifier)
                {
                    register_var_ptr->dcs_online_calendars[i][j].c_ram_sf1        = 0;
                    register_var_ptr->dcs_online_calendars[i][j].c_ram_sf2        = 0;
                    register_var_ptr->dcs_online_calendars[i][j].c_ram_channel    = 0;
                    register_var_ptr->dcs_online_calendars[i][j].c_ram_identifier = 0x7F;

                    PMC_LOG_TRACE("cpb crash restart - cpb_audit_dcs_ctxt_reg_clean: register online page didn't match context, after swap, push_port: %u, pop_port : %u, wid: %u, rid: %u\n",
                    register_var_ptr->dcs_online_calendars[i][j].c_ram_sf1,
                    i,
                    register_var_ptr->dcs_online_calendars[i][j].c_ram_sf2,
                    register_var_ptr->dcs_online_calendars[i][j].c_ram_identifier);

                    result = cpb_dcs_wrr_entry_set(cpb_handle, i, j, 0, 0, 0, 0x7F);
                }

                /* online and offline DCS register space match and represent the union of
                   overlap between ctxt and register space */
            }

            /* Copy register space to context */
            for(j = 0; j < cpb_num_calendar_entries_get(cpb_handle,i); j++)
            {
                ctxt_var_ptr->dcs_offline_calendars[i][j].c_ram_sf1        = register_var_ptr->dcs_online_calendars[i][j].c_ram_sf1;
                ctxt_var_ptr->dcs_offline_calendars[i][j].c_ram_sf2        = register_var_ptr->dcs_online_calendars[i][j].c_ram_sf2;
                ctxt_var_ptr->dcs_offline_calendars[i][j].c_ram_channel    = register_var_ptr->dcs_online_calendars[i][j].c_ram_channel;
                ctxt_var_ptr->dcs_offline_calendars[i][j].c_ram_identifier = register_var_ptr->dcs_online_calendars[i][j].c_ram_identifier;

                ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_sf1        = register_var_ptr->dcs_online_calendars[i][j].c_ram_sf1;
                ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_sf2        = register_var_ptr->dcs_online_calendars[i][j].c_ram_sf2;
                ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_channel    = register_var_ptr->dcs_online_calendars[i][j].c_ram_channel;
                ctxt_var_ptr->dcs_online_calendars[i][j].c_ram_identifier = register_var_ptr->dcs_online_calendars[i][j].c_ram_identifier;
            }
        }
    }

    PMC_RETURN(result);

} /* cpb_audit_dcs_ctxt_reg_clean */

/*******************************************************************************
* cpb_audit_dcs_util_schd_clean
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function compares util_schd and DCS to ensure the union of entries
*   are present.  \n\n
*
*   In the case a DCS entry does not exist but util_schd state
*   is not start state, the util_schd will be brought back to start state and
*   the associated QSn_CH_EN bit and associated context will be brought back
*   to start state.\n\n
*
*   In the case the DCS entry is present but the util_schd state is START,
*   the DCS entry will be removed. \n\n
*
*   When completed the DCS will match util_schd and QSn_CH_EN settings.
*
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance
*   *register_var_ptr           - pointer to register var data.  The DCS
*                                 data will be used as a scratch pad for
*                                 comparison within this API, it will be
*                                 corrupted moving forward.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_audit_dcs_util_schd_clean(cpb_handle_t *cpb_handle,
                                                cpb_var_t *register_var_ptr)
{

    UINT32 i, j;
    UINT32 dist_entries[96];
    BOOL8 calendar_used;

    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();

    /* this function assumes the online and offline DCS calendar data matches */
    for(i = 0; i < cpb_handle->cfg.num_dcs; i++)
    {
        /* If DCS enabled, compare contents */
        if(register_var_ptr->dcs_inst_init_flag[i] == 1)
        {
            /* recover data for util_schd and compare with the DCS offline context */
            util_schd_group_dist_gen(cpb_handle->util_schd_handle[i], 0,
                                     cpb_handle->util_schd_handle[i]->cfg.block_ctxt.max_entries,
                                     dist_entries);
            util_schd_dcs_format_gen(cpb_handle->util_schd_handle[i],
                                     cpb_handle->util_schd_handle[i]->cfg.block_ctxt.max_entries,
                                     dist_entries,
                                     register_var_ptr->dcs_offline_calendars[i]);

            for(j = 0; j < cpb_num_calendar_entries_get(cpb_handle,i); j++)
            {
                /* set mismatched entries back to START state in util_schd */
                if(register_var_ptr->dcs_offline_calendars[i][j].c_ram_sf1 != cpb_handle->var.dcs_offline_calendars[i][j].c_ram_sf1 ||
                   register_var_ptr->dcs_offline_calendars[i][j].c_ram_sf2 != cpb_handle->var.dcs_offline_calendars[i][j].c_ram_sf2 ||
                   register_var_ptr->dcs_offline_calendars[i][j].c_ram_channel != cpb_handle->var.dcs_offline_calendars[i][j].c_ram_channel ||
                   register_var_ptr->dcs_offline_calendars[i][j].c_ram_identifier != cpb_handle->var.dcs_offline_calendars[i][j].c_ram_identifier)
                {
                    /* register_var_ptr offline page was generated using data in util_schd. If an entry in this util_schd
                     * generated page doesn't match an entry in the existing register calendar then either 1) util_schd has a
                     * channel that the DCS doesn't, or 2) util_schd has a channel with the wrong number of entries. Either way,
                     * set the channel back to start. */
                    PMC_LOG_TRACE("cpb crash restart - cpb_audit_dcs_util_schd_clean: setting util_schd channel back to START state, util_schd: pop_port: %u, rid: %u, DCS calendar: pop_port: %u, rid: %u\n",
                    i,
                    register_var_ptr->dcs_offline_calendars[i][j].c_ram_identifier,
                    i,
                    cpb_handle->var.dcs_offline_calendars[i][j].c_ram_identifier);

                    /* PMC_LOG_TRACE("cpb crash restart - cpb_audit_dcs_util_schd_clean: result: %u, chnl_state: %u\n",(UINT32)result,(UINT32)cpb_handle->util_schd_handle[i]->var.schd_ctxt->chnl_ctxt[j].state);*/

                    /*If either of the values compared are valid read ids, they must be set back to start state */
                    if(register_var_ptr->dcs_offline_calendars[i][j].c_ram_identifier < cpb_handle->util_schd_handle[i]->cfg.block_ctxt.num_schd_chnl && result == PMC_SUCCESS)
                        result = util_schd_chnl_state_set(cpb_handle->util_schd_handle[i],
                                                      register_var_ptr->dcs_offline_calendars[i][j].c_ram_identifier,
                                                          UTIL_SCHD_CHNL_START);

                    if(cpb_handle->var.dcs_offline_calendars[i][j].c_ram_identifier < cpb_handle->util_schd_handle[i]->cfg.block_ctxt.num_schd_chnl && result == PMC_SUCCESS)
                        result = util_schd_chnl_state_set(cpb_handle->util_schd_handle[i],
                                                      cpb_handle->var.dcs_offline_calendars[i][j].c_ram_identifier,
                                                      UTIL_SCHD_CHNL_START);

                    /* PMC_LOG_TRACE("cpb crash restart - cpb_audit_dcs_util_schd_clean: result: %u, chnl_state: %u\n",(UINT32)result,(UINT32)cpb_handle->util_schd_handle[i]->var.schd_ctxt->chnl_ctxt[j].state);*/
                }
            }
            /* regenerate the util_schd and apply to DCS online and offline pages - in the
               event that DCS contained channels that were not in util_schd they will have
               been silently removed. */
            if(result == PMC_SUCCESS)
                result = cpb_dcs_page_update_and_swap(cpb_handle, i);

            /*If all calendar entries were removed in a DCS, disable the DCS */
            calendar_used = FALSE;
            for(j = 0; j < cpb_num_calendar_entries_get(cpb_handle,i); j++)
            {
                if(cpb_handle->var.dcs_online_calendars[i][j].c_ram_identifier != DCS_NULL_QUEUE_ID)
                {
                    calendar_used = TRUE;
                    break;
                }
            }
            /*
             * Reset only if the calendar is not used and the index is
             * greater than one or dcpb_em_sifd1_sel values are not one
             * for the corresponding index.
             * That is if the DCS has been started for indiex 0 or 1
             * (SIFD1 or SIFD2) then do not turn if off simply because none
             * of the calendars are being used.
             * Ditto for the ODUKSW, with except for port 0 in SYSOTN mode which
             * connects to CTL instead of SIFD1.
             */
            if (!calendar_used &&
                (i > 1 ||
                 ((i == 0 && cpb_handle->var.dcpb_em_sifd1_sel == 0 && cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB) ||
                  (i == 1 && cpb_handle->var.dcpb_em_sifd2_sel == 0 && cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB) ||
                  (i == 0 && cpb_handle->cfg.sysotn_mode == TRUE && cpb_handle->cfg.cpb_type == CPB_INSTANCE_OCPB) ||
                  (cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB))))
            {
                cpb_dcs_enable(cpb_handle, i, 0);
                cpb_handle->var.dcs_inst_init_flag[i] = 0;
            }
        } /* end if DCS init */
    } /* end for i */

    PMC_RETURN(result);

} /* cpb_audit_dcs_util_schd_clean */

/*******************************************************************************
* cpb_audit_fifo_ctxt_reg_clean
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function ensures the fifo_var context and register structures are
*   coherent by reducing the configuration to the union of the two.
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance
*   *ctxt_var_ptr               - pointer to register space recovered view of context
*   *register_var_ptr           - pointer to register space recovered view of context
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_audit_fifo_ctxt_reg_clean(cpb_handle_t *cpb_handle,
                                               cpb_var_t *ctxt_var_ptr,
                                               cpb_var_t *register_var_ptr)
{
    UINT32 i, j;
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 queue_index;

    PMC_ENTRY();

    /* update register_var_ptr for fifo_var_data to be union with identified FIFO in cpb_handle->var.fifo_var_data... */
    for(i = 0; i < cpb_handle->cfg.num_queue_systems; i++) /* i is the DCS number */
    {
        for(j = 0; j < cpb_num_sched_chans_get(cpb_handle,i); j++) /* j is the read queue id */
        {

            queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, i, j);

            /* comparte .push_port_id and .write_id */
            if(cpb_handle->var.fifo_var_data[queue_index].status       != register_var_ptr->fifo_var_data[queue_index].status ||
               cpb_handle->var.fifo_var_data[queue_index].push_port_id != register_var_ptr->fifo_var_data[queue_index].push_port_id ||
               cpb_handle->var.fifo_var_data[queue_index].write_id     != register_var_ptr->fifo_var_data[queue_index].write_id)
            {

                PMC_LOG_TRACE("cpb crash restart - cpb_audit_fifo_ctxt_reg_clean: clearing fifo_var entry, push_port: %u, wid: %u, pop_port: %u, rid: %u, chnl_type: %u\n",
                register_var_ptr->fifo_var_data[queue_index].push_port_id,
                register_var_ptr->fifo_var_data[queue_index].write_id,
                i,
                j,
                (UINT32)register_var_ptr->fifo_var_data[queue_index].chnl_type);

                register_var_ptr->fifo_var_data[queue_index].status = CPB_FIFO_NOT_USED;
                register_var_ptr->fifo_var_data[queue_index].write_id = CPB_BLOCK_WQID_NIL;
                register_var_ptr->fifo_var_data[queue_index].push_port_id = CPB_FIFO_PUSHID_NIL;
                register_var_ptr->fifo_var_data[queue_index].chnl_type = CPB_FIFO_INVALID_CH;
                register_var_ptr->fifo_var_data[queue_index].fifo_end_addr = 0;

                /* if (CPB_INSTANCE_MCPB != cpb_handle->cfg.cpb_type) */
                {
                    cpb_handle->var.fifo_var_data[queue_index].status = CPB_FIFO_NOT_USED;
                    cpb_handle->var.fifo_var_data[queue_index].write_id = CPB_BLOCK_WQID_NIL;
                    cpb_handle->var.fifo_var_data[queue_index].push_port_id = CPB_FIFO_PUSHID_NIL;
                    cpb_handle->var.fifo_var_data[queue_index].chnl_type = CPB_FIFO_INVALID_CH;
                    cpb_handle->var.fifo_var_data[queue_index].fifo_end_addr = 0;
                }
            }
            /* if these fields match, then it will be assumed that fifo_end_addr is equivalent to the number of
               blocks in the PMPM block FIFO. */
        } /* end for j max_fifo_num */
    } /* end for i queue systems */


    PMC_RETURN(result);
} /* cpb_audit_fifo_ctxt_reg_clean */

/*******************************************************************************
* cpb_audit_fifo_var_slv_ch_en_clean
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function clears slave channel enable bits based on fifo_var
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance
*   *register_var_ptr           - pointer to register space recovered view of context
*   *slv_data_ptr               - pointer to register recovered DPI slave port
*                                 channel data

*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_audit_fifo_var_slv_ch_en_clean(cpb_handle_t *cpb_handle,
                                                     cpb_var_t *register_var_ptr,
                                                     cpb_slv_data_t *slv_data_ptr)
{
    UINT32 i, j, k, index, dcs_rd_channel_id, dcs_sf1_push_port_id,
    dcs_sf2_wr_queue_id;
    util_schd_chnl_state_t chnl_state;
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 k2;
    PMC_ENTRY();

    /* Loop through QSn_CH_EN and make sure there is a corresponding fifo_var
     * entry */
    for(i = 0; i <= cpb_handle->cfg.max_slv_dpi_port; i++)
    {
        for(j = 0; j <= cpb_handle->cfg.max_dpi_slv_chnl_id[i]; j++)
        {
            for(k = 0; k < 4; k++) /* per queue system / pop port id */
            {
                if(slv_data_ptr->slv_data[i][j].qs_ch_en[k] == 1)
                {
                    /* if operational check the mapping context available from
                       data in util_schd for coherency */
                    result = util_schd_dcs_chnl_data_get(cpb_handle->util_schd_handle[k],
                                                         slv_data_ptr->slv_data[i][j].qs_pop_qid[k],
                                                         &chnl_state,
                                                         &dcs_rd_channel_id,
                                                         &dcs_sf1_push_port_id,
                                                         &dcs_sf2_wr_queue_id);

                    if (PMC_SUCCESS != result)
                    {
                        continue;
                    }

                    index =  cpb_fifo_var_data_queue_index_get(cpb_handle, k, slv_data_ptr->slv_data[i][j].qs_pop_qid[k]);

                    /* if fifo not used, try QS 3 to process MGMT FEGE port exception  */
                    if (register_var_ptr->fifo_var_data[index].status != CPB_FIFO_BEING_USED &&
                        cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB &&
                        k == CPB_MCPB_POP_PORT_2)
                    {
                        k2 = CPB_MCPB_POP_PORT_3;
                        result = util_schd_dcs_chnl_data_get(cpb_handle->util_schd_handle[k2],
                                                             slv_data_ptr->slv_data[i][j].qs_pop_qid[k],
                                                             &chnl_state,
                                                             &dcs_rd_channel_id,
                                                             &dcs_sf1_push_port_id,
                                                             &dcs_sf2_wr_queue_id);

                        index =  cpb_fifo_var_data_queue_index_get(cpb_handle, k2, slv_data_ptr->slv_data[i][j].qs_pop_qid[k]);
                    }

                    /* if fifo not used, try alternate ingress port */
                    if (register_var_ptr->fifo_var_data[index].status != CPB_FIFO_BEING_USED &&
                        cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB && j > 0)
                    {
                        k2 = 255;
                        if(MCPB_FEGE_PORT_NUM == i)
                        {
                            k2 = MCPB_CPU_PORT_NUM;
                        }
                        else if (MCPB_CPU_PORT_NUM == i)
                        {
                            k2 = MCPB_FEGE_PORT_NUM;
                        }

                        if (255 != k2)
                        {
                            result = util_schd_dcs_chnl_data_get(cpb_handle->util_schd_handle[k],
                                                                 slv_data_ptr->slv_data[k2][j-1].qs_pop_qid[k],
                                                                 &chnl_state,
                                                                 &dcs_rd_channel_id,
                                                                 &dcs_sf1_push_port_id,
                                                                 &dcs_sf2_wr_queue_id);

                            index =  cpb_fifo_var_data_queue_index_get(cpb_handle, k, slv_data_ptr->slv_data[k2][j-1].qs_pop_qid[k]);
                        }

                    }


                    /* Note: This should not be a secondary channel because
                     * read queue ID is set in the slave registers */
                    if( PMC_SUCCESS == result &&
                        ((register_var_ptr->fifo_var_data[index].status != CPB_FIFO_BEING_USED) ||
                        ((cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB &&
                          register_var_ptr->fifo_var_data[index].write_id != dcs_sf2_wr_queue_id)) ||
                        (register_var_ptr->fifo_var_data[index].push_port_id != dcs_sf1_push_port_id) ||
                         (register_var_ptr->fifo_var_data[index].chnl_type == CPB_FIFO_SECONDARY_CH)  ))
                    {
                         /* check if the DCS is in alternate queue mode, if yes, only accept even rd queue id */
                        if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && k < CPB_MCPB_POP_PORT_2 && 1 == (index & 0x0001))
                        {                            
                            continue;    
                        }
                        

                        PMC_LOG_TRACE("cpb crash restart - cpb_audit_fifo_var_slv_ch_en_clean: clearing qs_ch_en, slave port: %u, slave channel: %u, queue system: %u\n",i,j,k);
                        slv_data_ptr->slv_data[i][j].qs_ch_en[k] = 0;
                        cpb_dpi_slave_port_chnl_enbl(cpb_handle, i, j, k, 0);
                        cpb_pmon_chnl_add_drop_cfg(cpb_handle, i, j, k, 0);


#ifndef CPB_UNIT_TEST
                        cpb_fw_slv_dpi_qs_ch_en_clear(cpb_handle,i,j,k);
#endif
                    }
                }
            }
        }
    }
    PMC_RETURN(result);
} /* cpb_audit_fifo_var_slv_ch_en_clean */

/*******************************************************************************
* cpb_audit_slv_ch_en_fifo_var_clean
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function invalidates fifo_var entries based on slave channel enable.
*
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance
*   *register_var_ptr           - pointer to register space recovered view of context
*   *slv_data_ptr               - pointer to register recovered DPI slave port
*                                 channel data
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_audit_slv_ch_en_fifo_var_clean(cpb_handle_t *cpb_handle,
                                                     cpb_var_t *register_var_ptr,
                                                     cpb_slv_data_t *slv_data_ptr)
{
    UINT32 i, j, slave_port, slave_channel;
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 queue_index;

    PMC_ENTRY();


    /* Loop through fifo_var and make sure slave zone primaries reader primaries and secondary channels
     * have corresponding QSn_CH_EN entries. Here's how to handle various channel types
                                            QSn_CH_MST
    CPB_FIFO_INVALID_CH       = 0,           0          QSn_CH_EN is set to 0
    CPB_FIFO_SECONDARY_CH     = 1,           X          rd_qid not matching the QSn_POP_QID
    CPB_SLAVE_ZONE_PRIMARY    = 2,           1          rd_qid matches the QSn_POP_QID
    CPB_READER_PRIMARY        = 3,           0          rd_qid matches the QSn_POP_QID
    */

    for(i = 0; i < cpb_handle->cfg.num_dcs; i++)
    {
        for(j = 0; j < cpb_num_sched_chans_get(cpb_handle,i); j++) /* search for the number of read queue id in queue system */
        {
            queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, i, j);

            if(register_var_ptr->fifo_var_data[queue_index].status == CPB_FIFO_BEING_USED)
            {
                if(cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB)
                {
                    cpb_ingress_mux_port_chnl_get(cpb_handle,
                                                  register_var_ptr->fifo_var_data[queue_index].push_port_id,
                                                  register_var_ptr->fifo_var_data[queue_index].write_id,
                                                  &slave_port,
                                                  &slave_channel);
                }
                else
                {
                    cpb_mcpb_ingress_mux_port_chnl_get(cpb_handle,
                                                       register_var_ptr->fifo_var_data[queue_index].push_port_id,
                                                       register_var_ptr->fifo_var_data[queue_index].write_id,
                                                       i, /* pop port id equivalent to DCS instance */
                                                       &slave_port,
                                                       &slave_channel);
                }

                if(register_var_ptr->fifo_var_data[queue_index].chnl_type == CPB_SLAVE_ZONE_PRIMARY)
                {
                    if( (slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_en[i] != 1 &&
                         cpb_handle->util_schd_handle[i]->var.schd_ctxt->chnl_ctxt[j].state != UTIL_SCHD_CHNL_BACKUP) ||
                        (slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_mst[i] != 1) ||
                        (slv_data_ptr->slv_data[slave_port][slave_channel].qs_pop_qid[i] != j) )
                    {
                        PMC_LOG_TRACE("cpb crash restart - cpb_audit_slv_ch_en_fifo_var_clean: setting fifo_var to not used");
                        register_var_ptr->fifo_var_data[queue_index].status = CPB_FIFO_NOT_USED;
                        cpb_handle->var.fifo_var_data[queue_index].status = CPB_FIFO_NOT_USED;

                        cpb_fifo_reset_cfg(cpb_handle,
                                           register_var_ptr->fifo_var_data[queue_index].push_port_id,
                                           i,
                                           TRUE,
                                           register_var_ptr->fifo_var_data[queue_index].write_id,
                                           j,
                                           1);
                    }
                }
                else if (register_var_ptr->fifo_var_data[queue_index].chnl_type == CPB_READER_PRIMARY)
                {
                    if( (slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_en[i] != 1) ||
                        (slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_mst[i] != 0) ||
                        (slv_data_ptr->slv_data[slave_port][slave_channel].qs_pop_qid[i] != j) )
                    {
                        PMC_LOG_TRACE("cpb crash restart - cpb_audit_slv_ch_en_fifo_var_clean: setting fifo_var to not used");
                        register_var_ptr->fifo_var_data[queue_index].status = CPB_FIFO_NOT_USED;
                        cpb_handle->var.fifo_var_data[queue_index].status = CPB_FIFO_NOT_USED;

                        cpb_fifo_reset_cfg(cpb_handle,
                                           register_var_ptr->fifo_var_data[queue_index].push_port_id,
                                           i,
                                           TRUE,
                                           register_var_ptr->fifo_var_data[queue_index].write_id,
                                           j,
                                           1);

                    }
                }
                else if (register_var_ptr->fifo_var_data[queue_index].chnl_type == CPB_FIFO_SECONDARY_CH)
                {
                    if( (slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_en[i] != 1) ||
                        (slv_data_ptr->slv_data[slave_port][slave_channel].qs_ch_mst[i] != 0) ||
                        (slv_data_ptr->slv_data[slave_port][slave_channel].qs_pop_qid[i] == j) )
                    {
                        PMC_LOG_TRACE("cpb crash restart - cpb_audit_slv_ch_en_fifo_var_clean: setting fifo_var to not used");
                        register_var_ptr->fifo_var_data[queue_index].status = CPB_FIFO_NOT_USED;
                        cpb_handle->var.fifo_var_data[queue_index].status = CPB_FIFO_NOT_USED;

                        cpb_fifo_reset_cfg(cpb_handle,
                                           register_var_ptr->fifo_var_data[queue_index].push_port_id,
                                           i,
                                           TRUE,
                                           register_var_ptr->fifo_var_data[queue_index].write_id,
                                           j,
                                           1);

                    }

                }
            }
        } /* end for j */
    } /* end for i */

    PMC_RETURN(result);
} /* cpb_audit_slv_ch_en_fifo_var_clean */

/*******************************************************************************
* cpb_audit_util_schd_fifo_var_clean
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function invalidates fifo_var entries based on util_schd.
*
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance
*   *register_var_ptr           - pointer to register space recovered view of context
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_audit_util_schd_fifo_var_clean(cpb_handle_t *cpb_handle,
                                                     cpb_var_t *register_var_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ERROR rc;
    PMC_ENTRY();
    UINT32 i, j, index, dcs_rd_channel_id, dcs_sf1_push_port_id, dcs_sf2_wr_queue_id;
    util_schd_chnl_state_t chnl_state;

    for(i = 0; i < cpb_handle->cfg.num_dcs; i++)
    {
        for(j = 0; j < cpb_num_sched_chans_get(cpb_handle,i); j++) /* search for the number of read queue id in queue system */
        {
            index = cpb_fifo_var_data_queue_index_get(cpb_handle, i, j);
            if(register_var_ptr->fifo_var_data[index].status == CPB_FIFO_BEING_USED)
            {
                UINT32 alt_queue_mod = 0;
                /* For an alternate queue MCPB util_schd data is stored for read qid - 1 */
                if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && 
                   i < 2 &&
                   (j%2 == 1))
                   alt_queue_mod = 1;
                rc = util_schd_dcs_chnl_data_get(cpb_handle->util_schd_handle[i],
                                                     j-alt_queue_mod,
                                                     &chnl_state,
                                                     &dcs_rd_channel_id,
                                                     &dcs_sf1_push_port_id,
                                                     &dcs_sf2_wr_queue_id);

                if(PMC_SUCCESS == rc && !(chnl_state == UTIL_SCHD_CHNL_OPERATIONAL || chnl_state == UTIL_SCHD_CHNL_BACKUP))
                {
                    PMC_LOG_TRACE("cpb crash restart - cpb_audit_util_schd_fifo_var_clean: setting fifo_var to not used. pop_port: %u, rid: %u\n",
                    i,
                    j);
                    register_var_ptr->fifo_var_data[index].status = CPB_FIFO_NOT_USED;
                    cpb_handle->var.fifo_var_data[index].status = CPB_FIFO_NOT_USED;
                    {
                        cpb_fifo_reset_cfg(cpb_handle,
                                           dcs_sf1_push_port_id,
                                           i,
                                           TRUE,
                                           dcs_sf2_wr_queue_id,
                                           j,
                                           1);
                    }

                }
            }
        }
    }

    PMC_RETURN(result);
} /*cpb_audit_util_schd_fifo_var_clean*/

/*******************************************************************************
* cpb_audit_blocks_fifo_var_clean
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function invalidates fifo_var entries based on the page and block
*   table.
*
*
* INPUTS:
*   *cpb_handle                 - pointer to cpb handle instance
*   *register_var_ptr           - pointer to register space recovered view of context
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_audit_blocks_fifo_var_clean(cpb_handle_t *cpb_handle,
                                                  cpb_var_t *register_var_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();
    UINT32 i, j, index, x, y, block_index;
    BOOL8 block_found = FALSE;

    for(i = 0; i < cpb_handle->cfg.num_dcs; i++)
    {
        for(j = 0; j < cpb_num_sched_chans_get(cpb_handle,i); j++) /* search for the number of read queue id in queue system */
        {
            index = cpb_fifo_var_data_queue_index_get(cpb_handle, i, j);
            if(register_var_ptr->fifo_var_data[index].status == CPB_FIFO_BEING_USED)
            {
                /* Make sure there's at least one block allocated for this
                 * FIFO */
                block_found = FALSE;
                for( x = 0; x < cpb_handle->cfg.num_pages && block_found != TRUE; x++)
                {
                    if(register_var_ptr->page_inverted_page_table[x].ctrl_page_valid == 1)
                    {
                        /*PMC_LOG_TRACE("cpb crash restart - cpb_audit_blocks_fifo_var_clean: found valid page");*/
                        for(y = 0; y < cpb_handle->cfg.blocks_per_page; y++)
                        {
                            block_index = x * cpb_handle->cfg.blocks_per_page + y;
                            if(register_var_ptr->page_inverted_page_table[x].ctrl_ipt_wp_id == register_var_ptr->fifo_var_data[index].push_port_id &&
                               ((CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && i == cpb_handle->var.page_inverted_page_table[x].mfege_ctrl_ipt_qs_id)
                                || (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && i == 3 && 2 == cpb_handle->var.page_inverted_page_table[x].mfege_ctrl_ipt_qs_id) 
                                || (register_var_ptr->page_inverted_page_table[x].ctrl_ipt_qs_id == i)) &&
                               register_var_ptr->block_inverted_page_table[block_index].ipt_wqid == register_var_ptr->fifo_var_data[index].write_id )
                            {
                                block_found = TRUE;
                                break;
                            }
                        }
                    }
                } /* end for x */

                if(!block_found)
                {
                    PMC_LOG_TRACE("cpb crash restart - cpb_audit_blocks_fifo_var_clean: setting fifo_var to not used");
                    register_var_ptr->fifo_var_data[index].status = CPB_FIFO_NOT_USED;
                    cpb_handle->var.fifo_var_data[index].status = CPB_FIFO_NOT_USED;

                    cpb_fifo_reset_cfg(cpb_handle,
                                       register_var_ptr->fifo_var_data[index].push_port_id,
                                       i,
                                       TRUE,
                                       register_var_ptr->fifo_var_data[index].write_id,
                                       j,
                                       1);
                }
            } /* end if fifo state is used */
        } /* end for j */
    } /* end for i */

    PMC_RETURN(result);
} /*cpb_audit_blocks_fifo_var_clean */

/*******************************************************************************
* cpb_audit_fifo_var_util_schd_clean
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function sets util_schd channel states to START based on fifo_var.
*
*
* INPUTS:
*   *cpb_handle        - pointer to cpb handle instance
*   *register_var_ptr  - pointer to register space recovered view of context
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_audit_fifo_var_util_schd_clean(cpb_handle_t *cpb_handle,
                                                     cpb_var_t *register_var_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();
    UINT32 i,j,dcs_rd_channel_id, dcs_sf1_push_port_id, dcs_sf2_wr_queue_id, index;
    util_schd_chnl_state_t chnl_state;

    for(i = 0; i < cpb_handle->cfg.num_dcs; i++)
    {
        for(j = 0; j < cpb_num_sched_chans_get(cpb_handle,i); j++)
        {
            result = util_schd_dcs_chnl_data_get(cpb_handle->util_schd_handle[i],
                                             j,
                                             &chnl_state,
                                             &dcs_rd_channel_id,
                                             &dcs_sf1_push_port_id,
                                             &dcs_sf2_wr_queue_id);
            /* If this channel is operational in util_schd but not in
             * fifo_var, set it back to start state in util_schd. */
            if(result == PMC_SUCCESS &&
               (chnl_state == UTIL_SCHD_CHNL_OPERATIONAL || chnl_state == UTIL_SCHD_CHNL_EQUIPPED))
            {
                index = cpb_fifo_var_data_queue_index_get(cpb_handle, i, j);
                if(register_var_ptr->fifo_var_data[index].status != CPB_FIFO_BEING_USED)
                {
                    PMC_LOG_TRACE("cpb crash restart - cpb_audit_fifo_var_util_schd_clean: setting util_schd channel to START state, pop_port: %u, rid: %u\n",
                    i,
                    j);

                    util_schd_chnl_state_set(cpb_handle->util_schd_handle[i],
                                             j,
                                             UTIL_SCHD_CHNL_START);
                }

            }
        }
    }
    PMC_RETURN(result);
} /* cpb_audit_fifo_var_util_schd_clean */


/*
 *  Process Functions - End
 */

/*
 *  Computational Operation Functions - Start
 */


/*******************************************************************************
* cpb_port_burst_element_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function retrieves the sub components of the comingled cpb_xfer_mode_t.
*
*
* INPUTS:
*   cpb_xfer_mode      - enum, defining the comingled transfer data
*
* OUTPUTS:
*   *p_xfer_mode_type  - pointer to enum, of the transfer mode for the input
*   *p_burst_mode      - pointer to enum, of the burst mode for the input
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void cpb_port_burst_element_get(cpb_xfer_mode_t cpb_xfer_mode, cpb_xfer_mode_type_t *p_xfer_mode_type, cpb_burst_mode_t *p_burst_mode)
{
    PMC_ENTRY();

    /* extract transfer type and burst size settings from input arguments */
    switch (cpb_xfer_mode) {
        case CPB_SEGMENT: /*  Segment mode */
            *p_xfer_mode_type = CPB_XFER_MODE_TYPE_SEGMENT;
            *p_burst_mode = CPB_BURST_WORD;
            break;
        case CPB_PACKET: /*  Packet mode */
            *p_xfer_mode_type = CPB_XFER_MODE_TYPE_PACKET;
            *p_burst_mode = CPB_BURST_WORD;
            break;
        case CPB_SEGMENT_BURST_128: /* Segment burst mode, burst size = 128 bytes */
            *p_xfer_mode_type = CPB_XFER_MODE_TYPE_SEGMENT;
            *p_burst_mode = CPB_BURST_128;
            break;
        case CPB_SEGMENT_BURST_192: /* Segment burst mode, burst size = 192 bytes */
            *p_xfer_mode_type = CPB_XFER_MODE_TYPE_SEGMENT;
            *p_burst_mode = CPB_BURST_192;
            break;
        case CPB_SEGMENT_BURST_256: /* Segment burst mode, burst size = 256 bytes */
            *p_xfer_mode_type = CPB_XFER_MODE_TYPE_SEGMENT;
            *p_burst_mode = CPB_BURST_256;
            break;
        case CPB_PACKET_BURST_128: /* Packet burst mode, burst size = 128 bytes */
            *p_xfer_mode_type = CPB_XFER_MODE_TYPE_PACKET;
            *p_burst_mode = CPB_BURST_128;
            break;
        case CPB_PACKET_BURST_192: /* Packet burst mode, burst size = 192 bytes */
            *p_xfer_mode_type = CPB_XFER_MODE_TYPE_PACKET;
            *p_burst_mode = CPB_BURST_192;
            break;
        case CPB_PACKET_BURST_256: /* Packet burst mode, burst size = 256 bytes */
            *p_xfer_mode_type = CPB_XFER_MODE_TYPE_PACKET;
            *p_burst_mode = CPB_BURST_256;
            break;
        default:
            PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG, 0, 0);
    }

    PMC_RETURN();
} /* cpb_port_burst_element_get */

/*******************************************************************************
* cpb_var_t_ram_data_default_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function initializes var_t ram data to to hard coded settings contained
*   within this function.  These values represent the states of the block when
*   it is in a reset state.\n\n
*
*   var_t ram data is data used by SW driver that is not recoverable from device
*   registers.
*
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*   *var_ptr               - pointer to var data for a CPB handle, modifed by
*                            this API.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_var_t_ram_data_default_set(cpb_handle_t *cpb_handle, cpb_var_t *var_ptr)
{

    /* Variable declaration */
    UINT32 index, i, j;
    UINT32 queue_index;

    PMC_ENTRY();

    /* Argument checking */

    /* return success if p_backup is NULL */

    /* var_t initialization of fifo_var_data */
    for(i = 0; i< cpb_handle->cfg.num_queue_systems; i++){
        for(index = 0; index < cpb_num_sched_chans_get(cpb_handle,i); index++)
        {
            queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, i, index);
            var_ptr->fifo_var_data[queue_index].fifo_end_addr = (UINT32)0;
            var_ptr->fifo_var_data[queue_index].status = CPB_FIFO_NOT_USED;
            var_ptr->fifo_var_data[queue_index].write_id =
            (UINT32)CPB_BLOCK_WQID_NIL;
            var_ptr->fifo_var_data[queue_index].push_port_id =
            (UINT32)CPB_FIFO_PUSHID_NIL;
            var_ptr->fifo_var_data[queue_index].chnl_type =
            CPB_FIFO_INVALID_CH;
        }
    }

    /* default settings for the online and offline calendars */
    for(i = 0; i< cpb_handle->cfg.pop_port_num; i++){
        for(index = 0; index < cpb_num_calendar_entries_get(cpb_handle,i); index++)
        {
            var_ptr->dcs_offline_calendars[i][index].c_ram_sf1 = 0;
            var_ptr->dcs_offline_calendars[i][index].c_ram_sf2 = 0;
            var_ptr->dcs_offline_calendars[i][index].c_ram_channel = 0;
            var_ptr->dcs_offline_calendars[i][index].c_ram_identifier = 0; /* DCS_NULL_QUEUE_ID; */

            var_ptr->dcs_online_calendars[i][index].c_ram_sf1 = 0;
            var_ptr->dcs_online_calendars[i][index].c_ram_sf2 = 0;
            var_ptr->dcs_online_calendars[i][index].c_ram_channel = 0;
            var_ptr->dcs_online_calendars[i][index].c_ram_identifier = 0; /* DCS_NULL_QUEUE_ID; */
        }

    }

    /* default setting for SIFD port zone option settings */
    for(i=0; i < CPB_NUM_SIFD_INTF; i++)
    {
        for(j=0; j < CPB_NUM_SIFD_INTF; j++)
        {
            var_ptr->sifd_zone_bypass[i][j] = 0;
        }
    }

    /* default values for DPI slave/master and DCS instance initialization
       tracking */
    /* initialize all the port flags to be 0
        0 - not initialized/1 - initialized */
    for(i = 0; i < 8; i++)
    {
        var_ptr->slv_dpi_port_init_flag[i] = FALSE;
        var_ptr->mst_dpi_port_init_flag[i] = FALSE;
    }
    for(i = 0; i < DCPB_NUM_QUEUE_SYSTEMS; i++) { var_ptr->dcs_inst_init_flag[i] = FALSE;}

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_var_t_ram_data_default_set */

/* LCOV_EXCL_START */
/*******************************************************************************
* cpb_var_t_ram_data_pointer_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures the pointer for var_t ram data.  var_t ram data is
*   data used by SW driver that is not recoverable from device registers.
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   *p_backup             - pointer to backup memory
*   size                  - size of backup memory
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_var_t_ram_data_pointer_set(cpb_handle_t *cpb_handle,
                                                 void *p_backup,
                                                 UINT32 size)
{
    PMC_ENTRY();

    /* Recover backup storage var_t data */
    cpb_handle->var.p_var_t_ram_data = p_backup;
    PMC_CTXT_REGISTER_PTR(&cpb_handle->var.p_var_t_ram_data, cpb_handle);
    cpb_handle->var.var_t_ram_data_size = size;

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_var_t_ram_data_pointer_set */
/* LCOV_EXCL_STOP */

/*******************************************************************************
* cpb_var_t_ram_data_element_ptr_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function references var_t ram data element pointers to the common
*   p_var_t_ram_data identified memory block.
*
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void cpb_var_t_ram_data_element_ptr_cfg(cpb_handle_t *cpb_handle)
{
    UINT32 i;
    util_schd_dcs_calendar_entry_t * ptr;

    PMC_ENTRY();

    PMC_ASSERT(NULL != cpb_handle->var.p_var_t_ram_data, CPB_ERR_CTXT_NOT_INITIALIZED, 0 , 0);
    cpb_handle->var.fifo_var_data = (cpb_fifo_var_t *)(cpb_handle->var.p_var_t_ram_data);
    PMC_CTXT_REGISTER_PTR(&cpb_handle->var.fifo_var_data, cpb_handle);

    ptr = (util_schd_dcs_calendar_entry_t *)(cpb_handle->var.fifo_var_data + cpb_handle->cfg.num_queue_systems*cpb_handle->cfg.max_fifo_num);
    for(i = 0;i < cpb_handle->cfg.num_dcs; i++)
    {
        cpb_handle->var.dcs_offline_calendars[i] = ptr;
        PMC_CTXT_REGISTER_PTR(&cpb_handle->var.dcs_offline_calendars[i], cpb_handle);
        ptr = ptr + cpb_handle->cfg.num_calendar_entries;
    }
    for(i = 0;i < cpb_handle->cfg.num_dcs; i++)
    {
        cpb_handle->var.dcs_online_calendars[i] = ptr;
        PMC_CTXT_REGISTER_PTR(&cpb_handle->var.dcs_online_calendars[i], cpb_handle);
        ptr = ptr + cpb_handle->cfg.num_calendar_entries;
    }

    cpb_handle->var.dcs_temp_calendar = ptr;
    PMC_CTXT_REGISTER_PTR(&cpb_handle->var.dcs_temp_calendar, cpb_handle);

    PMC_RETURN();
} /* cpb_var_t_ram_data_element_ptr_cfg */


/*******************************************************************************
* cpb_dcs_egress_dpi_chnl_source_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function retrieves the source data for an outbound port and channel.
*
* INPUTS:
*
*   *cpb_handle                  -  pointer to the CPB handle instance
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*
*
*
* OUTPUTS:
*   *p_egress_mux_input_port     - egress mux input port associated with the
*                                  outbound data, 1:1 correlation with the
*                                  DCS instance
*   *p_rd_channel_id             - DCS RD_CHANNEL_ID used to direct data to
*                                  egress_mux port and DPI channel
*   *p_rd_queue_id               - DCS RD_IDENTIFIER_ID used to identify CFC
*                                  FIFO outbound channel data is originating
*                                  from.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_egress_dpi_chnl_source_get( cpb_handle_t *cpb_handle,
                                                     UINT32 egress_mux_output_port,
                                                     UINT32 egress_mux_output_port_chnl,
                                                     UINT32 *p_egress_mux_input_port,
                                                     UINT32 *p_rd_channel_id,
                                                     UINT32 *p_rd_queue_id )
{
    UINT32 sifd_sel = 0;
    UINT32 temp_rd_channel_id;
    UINT32 temp_rd_queue_id;
    UINT32 dcs_inst = 0;
    PMC_ERROR result = PMC_SUCCESS;

    UINT32 dcs_chnl_id;

    PMC_ENTRY();

    if(egress_mux_output_port > cpb_handle->cfg.max_mst_dpi_port)
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(egress_mux_output_port_chnl > cpb_handle->cfg.max_dpi_mst_chnl_id[egress_mux_output_port])
        PMC_RETURN(CPB_ERR_INVALID_ARG);


    switch (cpb_handle->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
            dcs_inst = cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.dcs_inst;
            if (dcs_inst == 0xFF) {
                result = CPB_ERR_NO_DCS_CH_FOUND;
            } else {
                UINT32 offset;
                temp_rd_queue_id = cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.rd_queue_id;
                switch (egress_mux_output_port) {
                    case CPB_DCPB_DPI_PORT_SIFD1:
                        offset = DCPB_MST_PORT_0_CH_OFFSET;
                        break;
                    case CPB_DCPB_DPI_PORT_SIFD2:
                        offset = DCPB_MST_PORT_1_CH_OFFSET;
                        break;
                    case CPB_DCPB_DPI_PORT_CBRC:
                        offset = DCPB_MST_PORT_2_CH_OFFSET;
                        break;
                    case CPB_DCPB_DPI_PORT_MAPOTN:
                        offset = DCPB_MST_PORT_3_CH_OFFSET;
                        break;
                    case CPB_DCPB_DPI_PORT_ENET_LINE:
                        offset = DCPB_MST_PORT_4_CH_OFFSET;
                        break;
                    case CPB_DCPB_DPI_PORT_ENET_SYS:
                        offset = DCPB_MST_PORT_5_CH_OFFSET;
                        break;

                    default:
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                }
                temp_rd_channel_id = egress_mux_output_port_chnl + offset;
            }
            sifd_sel = 0;

            break;

        case CPB_INSTANCE_MCPB:
            switch(egress_mux_output_port)
            {
                case CPB_MCPB_EGR_SYS_ING:
                    if(0 == cpb_handle->var.mcpb_em_sel.em_igr_ext_sel)
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    dcs_inst = 0;
                    dcs_chnl_id = egress_mux_output_port_chnl*2;
                    temp_rd_channel_id = dcs_chnl_id;
                    break;
                case CPB_MCPB_EGR_LINE_ING:
                    if(1 == cpb_handle->var.mcpb_em_sel.em_igr_ext_sel)
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    dcs_inst = 0;
                    dcs_chnl_id = egress_mux_output_port_chnl*2;
                    temp_rd_channel_id = dcs_chnl_id;
                    break;
                case CPB_MCPB_EGR_SYS_EG:
                    if(0 == cpb_handle->var.mcpb_em_sel.em_egr_ext_sel)
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    dcs_inst = 1;
                    dcs_chnl_id = egress_mux_output_port_chnl*2;
                    temp_rd_channel_id = dcs_chnl_id;
                    break;
                case CPB_MCPB_EGR_LINE_EG:
                    if(1 == cpb_handle->var.mcpb_em_sel.em_egr_ext_sel)
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    dcs_inst = 1;
                    dcs_chnl_id = egress_mux_output_port_chnl*2;
                    temp_rd_channel_id = dcs_chnl_id;
                    break;
                case CPB_MCPB_EGR_CPU:
                    dcs_inst = 2;
                    dcs_chnl_id = egress_mux_output_port_chnl + 64;
                    temp_rd_channel_id = dcs_chnl_id;
                    break;
                case CPB_MCPB_EGR_FEGE:
                    dcs_inst = 3; /* this dcs id is used to determine the egress mux input port id, so is 2 rather than 3*/
                    dcs_chnl_id = egress_mux_output_port_chnl;
                    temp_rd_channel_id = dcs_chnl_id;
                    break;
                default:
                    PMC_RETURN(CPB_ERR_INVALID_ARG);
            } /*end switch(egress_mux_output_port) */
            result = cpb_dcs_ch_and_qid_get(cpb_handle,dcs_inst,
                                            dcs_chnl_id,
                                            0,
                                            &temp_rd_channel_id,
                                            &temp_rd_queue_id);
            break;

        case CPB_INSTANCE_OCPB:
            dcs_inst = cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.dcs_inst;
            if (dcs_inst == 0xFF) {
                result = CPB_ERR_NO_DCS_CH_FOUND;
            } else {
                temp_rd_queue_id = cpb_handle->var.cpb_connect_data->chnl[egress_mux_output_port][egress_mux_output_port_chnl].mst.rd_queue_id;
                temp_rd_channel_id = egress_mux_output_port_chnl;
            }
            break;

        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);

    }
    if(result == PMC_SUCCESS)
    {
        PMC_LOG_TRACE("cpb_dcs_egress_dpi_chnl_source_get results \n dcs_inst: %u \n temp_rd_channel_id: %u \n temp_rd_queue_id: %u \n",
                   dcs_inst,
                   temp_rd_channel_id,
                   temp_rd_queue_id);
        *p_egress_mux_input_port = dcs_inst;
        *p_rd_channel_id = temp_rd_channel_id;
        *p_rd_queue_id = temp_rd_queue_id;
    }
    PMC_RETURN(result);
} /* cpb_dcs_egress_dpi_chnl_source_get */


/*******************************************************************************
* cpb_dcs_egress_dpi_chnl_source_get_recovery
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function retrieves the source data for an outbound port and channel.\n\n
*
*   This function differs from cpb_dcs_egress_dpi_chnl_source_get() in that
*   it only accesses context which is stored as part of warm/crash restart
*   operation.
*
* INPUTS:
*
*   *cpb_handle                  - pointer to the CPB handle instance
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*
*
*
* OUTPUTS:
*   *p_egress_mux_input_port     - egress mux input port associated with the
*                                  outbound data, 1:1 correlation with the
*                                  DCS instance
*   *p_rd_channel_id             - DCS RD_CHANNEL_ID used to direct data to
*                                  egress_mux port and DPI channel
*   *p_rd_queue_id               - DCS RD_IDENTIFIER_ID used to identify CFC
*                                  FIFO outbound channel data is originating
*                                  from.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_dcs_egress_dpi_chnl_source_get_recovery( cpb_handle_t *cpb_handle,
                                                               UINT32 egress_mux_output_port,
                                                               UINT32 egress_mux_output_port_chnl,
                                                               UINT32 *p_egress_mux_input_port,
                                                               UINT32 *p_rd_channel_id,
                                                               UINT32 *p_rd_queue_id )
{
    UINT32 sifd_sel = 0;
    UINT32 temp_rd_channel_id;
    UINT32 temp_rd_queue_id;
    UINT32 dcs_inst = 0;
    PMC_ERROR result = CPB_ERR_NO_SW_CONTENT;
    UINT32 dcs_chnl_id;

    PMC_ENTRY();

    if(egress_mux_output_port > cpb_handle->cfg.max_mst_dpi_port)
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(egress_mux_output_port_chnl > cpb_handle->cfg.max_dpi_mst_chnl_id[egress_mux_output_port])
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    switch (cpb_handle->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
            switch(egress_mux_output_port)
            {
                case CPB_DCPB_DPI_PORT_SIFD1: /*SIFD1 can come from SCPB pop port 0 */
                    /*Check the port mux */
                    sifd_sel = cpb_handle->var.dcpb_em_sifd1_sel;
                    if (0 == sifd_sel)
                        result = CPB_ERR_NO_DCS_CH_FOUND;
                    else
                    {
                        /*Search in the DCS context for channel */
                        dcs_inst = 0;
                        result = cpb_dcs_ch_and_qid_get( cpb_handle,dcs_inst,
                                                         egress_mux_output_port_chnl,
                                                         DCPB_MST_PORT_0_CH_OFFSET,
                                                         &temp_rd_channel_id,
                                                         &temp_rd_queue_id);
                    }
                    break;

                case CPB_DCPB_DPI_PORT_SIFD2: /*SIFD2 can come from SCPB pop port 1 */
                    /*Check the port mux */
                    sifd_sel = cpb_handle->var.dcpb_em_sifd2_sel;

                    if (0 == sifd_sel)
                        result = CPB_ERR_NO_DCS_CH_FOUND;

                    else
                    {
                        /*Search in the DCS context for channel */
                        dcs_inst = 1;
                        result = cpb_dcs_ch_and_qid_get( cpb_handle,dcs_inst,
                                                         egress_mux_output_port_chnl,
                                                         DCPB_MST_PORT_1_CH_OFFSET,
                                                         &temp_rd_channel_id,
                                                         &temp_rd_queue_id);
                    }
                    break;

                case CPB_DCPB_DPI_PORT_CBRC: /*CBRC can come from SCPB pop ports 0, 1, 2 */
                    /*Check the 1st port mux path */
                    if (0 == cpb_handle->var.dcpb_em_sifd1_sel)
                    {
                        /*Search in the DCS context for channel */
                        dcs_inst = 0;
                        result = cpb_dcs_ch_and_qid_get( cpb_handle,dcs_inst,
                                                         egress_mux_output_port_chnl,
                                                         DCPB_MST_PORT_2_CH_OFFSET,
                                                         &temp_rd_channel_id,
                                                         &temp_rd_queue_id);
                        if (!result)
                            break;
                    }
                    /*Check the 2nd port mux path */
                    if (0 == cpb_handle->var.dcpb_em_sifd2_sel)
                    {
                        /*Search in the DCS context for channel */
                        dcs_inst = 1;
                        result = cpb_dcs_ch_and_qid_get( cpb_handle,dcs_inst,
                                                         egress_mux_output_port_chnl,
                                                         DCPB_MST_PORT_2_CH_OFFSET,
                                                         &temp_rd_channel_id,
                                                         &temp_rd_queue_id);
                        if (!result)
                            break;
                    }
                    /*Check port 2 */
                    dcs_inst = 2;
                    result = cpb_dcs_ch_and_qid_get( cpb_handle,dcs_inst,
                                                     egress_mux_output_port_chnl,
                                                     DCPB_MST_PORT_2_CH_OFFSET,
                                                     &temp_rd_channel_id,
                                                     &temp_rd_queue_id);
                    break;

                case CPB_DCPB_DPI_PORT_MAPOTN: /*MAPOTN can come from SCPB pop ports 2, 3 */
                    dcs_inst = 2;
                    result = cpb_dcs_ch_and_qid_get( cpb_handle,dcs_inst,
                                                     egress_mux_output_port_chnl,
                                                     DCPB_MST_PORT_3_CH_OFFSET,
                                                     &temp_rd_channel_id,
                                                     &temp_rd_queue_id);
                    if (!result)
                        break;
                    dcs_inst = 3;
                    result = cpb_dcs_ch_and_qid_get( cpb_handle,dcs_inst,
                                                     egress_mux_output_port_chnl,
                                                     DCPB_MST_PORT_3_CH_OFFSET,
                                                     &temp_rd_channel_id,
                                                     &temp_rd_queue_id);
                    break;

                case CPB_DCPB_DPI_PORT_ENET_LINE: /*ENET Line can come from SCPB pop ports 2, 3 */
                    dcs_inst = 2;
                    result = cpb_dcs_ch_and_qid_get( cpb_handle,dcs_inst,
                                                     egress_mux_output_port_chnl,
                                                     DCPB_MST_PORT_4_CH_OFFSET,
                                                     &temp_rd_channel_id,
                                                     &temp_rd_queue_id);
                    if (!result)
                        break;
                    dcs_inst = 3;
                    result = cpb_dcs_ch_and_qid_get( cpb_handle,dcs_inst,
                                                     egress_mux_output_port_chnl,
                                                     DCPB_MST_PORT_4_CH_OFFSET,
                                                     &temp_rd_channel_id,
                                                     &temp_rd_queue_id);
                    break;

                case CPB_DCPB_DPI_PORT_ENET_SYS: /*ENET System can come from SCPB pop ports 0, 1 */
                    /*Check the 1st port mux path */
                    if (0 == cpb_handle->var.dcpb_em_sifd1_sel)
                    {
                        /*Search in the DCS context for channel */
                        dcs_inst = 0;
                        result = cpb_dcs_ch_and_qid_get(cpb_handle,dcs_inst,
                                                        egress_mux_output_port_chnl,
                                                        DCPB_MST_PORT_5_CH_OFFSET,
                                                        &temp_rd_channel_id,
                                                        &temp_rd_queue_id);
                        if (!result)
                            break;
                    }
                    /*Check the 2nd port mux path */
                    if (0 == cpb_handle->var.dcpb_em_sifd2_sel)
                    {
                        /*Search in the DCS context for channel */
                        dcs_inst = 1;
                        result = cpb_dcs_ch_and_qid_get(cpb_handle,dcs_inst,
                                                        egress_mux_output_port_chnl,
                                                        DCPB_MST_PORT_5_CH_OFFSET,
                                                        &temp_rd_channel_id,
                                                        &temp_rd_queue_id);
                        if (!result)
                            break;
                    }
                    break;

                default:
                    PMC_RETURN(CPB_ERR_INVALID_ARG);
            } /*end switch(egress_mux_output_port) */
            break;

        case CPB_INSTANCE_MCPB:
            switch(egress_mux_output_port)
            {
                case CPB_MCPB_EGR_SYS_ING:
                    if(0 == cpb_handle->var.mcpb_em_sel.em_igr_ext_sel)
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    dcs_inst = 0;
                    dcs_chnl_id = egress_mux_output_port_chnl*2;
                    temp_rd_channel_id = dcs_chnl_id;
                    break;
                case CPB_MCPB_EGR_LINE_ING:
                    if(1 == cpb_handle->var.mcpb_em_sel.em_igr_ext_sel)
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    dcs_inst = 0;
                    dcs_chnl_id = egress_mux_output_port_chnl*2;
                    temp_rd_channel_id = dcs_chnl_id;
                    break;
                case CPB_MCPB_EGR_SYS_EG:
                    if(0 == cpb_handle->var.mcpb_em_sel.em_egr_ext_sel)
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    dcs_inst = 1;
                    dcs_chnl_id = egress_mux_output_port_chnl*2;
                    temp_rd_channel_id = dcs_chnl_id;
                    break;
                case CPB_MCPB_EGR_LINE_EG:
                    if(1 == cpb_handle->var.mcpb_em_sel.em_egr_ext_sel)
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    dcs_inst = 1;
                    dcs_chnl_id = egress_mux_output_port_chnl*2;
                    temp_rd_channel_id = dcs_chnl_id;
                    break;
                case CPB_MCPB_EGR_CPU:
                    dcs_inst = 2;
                    dcs_chnl_id = egress_mux_output_port_chnl + 64;
                    temp_rd_channel_id = dcs_chnl_id;
                    break;
                case CPB_MCPB_EGR_FEGE:
                    dcs_inst = 3; /* this dcs id is used to determine the egress mux input port id, so is 2 rather than 3*/
                    dcs_chnl_id = egress_mux_output_port_chnl;
                    temp_rd_channel_id = dcs_chnl_id;
                    break;
                default:
                    PMC_RETURN(CPB_ERR_INVALID_ARG);
            } /*end switch(egress_mux_output_port) */
            result = cpb_dcs_ch_and_qid_get(cpb_handle,dcs_inst,
                                            dcs_chnl_id,
                                            0,
                                            &temp_rd_channel_id,
                                            &temp_rd_queue_id);
            break;

        case CPB_INSTANCE_OCPB:
            dcs_inst = egress_mux_output_port;
            result = cpb_dcs_ch_and_qid_get( cpb_handle,egress_mux_output_port,
                                             egress_mux_output_port_chnl,
                                             0,
                                             &temp_rd_channel_id,
                                             &temp_rd_queue_id);
            break;

        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);

    } /* end switch (cpb_handle->cpb_type) */

    if(result == PMC_SUCCESS)
    {
        PMC_LOG_TRACE("cpb_dcs_egress_dpi_chnl_source_get results \n dcs_inst: %u \n temp_rd_channel_id: %u \n temp_rd_queue_id: %u \n",
                dcs_inst,
                temp_rd_channel_id,
                temp_rd_queue_id);
        *p_egress_mux_input_port = dcs_inst;
        *p_rd_channel_id = temp_rd_channel_id;
        *p_rd_queue_id = temp_rd_queue_id;
    }
    PMC_RETURN(result);
} /* cpb_dcs_egress_dpi_chnl_source_get_recovery */


/*******************************************************************************
* cpb_dcs_ch_and_qid_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function determins the read channel id and read queue id according to the
*   egress mux output port chnl id and the dcs id, and the offset of the egress mux
*   output port.
*
*
* INPUTS:
*   cpb_handle                   - The cpb handle pointer
*   dcs_inst                     - DCS instance from 0 to 3, destination subsystem.
*   egress_mux_output_port_chnl  - Destination channel number relative to
*                                  egress_mux_output_port.  This is the DPI
*                                  channel that transfers data to downstream
*                                  subsystem
*   offset                       - The offset of the egress mux output port
*
*
* OUTPUTS:
*   *p_rd_channel_id             - DCS RD_CHANNEL_ID used to direct data to
*                                  egress_mux port and DPI channel
*   *p_rd_queue_id               - DCS RD_IDENTIFIER_ID used to identify CFC
*                                  FIFO outbound channel data is originating
*                                  from.
*
* RETURNS:
*   PMC_SUCCESS                  - if the chnl has been found in dcs chnl ctxt
*   CPB_ERR_NO_DCS_CH_FOUND      - if the chnl is not found in the dcs chnl ctxt
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_dcs_ch_and_qid_get(cpb_handle_t *cpb_handle,
                                         UINT32 dcs_inst,
                                         UINT32 egress_mux_output_port_chnl,
                                         UINT32 offset,
                                         UINT32 *p_rd_channel_id,
                                         UINT32 *p_rd_queue_id)
{
    util_schd_chnl_ctxt_t *p_chnl_ctxt = NULL;
    util_schd_block_const_ctxt_t *p_block_ctxt = NULL;
    UINT32 dcs_rd_channel_id = 0;
    UINT32 i = 0;

    PMC_ENTRY();

    p_chnl_ctxt = cpb_handle->util_schd_handle[dcs_inst]->var.schd_ctxt->chnl_ctxt;
    p_block_ctxt = &(cpb_handle->util_schd_handle[dcs_inst]->cfg.block_ctxt);


    if (!(cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB && dcs_inst < CPB_MCPB_POP_PORT_2))
    {
        dcs_rd_channel_id = egress_mux_output_port_chnl+offset;
        for(i=0; i < p_block_ctxt->num_schd_chnl; i++)
        {
            if (p_chnl_ctxt[i].dcs_rd_channel_id == dcs_rd_channel_id &&
                    p_chnl_ctxt[i].state != UTIL_SCHD_CHNL_START)
            {
                *p_rd_channel_id = dcs_rd_channel_id;
                *p_rd_queue_id = i;
                PMC_RETURN(PMC_SUCCESS);
            }
        }
    }
    else if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB && dcs_inst < CPB_MCPB_POP_PORT_2)
    {
        dcs_rd_channel_id = egress_mux_output_port_chnl >> 1;
        for(i=0; i < p_block_ctxt->num_schd_chnl; i++)
        {
            if (p_chnl_ctxt[i].dcs_rd_channel_id == dcs_rd_channel_id &&
                p_chnl_ctxt[i].state != UTIL_SCHD_CHNL_START)
            {
                *p_rd_channel_id = dcs_rd_channel_id;
                *p_rd_queue_id = i;
                PMC_RETURN(PMC_SUCCESS);
            }
        }
    }

    /*No matching channel was found */
    PMC_RETURN(CPB_ERR_NO_DCS_CH_FOUND);

} /* cpb_dcs_ch_and_qid_get */

/*******************************************************************************
* cpb_ingress_mux_input_port_data_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function retrieves source data for a DCS Instance and Read Queue ID.
*
* INPUTS:
*
*   *cpb_handle                  - pointer to the CPB handle instance
*   egress_mux_input_port        -  Egress Mux Input Port associated with
*                                   destination subsystem. 1:1 mapped to DCS
*                                   instance.
*   rd_queue_id                  -  Read Queue ID used to transfer data from
*                                   CFC to DCS for the Egress Mux Input Port.
*
*
*
* OUTPUTS:
*   *p_wr_queue_id               - pointer to storage for the retreived
*                                  write queue id associated with the channel
*   *p_ingress_mux_input_port    - pointer to storage for the ingress mux
*                                  input port offset associated with the
*                                  channel
*   *p_ingress_mux_input_port_chnl - pointer to storage for the ingress mux
*                                    input port channel (slave dpi channel)
*                                    associated with the read channel.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_ingress_mux_input_port_data_get( cpb_handle_t *cpb_handle,
                                                      UINT32 egress_mux_input_port,
                                                      UINT32 rd_queue_id,
                                                      UINT32 *p_wr_queue_id,
                                                      UINT32 *p_ingress_mux_input_port,
                                                      UINT32 *p_ingress_mux_input_port_chnl )
{

    UINT32 push_port_id;
    UINT32 wr_queue_id;
    UINT32 queue;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    queue =  cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, rd_queue_id);

    wr_queue_id = cpb_handle->var.fifo_var_data[queue].write_id;
    push_port_id = cpb_handle->var.fifo_var_data[queue].push_port_id;



    /*PMC_LOG_TRACE("cpb_ingress_mux_input_port_data_get internal results \n wr_queue_id: %u \n push_port_id: %u \n",
               wr_queue_id,
               push_port_id);*/

    if(CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type)
    {
        switch(push_port_id)
        {
            case 0: /* SIFD1 or ENET_SYS/CBRC port sources */
            case 1: /* SIFD2 or ENET_SYS/CBRC port sources */
                if (0 == cpb_handle->var.dcpb_ingress_mux_output_source[push_port_id])
                {
                    /* ENET_SYS/CBRC case */
                    PMC_ASSERT(wr_queue_id <= 119, CPB_ERR_MAPPING_DATA_EXTRACT_FAIL, 0, 0);

                    if( 108 <= wr_queue_id )
                    {
                        *p_ingress_mux_input_port_chnl = wr_queue_id - DCPB_SLV_PORT_2_CH_OFFSET;
                        *p_ingress_mux_input_port = CPB_DCPB_DPI_PORT_CBRC;
                    } else {
                        PMC_ASSERT(wr_queue_id <= 11, CPB_ERR_MAPPING_DATA_EXTRACT_FAIL, 0, 0);
                        *p_ingress_mux_input_port_chnl = wr_queue_id;
                        *p_ingress_mux_input_port = CPB_DCPB_DPI_PORT_ENET_SYS;
                    }

                } else {

                    /* SIFD case */
                    PMC_ASSERT(wr_queue_id <= 149, CPB_ERR_MAPPING_DATA_EXTRACT_FAIL, 0, 0);
                    *p_ingress_mux_input_port_chnl = wr_queue_id;
                    *p_ingress_mux_input_port = (0 == push_port_id) ? CPB_DCPB_DPI_PORT_SIFD1 : CPB_DCPB_DPI_PORT_SIFD2;

                }
                break;

            case 2: /* CBRC/MAPOTN/ENET_LINE port sources */
            case 3: /* MAPOTN/ENET_LINE port sources */
                /* cbrc 108..119 */
                /* mapotn 12..107 */
                /* enet_line 0..11 */
                PMC_ASSERT(wr_queue_id <= 119, CPB_ERR_MAPPING_DATA_EXTRACT_FAIL, 0, 0);
                if(108 <= wr_queue_id)
                {
                    PMC_ASSERT(2 == push_port_id, CPB_ERR_MAPPING_DATA_EXTRACT_FAIL, 0, 0);
                    *p_ingress_mux_input_port_chnl = wr_queue_id - DCPB_SLV_PORT_2_CH_OFFSET;
                    *p_ingress_mux_input_port = CPB_DCPB_DPI_PORT_CBRC;
                } else if (12 <= wr_queue_id) {
                    *p_ingress_mux_input_port_chnl = wr_queue_id - DCPB_SLV_PORT_3_CH_OFFSET;
                    *p_ingress_mux_input_port = CPB_DCPB_DPI_PORT_MAPOTN;
                } else {
                    *p_ingress_mux_input_port_chnl = wr_queue_id;
                    *p_ingress_mux_input_port = CPB_DCPB_DPI_PORT_ENET_LINE;
                }
                break;
            default:
                result = CPB_ERR_MAPPING_DATA_EXTRACT_FAIL;

        }

    } else if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type){
        switch(push_port_id)
        {
            case 0:
                PMC_ASSERT(cpb_handle->var.mcpb_im_sel.igr_ext_sel <= 1, CPB_ERR_MAPPING_DATA_EXTRACT_FAIL, 0, 0);
                *p_ingress_mux_input_port = cpb_handle->var.mcpb_im_sel.igr_ext_sel;
                *p_ingress_mux_input_port_chnl = wr_queue_id;
                break;
            case 1:
                PMC_ASSERT(cpb_handle->var.mcpb_im_sel.egr_ext_sel <= 1, CPB_ERR_MAPPING_DATA_EXTRACT_FAIL, 0, 0);
                *p_ingress_mux_input_port = cpb_handle->var.mcpb_im_sel.egr_ext_sel + 2;
                *p_ingress_mux_input_port_chnl = wr_queue_id;
                break;
            case 2:
                switch(egress_mux_input_port)
                {
                    case 0:
                        *p_ingress_mux_input_port_chnl = wr_queue_id;
                        if(0 == (wr_queue_id & 0x0001)) /*even number*/
                            *p_ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
                        else
                            *p_ingress_mux_input_port = CPB_MCPB_ING_CPU_INS;
                        break;
                    case 1:
                        *p_ingress_mux_input_port_chnl = wr_queue_id;
                        if(0 == (wr_queue_id & 0x0001)) /*even number*/
                            *p_ingress_mux_input_port = CPB_MCPB_ING_CPU_INS;
                        else
                            *p_ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
                        break;
                    case 2:
                    case 3:
                        *p_ingress_mux_input_port_chnl = CPB_MCPB_CPU_TO_MGMT_CHNL;
                        if(0 == wr_queue_id)
                            *p_ingress_mux_input_port = CPB_MCPB_ING_CPU_INS;
                        else if(1 == wr_queue_id)
                            *p_ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
                        else
                            PMC_RETURN(CPB_ERR_MAPPING_DATA_EXTRACT_FAIL);
                        break;
                    default:
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                }
                break;
            case 3:
                PMC_ASSERT(cpb_handle->var.mcpb_im_sel.reflect_sel <= 1, CPB_ERR_MAPPING_DATA_EXTRACT_FAIL, 0, 0);
                *p_ingress_mux_input_port = cpb_handle->var.mcpb_im_sel.reflect_sel + 6;
                *p_ingress_mux_input_port_chnl = wr_queue_id;
                break;
            default:
                result = CPB_ERR_MAPPING_DATA_EXTRACT_FAIL;
        }
    } else if(CPB_INSTANCE_OCPB == cpb_handle->cfg.cpb_type){
        *p_ingress_mux_input_port_chnl = wr_queue_id;
        *p_ingress_mux_input_port = push_port_id;
    }

    *p_wr_queue_id = wr_queue_id;

    PMC_RETURN(result);
} /* cpb_ingress_mux_input_port_data_get */

/*******************************************************************************
*  cpb_fifo_end_addr_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns the end address that was used last by push port id,
*   pop port id and the write queue id.
*
*
* INPUTS:
*   *cpb_handle      - pointer to CPB handle instance.
*   queue_system_id  - FIFO ID
*   read_qid         - read queue identifier
*   *end_addr_ptr    - pointer to the end address that was used last by FIFO
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_fifo_end_addr_get(cpb_handle_t *cpb_handle,
                                        UINT32 queue_system_id,
                                        UINT32 read_qid,
                                        UINT32 *end_addr_ptr)
{
    /* Variable declaration */
    UINT32 queue_index;

    PMC_ENTRY();

    /* argument checking */
    if (read_qid > cpb_handle->cfg.max_fifo_num) {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && CPB_MCPB_POP_PORT_2 == queue_system_id &&
       25 > read_qid)
    {
        queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, 3, read_qid);
    }
    else
    {
        queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, queue_system_id, read_qid);
    }

    *end_addr_ptr = cpb_handle->var.fifo_var_data[queue_index].fifo_end_addr;

    PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "queue_syste_id = %u, read_qid = %u, end_addr_ptr= %u\n", queue_system_id, read_qid, *end_addr_ptr);

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_fifo_end_addr_get */

#if defined (PMC_VERIFICATION) | defined (PMC_SW_SIMULATION)
/*******************************************************************************
*  cpb_fifo_queue_cfg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns the fifo configuration for a specified queue.
*
*
* INPUTS:
*   *cpb_handle         - pointer to the CPB handle instance
*   queue_system_id     - FIFO ID
*   read_qid            - Read Queue ID
*
* OUTPUTS:
*   *push_port_id_ptr   - Pointer to Push Port Id
*   *wr_queue_id_ptr    - Pointer to Write queue Id
*   *end_addr_ptr       - Pointer to end addrss of FIFO ID
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_fifo_queue_cfg_get(cpb_handle_t *cpb_handle,
                                        UINT32 queue_system_id,
                                        UINT32 read_qid,
                                        UINT32 *push_port_id_ptr,
                                        UINT32 *wr_queue_id_ptr,
                                        UINT32 *end_addr_ptr)
{
    /* Variable declaration */
    UINT32 queue_index;

    PMC_ENTRY();

    /* argument checking */
    if (read_qid > cpb_handle->cfg.max_fifo_num) {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, queue_system_id, read_qid);

    *wr_queue_id_ptr = cpb_handle->var.fifo_var_data[queue_index].write_id;
    *push_port_id_ptr = cpb_handle->var.fifo_var_data[queue_index].push_port_id;
    *end_addr_ptr = cpb_handle->var.fifo_var_data[queue_index].fifo_end_addr;

    PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "queue_syste_id = %u, read_qid = %u, push_port_id_ptr= %u, wr_queue_id_ptr= %u, end_addr_ptr= %u\n", queue_system_id, read_qid, *push_port_id_ptr, *wr_queue_id_ptr, *end_addr_ptr);

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_fifo_queue_cfg_get */

/*******************************************************************************
*  cpb_dpi_chnl_cfg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns the master port/channel cfg for a specified slave port/channel.
*
*
* INPUTS:
*   *cpb_handle      - pointer to the CPB handle instance
*   wr_port_id       - DPI Slave port
*   wr_chan_id       - DPI Slave channel
*
* OUTPUTS:
*   *rd_port_id_ptr  - DPI Master port
*   *rd_chan_id_ptr  - DPI Master channel
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_chnl_cfg_get(cpb_handle_t *cpb_handle,
                                      UINT32 wr_port_id,
                                      UINT32 wr_chan_id,
                                      UINT32 *rd_port_id_ptr,
                                      UINT32 *rd_chan_id_ptr)
{
    /* Variable declaration */
    PMC_ENTRY();

    /* argument checking */
    if (wr_port_id > cpb_handle->cfg.max_slv_dpi_port) {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }
    if (wr_chan_id > cpb_handle->cfg.max_dpi_slv_chnl_id[wr_port_id]) {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    *rd_port_id_ptr = cpb_handle->var.dpi_wr_port[wr_port_id].wr_ch[wr_chan_id].rd_port_id;
    *rd_chan_id_ptr = cpb_handle->var.dpi_wr_port[wr_port_id].wr_ch[wr_chan_id].rd_ch_id;

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_dpi_chnl_cfg_get */
#endif

/*******************************************************************************
* cpb_chnl_inst_mapping
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function maps the rd_channel_id and the egress_mux_input_port (dcs_instance)
*   to the egress_mux_output_port and egress_mux_output_port_chnl.
*
*
*
* INPUTS:
*   cpb_handle                   -  The cpb handle pointer.
*   egress_mux_input_port        -  The ingress mux output port, corresponds to the SCPB pop port
*   rd_channel_id                -  The read channel id determined according
*                                   to the egress mux output port and channel.
*
*
* OUTPUTS:
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_chnl_inst_mapping( cpb_handle_t *cpb_handle,
                                         UINT32 egress_mux_input_port,
                                         UINT32 rd_channel_id,
                                         UINT32 *egress_mux_output_port,
                                         UINT32 *egress_mux_output_port_chnl )
{
    PMC_ENTRY();

    if(egress_mux_input_port >= cpb_handle->cfg.num_dcs)
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    *egress_mux_output_port = egress_mux_input_port;

    switch(cpb_handle->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
            switch(egress_mux_input_port) /* dcs_instance is egress_mux_input_port */
            {
                case 0: /* Dcs_instance 1 */
                    if(cpb_handle->var.dcpb_em_sifd1_sel == 1) /* sifd1 case */
                    {
                        *egress_mux_output_port = CPB_DCPB_DPI_PORT_SIFD1;
                        *egress_mux_output_port_chnl = rd_channel_id - DCPB_MST_PORT_0_CH_OFFSET;
                        PMC_LOG_TRACE("sel SIFD1=%u\n",cpb_handle->var.dcpb_em_sifd1_sel);
                    }
                    else if(cpb_handle->var.dcpb_em_sifd1_sel == 0)
                    {
                        if(rd_channel_id >= 32 && rd_channel_id <= 43)  /* verify 45 */ /* CBRC case */
                        {
                            *egress_mux_output_port = CPB_DCPB_DPI_PORT_CBRC;
                            *egress_mux_output_port_chnl = rd_channel_id - DCPB_MST_PORT_2_CH_OFFSET;
                        }
                        else if(rd_channel_id <= 11) /* ENET sys case */
                        {
                            *egress_mux_output_port = CPB_DCPB_DPI_PORT_ENET_SYS;
                            *egress_mux_output_port_chnl = rd_channel_id - DCPB_MST_PORT_5_CH_OFFSET;
                        }
                        else
                        {
                            PMC_RETURN(CPB_ERR_INVALID_ARG);
                        }
                        PMC_LOG_TRACE("sel SIFD1=%u\n",cpb_handle->var.dcpb_em_sifd1_sel);
                    }
                   break;
                case 1: /* Dcs_instance 2 */
                     if(cpb_handle->var.dcpb_em_sifd2_sel == 1) /* sifd2 case */
                    {
                        *egress_mux_output_port = CPB_DCPB_DPI_PORT_SIFD2;
                        *egress_mux_output_port_chnl = rd_channel_id - DCPB_MST_PORT_1_CH_OFFSET;
                        PMC_LOG_TRACE("sel SIFD2=%u\n",cpb_handle->var.dcpb_em_sifd2_sel);
                    }
                    else if(cpb_handle->var.dcpb_em_sifd1_sel == 0)
                    {
                        if(rd_channel_id >= 32 && rd_channel_id <= 43) /* CBRC case */
                        {
                            *egress_mux_output_port = CPB_DCPB_DPI_PORT_CBRC;
                            *egress_mux_output_port_chnl = rd_channel_id - DCPB_MST_PORT_2_CH_OFFSET;
                        }
                        else if(rd_channel_id >= 0 && rd_channel_id <= 11) /* ENET sys case */
                        {
                            *egress_mux_output_port = CPB_DCPB_DPI_PORT_ENET_SYS;
                            *egress_mux_output_port_chnl = rd_channel_id - DCPB_MST_PORT_5_CH_OFFSET;
                        }
                        else
                        {
                            PMC_RETURN(CPB_ERR_INVALID_ARG);
                        }
                        PMC_LOG_TRACE("sel SIFD2=%u\n",cpb_handle->var.dcpb_em_sifd2_sel);
                    }
                   break;
                case 2: /* Dcs_instance 3 */
                    if(rd_channel_id >= 0 && rd_channel_id <= 11) /* ENET line case */
                    {
                        *egress_mux_output_port = CPB_DCPB_DPI_PORT_ENET_LINE;
                        *egress_mux_output_port_chnl = rd_channel_id - DCPB_MST_PORT_4_CH_OFFSET;
                    }
                    else if(rd_channel_id >= 32 && rd_channel_id <= 45) /* CBRC case */
                    {
                        *egress_mux_output_port = CPB_DCPB_DPI_PORT_CBRC;
                        *egress_mux_output_port_chnl = rd_channel_id - DCPB_MST_PORT_2_CH_OFFSET;
                    }
                    else if(rd_channel_id >= 128 && rd_channel_id <= 223) /* MAPOTN case */
                    {
                        *egress_mux_output_port = CPB_DCPB_DPI_PORT_MAPOTN;
                        *egress_mux_output_port_chnl = rd_channel_id - DCPB_MST_PORT_3_CH_OFFSET;
                    }
                    else
                    {
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    }
                   break;
                case 3: /* Dcs_instance 4 */
                    if(rd_channel_id >= 0 && rd_channel_id <= 11) /* ENET line case */
                    {
                        *egress_mux_output_port = CPB_DCPB_DPI_PORT_ENET_LINE;
                        *egress_mux_output_port_chnl = rd_channel_id - DCPB_MST_PORT_4_CH_OFFSET;
                    }
                    else if(rd_channel_id >= 128 && rd_channel_id <= 223) /* MAPOTN case */
                    {
                        *egress_mux_output_port = CPB_DCPB_DPI_PORT_MAPOTN;
                        *egress_mux_output_port_chnl = rd_channel_id - DCPB_MST_PORT_3_CH_OFFSET;
                    }
                    else
                    {
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    }
                   break;
                default:
                    PMC_RETURN(CPB_ERR_INVALID_ARG);
            }
            break;
        case CPB_INSTANCE_MCPB:
            PMC_RETURN(CPB_ERR_NO_SW_CONTENT);
            break;
        case CPB_INSTANCE_OCPB:
            *egress_mux_output_port_chnl = rd_channel_id;
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_chnl_inst_mapping */

/*******************************************************************************
* cpb_chnl_prov_arg_check
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function check the argument for the cpb_chnl_prov function and determines the wr
*   channel id and rd channel id
*
*
*
* INPUTS:
*   cpb_handle                   -  The cpb handle pointer.
*   ingress_mux_input_port       -  The Ingress Mux input Port associated with
*                                   source subsystem.
*   ingress_mux_input_port_chnl  -  The source channel number relative to ingress_mux_input_port.
*   ingress_mux_egress_port      -  The ingress mux output port, corresponds to the SCPB push port
*   egress_mux_input_port        -  The ingress mux output port, corresponds to the SCPB pop port
*   egress_mux_output_port       -  Egress Mux Output Port associated with
*                                   destination subsystem.
*   egress_mux_output_port_chnl  -  Destination channel number relative to
*                                   egress_mux_output_port.  This is the DPI
*                                   channel that transfers data to downstream
*                                   subsystem
*
*
* OUTPUTS:
*   wr_channel_id                -  The write channel id determined according
*                                   to the ingress mux input port and channel.
*   rd_channel_id                -  The read channel id determined according
*                                   to the egress mux output port and channel.
*   wr_queue_id                  -  The write queue id determined according
*                                   to the egress mux output port and channel.
*   rd_queue_id                  -  (ONLY applies for MCPB)
*                                   The read queue id determined according
*                                   to the egress mux output port and channel,
*
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_chnl_prov_arg_check( cpb_handle_t *cpb_handle,
                                           UINT32 ingress_mux_input_port,
                                           UINT32 ingress_mux_input_port_chnl,
                                           UINT32 ingress_mux_egress_port,
                                           UINT32 egress_mux_input_port,
                                           UINT32 egress_mux_output_port,
                                           UINT32 egress_mux_output_port_chnl,
                                           UINT32 *wr_channel_id,
                                           UINT32 *rd_channel_id,
                                           UINT32 *wr_queue_id,
                                           UINT32 *rd_queue_id )
{
    UINT32 wr_chid =  DEFAULT_32BIT_INVALID;
    UINT32 rd_chid = DEFAULT_32BIT_INVALID;
    UINT32 wr_qid = DEFAULT_32BIT_INVALID;
    UINT32 rd_qid = DEFAULT_32BIT_INVALID;

    PMC_ENTRY();

    if(ingress_mux_input_port > cpb_handle->cfg.max_slv_dpi_port)
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(egress_mux_input_port > cpb_handle->cfg.max_mst_dpi_port)
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(ingress_mux_input_port_chnl > cpb_handle->cfg.max_dpi_slv_chnl_id[ingress_mux_input_port])
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(egress_mux_output_port_chnl > cpb_handle->cfg.max_dpi_mst_chnl_id[egress_mux_output_port])
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(ingress_mux_egress_port >= cpb_handle->cfg.push_port_num || egress_mux_input_port >= cpb_handle->cfg.push_port_num)
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    switch(cpb_handle->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
            /* verify the egress mux output port is mapped to the input port for DCS0/1
               based on EGR_SIFDn_SEL field setting */
            if(egress_mux_input_port == 0){
                if(cpb_handle->var.dcpb_em_sifd1_sel == 0){
                    /* the source is CBRC or ENET_SYS */
                    if(egress_mux_output_port != CPB_DCPB_DPI_PORT_CBRC &&
                       egress_mux_output_port != CPB_DCPB_DPI_PORT_ENET_SYS) {
                        PMC_RETURN(CPB_ERR_INVALID_EGR_MUX_PORT_MAPPING);
                    }
                } else {
                    /* the source is SIFD1 */
                    if(egress_mux_output_port != CPB_DCPB_DPI_PORT_SIFD1) {
                        PMC_RETURN(CPB_ERR_INVALID_EGR_MUX_PORT_MAPPING);
                    }
                }
            }
            if(egress_mux_input_port == 1){
                if(cpb_handle->var.dcpb_em_sifd2_sel == 0){
                    /* the source is CBRC or ENET_SYS */
                    if(egress_mux_output_port != CPB_DCPB_DPI_PORT_CBRC &&
                       egress_mux_output_port != CPB_DCPB_DPI_PORT_ENET_SYS) {
                        PMC_RETURN(CPB_ERR_INVALID_EGR_MUX_PORT_MAPPING);
                    }
                } else {
                    /* the source is SIFD2 */
                    if(egress_mux_output_port != CPB_DCPB_DPI_PORT_SIFD2) {
                        PMC_RETURN(CPB_ERR_INVALID_EGR_MUX_PORT_MAPPING);
                    }
                }
            }
            /* verify the ingress mux output port is mapped to the configured input port
               options based on IGR_SIFDn_SEL field setting */
            if(ingress_mux_egress_port == 0){
                if(cpb_handle->var.dcpb_ingress_mux_output_source[0] == 0){
                    /* the source is CBRC or ENET_SYS */
                    if(ingress_mux_input_port != CPB_DCPB_DPI_PORT_CBRC &&
                       ingress_mux_input_port != CPB_DCPB_DPI_PORT_ENET_SYS) {
                        PMC_RETURN(CPB_ERR_INVALID_IGR_MUX_PORT_MAPPING);
                    }
                } else {
                    /* the source is SIFD1 */
                    if(ingress_mux_input_port != CPB_DCPB_DPI_PORT_SIFD1) {
                        PMC_RETURN(CPB_ERR_INVALID_IGR_MUX_PORT_MAPPING);
                    }
                }
            }
            if(ingress_mux_egress_port == 1){
                if(cpb_handle->var.dcpb_ingress_mux_output_source[1] == 0){
                    /* the source is CBRC or ENET_SYS */
                    if(ingress_mux_input_port != CPB_DCPB_DPI_PORT_CBRC &&
                       ingress_mux_input_port != CPB_DCPB_DPI_PORT_ENET_SYS) {
                        PMC_RETURN(CPB_ERR_INVALID_IGR_MUX_PORT_MAPPING);
                    }
                } else {
                    /* the source is SIFD2 */
                    if(ingress_mux_input_port != CPB_DCPB_DPI_PORT_SIFD2) {
                        PMC_RETURN(CPB_ERR_INVALID_IGR_MUX_PORT_MAPPING);
                    }
                }
            }
            switch(egress_mux_output_port)
            {
                case CPB_DCPB_DPI_PORT_SIFD1: /*SIFD1*/
                    if(egress_mux_input_port != 0 )
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    if(cpb_handle->var.dcpb_em_sifd1_sel != 1) /* port mux check */
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    rd_chid = egress_mux_output_port_chnl + DCPB_MST_PORT_0_CH_OFFSET;
                    break;
                case CPB_DCPB_DPI_PORT_SIFD2: /*SIFD2*/
                    if(egress_mux_input_port != 1 )
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    if(cpb_handle->var.dcpb_em_sifd2_sel != 1)
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    rd_chid = egress_mux_output_port_chnl + DCPB_MST_PORT_1_CH_OFFSET;
                    break;
                case CPB_DCPB_DPI_PORT_CBRC: /*CBRC*/
                    if(egress_mux_input_port > 2 )
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    rd_chid = egress_mux_output_port_chnl + DCPB_MST_PORT_2_CH_OFFSET;
                    break;
                case CPB_DCPB_DPI_PORT_MAPOTN: /* MAPOTN */
                    if(egress_mux_input_port < 2 )
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    rd_chid = egress_mux_output_port_chnl + DCPB_MST_PORT_3_CH_OFFSET;
                    break;
                case CPB_DCPB_DPI_PORT_ENET_LINE: /* ENET Line */
                    if(egress_mux_input_port < 2 )
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    rd_chid = egress_mux_output_port_chnl + DCPB_MST_PORT_4_CH_OFFSET;
                    break;
                case CPB_DCPB_DPI_PORT_ENET_SYS: /* ENET Sys */
                    if(0 == egress_mux_input_port )
                    {
                        if(cpb_handle->var.dcpb_em_sifd1_sel != 0)
                           PMC_RETURN(CPB_ERR_INVALID_ARG);
                    } else if (1 == egress_mux_input_port) {
                        if(cpb_handle->var.dcpb_em_sifd2_sel != 0)
                           PMC_RETURN(CPB_ERR_INVALID_ARG);
                    } else { PMC_RETURN(CPB_ERR_INVALID_ARG);}
                    rd_chid = egress_mux_output_port_chnl + DCPB_MST_PORT_5_CH_OFFSET;
                    break;
                default:
                    PMC_RETURN(CPB_ERR_INVALID_ARG);
            }
            switch(ingress_mux_input_port)
            {
                case CPB_DCPB_DPI_PORT_SIFD1: /*SIFD1*/
                    if(ingress_mux_egress_port != 0 )
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    if(cpb_handle->var.dcpb_ingress_mux_output_source[0] != 1) /* data source check */
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    wr_chid = ingress_mux_input_port_chnl + DCPB_SLV_PORT_0_CH_OFFSET;
                    break;
                case CPB_DCPB_DPI_PORT_SIFD2: /*SIFD2*/
                    if(ingress_mux_egress_port != 1 )
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    if(cpb_handle->var.dcpb_ingress_mux_output_source[1] != 1) /* data source check */
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    wr_chid = ingress_mux_input_port_chnl + DCPB_SLV_PORT_1_CH_OFFSET;
                    break;
                case CPB_DCPB_DPI_PORT_CBRC: /*CBRC*/
                    if(ingress_mux_egress_port > 2 )
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    wr_chid = ingress_mux_input_port_chnl + DCPB_SLV_PORT_2_CH_OFFSET;
                    break;
                case CPB_DCPB_DPI_PORT_MAPOTN: /* MAPOTN */
                    if(ingress_mux_egress_port < 2 )
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    wr_chid = ingress_mux_input_port_chnl + DCPB_SLV_PORT_3_CH_OFFSET;
                    break;
                case CPB_DCPB_DPI_PORT_ENET_LINE: /* ENET Line */
                    if(ingress_mux_egress_port < 2 )
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    wr_chid = ingress_mux_input_port_chnl + DCPB_SLV_PORT_4_CH_OFFSET;
                    break;
                case CPB_DCPB_DPI_PORT_ENET_SYS: /* ENET Sys */
                    if(ingress_mux_egress_port > 1 )
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    if(cpb_handle->var.dcpb_ingress_mux_output_source[ingress_mux_egress_port] != 0) /* data source check */
                        PMC_RETURN(CPB_ERR_INVALID_ARG);
                    wr_chid = ingress_mux_input_port_chnl + DCPB_SLV_PORT_5_CH_OFFSET;
                    break;
                default:
                    PMC_RETURN(CPB_ERR_INVALID_ARG);
            }
            wr_qid = wr_chid;
            break;
        case CPB_INSTANCE_MCPB:
            switch(ingress_mux_input_port)
            {
                case CPB_MCPB_ING_LINE_IM_EXT:
                case CPB_MCPB_ING_SYS_IM_EXT:
                    wr_chid = ingress_mux_input_port_chnl;
                    wr_qid = ingress_mux_input_port_chnl;
                    if(0 == (ingress_mux_input_port_chnl & 0x0001))
                    {
                        rd_qid = 25 + (ingress_mux_input_port_chnl >> 1);
                        rd_chid = 65 + (ingress_mux_input_port_chnl >> 1) * 4;
                    } else {
                        rd_qid = ingress_mux_input_port_chnl >> 1;
                        rd_chid = 1 + (ingress_mux_input_port_chnl >> 1) * 4;
                    }
                    break;
                case CPB_MCPB_ING_LINE_EM_EXT:
                case CPB_MCPB_ING_SYS_EM_EXT:
                    wr_chid = ingress_mux_input_port_chnl;
                    wr_qid = ingress_mux_input_port_chnl;
                    if(0 == (ingress_mux_input_port_chnl & 0x0001))
                    {
                        rd_qid = 37 + (ingress_mux_input_port_chnl >> 1);
                        rd_chid = 64 + (ingress_mux_input_port_chnl >> 1) * 4;
                    } else {
                        rd_qid = 12 + (ingress_mux_input_port_chnl >> 1);
                        rd_chid = (ingress_mux_input_port_chnl >> 1) * 4;
                    }
                    break;
                case CPB_MCPB_ING_CPU_INS:
                    wr_chid = ingress_mux_input_port_chnl;
                    if(24 == ingress_mux_input_port_chnl)
                    {
                        wr_qid = 0;
                        rd_qid = 24;
                        rd_chid = 3;
                    } else {
                        wr_qid = ingress_mux_input_port_chnl;
                        rd_qid = ingress_mux_input_port_chnl;
                        rd_chid = ingress_mux_input_port_chnl >> 1;
                    }
                    break;
                case CPB_MCPB_ING_FEGE_INS:
                    wr_chid = ingress_mux_input_port_chnl;
                    if(24 == ingress_mux_input_port_chnl)
                    {
                        wr_qid = 1;
                        rd_qid = 61;
                        rd_chid = 67;
                    } else {
                        wr_qid = ingress_mux_input_port_chnl;
                        rd_qid = ingress_mux_input_port_chnl;
                        rd_chid = ingress_mux_input_port_chnl >> 1;
                    }
                    break;
                case CPB_MCPB_ING_LINE_REF:
                case CPB_MCPB_ING_SYS_REF:
                    wr_chid = ingress_mux_input_port_chnl;
                    wr_qid = ingress_mux_input_port_chnl;
                    rd_qid = 49 + ingress_mux_input_port_chnl;
                    rd_chid = 66 + ingress_mux_input_port_chnl * 4;
                    break;
                default:
                    PMC_RETURN(CPB_ERR_INVALID_ARG);
            }
            *rd_queue_id = rd_qid;
            break;
        case CPB_INSTANCE_OCPB:
            wr_chid = ingress_mux_input_port_chnl;
            rd_chid = egress_mux_output_port_chnl;
            wr_qid = wr_chid;
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
    }
    *wr_channel_id = wr_chid;
    *rd_channel_id = rd_chid;
    *wr_queue_id = wr_qid;

#if defined (PMC_VERIFICATION) | defined (PMC_SW_SIMULATION)
    cpb_handle->var.dpi_wr_port[ingress_mux_input_port].enable = TRUE;
    cpb_handle->var.dpi_wr_port[ingress_mux_input_port].wr_ch[ingress_mux_input_port_chnl].enable = TRUE;
    cpb_handle->var.dpi_wr_port[ingress_mux_input_port].wr_ch[ingress_mux_input_port_chnl].
                    rd_port_id = egress_mux_output_port;
    cpb_handle->var.dpi_wr_port[ingress_mux_input_port].wr_ch[ingress_mux_input_port_chnl].
                    rd_ch_id = egress_mux_output_port_chnl;
#endif
    PMC_RETURN(PMC_SUCCESS);
} /* cpb_chnl_prov_arg_check */

/*******************************************************************************
* cpb_rd_queue_id_to_dest_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function gets the output port and chnl id given the read queue id when a
*   channel is already provisioned. It looks up the util_schd chnl_ctxt indexed by
*   read queue id and find the dcs read channel id then translate it into the output
*   port and chnl id that is the same as used in datapath layer.
*
*
*
* INPUTS:
*   cpb_handle                   -  The cpb handle pointer.
*   dcs_inst                     -  The DCS instance id.
*   rd_queue_id                  -  The read queue id.
*   *egress_mux_output_port      -  Pointer to the Egress Mux Output Port
*                                   associated with  destination subsystem.
*   *egress_mux_output_port_chnl -  Pointer to the destination channel number
*                                   relative to egress_mux_output_port.
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_rd_queue_id_to_dest_chnl_get( cpb_handle_t *cpb_handle,
                                                    UINT32 dcs_inst,
                                                    UINT32 rd_queue_id,
                                                    UINT32 *egress_mux_output_port,
                                                    UINT32 *egress_mux_output_port_chnl )
{
    util_schd_chnl_ctxt_t *p_chnl_ctxt;
    UINT32 dcs_rd_channel_id;

    PMC_ENTRY();

    PMC_ASSERT(dcs_inst < cpb_handle->cfg.num_dcs, CPB_ERR_INVALID_ARG,0,0);
    PMC_ASSERT(rd_queue_id < cpb_handle->cfg.max_fifo_num, CPB_ERR_INVALID_ARG,0,0);

    p_chnl_ctxt = cpb_handle->util_schd_handle[dcs_inst]->var.schd_ctxt->chnl_ctxt;
    dcs_rd_channel_id = p_chnl_ctxt[rd_queue_id].dcs_rd_channel_id;

    switch(cpb_handle->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
            switch(dcs_inst)
            {
                case 0:
                    PMC_ASSERT(cpb_handle->var.dcpb_em_sifd1_sel <= 1, CPB_ERR_CODE_ASSERT, 0,0);
                    if(1 == cpb_handle->var.dcpb_em_sifd1_sel)
                    {
                        *egress_mux_output_port = CPB_DCPB_DPI_PORT_SIFD1;
                        *egress_mux_output_port_chnl = dcs_rd_channel_id;
                    } else {
                        if( dcs_rd_channel_id >= DCPB_MST_PORT_2_CH_OFFSET ) /* a CBRC channel*/
                        {
                            *egress_mux_output_port = CPB_DCPB_DPI_PORT_CBRC;
                            *egress_mux_output_port_chnl = dcs_rd_channel_id - DCPB_MST_PORT_2_CH_OFFSET;
                        } else {
                            *egress_mux_output_port = CPB_DCPB_DPI_PORT_ENET_SYS;
                            *egress_mux_output_port_chnl = dcs_rd_channel_id;
                        }
                    }
                    break;
                case 1:
                    PMC_ASSERT(cpb_handle->var.dcpb_em_sifd2_sel <= 1, CPB_ERR_CODE_ASSERT, 0,0);
                    if(1 == cpb_handle->var.dcpb_em_sifd2_sel)
                    {
                        *egress_mux_output_port = CPB_DCPB_DPI_PORT_SIFD2;
                        *egress_mux_output_port_chnl = dcs_rd_channel_id;
                    } else {
                        if( dcs_rd_channel_id >= DCPB_MST_PORT_2_CH_OFFSET ) /* a CBRC channel*/
                        {
                            *egress_mux_output_port = CPB_DCPB_DPI_PORT_CBRC;
                            *egress_mux_output_port_chnl = dcs_rd_channel_id - DCPB_MST_PORT_2_CH_OFFSET;
                        } else {
                            *egress_mux_output_port = CPB_DCPB_DPI_PORT_ENET_SYS;
                            *egress_mux_output_port_chnl = dcs_rd_channel_id;
                        }
                    }
                    break;
                case 2:
                    if(dcs_rd_channel_id >= DCPB_MST_PORT_3_CH_OFFSET)
                    {
                        *egress_mux_output_port = CPB_DCPB_DPI_PORT_MAPOTN;
                        *egress_mux_output_port_chnl = dcs_rd_channel_id - DCPB_MST_PORT_3_CH_OFFSET;
                    } else if(dcs_rd_channel_id >= DCPB_MST_PORT_2_CH_OFFSET) {
                        *egress_mux_output_port = CPB_DCPB_DPI_PORT_CBRC;
                        *egress_mux_output_port_chnl = dcs_rd_channel_id - DCPB_MST_PORT_2_CH_OFFSET;
                    } else {
                        *egress_mux_output_port = CPB_DCPB_DPI_PORT_ENET_LINE;
                        *egress_mux_output_port_chnl = dcs_rd_channel_id;
                    }
                    break;
                case 3:
                    if(dcs_rd_channel_id >= DCPB_MST_PORT_3_CH_OFFSET)
                    {
                        *egress_mux_output_port = CPB_DCPB_DPI_PORT_MAPOTN;
                        *egress_mux_output_port_chnl = dcs_rd_channel_id - DCPB_MST_PORT_3_CH_OFFSET;
                    } else {
                        *egress_mux_output_port = CPB_DCPB_DPI_PORT_ENET_LINE;
                        *egress_mux_output_port_chnl = dcs_rd_channel_id;
                    }
                    break;
                default:
                    PMC_RETURN(CPB_ERR_INVALID_ARG);
            }
            break;
        case CPB_INSTANCE_MCPB:
            switch(dcs_inst)
            {
                case 0:
                    if(1 == cpb_handle->var.mcpb_em_sel.em_igr_ext_sel)/* system side */
                        *egress_mux_output_port = CPB_MCPB_EGR_SYS_ING;
                    else            /* line side */
                        *egress_mux_output_port = CPB_MCPB_EGR_LINE_ING;
                    *egress_mux_output_port_chnl = dcs_rd_channel_id;
                    break;
                case 1:
                    if(1 == cpb_handle->var.mcpb_em_sel.em_egr_ext_sel)/* system side */
                        *egress_mux_output_port = CPB_MCPB_EGR_SYS_EG;
                    else            /* line side */
                        *egress_mux_output_port = CPB_MCPB_EGR_LINE_EG;
                    *egress_mux_output_port_chnl = dcs_rd_channel_id;
                    break;
                case 2:
                    *egress_mux_output_port = CPB_MCPB_EGR_CPU;
                    *egress_mux_output_port_chnl = dcs_rd_channel_id - 64;
                    break;
                case 3:
                    *egress_mux_output_port = CPB_MCPB_EGR_FEGE;
                    *egress_mux_output_port_chnl = dcs_rd_channel_id;
                    break;
                default:
                    PMC_RETURN(CPB_ERR_INVALID_ARG);
            }
            break;
        case CPB_INSTANCE_OCPB:
            *egress_mux_output_port = dcs_inst;
            *egress_mux_output_port_chnl = dcs_rd_channel_id;
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_rd_queue_id_to_dest_chnl_get */

#ifndef CPB_UNIT_TEST

/*******************************************************************************
* cpb_fw_opsa_debug_status_internal_get
* ___________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves debug state and configuration variables for OPSA start up.
*
* INPUTS:
*    cpb_handle            - DIGI device handle.
*    subsystem             - subsystem to read
*    channel               - channel of the specified subsystem to read
*
* OUTPUTS:
*    fw_opsa_status_ptr - pointer to storage for returned status.\n
*
*  RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
*  NOTES: CMD_REQ_OPSA_Get_Debug_Status message.
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_fw_opsa_debug_status_internal_get(cpb_handle_t *cpb_handle,
                                                       hostmsg_opsa_subsystem_cfg_t subsystem,
                                                       UINT8 channel,
                                                       fw_opsa_status_t *fw_opsa_status_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 data[1];
    UINT32 response[9];

    PMC_ENTRY();

    PMC_ASSERT((NULL != cpb_handle), HOSTMSG_ERR_INVALID_PARAMETERS, 0, 0);
    PMC_ASSERT((NULL != fw_opsa_status_ptr),
               HOSTMSG_ERR_INVALID_PARAMETERS, 0, 0);

    /* Add message body to the previously created header. */
    data[0] = ((UINT16)subsystem << 16) | channel;

    {
        HOSTMSG_DECLARE_QUERY_STAT(stat);
        result = hostmsg_perform_variable_length_query((pmc_handle_t *)cpb_handle,MODID_OPSA,HOSTMSG_CMD_REQ_OPSA_GET_DEBUG_STATUS_ST,data,1,response,9,NULL,stat);
    }

    if (PMC_SUCCESS == result)
    {
        /* Return requested data. */
        fw_opsa_status_ptr->mpma_enable         = response[0];
        fw_opsa_status_ptr->mpma_qs_ch_en       = response[1];
        fw_opsa_status_ptr->mpma_state          = response[2];
        fw_opsa_status_ptr->mpma_tick_cnt       = response[3];
        fw_opsa_status_ptr->mpmo_enable         = response[4];
        fw_opsa_status_ptr->mpmo_ch_data_target = response[5];
        fw_opsa_status_ptr->mpmo_acb_instance   = response[6];
        fw_opsa_status_ptr->mpmo_state          = response[7];
        fw_opsa_status_ptr->mpmo_tick_cnt       = response[8];
    }

    PMC_RETURN(result);

} /* cpb_fw_opsa_debug_status_internal_get */

/*******************************************************************************
* cpb_fw_opsa_cfg_mpma_port_add
* ___________________________________________________________________________
*
* DESCRIPTION:
*   Sends host message to FW to perform the MPMA startup operational procedure.
*   FW is designed such that in broadcast scenarios, should a second add for
*   a channel occur, the FW will check if initial MPMA configuration
*   has completed and if so, just update QSn_CH_EN of the specified DPI Slave
*   Port. Otherwise it will update the current job to use the
*   new QSn_CH_EN settings provided.
*
* INPUTS:
*   cpb_handle       - pointer to DIGI handle instance.
*   subsystem        - subsystem to configure
*   chnl_add_msk_ptr - pointer to array of bitmask specifying channels to
*                      enable\n
*                      chnl_add_msk_ptr[0]: Bitmask for channels 31:0\n
*                      chnl_add_msk_ptr[1]: Bitmask for channels 63:32\n
*                      chnl_add_msk_ptr[2]: Bitmask for channels 95:64
*   qs_ch_en_ptr     - Pointer to array of QSn_CH_EN config mask where
*                      each bit index in mask[3:0] corresponds to n
*                      in QSn_CH_EN.  Multiple bits may be set.
*                      The array must have a size of 96 to cover the 
*                      maximum number of instances of MPMA blocks.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*   CMD_CFG_OPSA_MPMA_Port_Add
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_fw_opsa_cfg_mpma_port_add(cpb_handle_t *cpb_handle,
                                               hostmsg_opsa_subsystem_cfg_t subsystem,
                                               UINT32 *chnl_add_msk_ptr,
                                               UINT8  *qs_ch_en_ptr)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 data[100];
    UINT32 i;

    PMC_ENTRY();

    PMC_ASSERT(NULL != cpb_handle, CPB_ERR_NULL_HANDLE, 0, 0);

    /* Subsystem and channel masks */
    data[0] = (UINT16)subsystem << 16;
    data[1] = chnl_add_msk_ptr[0];
    data[2] = chnl_add_msk_ptr[1];
    data[3] = chnl_add_msk_ptr[2];

    /* QS_CH_EN bits */
    for (i = 0; i < 96; i = i + sizeof(UINT32)) {
        data[4+i] = ((((UINT32)qs_ch_en_ptr[i]) << 24) & 0xff000000) | \
                    ((((UINT32)qs_ch_en_ptr[i+1]) << 16) & 0x00ff0000) | \
                    ((((UINT32)qs_ch_en_ptr[i+2]) << 8) & 0x0000ff00) | \
                    (((UINT32)qs_ch_en_ptr[i+3]) & 0x000000ff);
    } /* end for */
    {
        HOSTMSG_DECLARE_CFG_MSG_STAT(stat);
        result = hostmsg_send_cfg_message((pmc_handle_t *)cpb_handle,MODID_OPSA,HOSTMSG_CMD_CFG_OPSA_MPMA_PORT_ADD_ST,data,28,stat);
    }

    PMC_RETURN(result);

} /* cpb_fw_opsa_cfg_mpma_port_add() */
#endif


/*******************************************************************************
* cpb_determine_num_blocks
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Determines the number of memory blocks needed for the specified channel
*   The calculation is num_blocks = 2 * MTU / block size\n\n
*
*   If more blocks are needed they can be added at a higher level using
*   halt buffer.
*
* INPUTS:
*   cpb_handle          -   The cpb handle pointer
*   dcs_inst            -   The dcs instance index 0-3, for MCPB treated as pop port id
*   push_port_id        -   Push port id
*   rd_chnl_id          -   The output channel ID associated with egress mux
*                           output port, for mcpb treated as read queue id
*   rate                -   The rate
*   rate_units          -   The rate units, the actual rate is rate*10^(rate_units)
*   halt_buffer_size    -   For flow control, given in number of blocks
*   ilkn_source         -   Identifies if a DCPB channel is sourced from ILKN\n
*                           TRUE: data source is ILKN\n
*                           FALSE: data source is not ILKN
*
* OUTPUTS:
*   num_blocks          -   pointer to the number of blocks
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_determine_num_blocks( cpb_handle_t *cpb_handle,
                                            UINT32 dcs_inst,
                                            UINT32 push_port_id,
                                            UINT32 rd_chnl_id,
                                            UINT32 rate, UINT32 rate_units,
                                            UINT32 halt_buffer_size,
                                            BOOL8 ilkn_source,
                                            UINT32 *num_blocks )
{
    UINT32 result;
    UINT32 num_blks;
    INT32 num_block_units;
    UINT32 num_entries = 0;
    UINT32 fill_lvl_mult;

    PMC_ENTRY();

    switch(cpb_handle->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
            if (cpb_handle->cfg.dcs_use_ctxt[dcs_inst].alloc_mode == UTIL_SCHD_ALLOC_METHOD_CPB_DCS &&
                dcs_inst < 2)
            {
                result = cpb_dcs_db_num_entry_by_rd_chnl_id_get(cpb_handle,
                                                                dcs_inst,
                                                                rd_chnl_id,
                                                                &num_entries);
                PMC_ASSERT(num_entries!=0, CPB_ERR_CODE_ASSERT, 0, 0);

                if(CPB_XFER_MODE_TYPE_PACKET == cpb_dcs_burst_xfer_mode_get(cpb_handle, dcs_inst))
                {
                    if (TRUE == pmc_dcpb_one_trib_slot_min_buffer_revision(&cpb_handle->base))
                    {
                        if(num_entries == 1)
                        {
                            num_blks = 3;
                        }
                        else if(num_entries < 19)
                        {
                            num_blks = num_entries + 1;
                        }
                        else
                        {
                            num_blks = 20;
                        }
                    }
                    else
                    {
                        if(num_entries < 19)
                        {
                            num_blks = num_entries + 1;
                        }
                        else
                        {
                            num_blks = 20;
                        }
                    }
                } else {
                    num_blks = 2;
                }
                *num_blocks = num_blks + halt_buffer_size;
            } else {
                *num_blocks = 2 + halt_buffer_size;
            }
            break;
        case CPB_INSTANCE_OCPB:
            if (cpb_handle->cfg.dcs_use_ctxt[dcs_inst].alloc_mode == UTIL_SCHD_ALLOC_METHOD_CPB_DCS)
            {
                UINT32 multiplier = 2;
                result = cpb_dcs_db_num_entry_get(cpb_handle, dcs_inst,
                                                  dcs_inst,
                                                  rd_chnl_id,
                                                  &num_entries);
                PMC_ASSERT(num_entries!=0, CPB_ERR_CODE_ASSERT, 0, 0);


                fill_lvl_mult = 1;

                *num_blocks = (num_entries * multiplier * fill_lvl_mult) + halt_buffer_size;
            }
            else {
                /* For OCPB, the number of blocks is a linear formula which is
                   based on 2 blocks per ODU0 (1.25 Gb/s). This corresponds to
                   1 block per 625 Mb/s */
                result = util_schd_math_division(UTIL_SCHD_MATH_DIVISION_CEILING,
                                                 rate, rate_units,
                                                 625, UTIL_SCHD_1M_BIT_SEC,
                                                 &num_blks, &num_block_units);

                if (result) PMC_RETURN(UTIL_SCHD_ERR_CALCULATION_FAIL);
                *num_blocks = num_blks + halt_buffer_size;


            }

            break;
        case CPB_INSTANCE_MCPB:
            /* determine if a 1K or 4K FIFO depth required */
            switch(dcs_inst)
            {
                case 0:
                    PMC_ASSERT(rd_chnl_id < 24, CPB_ERR_INVALID_ARG, 0, 0);
                    if(rd_chnl_id % 2 == 1)
                    {
                        /* CPU Insert Rx - Odd RID */
                        *num_blocks = 3 + halt_buffer_size;
                    } else {
                        /* MGMT Insert Rx - Even RID */
                        *num_blocks = 11 + halt_buffer_size;
                    }
                    break;
                case 1:
                    *num_blocks = 11 + halt_buffer_size;
                    break;
                case 2:
                    PMC_ASSERT(rd_chnl_id < 62, CPB_ERR_INVALID_ARG, 0, 0);
                    /*
                    1k fifo required for:
                    Extract TX to CPU
                    TX_REFLT to CPU
                    Otherwise 4 k fifo required.
                    */
                    if(rd_chnl_id > 36 && rd_chnl_id < 61)
                    {
                        /* CPU Insert Rx - Odd RID */
                        *num_blocks = 3 + halt_buffer_size;
                    } else {
                        /* MGMT Insert Rx - Even RID */
                        *num_blocks = 11 + halt_buffer_size;
                    }
                    break;
                default:
                    PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG, 0, 0);
            }
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
    };

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_determine_num_blocks */


/*******************************************************************************
*  cpb_qs_current_pages_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns the number of PMPM pages allocated to a push-pop CFC
*   in the inverted page table, and the physical address array of the pages.
*
*
* INPUTS:
*   *cpb_handle               - pointer to the CPB handle instance
*   push_port_id              - The target push port id
*   pop_port_id               - The target pop port id
*   *num_current_pages_ptr    - pointer to the current number of PMPM pages that
*                               are allocated to the queue system push/pop pair
*   *current_pages_array      - pointer to an array of PMPM physical page indes
*                               that are allocated to the posh-pop port pair,
*                               current_pages_array should have enough length
*                               to contain the page array
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_qs_current_pages_get(cpb_handle_t *cpb_handle,
                                           UINT32 push_port_id,
                                           UINT32 pop_port_id,
                                           UINT32 *num_current_pages_ptr,
                                           UINT32 *current_pages_array)
{
    /* Variable declaration */
    UINT32 i;
    UINT32 num_current_pages;
    PMC_ENTRY();

    /* argument checking */
    if (push_port_id >= cpb_handle->cfg.push_port_num || pop_port_id >= cpb_handle->cfg.pop_port_num) {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    num_current_pages = 0;
    for(i = 0; i < cpb_handle->cfg.num_pages; i++)
    {
        if(cpb_handle->var.page_inverted_page_table[i].ctrl_ipt_qs_id == pop_port_id &&
           cpb_handle->var.page_inverted_page_table[i].ctrl_ipt_wp_id == push_port_id &&
           TRUE == cpb_handle->var.page_inverted_page_table[i].ctrl_page_valid)
        {
            current_pages_array[num_current_pages++] = i;
        }
    }

    PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "num_current_pages = %u \n", num_current_pages);

    *num_current_pages_ptr = num_current_pages;

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_qs_current_pages_get */

/*******************************************************************************
*  cpb_pmpm_empty_page_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns an array of empty physical page address indices and
*   checks if there is enough empty rows left for the num pages.
*
* INPUTS:
*   *cpb_handle             - pointer to the CPB handle instance
*   num_pages               - number of pages needed for FIFO
*
* OUTPUTS:
*   *available_page_array   - a pointer to array of empty indices for the
*                             inverted page table

* RETURNS:
*   PMC_SUCCESS, CPB_ERR_PMPM_PAGE_UNAVAILABLE or CPB_ERR_INVALID_ARG
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_pmpm_empty_page_get(cpb_handle_t *cpb_handle,
                                          UINT32 num_pages,
                                          UINT32 *available_page_array)
{
    /* Variable declaration */
    UINT32 i;
    UINT32 available_page_count;
    PMC_ENTRY();

    /* argument checking */
    if(num_pages > cpb_handle->cfg.num_pages){
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    /* initialize the array*/
    for(i = 0; i < cpb_handle->cfg.num_pages; i++)
    {
        available_page_array[i]= cpb_handle->cfg.page_null_entry;
    }

    /* get the list of all empty page indices and store them in the array */
    available_page_count = 0;
    for(i = 0; i < cpb_handle->cfg.num_pages; i++)
    {
        if(FALSE == cpb_handle->var.page_inverted_page_table[i].ctrl_page_valid)
        {
            available_page_array[available_page_count++] = i;
        }
    }

    PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "available_page_count = %u \n", available_page_count);

    /* check if enough number of pages are available */
    if(num_pages > available_page_count)
    {
        /* return error the not enough pages available */
        PMC_RETURN(CPB_ERR_PMPM_PAGE_UNAVAILABLE);
    }

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_pmpm_empty_page_get */

/*******************************************************************************
*  cpb_queue_current_blocks_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns the number of blocks allocated to a queue in a push-pop
*   CFC.
*
*
* INPUTS:
*   *cpb_handle               - pointer to CPB handle instance.
*   wqid                      - write queue id of the queue
*   num_pages                 - number of pages to walk through
*   *page_array               - the array of pages to walk through
*   *current_blocks_array     - the array of blocks to contain the result
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_queue_current_blocks_get(cpb_handle_t *cpb_handle,
                                               UINT32 wqid,
                                               UINT32 num_pages,
                                               UINT32 *page_array,
                                               UINT32 *current_blocks_array)
{
    /* Variable declaration */
#ifndef CPB_BLOCK_LIST
    UINT32 i,k;
    UINT32 num_current_blocks;

    PMC_ENTRY();

    num_current_blocks = 0;
    for(k = 0; k < num_pages; k++){
        for(i = 0; i < cpb_handle->cfg.blocks_per_page ; i++)
        {
            if(cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*page_array[k] + i].ipt_wqid ==
               wqid &&
               TRUE == cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*page_array[k] + i].ipt_valid)
                current_blocks_array[num_current_blocks++] = cpb_handle->cfg.blocks_per_page*page_array[k] + i;
        }
    }

#else
    UINT32 i,k;
    UINT32 num_current_blocks;
    UINT32 block_index;
    UINT32 write_port;
    UINT32 first_block;
    UINT32 queue_length;

    PMC_ENTRY();

    if (!num_pages) {
        PMC_RETURN(PMC_SUCCESS);
    }

    if (cpb_handle->cfg.cpb_type != CPB_INSTANCE_OCPB)  {
        /* Same as CPB_BLOCK_LIST undefined */
        num_current_blocks = 0;
        for(k = 0; k < num_pages; k++){
            for(i = 0; i < cpb_handle->cfg.blocks_per_page ; i++)
            {
                if(cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*page_array[k] + i].ipt_wqid ==
                   wqid &&
                   TRUE == cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*page_array[k] + i].ipt_valid)
                    current_blocks_array[num_current_blocks++] = cpb_handle->cfg.blocks_per_page*page_array[k] + i;
            }
        }
    } else {
        write_port = cpb_handle->var.page_inverted_page_table[page_array[0]].ctrl_ipt_wp_id;
        queue_length = cpb_handle->var.cpb_connect_data->queue_block[write_port][wqid].queue_length;
        first_block = cpb_handle->var.cpb_connect_data->queue_block[write_port][wqid].head_block;

        block_index = first_block;
        for (i=0; i<queue_length; i++) {
            current_blocks_array[i] = block_index;
            block_index = cpb_handle->var.block_inverted_page_table[block_index].ipt_queue_next;
        }
    }

#endif

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_queue_current_blocks_get */

/*******************************************************************************
*  cpb_queue_num_current_blocks_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns the number of blocks allocated to a queue FIFO in
*   the inverted page table.
*
* INPUTS:
*   *cpb_handle               - pointer to the CPB handle instance
*   wqid                      - write queue id
*   num_pages                 - number of pages to walk through, i.e., number of
*                               pages that are allocated to the push-pop CFC
*   *page_array               - the page array to walk through
*   *num_current_blocks_ptr   - pointer to the number of current blocks
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_queue_num_current_blocks_get( cpb_handle_t *cpb_handle,
                                                    UINT32 wqid,
                                                    UINT32 num_pages,
                                                    UINT32 *page_array,
                                                    UINT32 *num_current_blocks_ptr)
{
    /* Variable declaration */
#ifndef CPB_BLOCK_LIST
    UINT32 i,k;
    UINT32 num_current_blocks;


    PMC_ENTRY();

    num_current_blocks = 0;
    for(k = 0; k < num_pages; k++){
        for(i = 0; i < cpb_handle->cfg.blocks_per_page ; i++)
        {
            if(cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*page_array[k] + i].ipt_wqid ==
               wqid &&
               TRUE == cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*page_array[k] + i].ipt_valid)
                num_current_blocks++;
        }
    }

#else
    UINT32 i,k;
    UINT32 write_port;
    UINT32 queue_length;
    UINT32 num_current_blocks=0;

    if (cpb_handle->cfg.cpb_type != CPB_INSTANCE_OCPB) {
        /* same as CPB_BLOCK_LIST undefined */
        for(k = 0; k < num_pages; k++){
            for(i = 0; i < cpb_handle->cfg.blocks_per_page ; i++)
            {
                if(cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*page_array[k] + i].ipt_wqid ==
                   wqid &&
                   TRUE == cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*page_array[k] + i].ipt_valid)
                    num_current_blocks++;
            }
        }
    } else {

        queue_length = 0;
        if (num_pages) {
            write_port = cpb_handle->var.page_inverted_page_table[page_array[0]].ctrl_ipt_wp_id;
            queue_length = cpb_handle->var.cpb_connect_data->queue_block[write_port][wqid].queue_length;
        }

        num_current_blocks = queue_length;
    }
#endif

    /*PMC_LOG(PMC_LOG_SEV_LOW, CFC_LOG_CODE_LOG, 0, 0, "fifo_id = %u, num_current_pages= %u \n", fifo_id, num_current_pages);*/

    *num_current_blocks_ptr = num_current_blocks;
    PMC_LOG_TRACE("\nnumber of current blocks is : %u\n", num_current_blocks);

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_queue_num_current_blocks_get */

/*******************************************************************************
*  cpb_current_avail_blocks_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns the number of blocks in the given page array,
*   that are not currently assigned to any queue_id.
*
*
* INPUTS:
*   *cpb_handle         - pointer to CPB handle instance.
*   num_pages           - number of pages in the given array
*   *page_array         - pointer to the page array to be examined
*   *p_num_avail_blocks - pointer to the number of available blocks
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_current_avail_blocks_get( cpb_handle_t *cpb_handle,
                                                UINT32 num_pages,
                                                UINT32 *page_array,
                                                UINT32 *p_num_avail_blocks )
{
#ifndef CPB_BLOCK_LIST
    /* Variable declaration */
    UINT32 i,k;
    UINT32 num_avail_blocks = 0;

    PMC_ENTRY();

    num_avail_blocks = 0;
    for(k = 0; k < num_pages; k++){
        for(i = 0; i < cpb_handle->cfg.blocks_per_page ; i++)
        {
            if(FALSE == cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*page_array[k]+i].ipt_valid)
            {
                num_avail_blocks++;
            }
        }
    }

    *p_num_avail_blocks = num_avail_blocks;

    PMC_RETURN(PMC_SUCCESS);

#else

    /* Variable declaration */
    UINT32 i,k;
    UINT32 num_avail_blocks = 0;

    PMC_ENTRY();


    if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_OCPB) {
        for(k = 0; k < num_pages; k++) {
            num_avail_blocks += cpb_handle->var.page_inverted_page_table[page_array[k]].free_block_num;
        }
    } else {

        for(k = 0; k < num_pages; k++){
            for(i = 0; i < cpb_handle->cfg.blocks_per_page ; i++)
            {
                if(FALSE == cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*page_array[k]+i].ipt_valid)
                {
                    num_avail_blocks++;
                }
            }
        }
    }

    *p_num_avail_blocks = num_avail_blocks;

    PMC_RETURN(PMC_SUCCESS);

#endif

} /* cpb_current_avail_blocks_get */

/*******************************************************************************
*  cpb_qs_empty_block_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns an array of empty physical page address indices and
*   checks if there is enough empty rows left for the num pages.
*
* INPUTS:
*   *cpb_handle             - pointer to CPB handle instance.
*   push_port_id            - push port id, 1:1 mapped to the ingress mux out port
*   pop_port_id             - pop port id, 1:1 mapped to the egress mux input port
*   num_blocks              - number of blocks requested, if number of available
*                             blocks is greater than num_blocks, return SUCCESS,
*                             otherwise return FAIL
*   *available_block_array  - the array of indices for the available blocks
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_qs_empty_block_get( cpb_handle_t *cpb_handle,
                                          UINT32 push_port_id,
                                          UINT32 pop_port_id,
                                          UINT32 num_blocks,
                                          UINT32 *available_block_array )
{
    /* Variable declaration */
    UINT32 i,k;
    UINT32 available_block_count;
    UINT32 num_current_pages;
    UINT32 *current_page_array;
    PMC_ERROR ret_val;

    PMC_ENTRY();

    /* argument checking */
    if (push_port_id >= cpb_handle->cfg.push_port_num || pop_port_id >= cpb_handle->cfg.pop_port_num) {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    current_page_array = cpb_mem_pool_assign(cpb_handle, CPB_MEM_POOL_ID_1);
    PMC_ASSERT(current_page_array != NULL, CPB_ERR_CODE_ASSERT, 0, 0);

    if (!num_blocks) {
        PMC_RETURN(PMC_SUCCESS);
    }

    ret_val = cpb_qs_current_pages_get(cpb_handle,push_port_id,pop_port_id,&num_current_pages,current_page_array);
    if(ret_val){
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_1);
        PMC_RETURN(ret_val);
    }

    /* get all the empty blocks in the pages assigned to the QS */
    available_block_count = 0;
    for(i = 0; i < num_current_pages; i++)
    {
#ifndef CPB_BLOCK_LIST
        for(k = 0; k < cpb_handle->cfg.blocks_per_page; k++){
            if(CPB_PHYSICAL_BLOCK_EMPTY == cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*current_page_array[i]+k].ipt_valid)
            {
                available_block_array[available_block_count++] = cpb_handle->cfg.blocks_per_page*current_page_array[i]+k;
                if(available_block_count >= num_blocks)
                    break;
            }
        }

#else
        if (cpb_handle->cfg.cpb_type != CPB_INSTANCE_OCPB) {

            for(k = 0; k < cpb_handle->cfg.blocks_per_page; k++){
                if(CPB_PHYSICAL_BLOCK_EMPTY == cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*current_page_array[i]+k].ipt_valid)
                {
                    available_block_array[available_block_count++] = cpb_handle->cfg.blocks_per_page*current_page_array[i]+k;
                    if(available_block_count >= num_blocks)
                        break;
                }
            }
        } else {

            UINT32 free_block_num_in_page, free_block;
            UINT32 total_req_num_blocks;
            UINT32 left_req_num_blocks;
            UINT32 min;

            free_block_num_in_page = cpb_handle->var.page_inverted_page_table[current_page_array[i]].free_block_num;
            free_block = cpb_handle->var.page_inverted_page_table[current_page_array[i]].first_free_block;
            total_req_num_blocks = num_blocks;
            left_req_num_blocks = total_req_num_blocks - available_block_count;
            min = left_req_num_blocks > free_block_num_in_page?free_block_num_in_page:left_req_num_blocks; /* MIN(left_req_num_blocks, free_block_num) */
            for (k=0; k<min; k++) {
                available_block_array[available_block_count++] = free_block;
                free_block = cpb_handle->var.block_inverted_page_table[free_block].ipt_queue_next;
            }
        }
#endif

        if(available_block_count >= num_blocks)
            break;
    }

    PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "available_block_count = %u \n", available_block_count);

    /* check if enough number of blocks are available */
    if(num_blocks > available_block_count)
    {
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_1);
        PMC_RETURN(CPB_ERR_PMPM_BLOCK_UNAVAILABLE); /* return error the not enough pages available */
    }

    cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_1);
    PMC_RETURN(PMC_SUCCESS);

} /* cpb_qs_empty_block_get */

#ifndef DOXYGEN_PUBLIC_ONLY
#ifdef CPB_BLOCK_LIST

/*******************************************************************************
*  cpb_queue_block_check
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function checks the consistency of queue_block[][] in cpb.
*
* INPUTS:
*   *cpb_handle             - pointer to CPB handle instance.
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_queue_block_check( cpb_handle_t *cpb_handle )
{
    PMC_ERROR ret_val=PMC_SUCCESS;
    UINT32 i,j;
    UINT32 page_index;
    UINT32 head_block, tail_block, queue_length;
    UINT32 p,q; /* go through queue */
    UINT32 flag;

    UINT32 free_block_num;
    UINT32 first_free_block;
    UINT32 counted_free_block_num;

    PMC_ENTRY();

    /* 1) check queue_block, i.e. used blocks */
    for (i=0;i<4;i++) {
        for (j=0; j<UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_CHNLS_PER_PORT; j++) {
            head_block = cpb_handle->var.cpb_connect_data->queue_block[i][j].head_block;
            tail_block = cpb_handle->var.cpb_connect_data->queue_block[i][j].tail_block;
            queue_length = cpb_handle->var.cpb_connect_data->queue_block[i][j].queue_length;

            if (queue_length == 0) {
                if (head_block != CPB_NULL_BLOCK_ID || tail_block != CPB_NULL_BLOCK_ID) {
                    PMC_RETURN(CPB_ERR_CODE_ASSERT);
                }
            } else {

                if (head_block == CPB_NULL_BLOCK_ID || tail_block == CPB_NULL_BLOCK_ID) {
                    PMC_RETURN(CPB_ERR_CODE_ASSERT);
                }

                flag=0;
                flag |= cpb_handle->var.block_inverted_page_table[tail_block].ipt_lba != (queue_length-1);
                flag |= cpb_handle->var.block_inverted_page_table[head_block].ipt_lba != 0;
                /* for valid queue, both tail.next and head.prev should be NULL */
                flag |= cpb_handle->var.block_inverted_page_table[tail_block].ipt_queue_next != CPB_NULL_BLOCK_ID;
                flag |= cpb_handle->var.block_inverted_page_table[head_block].ipt_queue_prev != CPB_NULL_BLOCK_ID;

                if (flag) {
                    PMC_RETURN(CPB_ERR_CODE_ASSERT);
                }

                p = head_block;
                q = cpb_handle->var.block_inverted_page_table[p].ipt_queue_next;
                while (CPB_NULL_BLOCK_ID != q) {
                    flag |= cpb_handle->var.block_inverted_page_table[p].ipt_lba+1 != cpb_handle->var.block_inverted_page_table[q].ipt_lba;
                    flag |= cpb_handle->var.block_inverted_page_table[q].ipt_queue_prev != p;
                    /* move to next */
                    p = q;
                    q = cpb_handle->var.block_inverted_page_table[q].ipt_queue_next;
                }

                if (flag) {
                    PMC_RETURN(CPB_ERR_CODE_ASSERT);
                }
            }
        }
    }

    /* 2) check free blocks */
    for (page_index=0; page_index < cpb_handle->cfg.num_pages; page_index++) {
        free_block_num = cpb_handle->var.page_inverted_page_table[page_index].free_block_num;
        first_free_block = cpb_handle->var.page_inverted_page_table[page_index].first_free_block;

        if (free_block_num == 0) {
            if (first_free_block != CPB_NULL_BLOCK_ID) {
                PMC_RETURN(CPB_ERR_CODE_ASSERT);
            }
        } else {
            if (first_free_block == CPB_NULL_BLOCK_ID) {
                PMC_RETURN(CPB_ERR_CODE_ASSERT);
            }

            /* ensure the block id is in the current page */
            if (first_free_block / cpb_handle->cfg.blocks_per_page != page_index) {
                PMC_RETURN(CPB_ERR_CODE_ASSERT);
            }

            flag=0;
            counted_free_block_num=1;
            p = first_free_block;
            q = cpb_handle->var.block_inverted_page_table[p].ipt_queue_next;
            while (CPB_NULL_BLOCK_ID != q && !flag) {
                counted_free_block_num++;
                flag |= q / cpb_handle->cfg.blocks_per_page != page_index;
                flag |= cpb_handle->var.block_inverted_page_table[q].ipt_queue_prev != p;
                /* move to next */
                p=q;
                q=cpb_handle->var.block_inverted_page_table[q].ipt_queue_next;
            }

            if (flag || counted_free_block_num != free_block_num) {
                PMC_RETURN(CPB_ERR_CODE_ASSERT);
            }
        }
    }

    PMC_RETURN(ret_val);
} /* cpb_queue_block_check */

/*******************************************************************************
*  cpb_queue_block_dump
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function dumps used and free blocks information for debug purpose.
*
* INPUTS:
*   *cpb_handle             - pointer to CPB handle instance.
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_queue_block_dump( cpb_handle_t *cpb_handle )
{
    PMC_ERROR ret_val=PMC_SUCCESS;
    UINT32 i,j;
    UINT32 page_index;
    UINT32 head_block, tail_block, queue_length;
    UINT32 p,q; /* go through queue */
    UINT32 flag;

    UINT32 free_block_num;
    UINT32 first_free_block;
    UINT32 counted_free_block_num;

    PMC_ENTRY();

    PMC_LOG_TRACE("=========================[%s]=========================\n", __FUNCTION__);
    PMC_LOG_TRACE("USED BLOCKS IN PUSH QUEUES:\n");
    /* 1) check and dump queue_block, i.e. used blocks */
    for (i=0;i<4;i++) {
        for (j=0; j<UTIL_GLOBAL_CPB_CONNECT_MAX_NUM_CHNLS_PER_PORT; j++) {

            head_block = cpb_handle->var.cpb_connect_data->queue_block[i][j].head_block;
            tail_block = cpb_handle->var.cpb_connect_data->queue_block[i][j].tail_block;
            queue_length = cpb_handle->var.cpb_connect_data->queue_block[i][j].queue_length;

            if (queue_length == 0) {
                if (head_block != CPB_NULL_BLOCK_ID || tail_block != CPB_NULL_BLOCK_ID) {
                    PMC_RETURN(CPB_ERR_CODE_ASSERT);
                }
                /* PMC_LOG_TRACE("NULL queue\n"); */
            } else {
                PMC_LOG_TRACE("queue_block[%d][%d] length:%d [page:block]\n", i, j, queue_length);

                if (head_block == CPB_NULL_BLOCK_ID || tail_block == CPB_NULL_BLOCK_ID) {
                    PMC_RETURN(CPB_ERR_CODE_ASSERT);
                }

                flag=0;
                flag |= cpb_handle->var.block_inverted_page_table[tail_block].ipt_lba != (queue_length-1);
                flag |= cpb_handle->var.block_inverted_page_table[head_block].ipt_lba != 0;
                /* for valid queue, both tail.next and head.prev should be NULL */
                flag |= cpb_handle->var.block_inverted_page_table[tail_block].ipt_queue_next != CPB_NULL_BLOCK_ID;
                flag |= cpb_handle->var.block_inverted_page_table[head_block].ipt_queue_prev != CPB_NULL_BLOCK_ID;

                if (flag) {
                    PMC_RETURN(CPB_ERR_CODE_ASSERT);
                }

                PMC_LOG_TRACE("%03dth 0x%02x:0x%02x\n", cpb_handle->var.block_inverted_page_table[head_block].ipt_lba, 
                    head_block/cpb_handle->cfg.blocks_per_page, head_block%cpb_handle->cfg.blocks_per_page);

                p = head_block;
                q = cpb_handle->var.block_inverted_page_table[p].ipt_queue_next;
                while (CPB_NULL_BLOCK_ID != q && !flag) {

                    PMC_LOG_TRACE("%03dth 0x%02x:0x%02x\n", cpb_handle->var.block_inverted_page_table[q].ipt_lba, 
                        q/cpb_handle->cfg.blocks_per_page, q%cpb_handle->cfg.blocks_per_page);

                    flag |= cpb_handle->var.block_inverted_page_table[p].ipt_lba+1 != cpb_handle->var.block_inverted_page_table[q].ipt_lba;
                    flag |= cpb_handle->var.block_inverted_page_table[q].ipt_queue_prev != p;
                    /* move to next */
                    p = q;
                    q = cpb_handle->var.block_inverted_page_table[q].ipt_queue_next;
                }

                if (flag) {
                    PMC_RETURN(CPB_ERR_CODE_ASSERT);
                }
            }
        }
    }

    /* 2) check and dump free blocks */
    PMC_LOG_TRACE("\nFREE BLOCKS IN PAGES:\n");
    for (page_index=0; page_index < cpb_handle->cfg.num_pages; page_index++) {

        free_block_num = cpb_handle->var.page_inverted_page_table[page_index].free_block_num;
        first_free_block = cpb_handle->var.page_inverted_page_table[page_index].first_free_block;

        if (free_block_num == 0) {
            if (first_free_block != CPB_NULL_BLOCK_ID) {
                PMC_RETURN(CPB_ERR_CODE_ASSERT);
            }
            /* PMC_LOG_TRACE("fully used page\n"); */
        } else {
            if (first_free_block == CPB_NULL_BLOCK_ID) {
                PMC_RETURN(CPB_ERR_CODE_ASSERT);
            }

            /* ensure the block id is in the current page */
            if (first_free_block / cpb_handle->cfg.blocks_per_page != page_index) {
                PMC_RETURN(CPB_ERR_CODE_ASSERT);
            }

            if (free_block_num != cpb_handle->cfg.blocks_per_page) { /* only dump partially free page */
                PMC_LOG_TRACE("page:%d partially free, with free blocks:\n", page_index);
                PMC_LOG_TRACE("00th: 0x%02x\n", first_free_block % cpb_handle->cfg.blocks_per_page);
            }

            flag=0;
            counted_free_block_num=1;
            p = first_free_block;
            q = cpb_handle->var.block_inverted_page_table[p].ipt_queue_next;
            while (CPB_NULL_BLOCK_ID != q && !flag) {
                if (free_block_num != cpb_handle->cfg.blocks_per_page) { /* only dump partially free page */
                    PMC_LOG_TRACE("%02xth: 0x%02x\n", counted_free_block_num, q % cpb_handle->cfg.blocks_per_page);
                }

                counted_free_block_num++;
                flag |= q / cpb_handle->cfg.blocks_per_page != page_index;
                flag |= cpb_handle->var.block_inverted_page_table[q].ipt_queue_prev != p;
                /* move to next */
                p=q;
                q=cpb_handle->var.block_inverted_page_table[q].ipt_queue_next;
            }

            if (flag || counted_free_block_num != free_block_num) {
                PMC_RETURN(CPB_ERR_CODE_ASSERT);
            }
        }
    }

    PMC_RETURN(ret_val);
} /* cpb_queue_block_dump */

#endif
#endif

/*******************************************************************************
* cpb_slv_chnl_qs_ch_en_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function retrieves the expected QSn_CH_EN bits that should be set
*   for a DPI Slave Port Channel.
*
* INPUTS:
*   *cpb_handle                   - The pointer to the CPB instance.
*   ingress_mux_input_port        - DPI Slave Port
*   ingress_mux_input_port_chnl   - DPI Slave Port Channel
*
* OUTPUTS:
*   *qs_ch_en_ptr                 - Pointer updated by API call with the
*                                   set of QSn_CH_EN bits for active channels\n
*                                   Bit 0 set: QS0_CH_EN set\n
*                                   Bit 1 set: QS1_CH_EN set\n
*                                   Bit 2 set: QS2_CH_EN set\n
*                                   Bit 3 set: QS3_CH_EN set\n
*                                   Bits 4 to 7: not used
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_slv_chnl_qs_ch_en_get(cpb_handle_t *cpb_handle,
                                      UINT32 ingress_mux_input_port,
                                      UINT32 ingress_mux_input_port_chnl,
                                      UINT8  *qs_ch_en_ptr)
{

    UINT32 push_port, wid, dcs_rd_channel_id, temp_slave_port, temp_slave_channel, i, j;
    util_schd_chnl_state_t chnl_state;
    UINT32 queue_index;
    UINT32 num_sched_chan;
    cpb_fifo_var_t  *fifo_var_data;


    PMC_ENTRY();

    *qs_ch_en_ptr = 0;

    for(i=0;i < cpb_handle->cfg.num_queue_systems;i++) /* i is the DCS number (also queue system */
    {
        num_sched_chan = cpb_num_sched_chans_get(cpb_handle,i);
        queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, i, 0);
        fifo_var_data = &cpb_handle->var.fifo_var_data[queue_index];

        for(j=0;j < num_sched_chan;j++) /* j is the read queue id */
        {

            if(fifo_var_data->status == CPB_FIFO_BEING_USED)
            {
                push_port = fifo_var_data->push_port_id;
                wid = fifo_var_data->write_id;

                if(cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB)
                {
                    cpb_ingress_mux_port_chnl_get(cpb_handle,
                                                  push_port,
                                                  wid,
                                                  &temp_slave_port,
                                                  &temp_slave_channel);
                }
                else
                {
                    cpb_mcpb_ingress_mux_port_chnl_get(cpb_handle,
                                                       push_port,
                                                       wid,
                                                       i, /* interpretted as pop port for MCPB instance */
                                                       &temp_slave_port,
                                                       &temp_slave_channel);
                }

                if(temp_slave_port == ingress_mux_input_port &&
                   temp_slave_channel == ingress_mux_input_port_chnl)
                {
                    util_schd_dcs_chnl_data_get(cpb_handle->util_schd_handle[i],
                                                j, /* read qid */
                                                &chnl_state,
                                                &dcs_rd_channel_id,
                                                &push_port,
                                                &wid);

                    if(chnl_state == UTIL_SCHD_CHNL_OPERATIONAL)
                    {
                        *qs_ch_en_ptr |= (1<<i);
                    }
                }
            }
            fifo_var_data++;
        }
    }

    PMC_RETURN();

} /* cpb_slv_chnl_qs_ch_en_get() */

/*******************************************************************************
* cpb_slv_chnl_qs_ch_en_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function configures QSn_CH_EN bits for a DPI Slave Port Channel.
*
* INPUTS:
*   *cpb_handle                   - The pointer to the CPB instance.
*   ingress_mux_input_port        - DPI Slave Port
*   ingress_mux_input_port_chnl   - DPI Slave Port Channel
*   enable                        - 0: Disable the corresponding QSn_CH_EN bits\n
*                                   1: Enable the corresponding QSn_CH_EN bits
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_slv_chnl_qs_ch_en_set(cpb_handle_t *cpb_handle,
                                      UINT32 ingress_mux_input_port,
                                      UINT32 ingress_mux_input_port_chnl,
                                      UINT32 enable)
{

    slave_dpi_buffer_t slave_dpi_buffer;

    PMC_ENTRY();

    slave_dpi_buffer_init(&slave_dpi_buffer, cpb_handle, ingress_mux_input_port);

    slave_dpi_field_QS0_CH_EN_set(&slave_dpi_buffer, cpb_handle, ingress_mux_input_port, ingress_mux_input_port_chnl,  enable & 0x1);
    slave_dpi_field_QS1_CH_EN_set(&slave_dpi_buffer, cpb_handle, ingress_mux_input_port, ingress_mux_input_port_chnl, (enable & 0x2) >> 1);
    slave_dpi_field_QS2_CH_EN_set(&slave_dpi_buffer, cpb_handle, ingress_mux_input_port, ingress_mux_input_port_chnl, (enable & 0x4) >> 2);
    slave_dpi_field_QS3_CH_EN_set(&slave_dpi_buffer, cpb_handle, ingress_mux_input_port, ingress_mux_input_port_chnl, (enable & 0x8) >> 3);

    slave_dpi_buffer_flush(&slave_dpi_buffer);

    PMC_RETURN();

} /* cpb_slv_chnl_qs_ch_en_set() */

/*******************************************************************************
* cpb_slv_chnl_qs_ch_en_get_all
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function retrieves the expected QSn_CH_EN bits that should be set
*   for an array of DPI Slave Port Channels.
*
* INPUTS:
*   *cpb_handle                         - The pointer to the CPB instance.
*   ingress_mux_input_port              - DPI Slave Port
*   *ingress_mux_input_port_chnl_ptr    - Pointer to an array of DPI Slave Port Channels
*   enable                              - Indicates if this is part of provisioning or not
*                                         FALSE -- deactivate
*                                         TRUE  -- activate
*
* OUTPUTS:
*   *qs_ch_en_ptr                 - Pointer updated by API call with the
*                                   set of QSn_CH_EN bits for active channels\n
*                                   Bit 0 set: QS0_CH_EN set\n
*                                   Bit 1 set: QS1_CH_EN set\n
*                                   Bit 2 set: QS2_CH_EN set\n
*                                   Bit 3 set: QS3_CH_EN set\n
*                                   Bits 4 to 7: not used
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_ocpb_slv_chnl_qs_ch_en_get_all(cpb_handle_t *cpb_handle,
                                               UINT32 ingress_mux_input_port,
                                               UINT32 *ingress_mux_input_port_chnl_ptr,
                                               BOOL8  enable,
                                               UINT8  *qs_ch_en_ptr)
{

    UINT32 push_port, wid, dcs_rd_channel_id, i, j;
    util_schd_chnl_state_t chnl_state;
    UINT32 queue_index;
    UINT32 k;
    cpb_fifo_var_t *fifo_var_data;

    PMC_ENTRY();

    *qs_ch_en_ptr = 0;

    if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_OCPB)
    {
        for(i=0;i < cpb_handle->cfg.num_queue_systems;i++) /* i is the DCS number (also queue system */
        {
            queue_index = i * CPB_MAX_FIFO_NUM;
            fifo_var_data = &cpb_handle->var.fifo_var_data[queue_index];
            for(j=0;j < CPB_MAX_FIFO_NUM;j++) /* j is the read queue id */
            {

                if(fifo_var_data->status == CPB_FIFO_BEING_USED)
                {
                    push_port = fifo_var_data->push_port_id;
                    wid = fifo_var_data->write_id;

                    for (k = 0; k < 96; k++)
                    {
                        if (ingress_mux_input_port_chnl_ptr[k] != 0xFF)
                        {
                            /* go through all channel IDs in ingress_mux_input_port_chnl_ptr[] */
                            if (push_port == ingress_mux_input_port 
                                && wid == ingress_mux_input_port_chnl_ptr[k])
                            {
                                util_schd_dcs_chnl_data_get(cpb_handle->util_schd_handle[i],
                                                            j, /* read qid */
                                                            &chnl_state,
                                                            &dcs_rd_channel_id,
                                                            &push_port,
                                                            &wid);

                                if((enable == FALSE && chnl_state == UTIL_SCHD_CHNL_EQUIPPED)
                                   || (enable == TRUE && chnl_state == UTIL_SCHD_CHNL_OPERATIONAL))
                                {
                                    qs_ch_en_ptr[k] |= (1<<i);
                                }
                            }
                        }
                        else {
                            break;
                        }
                    }
                }
                fifo_var_data++;
            }
        }
    }
    
    PMC_RETURN();

} /* cpb_ocpb_slv_chnl_qs_ch_en_get_all() */

/*******************************************************************************
*  cpb_queue_memory_allocate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function allocates memory to a queue (FIFO) based on the number of pages it
*   needs for the application using the queue. This is done via the block inverted
*   page table, by allocating a physical block to each virtual block needed by the
*   queue
*
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*   queue_id               - write queue ID of the queue
*   num_current_blocks     - number of blocks curretnly allocated to the queue
*   num_blocks_requested   - number of blocks to requested by the queue
*   *available_block_array - array of available blocks in the block IPT
*
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_queue_memory_allocate(cpb_handle_t *cpb_handle,
                                            UINT32 queue_id,
                                            UINT32 num_current_blocks,
                                            UINT32 num_blocks_requested,
                                            UINT32 *available_block_array)
{
    /* Variable declaration */
    UINT32 virtual_block;
    UINT32 page_index;
    UINT32 block_index;
#ifdef CPB_BLOCK_LIST
    UINT32 prev, next;
    UINT32 phy_block_id, tail_block;
    UINT32 push_port_id=0xFFFFFFFF;
#endif

    PMC_ENTRY();

    PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "queue_id = %u, num_current_blocks = %u, num_blocks_requested = %u\n", queue_id, num_current_blocks, num_blocks_requested);

    if (num_blocks_requested < num_current_blocks) {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    for(virtual_block = 0; virtual_block < (num_blocks_requested-num_current_blocks); virtual_block++)
    {
        /* allocate the physical block to the queue virtual page by programming
           the WQ ID and Virutal block into the block inverted page table entry
           which represnet the physical block */

        /* Apply field settings */
        PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "virtual_block = %u, available_block_array[virtual_block]=%u\n", virtual_block, available_block_array[virtual_block]);
        PMC_ASSERT(cpb_handle->cfg.blocks_per_page != 0, CPB_ERR_DIVIDED_BY_ZERO,0,0);
        page_index = available_block_array[virtual_block] / cpb_handle->cfg.blocks_per_page;
        block_index = available_block_array[virtual_block] % cpb_handle->cfg.blocks_per_page;
        cpb_block_table_cfg(cpb_handle, FALSE, page_index, block_index, 1, queue_id, num_current_blocks + virtual_block);

#ifdef CPB_BLOCK_LIST
        if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_OCPB) {
            /* remove the block from the free list and attach it into the write queue */
            phy_block_id = available_block_array[virtual_block];
            prev = cpb_handle->var.block_inverted_page_table[phy_block_id].ipt_queue_prev;
            next = cpb_handle->var.block_inverted_page_table[phy_block_id].ipt_queue_next; /* both prev and next could be NULL */
            if (CPB_NULL_BLOCK_ID != prev) {
                cpb_handle->var.block_inverted_page_table[prev].ipt_queue_next = next;
            }
            if (CPB_NULL_BLOCK_ID != next) {
                cpb_handle->var.block_inverted_page_table[next].ipt_queue_prev = prev;
            }

            if (cpb_handle->var.page_inverted_page_table[page_index].first_free_block == phy_block_id) {
                cpb_handle->var.page_inverted_page_table[page_index].first_free_block = next; /* no matter if next is NULL */
            }

            cpb_handle->var.page_inverted_page_table[page_index].free_block_num--;
            cpb_handle->var.block_inverted_page_table[phy_block_id].ipt_queue_prev = CPB_NULL_BLOCK_ID;
            cpb_handle->var.block_inverted_page_table[phy_block_id].ipt_queue_next = CPB_NULL_BLOCK_ID;

            /* append the new phy_block_id to the queue tail */
            if (0xFFFFFFFF == push_port_id) {
                push_port_id = cpb_handle->var.page_inverted_page_table[page_index].ctrl_ipt_wp_id;
            } else {
                PMC_ASSERT(push_port_id == cpb_handle->var.page_inverted_page_table[page_index].ctrl_ipt_wp_id, CPB_ERR_CODE_ASSERT, 0, 0);
            }
            if (cpb_handle->var.cpb_connect_data->queue_block[push_port_id][queue_id].queue_length == 0) {
                /* Inserting the first block into queue */
                cpb_handle->var.cpb_connect_data->queue_block[push_port_id][queue_id].head_block = phy_block_id;
                cpb_handle->var.cpb_connect_data->queue_block[push_port_id][queue_id].tail_block = phy_block_id;
            } else {
                tail_block = cpb_handle->var.cpb_connect_data->queue_block[push_port_id][queue_id].tail_block;
                cpb_handle->var.block_inverted_page_table[tail_block].ipt_queue_next = phy_block_id;
                cpb_handle->var.block_inverted_page_table[phy_block_id].ipt_queue_prev = tail_block;
                cpb_handle->var.cpb_connect_data->queue_block[push_port_id][queue_id].tail_block = phy_block_id;
            }
            cpb_handle->var.cpb_connect_data->queue_block[push_port_id][queue_id].queue_length++;
        }
#endif
    }

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_queue_memory_allocate */



/*******************************************************************************
*  cpb_fifo_end_addr_cal
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function calculates and returns the end address that needs to be
*   configured based on the number of pages for a FIFO.
*
* INPUTS:
*   *cpb_handle      - pointer to CPB handle instance.
*   read_qid         - read queue id of the queue
*   num_blocks       - number of blocks needed for queue
*   *end_addr_ptr    - pointer to the end address
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_fifo_end_addr_cal( cpb_handle_t *cpb_handle,
                                         UINT32 read_qid,
                                         UINT32 num_blocks,
                                         UINT32 *end_addr_ptr )
{
    /* Variable declaration */
    UINT32 end_address;
    PMC_ENTRY();


    end_address = num_blocks*cpb_handle->cfg.bursts_per_block-1;

    PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "read_queue_id = %u, end_address= %u\n", read_qid, end_address);

    *end_addr_ptr = end_address;

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_fifo_end_addr_cal */

/*******************************************************************************
*  cpb_queue_memory_deallocate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function deallocates memory of a queue based on the number of blocks it
*   needs to be removed for the queue. This is done via the block inverted page
*   table, by marking the Valid bit, WID and Virtual page as unallocated
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   push_port_id          - Push port identified
*   write_qid             - Write Queue identifier
*   num_current_blocks    - number of blocks curretnly allocated to the FIFO
*   num_blocks_requested  - number of blocks to be allocated to the FIFO
*   *excess_block_array   - the array of excess blocks
*
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_queue_memory_deallocate( cpb_handle_t *cpb_handle,
                                               UINT32 push_port_id,
                                               UINT32 write_qid,
                                               UINT32 num_current_blocks,
                                               UINT32 num_blocks_requested,
                                               UINT32 *excess_block_array )
{
    /* Variable declaration */
    UINT32 page_index;
    UINT32 block_index; /* inside page */
    UINT32 num_block_to_free = num_current_blocks - num_blocks_requested;
    UINT32 num_freed_block = 0;
    UINT32 i;
#ifdef CPB_BLOCK_LIST
    UINT32 block_id, freed_block_id; /* universal */
    UINT32 first_free_block_in_page;
#endif
    PMC_ENTRY();

    if (!num_block_to_free) {
        PMC_RETURN(PMC_SUCCESS);
    }

    PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "num_current_blocks = %u, num_blocks_requested = %u\n",num_current_blocks, num_blocks_requested);

#ifndef CPB_BLOCK_LIST
    for(i = 0; i < num_current_blocks; i++)
    {
        if(cpb_handle->var.block_inverted_page_table[excess_block_array[i]].ipt_lba >= num_blocks_requested)
        {
            PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "virtual_page = %u, excess_block_array[virtual_block]=%u\n", i, excess_block_array[i]);
            page_index = excess_block_array[i] / cpb_handle->cfg.blocks_per_page;
            block_index = excess_block_array[i] % cpb_handle->cfg.blocks_per_page;

            cpb_block_table_cfg(cpb_handle, FALSE, page_index, block_index, 0, 0, 0);
            num_freed_block++;
        }
    }

    PMC_ASSERT(num_freed_block == num_block_to_free, CPB_ERR_CODE_ASSERT, 0, 0);

#else
    if (cpb_handle->cfg.cpb_type != CPB_INSTANCE_OCPB) {
        /* same as CPB_BLOCK_LIST undefined */
        for(i = 0; i < num_current_blocks; i++)
        {
            if(cpb_handle->var.block_inverted_page_table[excess_block_array[i]].ipt_lba >= num_blocks_requested)
            {
                PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "virtual_page = %u, excess_block_array[virtual_block]=%u\n", i, excess_block_array[i]);
                page_index = excess_block_array[i] / cpb_handle->cfg.blocks_per_page;
                block_index = excess_block_array[i] % cpb_handle->cfg.blocks_per_page;

                cpb_block_table_cfg(cpb_handle, FALSE, page_index, block_index, 0, 0, 0);
                num_freed_block++;
            }
        }

        PMC_ASSERT(num_freed_block == num_block_to_free, CPB_ERR_CODE_ASSERT, 0, 0);
    } else {

        block_id = cpb_handle->var.cpb_connect_data->queue_block[push_port_id][write_qid].tail_block;
        PMC_ASSERT(cpb_handle->var.cpb_connect_data->queue_block[push_port_id][write_qid].queue_length>=num_block_to_free, CPB_ERR_CODE_ASSERT, 0, 0);
        for (i=0; i<num_block_to_free; i++) {
            page_index = block_id / cpb_handle->cfg.blocks_per_page;
            block_index = block_id % cpb_handle->cfg.blocks_per_page; /* can do it with bitmask operation? */
            cpb_block_table_cfg(cpb_handle, FALSE, page_index, block_index, 0, 0, 0);

            freed_block_id = block_id;
            block_id = cpb_handle->var.block_inverted_page_table[block_id].ipt_queue_prev;

            /* remove this block from queue */
            cpb_handle->var.cpb_connect_data->queue_block[push_port_id][write_qid].queue_length--;
            cpb_handle->var.cpb_connect_data->queue_block[push_port_id][write_qid].tail_block = block_id;
            cpb_handle->var.block_inverted_page_table[freed_block_id].ipt_queue_prev = CPB_NULL_BLOCK_ID;
            cpb_handle->var.block_inverted_page_table[freed_block_id].ipt_queue_next = CPB_NULL_BLOCK_ID;

            /* insert it into free list */
            first_free_block_in_page = cpb_handle->var.page_inverted_page_table[page_index].first_free_block;
            cpb_handle->var.block_inverted_page_table[freed_block_id].ipt_queue_next = first_free_block_in_page;
            if (first_free_block_in_page != CPB_NULL_BLOCK_ID) {
                cpb_handle->var.block_inverted_page_table[first_free_block_in_page].ipt_queue_prev = freed_block_id;
            }
            cpb_handle->var.page_inverted_page_table[page_index].first_free_block = freed_block_id;
            cpb_handle->var.page_inverted_page_table[page_index].free_block_num++;
        }
        /*
        cpb_handle->var->queue_block[push_port_id][write_qid].queue_length = num_blocks_requested;
        cpb_handle->var->queue_block[push_port_id][write_qid].tail_block = block_id;
        */
        if (0 == cpb_handle->var.cpb_connect_data->queue_block[push_port_id][write_qid].queue_length) {
            cpb_handle->var.cpb_connect_data->queue_block[push_port_id][write_qid].head_block = CPB_NULL_BLOCK_ID;
            cpb_handle->var.cpb_connect_data->queue_block[push_port_id][write_qid].tail_block = CPB_NULL_BLOCK_ID;
        }
        num_freed_block = num_block_to_free; /* suppress warning */
    }
#endif

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_queue_memory_deallocate */

/*******************************************************************************
*  cpb_pmpm_queue_system_page_assign
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function assigns the requested number of PMPM pages to a queue system
*   instance.\n\n
*
*   The function takes in the total number of pages to be assigned to the
*   queue system and accounts for any pages already assigned to the queue
*   system.  Based on the desired pages it will either add or remove pages
*   from the queue system.\n\n
*
*   In order to successfully remove a page from a queue system none of the
*   blocks within the page can be assigned to a queue instance.  In the
*   event that the requested number of pages cannot be removed because the
*   pages are in use an error will be returned CPB_ERR_PMPM_PAGE_UNRELEASEABLE.\n\n
*
*   In the event that pages are requested for addition to a queue system and
*   no free pages are available an error will be returned
*   CPB_ERR_PMPM_PAGE_UNAVAILABLE.
*
*
* INPUTS:
*   *cpb_handle       - pointer to CPB handle instance.
*   push_port_id      - Ingress Mux Output Port to have PMPM page
*                       assigned\n
*                       0 to 3
*   pop_port_id       - 1:1 mapped with egress mux input ports.\n
*                       0 to 3
*   mfege_pop_port_id - MGMT FEGE 1:1 mapped with egress mux input ports.\n
*                       0 to 3
*   num_pages         - number of pages to associate with the CFC.
*
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_pmpm_queue_system_page_assign( cpb_handle_t *cpb_handle,
                                                     UINT32 push_port_id,
                                                     UINT32 pop_port_id,
                                                     UINT32 mfege_pop_port_id,
                                                     UINT32 num_pages )
{
    /* Variable declaration */
    UINT32 i,k;
    UINT32 num_current_pages;
    UINT32 *current_page_array;
    UINT32 *temp_page_array;
    PMC_ERROR ret_val;
    UINT32 num_releasable_pages;
    BOOL8   releasable;
    UINT32 num_pages_freed = CPB_INVALID_REMAP_VALUE;
    UINT32 num_pages_failed  = CPB_INVALID_REMAP_VALUE;

    PMC_ENTRY();

    PMC_LOG_TRACE("Requesting %u pages from PMPM ", num_pages);
    if(num_pages>cpb_handle->cfg.num_pages){
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }
    current_page_array = cpb_mem_pool_assign(cpb_handle, CPB_MEM_POOL_ID_3);
    PMC_ASSERT(current_page_array != NULL, CPB_ERR_CODE_ASSERT, 0, 0);
    temp_page_array = current_page_array + cpb_handle->cfg.num_pages;

    ret_val = cpb_qs_current_pages_get(cpb_handle,push_port_id,pop_port_id,&num_current_pages,current_page_array);
    if(ret_val){
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_3);
        PMC_RETURN(ret_val);
    }

    if(num_current_pages<num_pages){ /* need to allocate new pages to QS */

        ret_val = cpb_pmpm_empty_page_get(cpb_handle, num_pages - num_current_pages, temp_page_array);

        if(pmc_cpb_pmpm_block_remap(&cpb_handle->base))
        {
            if(ret_val == CPB_ERR_PMPM_PAGE_UNAVAILABLE)
            {
                /*If there are not enough PMPM pages we can try to free some using
                * the block remap feature */
                for(i=0;i<cpb_handle->cfg.num_pages-1 && num_pages_freed != 0;i++)
                {
                    ret_val = cpb_pmpm_recover_pages(cpb_handle,
                                                     &num_pages_freed,
                                                     &num_pages_failed);

                }

                if(ret_val == PMC_SUCCESS)
                    ret_val = cpb_pmpm_empty_page_get(cpb_handle, num_pages - num_current_pages, temp_page_array);
            }
        }


        if (ret_val) {
            cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_3);
            PMC_RETURN(ret_val);
        }

        for(i = 0; i < (num_pages - num_current_pages); i++)
        {
            /* allocate the physical page to the QS */
            /* Apply field settings */
            PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "virtual_page = %u, excess_page_array[virtual_page]=%u\n", i, temp_page_array[i]);
            cpb_page_table_cfg(cpb_handle, temp_page_array[i], TRUE , push_port_id,pop_port_id, mfege_pop_port_id);
        }

    } else if(num_current_pages>num_pages){ /* need to release current pages from QS */

        num_releasable_pages = 0;

        for(i = 0; i < cpb_handle->cfg.num_pages; i++)
        {
            temp_page_array[i]= cpb_handle->cfg.page_null_entry;
        }

        for(i = 0; i < num_current_pages; i++)
        {
            releasable = 1;
            for(k = 0; k < cpb_handle->cfg.blocks_per_page; k++){
                if(cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*current_page_array[i]+k].ipt_valid != FALSE) {
                        releasable = 0;
                        break;
            }
            }
            if(1 == releasable){
                temp_page_array[num_releasable_pages++] = i;
            }
        }

        if(num_releasable_pages < num_current_pages - num_pages){
            cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_3);
            PMC_RETURN(CPB_ERR_PMPM_PAGE_UNRELEASEABLE);
        } else {
            for(i = 0; i < num_current_pages - num_pages; i++) {

                PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "virtual_page = %u, excess_page_array[virtual_page]=%u\n", i, temp_page_array[i]);
                cpb_page_table_cfg(cpb_handle, temp_page_array[i], FALSE, 0, 0, 0);
            }
        }

    }
    cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_3);
    PMC_RETURN(PMC_SUCCESS);
} /* cpb_pmpm_queue_system_page_assign */

/*******************************************************************************
*  cpb_pmpm_queue_system_page_release
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function releases the pages assigned to the push/pop ports. It tries to
*   release as many pages as they can detect that does not have any block being
*   used.
*
* INPUTS:
*   *cpb_handle       - pointer to CPB handle instance.
*   push_port_id      - Ingress Mux Output Port to have PMPM page
*                       assigned\n
*                       0 to 3
*   pop_port_id       - 1:1 mapped with egress mux input ports.\n
*                       0 to 3
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_pmpm_queue_system_page_release( cpb_handle_t *cpb_handle,
                                                      UINT32 push_port_id,
                                                      UINT32 pop_port_id )
{
    /* Variable declaration */
    UINT32 i,k;
    UINT32 num_current_pages;
    UINT32 *current_page_array;
    UINT32 *temp_page_array;
    PMC_ERROR ret_val;
    UINT32 num_releasable_pages;
    BOOL8   releasable;

    PMC_ENTRY();

    PMC_ASSERT(push_port_id < cpb_handle->cfg.push_port_num, CPB_ERR_CODE_ASSERT, 0,0);
    PMC_ASSERT(pop_port_id < cpb_handle->cfg.pop_port_num, CPB_ERR_CODE_ASSERT, 0,0);

    PMC_LOG_TRACE("Releasing pages from push/pop port: %u/%u ", push_port_id,pop_port_id);

    current_page_array = cpb_mem_pool_assign(cpb_handle, CPB_MEM_POOL_ID_3);
    PMC_ASSERT(current_page_array != NULL, CPB_ERR_CODE_ASSERT, 0, 0);
    temp_page_array = current_page_array + cpb_handle->cfg.num_pages;

    ret_val = cpb_qs_current_pages_get(cpb_handle,push_port_id,pop_port_id,&num_current_pages,current_page_array);
    if(ret_val){
        cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_3);
        PMC_RETURN(ret_val);
    }

    num_releasable_pages = 0;
    for(i = 0; i < num_current_pages; i++)
    {
        releasable = 1;
        for(k = 0; k < cpb_handle->cfg.blocks_per_page; k++){
            if(cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*current_page_array[i]+k].ipt_valid != FALSE) {
                    releasable = 0;
                    break;
            }
        }
        if(1 == releasable){
            temp_page_array[num_releasable_pages++] = current_page_array[i];
        }
    }

    PMC_ASSERT(num_releasable_pages <= cpb_handle->cfg.num_pages, CPB_ERR_CODE_ASSERT,0,0);

    for(i = 0; i < num_releasable_pages; i++) {

        PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "virtual_page = %u, excess_page_array[virtual_page]=%u\n", i, temp_page_array[i]);
        cpb_page_table_cfg(cpb_handle, temp_page_array[i], FALSE, 0, 0, 0);
    }

    cpb_mem_pool_release(cpb_handle, CPB_MEM_POOL_ID_3);
    PMC_RETURN(PMC_SUCCESS);
} /* cpb_pmpm_queue_system_page_release */

/*******************************************************************************
*  cpb_dcs_common_state_check
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function check the chnl status of the DCS instance specified by dcs_inst.
*
*
* INPUTS:
*   *cpb_handle       - pointer to CPB handle instance.
*   dcs_inst          - the DCS instance index
*   *match            - pointer to the test result
*
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_dcs_common_state_check( cpb_handle_t *cpb_handle,
                                              UINT32 dcs_inst,
                                              BOOL8 *match )
{
    /* Variable declaration */
    util_schd_chnl_ctxt_t *p_chnl_ctxt = NULL;
    util_schd_block_const_ctxt_t *p_block_ctxt = NULL;
    UINT32 i;

    PMC_ENTRY();

    p_chnl_ctxt = cpb_handle->util_schd_handle[dcs_inst]->var.schd_ctxt->chnl_ctxt;
    p_block_ctxt = &(cpb_handle->util_schd_handle[dcs_inst]->cfg.block_ctxt);
    *match = TRUE;
    for(i=0; i < p_block_ctxt->num_schd_chnl; i++)
    {
        PMC_LOG_TRACE("cpb_dcs_common_state_check: \n i = %u, \n p_chnl_ctxt[i].dcs_rd_channel_id = %u, \n p_chnl_ctxt[i].state = %u\n ", i, p_chnl_ctxt[i].dcs_rd_channel_id, p_chnl_ctxt[i].state);
        if(p_chnl_ctxt[i].state != UTIL_SCHD_CHNL_START)
        {
            *match = FALSE;
            PMC_RETURN(PMC_SUCCESS);
        }
    }

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_dcs_common_state_check */

/*******************************************************************************
* cpb_mem_pool_assign
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function provides a method to set the in_use flag to not available and
*  returns a pointer based on the kind of pool_id provided. The pointers only differ
*  in size as explained by pool_id.\n\n
*
*  Below are the function call stacks where cpb_mem_pool_assign is used to assign memory
*  instead of PMC_CTXT_CALLOC:\n\n
*
*  cpb_util_chnl_prov(pool_id 0) -> cpb_queue_build(pool_id: 2) -> cpb_qs_empty_block_get(pool_id 1)\n
*  cpb_util_chnl_prov(pool_id 0) -> cpb_pmpm_queue_system_page_assign(pool_id 3)\n\n
*
*  cpb_queue_resize(pool_id: 2)   -> cpb_qs_empty_block_get(pool_id 1)\n
*  cpb_queue_resize(pool_id: 2)   -> cpb_pmpm_queue_system_page_assign(pool_id 3)\n
*  cpb_queue_resize(pool_id: 2)   -> cpb_pmpm_queue_system_page_release(pool_id 3)\n\n
*
*  cpb_queue_destroy(pool_id: 2)  -> cpb_pmpm_queue_system_page_assign(pool_id 3)\n\n

*  cpb_chnl_source_and_type_test(pool_id: 0)\n
*  cpb_queue_num_block_get(pool_id: 2)
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance
*   pool_id                - Relates to the elements of the *cpb_mem_pool[] array
*                            in cpb_var_t. Each element represents which pointer
*                            to return based on the different sizes as below:\n
*                            pool_id: 0 == num_pages\n
*                            pool_id: 1 == num_pages\n
*                            pool_id: 2 == (block_per_page*num_pages) + num_pages\n
*                            pool_id: 3 == num_pages*2
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32 type pointer for the assigned pool_id.
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32* cpb_mem_pool_assign(cpb_handle_t *cpb_handle, UINT8 pool_id)
{
    UINT32 size = 0;

    PMC_ENTRY();
    PMC_ASSERT(pool_id < LAST_CPB_MEM_POOL_ID, CPB_ERR_CODE_ASSERT, 0, 0);
    PMC_ASSERT(cpb_handle->var.cpb_mem_pool_in_use[pool_id]==FALSE, CPB_MEM_POOL_NOT_AVAILABLE, 0, 0);

    switch(pool_id)
    {
        case 0:
        case 1:
            size = cpb_handle->cfg.num_pages;
            break;
        case 2:
            size = ((cpb_handle->cfg.num_pages*cpb_handle->cfg.blocks_per_page) + cpb_handle->cfg.num_pages);
            break;
        case 3:
            size = (cpb_handle->cfg.num_pages * 2);
            break;
    }

    PMC_MEMSET(cpb_handle->var.cpb_mem_pool[pool_id], 0, size);
    cpb_handle->var.cpb_mem_pool_in_use[pool_id]=TRUE;

    PMC_RETURN(cpb_handle->var.cpb_mem_pool[pool_id]);
} /* cpb_mem_pool_assign */

/*******************************************************************************
* cpb_mem_pool_release
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function provides a method to set the in_use flag to available for the
*  pointers in use from the *cpb_mem_pool[] array in cpb_var_t. This functions also
*  replaces PMC_FREE for the functions where we previously CALLOCed memory as
*  mentioned in cpb_mem_pool_assign().
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance
*   pool_id                - pool ID to be released
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void cpb_mem_pool_release(cpb_handle_t *cpb_handle, UINT8 pool_id)
{
    PMC_ENTRY();
    PMC_ASSERT(pool_id < LAST_CPB_MEM_POOL_ID, CPB_ERR_CODE_ASSERT, 0, 0);
    PMC_ASSERT(cpb_handle->var.cpb_mem_pool_in_use[pool_id]==TRUE, CPB_MEM_POOL_AVAILABLE, 0, 0);
    cpb_handle->var.cpb_mem_pool_in_use[pool_id]=FALSE;
    PMC_RETURN();
} /* cpb_mem_pool_release */

/*******************************************************************************
* cpb_mem_pool_alloc
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function allocates memory for the mem_pools.  This will end up being
*  called on start/restart.
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void cpb_mem_pool_alloc(cpb_handle_t *cpb_handle)
{
    PMC_ENTRY();

    cpb_handle->var.cpb_mem_pool[0] = (UINT32*)PMC_CALLOC(sizeof(UINT32)*cpb_handle->cfg.num_pages);
    PMC_ASSERT(cpb_handle->var.cpb_mem_pool[0] != NULL, CPB_ERR_CODE_ASSERT, 0 , 0);

    cpb_handle->var.cpb_mem_pool[1] = (UINT32*)PMC_CALLOC(sizeof(UINT32)*cpb_handle->cfg.num_pages);
    PMC_ASSERT(cpb_handle->var.cpb_mem_pool[1] != NULL, CPB_ERR_CODE_ASSERT, 0 , 0);

    cpb_handle->var.cpb_mem_pool[2] = (UINT32*)PMC_CALLOC(sizeof(UINT32)*cpb_handle->cfg.blocks_per_page*cpb_handle->cfg.num_pages +
                                                 sizeof(UINT32)*cpb_handle->cfg.num_pages);
    PMC_ASSERT(cpb_handle->var.cpb_mem_pool[2] != NULL, CPB_ERR_CODE_ASSERT, 0 , 0);

    cpb_handle->var.cpb_mem_pool[3] = (UINT32*)PMC_CALLOC(sizeof(UINT32)* cpb_handle->cfg.num_pages * 2);
    PMC_ASSERT(cpb_handle->var.cpb_mem_pool[3] != NULL, CPB_ERR_CODE_ASSERT, 0 , 0);

    PMC_RETURN();
} /* cpb_mem_pool_alloc */

/*******************************************************************************
* cpb_sifd_chnl_ctxt_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function provides an accessor for data structure storing zone bypass
*  configuration data for SIFD ports of DCPB.  It provides the ability to
*  set context for a SIFD port and channel.
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance
*   port                   - SIFD Port, 0 or 1
*   chnl                   - SIFD Channel, 0 to 149
*   zone_bypass            - For SIFD bound egress_mux_output_port, specifies
*                            if the ZONE data transferred to
*                            ingress_mux_input_port_chnl represents the local
*                            CPB FIFO depth or the SIFD port XON/XOFF status
*                            for the channel.  Valid values:\n
*                            0: Use CPB FIFO depth\n
*                            1: Use SIFD XON/XOFF status
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_sifd_chnl_ctxt_set(cpb_handle_t *cpb_handle, UINT32 port, UINT32 chnl, UINT32 zone_bypass)
{
    UINT32 word_offset, bit_index;

    PMC_ENTRY();

    PMC_ASSERT(port <= 1, CPB_ERR_INVALID_ARG, port, 0);
    PMC_ASSERT(chnl < 150, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(zone_bypass <= 1, CPB_ERR_INVALID_ARG, 0, 0);

    word_offset = CPB_GET_32_BIT_WORD_OFFSET(chnl);
    bit_index = CPB_GET_32_BIT_WORD_INDEX(chnl);
    if(zone_bypass == 1)
    {
        /* set the bit */
        CPB_SET_BIT_IN_32_BIT_WORD(cpb_handle->var.sifd_zone_bypass[port][word_offset],1<<bit_index);

    } else {
        /* clear the bit */
        CPB_CLEAR_BIT_IN_32_BIT_WORD(cpb_handle->var.sifd_zone_bypass[port][word_offset],1<<bit_index);

    }

    PMC_RETURN();

} /* cpb_sifd_chnl_ctxt_set */

/*******************************************************************************
* cpb_sifd_chnl_ctxt_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function provides an accessor for data structure storing zone bypass
*  configuration data for SIFD ports of DCPB.  It provides the ability to retrieve
*  the configuration setting for a SIFD port and channel.
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance
*   port                   - SIFD Port, 0 or 1
*   chnl                   - SIFD Channel, 0 to 149
*
* OUTPUTS:
*   zone_bypass_ptr        - For SIFD bound egress_mux_output_port, specifies
*                            if the ZONE data transferred to
*                            ingress_mux_input_port_chnl represents the local
*                            CPB FIFO depth or the SIFD port XON/XOFF status
*                            for the channel.  Valid values:\n
*                            0: Use CPB FIFO depth\n
*                            1: Use SIFD XON/XOFF status
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_sifd_chnl_ctxt_get(cpb_handle_t *cpb_handle, UINT32 port, UINT32 chnl, UINT32 *zone_bypass_ptr)
{
    UINT32 word_offset, bit_index;

    PMC_ENTRY();

    PMC_ASSERT(port <= 1, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(chnl < 150, CPB_ERR_INVALID_ARG, 0, 0);

    word_offset = CPB_GET_32_BIT_WORD_OFFSET(chnl);
    bit_index = CPB_GET_32_BIT_WORD_INDEX(chnl);

    *zone_bypass_ptr = CPB_GET_BIT_IN_32_BIT_WORD(cpb_handle->var.sifd_zone_bypass[port][word_offset],bit_index,1<<bit_index);

    PMC_RETURN();

} /* cpb_sifd_chnl_ctxt_get */

/*******************************************************************************
* cpb_rd_queue_id_data_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function retrieves the datapath elements for a read queue id.
*
*
* INPUTS:
*   *cpb_handle             - pointer to CPB handle instance
*   dcs_inst                - DCS Instance
*   rid                     - DCS C_RAM_IDENTIFIER
*
* OUTPUTS:
*   chnl_state_ptr          - Read queue ID channel state
*   egress_port_ptr         - DPI Master Port
*   egress_chnl_ptr         - DPI Master Port Channel
*   dcs_rd_channel          - DCS C_RAM_CHANNEL
*   push_port               - Ingress mux output port
*   wid                     - Write queue id
*   ingress_port_ptr        - DPI Slave Port
*   ingress_chnl_ptr        - DPI Slave Chnl
*   is_broadcast            - Broadcast is defined as: DPI slave port
*                            channel is processed by more than one queue
*                            system (ie target more than one
*                            egress_mux_output_port) \n
*                            FALSE : is not a broadcast channel \n
*                            TRUE  : is a broadcast channel
*   is_multicast            - Multicast is defined as: There are more than
*                            one reader for the DPI Slave Port Channel
*                            within the queue system associated with
*                            egress_mux_output_port \n
*                            FALSE : is not a multicast channel \n
*                            TRUE  : is a multicast channel
*  is_reader_primary        - The egress mux output port channel is the
*                            primary reader for the queue system in which
*                            it is configured.
*  is_slave_zone_primary    - The egress mux output port channel is the DPI
*                            slave port channel zone source for all channels
*                            associated with the DPI slave port channel.
*
* RETURNS:
*   BOOL8                  - TRUE  : DCS and read queue ID are configured \n
*                            FALSE : DCS and read queue ID are not configured
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL8 cpb_rd_queue_id_data_get(cpb_handle_t *cpb_handle,
                                       UINT32 dcs_inst,
                                       UINT32 rid,
                                       util_schd_chnl_state_t *chnl_state_ptr,
                                       UINT32 *egress_port_ptr,
                                       UINT32 *egress_chnl_ptr,
                                       UINT32 *dcs_rd_channel,
                                       UINT32 *push_port,
                                       UINT32 *wid,
                                       UINT32 *ingress_port_ptr,
                                       UINT32 *ingress_chnl_ptr,
                                       BOOL8 *is_broadcast,
                                       BOOL8 *is_multicast,
                                       BOOL8 *is_reader_primary,
                                       BOOL8 *is_slave_zone_primary)
{
    UINT32 slave_port,slave_channel, index;
    PMC_ENTRY();


    index = cpb_fifo_var_data_queue_index_get(cpb_handle, dcs_inst, rid);
    if(cpb_handle->var.fifo_var_data[index].status == CPB_FIFO_NOT_USED)
        PMC_RETURN(FALSE);

    *wid = cpb_handle->var.fifo_var_data[index].write_id;
    *push_port = cpb_handle->var.fifo_var_data[index].push_port_id;

    PMC_ASSERT(cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB, CPB_ERR_CODE_ASSERT, 0, 0);
    cpb_ingress_mux_port_chnl_get(cpb_handle,
                                  *push_port,
                                  *wid,
                                  ingress_port_ptr,
                                  ingress_chnl_ptr);


    cpb_egress_mux_port_chnl_get(cpb_handle,
                                 dcs_inst,
                                 rid,
                                 dcs_rd_channel,
                                 egress_port_ptr,
                                 egress_chnl_ptr);
    cpb_chnl_source_type_and_primary_test_recovery(cpb_handle,
                                                   *egress_port_ptr,
                                                   *egress_chnl_ptr,
                                                    &slave_port,
                                                    &slave_channel,
                                                    is_broadcast,
                                                    is_multicast,
                                                    is_reader_primary,
                                                    is_slave_zone_primary);

    util_schd_chnl_state_get(cpb_handle->util_schd_handle[dcs_inst],
                             rid,
                             chnl_state_ptr);
    PMC_RETURN(TRUE);

} /* cpb_rd_queue_id_data_get */


/*******************************************************************************
* cpb_egress_mux_port_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function retrieves the DPI Master Port Channel that is associated with
*  a DCS read channel ID.
*
* INPUTS:
*   *cpb_handle             - pointer to CPB handle instance
*   dcs_inst                - DCS Instance
*   rid                     - DCS C_RAM_CHANNEL_ID setting
*
* OUTPUTS:
*   dcs_rd_channel          - Read channel from the DCS calendar
*   egress_port_ptr         - DPI Master Port
*   egress_chnl_ptr         - DPI Master Port Channel
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void cpb_egress_mux_port_chnl_get(cpb_handle_t *cpb_handle,
                                          UINT32 dcs_inst,
                                          UINT32 rid,
                                          UINT32 *dcs_rd_channel,
                                          UINT32 *egress_port_ptr,
                                          UINT32 *egress_chnl_ptr)
{

    util_schd_chnl_state_t chnl_state;
    UINT32 push_port, wid;

    PMC_ENTRY();

    if(cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB)
    {
        util_schd_dcs_chnl_data_get(cpb_handle->util_schd_handle[dcs_inst],
                                    rid,
                                    &chnl_state,
                                    dcs_rd_channel,
                                    &push_port,
                                    &wid);
    
    
        *egress_port_ptr = cpb_master_port_get(cpb_handle, dcs_inst, *dcs_rd_channel);
        *egress_chnl_ptr = cpb_master_channel_get(cpb_handle, *egress_port_ptr, *dcs_rd_channel);
    }
    else
    {
        cpb_mcpb_egress_mux_port_chnl_get(cpb_handle,
                                          dcs_inst,
                                          rid,
                                          dcs_rd_channel,
                                          egress_port_ptr,
                                          egress_chnl_ptr);
    }

    PMC_RETURN();

} /* cpb_egress_mux_port_chnl_get */

/*******************************************************************************
* cpb_mcpb_egress_mux_port_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function retrieves the DPI Master Port Channel that is associated with
*  a DCS read channel ID for the static resource definition of and MCPB 
*  instance.
*
* INPUTS:
*   *cpb_handle             - pointer to CPB handle instance
*   dcs_inst                - DCS Instance
*   rid                     - DCS C_RAM_CHANNEL_ID setting
*
* OUTPUTS:
*   dcs_rd_channel          - Read channel from the DCS calendar
*   egress_port_ptr         - DPI Master Port
*   egress_chnl_ptr         - DPI Master Port Channel
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void cpb_mcpb_egress_mux_port_chnl_get(cpb_handle_t *cpb_handle,
                                               UINT32 dcs_inst,
                                               UINT32 rid,
                                               UINT32 *dcs_rd_channel,
                                               UINT32 *egress_port_ptr,
                                               UINT32 *egress_chnl_ptr)
{

    UINT32 egress_mux_output_port_chnl = 999;
    cpb_mcpb_egr_output_port_type_t egress_mux_output_port = LAST_CPB_MCPB_EGRESS_PORT;

    PMC_ENTRY();    

    PMC_ASSERT(cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB, CPB_ERR_CODE_ASSERT, 0, 0);

    switch(dcs_inst)
    {
        case 0:
            /* determine if Master DPI Port 0/1 used */
            /* DCS 0 CPB_MCPB_EGR_SYS_ING needs cpb_handle->var.mcpb_em_sel.em_igr_ext_sel == 1
               DCS 0 CPB_MCPB_EGR_LINE_ING needs cpb_handle->var.mcpb_em_sel.em_igr_ext_sel == 0
             */
            egress_mux_output_port = (cpb_ctrl_field_EM_IGR_EXT_SEL_get(NULL, cpb_handle) == 1) ? CPB_MCPB_EGR_SYS_ING:CPB_MCPB_EGR_LINE_ING;
            egress_mux_output_port_chnl = rid/2;
            break;
        case 1:
            /* determine if Master DPI Port 0/1 used */
            /* DCS 1 CPB_MCPB_EGR_SYS_EG needs cpb_handle->var.mcpb_em_sel.em_egr_ext_sel == 1
               DCS 1 CPB_MCPB_EGR_LINE_EG needs cpb_handle->var.mcpb_em_sel.em_egr_ext_sel == 0
             */
            egress_mux_output_port = (cpb_ctrl_field_EM_EGR_EXT_SEL_get(NULL, cpb_handle) == 1)? CPB_MCPB_EGR_SYS_EG:CPB_MCPB_EGR_LINE_EG;
            egress_mux_output_port_chnl = rid/2;
            break;
        case 2:
        case 3:
            egress_mux_output_port = dcs_inst == 2 ? CPB_MCPB_EGR_CPU:CPB_MCPB_EGR_FEGE;
            if(rid < 12)
            {
                if(dcs_inst == 2) PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG, 0, 0);
                egress_mux_output_port_chnl = (rid << 2) + 1;
            }
            else if(rid < 24)
            {
                if(dcs_inst == 2) PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG, 0, 0);
                egress_mux_output_port_chnl = ((rid - 12) << 2);
            }
            else if(rid == 24)
            {
                if(dcs_inst == 2) PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG, 0, 0);
                egress_mux_output_port_chnl = 0x3;
            }
            else if(rid < 37)
            {
                if(dcs_inst == 3) PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG, 0, 0);
                egress_mux_output_port_chnl = ((rid - 25) << 2) + 0x41;
            }
            else if(rid < 49)
            {
                if(dcs_inst == 3) PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG, 0, 0);
                egress_mux_output_port_chnl = ((rid - 37) << 2) + 0x40;
            }
            else if(rid < 61)
            {
                if(dcs_inst == 3) PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG, 0, 0);
                egress_mux_output_port_chnl = ((rid - 49) << 2) + 0x42;
            }
            else if(rid == 61)
            {
                if(dcs_inst == 3) PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG, 0, 0);
                egress_mux_output_port_chnl = 0x43;
            }
            else
            {
                PMC_ASSERT(FALSE, CPB_ERR_CODE_ASSERT, 0, 0);
            }
            break;
        default:
            PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG, 0, 0);
            break;
    }

    *dcs_rd_channel = egress_mux_output_port_chnl;
    *egress_port_ptr = (UINT32)egress_mux_output_port;
    *egress_chnl_ptr = (egress_mux_output_port_chnl > 0x40) ? (egress_mux_output_port_chnl - 0x40):egress_mux_output_port_chnl;

    PMC_RETURN();
} /* cpb_mcpb_egress_mux_port_chnl_get */

/*******************************************************************************
* cpb_ingress_mux_port_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function retrieves the DPI slave port and channel that is associated with
*  a push port and write queue ID.
*
* INPUTS:
*   *cpb_handle             - pointer to CPB handle instance
*   push_port               - Push Port ID
*   wid                     - Write Queue ID
*
* OUTPUTS:
*   ingress_port_ptr        - DPI Slave Port
*   ingress_chnl_ptr        - DPI Slave Port Channel
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void cpb_ingress_mux_port_chnl_get(cpb_handle_t *cpb_handle,
                                           UINT32 push_port,
                                           UINT32 wid,
                                           UINT32 *ingress_port_ptr,
                                           UINT32 *ingress_chnl_ptr)
{
    PMC_ENTRY();

    PMC_ASSERT(cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB, CPB_ERR_CODE_ASSERT, 0, 0);

    *ingress_port_ptr = cpb_slave_port_get(cpb_handle, push_port, wid);
    *ingress_chnl_ptr = cpb_slave_channel_get(cpb_handle, push_port, wid);

    PMC_RETURN();

} /* cpb_ingress_mux_port_chnl_get */

/*******************************************************************************
* cpb_rd_queue_id_and_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function retrieves the Read Queue ID for a Write Queue ID associated
*  to a push/pop port pair.
*
* INPUTS:
*   *cpb_handle             - pointer to CPB handle instance
*   push_port               - Push Port ID
*   pop_port                - Pop Port ID
*   wid                     - Write Queue ID
*
* OUTPUTS:
*   rd_queue_id_ptr         - Read Queue ID
*   output_state_ptr        - Output Port State
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void cpb_rd_queue_id_and_state_get(cpb_handle_t *cpb_handle,
                                           UINT32 push_port,
                                           UINT32 pop_port,
                                           UINT32 wid,
                                           UINT32 *rd_queue_id_ptr,
                                           util_global_chnl_state_t *output_state_ptr)
{
    UINT32 ingress_port, ingress_chnl;
    UINT8 mst_port, mst_chnl;
    BOOL8 found = FALSE;
    PMC_ENTRY();

    PMC_ASSERT(cpb_handle->cfg.cpb_type != CPB_INSTANCE_MCPB, CPB_ERR_CODE_ASSERT, 0, 0);

    ingress_port = cpb_slave_port_get(cpb_handle, push_port, wid);
    ingress_chnl = cpb_slave_channel_get(cpb_handle, push_port, wid);
    mst_port = cpb_handle->var.cpb_connect_data->chnl[ingress_port][ingress_chnl].slv.dest_mst_port;
    mst_chnl = cpb_handle->var.cpb_connect_data->chnl[ingress_port][ingress_chnl].slv.dest_mst_chnl;

    while(mst_port != CPB_INDEX_LAST && found == FALSE)
    {
        if(cpb_handle->var.cpb_connect_data->chnl[mst_port][mst_chnl].mst.dcs_inst == pop_port &&
           cpb_handle->var.cpb_connect_data->chnl[mst_port][mst_chnl].mst.is_reader_primary == TRUE)
        {
            found = TRUE;
            *rd_queue_id_ptr  = cpb_handle->var.cpb_connect_data->chnl[mst_port][mst_chnl].mst.rd_queue_id;
            *output_state_ptr = cpb_handle->var.cpb_connect_data->chnl[mst_port][mst_chnl].mst.state;
        }
        else
        {
            mst_port = cpb_handle->var.cpb_connect_data->chnl[mst_port][mst_chnl].mst.next_dest_mst_port;
            mst_chnl = cpb_handle->var.cpb_connect_data->chnl[mst_port][mst_chnl].mst.next_dest_mst_chnl;
        }
    }

    PMC_ASSERT(mst_port != CPB_INDEX_LAST, CPB_ERR_CODE_ASSERT, 0, 0);

    PMC_RETURN();

} /* cpb_rd_queue_id_and_state_get */

/*******************************************************************************
* cpb_mcpb_ingress_mux_port_chnl_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*  This function retrieves the DPI slave port and channel that is associated with
*  a push port and write queue ID.
*
* INPUTS:
*   *cpb_handle             - pointer to CPB handle instance
*   push_port               - Push Port ID
*   wid                     - Write Queue ID
*   dcs_inst                - DCS Inst ID
*
* OUTPUTS:
*   ingress_port_ptr        - DPI Slave Port
*   ingress_chnl_ptr        - DPI Slave Port Channel
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void cpb_mcpb_ingress_mux_port_chnl_get(cpb_handle_t *cpb_handle,
                                                UINT32 push_port,
                                                UINT32 wid,
                                                UINT32 dcs_inst,
                                                UINT32 *ingress_port_ptr,
                                                UINT32 *ingress_chnl_ptr)
{

    cpb_mcpb_ingr_input_port_type_t ingress_mux_input_port = LAST_CPB_MCPB_INGRESS_PORT;
    UINT32 ingress_mux_input_port_chnl = 999;
    PMC_ENTRY();

    PMC_ASSERT(cpb_handle->cfg.cpb_type == CPB_INSTANCE_MCPB, CPB_ERR_CODE_ASSERT, 0, 0);

    switch(push_port)
    {
        case 0:
            ingress_mux_input_port = (0 == cpb_ctrl_field_IM_IGR_EXT_SEL_get(NULL, cpb_handle)) ? CPB_MCPB_ING_LINE_IM_EXT : CPB_MCPB_ING_SYS_IM_EXT;
            ingress_mux_input_port_chnl = wid;
            break;
        case 1:
            ingress_mux_input_port = (0 == cpb_ctrl_field_IM_EGR_EXT_SEL_get(NULL, cpb_handle)) ? CPB_MCPB_ING_LINE_EM_EXT : CPB_MCPB_ING_SYS_EM_EXT;
            ingress_mux_input_port_chnl = wid;
            break;
        case 2:
            if(dcs_inst == 3)
            {
                if(wid == 0) ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
                ingress_mux_input_port_chnl = 24;
                PMC_ASSERT(ingress_mux_input_port != LAST_CPB_MCPB_INGRESS_PORT, CPB_ERR_CODE_ASSERT, 0, 0);
            }
            else if(dcs_inst == 2) /* (P2-P2) */
            {
                if(wid == 1) ingress_mux_input_port = CPB_MCPB_ING_CPU_INS;
                ingress_mux_input_port_chnl = 24;
                PMC_ASSERT(ingress_mux_input_port != LAST_CPB_MCPB_INGRESS_PORT, CPB_ERR_CODE_ASSERT, 0, 0);
            } 
            else if(dcs_inst == 1) /* (P2-P1) */
            {
                /* odd WID has CPB_MCPB_ING_FEGE_INS source, even WID has CPB_MCPB_ING_CPU_INS source */
                ingress_mux_input_port = (wid%2) ? CPB_MCPB_ING_FEGE_INS:CPB_MCPB_ING_CPU_INS;
                ingress_mux_input_port_chnl = wid;
            }
            else if(dcs_inst == 0) /* (P2-P0) */
            {
                /* odd WID has CPB_MCPB_ING_CPU_INS source, even WID has CPB_MCPB_ING_FEGE_INS source */
                ingress_mux_input_port = (wid%2) ? CPB_MCPB_ING_CPU_INS:CPB_MCPB_ING_FEGE_INS;
                ingress_mux_input_port_chnl = wid;
            }
            else
            {
                PMC_ASSERT(FALSE, CPB_ERR_CODE_ASSERT, 0, 0);
            }
            break;
        case 3:
            ingress_mux_input_port = (0 == cpb_ctrl_field_IM_REFLECT_SEL_get(NULL, cpb_handle)) ? CPB_MCPB_ING_LINE_REF : CPB_MCPB_ING_SYS_REF;
            break;
        default:
            PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG, 0, 0);
            break;
    }

    *ingress_port_ptr = (UINT32)ingress_mux_input_port;
    *ingress_chnl_ptr = ingress_mux_input_port_chnl;


    PMC_RETURN();

} /* cpb_mcpb_ingress_mux_port_chnl_get */

/*******************************************************************************
* cpb_slave_channel_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Gets the DPI slave channel from the push port and write queue id.
*
* INPUTS:
*   cpb_handle      - Pointer to CPB context
*   push_port       - SCPB push port number
*   wid             - SCPB write queue ID
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   DPI slave channel
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32 cpb_slave_channel_get(cpb_handle_t * cpb_handle, UINT32 push_port, UINT32 wid)
{
    UINT32 slave_channel = 0xFF;
    UINT32 sifd1_sel;
    UINT32 sifd2_sel;
    PMC_ENTRY();

    sifd1_sel = 1;
    sifd2_sel = 1;

    switch(cpb_handle->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
            switch(push_port)
            {
                case 0:
                case 1:
                    sifd1_sel = cpb_handle->var.dcpb_ingress_mux_output_source[0];
                    sifd2_sel = cpb_handle->var.dcpb_ingress_mux_output_source[1];

                    if(sifd1_sel == 1 && push_port == 0)
                        slave_channel = wid;
                    else if(sifd2_sel == 1 && push_port == 1)
                        slave_channel = wid;
                    else if(wid <= 11)
                        slave_channel = wid;
                    else if(wid >= 108 && wid <= 119)
                        slave_channel = wid - 108;
                    break;
                case 2:
                case 3:
                    if(wid <= 11)
                        slave_channel = wid;
                    else if(wid >= 12 && wid <= 107)
                        slave_channel = wid - 12;
                    else if(wid >= 108 && wid <= 119)
                        slave_channel = wid - 108;
                    break;
            }
            break;
        case CPB_INSTANCE_OCPB:
            slave_channel = wid;
            break;
        case CPB_INSTANCE_MCPB:
            PMC_LOG(PMC_LOG_SEV_HIGHEST, CPB_ERR_NO_SW_CONTENT, 0, 0); 
            break;
        case LAST_CPB_INSTANCE:
            break;

    }

    PMC_RETURN(slave_channel);
} /* cpb_slave_channel_get */

/*******************************************************************************
* cpb_slave_port_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Gets the DPI slave port from the push port and write queue id.
*
* INPUTS:
*   cpb_handle      - Pointer to CPB context
*   push_port       - SCPB push port number
*   wid             - SCPB write queue ID
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   DPI slave port
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32 cpb_slave_port_get(cpb_handle_t * cpb_handle, UINT32 push_port, UINT32 wid)
{
    UINT32 slave_port = 0xFF;
    UINT32 sifd1_sel;
    UINT32 sifd2_sel;
    PMC_ENTRY();

    sifd1_sel = 1;
    sifd2_sel = 1;

    switch(cpb_handle->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
            switch(push_port)
            {
                case 0:
                case 1:
                    sifd1_sel = cpb_handle->var.dcpb_ingress_mux_output_source[0];
                    sifd2_sel = cpb_handle->var.dcpb_ingress_mux_output_source[1];

                    if(sifd1_sel == 1 && push_port == 0)
                        slave_port = 0;
                    else if(sifd2_sel == 1 && push_port == 1)
                        slave_port = 1;
                    else if(wid <= 11)
                        slave_port = 5;
                    else if(wid >= 108 && wid <= 119)
                        slave_port = 2;
                    break;
                case 2:
                case 3:
                    if(wid <= 11)
                        slave_port = 4;
                    else if(wid >= 12 && wid <= 107)
                        slave_port = 3;
                    else if(wid >= 108 && wid <= 119)
                        slave_port = 2;
                    break;
            }
            break;
        case CPB_INSTANCE_OCPB:
            slave_port = push_port;
            break;
        case CPB_INSTANCE_MCPB:
            PMC_LOG(PMC_LOG_SEV_HIGHEST, CPB_ERR_NO_SW_CONTENT, 0, 0); 
            break;
        case LAST_CPB_INSTANCE:
            break;

    }

    PMC_RETURN(slave_port);
} /* cpb_slave_port_get */


/*******************************************************************************
* cpb_master_channel_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Get the DPI master channel from the DPI master port and the DCS channel
*
* INPUTS:
*   cpb_handle      - Pointer to CPB context
*   master_port     - DPI master port
*   dcs_channel     - DCS channel number (stored in the calendar)
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   DPI master channel
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32 cpb_master_channel_get(cpb_handle_t * cpb_handle, UINT32 master_port, UINT32 dcs_channel)
{
    UINT32 master_channel = 0xFF;
    PMC_ENTRY();

    switch(cpb_handle->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
            if(master_port == 2)
                master_channel = dcs_channel - 32;
            else if(master_port == 3)
                master_channel = dcs_channel - 128;
            else
                master_channel = dcs_channel;
            break;
        case CPB_INSTANCE_OCPB:
            master_channel = dcs_channel;
            break;
        case CPB_INSTANCE_MCPB:
            PMC_LOG(PMC_LOG_SEV_HIGHEST, CPB_ERR_NO_SW_CONTENT, 0, 0); 
            break;

        case LAST_CPB_INSTANCE:
            break;
    }
    PMC_RETURN(master_channel);
} /* cpb_master_channel_get */

/*******************************************************************************
* cpb_master_port_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Get the DPI master port from the DCS instantiation and the DCS channel
*   number.
*
* INPUTS:
*   cpb_handle      - Pointer to the CPB context
*   dcs_inst        - DCS instance number
*   dcs_channel     - DCS channel number (from the calendar)
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   DPI master port
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32 cpb_master_port_get(cpb_handle_t * cpb_handle, UINT32 dcs_inst, UINT32 dcs_channel)
{
    UINT32 master_port = 0xFF;
    PMC_ENTRY();

    switch(cpb_handle->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
            switch(dcs_inst)
            {
                case 0:
                case 1:
                    if(cpb_handle->var.dcpb_em_sifd1_sel && dcs_inst == 0)
                        master_port = 0;
                    else if(cpb_handle->var.dcpb_em_sifd2_sel && dcs_inst == 1)
                        master_port = 1;
                    else if (dcs_channel <= 11)
                        master_port = 5;
                    else if (dcs_channel <= 43)
                        master_port = 2;
                    break;
                case 2:
                case 3:
                    if (dcs_channel <= 11)
                        master_port = 4;
                    else if (dcs_channel >= 32 && dcs_channel <= 43)
                        master_port = 2;
                    else if (dcs_channel >= 128 && dcs_channel <= 223)
                        master_port = 3;
                    break;
            }
            break;
        case CPB_INSTANCE_OCPB:
            master_port = dcs_inst;
            break;
        case CPB_INSTANCE_MCPB:
            PMC_LOG(PMC_LOG_SEV_HIGHEST, CPB_ERR_NO_SW_CONTENT, 0, 0); 
            break;

        case LAST_CPB_INSTANCE:
            break;

    }
    PMC_RETURN(master_port);
} /* cpb_master_port_get */

/*******************************************************************************
* cpb_channel_state_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Returns the util_schd state of the passed in channel.
*
* INPUTS:
*   cpb_handle      - Pointer to the CPB context
*   cpb_port        - Either the cpb egress port or ingress port
*                     depending on the value of is_egress_port
*   cpb_channel     - Either the cpb egress chanel or ingress channel
*                     depending on the value of is_egress_port
*   is_egress_port  - TRUE: The preceding two parameters refer to
*                           the egress interface.\n
*                     FALSE: The preceding two parameters refer to
*                           the ingress interface.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   The util_schd state of the channel.
*
* NOTES:
*
*******************************************************************************/
PUBLIC util_schd_chnl_state_t cpb_channel_state_get(cpb_handle_t * cpb_handle,
                                                    UINT32 cpb_port,
                                                    UINT32 cpb_channel,
                                                    BOOL8 is_egress_port)
{
    util_schd_chnl_state_t   chnl_state = UTIL_SCHD_CHNL_START;
    util_global_chnl_state_t internal_chnl_state = UTIL_GLOBAL_CHNL_START;

    PMC_ENTRY();

    if (is_egress_port == TRUE)
    {
        internal_chnl_state = cpb_handle->var.cpb_connect_data->chnl[cpb_port][cpb_channel].mst.state;
    } else 
    {
        internal_chnl_state = cpb_handle->var.cpb_connect_data->chnl[cpb_port][cpb_channel].slv.state;
    }

    switch(internal_chnl_state)
    {
        case UTIL_GLOBAL_CHNL_START:
            chnl_state = UTIL_SCHD_CHNL_START;
            break;
        case UTIL_GLOBAL_CHNL_EQUIPPED:
            chnl_state = UTIL_SCHD_CHNL_EQUIPPED;
            break;
        case UTIL_GLOBAL_CHNL_OPERATIONAL:
            chnl_state = UTIL_SCHD_CHNL_OPERATIONAL;
            break;
        case UTIL_GLOBAL_CHNL_BACKUP:
            chnl_state = UTIL_SCHD_CHNL_BACKUP;
            break;
        default:
            PMC_ASSERT(FALSE, CPB_ERR_CODE_ASSERT, 0, 0);
            break;
    }



    PMC_RETURN(chnl_state);
} /* cpb_channel_state_get */

/*******************************************************************************
* cpb_slv_port_chnl_pop_port_data_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*    This function retrieves the pop port and channel for a provisioned channel
*    referenced from the DPI slave port and channel.\n\n
*
*    This function retrieves the data for the primary zone master.
*
*
* INPUTS:
*   *h                          - pointer to cpb handle instance
*                                 channel data
*   slave_port                  - DPI Slave Port
*   slave_chnl                  - DPI Slave Channel
* OUTPUTS:
*   *pop_port_ptr               - Pointer to pop port value
*   *pop_rd_qid_ptr             - Pointer to read queue ID.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void cpb_slv_port_chnl_pop_port_data_get(cpb_handle_t *h,
                                                 UINT32 slave_port,
                                                 UINT32 slave_chnl,
                                                 UINT32 *pop_port_ptr,
                                                 UINT32 *pop_rd_qid_ptr)
{

    UINT32 qs_ch_mst[4] = {0, 0, 0, 0};
    UINT32 qs_pop_qid[4] = {0, 0, 0, 0};
    UINT32 match_true = 0, i;
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    /* assert if this is MCPB channel handle type */
    PMC_ASSERT(h->cfg.cpb_type != CPB_INSTANCE_MCPB, CPB_ERR_CODE_ASSERT, 0, 0);

    result = cpb_slv_dpi_qs_ch_mst_get(h, slave_port, slave_chnl,
                                       &(qs_ch_mst[0]), &(qs_ch_mst[1]),
                                       &(qs_ch_mst[2]), &(qs_ch_mst[3]));

    PMC_ASSERT(result == PMC_SUCCESS, CPB_ERR_CODE_ASSERT, 0, 0);
    PMC_ASSERT(qs_ch_mst[0] != 0 || qs_ch_mst[1] != 0 || qs_ch_mst[2] != 0 || qs_ch_mst[3] != 0, CPB_ERR_CODE_ASSERT, 0, 0);

    result = cpb_slv_dpi_qs_pop_qid_get(h, slave_port, slave_chnl,
                                       &(qs_pop_qid[0]), &(qs_pop_qid[1]),
                                       &(qs_pop_qid[2]), &(qs_pop_qid[3]));

    PMC_ASSERT(result == PMC_SUCCESS, CPB_ERR_CODE_ASSERT, 0, 0);

    for(i = 0; i < h->cfg.pop_port_num; i++)
    {
        if(qs_ch_mst[i] == 1)
        {
            match_true++;
            *pop_port_ptr = i;
            *pop_rd_qid_ptr = qs_pop_qid[i];
        }
    }
    /* assert if no match or a duplicate match detected */
    PMC_ASSERT(match_true == 1, CPB_ERR_CODE_ASSERT, 0, 0);

    PMC_RETURN();

} /* cpb_slv_port_chnl_pop_port_data_get */

/*******************************************************************************
* cpb_dsc_calendar_pinch_mode_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function is used for G.HAO to resize the CPB queue for a given channel
*   configured in ODUflex. The zone threshold is updated accordingly.
*
* INPUTS:
*   *cpb_handle       - pointer to CPB handle instance.
*   output_port       - The output port (or queue id)
*   cal_pinch_type    - See util_global_calendar_pinch_t.  Used to set a custom
*                       calendar pinch scenario.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dsc_calendar_pinch_mode_set(cpb_handle_t *cpb_handle,
                                                 UINT32 output_port,
                                                 util_global_calendar_pinch_t cal_pinch_type)
{
    PMC_ERROR result = PMC_SUCCESS;

    PMC_ENTRY();

    result = util_schd_calendar_pinch_mode_set(cpb_handle->util_schd_handle[output_port],
                                                cal_pinch_type);


    PMC_RETURN(result);

} /* cpb_dsc_calendar_pinch_mode_set */

/*
 *  Computational Operation Functions - End
 */

/*
 *  Register Access Operation Functions - Start
 */

/*******************************************************************************
*  cpb_page_table_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures the SCPB page table
*
*
* INPUTS:
*   *cpb_handle          - pointer to CPB handle instance.
*   index                - the page index
*   page_valid           - the page valid bit value to be configured
*   push_port_id         - the push port id\n
*                           0:3
*   pop_port_id          - the pop port id\n
*                           0:3
*   mfege_pop_port_id    - MGMT FEGE pop port id\n
*                           0:3
* OUTPUTS:
*   None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_page_table_cfg( cpb_handle_t *cpb_handle,
                                      UINT32 index,
                                      BOOL8   page_valid,
                                      UINT32 push_port_id,
                                      UINT32 pop_port_id,
                                      UINT32 mfege_pop_port_id)
{
    scpb_reg_buffer_t scpb_reg_buffer[1];

    pmpm_buffer_t pmpm_buffer[1];

    PMC_ENTRY();

    scpb_reg_buffer_init( scpb_reg_buffer, cpb_handle);
    pmpm_buffer_init    (pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM );


    /* argument checking */
    if (page_valid > 1) {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    PMC_LOG(PMC_LOG_SEV_LOW, CPB_LOG_CODE_LOG, 0, 0, "configuring page inverted page table: page_valid = %u pop_port_id = %u push_port_id = %u \n", page_valid,pop_port_id,push_port_id);

    /* If allocating a page, write to valid last such that LPA and ID's are set when page is enabled */
    if (1 == page_valid)
    {
        /* Take the page out of shutdown state and allow PMPM to automatically put this page in and out of light sleep as needed */
        pmpm_field_PWR_MODE_set           (pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM, index, 0);
        pmpm_field_DYNAMIC_ADDR_LS_EN_set ( pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM, index, 1);
        pmpm_field_DYNAMIC_LS_EN_set      ( pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM, index, 1);
        pmpm_buffer_flush( pmpm_buffer );

        pmpm_buffer_init    (pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_PL );
        pmpm_field_PWR_MODE_set           (pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_PL, index, 0);
        pmpm_field_DYNAMIC_ADDR_LS_EN_set ( pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_PL, index, 1);
        pmpm_field_DYNAMIC_LS_EN_set      ( pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_PL, index, 1);
        pmpm_buffer_flush( pmpm_buffer );

        pmpm_buffer_init    (pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_EOP );
        pmpm_field_PWR_MODE_set           (pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_EOP, index, 0);
        pmpm_field_DYNAMIC_ADDR_LS_EN_set ( pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_EOP, index, 1);
        pmpm_field_DYNAMIC_LS_EN_set      ( pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_EOP, index, 1);
        pmpm_buffer_flush( pmpm_buffer );


        scpb_reg_field_IPT_QS_ID_set     ( scpb_reg_buffer, cpb_handle, index, pop_port_id );
        scpb_reg_field_IPT_WP_ID_set     ( scpb_reg_buffer, cpb_handle, index, push_port_id );
        scpb_reg_buffer_flush(scpb_reg_buffer);

        scpb_reg_field_PAGE_VALID_set    ( scpb_reg_buffer, cpb_handle, index, page_valid);
        scpb_reg_field_IPT_QS_ID_set     ( scpb_reg_buffer, cpb_handle, index, pop_port_id );
        scpb_reg_field_IPT_WP_ID_set     ( scpb_reg_buffer, cpb_handle, index, push_port_id );
        scpb_reg_buffer_flush(scpb_reg_buffer);
    }
    /* If deallocating a page, write to valid first such that LPA and ID's are set when page is disabled */
    else
    {
        scpb_reg_field_PAGE_VALID_set    ( NULL, cpb_handle, index, page_valid);

        scpb_reg_field_IPT_QS_ID_set     ( scpb_reg_buffer, cpb_handle, index, pop_port_id );
        scpb_reg_field_IPT_WP_ID_set     ( scpb_reg_buffer, cpb_handle, index, push_port_id );
        scpb_reg_field_PAGE_VALID_set    ( scpb_reg_buffer, cpb_handle, index, page_valid);
        scpb_reg_buffer_flush(scpb_reg_buffer);

        /* Put the page in shutdown state and Dis-allow PMPM to automatically put this page in and out of light sleep as needed */
        pmpm_field_PWR_MODE_set           (pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM, index, 3);
        pmpm_field_DYNAMIC_ADDR_LS_EN_set ( pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM, index, 0);
        pmpm_field_DYNAMIC_LS_EN_set      ( pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM, index, 0);
        pmpm_buffer_flush( pmpm_buffer );

        pmpm_buffer_init    (pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_PL );
        pmpm_field_PWR_MODE_set           (pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_PL, index, 3);
        pmpm_field_DYNAMIC_ADDR_LS_EN_set ( pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_PL, index, 0);
        pmpm_field_DYNAMIC_LS_EN_set      ( pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_PL, index, 0);
        pmpm_buffer_flush( pmpm_buffer );

        pmpm_buffer_init    (pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_EOP );
        pmpm_field_PWR_MODE_set           (pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_EOP, index, 3);
        pmpm_field_DYNAMIC_ADDR_LS_EN_set ( pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_EOP, index, 0);
        pmpm_field_DYNAMIC_LS_EN_set      ( pmpm_buffer, cpb_handle, CPB_PMPM_INST_PMPM_EOP, index, 0);
        pmpm_buffer_flush( pmpm_buffer );
    }

#ifndef  CFC_REG_OP_CTXT_DISABLE
    /* Update var_t context */
    cpb_handle->var.page_inverted_page_table[index].ctrl_page_valid = page_valid;
    cpb_handle->var.page_inverted_page_table[index].ctrl_ipt_qs_id = pop_port_id;
    /* process MGMT FEGE port exception */
    if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type && CPB_FIFO_PUSHID_NIL != mfege_pop_port_id)
    {
        cpb_handle->var.page_inverted_page_table[index].mfege_ctrl_ipt_qs_id = mfege_pop_port_id;
    }
    cpb_handle->var.page_inverted_page_table[index].ctrl_ipt_wp_id = push_port_id;
#endif /* CFC_REG_OP_CTXT_DISABLE */

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_page_table_cfg */

/*******************************************************************************
*  cpb_block_table_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures the SCPB block table that maps pmpm blocks to queue
*   system instances.
*
*
* INPUTS:
*   *cpb_handle          - pointer to CFC handle instance.
*   basic_execute        - TRUE:  explicitly writes the three fields
*                          FALSE: respected IPT_BLOCK_VALID setting sequence
*   page_index           - the index of the page that the block belongs to
*   block_index          - the index of the block within the page which the block
*                          belongs to
*   block_valid          - the valid bit to be configured
*   queue_id             - the write queue id to be configured
*   lba                  - the IBA value to be configured
*
*
* OUTPUTS:
*    None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void cpb_block_table_cfg( cpb_handle_t *cpb_handle,
                                  BOOL8  basic_execute,
                                  UINT32 page_index,
                                  UINT32 block_index,
                                  UINT32 block_valid,
                                  UINT32 queue_id,
                                  UINT32 lba )
{
    UINT32 index;
    scpb_reg_buffer_t scpb_reg_buffer[1];
    PMC_ENTRY();

    if(basic_execute == FALSE)
    {
        /* If allocating a block, write to valid last such that LBA and WQID are set when block is enabled */
        if (1 == block_valid)
        {
            scpb_reg_buffer_init( scpb_reg_buffer, cpb_handle);
            scpb_reg_field_IPT_WQID_set    (scpb_reg_buffer, cpb_handle, page_index, block_index, queue_id);
            scpb_reg_field_IPT_LBA_set    (scpb_reg_buffer, cpb_handle, page_index, block_index, lba);
            scpb_reg_buffer_flush(scpb_reg_buffer);
    
            scpb_reg_buffer_init( scpb_reg_buffer, cpb_handle);
            scpb_reg_field_IPT_WQID_set    (scpb_reg_buffer, cpb_handle, page_index, block_index, queue_id);
            scpb_reg_field_IPT_LBA_set    (scpb_reg_buffer, cpb_handle, page_index, block_index, lba);
            scpb_reg_field_IPT_BLOCK_VALID_set (scpb_reg_buffer, cpb_handle, page_index, block_index, block_valid);
            scpb_reg_buffer_flush(scpb_reg_buffer);
        }
        /* If deallocating a block, write to valid first such that LBA and WQID are set when block is disabled */
        else
        {
            scpb_reg_field_IPT_BLOCK_VALID_set (NULL, cpb_handle, page_index, block_index, block_valid);
            scpb_reg_buffer_init( scpb_reg_buffer, cpb_handle);
            scpb_reg_field_IPT_WQID_set    (scpb_reg_buffer, cpb_handle, page_index, block_index, queue_id);
            scpb_reg_field_IPT_LBA_set    (scpb_reg_buffer, cpb_handle, page_index, block_index, lba);
            scpb_reg_field_IPT_BLOCK_VALID_set (scpb_reg_buffer, cpb_handle, page_index, block_index, block_valid);
            scpb_reg_buffer_flush(scpb_reg_buffer);
        }
    }
    else
    {
        scpb_reg_buffer_init( scpb_reg_buffer, cpb_handle);
        scpb_reg_field_IPT_WQID_set    (scpb_reg_buffer, cpb_handle, page_index, block_index, queue_id);
        scpb_reg_field_IPT_LBA_set    (scpb_reg_buffer, cpb_handle, page_index, block_index, lba);
        scpb_reg_field_IPT_BLOCK_VALID_set (scpb_reg_buffer, cpb_handle, page_index, block_index, block_valid);
        scpb_reg_buffer_flush(scpb_reg_buffer);
    }
    /*           page_index,block_index,block_valid,queue_id,lba); */
#ifndef  CFC_REG_OP_CTXT_DISABLE
    /* Update var_t context */

    index = page_index*cpb_handle->cfg.blocks_per_page + block_index;
    cpb_handle->var.block_inverted_page_table[index].ipt_valid = block_valid;
    cpb_handle->var.block_inverted_page_table[index].ipt_wqid = queue_id;
    cpb_handle->var.block_inverted_page_table[index].ipt_lba = lba;
#endif /* CFC_REG_OP_CTXT_DISABLE */

    PMC_RETURN();

} /* cpb_block_table_cfg */

/*******************************************************************************
*  cpb_fifo_end_addr_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function performs an end address update for a queue.  It will
*   monitor the success of the update and if unsuccessul abort the update.\n\n
*
*   If aborted CPB_ERR_END_ADDR_UPDATE_INCOMPLETE will be returned.  This
*   function terminates access to the FIFO Controller Configuration Interface
*   registers for the fifo_id.
*
*
* INPUTS:
*   *cpb_handle     - pointer to CPB handle instance.
*   push_port_id    - push port id
*   queue_system_id - queue system id, 1:1 mapped to the pop port id
*   write_qid       - write queue id
*   read_qid        - read queue id
*   end_address     - end address value that needs to be configured
*   cfg_mode        - TRUE: Dynamic Update, FIFO Write/Read Pointers out of reset
*                     FALSE: Initial Update, FIFO Write/Read Pointers in reset 
*   multicast       - Flag indicating whether this is a multicast or not
*                     case
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_fifo_end_addr_cfg(cpb_handle_t *cpb_handle,
                                        UINT32 push_port_id,
                                        UINT32 queue_system_id,
                                        UINT32 write_qid,
                                        UINT32 read_qid,
                                        UINT32 end_address,
                                        BOOL8 cfg_mode,
                                        BOOL8 multicast)
{
    /* Variable declaration */
    UINT32 queue_index;
    UINT32 num_iter;
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 value = 1, i = 0, attempt_max = 1;
    qs_buffer_t qs_buffer;

    PMC_ENTRY();

    /* argument checking */
    if (queue_system_id > 3) 
    {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    if(TRUE == multicast)
    {
        attempt_max = 2;
    }

    qs_buffer_init( &qs_buffer, cpb_handle, queue_system_id);
    PMC_LOG_TRACE("\nwith buffering ... \n");

    /* make the FIFO end address update request */
    qs_field_FIFO_END_ADDR_CHG_RID_set( &qs_buffer, cpb_handle, queue_system_id, read_qid);
    qs_field_FIFO_END_ADDR_CHG_WID_set( &qs_buffer, cpb_handle, queue_system_id, write_qid+push_port_id*256);
    /* note: the WID field has 10 bits, where the lower 8 bits of value gives write queue id,
       the higher 2 bits gives the push port id*/
    qs_field_FIFO_END_ADDR_set( &qs_buffer, cpb_handle, queue_system_id, end_address);
    qs_field_FIFO_END_ADDR_CHG_REQ_set( &qs_buffer, cpb_handle, queue_system_id, 1);


    qs_buffer_flush(&qs_buffer);
    /* confirm end address update when queue dynamically operating */
    if(cfg_mode == TRUE)  
    {
        for(i=0; i<attempt_max; i++)
        {
            /* 
             * disable the firmware queue since we need to look at the 
             * poll return status 
             */

            l5sys_firmware_queue_disable(cpb_handle);
        
            /* 
             * poll the END_ADDR_CHG_REQ bit for acknowledgment of the 
             * update request 
             */
            result = qs_field_FIFO_END_ADDR_CHG_REQ_poll(NULL, cpb_handle, queue_system_id, 0,
                                                         PMC_POLL_EQUAL, CPB_NUM_USEC_ITERATIONS,
                                                         &num_iter, 1);
            /* re-enable the firmware queue */
            l5sys_firmware_queue_enable(cpb_handle);

            if(TRUE== multicast && 0 == i)
            {
                if(PMC_SUCCESS != result) /* Polling the req bit timed out */
                {
                    PMC_ERROR temp_result = PMC_SUCCESS;
                    /* set the write pointer to in reset state */
                    temp_result = cpb_fifo_reset_wr_cfg(cpb_handle,
                                                        push_port_id,
                                                        queue_system_id,
                                                        write_qid,
                                                        1);
                    PMC_ASSERT(PMC_SUCCESS==temp_result, CPB_ERR_CODE_ASSERT, 0, 0);
                }
                else
                {
                    /* set for loop exit condition  */
                    i = attempt_max;
                }
            }

            if(TRUE == multicast && 1 == i)
            {
                /* return the write pointer to out of reset state */
                PMC_ERROR temp_result = PMC_SUCCESS;

                temp_result = cpb_fifo_reset_wr_cfg(cpb_handle,
                                                    push_port_id,
                                                    queue_system_id,
                                                    write_qid,
                                                    0);
                PMC_ASSERT(PMC_SUCCESS==temp_result, CPB_ERR_CODE_ASSERT, 0, 0);
            }
        }
        if(PMC_SUCCESS != result) /* Polling the req bit timed out */
        {
            /* Abort the request */
            PMC_LOG_TRACE("FIFO_END_ADDR_CHG_REQ was not serviced after %u iterations. Aborting...\n",num_iter);
    
            /* Abort the request */
            qs_field_FIFO_END_ADDR_CHG_ABORT_set( NULL, cpb_handle, queue_system_id, 1);
    
            /* Poll the abort to check when it's been serviced */
            value = qs_field_FIFO_END_ADDR_CHG_SUCCESS_get (NULL, cpb_handle, queue_system_id);
    
            if(1 == value)
                result = PMC_SUCCESS;
            else
                result = CPB_ERR_POLL_FAIL;
    
    
            if (PMC_SUCCESS == result)
            {
                PMC_LOG_TRACE("FIFO_END_ADDR_CHG_REQ was aborted, but it completed successfully before the abort was issued\n");
                result = PMC_SUCCESS; /* SUCCESSFUL COMPLETION The abort was not taken because the update succeeded */
            }
            else /* end address change abort operation failed */
            {
                PMC_LOG_TRACE("FIFO_END_ADDR_CHG_REQ failed and was aborted after %u iterations",num_iter);
                result = CPB_ERR_ADDR_CHG_ABORT;
            }
    
        } /*end if else req poll was successfull */
    } /* cfg_mode == TRUE operation */
#ifdef PMC_SW_SIMULATION
        result = PMC_SUCCESS;
#endif

#ifndef  CPB_REG_OP_CTXT_DISABLE
        /* MCPB fifo status will be updated in upper function. */
        if (CPB_INSTANCE_MCPB != cpb_handle->cfg.cpb_type)
        {
            if(PMC_SUCCESS == result)
            {
                /* Success modification of end address, update var_t context */
                
                queue_index =  cpb_fifo_var_data_queue_index_get(cpb_handle, queue_system_id, read_qid);
                
                cpb_handle->var.fifo_var_data[queue_index].fifo_end_addr = end_address;
                cpb_handle->var.fifo_var_data[queue_index].write_id = write_qid;
                cpb_handle->var.fifo_var_data[queue_index].status = CPB_FIFO_BEING_USED;
                cpb_handle->var.fifo_var_data[queue_index].push_port_id = push_port_id;
            }
        }
#endif /* CFC_REG_OP_CTXT_DISABLE */


    PMC_RETURN(result);

} /* cpb_fifo_end_addr_cfg */

/*******************************************************************************
*  cpb_fifo_reset_rd_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function takes the specified FIFO out of reset or
*   alternatively puts the specified FIFO into reset
*
*
* INPUTS:
*   *cpb_handle         - pointer to CPB handle instance.
*   queue_system_id     - queue system id
*   read_qid            - read queue id
*   reset_value         - 1: take the fifo into reset\n
*                         0: take the fifo out of reset
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_fifo_reset_rd_cfg(cpb_handle_t *cpb_handle,
                                        UINT32 queue_system_id,
                                        UINT32 read_qid,
                                        UINT32 reset_value)
{
    /* Variable declaration */
    PMC_ENTRY();

    /* argument checking */
    if (queue_system_id >= cpb_handle->cfg.pop_port_num) {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    qs_field_RPTR_RST_POP_set ( NULL, cpb_handle, queue_system_id, read_qid, reset_value );

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_fifo_reset_rd_cfg */

/*******************************************************************************
*  cpb_fifo_reset_wr_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function takes the specified FIFO out of reset or
*   alternatively puts the specified FIFO into reset
*
*
* INPUTS:
*   *cpb_handle         - pointer to CPB handle instance.
*   push_port_id        - push port id
*   queue_system_id     - queue system id
*   write_qid           - write queue id
*   reset_value         - 1: take the fifo into reset\n
*                         0: take the fifo out of reset
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_fifo_reset_wr_cfg(cpb_handle_t *cpb_handle,
                                        UINT32 push_port_id,
                                        UINT32 queue_system_id,
                                        UINT32 write_qid,
                                        UINT32 reset_value)
{
    /* Variable declaration */
    PMC_ENTRY();

    /* argument checking */
    if (push_port_id >= cpb_handle->cfg.push_port_num || queue_system_id >= cpb_handle->cfg.pop_port_num) {
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    switch(push_port_id)
    {
    case 0:
        qs_field_WPTR_RST_PUSH_P0_set( NULL, cpb_handle, queue_system_id, write_qid, reset_value);
        break;
    case 1:
        qs_field_WPTR_RST_PUSH_P1_set( NULL, cpb_handle, queue_system_id, write_qid, reset_value);
        break;
    case 2:
        qs_field_WPTR_RST_PUSH_P2_set( NULL, cpb_handle, queue_system_id, write_qid, reset_value);
        break;
    case 3:
        qs_field_WPTR_RST_PUSH_P3_set( NULL, cpb_handle, queue_system_id, write_qid, reset_value);
        break;
    default:
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_fifo_reset_wr_cfg */

/*******************************************************************************
*  cpb_fifo_reset_access_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures DBG_RADDR field in order to allow write access to
*   RPTR_RST and WPTR_RSTn fields within the queue system.
*
*
* INPUTS:
*   *cpb_handle         - pointer to CPB handle instance.
*   queue_system_id     - queue system id
*   action              - BOOL, defines pointer access type:\n
*                         TRUE:  Pointers may be written\n
*                         FALSE: Pointers not reliably writable, available for
*                                functional usage by queue system.
*
* OUTPUTS:
*    None.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_fifo_reset_access_cfg(cpb_handle_t *cpb_handle,
                                            UINT32 queue_system_id,
                                            BOOL8 action)
{
    /* Variable declaration */
    PMC_ENTRY();

    if (TRUE == pmc_cpb_reset_pointer_access_revision(&cpb_handle->base))
    {
        PMC_RETURN(PMC_SUCCESS);
    }
    else {
        /* argument checking */
        if (queue_system_id >= cpb_handle->cfg.pop_port_num)
        {
            PMC_RETURN(CPB_ERR_INVALID_ARG);
        }


        if(action == TRUE)
        {
            qs_reg_DBG_CTRL_write( NULL, cpb_handle, queue_system_id, 0xFF );
            /*qs_field_DBG_RADDR_set       ( NULL, cpb_handle, queue_system_id, 0xFF );   */
        } else {
            qs_reg_DBG_CTRL_write( NULL, cpb_handle, queue_system_id, 0x00 );
            /*qs_field_DBG_RADDR_set       ( NULL, cpb_handle, queue_system_id, 0x00 );*/
        }
    }

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_fifo_reset_access_cfg */

/*******************************************************************************
* cpb_var_t_reg_data_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function updates var_t register data to match the current settings
*   contained in device registers.
*
*   var_t register data is data used by SW driver that is directly traceable to
*   device register settings.
*
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*
* OUTPUTS:
*   *var_ptr               - pointer to cpb_var_t type context.  This will be
*                            updated by this API to reflect the register space
*                            settings.
*
* RETURNS:
*    PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_var_t_reg_data_update(cpb_handle_t *cpb_handle, cpb_var_t *var_ptr)
{

#ifndef PMC_SW_SIMULATION
    /* Variable declaration */
    UINT32 page_index,block_index,index;
    scpb_reg_buffer_t scpb_reg_buffer1;
    scpb_reg_buffer_t scpb_reg_buffer2;
    cpb_ctrl_buffer_t cpb_ctrl_buffer1;
    cpb_ctrl_buffer_t cpb_ctrl_buffer2;
    
    PMC_ENTRY();
    PMC_ASSERT(NULL != cpb_handle, CPB_ERR_NULL_HANDLE, 0, 0);
    scpb_reg_buffer_init(&scpb_reg_buffer1, cpb_handle);
    scpb_reg_buffer_init(&scpb_reg_buffer2, cpb_handle);
    
    cpb_ctrl_buffer_init(&cpb_ctrl_buffer1, cpb_handle);
    cpb_ctrl_buffer_init(&cpb_ctrl_buffer2, cpb_handle);
    



/* go through all pages and blocks and initialize these variables based on register settings */
    PMC_ASSERT(NULL != var_ptr, CPB_ERR_CODE_ASSERT,0,0);
    for( page_index = 0; page_index < cpb_handle->cfg.num_pages; page_index++)
    {
        PMC_LOG_TRACE("\n updating page %u ... \n",page_index);
        var_ptr->page_inverted_page_table[page_index].ctrl_page_valid = scpb_reg_field_PAGE_VALID_get(&scpb_reg_buffer1,cpb_handle,page_index);
        var_ptr->page_inverted_page_table[page_index].ctrl_ipt_qs_id = scpb_reg_field_IPT_QS_ID_get(&scpb_reg_buffer1,cpb_handle,page_index);
        var_ptr->page_inverted_page_table[page_index].ctrl_ipt_wp_id = scpb_reg_field_IPT_WP_ID_get(&scpb_reg_buffer1,cpb_handle,page_index);
        PMC_ATOMIC_YIELD(cpb_handle->base.parent_handle, 0);
        for(block_index = 0; block_index < cpb_handle->cfg.blocks_per_page; block_index++)
        {
            index = page_index * cpb_handle->cfg.blocks_per_page + block_index;
            var_ptr->block_inverted_page_table[index].ipt_valid = scpb_reg_field_IPT_BLOCK_VALID_get (&scpb_reg_buffer2, cpb_handle, page_index, block_index);
            var_ptr->block_inverted_page_table[index].ipt_wqid = scpb_reg_field_IPT_WQID_get(&scpb_reg_buffer2, cpb_handle, page_index, block_index);
            var_ptr->block_inverted_page_table[index].ipt_lba = scpb_reg_field_IPT_LBA_get(&scpb_reg_buffer2, cpb_handle, page_index, block_index);
        }
    }

    /* initialization of register tracable var_t data */
    if(CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type)
    {
        var_ptr->mcpb_im_sel.igr_ext_sel = cpb_ctrl_field_IM_IGR_EXT_SEL_get(&cpb_ctrl_buffer1, cpb_handle);
        var_ptr->mcpb_im_sel.egr_ext_sel = cpb_ctrl_field_IM_EGR_EXT_SEL_get(&cpb_ctrl_buffer1, cpb_handle);
        var_ptr->mcpb_im_sel.reflect_sel = cpb_ctrl_field_IM_REFLECT_SEL_get(&cpb_ctrl_buffer1, cpb_handle);
        var_ptr->mcpb_em_sel.em_egr_ext_sel = cpb_ctrl_field_EM_EGR_EXT_SEL_get(&cpb_ctrl_buffer2, cpb_handle);
        var_ptr->mcpb_em_sel.em_igr_ext_sel = cpb_ctrl_field_EM_IGR_EXT_SEL_get(&cpb_ctrl_buffer2, cpb_handle);
    } else if(CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type) {
        var_ptr->dcpb_em_sifd1_sel = cpb_ctrl_field_EGR_SIFD1_SEL_get ( NULL, cpb_handle );
        var_ptr->dcpb_em_sifd2_sel = cpb_ctrl_field_EGR_SIFD2_SEL_get ( NULL, cpb_handle );
    }

#endif

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_var_t_reg_data_update */

/*******************************************************************************
* cpb_dcs_burst_xfer_mode_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures the burst and transfer mode settings for DCS.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   slice                 - DCS instance 0 to 3
*   xfer_mode             - Enum, interface transfer mode:\n
*                           CPB_XFER_PACKET\n
*                           CPB_XFER_SEGMENT
*   burst_mode            - Enum, interface burst mode:\n
*                           CPB_BURST_OFF\n
*                           CPB_BURST_128\n
*                           CPB_BURST_192\n
*                           CPB_BURST_256
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_burst_xfer_mode_cfg( cpb_handle_t *h,
                                              UINT32 slice,
                                              cpb_xfer_mode_type_t xfer_mode,
                                              cpb_burst_mode_t burst_mode )
{
    UINT32 xfer_mode_val, burst_size, burst_en;
    dcs_buffer_t dcs_buffer;

    PMC_ENTRY();

    /* Argument checking*/
    PMC_ASSERT( slice < h->cfg.num_dcs, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT( xfer_mode < LAST_CPB_XFER_MODE_TYPE, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT( burst_mode < LAST_CPB_BURST, CPB_ERR_INVALID_ARG, 0, 0);

    if (xfer_mode == CPB_XFER_MODE_TYPE_PACKET) xfer_mode_val = 1;
    else if (xfer_mode == CPB_XFER_MODE_TYPE_SEGMENT) xfer_mode_val = 0;
    else xfer_mode_val = 2; /*invalid*/

    switch(burst_mode)
    {
        case CPB_BURST_WORD:
            burst_size = 0;
            burst_en = 0;
            break;
        case CPB_BURST_128:
            burst_size = 128;
            burst_en = 1;
            break;
        case CPB_BURST_192:
            burst_size = 192;
            burst_en = 1;
            break;
        case CPB_BURST_256:
            burst_size = 256;
            burst_en = 1;
            break;
        default:
            burst_size = 0;
            burst_en = 0;
            PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG, 0, 0);
    }

    dcs_buffer_init(&dcs_buffer, h, slice);

    /* apply field settings */
    dcs_field_DCS_BURST_SIZE_set( &dcs_buffer, h, slice, burst_size );
    dcs_field_DCS_BURST_MODE_set( &dcs_buffer, h, slice, burst_en );
    dcs_field_DCS_XFER_MODE_set( &dcs_buffer, h, slice, xfer_mode_val );

    dcs_buffer_flush(&dcs_buffer);

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_dcs_burst_xfer_mode_cfg */

/*******************************************************************************
* cpb_dcs_burst_xfer_mode_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures the burst and transfer mode settings for DCS.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   slice                 - DCS instance 0 to 3
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   cpb_xfer_mode_type_t - DCS_XFER_MODE used by DCS instance
*
* NOTES:
*
*******************************************************************************/
PUBLIC cpb_xfer_mode_type_t cpb_dcs_burst_xfer_mode_get( cpb_handle_t *h,
                                                         UINT32 slice )
{
    UINT32 xfer_mode_val;
    cpb_xfer_mode_type_t xfer_mode = LAST_CPB_XFER_MODE_TYPE;

    PMC_ENTRY();

    /* Argument checking*/
    PMC_ASSERT( slice < h->cfg.num_dcs, CPB_ERR_INVALID_ARG, 0, 0);

    /* retrieve field settings */
    xfer_mode_val = dcs_field_DCS_XFER_MODE_get(NULL, h, slice);

    if (xfer_mode_val == 1) xfer_mode = CPB_XFER_MODE_TYPE_PACKET;
    else if (xfer_mode_val == 0) xfer_mode = CPB_XFER_MODE_TYPE_SEGMENT;
    else PMC_ASSERT(FALSE, CPB_ERR_CODE_ASSERT, 0, 0);

    PMC_RETURN(xfer_mode);

} /* cpb_dcs_burst_xfer_mode_cfg_get */

/*******************************************************************************
* cpb_dpi_slave_port_burst_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures burst interface configuration for a DPI Slave
*   port. This is configuration that is common to all channels within the port.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Master Port Number:\n
*                           0 to 7
*   burst_mode            - Enum, interface burst mode:\n
*                           CPB_BURST_OFF\n
*                           CPB_BURST_128\n
*                           CPB_BURST_192\n
*                           CPB_BURST_256
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_slave_port_burst_cfg( cpb_handle_t *h,
                                               UINT32 port,
                                               cpb_burst_mode_t burst_mode )
{
    UINT32 burst_en;

    PMC_ENTRY();

    /* Argument checking */
    PMC_ASSERT( burst_mode < LAST_CPB_BURST, CPB_ERR_INVALID_ARG, 0, 0);

    switch(burst_mode)
    {
        case CPB_BURST_WORD:
            burst_en = 0;
            break;
        case CPB_BURST_128:
            burst_en = 1;
            break;
        case CPB_BURST_192:
            burst_en = 1;
            break;
        case CPB_BURST_256:
            burst_en = 1;
            break;
        default:
            burst_en = 0;
            PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG, 0, 0);
    }

    /* Apply field settings */
    slave_dpi_field_BURST_EN_set  ( NULL, h, port, burst_en );

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_dpi_slave_port_burst_cfg */

/*******************************************************************************
* cpb_dpi_slave_port_chnl_zone_ovrd_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures zone status reporting behavior for a DPI Slave Port
*   channel.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   slave_port            - DPI Slave Port Number.  Legal values:\n
*                           0: SIFD 1\n
*                           1: SIFD 2\n
*                           2: CBRC\n
*                           3: ENET_SYS\n
*                           4: MAPOTN\n
*                           5: ENET_LINE
*   slave_chnl            - DPI Slave Port Channel.
*   mode                  - Enum, zone status reporting type\n
*                           CPB_SLV_CHNL_ZONE_FIFO = 0,\n
*                           CPB_SLV_CHNL_ZONE_FIFO_AND_MSTR_XOFF\n
*                           CPB_SLV_CHNL_ZONE_FORCE,\n
*   master_port           - DPI Master Port Number, only valid for mode set to
*                           CPB_SLV_CHNL_ZONE_FIFO_AND_MSTR_XOFF
*   master_chnl           - DPI Master Port Channel, only valid for mode set
*                           to CPB_SLV_CHNL_ZONE_FIFO_AND_MSTR_XOFF
*
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_slave_port_chnl_zone_ovrd_cfg(cpb_handle_t  *h,
                                                       UINT32 slave_port,
                                                       UINT32 slave_chnl,
                                                       cpb_dpi_chnl_zone_mode_t mode,
                                                       UINT32 master_port,
                                                       UINT32 master_chnl)
{
    UINT32 zone_ovrd_en, zone_ovrd_cfg;
    slave_dpi_buffer_t slave_dpi_buffer;

    PMC_ENTRY();

    /* determine field settings */
    switch(mode)
    {
        case CPB_SLV_CHNL_ZONE_FIFO: /* No override */
            zone_ovrd_en = 0;
            zone_ovrd_cfg = 0;
            break;
        case CPB_SLV_CHNL_ZONE_FIFO_AND_MSTR_XOFF: /* Xoff override */
            zone_ovrd_en = 1;
            zone_ovrd_cfg = 0;
            break;
        case CPB_SLV_CHNL_ZONE_FORCE: /* Register override */
            zone_ovrd_en = 1;
            zone_ovrd_cfg = 1;
            break;
        default:
            zone_ovrd_en = 1;
            zone_ovrd_cfg = 1;
            PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    slave_dpi_buffer_init(&slave_dpi_buffer, h, slave_port);

    /* apply field settings */
    slave_dpi_field_ZONE_OVRD_EN_set( &slave_dpi_buffer, h, slave_port, slave_chnl, zone_ovrd_en);
    slave_dpi_field_ZONE_OVRD_CFG_set( &slave_dpi_buffer, h, slave_port, slave_chnl, zone_ovrd_cfg );

    /* Extra config for zone bypass */
    if(mode == CPB_SLV_CHNL_ZONE_FIFO_AND_MSTR_XOFF)
    {
        slave_dpi_field_ZONE_OVRD_DPI_MST_set( &slave_dpi_buffer, h, slave_port, slave_chnl, master_port );
        slave_dpi_field_ZONE_OVRD_XOFF_CH_set( &slave_dpi_buffer, h, slave_port, slave_chnl, master_chnl );
    }

    slave_dpi_buffer_flush(&slave_dpi_buffer);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dpi_slave_port_chnl_zone_ovrd_cfg */

/*******************************************************************************
* cpb_dpi_slave_port_chnl_map_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures zone status for a DPI Slave Port channel, when
*   operating in ZONE BYPASS mode.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Slave Port Number.  Legal values:\n
*                           0: SIFD 1\n
*                           1: SIFD 2\n
*                           2: CBRC\n
*                           3: ENET_SYS\n
*                           4: MAPOTN\n
*                           5: ENET_LINE
*   chnl                  - DPI Slave Port Channel.
*   dpi_mstr_port         - DPI Master Port Number, only valid for mode set to
*                           CPB_SLV_CHNL_ZONE_FIFO_AND_MSTR_XOFF
*   dpi_mstr_chnl         - DPI Master Port Channel, only valid for mode set
*                           to CPB_SLV_CHNL_ZONE_FIFO_AND_MSTR_XOFF
*
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_slave_port_chnl_map_cfg(cpb_handle_t  *h,
                                                 UINT32 port,
                                                 UINT32 chnl,
                                                 UINT32 dpi_mstr_port,
                                                 UINT32 dpi_mstr_chnl)
{
    slave_dpi_buffer_t slave_dpi_buffer;

    PMC_ENTRY();

    slave_dpi_buffer_init(&slave_dpi_buffer, h, port);

    /* apply field settings */
    slave_dpi_field_ZONE_OVRD_DPI_MST_set( &slave_dpi_buffer, h, port, chnl, dpi_mstr_port );
    slave_dpi_field_ZONE_OVRD_XOFF_CH_set( &slave_dpi_buffer, h, port, chnl, dpi_mstr_chnl );

    slave_dpi_buffer_flush(&slave_dpi_buffer);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dpi_slave_port_chnl_map_cfg */


/*******************************************************************************
* cpb_dpi_slave_port_chnl_zone_type_cfg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function return zone status reporting behavior for a DPI Slave Port
*   channel.\n\n
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Slave Port Number.  Legal values:\n
*                           0: SIFD 1\n
*                           1: SIFD 2\n
*                           2: CBRC\n
*                           3: ENET_SYS\n
*                           4: MAPOTN\n
*                           5: ENET_LINE
*   chnl                  - DPI Slave Port Channel.
*
* OUTPUTS:
*   *mode                  - Enum, zone status reporting type\n
*                           CPB_SLV_CHNL_ZONE_FIFO = 0,\n
*                           CPB_SLV_CHNL_ZONE_FIFO_AND_MSTR_XOFF\n
*                           CPB_SLV_CHNL_ZONE_FORCE,
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_slave_port_chnl_zone_type_cfg_get(cpb_handle_t  *h,
                                                           UINT32 port,
                                                           UINT32 chnl,
                                                           cpb_dpi_chnl_zone_mode_t *mode)
{
    UINT32 zone_ovrd_en, zone_ovrd_cfg;

    PMC_ENTRY();

    zone_ovrd_en  = slave_dpi_field_ZONE_OVRD_EN_get( NULL, h, port, chnl);
    zone_ovrd_cfg = slave_dpi_field_ZONE_OVRD_CFG_get( NULL, h, port, chnl);

    if (zone_ovrd_en == 1 && zone_ovrd_cfg == 1)
    {
        *mode = CPB_SLV_CHNL_ZONE_FORCE;
    } else
    {
        *mode = (zone_ovrd_en == 1)?CPB_SLV_CHNL_ZONE_FIFO_AND_MSTR_XOFF:CPB_SLV_CHNL_ZONE_FIFO;
    }

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dpi_slave_port_chnl_zone_type_cfg_get */

/*******************************************************************************
* cpb_dpi_slave_port_chnl_zone_thresh_cfg_check
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function checks and configures zone threshold settings for a DPI Slave
*   port channel.\n\n
*
*   Zone threshold settings are in units of 48 byte increments.  Zone thresholds
*   must be set ZONE_THR_0_1 < ZONE_THR_1_2 < ZONE_THR_2_3.  Zone thresholds may
*   not exceed the total number of 48 byte increments available in the CFC FIFO
*   associated with the queue ID for the master queue system.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Slave Port Number.  Legal values:\n
*                           0: SIFD 1\n
*                           1: SIFD 2\n
*                           2: CBRC\n
*                           3: ENET_SYS\n
*                           4: MAPOTN\n
*                           5: ENET_LINE
*   chnl                  - DPI Slave Port Channel.
*   zone_0_1              - Zone threshold between 00 and 01 FIFO occupancy
*   zone_1_2              - Zone threshold between 01 and 10 FIFO occupancy
*   zone_2_3              - Zone threshold between 10 and 11 FIFO occupancy
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_slave_port_chnl_zone_thresh_cfg_check(cpb_handle_t *h,
                                                               UINT32 port,
                                                               UINT32 chnl,
                                                               UINT32 zone_0_1,
                                                               UINT32 zone_1_2,
                                                               UINT32 zone_2_3)
{
    PMC_ERROR rc = PMC_SUCCESS;



    PMC_ENTRY();

    if ( (  zone_0_1 >= zone_1_2 && !(zone_0_1==0 && zone_1_2==0) ) ||
         (  zone_1_2 >= zone_2_3 && !(zone_1_2==0 && zone_2_3==0) ) )
    {
        rc = CPB_ERR_INVALID_ARG;
    }


    /* this check is not ready */
    if (PMC_SUCCESS == rc)
    {
        UINT32 min_num_blocks;
        UINT32 max_num_blocks;
        rc = cpb_dpi_slave_port_chnl_min_max_num_block_get(h,port,chnl,&min_num_blocks,&max_num_blocks);
        PMC_LOG_TRACE("\nChecking zone threshold: \n port = %u \n chnl = %u zone = %u min = %u max = %u\n",port,chnl,zone_2_3, min_num_blocks,max_num_blocks);
        rc = PMC_SUCCESS;
    }

    if (PMC_SUCCESS == rc)
    {
        rc = cpb_dpi_slave_port_chnl_zone_thresh_cfg(h, port, chnl,zone_0_1, zone_1_2, zone_2_3);
    }

    PMC_RETURN(rc);
} /* cpb_dpi_slave_port_chnl_zone_thresh_cfg_check */

/*******************************************************************************
* cpb_dpi_slave_port_chnl_zone_thresh_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures zone threshold settings for a DPI Slave port
*   channel.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Slave Port Number.  Legal values:\n
*                           0: SIFD 1\n
*                           1: SIFD 2\n
*                           2: CBRC\n
*                           3: ENET_SYS\n
*                           4: MAPOTN\n
*                           5: ENET_LINE
*   chnl                  - DPI Slave Port Channel.
*   zone_0_1              - Zone threshold between 00 and 01 FIFO occupancy
*   zone_1_2              - Zone threshold between 01 and 10 FIFO occupancy
*   zone_2_3              - Zone threshold between 10 and 11 FIFO occupancy
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_slave_port_chnl_zone_thresh_cfg(cpb_handle_t *h,
                                                         UINT32 port,
                                                         UINT32 chnl,
                                                         UINT32 zone_0_1,
                                                         UINT32 zone_1_2,
                                                         UINT32 zone_2_3)
{
    PMC_ENTRY();

    /* apply field settings */
    slave_dpi_field_ZONE_THR_0_1_set ( NULL, h, port, chnl, zone_0_1);
    slave_dpi_field_ZONE_THR_1_2_set ( NULL, h, port, chnl, zone_1_2);
    slave_dpi_field_ZONE_THR_2_3_set ( NULL, h, port, chnl, zone_2_3);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dpi_slave_port_chnl_zone_thresh_cfg */

/*******************************************************************************
* cpb_dpi_slave_port_chnl_zone_thresh_cfg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function returns zone threshold settings for a DPI Slave port
*   channel.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Slave Port Number.  Legal values:\n
*                           0: SIFD 1\n
*                           1: SIFD 2\n
*                           2: CBRC\n
*                           3: ENET_SYS\n
*                           4: MAPOTN\n
*                           5: ENET_LINE
*   chnl                  - DPI Slave Port Channel.
*
* OUTPUTS:
*   *zone_0_1              - Zone threshold between 00 and 01 FIFO occupancy
*   *zone_1_2              - Zone threshold between 01 and 10 FIFO occupancy
*   *zone_2_3              - Zone threshold between 10 and 11 FIFO occupancy
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_slave_port_chnl_zone_thresh_cfg_get(cpb_handle_t *h,
                                                             UINT32 port,
                                                             UINT32 chnl,
                                                             UINT32 *zone_0_1,
                                                             UINT32 *zone_1_2,
                                                             UINT32 *zone_2_3)
{
    PMC_ENTRY();

    /* apply field settings */
    *zone_0_1 = slave_dpi_field_ZONE_THR_0_1_get ( NULL, h, port, chnl);
    *zone_1_2 = slave_dpi_field_ZONE_THR_1_2_get ( NULL, h, port, chnl);
    *zone_2_3 = slave_dpi_field_ZONE_THR_2_3_get ( NULL, h, port, chnl);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dpi_slave_port_chnl_zone_thresh_cfg_get */

/*******************************************************************************
* cpb_dpi_mstr_port_chnl_zone_mode_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures zone status reporting behavior for a DPI Master
*   Port channel.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Master Port Number.  Legal values (DCPB/OCPB/MCPB):\n
*                           0: SIFD 1\n
*                           1: SIFD 2\n
*                           2: CBRC\n
*                           3: ENET_SYS\n
*                           4: MAPOTN\n
*                           5: ENET_LINE
*   chnl                  - DPI Slave Port Channel.
*   mode                  - Enum, zone status reporting type\n
*                           CPB_SLV_CHNL_ZONE_FIFO = 0,\n
*                           CPB_SLV_CHNL_ZONE_FORCE
*
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_mstr_port_chnl_zone_mode_cfg(cpb_handle_t  *h,
                                                       UINT32 port,
                                                       UINT32 chnl,
                                                       cpb_dpi_chnl_zone_mode_t mode)
{
    UINT32 zone_ovrd_en;
    UINT32 zone_ovrd_cfg;

    master_dpi_buffer_t master_dpi_buf[1];

    PMC_ENTRY();

    /* determine field settings */
    switch(mode)
    {
        case CPB_SLV_CHNL_ZONE_FIFO: /* No override */
            zone_ovrd_en = 0;
            zone_ovrd_cfg = 1;
            break;
        case CPB_SLV_CHNL_ZONE_FORCE: /* Register override */
            zone_ovrd_en = 1;
            zone_ovrd_cfg = 1;
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    /* apply field settings */
    master_dpi_buffer_init(master_dpi_buf, h, port);
    master_dpi_field_ZONE_OVRD_EN_set(master_dpi_buf, h, port, chnl, zone_ovrd_en );
    master_dpi_field_ZONE_OVRD_CFG_set(master_dpi_buf, h, port, chnl, zone_ovrd_cfg );
    master_dpi_buffer_flush(master_dpi_buf);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dpi_mstr_port_chnl_zone_mode_cfg */

/*******************************************************************************
* cpb_dpi_slave_port_zone_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures Zone interface configuration for a DPI Slave port.
*   This is configuration that is common to all channels within the port.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Slave Port Number.  Legal values:\n
*                           0: SIFD 1\n
*                           1: SIFD 2\n
*                           2: CBRC\n
*                           3: ENET_SYS\n
*                           4: MAPOTN\n
*                           5: ENET_LINE
*   num_chnl              - Number of channels within the port
*   ovrd_val              - ZONE override value.  Zone Value transmit to upstream
*                           used for all port channels when flow control mode set
*                           to CPB_SLV_CHNL_ZONE_FORCE or
*                           CPB_SLV_CHNL_ZONE_FIFO_AND_MSTR_XOFF (in presence
*                           of XOFF assertion)
*   burst_mode            - Burst mode enabled
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*/
/*
* NOTES:
*******************************************************************************/

PUBLIC PMC_ERROR cpb_dpi_slave_port_zone_cfg(cpb_handle_t *h,
                                             UINT32 port,
                                             UINT32 num_chnl,
                                             UINT32 ovrd_val, cpb_burst_mode_t burst_mode)
{
    UINT32 zone_cfg, zone_en;
    slave_dpi_buffer_t slave_dpi_buffer;

    PMC_ENTRY();

    /* Default to zone enabled and configured for slave_id mode */
    zone_en = 1;
    zone_cfg = 0;

    PMC_ASSERT(port <= h->cfg.max_slv_dpi_port,CPB_ERR_INVALID_ARG,0,0);

    switch(h->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
            /* CBRC port does not support zone */
            if(CPB_DCPB_DPI_PORT_CBRC == port)
            {
                zone_en = 0;
            }
            /* SIFD ports configured for round-robin mode */
            else if(CPB_DCPB_DPI_PORT_SIFD1 == port || CPB_DCPB_DPI_PORT_SIFD2 == port)
            {
                zone_cfg = 1;
            }
            break;
        case CPB_INSTANCE_MCPB:
            /* ENET line/sys/reflect ports do not support zone */
            if (CPB_MCPB_ING_CPU_INS != port && CPB_MCPB_ING_FEGE_INS != port)
            {
                zone_en = 0;
            }
            /* CPU, FEGE ports configured for round-robin mode*/
            else
            {
                zone_cfg = 1;
            }
            break;
        case CPB_INSTANCE_OCPB:
            /* ODUk ports do not support zone */
            /*SIFD1 port is provisioned differently in SYSOTN card application*/
            if ( (CPB_DCPB_DPI_PORT_SIFD1 != port && CPB_DCPB_DPI_PORT_SIFD2 != port)
                  || (CPB_DCPB_DPI_PORT_SIFD1 == port && h->cfg.sysotn_mode == TRUE))
            {
                zone_en = 0;
            }
            /* SIFD ports configured for round-robin mode */
            else
            {
                if (burst_mode == CPB_BURST_WORD)
                {
                    zone_cfg = 0;
                }
                else
                {
                    zone_cfg = 1;
                }
            }
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    slave_dpi_buffer_init(&slave_dpi_buffer, h, port);

    /* apply field settings */
    slave_dpi_field_ZONE_EN_set(&slave_dpi_buffer, h, port, zone_en);
    slave_dpi_field_ZONE_CFG_set(&slave_dpi_buffer, h, port, zone_cfg);
    slave_dpi_field_ZONE_OVRD_VAL_set(&slave_dpi_buffer, h, port, ovrd_val);
    slave_dpi_field_ZONE_MAX_CH_set(&slave_dpi_buffer, h, port, num_chnl);

    slave_dpi_buffer_flush(&slave_dpi_buffer);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dpi_slave_port_zone_cfg */

/*******************************************************************************
* cpb_dpi_slave_port_hdr_remove_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures packet header removal interface configuration for
*   a DPI Slave port. This is configuration that is common to all channels
*   within the port.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Slave Port Number:\n
*                           0 to 7
*   hdr_size              - Number of header bytes to strip for channels
*                           within the port that have header stripping
*                           enabled
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_slave_port_hdr_remove_cfg(cpb_handle_t *h,
                                                   UINT32 port,
                                                   UINT32 hdr_size)
{
    /*
        Provides configuration of fields:
            HDR_SIZE
        Need input from Pat as to which subsystems use this feature and if this is
        something that is visible externally for data coming from SIFD, that is
        external header gets stripped before going to downstream subsystems.  What
        are the SIFD transfer formats.

        There is a table showing when this is used.
    */

    PMC_ENTRY();

    /* apply field settings */
    slave_dpi_field_HDR_SIZE_set(NULL, h, port, hdr_size);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dpi_slave_port_hdr_remove_cfg */

/*******************************************************************************
* cpb_dpi_slave_port_chnl_hdr_strip_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures header stripping for a DPI slave port channel.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Slave Port Number:\n
*                           0 to cpb_handle->cfg.max_slv_dpi_port
*   chnl                  - DPI Slave Port Channel Number:\n
*                           0 to cpb_handle->cfg.max_dpi_slv_chnl_id[port]
*   strip                 - Header stripping operation:\n
*                           0: Do not strip header\n
*                           1: Strip header
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_slave_port_chnl_hdr_strip_cfg(cpb_handle_t *h,
                                                       UINT32 port,
                                                       UINT32 chnl,
                                                       UINT32 strip)
{
    PMC_ENTRY();

    slave_dpi_buffer_t slave_dpi_buf[1];

    if(port > h->cfg.max_slv_dpi_port)
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    /* apply field settings */
    slave_dpi_buffer_init(slave_dpi_buf, h, port);
    slave_dpi_field_HDR_EN_set(slave_dpi_buf, h, port, chnl, strip);
    slave_dpi_buffer_flush(slave_dpi_buf);


    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dpi_slave_port_chnl_hdr_strip_cfg */

/*******************************************************************************
* cpb_dpi_slave_port_chnl_rd_queue_map_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures the destination read queue ID processed by DCS for a DPI
*   slave port channel, the pop port id is given by queue system id.
*
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Slave Port Number:\n
*                           0 to 7
*   chnl                  - DPI Slave Port Channel Number:
*   queue_system          - Queue System transferring channel
*   rd_queue_id           - Read Queue ID processed by DCS
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_slave_port_chnl_rd_queue_map_cfg(cpb_handle_t *h,
                                                          UINT32 port,
                                                          UINT32 chnl,
                                                          UINT32 queue_system,
                                                          UINT32 rd_queue_id)
{
    PMC_ENTRY();

    /* determine field settings and apply */
    switch(queue_system)
    {
        case 0: /* Pop port 0 */
            slave_dpi_field_QS0_POP_QID_set(NULL, h, port, chnl, rd_queue_id);
            break;
        case 1: /* Pop port 1 */
            slave_dpi_field_QS1_POP_QID_set(NULL, h, port, chnl, rd_queue_id);
            break;
        case 2: /* Pop port 2 */
            slave_dpi_field_QS2_POP_QID_set(NULL, h, port, chnl, rd_queue_id);
            break;
        case 3: /* Pop port 3 */
            slave_dpi_field_QS3_POP_QID_set(NULL, h, port, chnl, rd_queue_id);
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dpi_slave_port_chnl_rd_queue_map_cfg */

/*******************************************************************************
* cpb_dpi_slave_port_chnl_enbl
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function enables transfer of data from a DPI slave port to a queue
*   system.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Slave Port Number:\n
*                           0 to 7
*   chnl                  - DPI Slave Port Channel Number
*   queue_system          - Queue System transferring channel
*   enable                - Enabled state of channel writing to queue system,
*                           queue\n
*                           0: Disabled\n
*                           1: Enabled
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_slave_port_chnl_enbl(cpb_handle_t *h,
                                              UINT32 port,
                                              UINT32 chnl,
                                              UINT32 queue_system,
                                              UINT32 enable)
{
    PMC_ENTRY();

    PMC_LOG_TRACE("\nEnabling source port and channel: \n port = %u \n chnl = %u\n",port,chnl);

    /* determine field settings and apply */
#if  defined(PMC_SW_SIMULATION)
    switch(queue_system)
    {
        case 0: /* Push port 0 */
            slave_dpi_field_QS0_CH_EN_set(NULL, h, port, chnl, enable);
            break;
        case 1: /* Push port 1 */
            slave_dpi_field_QS1_CH_EN_set(NULL, h, port, chnl, enable);
            break;
        case 2: /* Push port 2 */
            slave_dpi_field_QS2_CH_EN_set(NULL, h, port, chnl, enable);
            break;
        case 3: /* Push port 3 */
            slave_dpi_field_QS3_CH_EN_set(NULL, h, port, chnl, enable);
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
    }
#else
    if(h->cfg.cpb_type == CPB_INSTANCE_MCPB)
    {
        switch(queue_system)
        {
            case 0: /* Push port 0 */
                slave_dpi_field_QS0_CH_EN_set(NULL, h, port, chnl, enable);
                break;
            case 1: /* Push port 1 */
                slave_dpi_field_QS1_CH_EN_set(NULL, h, port, chnl, enable);
                break;
            case 2: /* Push port 2 */
                slave_dpi_field_QS2_CH_EN_set(NULL, h, port, chnl, enable);
                break;
            case 3: /* Push port 3 */
                slave_dpi_field_QS3_CH_EN_set(NULL, h, port, chnl, enable);
                break;
            default:
                PMC_RETURN(CPB_ERR_INVALID_ARG);
        }
    }
#endif /*defined(PMC_EMULATION)| defined(PMC_VERIFICATION) || defined(PMC_SW_SIMULATION) */

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dpi_slave_port_chnl_enbl */

/*******************************************************************************
* mcpb_dpi_slave_port_chnl_flush
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function flushes MCPB channel path queue.
*
*
* INPUTS:
*    *handle            - pointer to CPB handle instance.
*    egr_port           - type of the egress port
*    egr_chnl           - egress channel
*    ingr_port          - type of the ingress port
*    ingr_chnl          - ingress channel
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR mcpb_dpi_slave_port_chnl_flush(cpb_handle_t *handle,
                                                UINT32        egr_port,
                                                UINT32        egr_chnl,
                                                UINT32        ingr_port,
                                                UINT32        ingr_chnl)
{
    PMC_ERROR rc = PMC_SUCCESS;

    /* these are the vars that we will be using */
    UINT32 dcs;
    UINT32 ram_chid;
    UINT32 slv_port;
    UINT32 slv_chid;

    UINT32 wr_chid =  DEFAULT_32BIT_INVALID;
    UINT32 rd_chid = DEFAULT_32BIT_INVALID;
    UINT32 wr_qid = DEFAULT_32BIT_INVALID;
    UINT32 rd_qid = DEFAULT_32BIT_INVALID;

    UINT32 egress_mux_output_port = egr_port;
    UINT32 egress_mux_output_port_chnl = egr_chnl;
    UINT32 push_port_id = 999,queue_system_id = 999;
    UINT32 ingress_mux_input_port, ingress_mux_input_port_chnl;
    UINT32 egress_mux_input_port = 999;
    UINT32 dcs_entry = 999;
    UINT32 itr;
    UINT32 ram_channel = 999;
    UINT32 ram_sf1;
    UINT32 ram_sf2;
    UINT32 ram_ch;
    UINT32 ram_id;

    PMC_ENTRY();

    ingress_mux_input_port_chnl = ingr_chnl;

    if (PMC_SUCCESS == rc)
    {
        /* determine the source port id and source port channel id, as well as the
           push port and pop port id */
        switch(egress_mux_output_port)
        {
            case CPB_MCPB_EGR_SYS_ING:
                if(handle->var.mcpb_em_sel.em_igr_ext_sel != 1)
                {
                    rc = CPB_ERR_INVALID_ARG;
                }
                queue_system_id = 0;
                egress_mux_input_port = 0;
                push_port_id = 2;
                ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
                break;
            case CPB_MCPB_EGR_LINE_ING:
                if(handle->var.mcpb_em_sel.em_igr_ext_sel != 0)
                {
                   rc = CPB_ERR_INVALID_ARG;
                }
                queue_system_id = 0;
                egress_mux_input_port = 0;
                push_port_id = 2;
                ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
                break;
            case CPB_MCPB_EGR_SYS_EG:
                if(handle->var.mcpb_em_sel.em_egr_ext_sel != 1)
                {
                   rc = CPB_ERR_INVALID_ARG;
                }
                queue_system_id = 1;
                egress_mux_input_port = 1;
                push_port_id = 2;
                ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
                break;
            case CPB_MCPB_EGR_LINE_EG:
                if(handle->var.mcpb_em_sel.em_egr_ext_sel != 0)
                {
                   rc = CPB_ERR_INVALID_ARG;
                }
                queue_system_id = 1;
                egress_mux_input_port = 1;
                push_port_id = 2;
                ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
                break;
            case CPB_MCPB_EGR_CPU:
                queue_system_id = 2;
                egress_mux_input_port = 2;
                switch(egress_mux_output_port_chnl % 4)
                {
                    case 0:
                        push_port_id = 1;
                        ingress_mux_input_port = (0 == handle->var.mcpb_im_sel.egr_ext_sel) ? CPB_MCPB_ING_LINE_EM_EXT : CPB_MCPB_ING_SYS_EM_EXT;
                        break;
                    case 1:
                        push_port_id = 0;
                        ingress_mux_input_port = (0 == handle->var.mcpb_im_sel.igr_ext_sel) ? CPB_MCPB_ING_LINE_IM_EXT : CPB_MCPB_ING_SYS_IM_EXT;
                        break;
                    case 2:
                        push_port_id = 3;
                        ingress_mux_input_port = (0 == handle->var.mcpb_im_sel.reflect_sel) ? CPB_MCPB_ING_LINE_REF : CPB_MCPB_ING_SYS_REF;
                        break;
                    case 3:
                        if((egress_mux_output_port_chnl / 4) != 0)
                        {
                            rc = CPB_ERR_INVALID_ARG;
                        }
                        push_port_id = 2;
                        ingress_mux_input_port = CPB_MCPB_ING_FEGE_INS;
                        break;
                    default:
                        rc = CPB_ERR_INVALID_ARG;
                }
                break;
            case CPB_MCPB_EGR_FEGE:
                queue_system_id = 2;
                egress_mux_input_port = 3;
                switch(egress_mux_output_port_chnl % 4)
                {
                    case 0:
                        push_port_id = 1;
                        ingress_mux_input_port = (0 == handle->var.mcpb_im_sel.egr_ext_sel) ? CPB_MCPB_ING_LINE_EM_EXT : CPB_MCPB_ING_SYS_EM_EXT;
                        break;
                    case 1:
                        push_port_id = 0;
                        ingress_mux_input_port = (0 == handle->var.mcpb_im_sel.igr_ext_sel) ? CPB_MCPB_ING_LINE_IM_EXT : CPB_MCPB_ING_SYS_IM_EXT;
                        break;
                    case 3:
                        if((egress_mux_output_port_chnl / 4) != 0)
                        {
                            rc = CPB_ERR_INVALID_ARG;
                        }
                        push_port_id = 2;
                        ingress_mux_input_port = CPB_MCPB_ING_CPU_INS;
                        break;
                    default:
                        rc = CPB_ERR_INVALID_ARG;
                        break;
                }
                break;
            default:
                rc = CPB_ERR_INVALID_ARG;
                break;
        }
    }

    if (PMC_SUCCESS == rc) {
        switch(ingress_mux_input_port)
        {
            case CPB_MCPB_ING_LINE_IM_EXT:
            case CPB_MCPB_ING_SYS_IM_EXT:
                wr_chid = ingress_mux_input_port_chnl;
                wr_qid = ingress_mux_input_port_chnl;
                if(0 == (ingress_mux_input_port_chnl & 0x0001))
                {
                    rd_qid = 25 + (ingress_mux_input_port_chnl >> 1);
                    rd_chid = 65 + (ingress_mux_input_port_chnl >> 1) * 4;
                } else {
                    rd_qid = ingress_mux_input_port_chnl >> 1;
                    rd_chid = 1 + (ingress_mux_input_port_chnl >> 1) * 4;
                }
                break;
            case CPB_MCPB_ING_LINE_EM_EXT:
            case CPB_MCPB_ING_SYS_EM_EXT:
                wr_chid = ingress_mux_input_port_chnl;
                wr_qid = ingress_mux_input_port_chnl;
                if(0 == (ingress_mux_input_port_chnl & 0x0001))
                {
                    rd_qid = 37 + (ingress_mux_input_port_chnl >> 1);
                    rd_chid = 64 + (ingress_mux_input_port_chnl >> 1) * 4;
                } else {
                    rd_qid = 12 + (ingress_mux_input_port_chnl >> 1);
                    rd_chid = (ingress_mux_input_port_chnl >> 1) * 4;
                }
                break;
            case CPB_MCPB_ING_CPU_INS:
                wr_chid = ingress_mux_input_port_chnl;
                if(24 == ingress_mux_input_port_chnl)
                {
                    wr_qid = 0;
                    rd_qid = 24;
                    rd_chid = 3;
                } else {
                    wr_qid = ingress_mux_input_port_chnl;
                    rd_qid = ingress_mux_input_port_chnl;
                    rd_chid = ingress_mux_input_port_chnl >> 1;
                }
                break;
            case CPB_MCPB_ING_FEGE_INS:
                wr_chid = ingress_mux_input_port_chnl;
                if(24 == ingress_mux_input_port_chnl)
                {
                    wr_qid = 1;
                    rd_qid = 61;
                    rd_chid = 67;
                } else {
                    wr_qid = ingress_mux_input_port_chnl;
                    rd_qid = ingress_mux_input_port_chnl;
                    rd_chid = ingress_mux_input_port_chnl >> 1;
                }
                break;
            case CPB_MCPB_ING_LINE_REF:
            case CPB_MCPB_ING_SYS_REF:
                wr_chid = ingress_mux_input_port_chnl;
                wr_qid = ingress_mux_input_port_chnl;
                rd_qid = 49 + ingress_mux_input_port_chnl;
                rd_chid = 66 + ingress_mux_input_port_chnl * 4;
                break;
            default:
                rc = CPB_ERR_INVALID_ARG;
                break;
        }
    }

    if (PMC_SUCCESS == rc)
    {

        dcs = egress_mux_input_port;
        ram_chid = egress_mux_output_port_chnl;
        slv_port = ingress_mux_input_port;
        slv_chid = ingress_mux_input_port_chnl;

        PMC_LOG_TRACE("MCPB: dcs: %d qs: %d push_port_id: %d wr_qid: %d rd_qid: %d \n", dcs, queue_system_id, push_port_id, wr_qid, rd_qid);
        PMC_LOG_TRACE("MCPB: input slave port: %d input slave port ch: %d \n", slv_port, slv_chid);
    }
    /* Now that we finally have eveyrthing we need, flush out the MCPB */

    /* cant call some of these private functions, so just use the full deactivate/activate instead */

    for (itr = 0; itr < 12 && PMC_SUCCESS == rc; itr++)
    {
        ram_channel = dcs_field_C_RAM_CHANNEL_get(NULL, handle, dcs, itr);

        if (ram_channel == ram_chid)
        {
             dcs_entry = itr;
             break;
        }
    }
    if (PMC_SUCCESS == rc)
    {

        /* make a copy first */
        ram_sf1 = dcs_field_C_RAM_SF1_get(NULL, handle, dcs, dcs_entry);
        ram_sf2 = dcs_field_C_RAM_SF2_get(NULL, handle, dcs, dcs_entry);
        ram_ch  = dcs_field_C_RAM_CHANNEL_get(NULL, handle, dcs, dcs_entry);
        ram_id  = dcs_field_C_RAM_IDENTIFIER_get(NULL, handle, dcs, dcs_entry);

        /* Disable QS */
        switch (queue_system_id)
        {
        case 0:
            slave_dpi_field_QS0_CH_EN_set(NULL, handle, slv_port, slv_chid, 0);
            break;
        case 1:
            slave_dpi_field_QS1_CH_EN_set(NULL, handle, slv_port, slv_chid, 0);
            break;
        case 2:
            slave_dpi_field_QS2_CH_EN_set(NULL, handle, slv_port, slv_chid, 0);
            break;
        default:
            rc = CPB_ERR_INVALID_ARG;
        }
    }

    /* remove entry from DCS */
    for (itr = 0; itr < 2 && PMC_SUCCESS == rc; itr++)
    {
        dcs_field_C_RAM_SF1_set(NULL, handle, dcs, dcs_entry, 0);
        dcs_field_C_RAM_SF2_set(NULL, handle, dcs, dcs_entry, 0);
        dcs_field_C_RAM_CHANNEL_set(NULL, handle, dcs, dcs_entry, 0);
        dcs_field_C_RAM_IDENTIFIER_set(NULL, handle, dcs, dcs_entry, 0x7f);

        dcs_field_DCS_PAGE_SWAP_set(NULL, handle, dcs, 1);

        /*PMC_OS_USLEEP(20000);*/
        PMC_ATOMIC_YIELD(handle->base.parent_handle,20000);
    }

    if (PMC_SUCCESS == rc)
    {
        /* reset the read ptr first then the write ptr */
        qs_field_RPTR_RST_POP_set(NULL, handle, queue_system_id, rd_qid, 1);

        switch (push_port_id)
        {
        case 0:
            qs_field_WPTR_RST_PUSH_P0_set(NULL, handle, queue_system_id, wr_qid, 1);
            break;
        case 1:
            qs_field_WPTR_RST_PUSH_P1_set(NULL, handle, queue_system_id, wr_qid, 1);
            break;
        case 2:
            qs_field_WPTR_RST_PUSH_P2_set(NULL, handle, queue_system_id, wr_qid, 1);
            break;
        case 3:
            qs_field_WPTR_RST_PUSH_P3_set(NULL, handle, queue_system_id, wr_qid, 1);
            break;
        default:
            rc = CPB_ERR_INVALID_ARG;
            break;
        }

        qs_field_DBG_RADDR_set(NULL, handle, queue_system_id, 0xFF);

        /* now flush the queue */
        dcs_field_DCS_Q_RESET_set(NULL, handle, queue_system_id, wr_qid);
        /*PMC_OS_USLEEP(20000);*/
        PMC_ATOMIC_YIELD(handle->base.parent_handle,20000);
        dcs_field_DCS_Q_RESET_set(NULL, handle, queue_system_id, wr_qid);

        /* reprov */
        switch (push_port_id)
        {
        case 0:
            qs_field_WPTR_RST_PUSH_P0_set(NULL, handle, queue_system_id, wr_qid, 0);
            break;
        case 1:
            qs_field_WPTR_RST_PUSH_P1_set(NULL, handle, queue_system_id, wr_qid, 0);
            break;
        case 2:
            qs_field_WPTR_RST_PUSH_P2_set(NULL, handle, queue_system_id, wr_qid, 0);
            break;
        case 3:
            qs_field_WPTR_RST_PUSH_P3_set(NULL, handle, queue_system_id, wr_qid, 0);
            break;
        default:
            rc = CPB_ERR_INVALID_ARG;
            break;
        }

        qs_field_RPTR_RST_POP_set(NULL, handle, queue_system_id, rd_qid, 0);

        qs_field_DBG_RADDR_set(NULL, handle, queue_system_id, 0x0);
    }

    for (itr = 0; itr < 2 && PMC_SUCCESS == rc; itr++)
    {
        dcs_field_C_RAM_SF1_set(NULL, handle, dcs, dcs_entry, ram_sf1);
        dcs_field_C_RAM_SF2_set(NULL, handle, dcs, dcs_entry, ram_sf2);
        dcs_field_C_RAM_CHANNEL_set(NULL, handle, dcs, dcs_entry, ram_ch);
        dcs_field_C_RAM_IDENTIFIER_set(NULL, handle, dcs, dcs_entry, ram_id);

        dcs_field_DCS_PAGE_SWAP_set(NULL, handle, dcs, 1);

        /*PMC_OS_USLEEP(20000);*/
        PMC_ATOMIC_YIELD(handle->base.parent_handle,20000);
        
    }

    if (PMC_SUCCESS == rc)
    {
        switch (queue_system_id)
        {
        case 0:
            slave_dpi_field_QS0_CH_EN_set(NULL, handle, slv_port, slv_chid, 1);
            break;
        case 1:
            slave_dpi_field_QS1_CH_EN_set(NULL, handle, slv_port, slv_chid, 1);
            break;
        case 2:
            slave_dpi_field_QS2_CH_EN_set(NULL, handle, slv_port, slv_chid, 1);
            break;
        default:
            rc = CPB_ERR_INVALID_ARG;
            break;
        }
    }

    PMC_RETURN(rc);
} /* mcpb_dpi_slave_port_chnl_flush */

/*******************************************************************************
* cpb_dpi_slave_port_chnl_min_max_num_block_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function provides from a DPI slave port, the minimum and maximum \n
*   number of block for its associated queue systems
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Slave Port Number:\n
*                           0 to 7
*   chnl                  - DPI Slave Port Channel Number
*
* OUTPUTS:
*   *min_num_blocks       - The minimum number of blocks associated to the slave port
*   *max_num_blocks       - The maximum number of blocks associated to the slave port
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_dpi_slave_port_chnl_min_max_num_block_get(cpb_handle_t *h,
                                                                UINT32 port,
                                                                UINT32 chnl,
                                                                UINT32 *min_num_blocks,
                                                                UINT32 *max_num_blocks)
{

    PMC_ERROR rc = PMC_SUCCESS;
#ifndef PMC_SW_SIMULATION
    UINT32 pop_qid_itr = 0;
    BOOL8 enable = TRUE;
    UINT32 rd_qid = 0;
    UINT32 num_blocks = 0;
#endif
    PMC_ENTRY();

    *max_num_blocks = 0;
    *min_num_blocks = 0xFFFFFFFF;
#ifndef PMC_SW_SIMULATION
    for (pop_qid_itr = 0;
         pop_qid_itr < DCPB_NUM_QUEUE_SYSTEMS && PMC_SUCCESS == rc;
         pop_qid_itr ++)
    {
        /* determine field settings and apply */
        switch(pop_qid_itr)
        {
        case 0: /* Push port 0 */
            enable = slave_dpi_field_QS0_CH_EN_get(NULL, h, port, chnl);
            if (TRUE == enable)
            {
                rd_qid = slave_dpi_field_QS0_POP_QID_get(NULL, h, port, chnl);
            }

            break;
        case 1: /* Push port 1 */
            enable = slave_dpi_field_QS1_CH_EN_get(NULL, h, port, chnl);
            if (TRUE == enable)
            {
                rd_qid = slave_dpi_field_QS1_POP_QID_get(NULL, h, port, chnl);
            }
            break;
        case 2: /* Push port 2 */
            enable = slave_dpi_field_QS2_CH_EN_get(NULL, h, port, chnl);
            if (TRUE == enable)
            {
                rd_qid = slave_dpi_field_QS2_POP_QID_get(NULL, h, port, chnl);
            }
            break;
        case 3: /* Push port 3 */
            enable = slave_dpi_field_QS3_CH_EN_get(NULL, h, port, chnl);
            if (TRUE == enable)
            {
                rd_qid = slave_dpi_field_QS3_POP_QID_get(NULL, h, port, chnl);
            }
            break;
        default:
            enable = FALSE;
            rc = CPB_ERR_INVALID_ARG;
        }

        if (TRUE == enable)
        {
            /* get number of block for this pop queue */
            rc = cpb_queue_num_block_get(h,pop_qid_itr,rd_qid,&num_blocks);

            if (num_blocks > *max_num_blocks)
            {
                *max_num_blocks = num_blocks;
            }
            if (num_blocks < *min_num_blocks)
            {
                *min_num_blocks = num_blocks;
            }
        }
    }
#else
    *max_num_blocks = 0xFFFFFFFF;
    *min_num_blocks = 0;
#endif
    /* if we have not found any pop queue associated to the psuh queue */
    if (0 == *max_num_blocks)
    {
        rc = CPB_ERR_INVALID_ARG;
    }

    PMC_RETURN(rc);
} /* cpb_dpi_slave_port_chnl_min_max_num_block_get */


/*******************************************************************************
* cpb_dpi_slave_port_chnl_zone_source_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures which (if any) queue system is the zone source for
*   a DPI slave port channel.  Only one channel may be specified as the zone
*   source.  No channels may be specified if the upstream DPI master does not
*   require ZONE data.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI slave port number 0 to 7
*   chnl                  - DPI slave port channel 0 to n where n
*                           is a function of the DPI slave port and CPB
*                           instantiation.
*   operation             - 0: set a zone master 1: clear a zone master
*   master_queue          - Specifies the master queue for the channel.\n
*                           0:    Queue System 0\n
*                           1:    Queue System 1\n
*                           2:    Queue System 2\n
*                           3:    Queue System 3\n
*                           0xFF: None
*
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_slave_port_chnl_zone_source_cfg(cpb_handle_t *h,
                                                         UINT32 port,
                                                         UINT32 chnl,
                                                         UINT32 operation,
                                                         UINT32 master_queue)
{
    /*
        Provides configuration of fields:
            QS0_CH_MST, QS1_CH_MST, QS2_CH_MST, QS3_CH_MST
        Requirement for this function:
        1, Only one bit can be 1 at any time.
        2, idempotent, calling twice of this function does not change the status
           of device even during function execution
    */
    slave_dpi_buffer_t slave_dpi_buffer;

    PMC_ENTRY();
    /* argument check */
    if(port > h->cfg.max_slv_dpi_port)
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(chnl > h->cfg.max_dpi_slv_chnl_id[port])
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(master_queue >= h->cfg.pop_port_num)
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(operation > 1)
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    slave_dpi_buffer_init(&slave_dpi_buffer, h, port);

    if(0 == operation) /*set a zone master*/
    {
        switch(master_queue)
        {
            case 0:
                slave_dpi_field_QS1_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                slave_dpi_field_QS2_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                slave_dpi_field_QS3_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                slave_dpi_field_QS0_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 1);
                break;
            case 1:
                slave_dpi_field_QS0_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                slave_dpi_field_QS2_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                slave_dpi_field_QS3_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                slave_dpi_field_QS1_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 1);
                break;
            case 2:
                slave_dpi_field_QS0_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                slave_dpi_field_QS1_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                slave_dpi_field_QS3_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                slave_dpi_field_QS2_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 1);
                break;
            case 3:
                slave_dpi_field_QS0_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                slave_dpi_field_QS1_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                slave_dpi_field_QS2_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                slave_dpi_field_QS3_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 1);
                break;
            default:
                PMC_RETURN(CPB_ERR_INVALID_ARG);
        }
    } else
    { /* clear one QSx_CH_MST field */
        switch(master_queue)
        {
           case 0:
                slave_dpi_field_QS0_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                break;
           case 1:
                slave_dpi_field_QS1_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                break;
            case 2:
                slave_dpi_field_QS2_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                break;
            case 3:
                slave_dpi_field_QS3_CH_MST_set(&slave_dpi_buffer, h, port, chnl, 0);
                break;
            default:
                PMC_RETURN(CPB_ERR_INVALID_ARG);
        }
    }

    slave_dpi_buffer_flush(&slave_dpi_buffer);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dpi_slave_port_chnl_zone_source_cfg */


/*******************************************************************************
* cpb_dpi_slave_port_chnl_ing_mux_output_port_sel_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function configures which ingress mux output port is receiving data
*   from an ingress mux input port for a channel within the input port.\n\n
*
*   The ingress mux output port is 1:1 mapped to a set of four queue systems.\n\n
*
*   The ingres mux input port is 1:1 mapped with a DPI Slave Port.
*
*
* INPUTS:
*   *h                   - pointer to CPB handle instance.
*   port                 - DPI Slave Port Number.  Legal values:\n
*                           0: SIFD1\n
*                           1: SIFD2\n
*                           2: CBRC\n
*                           3: ENET_SYS\n
*                           4: MAPOTN\n
*                           5: ENET_LINE
*   chnl                 - DPI Slave Port Channel.
*   operation            - 0 setting the imux output 1 clearing the imux output
*   output_port          - Ingress Mux Output Port to receive data from DPI Slave
*                          Port for the specified chnl.  Legal values:\n
*                           port set to 0 'SIFD1' push port 0\n
*                           port set to 1 'SIFD2' push port 1\n
*                           port set to 2 'CBRC' push port 0, 1, 2\n
*                           port set to 3 'ENET_SYS' push port 0, 1\n
*                           port set to 4 'MAPOTN' push port 2, 3\n
*                           port set to 5 'ENET_LINE' push port 2,3\n
*
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_slave_port_chnl_ing_mux_output_port_sel_cfg(cpb_handle_t *h,
                                                                     UINT32 port,
                                                                     UINT32 chnl,
                                                                     UINT32 operation,
                                                                     UINT32 output_port)
{
    PMC_ENTRY();

    if(operation > 1)
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    if(0 == operation)
    {/* determine field settings and apply */
        switch(port)
        {
            case CPB_DCPB_DPI_PORT_SIFD1:
                if (output_port != 0) {

                    PMC_RETURN(CPB_ERR_INVALID_ARG);
                } else {

                    slave_dpi_field_DCPB_IMUX_SEL_set(NULL, h, port, chnl, output_port);
                };
                break;
            case CPB_DCPB_DPI_PORT_SIFD2:
                if (output_port != 1) {

                    PMC_RETURN(CPB_ERR_INVALID_ARG);
                } else {

                    slave_dpi_field_DCPB_IMUX_SEL_set(NULL, h, port, chnl, output_port);
                };
                break;
            case CPB_DCPB_DPI_PORT_CBRC: /* CBRC */
                    /* Valid values are 0, 1, 2 */
                if (output_port > 2) {

                    PMC_RETURN(CPB_ERR_INVALID_ARG);
                } else {

                    slave_dpi_field_DCPB_IMUX_SEL_set(NULL, h, port, chnl, output_port);
                };
                break;
            case CPB_DCPB_DPI_PORT_ENET_SYS: /* ENET_SYS */
                    /* Valid values are 0, 1 */
                if (output_port > 1) {

                    PMC_RETURN(CPB_ERR_INVALID_ARG);
                } else {

                    slave_dpi_field_DCPB_IMUX_SEL_set(NULL, h, port, chnl, output_port);
                };
                break;
            case CPB_DCPB_DPI_PORT_MAPOTN: /* MAPOTN */
                    /* Valid values are 2, 3 */
                if (output_port < 2 || output_port > 3) {

                    PMC_RETURN(CPB_ERR_INVALID_ARG);
                } else {

                    slave_dpi_field_DCPB_IMUX_SEL_set(NULL, h, port, chnl, output_port);
                };
                break;
            case CPB_DCPB_DPI_PORT_ENET_LINE: /* ENET_LINE */
                    /* Valid values are 2, 3 */
                if (output_port < 2 || output_port > 3) {

                    PMC_RETURN(CPB_ERR_INVALID_ARG);
                } else {

                    slave_dpi_field_DCPB_IMUX_SEL_set(NULL, h, port, chnl, output_port);
                };
                break;
            default:
                PMC_RETURN(CPB_ERR_INVALID_ARG);
        }
    } else {
        slave_dpi_field_DCPB_IMUX_SEL_set(NULL, h, port, chnl, 0);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dpi_slave_port_chnl_ing_mux_output_port_sel_cfg */

/*******************************************************************************
* cpb_dpi_mstr_port_chnl_zone_0_1_zone_1_2_thresh_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures zone_thr_0_1 and zone_thr_1_2 threshold settings 
*   for a DPI Master port channel.\n\n
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Master Port
*   chnl                  - DPI Master Port Channel
*   zone_0_1              - Zone threshold between 00 and 01 FIFO occupancy
*   zone_1_2              - Zone threshold between 01 and 10 FIFO occupancy
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_mstr_port_chnl_zone_0_1_zone_1_2_thresh_cfg(cpb_handle_t *h,
                                                                     UINT32 port,
                                                                     UINT32 chnl,
                                                                     UINT32 zone_0_1,
                                                                     UINT32 zone_1_2)
{
    PMC_ENTRY();

    /* apply field settings */
    master_dpi_field_ZONE_THR_0_1_set       ( NULL, h, port, chnl, zone_0_1);
    master_dpi_field_ZONE_THR_1_2_set       ( NULL, h, port, chnl, zone_1_2);

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_dpi_mstr_port_chnl_zone_0_1_zone_1_2_thresh_cfg */

/*******************************************************************************
* cpb_dpi_mstr_port_chnl_zone_thresh_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures zone threshold settings for a DPI Master port
*   channel.\n\n
*
*   Zone threshold settings are in units of 48 byte increments.  Zone thresholds
*   must be set ZONE_THR_0_1 < ZONE_THR_1_2 < ZONE_THR_2_3.  Zone thresholds may
*   not exceed the total number of 48 byte increments available in the CFC FIFO
*   associated with the queue ID for the master queue system.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Master Port
*   chnl                  - DPI Master Port Channel
*   zone_0_1              - Zone threshold between 00 and 01 FIFO occupancy
*   zone_1_2              - Zone threshold between 01 and 10 FIFO occupancy
*   zone_2_3              - Zone threshold between 10 and 11 FIFO occupancy
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_mstr_port_chnl_zone_thresh_cfg(cpb_handle_t *h,
                                                        UINT32 port,
                                                        UINT32 chnl,
                                                        UINT32 zone_0_1,
                                                        UINT32 zone_1_2,
                                                        UINT32 zone_2_3)
{
    PMC_ENTRY();

    if ((zone_0_1 >= zone_1_2) || (zone_1_2 >= zone_2_3)){

        PMC_RETURN(CPB_ERR_INVALID_ARG);
    };

    /* apply field settings */
    master_dpi_field_ZONE_THR_0_1_set       ( NULL, h, port, chnl, zone_0_1);
    master_dpi_field_ZONE_THR_1_2_set       ( NULL, h, port, chnl, zone_1_2);
    master_dpi_field_ZONE_THR_2_3_set       ( NULL, h, port, chnl, zone_2_3);

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_dpi_mstr_port_chnl_zone_thresh_cfg */

/*******************************************************************************
* cpb_dpi_mstr_port_zone_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures Zone interface configuration for a DPI Master port.
*   This is configuration that is common to all channels within the port.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI Master Port Number.  Legal values:\n
*                           0 to 7
*   enable                - Number of channels assocaited with the DPI Master
*                           Port
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dpi_mstr_port_zone_cfg(cpb_handle_t *h,
                                            UINT32 port,
                                            UINT32 enable)
{
    PMC_ENTRY();
    master_dpi_field_ZONE_EN_set( NULL, h, port, enable);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dpi_mstr_port_zone_cfg */

/*******************************************************************************
* cpb_mux_mgmt_src_sel_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures the ingress mux PORT MUX for CPB(M) to select data
*   from ENET system or ENET line subsystems.  It configures all ingress port
*   mux to select from either ENET system or ENET line as the device only
*   supports management traffic from one or the other ENET subsystem.\n\n
*
*   This function is only applicable to the CPB(M) instantiation of the CPB
*   block.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   source                - Subsystem data source for ingress mux port\n
*                           0: Line Side ENET (ENET_LINE)\n
*                           1: System Side ENET (ENET_SYS)
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_mux_mgmt_src_sel_cfg(cpb_handle_t *h,
                                          UINT32 source)
{
    UINT32 igr_ext_sel, egr_ext_sel, reflect_sel;
    cpb_ctrl_buffer_t cpb_ctrl_buffer;

    PMC_ENTRY();

#ifndef  CPB_REG_OP_CTXT_DISABLE
    if(CPB_INSTANCE_MCPB != h->cfg.cpb_type) PMC_RETURN(CPB_ERR_INVALID_CPB_TYPE);
#endif /* CFC_REG_OP_CTXT_DISABLE */

    /*Determine values*/
    if (1 == source) {

        /* ENET System side */
        igr_ext_sel = 1;
        egr_ext_sel = 1;
        reflect_sel = 1;
    } else if (0 == source) {

        /* ENET Line side */
        igr_ext_sel = 0;
        egr_ext_sel = 0;
        reflect_sel = 0;
    } else {

        PMC_RETURN(CPB_ERR_INVALID_ARG);
    };

    cpb_ctrl_buffer_init(&cpb_ctrl_buffer, h);

    cpb_ctrl_field_IM_IGR_EXT_SEL_set(&cpb_ctrl_buffer, h, igr_ext_sel);
    cpb_ctrl_field_IM_EGR_EXT_SEL_set(&cpb_ctrl_buffer, h, egr_ext_sel);
    cpb_ctrl_field_IM_REFLECT_SEL_set(&cpb_ctrl_buffer, h, reflect_sel);

    cpb_ctrl_buffer_flush(&cpb_ctrl_buffer);

#ifndef  CPB_REG_OP_CTXT_DISABLE
    h->var.mcpb_im_sel.igr_ext_sel = igr_ext_sel;
    h->var.mcpb_im_sel.egr_ext_sel = egr_ext_sel;
    h->var.mcpb_im_sel.reflect_sel = reflect_sel;
#endif /* CFC_REG_OP_CTXT_DISABLE */

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_mux_mgmt_src_sel_cfg */

/*******************************************************************************
* cpb_mux_mgmt_dest_sel_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures all egress mux PORT MUX for CPB(M) to send data
*   to either of ENET system or ENET line subsystems.  It configures all egress
*   port mux to select from either ENET system or ENET line as the device only
*   supports management traffic from one or the other ENET subsystem.\n\n
*
*   This function is only applicable to the CPB(M) instantiation of the CPB
*   block.
*
*
* INPUTS:
*   *h                   - pointer to CPB handle instance.
*   dest                 - Subsystem destination for egress mux port data\n
*                           1: System Side ENET (ENET_SYS)\n
*                           0: Line Side ENET (ENET_LINE)
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_mux_mgmt_dest_sel_cfg(cpb_handle_t *h,
                                           UINT32 dest)
{
    UINT32 igr_ext_sel, egr_ext_sel;
    cpb_ctrl_buffer_t cpb_ctrl_buffer;

    PMC_ENTRY();

    /* Determine values */
    if (1 == dest) {

        /* ENET System side */
        igr_ext_sel = 1;
        egr_ext_sel = 1;
    } else if (0 == dest) {

        /*  ENET Line side */
        igr_ext_sel = 0;
        egr_ext_sel = 0;
    } else {

        PMC_RETURN(CPB_ERR_INVALID_ARG);
    };

    cpb_ctrl_buffer_init(&cpb_ctrl_buffer, h);

    cpb_ctrl_field_EM_IGR_EXT_SEL_set(&cpb_ctrl_buffer, h, igr_ext_sel);
    cpb_ctrl_field_EM_EGR_EXT_SEL_set(&cpb_ctrl_buffer, h, egr_ext_sel);

    cpb_ctrl_buffer_flush(&cpb_ctrl_buffer);
#ifndef  CPB_REG_OP_CTXT_DISABLE
    h->var.mcpb_em_sel.em_egr_ext_sel = egr_ext_sel;
    h->var.mcpb_em_sel.em_igr_ext_sel = igr_ext_sel;
#endif /* CFC_REG_OP_CTXT_DISABLE */
    PMC_RETURN(PMC_SUCCESS);
} /* cpb_mux_mgmt_dest_sel_cfg */


/*******************************************************************************
* cpb_mux_cpbd_src_sel_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures an ingress mux PORT MUX for CPB(D) to select data
*   for transfer to SIFD or ENET_SYS/CBRC.\n\n
*
*   This function is only applicable to the CPB(D) instantiation of the CPB
*   block.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - Ingress Mux Port\n
*                           0: SIFD1 or ENET_SYS/CBRC\n
*                           1: SIFD2 or ENET_SYS/CBRC
*   src                   - Subsystem data source for ingress mux port\n
*                           0: ENET_SYS/CBRC\n
*                           1: SIFD
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_mux_cpbd_src_sel_cfg(cpb_handle_t *h,
                                          UINT32 port,
                                          UINT32 src)
{
    PMC_ENTRY();

    if (port > 1 || src > 1)
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    if( 0 == port)
    {
        cpb_ctrl_field_IGR_SIFD1_SEL_set(NULL, h, src);
    } else {
        cpb_ctrl_field_IGR_SIFD2_SEL_set(NULL, h, src);
    }

#ifndef  CPB_REG_OP_CTXT_DISABLE
    h->var.dcpb_ingress_mux_output_source[port] = src;
#endif /* CFC_REG_OP_CTXT_DISABLE */

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_mux_cpbd_src_sel_cfg */


/*******************************************************************************
* cpb_mux_cpbd_dest_sel_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures an egress mux PORT MUX for CPB(D) to select data
*   for transfer to SIFD or ENET_SYS/CBRC.\n\n
*
*   This function is only applicable to the CPB(D) instantiation of the CPB
*   block.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - Ingress Mux Port\n
*                           0: SIFD1 or ENET_SYS/CBRC\n
*                           1: SIFD2 or ENET_SYS/CBRC
*   dest                  - Subsystem data source for ingress mux port\n
*                           0: ENET_SYS/CBRC\n
*                           1: SIFD
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_mux_cpbd_dest_sel_cfg(cpb_handle_t *h,
                                           UINT32 port,
                                           UINT32 dest)
{
    PMC_ENTRY();

    if (port > 1 || dest > 1)
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    if( 0 == port)
    {
        cpb_ctrl_field_EGR_SIFD1_SEL_set(NULL, h, dest);
    } else {
        cpb_ctrl_field_EGR_SIFD2_SEL_set(NULL, h, dest);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_mux_cpbd_dest_sel_cfg */


/*******************************************************************************
* cpb_xoff_mask_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures Zone interface configuration for a DPI Slave port.
*   This is configuration that is common to all channels within the port.
*
*
* INPUTS:
*   *h                     - pointer to CPB handle instance.
*   dcs_inst               - DCS instance
*   dpi_mst_port           - DPI Master Port
*   dpi_mst_channel        - DPI Master Channel
*   set_mask               - If TRUE set mask bit else clear the bit
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_xoff_mask_set(cpb_handle_t *h,
                                   UINT32 dcs_inst,
                                   UINT32 dpi_mst_port,
                                   UINT32 dpi_mst_channel,
                                   BOOL8 set_mask)
{
    UINT32 value[8] = {0,0,0,0,0,0,0,0};
    UINT32 index = 0;
    UINT32 sub_index = 0;
    UINT32 dpi_mst_channel_offset = 0;

    PMC_ENTRY();

    switch(dcs_inst)
    {
        case 0:
            cpb_ctrl_lfield_XOFF_MASK_DCS_0_get(NULL,h,value);

            if (dpi_mst_port == 2)
                dpi_mst_channel_offset = dpi_mst_channel + DCPB_MST_PORT_2_CH_OFFSET;
            else
                dpi_mst_channel_offset = dpi_mst_channel;

            index = dpi_mst_channel_offset/DCPB_MST_PORT_2_CH_OFFSET;
            sub_index = dpi_mst_channel_offset - (DCPB_MST_PORT_2_CH_OFFSET*index);
            if (set_mask)
                value[index] |= 1 << sub_index;
            else
                value[index] &= ~(1 << sub_index);

            cpb_ctrl_lfield_XOFF_MASK_DCS_0_set(NULL, h, value );
            break;
        case 1:
            cpb_ctrl_lfield_XOFF_MASK_DCS_1_get(NULL,h,value);

            if (dpi_mst_port == 2)
                dpi_mst_channel_offset = dpi_mst_channel + DCPB_MST_PORT_2_CH_OFFSET;
            else
                dpi_mst_channel_offset = dpi_mst_channel;

            index = dpi_mst_channel_offset/DCPB_MST_PORT_2_CH_OFFSET;
            sub_index = dpi_mst_channel_offset - (DCPB_MST_PORT_2_CH_OFFSET*index);
            if (set_mask)
                value[index] |= 1 << sub_index;
            else
                value[index] &= ~(1 << sub_index);

            cpb_ctrl_lfield_XOFF_MASK_DCS_1_set(NULL, h, value );
            break;
        case 2:
            cpb_ctrl_lfield_XOFF_MASK_DCS_2_get(NULL,h,value);

            if (dpi_mst_port == 2)
                dpi_mst_channel_offset = dpi_mst_channel + DCPB_MST_PORT_2_CH_OFFSET;
            else if (dpi_mst_port == 3)
                dpi_mst_channel_offset = dpi_mst_channel + DCPB_MST_PORT_3_CH_OFFSET;
            else
                dpi_mst_channel_offset = dpi_mst_channel;

            index = dpi_mst_channel_offset/DCPB_MST_PORT_2_CH_OFFSET;
            sub_index = dpi_mst_channel_offset - (DCPB_MST_PORT_2_CH_OFFSET*index);

            if (set_mask)
                value[index] |= 1 << sub_index;
            else
                value[index] &= ~(1 << sub_index);
            cpb_ctrl_lfield_XOFF_MASK_DCS_2_set(NULL, h, value );
            break;
        case 3:
            cpb_ctrl_lfield_XOFF_MASK_DCS_3_get(NULL,h,value);

            if (dpi_mst_port == 3)
                dpi_mst_channel_offset = dpi_mst_channel + DCPB_MST_PORT_3_CH_OFFSET;
            else
                dpi_mst_channel_offset = dpi_mst_channel;

            index = dpi_mst_channel_offset/DCPB_MST_PORT_2_CH_OFFSET;
            sub_index = dpi_mst_channel_offset - (DCPB_MST_PORT_2_CH_OFFSET*index);
            if (set_mask)
                value[index] |= 1 << sub_index;
            else
                value[index] &= ~(1 << sub_index);

            cpb_ctrl_lfield_XOFF_MASK_DCS_3_set(NULL, h, value );
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);

    }

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_xoff_mask_set */

/*******************************************************************************
* cpb_dpi_slave_port_chnl_zone_source_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function gets the zone source of the slave port channel. The zone source
*   returned is the id of the queue system.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - DPI slave port number 0 to 7
*   chnl                  - DPI slave port channel 0 to n where n
*                           is a function of the DPI slave port and CPB
*                           instantiation.
*
* OUTPUTS:
*   *zone_source          - pointer to the zone source
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_dpi_slave_port_chnl_zone_source_get( cpb_handle_t *h,
                                                          UINT32 port,
                                                          UINT32 chnl,
                                                          UINT32 *zone_source )
{
    UINT32 temp = 0;
    PMC_ENTRY();
    /* argument check */
    if(port > h->cfg.max_slv_dpi_port)
        PMC_RETURN(CPB_ERR_INVALID_ARG);
    if(chnl > h->cfg.max_dpi_slv_chnl_id[port])
        PMC_RETURN(CPB_ERR_INVALID_ARG);

    temp = slave_dpi_field_QS0_CH_MST_get(NULL, h, port, chnl);
    if(1 == temp)
    {
        *zone_source = 0;
        PMC_RETURN(PMC_SUCCESS);
    }
    temp = slave_dpi_field_QS1_CH_MST_get(NULL, h, port, chnl);
    if(1 == temp)
    {
        *zone_source = 1;
        PMC_RETURN(PMC_SUCCESS);
    }
    temp = slave_dpi_field_QS2_CH_MST_get(NULL, h, port, chnl);
    if(1 == temp)
    {
        *zone_source = 2;
        PMC_RETURN(PMC_SUCCESS);
    }
    temp = slave_dpi_field_QS3_CH_MST_get(NULL, h, port, chnl);
    if(1 == temp)
    {
        *zone_source = 3;
        PMC_RETURN(PMC_SUCCESS);
    }

    PMC_RETURN(CPB_ERR_ZONE_SOURCE_NOT_FOUND);
} /* cpb_dpi_slave_port_chnl_zone_source_get */

/*******************************************************************************
* cpb_dcs_xoff_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures the XOFF behavior for all channels associated with
*   a DCS.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   slice                 - DCS instance 0 to 3
*   xoff_type             - Enum, XOFF type
*   xfer_term             - Enum, Transfer termination behavior
*
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_xoff_cfg( cpb_handle_t *h,
                                   UINT32 slice,
                                   cpb_xoff_type_t xoff_type,
                                   cpb_xoff_mode_t xfer_term )
{
    PMC_ENTRY();

    PMC_ASSERT(xfer_term != LAST_CPB_XOFF_BOUNDARY, CPB_ERR_INVALID_ARG,0,0);

    /* determine field settings and apply */
    switch((int)xoff_type)
    {
        case 0: /* Link xoff */
            dcs_field_DCS_LINK_XOFF_MODE_set(NULL, h, slice, xfer_term);
            break;
        case 1: /* Channel xoff */
            dcs_field_DCS_CH_XOFF_MODE_set(NULL, h, slice, xfer_term);
            break;
        default:
           PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG,0,0);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dcs_xoff_cfg */


/*******************************************************************************
* cpb_dcs_credit_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures the XOFF behavior for all channels associated with
*   a DCS.
*
*
* INPUTS:
*   *h                      - pointer to CPB handle instance.
*   slice                   - DCS instance 0 to 3
*   credit_type             - Enum, Credit type
*   credit_mode             - Enum, Credit mode
*
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_credit_cfg( cpb_handle_t *h,
                                   UINT32 slice,
                                   cpb_credit_type_t credit_type,
                                   UINT32 credit_mode)
{

    UINT32 credit_size;
    dcs_buffer_t dcs_buffer;

    PMC_ENTRY();
    PMC_ASSERT(credit_type != LAST_CPB_CREDIT_TYPE, CPB_ERR_INVALID_ARG,0,0);
    PMC_ASSERT(credit_mode <= 1, CPB_ERR_INVALID_ARG,0,0);

    credit_size = (h->cfg.mtu_size/(h->cfg.bus_width/BITS_IN_A_BYTE))-1;

    /*determine field settings and apply */
    switch(credit_type)
    {
        case CPB_CREDIT_TYPE_BURST: /* Burst credit */
            dcs_field_DCS_DISABLE_BURST_CREDIT_set(NULL, h, slice, 1 - credit_mode);
            break;
        case CPB_CREDIT_TYPE_PACKET: /* Packet credit */

            dcs_buffer_init(&dcs_buffer, h, slice);

            dcs_field_DCS_QUANTUM_MODE_set(&dcs_buffer, h, slice, credit_mode);

            if (1 == credit_mode)
            {
                dcs_field_DCS_QUANTUM_SIZE_set(&dcs_buffer, h, slice, credit_size);
            }

            dcs_buffer_flush(&dcs_buffer);
            break;
        default:
           PMC_ASSERT(FALSE, CPB_ERR_INVALID_ARG,0,0);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dcs_credit_cfg */


/*******************************************************************************
* cpb_dcs_page_ctrl_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configure DCS Top of Page alignment related fields.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   slice                 - DCS instance 0 to 3
*   mode                  - DCS_TOP_OF_PAGE_MODE field setting
*   ptr                   - DCS_TOP_OF_PAGE_PTR field setting
*
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_page_ctrl_cfg(cpb_handle_t *h,
                                       UINT32 slice,
                                       UINT32 mode,
                                       UINT32 ptr )
{
    dcs_buffer_t dcs_buffer;

    PMC_ENTRY();

    if (mode > 3) {

        PMC_RETURN(CPB_ERR_INVALID_ARG);
    };

    dcs_buffer_init(&dcs_buffer, h, slice);

    dcs_field_DCS_TOP_OF_PAGE_MODE_set(&dcs_buffer, h, slice, mode);
    dcs_field_DCS_TOP_OF_PAGE_PTR_set(&dcs_buffer, h, slice, ptr);

    dcs_buffer_flush(&dcs_buffer);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dcs_page_ctrl_cfg */

/* LCOV_EXCL_START */
/*******************************************************************************
* cpb_dcs_page_align
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function forces the alignment of a DCS scheduler to the top of page.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   slice                 - DCS instance 0 to 3
*
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_page_align( cpb_handle_t *h,
                                     UINT32 slice )
{

    UINT32 align;

    PMC_ENTRY();

    align = 1;

    dcs_field_DCS_TOP_OF_PAGE_set(NULL, h, slice, align);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dcs_page_align */
/* LCOV_EXCL_STOP */

/*******************************************************************************
* cpb_dcs_wrr_entry_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function writes the contents to a DCS WRR calendar entry in the offline
*   page.
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   dcs_inst              - DCS instance 0 to 3
*   entry_offset          - The index of the entry
*   c_ram_sf1             - push port id
*   c_ram_sf2             - write queue id
*   c_ram_channel         - Channel Identifier of Calendar entry
*   c_ram_identifier      - Queue or Group Identifier of Calendar entry
*
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
* PMC_ENTRY/PMC_RETURN not require here because of the number of times this
* function gets called.
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_dcs_wrr_entry_set( cpb_handle_t *cpb_handle,
                                         UINT32 dcs_inst,
                                         UINT32 entry_offset,
                                         UINT32 c_ram_sf1,
                                         UINT32 c_ram_sf2,
                                         UINT32 c_ram_channel,
                                         UINT32 c_ram_identifier)
{
        dcs_buffer_t dcs_buffer;

        dcs_buffer_init(&dcs_buffer, cpb_handle, dcs_inst);

        dcs_field_C_RAM_SF1_set        ( &dcs_buffer, cpb_handle, dcs_inst, entry_offset, c_ram_sf1);
        dcs_field_C_RAM_SF2_set        ( &dcs_buffer, cpb_handle, dcs_inst, entry_offset, c_ram_sf2);
        dcs_field_C_RAM_CHANNEL_set    ( &dcs_buffer, cpb_handle, dcs_inst, entry_offset, c_ram_channel);
        dcs_field_C_RAM_IDENTIFIER_set ( &dcs_buffer, cpb_handle, dcs_inst, entry_offset, c_ram_identifier);

        dcs_buffer_flush(&dcs_buffer);

        return(PMC_SUCCESS);
} /* cpb_dcs_wrr_entry_set */

/*******************************************************************************
* cpb_dcs_page_swap
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function initiates the swap of offline and online DCS calendar pages
*   using the local swap bit for the DCS.
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   dcs_inst              - DCS instance 0 to 3
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_page_swap( cpb_handle_t *cpb_handle, UINT32 dcs_inst )
{
    PMC_ENTRY();
    dcs_field_DCS_PAGE_SWAP_set(NULL, cpb_handle, dcs_inst, 1 );
    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dcs_page_swap */



/*******************************************************************************
* cpb_dcs_queue_reset
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function resets the context for a queue.  It may only be called prior
*   to the queue being associated with a WRR entry.\n\n
*
*   This is the DCS processing queue ID that is 1:1 mapped to the pop queue ID.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   slice                 - DCS instance 0 to 3
*   queue_id              - Queue to be reset
*
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_queue_reset( cpb_handle_t *h,
                                      UINT32 slice,
                                      UINT32 queue_id)
{
    PMC_ENTRY();

    dcs_field_DCS_Q_RESET_set(NULL, h, slice, queue_id);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dcs_queue_reset */

/* LCOV_EXCL_START */
/*******************************************************************************
* cpb_dcs_ram_power_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures the power consumption mode of the internal RAMs
*   used by a DCS instance.\n\n
*
*   For proper DCS operation the RAMs must be set to an operational mode.
*
*
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   slice                 - DCS instance 0 to 3
*   ram                   - RAM to be configured:\n
*                           0: RPL (Remaining Packet Length) RAM\n
*                           1: Standby Calendar RAM\n
*                           2: Active Calendar RAM\n
*                           3: All
*   mode                  - Power savings mode:\n
*                           3: RAM is forced into Shutdown mode.\n
*                           2: RAM is forced into Deep Sleep mode.\n
*                           1: RAM is forced into Light Sleep mode.\n
*                           0: RAM is in normal functional mode.
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_ram_power_cfg( cpb_handle_t *h,
                                        UINT32 slice,
                                        cpb_target_ram_t ram,
                                        cpb_ram_power_mode_t mode )
{
    UINT32 override;

    PMC_ENTRY();

    override = 0;

    /* determine field settings and apply */
    switch(ram)
    {
        case CPB_RAM_RPL: /* RPL_RAM */
            if (mode > CPB_RAM_POWER_DEEP_SLEEP) {
                PMC_RETURN(CPB_ERR_INVALID_ARG);
            } else {
            };
            break;
        case CPB_RAM_STANDBY: /* C_RAM_STBY */
            if (mode > CPB_RAM_POWER_DEEP_SLEEP) {

                PMC_RETURN(CPB_ERR_INVALID_ARG);
            } else {
            };
            break;
        case CPB_RAM_ACTIVE: /* C_RAM_ACTV */
            if (mode > CPB_RAM_POWER_DEEP_SLEEP) {

                PMC_RETURN(CPB_ERR_INVALID_ARG);
            } else {
            };
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
    }

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dcs_ram_power_cfg */
/* LCOV_EXCL_STOP */


/*******************************************************************************
* cpb_dcs_enable
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function enables or disables a DCS instance
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   slice                 - DCS instance 0 to 3
*   enable                - DCS enable state:\n
*                           1: Enabled\n
*                           0: Disabled
*
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_enable( cpb_handle_t *h,
                                 UINT32 slice,
                                 UINT32 enable )
{
    PMC_ENTRY();

    if (enable > 1) { PMC_RETURN(CPB_ERR_INVALID_ARG);}

    /* SH: Should a check be added for the pointer value being smaller than
     the calendar size? */

    dcs_field_DCS_ENABLE_set(NULL, h, slice, enable);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dcs_enable */

/*******************************************************************************
* cpb_dcs_poll_swap_success
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function polls the DCS_PAGE_SWAP_STATUS bit, in the event of ILKN
*   DCS poll failure, will perform a procedure to force the success of the
*   page swap.
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*   dcs_inst               - DCS instance 0 to 3
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_poll_swap_success( cpb_handle_t *cpb_handle, UINT32 dcs_inst )
{
    BOOL8 ilkn_dcs_force_swap = FALSE;
    PMC_ERROR result;

    PMC_ENTRY();


    result = cpb_dcs_swap_poll(cpb_handle, dcs_inst);


    if(PMC_SUCCESS != result &&
       (CPB_INSTANCE_MCPB != cpb_handle->cfg.cpb_type) &&
       (1 == dcs_inst || 0 == dcs_inst))
    {
        ilkn_dcs_force_swap = TRUE;
    }

    /* ILKN DCS instances may fail poll due to continuous link xoff
       condition.  To address, the following code will force the
       downstream ILKN resource to not report link XOFF to the 
       DCS instance. In doing so, the poll result should be
       successful - this operation only executes during CWR. */
    if(TRUE == ilkn_dcs_force_swap)
    {
        if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_OCPB ||
            (cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB && 
             ((0 == dcs_inst && 1 == cpb_handle->var.dcpb_em_sifd1_sel) ||
              (1 == dcs_inst && 1 == cpb_handle->var.dcpb_em_sifd2_sel))))
        {
            /* call external operation to control the ILKN link xoff related field
               and verify the success of the DCS page swap event */
            digi_cpb_ilkn_dcs_swap_force((void *)cpb_handle->base.parent_handle,
                                         (void *)cpb_handle,
                                         ((0 == dcs_inst) ? 0 : 1));

            /* redundantly poll to retrieve status of the poll event */
            result = cpb_dcs_swap_poll(cpb_handle, dcs_inst);
        }
    }

    /* return page swap failure if polling fails */
    PMC_RETURN(result);

} /* cpb_dcs_poll_swap_success */

/*******************************************************************************
* cpb_dcs_swap_poll
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function polls the DCS_PAGE_SWAP_STATUS bit.
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*   dcs_inst               - DCS instance 0 to 3
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_swap_poll( cpb_handle_t *cpb_handle, UINT32 dcs_inst )
{


    UINT32 max_count = DCS_PAGE_SWAP_POLL_ITERATIONS;
    UINT32 delay_between_polls_in_microseconds = DCS_PAGE_SWAP_POLL_DELAY;
    UINT32 num_iter;
    PMC_ERROR result;

    PMC_ENTRY();


    l5sys_ignore_poll_errors(cpb_handle);
    result = dcs_field_DCS_PAGE_SWAP_STATUS_poll ( NULL, cpb_handle, dcs_inst,0, PMC_POLL_EQUAL, 1,
                                                   NULL,
                                                   0 );
    l5sys_abort_on_poll_errors(cpb_handle);
    result = dcs_field_DCS_PAGE_SWAP_STATUS_poll ( NULL, cpb_handle, dcs_inst,0, PMC_POLL_EQUAL, max_count,
                                                   &num_iter,
                                                   delay_between_polls_in_microseconds );

    if(PMC_SUCCESS!=result)
        PMC_LOG_TRACE("DCS_PAGE_SWAP_STATUS failed after %u iterations\n",num_iter);
    else
        PMC_LOG_TRACE("DCS_PAGE_SWAP_STATUS succeeded after %u iterations\n",num_iter);


    /* return page swap failure if polling fails */
    PMC_RETURN(result);

} /* cpb_dcs_swap_poll */

/*******************************************************************************
* cpb_x_default_register_start_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function writes to all registers in the CPB subsystem that do not
*   have a defined default value.
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.

*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_x_default_register_start_set( cpb_handle_t *cpb_handle)
{
    UINT32 a, n;
    PMC_ENTRY();


    /* Slave DPI Port Reset Configuration */
    for(a=0; a <= cpb_handle->cfg.max_slv_dpi_port; a++)
    {
        for(n=0; n <= cpb_handle->cfg.max_dpi_slv_chnl_id[a]; n++)
        {
            slave_dpi_reg_CH_CONFIG_array_write         ( NULL, cpb_handle, a, n, 0);
            slave_dpi_reg_CH_Q_MAP_array_write          ( NULL, cpb_handle, a, n, 0);
            slave_dpi_reg_ZONE_0_1_array_write          ( NULL, cpb_handle, a, n, 0);
            slave_dpi_reg_ZONE_1_2_array_write          ( NULL, cpb_handle, a, n, 0);
            slave_dpi_reg_ZONE_2_3_array_write          ( NULL, cpb_handle, a, n, 0);
            slave_dpi_reg_ZONE_OVRD_CONFIG_array_write  ( NULL, cpb_handle, a, n, 0);
        }
    }
    /* Master DPI Port Reset Configuration */
    for(a=0; a <= cpb_handle->cfg.max_mst_dpi_port; a++)
    {
        for(n=0; n <= cpb_handle->cfg.max_dpi_mst_chnl_id[a]; n++)
        {
            master_dpi_reg_ZONE_0_1_array_write         ( NULL, cpb_handle, a, n, 0);
            master_dpi_reg_ZONE_1_2_array_write         ( NULL, cpb_handle, a, n, 0);
            master_dpi_reg_ZONE_2_3_array_write         ( NULL, cpb_handle, a, n, 0);
            master_dpi_reg_ZONE_OVRD_CONFIG_array_write ( NULL, cpb_handle, a, n, 0);
        }
    }

    PMC_RETURN();

} /* cpb_x_default_register_start_set */






/*******************************************************************************
* cpb_pmon_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Enable or disable a PMON counter on a CPB slave port. If disable is set, then
*   the inputs count_drop_packets, count_err_packets, count_oversize_packets, and
*   count_good_packets are ignored.
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.
*   port                   - UINT32 defining the port number
*   counter_num            - The counter number. There are 4 counters per port.
*   pmon_mode              - ENUM defining the PMON mode (byte, packet, or disable)
*   count_drop_packets     - Disable count packets marked as drop in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*   count_err_packets      - Disable count packets marked as error in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*   count_oversize_packets - Disable count oversized packets in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*   count_good_packets     - Disable count normal packets in this counter\n
*                            1: disable drop packet count\n
*                            0: enable drop packet count
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_pmon_cfg( cpb_handle_t *cpb_handle,
                                  UINT32 port,
                                  UINT32 counter_num,
                                  cpb_pmon_mode pmon_mode,
                                  BOOL8 count_drop_packets,
                                  BOOL8 count_err_packets,
                                  BOOL8 count_oversize_packets,
                                  BOOL8 count_good_packets)
{
    UINT32 filter = 0;
    PMC_ENTRY();

    if(pmon_mode == CPB_PMON_MODE_DISABLE)
    {
        switch (counter_num)
        {
            case 0:
                slave_dpi_field_PMON_CNT0_RST_set( NULL, cpb_handle, port, 1 );
                break;
            case 1:
                slave_dpi_field_PMON_CNT1_RST_set( NULL, cpb_handle, port, 1 );
                break;
            case 2:
                slave_dpi_field_PMON_CNT2_RST_set( NULL, cpb_handle, port, 1 );
                break;
            case 3:
                slave_dpi_field_PMON_CNT3_RST_set( NULL, cpb_handle, port, 1 );
                break;
            default:
                PMC_RETURN(CPB_ERR_INVALID_ARG);
                break;

        }
        PMC_RETURN(PMC_SUCCESS);
    }

    /* Set the mode */
    switch (counter_num) {
        case 0:
            if(pmon_mode == CPB_PMON_MODE_PACKET)
                slave_dpi_field_PMON_CNT0_MODE_set (NULL, cpb_handle, port, 1);
            else
                slave_dpi_field_PMON_CNT0_MODE_set (NULL, cpb_handle, port, 0);
            break;
        case 1:
            if(pmon_mode == CPB_PMON_MODE_PACKET)
                slave_dpi_field_PMON_CNT1_MODE_set (NULL, cpb_handle, port, 1);
            else
                slave_dpi_field_PMON_CNT1_MODE_set (NULL, cpb_handle, port, 0);
            break;
        case 2:
            if(pmon_mode == CPB_PMON_MODE_PACKET)
                slave_dpi_field_PMON_CNT2_MODE_set (NULL, cpb_handle, port, 1);
            else
                slave_dpi_field_PMON_CNT2_MODE_set (NULL, cpb_handle, port, 0);
            break;
        case 3:
            if(pmon_mode == CPB_PMON_MODE_PACKET)
                slave_dpi_field_PMON_CNT3_MODE_set (NULL, cpb_handle, port, 1);
            else
                slave_dpi_field_PMON_CNT3_MODE_set (NULL, cpb_handle, port, 0);
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
            break;
    }

    /* Set the filter */
    if(count_drop_packets)
        filter |= CPB_PMON_CNT_PKT_FILT_DROP_PACKETS_MSK;
    if(count_err_packets)
        filter |= CPB_PMON_CNT_PKT_FILT_ERR_PACKETS_MSK;
    if(count_oversize_packets)
        filter |= CPB_PMON_CNT_PKT_OVERSIZED_PACKETS_MSK;
    if(count_good_packets)
        filter |= CPB_PMON_CNT_PKT_GOOD_PACKETS_MSK;

    switch (counter_num) {
        case 0:
            slave_dpi_field_PMON_CNT0_PKT_FILT_set(NULL, cpb_handle, port, filter);
            break;
        case 1:
            slave_dpi_field_PMON_CNT1_PKT_FILT_set(NULL, cpb_handle, port, filter);
            break;
        case 2:
            slave_dpi_field_PMON_CNT2_PKT_FILT_set(NULL, cpb_handle, port, filter);
            break;
        case 3:
            slave_dpi_field_PMON_CNT3_PKT_FILT_set(NULL, cpb_handle, port, filter);
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
            break;
    }


    /* Take counter out of reset  */
    switch (counter_num) {
        case 0:
            slave_dpi_field_PMON_CNT0_RST_set( NULL, cpb_handle, port, 0 );
            break;
        case 1:
            slave_dpi_field_PMON_CNT1_RST_set( NULL, cpb_handle, port, 0 );
            break;
        case 2:
            slave_dpi_field_PMON_CNT2_RST_set( NULL, cpb_handle, port, 0 );
            break;
        case 3:
            slave_dpi_field_PMON_CNT3_RST_set( NULL, cpb_handle, port, 0 );
            break;
        default:
            PMC_RETURN(CPB_ERR_INVALID_ARG);
            break;
    }

    PMC_RETURN(PMC_SUCCESS);

} /* cpb_pmon_cfg */


/*******************************************************************************
* cpb_dcs_wrr_entry_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function reads the contents to a DCS WRR calendar entry in the offline
*   page.
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   dcs_inst              - DCS instance 0 to 3
*   entry_offset          - The index of the entry
*
* OUTPUTS:
*   c_ram_sf1_ptr         - push port id
*   c_ram_sf2_ptr         - write queue id
*   c_ram_channel_ptr     - Channel Identifier of Calendar entry
*   c_ram_identifier_ptr  - Queue or Group Identifier of Calendar entry*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_dcs_wrr_entry_get( cpb_handle_t *cpb_handle,
                                         UINT32 dcs_inst,
                                         UINT32 entry_offset,
                                         UINT32 *c_ram_sf1_ptr,
                                         UINT32 *c_ram_sf2_ptr,
                                         UINT32 *c_ram_channel_ptr,
                                         UINT32 *c_ram_identifier_ptr)
{
        dcs_buffer_t dcs_buffer;

        PMC_ENTRY();

        dcs_buffer_init(&dcs_buffer, cpb_handle, dcs_inst);

        *c_ram_sf1_ptr        = dcs_field_C_RAM_SF1_get        ( &dcs_buffer, cpb_handle, dcs_inst, entry_offset);
        *c_ram_sf2_ptr        = dcs_field_C_RAM_SF2_get        ( &dcs_buffer, cpb_handle, dcs_inst, entry_offset);
        *c_ram_channel_ptr    = dcs_field_C_RAM_CHANNEL_get    ( &dcs_buffer, cpb_handle, dcs_inst, entry_offset);
        *c_ram_identifier_ptr = dcs_field_C_RAM_IDENTIFIER_get ( &dcs_buffer, cpb_handle, dcs_inst, entry_offset);

        PMC_RETURN  (PMC_SUCCESS);
} /* cpb_dcs_wrr_entry_get */

/*******************************************************************************
* cpb_slv_dpi_qs_ch_en_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function reads the QSn_CH_EN for a DPI slave port channel.
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   slv_port              - DPI Slave Port 0 to 7
*   chnl                  - DPI Slave Port Channel 0 to 255
*
* OUTPUTS:
*   qs0_ch_en_ptr         - QS0_CH_EN field setting
*   qs1_ch_en_ptr         - QS1_CH_EN field setting
*   qs2_ch_en_ptr         - QS2_CH_EN field setting
*   qs3_ch_en_ptr         - QS3_CH_EN field setting
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_slv_dpi_qs_ch_en_get(cpb_handle_t *cpb_handle,
                                           UINT32 slv_port,
                                           UINT32 chnl,
                                           UINT32 *qs0_ch_en_ptr,
                                           UINT32 *qs1_ch_en_ptr,
                                           UINT32 *qs2_ch_en_ptr,
                                           UINT32 *qs3_ch_en_ptr)
{
        slave_dpi_buffer_t slave_dpi_buffer;

        PMC_ENTRY();

        slave_dpi_buffer_init( &slave_dpi_buffer, cpb_handle, slv_port);

        *qs0_ch_en_ptr = slave_dpi_field_QS0_CH_EN_get ( &slave_dpi_buffer, cpb_handle, slv_port, chnl);
        *qs1_ch_en_ptr = slave_dpi_field_QS1_CH_EN_get ( &slave_dpi_buffer, cpb_handle, slv_port, chnl);
        *qs2_ch_en_ptr = slave_dpi_field_QS2_CH_EN_get ( &slave_dpi_buffer, cpb_handle, slv_port, chnl);
        *qs3_ch_en_ptr = slave_dpi_field_QS3_CH_EN_get ( &slave_dpi_buffer, cpb_handle, slv_port, chnl);

        PMC_RETURN  (PMC_SUCCESS);
} /* cpb_slv_dpi_qs_ch_en_get */

#ifndef CPB_UNIT_TEST
/*******************************************************************************
* cpb_fw_slv_dpi_qs_ch_en_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function reads the QSn_CH_EN for a DPI slave port channel from firmware.
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   slv_port              - DPI Slave Port 0 to 7
*   slv_chnl              - DPI Slave Port Channel 0 to 255
*
* OUTPUTS:
*   slv_data_ptr          - Updates this structure with the results
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_fw_slv_dpi_qs_ch_en_get(cpb_handle_t *cpb_handle,
                                              UINT32 slv_port,
                                              UINT32 slv_chnl,
                                              cpb_slv_data_t *slv_data_ptr)
{
    PMC_ENTRY();

    PMC_ERROR result = PMC_SUCCESS;
    UINT32 i;
    hostmsg_opsa_subsystem_cfg_t subsystem = LAST_OPSA_HOSTMSG_SS;
    fw_opsa_status_t fw_opsa_status;

    switch (cpb_handle->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
            switch (slv_port)
            {
                case 0:
                case 1:
                break;

                case 2:
                    subsystem = OPSA_HOSTMSG_CPB_SS_CBRC;
                break;

                case 3:
                    subsystem = OPSA_HOSTMSG_CPB_SS_MAPOTN;
                break;

                case 4:
                    subsystem = OPSA_HOSTMSG_CPB_SS_ENET_LINE;
                break;

                case 5:
                    subsystem = OPSA_HOSTMSG_CPB_SS_ENET_SYS;

            }

        break;

        case CPB_INSTANCE_OCPB:
            switch (slv_port)
            {
                case 0:
                    if(cpb_handle->var.cpb_oduksw_port0 == CPB_ODUKSW_PORT0_COREOTN_CTRL && slv_chnl < 12)
                    {
                        /* Only channels 0-11 are valid with this connection */
                        subsystem = OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_CTL;
                    }
                    else
                    {
                        subsystem = LAST_OPSA_HOSTMSG_SS;
                    }
                break;

                case 1:
                break;

                case 2:
                    subsystem = OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_FO1;
                break;

                case 3:
                    subsystem = OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_FO2;
                break;
            }
        break;

        default:
        break;
    }

    if (subsystem != LAST_OPSA_HOSTMSG_SS)
    {
        result = cpb_fw_opsa_debug_status_internal_get(cpb_handle,
                                                       subsystem,
                                                       slv_chnl,
                                                       &fw_opsa_status);

        if(fw_opsa_status.mpma_enable == 1)
        {
            for(i=0;i<4;i++)
            {
                if( ((fw_opsa_status.mpma_qs_ch_en>>i) & 1) == 1 )
                {
                    slv_data_ptr->slv_data[slv_port][slv_chnl].qs_ch_en[i] = 1;
                    PMC_LOG_TRACE("cpb_fw_slv_dpi_qs_ch_en_get - Setting qs ch en for slv_port: %u, slv_chnl %u\n",slv_port,slv_chnl);


                }
            }
        }

    }
    if (PMC_SUCCESS != result)
    {
        PMC_LOG_TRACE("cpb_fw_slv_dpi_qs_ch_en_get - Setting qs ch en for slv_port: %u, slv_chnl %u\n",slv_port,slv_chnl);
    }
    PMC_RETURN  (result);

} /* cpb_fw_slv_dpi_qs_ch_en_get */

/*******************************************************************************
* cpb_fw_slv_dpi_qs_ch_en_clear
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function clears the QSn_CH_MST for a DPI slave port channel in the
*   firmware.
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   slv_port              - DPI Slave Port 0 to 7
*   slv_chnl              - DPI Slave Port Channel 0 to 255
*   queue_system          - queue system number 0 to 3
*
* OUTPUTS:
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_fw_slv_dpi_qs_ch_en_clear(cpb_handle_t *cpb_handle,
                                                UINT32 slv_port,
                                                UINT32 slv_chnl,
                                                UINT32 queue_system)
{
    UINT8 qs_ch_en_array[96] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
                                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
                                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
                                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
                                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
                                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    UINT32 chnl_add_msk[3] = {0, 0, 0};
    hostmsg_opsa_subsystem_cfg_t subsystem = LAST_OPSA_HOSTMSG_SS;
    PMC_ERROR result = PMC_SUCCESS;
    UINT8 qs_ch_en_mask = 0;

    PMC_ENTRY();

    switch (cpb_handle->cfg.cpb_type)
    {
        case CPB_INSTANCE_DCPB:
            switch (slv_port)
            {
                case 0:
                case 1:
                break;

                case 2:
                    subsystem = OPSA_HOSTMSG_CPB_SS_CBRC;
                break;

                case 3:
                    subsystem = OPSA_HOSTMSG_CPB_SS_MAPOTN;
                break;

                case 4:
                    subsystem = OPSA_HOSTMSG_CPB_SS_ENET_LINE;
                break;

                case 5:
                    subsystem = OPSA_HOSTMSG_CPB_SS_ENET_SYS;

            }

        break;

        case CPB_INSTANCE_OCPB:
            switch (slv_port)
            {
                case 0:
                    if(cpb_handle->var.cpb_oduksw_port0 == CPB_ODUKSW_PORT0_COREOTN_CTRL && slv_chnl < 12)
                    {
                        /* Only channels 0-11 are valid with this connection */
                        subsystem = OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_CTL;
                    }
                    else
                    {
                        subsystem = LAST_OPSA_HOSTMSG_SS;
                    }

                break;

                case 1:
                break;

                case 2:
                    subsystem = OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_FO1;
                break;

                case 3:
                    subsystem = OPSA_HOSTMSG_ODUK_SW_SS_COREOTN_FO2;
                break;
            }
        break;

        default:
        break;
    }

    if(subsystem != LAST_OPSA_HOSTMSG_SS && slv_chnl < 96)
    {
        qs_ch_en_mask = 1 << queue_system;

        chnl_add_msk[slv_chnl/32] |= 1 << (slv_chnl %32);

        qs_ch_en_array[slv_chnl] = qs_ch_en_mask;

        result = cpb_fw_opsa_cfg_mpma_port_add(cpb_handle,
                                               subsystem,
                                               chnl_add_msk,
                                               qs_ch_en_array);

    }

    PMC_RETURN(result);
} /*cpb_fw_slv_dpi_qs_ch_en_clear */

#endif /* CPB_UNIT_TEST */

/*******************************************************************************
* cpb_oduksw_port0_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This functions sets cpb_oduksw_port0 in cpb context
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   cpb_oduksw_port0      - See cpb_oduksw_port0_t
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_oduksw_port0_set(cpb_handle_t *cpb_handle,
                                 cpb_oduksw_port0_t cpb_oduksw_port0)
{
    PMC_ENTRY();

    cpb_handle->var.cpb_oduksw_port0 = cpb_oduksw_port0;

    PMC_RETURN();
} /* cpb_oduksw_port0_set */


/*******************************************************************************
* cpb_oduksw_port0_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This functions sets cpb_oduksw_port0 in cpb context
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   cpb_oduksw_port0_t    - ODUKSW port 0 configuration context
*
* NOTES:
*
*******************************************************************************/
PUBLIC cpb_oduksw_port0_t cpb_oduksw_port0_get(cpb_handle_t *cpb_handle)
{
    PMC_ENTRY();

    PMC_RETURN(cpb_handle->var.cpb_oduksw_port0);

} /* cpb_oduksw_port0_get */


/*******************************************************************************
* cpb_slv_dpi_qs_ch_mst_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function reads the QSn_CH_MST for a DPI slave port channel.
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   slv_port              - DPI Slave Port 0 to 7
*   chnl                  - DPI Slave Port Channel 0 to 255
*
* OUTPUTS:
*   qs0_ch_mst_ptr         - QS0_CH_MST field setting
*   qs1_ch_mst_ptr         - QS1_CH_MST field setting
*   qs2_ch_mst_ptr         - QS2_CH_MST field setting
*   qs3_ch_mst_ptr         - QS3_CH_MST field setting
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_slv_dpi_qs_ch_mst_get(cpb_handle_t *cpb_handle,
                                            UINT32 slv_port,
                                            UINT32 chnl,
                                            UINT32 *qs0_ch_mst_ptr,
                                            UINT32 *qs1_ch_mst_ptr,
                                            UINT32 *qs2_ch_mst_ptr,
                                            UINT32 *qs3_ch_mst_ptr)
{
        slave_dpi_buffer_t slave_dpi_buffer;

        PMC_ENTRY();

        slave_dpi_buffer_init( &slave_dpi_buffer, cpb_handle, slv_port);

        *qs0_ch_mst_ptr = slave_dpi_field_QS0_CH_MST_get ( &slave_dpi_buffer, cpb_handle, slv_port, chnl);
        *qs1_ch_mst_ptr = slave_dpi_field_QS1_CH_MST_get ( &slave_dpi_buffer, cpb_handle, slv_port, chnl);
        *qs2_ch_mst_ptr = slave_dpi_field_QS2_CH_MST_get ( &slave_dpi_buffer, cpb_handle, slv_port, chnl);
        *qs3_ch_mst_ptr = slave_dpi_field_QS3_CH_MST_get ( &slave_dpi_buffer, cpb_handle, slv_port, chnl);

        PMC_RETURN  (PMC_SUCCESS);
} /* cpb_slv_dpi_qs_ch_mst_get */

/*******************************************************************************
* cpb_slv_dpi_qs_pop_qid_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function reads the QSn_CH_EN for a DPI slave port channel.
*
*
* INPUTS:
*   *cpb_handle           - pointer to CPB handle instance.
*   slv_port              - DPI Slave Port 0 to 7
*   chnl                  - DPI Slave Port Channel 0 to 255
*
* OUTPUTS:
*   qs0_pop_qid_ptr         - QS0_POP_QID field setting
*   qs1_pop_qid_ptr         - QS1_POP_QID field setting
*   qs2_pop_qid_ptr         - QS2_POP_QID field setting
*   qs3_pop_qid_ptr         - QS3_POP_QID field setting
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_slv_dpi_qs_pop_qid_get(cpb_handle_t *cpb_handle,
                                           UINT32 slv_port,
                                           UINT32 chnl,
                                           UINT32 *qs0_pop_qid_ptr,
                                           UINT32 *qs1_pop_qid_ptr,
                                           UINT32 *qs2_pop_qid_ptr,
                                           UINT32 *qs3_pop_qid_ptr)
{
        slave_dpi_buffer_t slave_dpi_buffer;

        PMC_ENTRY();

        slave_dpi_buffer_init( &slave_dpi_buffer, cpb_handle, slv_port);

        *qs0_pop_qid_ptr = slave_dpi_field_QS0_POP_QID_get ( &slave_dpi_buffer, cpb_handle, slv_port, chnl);
        *qs1_pop_qid_ptr = slave_dpi_field_QS1_POP_QID_get ( &slave_dpi_buffer, cpb_handle, slv_port, chnl);
        *qs2_pop_qid_ptr = slave_dpi_field_QS2_POP_QID_get ( &slave_dpi_buffer, cpb_handle, slv_port, chnl);
        *qs3_pop_qid_ptr = slave_dpi_field_QS3_POP_QID_get ( &slave_dpi_buffer, cpb_handle, slv_port, chnl);

        PMC_RETURN  (PMC_SUCCESS);
} /* cpb_slv_dpi_qs_pop_qid_get */

/*******************************************************************************
* cpb_dcs_enable
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function enables or disables a DCS instance
*
*
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   slice                 - DCS instance 0 to 3
*
*
* OUTPUTS:
*   *enable_ptr           - DCS enable state:\n
*                           1: Enabled\n
*                           0: Disabled
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_dcs_enable_get( cpb_handle_t *h,
                                      UINT32 slice,
                                      BOOL8 *enable_ptr )
{
    PMC_ENTRY();

    *enable_ptr = dcs_field_DCS_ENABLE_get(NULL, h, slice);

    PMC_RETURN(PMC_SUCCESS);
} /* cpb_dcs_enable_get */

/*******************************************************************************
* cpb_mux_cpbd_src_sel_cfg_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function configures an ingress mux PORT MUX for CPB(D) to select data
*   for transfer to SIFD or ENET_SYS/CBRC.\n\n
*
*   This function is only applicable to the CPB(D) instantiation of the CPB
*   block.
*
*
* INPUTS:
*   *h                    - pointer to CPB handle instance.
*   port                  - Ingress Mux Port\n
*                           0: SIFD1 or ENET_SYS/CBRC\n
*                           1: SIFD2 or ENET_SYS/CBRC
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32                - Subsystem data source for ingress mux port\n
*                           0: ENET_SYS/CBRC\n
*                           1: SIFD
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32 cpb_mux_cpbd_src_sel_cfg_get(cpb_handle_t *h,
                                            UINT32 port)
{
    UINT32 igr_sifd_sel= 0;
    PMC_ENTRY();

    PMC_ASSERT(port <= 1, CPB_ERR_INVALID_ARG, 0, 0);

    if( 0 == port)
    {
        igr_sifd_sel = cpb_ctrl_field_IGR_SIFD1_SEL_get(NULL, h);
    } else {
        igr_sifd_sel = cpb_ctrl_field_IGR_SIFD2_SEL_get(NULL, h);
    }
    PMC_RETURN(igr_sifd_sel);

} /* cpb_mux_cpbd_src_sel_cfg_get */

/*******************************************************************************
* FUNCTION: cpb_debug_page_block_alloc_print
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function prints information about the page and block table.
*
*
* INPUTS:
*   cpb_handle       - Pointer to subsystem handle
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_debug_page_block_alloc_print(cpb_handle_t *cpb_handle)
{
    UINT32 i,j, index;
    PMC_ENTRY();

    PMC_LOG_NOTRACE("\n========================== cpb memory print ===========================\n");

    for( i = 0; i < cpb_handle->cfg.num_pages; i++)
    {
        PMC_LOG_NOTRACE("Page %u, Active %u", i, cpb_handle->var.page_inverted_page_table[i].ctrl_page_valid);
        if(cpb_handle->var.page_inverted_page_table[i].ctrl_page_valid)
        {
            PMC_LOG_NOTRACE("    push port: %u, pop port %u\n", cpb_handle->var.page_inverted_page_table[i].ctrl_ipt_wp_id, cpb_handle->var.page_inverted_page_table[i].ctrl_ipt_qs_id);
            for(j = 0; j < cpb_handle->cfg.blocks_per_page; j++)
            {
                index = i * cpb_handle->cfg.blocks_per_page + j;

                PMC_LOG_NOTRACE("    Block %u, Active %u\n", j, cpb_handle->var.block_inverted_page_table[index].ipt_valid);
            }
        }
    }

    PMC_RETURN();
} /* cpb_debug_page_block_alloc_print */



/*******************************************************************************
* FUNCTION: cpb_int_validate()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Validates input for interrupt functions.
*
*
* INPUTS:
*   cpb_handle       - Pointer to subsystem handle
*   port             - ingress mux input port id
*   port_chnl        - ingress mux input port chnl id
*   non_null_ptr     - Pointer to be checked that should not be null
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_int_validate(cpb_handle_t    *cpb_handle,
                                   UINT32           port,
                                   UINT32           port_chnl,
                                   void            *non_null_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;

    PMC_ENTRY();

    PMC_ASSERT(NULL != cpb_handle, CPB_ERR_NULL_HANDLE, 0, 0);


    if (NULL == non_null_ptr)
    {
        result = CPB_ERR_NULL_HANDLE;
    }

    if (PMC_SUCCESS == result)
    {
        result = cpb_chnl_range_check(cpb_handle,
                                      port,
                                      port_chnl,
                                      port,
                                      port_chnl);
    }


    PMC_RETURN(result);
} /* cpb_int_validate */



/* LCOV_EXCL_START */
/*******************************************************************************
* FUNCTION: cpb_int_chnl_clear()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Clears interrupts based on bits that are set in the
*   channel interrupt table.
*
*
* INPUTS:
*   cpb_handle        - Pointer to subsystem handle
*   port              - ingress mux input port id
*   port_chnl         - ingress mux input port chnl id
*   int_table_ptr     - pointer to channel interrupt table with
*                       bits set to clear interrupts
*   int_en_table_ptr  - Pointer to table tracking enabled interrupts
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_int_chnl_clear(cpb_handle_t    *cpb_handle,
                                    UINT32           port,
                                    UINT32           port_chnl,
                                    cpb_int_chnl_t  *int_table_ptr,
                                    cpb_int_chnl_t  *int_en_table_ptr)
{
    PMC_ERROR       result = PMC_SUCCESS;
    UINT32          link1 = port;
    UINT32          link2 = port_chnl;

    PMC_ENTRY();

    result = cpb_int_validate(cpb_handle, port, port_chnl, int_en_table_ptr);



    #ifdef CPB_INT_RANGE
    #undef CPB_INT_RANGE
    #endif
    #define CPB_INT_RANGE    UTIL_GLOBAL_INT_CLEAR_RANGE

    CPB_INT_TABLE_DEFINE();


    PMC_RETURN(result);
} /* cpb_int_chnl_clear */
/* LCOV_EXCL_STOP */



/*******************************************************************************
* FUNCTION: cpb_int_chnl_retrieve()
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Retrieves all interrupts to the channelized interrupt table.
*
*
* INPUTS:
*   cpb_handle        - Pointer to subsystem handle
*   port              - ingress mux input port id
*   port_chnl         - ingress mux input port chnl id
*   filt_table_ptr    - pointer to filter table. Mark fields as TRUE within this
*                       table to indicate that the interrupt/status will be retrieved
*                       to the output table. NULL to retrieve all
*                       interrupt/status.
*
* OUTPUTS:
*   int_table_ptr     - pointer to channel interrupt table to fill with
*                       retrieved data
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_int_chnl_retrieve(cpb_handle_t    *cpb_handle,
                                       UINT32           port,
                                       UINT32           port_chnl,
                                       cpb_int_chnl_t  *filt_table_ptr,
                                       cpb_int_chnl_t  *int_table_ptr)
{
    PMC_ERROR            result = PMC_SUCCESS;
    UINT32               link   = port;
    UINT32               link1  = port;
    UINT32               link2  = port_chnl;

    PMC_ENTRY();

    result = cpb_int_validate(cpb_handle, port, port_chnl, int_table_ptr);


    UTIL_GLOBAL_INT_BUFFER_INIT(cpb_handle, slave_dpi, UTIL_GLOBAL_INT_OPTIMIZE);

    #ifdef CPB_INT_RANGE
    #undef CPB_INT_RANGE
    #endif
    #define CPB_INT_RANGE    UTIL_GLOBAL_INT_RETRIEVE_RANGE

    CPB_INT_TABLE_DEFINE();

    UTIL_GLOBAL_INT_BUFFER_FLUSH(cpb_handle, slave_dpi);

    PMC_RETURN(result);
} /* cpb_int_chnl_retrieve */


/*******************************************************************************
* cpb_dcs_calendar_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Reconfigures DCS calendar by performing page update and swap.  It is
*   assumed that the database has been modified prior to calling this.
*
* INPUTS:
*   *cpb_handle      - pointer to cpb handle instance.
*   dcs_inst         - DCS instance from 0 to 3
*   rd_queue_id      - Read Queue ID
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_dcs_calendar_cfg(cpb_handle_t *cpb_handle,
                                      UINT32 dcs_inst,
                                      UINT32 rd_queue_id)
{
    PMC_ENTRY();

    PMC_LOG_TRACE("Configuring DCS calendar...\n");
    PMC_LOG_TRACE("dcs_inst = %u\n ", dcs_inst);

    /* confirm database associated with DCS instance */
    /* if data base does not exist return an error */
    if(cpb_handle->cfg.dcs_use_ctxt[dcs_inst].alloc_mode != UTIL_SCHD_ALLOC_METHOD_CPB_DCS)
    {
        PMC_RETURN(CPB_ERR_UNSUPPORTED_SCHD_MODE);
    }

    cpb_dcs_chnl_activate(cpb_handle, dcs_inst, rd_queue_id);
    /* Update offline page and swap it in*/
    cpb_dcs_page_update_and_swap(cpb_handle, dcs_inst);

    PMC_LOG_TRACE("cpb_dcs_calendar_reconfig result: success\n");
    PMC_RETURN(PMC_SUCCESS);


} /* cpb_dcs_calendar_cfg */


/*******************************************************************************
* cpb_pmpm_recover_pages
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function attempts to free one page from each push-pop port pair. It
*   can be called multiple times to free additional pages.
*
* INPUTS:
*   *cpb_handle         - pointer to CPB handle instance.
*
* OUTPUTS:
*   *num_pages_freed    - the number of pages freed as a result of calling
*                         this function.
*   *num_pages_failed   - the number of pages that should have been freed
*                         but encountered an error.
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_pmpm_recover_pages(cpb_handle_t *cpb_handle,
                                        UINT32 *num_pages_freed,
                                        UINT32 *num_pages_failed)
{

    PMC_ERROR result = PMC_SUCCESS;
    PMC_ERROR resize_up_result = PMC_SUCCESS;
    PMC_ERROR resize_down_result = PMC_SUCCESS;
    cpb_pmpm_use_summary_t page_summary;
    UINT32 port_pair_block_use[32];
    UINT32 i, k, a, j, push_port, pop_port, rid, n;
    BOOL do_consolidate = FALSE;
    UINT32 queue_index;

    PMC_ENTRY();

    *num_pages_freed = 0;
    *num_pages_failed = 0;

    /* Analyze pages and blocks to get a usage summary */
    result = cpb_pmpm_usage_summary_get(cpb_handle,
                                        &page_summary);
    if(result != PMC_SUCCESS)
        PMC_RETURN(result);

    /* Check if more than one page share the same push-pop port pair and if blocks
     * can be consolidated. */
    for(k=0;k<16;k++) /* k in the index in page_summary.page_assign, k = IPT_QS_ID * 4 + IPT_WP_ID */
    {
        cpb_port_pair_block_use_array_clean(cpb_handle, port_pair_block_use);

        if(page_summary.page_assign[k] != 0)
        {
            UINT32 page_with_space_mask = 0;
            UINT32 page_with_least_entries = 0;
            for(i=0;i<cpb_handle->cfg.num_pages;i++) /* i is the page index */
            {
                if( (page_summary.page_assign[k] & (1<<i) ) != 0)
                {
                    /* Page i is assigned to this push-pop pair */
                    port_pair_block_use[i] = page_summary.page_block_use[i];
                }
            }

            do_consolidate = cpb_page_indexes_to_consolidate(cpb_handle, port_pair_block_use, &page_with_space_mask,
                                                             &page_with_least_entries);

            /* If blocks can be moved, move them from the page with less blocks to the page
             * with more blocks */
            /* page_index2 should be moved into page_index1. All of the blocks in page2 must
             * be able to fit in page1*/

            if(do_consolidate)
            {

                for(j = 0; j < cpb_handle->cfg.blocks_per_page; j++)
                {
                    /* For every block that could need to be moved */

                    if(cpb_handle->var.block_inverted_page_table[page_with_least_entries*cpb_handle->cfg.blocks_per_page+j].ipt_valid == TRUE)
                    {
                        UINT32 new_page_index = 999;
                        do_consolidate = TRUE;

                        /* We have old page addr and old block addr and new page addr.
                         * Need to find new block addr */
                        for(i=0;i<cpb_handle->cfg.num_pages;i++) /* i is the page index */
                        {
                            if(((page_with_space_mask >> i) & 0x1) == 0x1 && port_pair_block_use[i] < cpb_handle->cfg.blocks_per_page)
                            {
                                new_page_index = i;
                                port_pair_block_use[i]++;
                                break;
                            }
                        }

                        for(n = 0; n < cpb_handle->cfg.blocks_per_page && do_consolidate == TRUE; n++)  
                        {                                                                               
                            if(cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*new_page_index+n].ipt_valid == FALSE)
                            {
                                /* We found a spot to move this block. Now move it */

                                util_global_chnl_state_t output_state = LAST_UTIL_GLOBAL_CHNL_STATE;
                                UINT32 dummy;
                                do_consolidate = FALSE;
#ifndef PMC_SW_SIMULATION
                                /* determine operational state of FIFO associated with block */
                                cpb_rd_queue_id_and_state_get(cpb_handle,
                                                              cpb_handle->var.page_inverted_page_table[page_with_least_entries].ctrl_ipt_wp_id,
                                                              cpb_handle->var.page_inverted_page_table[page_with_least_entries].ctrl_ipt_qs_id,
                                                              cpb_handle->var.block_inverted_page_table[page_with_least_entries*cpb_handle->cfg.blocks_per_page + j].ipt_wqid,
                                                              &dummy,
                                                              &output_state);
#else
                                if(FALSE) /* resolve compile issue with unused function */
                                {
                                            cpb_rd_queue_id_and_state_get(cpb_handle,
                                                                          cpb_handle->var.page_inverted_page_table[page_with_least_entries].ctrl_ipt_wp_id,
                                                                          cpb_handle->var.page_inverted_page_table[page_with_least_entries].ctrl_ipt_qs_id,
                                                                          cpb_handle->var.block_inverted_page_table[page_with_least_entries*cpb_handle->cfg.blocks_per_page + j].ipt_wqid,
                                                                          &dummy,
                                                                          &output_state);  
                                }
                                output_state = UTIL_GLOBAL_CHNL_OPERATIONAL;
#endif
                        
                                if(!(output_state == UTIL_GLOBAL_CHNL_OPERATIONAL || output_state == UTIL_GLOBAL_CHNL_BACKUP))
                                {
                                    /* case where FIFO is not scheduled in DCS - the old block may be written to 0s and the new
                                       block updated with the data of the old block. */
                                    UINT32 wqid_val = cpb_handle->var.block_inverted_page_table[page_with_least_entries*cpb_handle->cfg.blocks_per_page + j].ipt_wqid;
                                    UINT32 lba_val  = cpb_handle->var.block_inverted_page_table[page_with_least_entries*cpb_handle->cfg.blocks_per_page + j].ipt_lba;

                                    /* write old block to 0s */
                                    cpb_block_table_cfg(cpb_handle,
                                                        FALSE,
                                                        page_with_least_entries,
                                                        j,
                                                        0,
                                                        0,
                                                        0);

                                    /* write old block's data to new block */
                                    cpb_block_table_cfg(cpb_handle,
                                                        FALSE,
                                                        new_page_index,
                                                        n,
                                                        1,
                                                        wqid_val,
                                                        lba_val);

#ifdef CPB_BLOCK_LIST
                                    if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_OCPB) {
                                        /* old_page_addr old_block_addr new_page_addr new_block_addr are all index */
                                        UINT32 new_uni_block_id, old_uni_block_id;
                                        UINT32 push_port_id;
                                        UINT32 write_qid;

                                        new_uni_block_id = new_page_index*cpb_handle->cfg.blocks_per_page + n;
                                        old_uni_block_id = page_with_least_entries*cpb_handle->cfg.blocks_per_page + j;

                                        push_port_id = cpb_handle->var.page_inverted_page_table[new_page_index].ctrl_ipt_wp_id;
                                        write_qid = cpb_handle->var.block_inverted_page_table[new_uni_block_id].ipt_wqid;

                                        if (cpb_handle->var.cpb_connect_data->queue_block[push_port_id][write_qid].head_block == old_uni_block_id) {
                                            cpb_handle->var.cpb_connect_data->queue_block[push_port_id][write_qid].head_block = new_uni_block_id;
                                        } 
                                        if (cpb_handle->var.cpb_connect_data->queue_block[push_port_id][write_qid].tail_block == old_uni_block_id) {
                                            cpb_handle->var.cpb_connect_data->queue_block[push_port_id][write_qid].tail_block = new_uni_block_id;
                                        }
                                        /* quene_length not changed */
                                        
                                        cpb_handle->var.block_inverted_page_table[new_uni_block_id].ipt_queue_prev = cpb_handle->var.block_inverted_page_table[old_uni_block_id].ipt_queue_prev;
                                        cpb_handle->var.block_inverted_page_table[new_uni_block_id].ipt_queue_next = cpb_handle->var.block_inverted_page_table[old_uni_block_id].ipt_queue_next;

                                        cpb_handle->var.block_inverted_page_table[old_uni_block_id].ipt_queue_prev = CPB_NULL_BLOCK_ID;
                                        cpb_handle->var.block_inverted_page_table[old_uni_block_id].ipt_queue_next = CPB_NULL_BLOCK_ID;
                                    }
#endif

                                }
                                else
                                {
                                    /* case where FIFO is scheduled in DCS - the operational channel requires the hardware block 
                                       remap feature to move the block */
                                    result = cpb_remap_block_cfg(cpb_handle,
                                                                 page_with_least_entries,
                                                                 j,
                                                                 new_page_index,
                                                                 n);
    
                                    /* If a move fails, it's possible that a FIFO is using all of it's blocks all
                                     * of the time. We can grow the FIFO by one, do the move, and then shrink the
                                     * FIFO by one */
                                    if(result != PMC_SUCCESS)
                                    {
                                        pop_port = k / 4;
                                        push_port = k % 4;
                                        rid = CPB_INVALID_REMAP_VALUE;
                                        for(a=0;a<cpb_handle->cfg.max_fifo_num;a++) /* a is the read queue id */
                                        {
                                            queue_index =  cpb_fifo_var_data_queue_index_get(cpb_handle, pop_port, a);
                                            if(cpb_handle->var.fifo_var_data[queue_index].status == CPB_FIFO_BEING_USED &&
                                               cpb_handle->var.fifo_var_data[queue_index].push_port_id == push_port &&
                                               cpb_handle->var.fifo_var_data[queue_index].write_id ==
                                                  cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*page_with_least_entries+j].ipt_wqid)
                                            {
                                                rid = a;
                                                continue;
                                            }
                                        }
    
                                        /* If we already had a failed resize dont
                                         * try again */
                                        if(rid != CPB_INVALID_REMAP_VALUE && cpb_handle->var.block_leak.leak_exists == FALSE)
                                        {
                                            /* To avoid the queue resize creating a block at the destination address of the remap, temporarily set the valid to
                                             * true */
                                            cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*new_page_index+n].ipt_valid = 1;
    
                                            resize_up_result = cpb_queue_relative_resize(cpb_handle,
                                                                                         pop_port,
                                                                                         rid,
                                                                                         FALSE,
                                                                                         1,
                                                                                         0);
    
                                            cpb_handle->var.block_inverted_page_table[cpb_handle->cfg.blocks_per_page*new_page_index+n].ipt_valid = 0;
    
                                            if(resize_up_result == PMC_SUCCESS)
                                            {
                                                result = cpb_remap_block_cfg(cpb_handle,
                                                                             page_with_least_entries,
                                                                             j,
                                                                             new_page_index,
                                                                             n);
    
                                            }
    
                                            /* If the queue was resized up, then resize it back down */
                                            if(resize_up_result == PMC_SUCCESS)
                                            {
    
                                                resize_down_result = cpb_queue_relative_resize(cpb_handle,
                                                                                               pop_port,
                                                                                               rid,
                                                                                               FALSE,
                                                                                               0,
                                                                                               1);
    
                                                if(resize_down_result != PMC_SUCCESS)
                                                {
                                                    /* Block leak indicates that a FIFO was resized up by
                                                     * one block to do the remap but couldn't be
                                                     * resized back down. There is one more block allocated
                                                     * then there should be. We only allow a block leak of
                                                     * 1 for the entire CPB instance. */
                                                    cpb_handle->var.block_leak.leak_exists = TRUE;
                                                    cpb_handle->var.block_leak.pop_port = pop_port;
                                                    cpb_handle->var.block_leak.rid = rid;
                                                }
                                            }
                                            /* If the initial resize up failed, we can reset it for the next FIFO.
                                             * There is no block leak */
                                            resize_up_result = PMC_SUCCESS;
                                        }
                                    } /* end if(result != PMC_SUCCESS) of first block remap */
                                }

                            } /* end if(cpb_handle->var.block_inverted_page_table[page1_block_index].ipt_valid == FALSE) */
                        } /* end for(n = 0; n < cpb_handle->cfg.blocks_per_page && do_consolidate == TRUE; n++) */
                    } /* end if(cpb_handle->var.block_inverted_page_table[page2_block_index].ipt_valid == TRUE) */
                } /* end for(j = 0; j < cpb_handle->cfg.blocks_per_page; j++) */

                /* If all the remaps and resizes were successful, page2 is
                 * empty and can be released. If the FIFO was resized up, the
                 * block was remaped, and the resize down failed, then it's
                 * possible that this FIFO still has a block on page2 so we
                 * can't release it */
                if(result == PMC_SUCCESS && resize_down_result == PMC_SUCCESS)
                {
                    /* page2 had all of it's blocks moved so invalidate the page */
                    result = cpb_page_table_cfg(cpb_handle,
                                                page_with_least_entries,
                                                0,
                                                0,
                                                0,
                                                0);
                    *num_pages_freed = *num_pages_freed + 1;
                }
                else
                {
                    *num_pages_failed = *num_pages_failed + 1;
                    result = PMC_SUCCESS; /* the failure has been tracked */
                    resize_down_result = PMC_SUCCESS;
                }
            } /* end if(do_consolidate) */

        } /* end if if(page_summary.page_assign[k] != 0) */

    } /* end for k */

    PMC_RETURN(result);

} /* cpb_pmpm_recover_pages */

/*******************************************************************************
* cpb_remap_clean
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function attemps to clean a block leak if one exists.
*
* INPUTS:
*   *cpb_handle     - pointer to CPB handle instance.
*
* OUTPUTS:
*   *master_port       - If there is a block leak this is the master port
*                         associated with the block leak
*   *master_channel    - If there is a block leak this is the master channel
*                         associated with the block leak
*
* RETURNS:
*   TRUE    - There is still an outstanding block leak
*   FALSE   - Either there was no block leak, or there was
*             a block leak and it has been resolved
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL cpb_remap_clean(cpb_handle_t * cpb_handle,
                            UINT32 * master_port,
                            UINT32 * master_channel)
{

    PMC_ENTRY();
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 dcs_rd_channel;

    if(cpb_handle->var.block_leak.leak_exists == FALSE)
        PMC_RETURN(FALSE);

    /* Resize this queue down */
    result = cpb_queue_relative_resize(cpb_handle,
                                       cpb_handle->var.block_leak.pop_port,
                                       cpb_handle->var.block_leak.rid,
                                       TRUE,
                                       0,
                                       1);

    if(result == PMC_SUCCESS)
    {
        cpb_handle->var.block_leak.leak_exists = FALSE;
        cpb_handle->var.block_leak.pop_port = CPB_INVALID_REMAP_VALUE;
        cpb_handle->var.block_leak.rid = CPB_INVALID_REMAP_VALUE;
    }
    else
    {
        cpb_egress_mux_port_chnl_get(cpb_handle,
                                     cpb_handle->var.block_leak.pop_port,
                                     cpb_handle->var.block_leak.rid,
                                     &dcs_rd_channel,
                                     master_port,
                                     master_channel);

    }

    PMC_RETURN(cpb_handle->var.block_leak.leak_exists);
} /* cpb_remap_clean */


/*******************************************************************************
* cpb_pmpm_usage_summary_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This functions returns information about page block use and page push-pop
*   port pair assignment.
*
* INPUTS:
*   *cpb_handle     - pointer to CPB handle instance.
*
* OUTPUTS:
*   *page_summary       - describes pmpm page use. See cpb_pmpm_use_summary_t
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_pmpm_usage_summary_get(cpb_handle_t *cpb_handle,
                                            cpb_pmpm_use_summary_t *page_summary)
{
    PMC_ERROR result = PMC_SUCCESS;
    UINT32 i, j, k, index, queue_system, push_port;

    PMC_ENTRY();

    for(i=0;i<cpb_handle->cfg.num_pages;i++)
    {
        if(cpb_handle->var.page_inverted_page_table[i].ctrl_page_valid == FALSE)
        {
            page_summary->page_block_use[i] = CPB_INVALID_REMAP_VALUE;
        }
        else
        {
            page_summary->page_block_use[i] = 0;

            for(j = 0; j < cpb_handle->cfg.blocks_per_page; j++)
            {
                index = i * cpb_handle->cfg.blocks_per_page + j;

                if(cpb_handle->var.block_inverted_page_table[index].ipt_valid == TRUE)
                    page_summary->page_block_use[i]++;

            }
        }
    }

    for(k=0;k<16;k++)
    {
        /* Array index = IPT_QS_ID * 4 + IPT_WP_ID */
        queue_system = k / 4;
        push_port = k % 4;
        page_summary->page_assign[k] = 0;

        for(i=0;i<cpb_handle->cfg.num_pages;i++)
        {
            if(cpb_handle->var.page_inverted_page_table[i].ctrl_page_valid == TRUE &&
            cpb_handle->var.page_inverted_page_table[i].ctrl_ipt_qs_id == queue_system &&
                cpb_handle->var.page_inverted_page_table[i].ctrl_ipt_wp_id == push_port)
            {
                page_summary->page_assign[k] = (page_summary->page_assign[k] | (1<<i) );
            }

        }
    }

    PMC_RETURN(result);
} /* cpb_pmpm_usage_summary_get */

/*******************************************************************************
* cpb_remap_block_cfg
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function remaps the memory block from old_page_addr/old_block_addr to
*   new_page_addr/new_block_addr.
*   If this cannot be done safely, it will abort the remap and return an error
*   code.
*
* INPUTS:
*   *cpb_handle       - pointer to CPB handle instance.
*   old_page_addr     - address of old page
*   old_block_addr    - address of old block relative to the page
*   new_page_addr     - address of new page
*   new_block_addr    - address of new block relative to the page
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   CPB_ERR_REMAP_ABORTED - Internally generated error code
*                       0 - PMC_SUCCESS
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_remap_block_cfg(cpb_handle_t *cpb_handle,
                                     UINT32 old_page_addr,
                                     UINT32 old_block_addr,
                                     UINT32 new_page_addr,
                                     UINT32 new_block_addr)
{
    /* Variable declaration */
    scpb_reg_buffer_t scpb_reg_buffer;
    UINT32 remap_success;
    BOOL8 aborted = FALSE;
    PMC_ERROR ret_val = PMC_SUCCESS;
    PMC_ERROR function_ret_val = PMC_SUCCESS;
    PMC_ENTRY();

    /* Internally, the required block addr is computed
     * based on the page address and the block address*/
    UINT32 old_hw_block_addr;
    UINT32 new_hw_block_addr;
    BOOL old_ipt_active, new_ipt_active;

    /* If there is a current request pending, abort it */
#ifndef PMC_SW_SIMULATION
    ret_val = cpb_remap_block_abort(cpb_handle);
    if(ret_val != PMC_SUCCESS)
        PMC_RETURN(ret_val);
#endif

    old_hw_block_addr =
    (cpb_handle->cfg.blocks_per_page * old_page_addr) + old_block_addr;

    new_hw_block_addr =
    (cpb_handle->cfg.blocks_per_page * new_page_addr) + new_block_addr;

    scpb_reg_buffer_init( &scpb_reg_buffer, cpb_handle);

    /* First, assert that OLD block address has valid/active set to 1
     * and NEW block address has valid/active set to 0.
     * These are assertions instead of error because we never expect
     * this to not be the case.*/

    /* recover the active bits as they are read only */
    old_ipt_active =
    scpb_reg_field_IPT_BLOCK_ACTIVE_get (NULL, cpb_handle, old_page_addr, old_block_addr);
    new_ipt_active =
    scpb_reg_field_IPT_BLOCK_ACTIVE_get (NULL, cpb_handle, new_page_addr, new_block_addr);

    PMC_ASSERT(cpb_handle->var.block_inverted_page_table[old_hw_block_addr].ipt_valid == 1, CPB_ERR_CODE_ASSERT, 0, 0);
    PMC_ASSERT(cpb_handle->var.block_inverted_page_table[new_hw_block_addr].ipt_valid == 0, CPB_ERR_CODE_ASSERT, 0, 0);

#ifndef PMC_SW_SIMULATION
    PMC_ASSERT(old_ipt_active == 1, CPB_ERR_CODE_ASSERT, 0, 0);
    PMC_ASSERT(new_ipt_active == 0, CPB_ERR_CODE_ASSERT, 0, 0);
#endif

    /* Perform a test to confirm that the new and old block use the same IPT push/pop
       port pair, if not assert as the block migration is not valid */
    PMC_ASSERT(cpb_handle->var.page_inverted_page_table[old_page_addr].ctrl_ipt_qs_id == cpb_handle->var.page_inverted_page_table[new_page_addr].ctrl_ipt_qs_id, CPB_ERR_CODE_ASSERT, 0, 0);
    PMC_ASSERT(cpb_handle->var.page_inverted_page_table[old_page_addr].ctrl_ipt_wp_id == cpb_handle->var.page_inverted_page_table[new_page_addr].ctrl_ipt_wp_id, CPB_ERR_CODE_ASSERT, 0, 0);

    /* Need to set the LBA and WQID of the new block to match that of the old
     * block, the valid bit must remain set to 0 */
    cpb_block_table_cfg(cpb_handle,
                        TRUE,
                        new_page_addr,
                        new_block_addr,
                        0,
                        cpb_handle->var.block_inverted_page_table[old_hw_block_addr].ipt_wqid,
                        cpb_handle->var.block_inverted_page_table[old_hw_block_addr].ipt_lba);
    /* 1.  Set old block address field
     * 2.  Set new block address field
     * 3.  Set Remap Old Block config
     * 4.  Set Remap Old Page config
     * 5.  Set REMAP_REQ field to 1*/
    scpb_reg_field_REMAP_OLD_BLOCK_ADDR_set( &scpb_reg_buffer,
                                             cpb_handle,
                                             old_hw_block_addr);
    scpb_reg_field_REMAP_NEW_BLOCK_ADDR_set( &scpb_reg_buffer,
                                             cpb_handle,
                                             new_hw_block_addr);

    scpb_reg_field_REMAP_WQID_set( &scpb_reg_buffer,
                                   cpb_handle,
                                   cpb_handle->var.block_inverted_page_table[old_hw_block_addr].ipt_wqid);

    scpb_reg_field_REMAP_LBA_set( &scpb_reg_buffer,
                                   cpb_handle,
                                   cpb_handle->var.block_inverted_page_table[old_hw_block_addr].ipt_lba);


    scpb_reg_field_REMAP_QS_ID_set   ( &scpb_reg_buffer,
                                       cpb_handle,
                                       cpb_handle->var.page_inverted_page_table[old_page_addr].ctrl_ipt_qs_id );
    scpb_reg_field_REMAP_WP_ID_set     ( &scpb_reg_buffer,
                                       cpb_handle,
                                       cpb_handle->var.page_inverted_page_table[old_page_addr].ctrl_ipt_wp_id );


    scpb_reg_field_REMAP_REQ_set( &scpb_reg_buffer,
                                  cpb_handle,
                                  0x1);


    scpb_reg_buffer_flush(&scpb_reg_buffer);

    /* Poll REMAP_REQ to ensure success */
    ret_val = cpb_remap_req_poll_success( cpb_handle );

    /* If REMAP_REQ is still 1, then we must abort*/
    if (ret_val != PMC_SUCCESS)
    {
        /* Abort the request */
        PMC_LOG(PMC_LOG_SEV_HIGH, 0, 0, 0,
                "REMAP_REQ ABORTED=TRUE OldBlock=%d\n", old_block_addr);

        scpb_reg_field_REMAP_ABORT_set( &scpb_reg_buffer,
                                        cpb_handle,
                                        0x1 );
        scpb_reg_buffer_flush(&scpb_reg_buffer);

        /* Poll until REMAP_REQ gets cleared due to abort */
        ret_val = cpb_remap_req_poll_success( cpb_handle );

        PMC_ASSERT(PMC_SUCCESS == ret_val, CPB_ERR_CODE_ASSERT, 0, 0);

        /* If we had to abort, assume the remap request errored
         * It may have succeeded in the meantime, in which case
         * it will be updated below */  
        aborted = TRUE;

    }
    /* Read REMAP_SUCCESS bit
     * If it is 1, then set IPT_VALID (OLD_BLOCK_ADDR) to 0
     *  and IPT_VALID (NEW_BLOCK_ADDR) to 1.
    */
    remap_success = scpb_reg_field_REMAP_SUCCESS_get(&scpb_reg_buffer, 
                                                     cpb_handle);

#ifdef PMC_SW_SIMULATION
    remap_success = 1;
#endif
    if (TRUE == remap_success) 
   {
#ifndef PMC_SW_SIMULATION
        /* state of the active bit must have changed, if not then assert */
        PMC_ASSERT(0 == scpb_reg_field_IPT_BLOCK_ACTIVE_get(NULL, cpb_handle, old_page_addr, old_block_addr), CPB_ERR_CODE_ASSERT, 0, 0);
        PMC_ASSERT(1 == scpb_reg_field_IPT_BLOCK_ACTIVE_get(NULL, cpb_handle, new_page_addr, new_block_addr), CPB_ERR_CODE_ASSERT, 0, 0);
#endif
        /* update the new block so the valid bit is set */
        cpb_block_table_cfg(cpb_handle,
                            TRUE,
                            new_page_addr,
                            new_block_addr,
                            1,
                            cpb_handle->var.block_inverted_page_table[new_hw_block_addr].ipt_wqid,
                            cpb_handle->var.block_inverted_page_table[new_hw_block_addr].ipt_lba);

        /* update the old block so it is free */
        cpb_block_table_cfg(cpb_handle,
                            FALSE,
                            old_page_addr,
                            old_block_addr,
                            0,
                            0,
                            0);

        function_ret_val = PMC_SUCCESS;

#ifdef CPB_BLOCK_LIST
        if (cpb_handle->cfg.cpb_type == CPB_INSTANCE_OCPB) {
            /* old_page_addr old_block_addr new_page_addr new_block_addr are all index */
            UINT32 new_uni_block_id, old_uni_block_id;
            UINT32 push_port_id;
            UINT32 write_qid;

            /*
            new_uni_block_id = new_page_addr*cpb_handle->cfg.blocks_per_page + new_block_addr;
            old_uni_block_id = old_page_addr*cpb_handle->cfg.blocks_per_page + old_block_addr;
            */
            new_uni_block_id = new_hw_block_addr;
            old_uni_block_id = old_hw_block_addr;

            push_port_id = cpb_handle->var.page_inverted_page_table[new_page_addr].ctrl_ipt_wp_id;
            write_qid = cpb_handle->var.block_inverted_page_table[new_hw_block_addr].ipt_wqid;

            if (cpb_handle->var.cpb_connect_data->queue_block[push_port_id][write_qid].head_block == old_uni_block_id) {
                cpb_handle->var.cpb_connect_data->queue_block[push_port_id][write_qid].head_block = new_uni_block_id;
            } 
            if (cpb_handle->var.cpb_connect_data->queue_block[push_port_id][write_qid].tail_block == old_uni_block_id) {
                cpb_handle->var.cpb_connect_data->queue_block[push_port_id][write_qid].tail_block = new_uni_block_id;
            }
            /* quene_length not changed */
            
            cpb_handle->var.block_inverted_page_table[new_uni_block_id].ipt_queue_prev = cpb_handle->var.block_inverted_page_table[old_uni_block_id].ipt_queue_prev;
            cpb_handle->var.block_inverted_page_table[new_uni_block_id].ipt_queue_next = cpb_handle->var.block_inverted_page_table[old_uni_block_id].ipt_queue_next;

            cpb_handle->var.block_inverted_page_table[old_uni_block_id].ipt_queue_prev = CPB_NULL_BLOCK_ID;
            cpb_handle->var.block_inverted_page_table[old_uni_block_id].ipt_queue_next = CPB_NULL_BLOCK_ID;
        }
#endif
    } 
    else if(aborted == TRUE)
    {
        /* remove config from new block */
        cpb_block_table_cfg(cpb_handle,
                            TRUE,
                            new_page_addr,
                            new_block_addr,
                            0,
                            0,
                            0);

        PMC_LOG(PMC_LOG_SEV_HIGH, 0, 0, 0,
                "REMAP_REQ Executed for OldBlock=%d. REturn REMAP_ABORTED\n", old_block_addr);
        /*
         * Set the actual function return value.
         */
        function_ret_val = CPB_ERR_REMAP_ABORTED;
    }
    else
    {
        /* illegal logic state - ASSERT */
       PMC_ASSERT(FALSE, CPB_ERR_CODE_ASSERT, 0, 0);

    }

    PMC_RETURN(function_ret_val);

} /* cpb_remap_block_cfg */


/*******************************************************************************
* cpb_remap_block_abort
* ______________________________________________________________________________
*
* DESCRIPTION:
*   If there is currently a remap request pending, it will be aborted.
*
* INPUTS:
*   *cpb_handle       - pointer to CPB handle instance.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   PMC_SUCCESS - on success, error otherwise.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_remap_block_abort(cpb_handle_t *cpb_handle)
{
    UINT32 request_bit = 0;
    PMC_ERROR result = PMC_SUCCESS;
    PMC_ENTRY();

    request_bit = scpb_reg_field_REMAP_REQ_get(NULL,cpb_handle);

    if(request_bit == 1)
    {
        /* Abort the request */
        PMC_LOG_TRACE("REMAP_REQ is 1. Aborting...\n");

        scpb_reg_field_REMAP_ABORT_set(NULL,
                                       cpb_handle,
                                       0x1 );

        /* Poll until REMAP_REQ gets cleared due to abort */
        result = cpb_remap_req_poll_success(cpb_handle);

    }

    PMC_RETURN(result);
} /* cpb_remap_block_abort */


/*******************************************************************************
* cpb_remap_req_poll_success
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function polls the REMAP_REQ bit.
*
*
*
* INPUTS:
*   *cpb_handle            - pointer to CPB handle instance.

*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE PMC_ERROR cpb_remap_req_poll_success( cpb_handle_t *cpb_handle )
{
    /* Variable declaration */

    UINT32 max_count = CPB_REMAP_BLOCK_POLL_ITERATIONS;
    UINT32 delay_between_polls_in_microseconds = CPB_REMAP_BLOCK_POLL_DELAY;
    UINT32 num_iter;
    PMC_ERROR result;

    PMC_ENTRY();

    /*
     * Disable the FW queue to ensure that the poll actual completes or
     * actually fails and that the notification of the failure is reported
     * now.
     */
    l5sys_firmware_queue_disable(cpb_handle);
    /* Increase poll time for DCPB, since it has larger block sizes,
     * it can take longer to reach the safe wptr location
     */
    if(cpb_handle->cfg.cpb_type == CPB_INSTANCE_DCPB) {
        max_count = max_count * 4;
    }

    result = scpb_reg_field_REMAP_REQ_poll ( NULL,
                                             cpb_handle,
                                             0,
                                             PMC_POLL_EQUAL,
                                             max_count,
                                             &num_iter,
                                             delay_between_polls_in_microseconds );

    if(PMC_SUCCESS!=result)
        PMC_LOG_TRACE("REMAP_REQ failed after %u iterations\n",num_iter);
    else
        PMC_LOG_TRACE("REMAP_REQ succeeded after %u iterations\n",num_iter);

    l5sys_firmware_queue_enable(cpb_handle);
    /* return failure if polling fails */
    PMC_RETURN(result);

} /* cpb_remap_req_poll_success */

/*******************************************************************************
* cpb_port_pair_block_use_array_clean
* ______________________________________________________________________________
*
* DESCRIPTION:
*   This function set an array to defualt values.
*
*
* INPUTS:
*   cpb_handle              - Pointer to subsystem handle
*
* OUTPUTS:
*   *port_pair_block_use    - Array set to default values
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE void cpb_port_pair_block_use_array_clean(cpb_handle_t *cpb_handle,
                                                 UINT32 *port_pair_block_use)
{
    UINT32 i;
    PMC_ENTRY();

    for(i=0;i<32;i++)
        port_pair_block_use[i] = CPB_INVALID_REMAP_VALUE;

    PMC_RETURN();
} /* cpb_port_pair_block_use_array_clean  */

/*******************************************************************************
* cpb_page_indexes_to_consolidate
* ______________________________________________________________________________
*
* DESCRIPTION:
*   Look through the pages being used by this particular port pair and determine
*   if all the blocks from one page can fit in other pages that have available
*   space.
*
*
* INPUTS:
*   cpb_handle          - Pointer to subsystem handle
*   port_pair_block_use - Array of size 32. The index is the page number
*                         and the value is the number of blocks used in
*                         that page. This represents all of the pages and
*                         blocks used by a single port pair.
*
* OUTPUTS:
*   *page_with_space_mask     - Mask of PMPM pages that have available space
*                               for moving blocks from page with least used
*                               space.
*   *page_with_least_entries  - The index of the page from which the blocks
*                               should be moved.
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PRIVATE BOOL cpb_page_indexes_to_consolidate(cpb_handle_t *cpb_handle,
                                             UINT32 *port_pair_block_use,
                                             UINT32 *page_with_space_mask,
                                             UINT32 *page_with_least_entries)
{
    UINT32 i;
    UINT32 least_entries = cpb_handle->cfg.blocks_per_page;
    UINT32 pages_with_space = 0;
    UINT32 blocks_used = 0;
    PMC_ENTRY();

    *page_with_space_mask = 0;

    for(i=0; i < cpb_handle->cfg.num_pages; i++)
    {
        if(port_pair_block_use[i] != CPB_INVALID_REMAP_VALUE &&
           port_pair_block_use[i] < cpb_handle->cfg.blocks_per_page)
        {
            blocks_used += port_pair_block_use[i];
            pages_with_space++;
            *page_with_space_mask |= (1 << i);
            if(port_pair_block_use[i] < least_entries)
            {
                *page_with_least_entries = i;
                least_entries = port_pair_block_use[i];
            }
        }
    }

    *page_with_space_mask = *page_with_space_mask ^ (1 << *page_with_least_entries);

    if(pages_with_space > 1 &&
       (blocks_used <= ((pages_with_space-1) * cpb_handle->cfg.blocks_per_page)))
    {
        PMC_RETURN(TRUE);
    }

    PMC_RETURN(FALSE);
} /* cpb_page_indexes_to_consolidate  */


/*******************************************************************************
* cpb_ghao_queue_resize_zone_update
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function is used for G.HAO to resize the CPB queue for a given channel
*   configured in ODUflex. The zone threshold is updated accordingly.
*
* INPUTS:
*   *cpb_handle                 - pointer to CPB handle instance.
*   egress_mux_output_port      - master DPI port id
*   egress_mux_output_port_chnl - master DPI port channel id
*   halt_buffer                 - ODUk Switch FIFO buffer
*   oduflex_num_ts              - requested number of ODUflex tribslots
*   increase                    - 0: decrease; 1: increase
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   None.
*
* NOTES:
*
*******************************************************************************/
PUBLIC PMC_ERROR cpb_ghao_queue_resize_zone_update ( cpb_handle_t *cpb_handle,
                                                     UINT32 egress_mux_output_port,
                                                     UINT32 egress_mux_output_port_chnl,
                                                     UINT32 halt_buffer,
                                                     UINT32 oduflex_num_ts,
                                                     BOOL increase)
{
    PMC_ERROR result = PMC_SUCCESS;
    util_schd_chnl_rate_exp_t rate_units = UTIL_SCHD_1_BIT_SEC;
    UINT32 egress_mux_input_port = 0;
    UINT32 rd_channel_id = 0;
    UINT32 rd_queue_id = 0;
    UINT32 pop_port_id = 0;
    UINT32 push_port_id = 0;
    UINT32 wr_queue_id = 0;
    UINT32 ingress_mux_input_port = 0;
    UINT32 ingress_mux_input_port_chnl = 0;
    UINT32 queue_index = 0;
    DOUBLE odu_rate = 0;
    UINT32 out_odu_rate = 0;
    UINT32 num_blocks = 0;
    BOOL ilkn_source = FALSE;

    PMC_ENTRY();

    PMC_LOG_TRACE("Call cpb_ghao_queue_resize_zone_update(): egress_mux_output_port=%d, egress_mux_output_port_chnl=%d, halt_buffer=%d, oduflex_num_ts=%d, increase=%d\n", egress_mux_output_port, egress_mux_output_port_chnl, halt_buffer, oduflex_num_ts, increase);

    /* Get pop_port_id and rd_channel_id */
    if (result == PMC_SUCCESS)
    {
        result = cpb_dcs_egress_dpi_chnl_source_get( cpb_handle,
                                                     egress_mux_output_port,
                                                     egress_mux_output_port_chnl,
                                                     &egress_mux_input_port,
                                                     &rd_channel_id,
                                                     &rd_queue_id);
    }

    if (result == PMC_SUCCESS)
    {
        queue_index = cpb_fifo_var_data_queue_index_get(cpb_handle, egress_mux_input_port, rd_queue_id);
        if(cpb_handle->var.fifo_var_data[queue_index].chnl_type != CPB_SLAVE_ZONE_PRIMARY &&
           cpb_handle->var.fifo_var_data[queue_index].chnl_type != CPB_READER_PRIMARY)
        {
            PMC_RETURN(CPB_ERR_INVALID_ARG);
        }
    }

    /* Get ingress_mux_input_port and ingress_mux_input_port_chnl */
    if (result == PMC_SUCCESS)
    {
        result = cpb_ingress_mux_input_port_data_get(cpb_handle,
                                                     egress_mux_input_port,
                                                     rd_queue_id,
                                                     &wr_queue_id,
                                                     &ingress_mux_input_port,
                                                     &ingress_mux_input_port_chnl);
    }

    /* Calculate ODUflex rate */
    if (oduflex_num_ts <= 8)
    {
         odu_rate = (oduflex_num_ts * UTIL_GLOBAL_ODU2_TS_RATE);
    }
    else if (oduflex_num_ts <= 32)
    {
         odu_rate = (oduflex_num_ts * UTIL_GLOBAL_ODU3_TS_RATE);
    }
    else
    {
         odu_rate = (oduflex_num_ts * UTIL_GLOBAL_ODU4_TS_RATE);
    }
    /* convert odu_rate to fit in UINT32 */
    while (odu_rate > 4200E6)
    {
        /* increase rate unit */
        odu_rate /= 10;
        rate_units = (util_schd_chnl_rate_exp_t)((UINT32)rate_units + 1) ;
    }
    out_odu_rate = (UINT32)odu_rate;
    PMC_LOG_TRACE("odu_rate = %u\n", out_odu_rate);




    if(CPB_INSTANCE_DCPB == cpb_handle->cfg.cpb_type &&
       (CPB_DCPB_DPI_PORT_SIFD1 == ingress_mux_input_port ||
        CPB_DCPB_DPI_PORT_SIFD2 == ingress_mux_input_port))
    {
        ilkn_source = TRUE;
    }
    else
    {
        ilkn_source = FALSE;
    }


    /* Get number of blocks to be allocated */
    if (result == PMC_SUCCESS)
    {
        pop_port_id = egress_mux_input_port;
        push_port_id = ingress_mux_input_port;
        result = cpb_determine_num_blocks(cpb_handle,
                                          pop_port_id,
                                          push_port_id,
                                          rd_channel_id,
                                          out_odu_rate,
                                          rate_units,
                                          halt_buffer,
                                          ilkn_source,
                                          &num_blocks);
    }

    PMC_LOG_TRACE("cpb_ghao_queue_resize_zone_update(): new_num_blocks=%d\n", num_blocks);



    if(result == PMC_SUCCESS)
    {

        /* Perform resizing step */
        if (increase)
        {
            /* Resize fifo */
            if (result == PMC_SUCCESS)
            {
                result = cpb_queue_resize_wrapper( cpb_handle,
                                                   egress_mux_output_port,
                                                   egress_mux_output_port_chnl,
                                                   num_blocks);
            };
            /* Update zone threshold */
            if (result == PMC_SUCCESS)
            {
                result = cpb_dpi_slave_port_chnl_zone_thresh_cfg(cpb_handle,
                                                                 ingress_mux_input_port,
                                                                 ingress_mux_input_port_chnl,
                                                                 num_blocks*cpb_handle->cfg.bursts_per_block/4,
                                                                 num_blocks*cpb_handle->cfg.bursts_per_block/2,
                                                                 3*num_blocks*cpb_handle->cfg.bursts_per_block/4);
            }
        }
        else
        {
            /* Update zone threshold */
            if (result == PMC_SUCCESS)
            {
                result = cpb_dpi_slave_port_chnl_zone_thresh_cfg(cpb_handle,
                                                                 ingress_mux_input_port,
                                                                 ingress_mux_input_port_chnl,
                                                                 num_blocks*cpb_handle->cfg.bursts_per_block/4,
                                                                 num_blocks*cpb_handle->cfg.bursts_per_block/2,
                                                                 3*num_blocks*cpb_handle->cfg.bursts_per_block/4);
            };
            if (result == PMC_SUCCESS)
            {
                /* Resize fifo */
                result = cpb_queue_resize_wrapper( cpb_handle,
                                                   egress_mux_output_port,
                                                   egress_mux_output_port_chnl,
                                                   num_blocks);
            }
            else
            {
                /* Restore zone threshold*/
                cpb_dpi_slave_port_chnl_zone_thresh_cfg(cpb_handle,
                                                        ingress_mux_input_port,
                                                        ingress_mux_input_port_chnl,
                                                        num_blocks*cpb_handle->cfg.bursts_per_block/4,
                                                        num_blocks*cpb_handle->cfg.bursts_per_block/2,
                                                        3*num_blocks*cpb_handle->cfg.bursts_per_block/4);
            }
        }

    }


    PMC_RETURN(result);

} /* cpb_ghao_queue_resize_zone_update */

/*******************************************************************************
* cpb_fifo_var_data_queue_index_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function returns queue index associated to given channel.
*
* INPUTS:
*   *cpb_handle                 - pointer to CPB handle instance.
*   egress_mux_input_port       - Egress Mux Input Port.  Defines the DCS instance
*                                 to process the outbound data stream.
*   rd_queue_id                 - The read channel id.
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   FIFO data queue index.
*
* NOTES:
* PMC_ENTRY/PMC_RETURN not require here because of the number of times this
* function gets called.
*
*******************************************************************************/
PRIVATE UINT32 cpb_fifo_var_data_queue_index_get(cpb_handle_t *cpb_handle,
                                             UINT32        egress_mux_input_port,
                                             UINT32        rd_queue_id)
{
    UINT32 queue_id;
    queue_id = (egress_mux_input_port * cpb_handle->cfg.max_fifo_num) + rd_queue_id;

    return(queue_id);
} /* cpb_fifo_var_data_queue_index_get */

/*******************************************************************************
* cpb_num_calendar_entries_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function returns number of calendar entry per DCS
*
* INPUTS:
*   *cpb_handle                 - pointer to CPB handle instance.
*   dcs_inst                    - The dcs instance
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32 - number of calender entrie per DCS
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32 cpb_num_calendar_entries_get(cpb_handle_t *cpb_handle, UINT32 dcs_inst)
{
    UINT32 result = 0;

    PMC_ENTRY();
    if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type)
    {
        PMC_ASSERT(dcs_inst < MCPB_NUM_QUEUE_SYSTEMS, CPB_ERR_CODE_ASSERT, 0, 0);
        if (0 == dcs_inst || 1 == dcs_inst) 
        {            
            result = MCPB_MAX_SCHED_ENTRIES_DCS0_1;
        } else if (2 == dcs_inst)
        {
            result = MCPB_MAX_SCHED_ENTRIES_DCS2;
        } else 
        {
            result = MCPB_MAX_SCHED_ENTRIES_DCS3;
        }
    } else 
    {
        result = cpb_handle->cfg.num_calendar_entries;
    }
    PMC_RETURN(result);        
}

/*******************************************************************************
* cpb_num_sched_chans_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function returns number of scheduler channels  per DCS
*
* INPUTS:
*   *cpb_handle                 - pointer to CPB handle instance.
*   dcs_inst                    - The dcs instance
*
* OUTPUTS:
*   None.
*
* RETURNS:
*   UINT32 - number of calender entrie per DCS
*
* NOTES:
*
*******************************************************************************/
PRIVATE UINT32 cpb_num_sched_chans_get(cpb_handle_t *cpb_handle, UINT32 dcs_inst)
{
    UINT32 result = 0;

    PMC_ENTRY();
    if (CPB_INSTANCE_MCPB == cpb_handle->cfg.cpb_type)
    {
        PMC_ASSERT(dcs_inst < MCPB_NUM_QUEUE_SYSTEMS, CPB_ERR_CODE_ASSERT, 0, 0);
        if (0 == dcs_inst || 1 == dcs_inst) 
        {            
            result = MCPB_NUM_SCHED_CHANS_DCS0_1;
        } else if (2 == dcs_inst)
        {
            result = MCPB_NUM_SCHED_CHANS_DCS2;
        } else 
        {
            result = MCPB_NUM_SCHED_CHANS_DCS3;
        }
    } else 
    {
        result = CPB_MAX_FIFO_NUM;
    }
    PMC_RETURN(result);        
}

/*******************************************************************************
* cpb_oduksw_port_bulk_update_req_set
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   Set an indication whether there should be an update on an ODUKSW port
*   in the desired direction while performing bulk reprovision on ODUKSW.
*
* INPUTS:
*   *cpb_handle         - pointer to CPB handle instance
*   port_type           - the ODUKSW port type.
*   port_direction      - the ODUKSW port direction.
*   update_required     - TRUE: if the update is needed.
*
* RETURNS:
*   none
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_oduksw_port_bulk_update_req_set(cpb_handle_t *cpb_handle,
                                                util_global_oduk_port_t port_type,
                                                util_global_datapath_dir_t port_direction,
                                                BOOL8 update_required)
{
    PMC_ENTRY();

    PMC_ASSERT(port_type < UTIL_GLOBAL_ODUKSW_CONNECT_MAX_NUM_PORTS, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(port_direction < LAST_UTIL_GLOBAL_DATAPATH_DIR, CPB_ERR_INVALID_ARG,0 , 0);

    cpb_handle->var.cpb_connect_data->port_bulk_update_required[port_type][port_direction] = update_required;

    PMC_RETURN();
} /*cpb_oduksw_port_bulk_update_req_set*/

/*******************************************************************************
* cpb_oduksw_port_bulk_update_req_get
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   Get the indication whether there should be an update on an ODUKSW port
*   in the desired direction while performing bulk reprovision on ODUKSW.
*
* INPUTS:
*   *cpb_handle         - pointer to CPB handle instance
*   port_type           - the ODUKSW port type.
*   port_direction      - the ODUKSW port direction.
*
* RETURNS:
*   TRUE: if the update is needed.
*
* NOTES:
*
*******************************************************************************/
PUBLIC BOOL8 cpb_oduksw_port_bulk_update_req_get(cpb_handle_t *cpb_handle,
                                                 util_global_oduk_port_t port_type,
                                                 util_global_datapath_dir_t port_direction)
{
    PMC_ENTRY();

    PMC_ASSERT(port_type < UTIL_GLOBAL_ODUKSW_CONNECT_MAX_NUM_PORTS, CPB_ERR_INVALID_ARG, 0, 0);
    PMC_ASSERT(port_direction < LAST_UTIL_GLOBAL_DATAPATH_DIR, CPB_ERR_INVALID_ARG, 0, 0);

    PMC_RETURN(cpb_handle->var.cpb_connect_data->port_bulk_update_required[port_type][port_direction]);
}/*cpb_oduksw_port_bulk_update_req_get*/

/*******************************************************************************
* cpb_oduksw_port_bulk_update_req_init
* ______________________________________________________________________________
*
* DESCRIPTION:
*
*   This function initialize the update indication array to it's default value.
*
* INPUTS:
*   *cpb_handle         - pointer to CPB handle instance
*
* RETURNS:
*   none
*
* NOTES:
*
*******************************************************************************/
PUBLIC void cpb_oduksw_port_bulk_update_req_init(cpb_handle_t *cpb_handle)
{
    UINT8 port = 0;

    PMC_ENTRY();

    for(port = 0; port < UTIL_GLOBAL_ODUK_PORT_NOT_USED; port++)
    {
        cpb_handle->var.cpb_connect_data->port_bulk_update_required[port][UTIL_GLOBAL_DATAPATH_DIR_EGRESS] = FALSE;
        cpb_handle->var.cpb_connect_data->port_bulk_update_required[port][UTIL_GLOBAL_DATAPATH_DIR_INGRESS] = FALSE;
    }
    PMC_RETURN();
} /*cpb_oduksw_port_bulk_update_req_init*/


/*
 *  Register Access Operation Functions - End
 */


/*
** End of file
*/


