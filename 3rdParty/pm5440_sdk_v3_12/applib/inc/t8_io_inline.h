/******************************************************************************
 *   COPYRIGHT (C) 2013 PMC-SIERRA, INC. ALL RIGHTS RESERVED.
 * --------------------------------------------------------------------------
 *  This software embodies materials and concepts which are proprietary and
 *  confidential to PMC-Sierra, Inc.
 *  PMC-Sierra distributes this software to its customers pursuant to the
 *  terms and conditions of the Software License Agreement
 *  contained in the text file software.lic that is distributed along with
 *  the software. This software can only be utilized if all
 *  terms and conditions of the Software License Agreement are
 *  accepted. If there are any questions, concerns, or if the
 *  Software License Agreement text file, software.lic, is missing please
 *  contact PMC-Sierra for assistance.
 * -------------------------------------------------------------------------
 *   DESCRIPTION:
 *     contains the inline implementation of all the field accessor functions
 *     and register accessor functions for the t8 block
 *****************************************************************************/
#ifndef _T8_IO_INLINE_H
#define _T8_IO_INLINE_H

#include "t8.h"
#include "t8_regs.h"

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define T8_IO_VERSION 2

/*
 * ==================================================================================
 *  tsb level structure and access functions for t8
 * ==================================================================================
 */
/* if logging is disabled then so is IO_LOGGING */
#ifndef NO_IO_LOGGING
# ifdef LOGGING_DISABLED
#  define NO_IO_LOGGING
# endif
#endif

/* log messages in the generated files log the caller's file/line/function instead of itself.*/
#ifndef IOLOG
# ifdef NO_IO_LOGGING
#  define IOLOG(...)
# else
#  define IOLOG(...) LOG( __VA_ARGS__)
# endif
#endif
#ifndef IO_RANGE_CHECK
# ifdef NO_IO_LOGGING
#  define IO_RANGE_CHECK(...)
# else
#  define IO_RANGE_CHECK(...) LOG( "** range check ** " __VA_ARGS__)
# endif
#endif
#ifndef IOLOG_DATA
# ifdef NO_IO_LOGGING
#  define IOLOG_DATA(...)
# else
#  define IOLOG_DATA(...) LOG_DATA( __VA_ARGS__)
# endif
#endif
typedef struct {
    coalesce_buffer_t coalesce_handle[1]; /* only used if register coalescing is enabled */
    t8_handle_t * h_ptr;
    UINT32 id;
    pmc_sys_handle_t * sys_handle;
    PMC_VAR_CONST UINT32 base_address;
    /* maybe eventually need to add some fields here per io handle */
} t8_buffer_t;
static INLINE void t8_buffer_init( t8_buffer_t *b_ptr,
                                   t8_handle_t *h_ptr,
                                   UINT32 id ) ALWAYS_INLINE;
static INLINE void t8_buffer_init( t8_buffer_t *b_ptr,
                                   t8_handle_t *h_ptr,
                                   UINT32 id )
{
    b_ptr->h_ptr                    = h_ptr;
    b_ptr->id                       = id;
    b_ptr->sys_handle               = ((pmc_handle_t *)h_ptr)->sys_handle;
    *(UINT32 *)&b_ptr->base_address = (((pmc_handle_t *)h_ptr)->base_address + ((0)*0x600) );
    /* currently this just checks that the previous function remembered to flush. */
    l1sys_init( b_ptr->coalesce_handle, b_ptr->sys_handle );
    IOLOG( "%s id=%d", "t8_buffer_init", id);
    
}

/* flush any changed fields to the register file and invalidate the read cache. */
static INLINE void t8_buffer_flush( t8_buffer_t *b_ptr ) ALWAYS_INLINE;
static INLINE void t8_buffer_flush( t8_buffer_t *b_ptr )
{
    IOLOG( "t8_buffer_flush" );
    l1sys_flush( b_ptr->coalesce_handle );
}
static INLINE UINT32 t8_reg_read( t8_buffer_t *b_ptr,
                                  t8_handle_t *h_ptr,
                                  UINT32 id,
                                  UINT32 mem_type,
                                  UINT32 reg ) ALWAYS_INLINE;
static INLINE UINT32 t8_reg_read( t8_buffer_t *b_ptr,
                                  t8_handle_t *h_ptr,
                                  UINT32 id,
                                  UINT32 mem_type,
                                  UINT32 reg )
{
    UINT32 value;
    if (b_ptr != NULL)
        value = l1sys_reg_read( b_ptr->coalesce_handle,
                                mem_type,
                                (b_ptr->base_address + (b_ptr->id)*0x600),
                                reg);
    else
        value = l2sys_reg_read( ((pmc_handle_t *)h_ptr)->sys_handle,
                                mem_type,
                                (((pmc_handle_t *)h_ptr)->base_address + (id)*0x600) + reg);
    return value;
}
static INLINE void t8_reg_write( t8_buffer_t *b_ptr,
                                 t8_handle_t *h_ptr,
                                 UINT32 id,
                                 UINT32 mem_type,
                                 UINT32 reg,
                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_write( t8_buffer_t *b_ptr,
                                 t8_handle_t *h_ptr,
                                 UINT32 id,
                                 UINT32 mem_type,
                                 UINT32 reg,
                                 UINT32 value )
{
    if (b_ptr != NULL)
        l1sys_reg_write( b_ptr->coalesce_handle,
                         mem_type,
                         (b_ptr->base_address + (b_ptr->id)*0x600),
                         reg,
                         value);
    else
        l2sys_reg_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                         mem_type,
                         (((pmc_handle_t *)h_ptr)->base_address + (id)*0x600) + reg,
                         value);
}

static INLINE void t8_field_set( t8_buffer_t *b_ptr,
                                 t8_handle_t *h_ptr,
                                 UINT32 id,
                                 UINT32 mem_type,
                                 UINT32 reg,
                                 UINT32 mask,
                                 UINT32 unused_mask,
                                 UINT32 ofs,
                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_set( t8_buffer_t *b_ptr,
                                 t8_handle_t *h_ptr,
                                 UINT32 id,
                                 UINT32 mem_type,
                                 UINT32 reg,
                                 UINT32 mask,
                                 UINT32 unused_mask,
                                 UINT32 ofs,
                                 UINT32 value )
{
    if (b_ptr != NULL)
        l1sys_field_set2( b_ptr->coalesce_handle,
                          mem_type,
                          (b_ptr->base_address + (b_ptr->id)*0x600),
                          reg,
                          mask,
                          unused_mask,
                          ofs,
                          value);
    else
    {
        if ((mask | unused_mask) == 0xffffffff)
        {
            l2sys_reg_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                             mem_type,
                             (((pmc_handle_t *)h_ptr)->base_address + (id)*0x600) + reg,
                             value<<ofs);
        }
        else
        {
            l2sys_reg_read_modify_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                                         mem_type,
                                         (((pmc_handle_t *)h_ptr)->base_address + (id)*0x600) + reg,
                                         mask,
                                         value<<ofs);
        }
    }
}

static INLINE void t8_action_on_write_field_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 mem_type,
                                                 UINT32 reg,
                                                 UINT32 mask,
                                                 UINT32 ofs,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_action_on_write_field_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 mem_type,
                                                 UINT32 reg,
                                                 UINT32 mask,
                                                 UINT32 ofs,
                                                 UINT32 value )
{
    if (b_ptr != NULL)
        l1sys_action_on_write_field_set( b_ptr->coalesce_handle,
                                         mem_type,
                                         (b_ptr->base_address + (b_ptr->id)*0x600),
                                         reg,
                                         mask,
                                         ofs,
                                         value);
    else
        l2sys_reg_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                         mem_type,
                         (((pmc_handle_t *)h_ptr)->base_address + (id)*0x600) + reg,
                         value<<ofs);
}

static INLINE void t8_burst_read( t8_buffer_t *b_ptr,
                                  t8_handle_t *h_ptr,
                                  UINT32 id,
                                  UINT32 mem_type,
                                  UINT32 reg,
                                  UINT32 len,
                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void t8_burst_read( t8_buffer_t *b_ptr,
                                  t8_handle_t *h_ptr,
                                  UINT32 id,
                                  UINT32 mem_type,
                                  UINT32 reg,
                                  UINT32 len,
                                  UINT32 *value )
{
    if (b_ptr != NULL)
        l1sys_burst_read( b_ptr->coalesce_handle,
                          mem_type,
                          (b_ptr->base_address + (b_ptr->id)*0x600),
                          reg,
                          len,
                          value);
    else
        l2sys_burst_read( ((pmc_handle_t *)h_ptr)->sys_handle,
                          mem_type,
                          (((pmc_handle_t *)h_ptr)->base_address + (id)*0x600) + reg,
                          len,
                          value);
}

static INLINE void t8_burst_write( t8_buffer_t *b_ptr,
                                   t8_handle_t *h_ptr,
                                   UINT32 id,
                                   UINT32 mem_type,
                                   UINT32 reg,
                                   UINT32 len,
                                   UINT32 *value ) ALWAYS_INLINE;
static INLINE void t8_burst_write( t8_buffer_t *b_ptr,
                                   t8_handle_t *h_ptr,
                                   UINT32 id,
                                   UINT32 mem_type,
                                   UINT32 reg,
                                   UINT32 len,
                                   UINT32 *value )
{
    if (b_ptr != NULL)
        l1sys_burst_write( b_ptr->coalesce_handle,
                           mem_type,
                           (b_ptr->base_address + (b_ptr->id)*0x600),
                           reg,
                           len,
                           value);
    else
        l2sys_burst_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                           mem_type,
                           (((pmc_handle_t *)h_ptr)->base_address + (id)*0x600) + reg,
                           len,
                           value);
}

static INLINE PMC_POLL_RETURN_TYPE t8_poll( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 mem_type,
                                            UINT32 reg,
                                            UINT32 mask,
                                            UINT32 value,
                                            PMC_POLL_COMPARISON_TYPE cmp,
                                            UINT32 max_count,
                                            UINT32 *num_failed_polls,
                                            UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_poll( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 mem_type,
                                            UINT32 reg,
                                            UINT32 mask,
                                            UINT32 value,
                                            PMC_POLL_COMPARISON_TYPE cmp,
                                            UINT32 max_count,
                                            UINT32 *num_failed_polls,
                                            UINT32 delay_between_polls_in_microseconds )
{
    if (b_ptr != NULL)
        return l1sys_poll( b_ptr->coalesce_handle,
                           mem_type,
                           (b_ptr->base_address + (b_ptr->id)*0x600),
                           reg,
                           mask,
                           value,
                           cmp,
                           max_count,
                           num_failed_polls,
                           delay_between_polls_in_microseconds);
    else
        return l2sys_poll( ((pmc_handle_t *)h_ptr)->sys_handle,
                           mem_type,
                           (((pmc_handle_t *)h_ptr)->base_address + (id)*0x600) + reg,
                           mask,
                           value,
                           cmp,
                           max_count,
                           num_failed_polls,
                           delay_between_polls_in_microseconds);
}

/*
 * ==================================================================================
 *  register access functions for t8
 * ==================================================================================
 */

static INLINE void t8_reg_PCIE3_CFG_1_write( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PCIE3_CFG_1_write( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PCIE3_CFG_1_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PCIE3_CFG_1,
                  value);
}

static INLINE void t8_reg_PCIE3_CFG_1_field_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 mask,
                                                 UINT32 ofs,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PCIE3_CFG_1_field_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 mask,
                                                 UINT32 ofs,
                                                 UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PCIE3_CFG_1_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PCIE3_CFG_1,
                  mask,
                  PMC_PM20_82_24_REG_PCIE3_CFG_1_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PCIE3_CFG_1_read( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PCIE3_CFG_1_read( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PCIE3_CFG_1);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PCIE3_CFG_1_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PCIE3_CFG_2_write( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PCIE3_CFG_2_write( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PCIE3_CFG_2_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PCIE3_CFG_2,
                  value);
}

static INLINE void t8_reg_PCIE3_CFG_2_field_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 mask,
                                                 UINT32 ofs,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PCIE3_CFG_2_field_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 mask,
                                                 UINT32 ofs,
                                                 UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PCIE3_CFG_2_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PCIE3_CFG_2,
                  mask,
                  PMC_PM20_82_24_REG_PCIE3_CFG_2_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PCIE3_CFG_2_read( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PCIE3_CFG_2_read( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PCIE3_CFG_2);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PCIE3_CFG_2_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_TX_CNTR_CFG_1_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTR_CFG_1_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_TX_CNTR_CFG_1_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_1,
                  value);
}

static INLINE void t8_reg_TX_CNTR_CFG_1_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTR_CFG_1_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_TX_CNTR_CFG_1_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_1,
                  mask,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_1_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_TX_CNTR_CFG_1_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_TX_CNTR_CFG_1_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_TX_CNTR_CFG_1);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_TX_CNTR_CFG_1_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_TX_CNTR_CFG_2_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTR_CFG_2_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_TX_CNTR_CFG_2_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_2,
                  value);
}

static INLINE void t8_reg_TX_CNTR_CFG_2_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTR_CFG_2_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_TX_CNTR_CFG_2_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_2,
                  mask,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_2_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_TX_CNTR_CFG_2_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_TX_CNTR_CFG_2_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_TX_CNTR_CFG_2);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_TX_CNTR_CFG_2_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_TX_CNTR_CFG_3_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTR_CFG_3_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_TX_CNTR_CFG_3_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_3,
                  value);
}

static INLINE void t8_reg_TX_CNTR_CFG_3_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTR_CFG_3_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_TX_CNTR_CFG_3_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_3,
                  mask,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_3_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_TX_CNTR_CFG_3_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_TX_CNTR_CFG_3_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_TX_CNTR_CFG_3);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_TX_CNTR_CFG_3_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_TX_CNTR_CFG_4_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTR_CFG_4_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_TX_CNTR_CFG_4_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_4,
                  value);
}

static INLINE void t8_reg_TX_CNTR_CFG_4_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTR_CFG_4_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_TX_CNTR_CFG_4_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_4,
                  mask,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_4_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_TX_CNTR_CFG_4_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_TX_CNTR_CFG_4_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_TX_CNTR_CFG_4);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_TX_CNTR_CFG_4_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_TX_CNTR_CFG_5_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTR_CFG_5_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_TX_CNTR_CFG_5_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_5,
                  value);
}

static INLINE void t8_reg_TX_CNTR_CFG_5_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTR_CFG_5_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_TX_CNTR_CFG_5_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_5,
                  mask,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_5_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_TX_CNTR_CFG_5_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_TX_CNTR_CFG_5_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_TX_CNTR_CFG_5);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_TX_CNTR_CFG_5_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_TX_CNTR_CFG_6_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTR_CFG_6_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_TX_CNTR_CFG_6_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_6,
                  value);
}

static INLINE void t8_reg_TX_CNTR_CFG_6_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTR_CFG_6_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_TX_CNTR_CFG_6_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_6,
                  mask,
                  PMC_PM20_82_24_REG_TX_CNTR_CFG_6_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_TX_CNTR_CFG_6_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_TX_CNTR_CFG_6_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_TX_CNTR_CFG_6);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_TX_CNTR_CFG_6_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_DIG_LPBK_CFG_write( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_DIG_LPBK_CFG_write( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_DIG_LPBK_CFG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_DIG_LPBK_CFG,
                  value);
}

static INLINE void t8_reg_DIG_LPBK_CFG_field_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_DIG_LPBK_CFG_field_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_DIG_LPBK_CFG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_DIG_LPBK_CFG,
                  mask,
                  PMC_PM20_82_24_REG_DIG_LPBK_CFG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_DIG_LPBK_CFG_read( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_DIG_LPBK_CFG_read( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_DIG_LPBK_CFG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_DIG_LPBK_CFG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_ANALOG_SIPO_BIST_CFG_REG_write( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ANALOG_SIPO_BIST_CFG_REG_write( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_ANALOG_SIPO_BIST_CFG_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG,
                  value);
}

static INLINE void t8_reg_ANALOG_SIPO_BIST_CFG_REG_field_set( t8_buffer_t *b_ptr,
                                                              t8_handle_t *h_ptr,
                                                              UINT32 id,
                                                              UINT32 mask,
                                                              UINT32 ofs,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ANALOG_SIPO_BIST_CFG_REG_field_set( t8_buffer_t *b_ptr,
                                                              t8_handle_t *h_ptr,
                                                              UINT32 id,
                                                              UINT32 mask,
                                                              UINT32 ofs,
                                                              UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_ANALOG_SIPO_BIST_CFG_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG,
                  mask,
                  PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_ANALOG_SIPO_BIST_CFG_REG_read( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ANALOG_SIPO_BIST_CFG_REG_read( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ANALOG_SIPO_BIST_CFG_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_OFFSET_RAM_CFG_write( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_OFFSET_RAM_CFG_write( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_OFFSET_RAM_CFG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_OFFSET_RAM_CFG,
                  value);
}

static INLINE void t8_reg_OFFSET_RAM_CFG_field_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_OFFSET_RAM_CFG_field_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_OFFSET_RAM_CFG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_OFFSET_RAM_CFG,
                  mask,
                  PMC_PM20_82_24_REG_OFFSET_RAM_CFG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_OFFSET_RAM_CFG_read( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_OFFSET_RAM_CFG_read( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_OFFSET_RAM_CFG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_OFFSET_RAM_CFG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PLL_CNFG_REG1_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PLL_CNFG_REG1_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PLL_CNFG_REG1_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PLL_CNFG_REG1,
                  value);
}

static INLINE void t8_reg_PLL_CNFG_REG1_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PLL_CNFG_REG1_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PLL_CNFG_REG1_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PLL_CNFG_REG1,
                  mask,
                  PMC_PM20_82_24_REG_PLL_CNFG_REG1_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PLL_CNFG_REG1_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PLL_CNFG_REG1_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PLL_CNFG_REG1);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PLL_CNFG_REG1_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_ADC_OC_CFG_1_write( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ADC_OC_CFG_1_write( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_ADC_OC_CFG_1_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ADC_OC_CFG_1,
                  value);
}

static INLINE void t8_reg_ADC_OC_CFG_1_field_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ADC_OC_CFG_1_field_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_ADC_OC_CFG_1_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ADC_OC_CFG_1,
                  mask,
                  PMC_PM20_82_24_REG_ADC_OC_CFG_1_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_ADC_OC_CFG_1_read( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ADC_OC_CFG_1_read( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_ADC_OC_CFG_1);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ADC_OC_CFG_1_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_ADC_OC_CFG_2_write( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ADC_OC_CFG_2_write( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_ADC_OC_CFG_2_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ADC_OC_CFG_2,
                  value);
}

static INLINE void t8_reg_ADC_OC_CFG_2_field_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ADC_OC_CFG_2_field_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_ADC_OC_CFG_2_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ADC_OC_CFG_2,
                  mask,
                  PMC_PM20_82_24_REG_ADC_OC_CFG_2_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_ADC_OC_CFG_2_read( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ADC_OC_CFG_2_read( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_ADC_OC_CFG_2);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ADC_OC_CFG_2_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_ADC_OC_REGISTER3_write( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ADC_OC_REGISTER3_write( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_ADC_OC_REGISTER3_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ADC_OC_REGISTER3,
                  value);
}

static INLINE void t8_reg_ADC_OC_REGISTER3_field_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ADC_OC_REGISTER3_field_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_ADC_OC_REGISTER3_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ADC_OC_REGISTER3,
                  mask,
                  PMC_PM20_82_24_REG_ADC_OC_REGISTER3_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_ADC_OC_REGISTER3_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ADC_OC_REGISTER3_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_ADC_OC_REGISTER3);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ADC_OC_REGISTER3_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PMM_WRAP_CNFG_REG1_write( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PMM_WRAP_CNFG_REG1_write( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PMM_WRAP_CNFG_REG1_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG1,
                  value);
}

static INLINE void t8_reg_PMM_WRAP_CNFG_REG1_field_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PMM_WRAP_CNFG_REG1_field_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PMM_WRAP_CNFG_REG1_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG1,
                  mask,
                  PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG1_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PMM_WRAP_CNFG_REG1_read( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PMM_WRAP_CNFG_REG1_read( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG1);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PMM_WRAP_CNFG_REG1_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PMM_WRAP_CNFG_REG2_write( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PMM_WRAP_CNFG_REG2_write( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PMM_WRAP_CNFG_REG2_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2,
                  value);
}

static INLINE void t8_reg_PMM_WRAP_CNFG_REG2_field_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PMM_WRAP_CNFG_REG2_field_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PMM_WRAP_CNFG_REG2_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2,
                  mask,
                  PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PMM_WRAP_CNFG_REG2_read( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PMM_WRAP_CNFG_REG2_read( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PMM_WRAP_CNFG_REG2_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_SIPO_CNFG_REG_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_SIPO_CNFG_REG_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_SIPO_CNFG_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_SIPO_CNFG_REG,
                  value);
}

static INLINE void t8_reg_SIPO_CNFG_REG_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_SIPO_CNFG_REG_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_SIPO_CNFG_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_SIPO_CNFG_REG,
                  mask,
                  PMC_PM20_82_24_REG_SIPO_CNFG_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_SIPO_CNFG_REG_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_SIPO_CNFG_REG_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_SIPO_CNFG_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_SIPO_CNFG_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PISO_CNFG_REG_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PISO_CNFG_REG_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PISO_CNFG_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PISO_CNFG_REG,
                  value);
}

static INLINE void t8_reg_PISO_CNFG_REG_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PISO_CNFG_REG_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PISO_CNFG_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PISO_CNFG_REG,
                  mask,
                  PMC_PM20_82_24_REG_PISO_CNFG_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PISO_CNFG_REG_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PISO_CNFG_REG_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PISO_CNFG_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PISO_CNFG_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_TX_CNTRL_OVERRIDE_1_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTRL_OVERRIDE_1_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_TX_CNTRL_OVERRIDE_1_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_1,
                  value);
}

static INLINE void t8_reg_TX_CNTRL_OVERRIDE_1_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTRL_OVERRIDE_1_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_TX_CNTRL_OVERRIDE_1_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_1,
                  mask,
                  PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_TX_CNTRL_OVERRIDE_1_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_TX_CNTRL_OVERRIDE_1_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_1);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_TX_CNTRL_OVERRIDE_1_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_TX_CNTRL_OVERRIDE_REG_5_write( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTRL_OVERRIDE_REG_5_write( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_TX_CNTRL_OVERRIDE_REG_5_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_REG_5,
                  value);
}

static INLINE void t8_reg_TX_CNTRL_OVERRIDE_REG_5_field_set( t8_buffer_t *b_ptr,
                                                             t8_handle_t *h_ptr,
                                                             UINT32 id,
                                                             UINT32 mask,
                                                             UINT32 ofs,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTRL_OVERRIDE_REG_5_field_set( t8_buffer_t *b_ptr,
                                                             t8_handle_t *h_ptr,
                                                             UINT32 id,
                                                             UINT32 mask,
                                                             UINT32 ofs,
                                                             UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_TX_CNTRL_OVERRIDE_REG_5_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_REG_5,
                  mask,
                  PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_REG_5_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_TX_CNTRL_OVERRIDE_REG_5_read( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_TX_CNTRL_OVERRIDE_REG_5_read( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_REG_5);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_TX_CNTRL_OVERRIDE_REG_5_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_CLK_DIV_FACT_write( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_CLK_DIV_FACT_write( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_CLK_DIV_FACT_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_CLK_DIV_FACT,
                  value);
}

static INLINE void t8_reg_CLK_DIV_FACT_field_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_CLK_DIV_FACT_field_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_CLK_DIV_FACT_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_CLK_DIV_FACT,
                  mask,
                  PMC_PM20_82_24_REG_CLK_DIV_FACT_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_CLK_DIV_FACT_read( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_CLK_DIV_FACT_read( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_CLK_DIV_FACT);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_CLK_DIV_FACT_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_DEGLITCHER_EN_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_DEGLITCHER_EN_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_DEGLITCHER_EN_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_DEGLITCHER_EN,
                  value);
}

static INLINE void t8_reg_DEGLITCHER_EN_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_DEGLITCHER_EN_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_DEGLITCHER_EN_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_DEGLITCHER_EN,
                  mask,
                  PMC_PM20_82_24_REG_DEGLITCHER_EN_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_DEGLITCHER_EN_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_DEGLITCHER_EN_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_DEGLITCHER_EN);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_DEGLITCHER_EN_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_DIGITAL_RSTB_REG_write( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_DIGITAL_RSTB_REG_write( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_DIGITAL_RSTB_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_DIGITAL_RSTB_REG,
                  value);
}

static INLINE void t8_reg_DIGITAL_RSTB_REG_field_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_DIGITAL_RSTB_REG_field_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_DIGITAL_RSTB_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_DIGITAL_RSTB_REG,
                  mask,
                  PMC_PM20_82_24_REG_DIGITAL_RSTB_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_DIGITAL_RSTB_REG_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_DIGITAL_RSTB_REG_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_DIGITAL_RSTB_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_DIGITAL_RSTB_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_0_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_0_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_0_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_0_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_0_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_0_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_0_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_0_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_0_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_0_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_0_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_0_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_0_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_1_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_1_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_1_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_1_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_1_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_1_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_1_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_1_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_1_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_1_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_1_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_1_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_1_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_2_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_2_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_2_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_2_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_2_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_2_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_2_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_2_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_2_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_2_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_2_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_2_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_2_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_3_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_3_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_3_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_3_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_3_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_3_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_3_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_3_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_3_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_3_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_3_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_3_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_3_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_4_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_4_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_4_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_4_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_4_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_4_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_4_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_4_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_4_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_4_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_4_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_4_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_4_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_5_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_5_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_5_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_5_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_5_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_5_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_5_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_5_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_5_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_5_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_5_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_5_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_5_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_6_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_6_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_6_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_6_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_6_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_6_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_6_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_6_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_6_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_6_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_6_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_6_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_6_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_7_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_7_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_7_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_7_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_7_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_7_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_7_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_7_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_7_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_7_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_7_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_7_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_7_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_8_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_8_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_8_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_8_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_8_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_8_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_8_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_8_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_8_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_8_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_8_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_8_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_8_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_9_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_9_REG_write( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_9_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_9_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_9_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_9_REG_field_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_9_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_9_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_9_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_9_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_9_REG_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_9_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_9_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_10_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_10_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_10_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_10_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_10_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_10_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_10_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_10_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_10_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_10_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_10_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_10_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_10_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_11_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_11_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_11_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_11_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_11_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_11_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_11_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_11_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_11_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_11_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_11_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_11_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_11_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_12_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_12_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_12_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_12_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_12_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_12_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_12_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_12_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_12_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_12_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_12_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_12_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_12_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_13_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_13_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_13_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_13_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_13_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_13_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_13_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_13_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_13_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_13_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_13_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_13_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_13_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_14_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_14_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_14_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_14_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_14_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_14_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_14_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_14_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_14_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_14_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_14_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_14_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_14_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_15_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_15_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_15_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_15_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_15_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_15_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_15_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_15_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_15_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_15_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_15_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_15_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_15_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_16_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_16_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_16_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_16_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_16_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_16_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_16_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_16_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_16_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_16_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_16_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_16_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_16_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_17_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_17_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_17_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_17_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_17_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_17_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_17_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_17_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_17_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_17_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_17_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_17_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_17_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_18_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_18_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_18_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_18_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_18_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_18_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_18_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_18_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_18_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_18_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_18_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_18_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_18_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_19_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_19_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_19_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_19_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_19_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_19_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_19_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_19_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_19_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_19_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_19_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_19_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_19_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_20_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_20_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_20_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_20_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_20_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_20_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_20_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_20_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_20_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_20_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_20_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_20_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_20_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_21_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_21_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_21_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_21_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_21_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_21_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_21_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_21_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_21_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_21_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_21_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_21_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_21_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_22_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_22_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_22_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_22_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_22_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_22_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_22_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_22_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_22_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_22_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_22_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_22_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_22_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_23_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_23_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_23_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_23_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_23_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_23_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_23_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_23_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_23_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_23_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_23_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_23_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_23_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_24_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_24_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_24_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_24_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_24_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_24_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_24_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_24_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_24_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_24_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_24_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_24_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_24_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_25_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_25_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_25_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_25_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_25_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_25_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_25_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_25_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_25_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_25_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_25_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_25_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_25_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_26_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_26_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_26_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_26_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_26_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_26_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_26_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_26_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_26_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_26_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_26_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_26_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_26_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_27_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_27_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_27_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_27_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_27_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_27_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_27_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_27_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_27_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_27_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_27_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_27_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_27_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_28_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_28_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_28_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_28_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_28_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_28_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_28_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_28_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_28_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_28_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_28_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_28_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_28_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_29_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_29_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_29_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_29_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_29_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_29_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_29_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_29_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_29_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_29_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_29_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_29_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_29_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_30_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_30_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_30_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_30_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_30_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_30_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_30_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_30_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_30_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_30_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_30_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_30_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_30_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PRIM_LUT_INDEX_31_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_31_REG_write( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PRIM_LUT_INDEX_31_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_31_REG,
                  value);
}

static INLINE void t8_reg_PRIM_LUT_INDEX_31_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PRIM_LUT_INDEX_31_REG_field_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PRIM_LUT_INDEX_31_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_31_REG,
                  mask,
                  PMC_PM20_82_24_REG_PRIM_LUT_INDEX_31_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_31_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PRIM_LUT_INDEX_31_REG_read( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PRIM_LUT_INDEX_31_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PRIM_LUT_INDEX_31_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_ALT_LUT_INDEX_0_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_0_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_ALT_LUT_INDEX_0_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_0_REG,
                  value);
}

static INLINE void t8_reg_ALT_LUT_INDEX_0_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_0_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_ALT_LUT_INDEX_0_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_0_REG,
                  mask,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_0_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_ALT_LUT_INDEX_0_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ALT_LUT_INDEX_0_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_ALT_LUT_INDEX_0_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ALT_LUT_INDEX_0_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_ALT_LUT_INDEX_1_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_1_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_ALT_LUT_INDEX_1_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_1_REG,
                  value);
}

static INLINE void t8_reg_ALT_LUT_INDEX_1_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_1_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_ALT_LUT_INDEX_1_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_1_REG,
                  mask,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_1_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_ALT_LUT_INDEX_1_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ALT_LUT_INDEX_1_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_ALT_LUT_INDEX_1_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ALT_LUT_INDEX_1_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_ALT_LUT_INDEX_2_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_2_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_ALT_LUT_INDEX_2_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_2_REG,
                  value);
}

static INLINE void t8_reg_ALT_LUT_INDEX_2_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_2_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_ALT_LUT_INDEX_2_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_2_REG,
                  mask,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_2_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_ALT_LUT_INDEX_2_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ALT_LUT_INDEX_2_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_ALT_LUT_INDEX_2_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ALT_LUT_INDEX_2_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_ALT_LUT_INDEX_3_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_3_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_ALT_LUT_INDEX_3_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_3_REG,
                  value);
}

static INLINE void t8_reg_ALT_LUT_INDEX_3_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_3_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_ALT_LUT_INDEX_3_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_3_REG,
                  mask,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_3_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_ALT_LUT_INDEX_3_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ALT_LUT_INDEX_3_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_ALT_LUT_INDEX_3_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ALT_LUT_INDEX_3_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_ALT_LUT_INDEX_4_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_4_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_ALT_LUT_INDEX_4_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_4_REG,
                  value);
}

static INLINE void t8_reg_ALT_LUT_INDEX_4_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_4_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_ALT_LUT_INDEX_4_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_4_REG,
                  mask,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_4_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_ALT_LUT_INDEX_4_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ALT_LUT_INDEX_4_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_ALT_LUT_INDEX_4_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ALT_LUT_INDEX_4_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_ALT_LUT_INDEX_5_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_5_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_ALT_LUT_INDEX_5_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_5_REG,
                  value);
}

static INLINE void t8_reg_ALT_LUT_INDEX_5_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_5_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_ALT_LUT_INDEX_5_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_5_REG,
                  mask,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_5_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_ALT_LUT_INDEX_5_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ALT_LUT_INDEX_5_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_ALT_LUT_INDEX_5_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ALT_LUT_INDEX_5_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_ALT_LUT_INDEX_6_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_6_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_ALT_LUT_INDEX_6_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_6_REG,
                  value);
}

static INLINE void t8_reg_ALT_LUT_INDEX_6_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_6_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_ALT_LUT_INDEX_6_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_6_REG,
                  mask,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_6_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_ALT_LUT_INDEX_6_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ALT_LUT_INDEX_6_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_ALT_LUT_INDEX_6_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ALT_LUT_INDEX_6_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_ALT_LUT_INDEX_7_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_7_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_ALT_LUT_INDEX_7_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_7_REG,
                  value);
}

static INLINE void t8_reg_ALT_LUT_INDEX_7_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ALT_LUT_INDEX_7_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_ALT_LUT_INDEX_7_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_7_REG,
                  mask,
                  PMC_PM20_82_24_REG_ALT_LUT_INDEX_7_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_ALT_LUT_INDEX_7_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ALT_LUT_INDEX_7_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_ALT_LUT_INDEX_7_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ALT_LUT_INDEX_7_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PGA_LUT_CTRL_REG_write( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PGA_LUT_CTRL_REG_write( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PGA_LUT_CTRL_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG,
                  value);
}

static INLINE void t8_reg_PGA_LUT_CTRL_REG_field_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PGA_LUT_CTRL_REG_field_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PGA_LUT_CTRL_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG,
                  mask,
                  PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PGA_LUT_CTRL_REG_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PGA_LUT_CTRL_REG_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PGA_LUT_CTRL_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PLL_CNFG_REG2_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PLL_CNFG_REG2_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PLL_CNFG_REG2_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PLL_CNFG_REG2,
                  value);
}

static INLINE void t8_reg_PLL_CNFG_REG2_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PLL_CNFG_REG2_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PLL_CNFG_REG2_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PLL_CNFG_REG2,
                  mask,
                  PMC_PM20_82_24_REG_PLL_CNFG_REG2_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PLL_CNFG_REG2_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PLL_CNFG_REG2_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PLL_CNFG_REG2);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PLL_CNFG_REG2_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PLL_CNFG_REG4_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PLL_CNFG_REG4_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PLL_CNFG_REG4_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PLL_CNFG_REG4,
                  value);
}

static INLINE void t8_reg_PLL_CNFG_REG4_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PLL_CNFG_REG4_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PLL_CNFG_REG4_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PLL_CNFG_REG4,
                  mask,
                  PMC_PM20_82_24_REG_PLL_CNFG_REG4_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PLL_CNFG_REG4_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PLL_CNFG_REG4_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PLL_CNFG_REG4);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PLL_CNFG_REG4_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PLL_CNFG_REG6_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PLL_CNFG_REG6_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PLL_CNFG_REG6_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PLL_CNFG_REG6,
                  value);
}

static INLINE void t8_reg_PLL_CNFG_REG6_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PLL_CNFG_REG6_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PLL_CNFG_REG6_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PLL_CNFG_REG6,
                  mask,
                  PMC_PM20_82_24_REG_PLL_CNFG_REG6_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PLL_CNFG_REG6_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PLL_CNFG_REG6_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PLL_CNFG_REG6);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PLL_CNFG_REG6_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_MDSP_CFG_REG1_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_MDSP_CFG_REG1_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_MDSP_CFG_REG1_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_MDSP_CFG_REG1,
                  value);
}

static INLINE void t8_reg_MDSP_CFG_REG1_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_MDSP_CFG_REG1_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_MDSP_CFG_REG1_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_MDSP_CFG_REG1,
                  mask,
                  PMC_PM20_82_24_REG_MDSP_CFG_REG1_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_MDSP_CFG_REG1_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_MDSP_CFG_REG1_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_MDSP_CFG_REG1);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_MDSP_CFG_REG1_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_MDSP_CFG_REG2_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_MDSP_CFG_REG2_write( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_MDSP_CFG_REG2_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_MDSP_CFG_REG2,
                  value);
}

static INLINE void t8_reg_MDSP_CFG_REG2_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_MDSP_CFG_REG2_field_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 mask,
                                                   UINT32 ofs,
                                                   UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_MDSP_CFG_REG2_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_MDSP_CFG_REG2,
                  mask,
                  PMC_PM20_82_24_REG_MDSP_CFG_REG2_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_MDSP_CFG_REG2_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_MDSP_CFG_REG2_read( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_MDSP_CFG_REG2);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_MDSP_CFG_REG2_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PGA_CFG_REG_write( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PGA_CFG_REG_write( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PGA_CFG_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PGA_CFG_REG,
                  value);
}

static INLINE void t8_reg_PGA_CFG_REG_field_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 mask,
                                                 UINT32 ofs,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PGA_CFG_REG_field_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 mask,
                                                 UINT32 ofs,
                                                 UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PGA_CFG_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PGA_CFG_REG,
                  mask,
                  PMC_PM20_82_24_REG_PGA_CFG_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PGA_CFG_REG_read( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PGA_CFG_REG_read( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PGA_CFG_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PGA_CFG_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_DIAG_CNFG_REG1_write( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_DIAG_CNFG_REG1_write( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_DIAG_CNFG_REG1_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_DIAG_CNFG_REG1,
                  value);
}

static INLINE void t8_reg_DIAG_CNFG_REG1_field_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_DIAG_CNFG_REG1_field_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_DIAG_CNFG_REG1_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_DIAG_CNFG_REG1,
                  mask,
                  PMC_PM20_82_24_REG_DIAG_CNFG_REG1_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_DIAG_CNFG_REG1_read( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_DIAG_CNFG_REG1_read( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_DIAG_CNFG_REG1);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_DIAG_CNFG_REG1_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_DIAG_CNFG_REG2_write( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_DIAG_CNFG_REG2_write( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_DIAG_CNFG_REG2_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_DIAG_CNFG_REG2,
                  value);
}

static INLINE void t8_reg_DIAG_CNFG_REG2_field_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_DIAG_CNFG_REG2_field_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_DIAG_CNFG_REG2_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_DIAG_CNFG_REG2,
                  mask,
                  PMC_PM20_82_24_REG_DIAG_CNFG_REG2_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_DIAG_CNFG_REG2_read( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_DIAG_CNFG_REG2_read( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_DIAG_CNFG_REG2);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_DIAG_CNFG_REG2_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_OFFSET_RAM_CNFG_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_OFFSET_RAM_CNFG_REG_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_OFFSET_RAM_CNFG_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_OFFSET_RAM_CNFG_REG,
                  value);
}

static INLINE void t8_reg_OFFSET_RAM_CNFG_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_OFFSET_RAM_CNFG_REG_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_OFFSET_RAM_CNFG_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_OFFSET_RAM_CNFG_REG,
                  mask,
                  PMC_PM20_82_24_REG_OFFSET_RAM_CNFG_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_OFFSET_RAM_CNFG_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_OFFSET_RAM_CNFG_REG_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_OFFSET_RAM_CNFG_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_OFFSET_RAM_CNFG_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_DIG_LPBK_CTRL_REG_write( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_DIG_LPBK_CTRL_REG_write( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_DIG_LPBK_CTRL_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG,
                  value);
}

static INLINE void t8_reg_DIG_LPBK_CTRL_REG_field_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 mask,
                                                       UINT32 ofs,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_DIG_LPBK_CTRL_REG_field_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 mask,
                                                       UINT32 ofs,
                                                       UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_DIG_LPBK_CTRL_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG,
                  mask,
                  PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_DIG_LPBK_CTRL_REG_read( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_DIG_LPBK_CTRL_REG_read( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_DIG_LPBK_CTRL_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_ADC_OC_REGISTER4_write( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ADC_OC_REGISTER4_write( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_ADC_OC_REGISTER4_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ADC_OC_REGISTER4,
                  value);
}

static INLINE void t8_reg_ADC_OC_REGISTER4_field_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ADC_OC_REGISTER4_field_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_ADC_OC_REGISTER4_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ADC_OC_REGISTER4,
                  mask,
                  PMC_PM20_82_24_REG_ADC_OC_REGISTER4_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_ADC_OC_REGISTER4_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ADC_OC_REGISTER4_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_ADC_OC_REGISTER4);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ADC_OC_REGISTER4_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_ADC_OC_REGISTER5_write( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ADC_OC_REGISTER5_write( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_ADC_OC_REGISTER5_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ADC_OC_REGISTER5,
                  value);
}

static INLINE void t8_reg_ADC_OC_REGISTER5_field_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_ADC_OC_REGISTER5_field_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_ADC_OC_REGISTER5_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_ADC_OC_REGISTER5,
                  mask,
                  PMC_PM20_82_24_REG_ADC_OC_REGISTER5_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_ADC_OC_REGISTER5_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ADC_OC_REGISTER5_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_ADC_OC_REGISTER5);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ADC_OC_REGISTER5_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_GCOC_MABC_CFG_REG_write( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_GCOC_MABC_CFG_REG_write( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_GCOC_MABC_CFG_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_GCOC_MABC_CFG_REG,
                  value);
}

static INLINE void t8_reg_GCOC_MABC_CFG_REG_field_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 mask,
                                                       UINT32 ofs,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_GCOC_MABC_CFG_REG_field_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 mask,
                                                       UINT32 ofs,
                                                       UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_GCOC_MABC_CFG_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_GCOC_MABC_CFG_REG,
                  mask,
                  PMC_PM20_82_24_REG_GCOC_MABC_CFG_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_GCOC_MABC_CFG_REG_read( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_GCOC_MABC_CFG_REG_read( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_GCOC_MABC_CFG_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_GCOC_MABC_CFG_REG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_DLOS_CFG_write( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_DLOS_CFG_write( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_DLOS_CFG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_DLOS_CFG,
                  value);
}

static INLINE void t8_reg_DLOS_CFG_field_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 mask,
                                              UINT32 ofs,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_DLOS_CFG_field_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 mask,
                                              UINT32 ofs,
                                              UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_DLOS_CFG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_DLOS_CFG,
                  mask,
                  PMC_PM20_82_24_REG_DLOS_CFG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_DLOS_CFG_read( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_DLOS_CFG_read( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_DLOS_CFG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_DLOS_CFG_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PATT_GEN_CNFG_REG1_write( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PATT_GEN_CNFG_REG1_write( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PATT_GEN_CNFG_REG1_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1,
                  value);
}

static INLINE void t8_reg_PATT_GEN_CNFG_REG1_field_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PATT_GEN_CNFG_REG1_field_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PATT_GEN_CNFG_REG1_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1,
                  mask,
                  PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PATT_GEN_CNFG_REG1_read( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PATT_GEN_CNFG_REG1_read( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PATT_GEN_CNFG_REG1_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PATT_GEN_CNFG_REG2_write( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PATT_GEN_CNFG_REG2_write( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PATT_GEN_CNFG_REG2_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG2,
                  value);
}

static INLINE void t8_reg_PATT_GEN_CNFG_REG2_field_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PATT_GEN_CNFG_REG2_field_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PATT_GEN_CNFG_REG2_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG2,
                  mask,
                  PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG2_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PATT_GEN_CNFG_REG2_read( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PATT_GEN_CNFG_REG2_read( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG2);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PATT_GEN_CNFG_REG2_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PATT_CHK_CNFG_REG1_write( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PATT_CHK_CNFG_REG1_write( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PATT_CHK_CNFG_REG1_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1,
                  value);
}

static INLINE void t8_reg_PATT_CHK_CNFG_REG1_field_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PATT_CHK_CNFG_REG1_field_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PATT_CHK_CNFG_REG1_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1,
                  mask,
                  PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PATT_CHK_CNFG_REG1_read( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PATT_CHK_CNFG_REG1_read( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PATT_CHK_CNFG_REG1_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_PATT_CHK_CNFG_REG2_write( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PATT_CHK_CNFG_REG2_write( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_PATT_CHK_CNFG_REG2_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG2,
                  value);
}

static INLINE void t8_reg_PATT_CHK_CNFG_REG2_field_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PATT_CHK_CNFG_REG2_field_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PATT_CHK_CNFG_REG2_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG2,
                  mask,
                  PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG2_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_PATT_CHK_CNFG_REG2_read( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PATT_CHK_CNFG_REG2_read( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG2);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PATT_CHK_CNFG_REG2_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_TX_CNTRL_OVERRIDE_5_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTRL_OVERRIDE_5_write( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_TX_CNTRL_OVERRIDE_5_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_5,
                  value);
}

static INLINE void t8_reg_TX_CNTRL_OVERRIDE_5_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_TX_CNTRL_OVERRIDE_5_field_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_TX_CNTRL_OVERRIDE_5_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_CONFIG,
                  PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_5,
                  mask,
                  PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_5_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_TX_CNTRL_OVERRIDE_5_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_TX_CNTRL_OVERRIDE_5_read( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_CONFIG,
                             PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_5);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_TX_CNTRL_OVERRIDE_5_read", reg_value, id);
    return reg_value;
}

static INLINE void t8_reg_INT_REG_write( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id,
                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_INT_REG_write( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id,
                                         UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_INT_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_STATUS,
                  PMC_PM20_82_24_REG_INT_REG,
                  value);
}

static INLINE void t8_reg_INT_REG_action_on_write_field_set( t8_buffer_t *b_ptr,
                                                             t8_handle_t *h_ptr,
                                                             UINT32 id,
                                                             UINT32 mask,
                                                             UINT32 ofs,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_INT_REG_action_on_write_field_set( t8_buffer_t *b_ptr,
                                                             t8_handle_t *h_ptr,
                                                             UINT32 id,
                                                             UINT32 mask,
                                                             UINT32 ofs,
                                                             UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_INT_REG_action_on_write_field_set", id, mask, ofs, value );
    t8_action_on_write_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  MEM_TYPE_STATUS,
                                  PMC_PM20_82_24_REG_INT_REG,
                                  mask,
                                  ofs,
                                  value);

}

static INLINE UINT32 t8_reg_INT_REG_read( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_INT_REG_read( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_STATUS,
                             PMC_PM20_82_24_REG_INT_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_INT_REG_read", reg_value, id);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_reg_INT_REG_poll( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 mask,
                                                        UINT32 value,
                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                        UINT32 max_count,
                                                        UINT32 *num_failed_polls,
                                                        UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_reg_INT_REG_poll( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 mask,
                                                        UINT32 value,
                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                        UINT32 max_count,
                                                        UINT32 *num_failed_polls,
                                                        UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "t8_reg_INT_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return t8_poll( b_ptr,
                    h_ptr,
                    id,
                    MEM_TYPE_STATUS,
                    PMC_PM20_82_24_REG_INT_REG,
                    mask,
                    value,
                    cmp,
                    max_count,
                    num_failed_polls,
                    delay_between_polls_in_microseconds);

}


static INLINE void t8_reg_IE_REG_write( t8_buffer_t *b_ptr,
                                        t8_handle_t *h_ptr,
                                        UINT32 id,
                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_IE_REG_write( t8_buffer_t *b_ptr,
                                        t8_handle_t *h_ptr,
                                        UINT32 id,
                                        UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "t8_reg_IE_REG_write", value );
    t8_reg_write( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_STATUS,
                  PMC_PM20_82_24_REG_IE_REG,
                  value);
}

static INLINE void t8_reg_IE_REG_field_set( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 mask,
                                            UINT32 ofs,
                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_IE_REG_field_set( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 mask,
                                            UINT32 ofs,
                                            UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_IE_REG_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_STATUS,
                  PMC_PM20_82_24_REG_IE_REG,
                  mask,
                  PMC_PM20_82_24_REG_IE_REG_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE UINT32 t8_reg_IE_REG_read( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_IE_REG_read( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_STATUS,
                             PMC_PM20_82_24_REG_IE_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_IE_REG_read", reg_value, id);
    return reg_value;
}

static INLINE UINT32 t8_reg_IV_REG_read( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_IV_REG_read( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_STATUS,
                             PMC_PM20_82_24_REG_IV_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_IV_REG_read", reg_value, id);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_reg_IV_REG_poll( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 mask,
                                                       UINT32 value,
                                                       PMC_POLL_COMPARISON_TYPE cmp,
                                                       UINT32 max_count,
                                                       UINT32 *num_failed_polls,
                                                       UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_reg_IV_REG_poll( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 mask,
                                                       UINT32 value,
                                                       PMC_POLL_COMPARISON_TYPE cmp,
                                                       UINT32 max_count,
                                                       UINT32 *num_failed_polls,
                                                       UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "t8_reg_IV_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return t8_poll( b_ptr,
                    h_ptr,
                    id,
                    MEM_TYPE_STATUS,
                    PMC_PM20_82_24_REG_IV_REG,
                    mask,
                    value,
                    cmp,
                    max_count,
                    num_failed_polls,
                    delay_between_polls_in_microseconds);

}


static INLINE void t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_burst_write( t8_buffer_t *b_ptr,
                                                                        t8_handle_t *h_ptr,
                                                                        UINT32 id,
                                                                        UINT32 ofs,
                                                                        UINT32 len,
                                                                        UINT32 *value ) ALWAYS_INLINE;
static INLINE void t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_burst_write( t8_buffer_t *b_ptr,
                                                                        t8_handle_t *h_ptr,
                                                                        UINT32 id,
                                                                        UINT32 ofs,
                                                                        UINT32 len,
                                                                        UINT32 *value )
{
    if (len + ofs > 96)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_burst_write", ofs, len, 96 );
    IOLOG( "%s of %d words id=%d ofs=%d len=%d", "t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_burst_write", 96, id, ofs, len);
    t8_burst_write( b_ptr,
                    h_ptr,
                    id,
                    MEM_TYPE_STATUS,
                    PMC_PM20_82_24_REG_PM20_82_24_OFFSET_RAM_REG0(ofs),
                    len,
                    value);

}

static INLINE void t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_field_set( t8_buffer_t *b_ptr,
                                                                      t8_handle_t *h_ptr,
                                                                      UINT32 id,
                                                                      UINT32 N,
                                                                      UINT32 mask,
                                                                      UINT32 ofs,
                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_field_set( t8_buffer_t *b_ptr,
                                                                      t8_handle_t *h_ptr,
                                                                      UINT32 id,
                                                                      UINT32 N,
                                                                      UINT32 mask,
                                                                      UINT32 ofs,
                                                                      UINT32 value )
{
    IOLOG( "%s <- id=%d mask=0x%08x ofs=%d value=0x%08x", "t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_field_set", id, mask, ofs, value );
    t8_field_set( b_ptr,
                  h_ptr,
                  id,
                  MEM_TYPE_STATUS,
                  PMC_PM20_82_24_REG_PM20_82_24_OFFSET_RAM_REG0(N),
                  mask,
                  PMC_PM20_82_24_REG_PM20_82_24_OFFSET_RAM_REG0_UNUSED_MASK,
                  ofs,
                  value);

}

static INLINE void t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_burst_read( t8_buffer_t *b_ptr,
                                                                       t8_handle_t *h_ptr,
                                                                       UINT32 id,
                                                                       UINT32 ofs,
                                                                       UINT32 len,
                                                                       UINT32 *value ) ALWAYS_INLINE;
static INLINE void t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_burst_read( t8_buffer_t *b_ptr,
                                                                       t8_handle_t *h_ptr,
                                                                       UINT32 id,
                                                                       UINT32 ofs,
                                                                       UINT32 len,
                                                                       UINT32 *value )
{
    if (len + ofs > 96)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_burst_read", ofs, len, 96 );
    t8_burst_read( b_ptr,
                   h_ptr,
                   id,
                   MEM_TYPE_STATUS,
                   PMC_PM20_82_24_REG_PM20_82_24_OFFSET_RAM_REG0(ofs),
                   len,
                   value);

    IOLOG( "%s of %d words id=%d ofs=%d len=%d", "t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_burst_read", 96, id, ofs, len);
}

static INLINE UINT32 t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_read( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_read( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 N )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_STATUS,
                             PMC_PM20_82_24_REG_PM20_82_24_OFFSET_RAM_REG0(N));

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_read", reg_value, id);
    return reg_value;
}

static INLINE UINT32 t8_reg_ANALOG_SIPO_BIST_STATUS_REG_read( t8_buffer_t *b_ptr,
                                                              t8_handle_t *h_ptr,
                                                              UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ANALOG_SIPO_BIST_STATUS_REG_read( t8_buffer_t *b_ptr,
                                                              t8_handle_t *h_ptr,
                                                              UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_STATUS,
                             PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_STATUS_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ANALOG_SIPO_BIST_STATUS_REG_read", reg_value, id);
    return reg_value;
}

static INLINE UINT32 t8_reg_TX_CNTR_STA_read( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_TX_CNTR_STA_read( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_STATUS,
                             PMC_PM20_82_24_REG_TX_CNTR_STA);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_TX_CNTR_STA_read", reg_value, id);
    return reg_value;
}

static INLINE UINT32 t8_reg_ADC_OC_STS_read( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_ADC_OC_STS_read( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_STATUS,
                             PMC_PM20_82_24_REG_ADC_OC_STS);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_ADC_OC_STS_read", reg_value, id);
    return reg_value;
}

static INLINE UINT32 t8_reg_TX_CTRL_STS_REG1_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_TX_CTRL_STS_REG1_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_STATUS,
                             PMC_PM20_82_24_REG_TX_CTRL_STS_REG1);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_TX_CTRL_STS_REG1_read", reg_value, id);
    return reg_value;
}

static INLINE UINT32 t8_reg_PLL_STS_REG_read( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PLL_STS_REG_read( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_STATUS,
                             PMC_PM20_82_24_REG_PLL_STS_REG);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PLL_STS_REG_read", reg_value, id);
    return reg_value;
}

static INLINE UINT32 t8_reg_DIAG_STATUS_REG1_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_DIAG_STATUS_REG1_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_STATUS,
                             PMC_PM20_82_24_REG_DIAG_STATUS_REG1);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_DIAG_STATUS_REG1_read", reg_value, id);
    return reg_value;
}

static INLINE UINT32 t8_reg_DIAG_STATUS_REG2_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_DIAG_STATUS_REG2_read( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_STATUS,
                             PMC_PM20_82_24_REG_DIAG_STATUS_REG2);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_DIAG_STATUS_REG2_read", reg_value, id);
    return reg_value;
}

static INLINE UINT32 t8_reg_PATT_CHK_STATUS_REG1_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_reg_PATT_CHK_STATUS_REG1_read( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 reg_value;

    reg_value = t8_reg_read( b_ptr,
                             h_ptr,
                             id,
                             MEM_TYPE_STATUS,
                             PMC_PM20_82_24_REG_PATT_CHK_STATUS_REG1);

    IOLOG( "%s -> 0x%08x; id=%d", "t8_reg_PATT_CHK_STATUS_REG1_read", reg_value, id);
    return reg_value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset config
 * ==================================================================================
 */
static INLINE void t8_field_TXRXCS_ATMSB_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TXRXCS_ATMSB_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TXRXCS_ATMSB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TXRXCS_ATMSB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TXRXCS_ATMSB_set", id, value );

    /* (0x00000000 bits 26) field TXRXCS_ATMSB of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    t8_reg_PCIE3_CFG_1_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_ATMSB_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_ATMSB_OFF,
                                  value);
}

static INLINE UINT32 t8_field_TXRXCS_ATMSB_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TXRXCS_ATMSB_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TXRXCS_ATMSB_get", id, 2);
    /* (0x00000000 bits 26) field TXRXCS_ATMSB of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    reg_value = t8_reg_PCIE3_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_ATMSB_MSK) >> PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_ATMSB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TXRXCS_ATMSB_get", id, value );

    return value;
}
static INLINE void t8_field_TXRXCS_MODE_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TXRXCS_MODE_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TXRXCS_MODE_set", id, 2);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TXRXCS_MODE_set", value, 15);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TXRXCS_MODE_set", id, value );

    /* (0x00000000 bits 25:22) bits 0:3 use field TXRXCS_MODE of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    t8_reg_PCIE3_CFG_1_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_MODE_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_MODE_OFF,
                                  value);
}

static INLINE UINT32 t8_field_TXRXCS_MODE_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TXRXCS_MODE_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TXRXCS_MODE_get", id, 2);
    /* (0x00000000 bits 25:22) bits 0:3 use field TXRXCS_MODE of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    reg_value = t8_reg_PCIE3_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_MODE_MSK) >> PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_MODE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TXRXCS_MODE_get", id, value );

    return value;
}
static INLINE void t8_field_range_TXRXCS_MODE_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_TXRXCS_MODE_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_TXRXCS_MODE_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_TXRXCS_MODE_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_TXRXCS_MODE_set", stop_bit, 3 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_TXRXCS_MODE_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000000 bits 25:22) bits 0:3 use field TXRXCS_MODE of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000000 bits 25:22) bits 0:3 use field TXRXCS_MODE of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
        t8_reg_PCIE3_CFG_1_field_set( b_ptr,
                                      h_ptr,
                                      id,
                                      subfield_mask << (PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_MODE_OFF + subfield_offset),
                                      PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_MODE_OFF + subfield_offset,
                                      value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_TXRXCS_MODE_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_TXRXCS_MODE_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_TXRXCS_MODE_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_TXRXCS_MODE_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_TXRXCS_MODE_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000000 bits 25:22) bits 0:3 use field TXRXCS_MODE of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    reg_value = t8_reg_PCIE3_CFG_1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_MODE_MSK)
                  >> PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_MODE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_MODE_MSK, PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_MODE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_TXRXCS_MODE_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_TXRXCS_CTRL_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TXRXCS_CTRL_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TXRXCS_CTRL_set", id, 2);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TXRXCS_CTRL_set", value, 15);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TXRXCS_CTRL_set", id, value );

    /* (0x00000000 bits 21:18) bits 0:3 use field TXRXCS_CTRL of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    t8_reg_PCIE3_CFG_1_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_CTRL_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_CTRL_OFF,
                                  value);
}

static INLINE UINT32 t8_field_TXRXCS_CTRL_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TXRXCS_CTRL_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TXRXCS_CTRL_get", id, 2);
    /* (0x00000000 bits 21:18) bits 0:3 use field TXRXCS_CTRL of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    reg_value = t8_reg_PCIE3_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_CTRL_MSK) >> PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_CTRL_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TXRXCS_CTRL_get", id, value );

    return value;
}
static INLINE void t8_field_range_TXRXCS_CTRL_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_TXRXCS_CTRL_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_TXRXCS_CTRL_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_TXRXCS_CTRL_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_TXRXCS_CTRL_set", stop_bit, 3 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_TXRXCS_CTRL_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000000 bits 21:18) bits 0:3 use field TXRXCS_CTRL of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000000 bits 21:18) bits 0:3 use field TXRXCS_CTRL of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
        t8_reg_PCIE3_CFG_1_field_set( b_ptr,
                                      h_ptr,
                                      id,
                                      subfield_mask << (PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_CTRL_OFF + subfield_offset),
                                      PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_CTRL_OFF + subfield_offset,
                                      value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_TXRXCS_CTRL_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_TXRXCS_CTRL_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_TXRXCS_CTRL_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_TXRXCS_CTRL_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_TXRXCS_CTRL_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000000 bits 21:18) bits 0:3 use field TXRXCS_CTRL of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    reg_value = t8_reg_PCIE3_CFG_1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_CTRL_MSK)
                  >> PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_CTRL_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_CTRL_MSK, PM20_82_24_REG_PCIE3_CFG_1_BIT_TXRXCS_CTRL_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_TXRXCS_CTRL_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PISO_ATMSB_set( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PISO_ATMSB_set( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_ATMSB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PISO_ATMSB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PISO_ATMSB_set", id, value );

    /* (0x00000000 bits 17) field PISO_ATMSB of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    t8_reg_PCIE3_CFG_1_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_ATMSB_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_ATMSB_OFF,
                                  value);
}

static INLINE UINT32 t8_field_PISO_ATMSB_get( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PISO_ATMSB_get( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_ATMSB_get", id, 2);
    /* (0x00000000 bits 17) field PISO_ATMSB of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    reg_value = t8_reg_PCIE3_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_ATMSB_MSK) >> PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_ATMSB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PISO_ATMSB_get", id, value );

    return value;
}
static INLINE void t8_field_PISO_ALTPAT_EN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PISO_ALTPAT_EN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_ALTPAT_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PISO_ALTPAT_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PISO_ALTPAT_EN_set", id, value );

    /* (0x00000000 bits 10) field PISO_ALTPAT_EN of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    t8_reg_PCIE3_CFG_1_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_ALTPAT_EN_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_ALTPAT_EN_OFF,
                                  value);
}

static INLINE UINT32 t8_field_PISO_ALTPAT_EN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PISO_ALTPAT_EN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_ALTPAT_EN_get", id, 2);
    /* (0x00000000 bits 10) field PISO_ALTPAT_EN of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    reg_value = t8_reg_PCIE3_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_ALTPAT_EN_MSK) >> PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_ALTPAT_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PISO_ALTPAT_EN_get", id, value );

    return value;
}
static INLINE void t8_field_PISO_ENB_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PISO_ENB_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_ENB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PISO_ENB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PISO_ENB_set", id, value );

    /* (0x00000000 bits 9) field PISO_ENB of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    t8_reg_PCIE3_CFG_1_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_ENB_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_ENB_OFF,
                                  value);
}

static INLINE UINT32 t8_field_PISO_ENB_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PISO_ENB_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_ENB_get", id, 2);
    /* (0x00000000 bits 9) field PISO_ENB of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    reg_value = t8_reg_PCIE3_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_ENB_MSK) >> PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_ENB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PISO_ENB_get", id, value );

    return value;
}
static INLINE void t8_field_PISO_DLB_EN_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PISO_DLB_EN_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_DLB_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PISO_DLB_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PISO_DLB_EN_set", id, value );

    /* (0x00000000 bits 0) field PISO_DLB_EN of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    t8_reg_PCIE3_CFG_1_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_DLB_EN_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_DLB_EN_OFF,
                                  value);
}

static INLINE UINT32 t8_field_PISO_DLB_EN_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PISO_DLB_EN_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_DLB_EN_get", id, 2);
    /* (0x00000000 bits 0) field PISO_DLB_EN of register PMC_PM20_82_24_REG_PCIE3_CFG_1 */
    reg_value = t8_reg_PCIE3_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_DLB_EN_MSK) >> PM20_82_24_REG_PCIE3_CFG_1_BIT_PISO_DLB_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PISO_DLB_EN_get", id, value );

    return value;
}
static INLINE void t8_field_BADJ_ENB_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_BADJ_ENB_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_BADJ_ENB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_BADJ_ENB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_BADJ_ENB_set", id, value );

    /* (0x00000004 bits 25) field BADJ_ENB of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    t8_reg_PCIE3_CFG_2_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_BADJ_ENB_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_BADJ_ENB_OFF,
                                  value);
}

static INLINE UINT32 t8_field_BADJ_ENB_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_BADJ_ENB_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_BADJ_ENB_get", id, 2);
    /* (0x00000004 bits 25) field BADJ_ENB of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    reg_value = t8_reg_PCIE3_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_2_BIT_BADJ_ENB_MSK) >> PM20_82_24_REG_PCIE3_CFG_2_BIT_BADJ_ENB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_BADJ_ENB_get", id, value );

    return value;
}
static INLINE void t8_field_TX_TEST_SEL_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TX_TEST_SEL_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_TEST_SEL_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TX_TEST_SEL_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TX_TEST_SEL_set", id, value );

    /* (0x00000004 bits 24) field TX_TEST_SEL of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    t8_reg_PCIE3_CFG_2_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_TX_TEST_SEL_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_TX_TEST_SEL_OFF,
                                  value);
}

static INLINE UINT32 t8_field_TX_TEST_SEL_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TX_TEST_SEL_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_TEST_SEL_get", id, 2);
    /* (0x00000004 bits 24) field TX_TEST_SEL of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    reg_value = t8_reg_PCIE3_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_2_BIT_TX_TEST_SEL_MSK) >> PM20_82_24_REG_PCIE3_CFG_2_BIT_TX_TEST_SEL_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TX_TEST_SEL_get", id, value );

    return value;
}
static INLINE void t8_field_TX_TEST_EN_set( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TX_TEST_EN_set( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_TEST_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TX_TEST_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TX_TEST_EN_set", id, value );

    /* (0x00000004 bits 23) field TX_TEST_EN of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    t8_reg_PCIE3_CFG_2_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_TX_TEST_EN_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_TX_TEST_EN_OFF,
                                  value);
}

static INLINE UINT32 t8_field_TX_TEST_EN_get( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TX_TEST_EN_get( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_TEST_EN_get", id, 2);
    /* (0x00000004 bits 23) field TX_TEST_EN of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    reg_value = t8_reg_PCIE3_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_2_BIT_TX_TEST_EN_MSK) >> PM20_82_24_REG_PCIE3_CFG_2_BIT_TX_TEST_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TX_TEST_EN_get", id, value );

    return value;
}
static INLINE void t8_field_ADC_ENB_set( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id,
                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADC_ENB_set( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id,
                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_ENB_set", id, 2);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADC_ENB_set", value, 7);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADC_ENB_set", id, value );

    /* (0x00000004 bits 22:20) bits 0:2 use field ADC_ENB of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    t8_reg_PCIE3_CFG_2_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_ENB_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_ENB_OFF,
                                  value);
}

static INLINE UINT32 t8_field_ADC_ENB_get( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADC_ENB_get( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_ENB_get", id, 2);
    /* (0x00000004 bits 22:20) bits 0:2 use field ADC_ENB of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    reg_value = t8_reg_PCIE3_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_ENB_MSK) >> PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_ENB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADC_ENB_get", id, value );

    return value;
}
static INLINE void t8_field_range_ADC_ENB_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 start_bit,
                                               UINT32 stop_bit,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ADC_ENB_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 start_bit,
                                               UINT32 stop_bit,
                                               UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADC_ENB_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADC_ENB_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADC_ENB_set", stop_bit, 2 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADC_ENB_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000004 bits 22:20) bits 0:2 use field ADC_ENB of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000004 bits 22:20) bits 0:2 use field ADC_ENB of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
        t8_reg_PCIE3_CFG_2_field_set( b_ptr,
                                      h_ptr,
                                      id,
                                      subfield_mask << (PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_ENB_OFF + subfield_offset),
                                      PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_ENB_OFF + subfield_offset,
                                      value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ADC_ENB_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 start_bit,
                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ADC_ENB_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 start_bit,
                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADC_ENB_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADC_ENB_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADC_ENB_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000004 bits 22:20) bits 0:2 use field ADC_ENB of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    reg_value = t8_reg_PCIE3_CFG_2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_ENB_MSK)
                  >> PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_ENB_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_ENB_MSK, PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_ENB_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADC_ENB_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ADC_MODE_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADC_MODE_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_MODE_set", id, 2);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADC_MODE_set", value, 255);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADC_MODE_set", id, value );

    /* (0x00000004 bits 19:12) bits 0:7 use field ADC_MODE of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    t8_reg_PCIE3_CFG_2_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_MODE_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_MODE_OFF,
                                  value);
}

static INLINE UINT32 t8_field_ADC_MODE_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADC_MODE_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_MODE_get", id, 2);
    /* (0x00000004 bits 19:12) bits 0:7 use field ADC_MODE of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    reg_value = t8_reg_PCIE3_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_MODE_MSK) >> PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_MODE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADC_MODE_get", id, value );

    return value;
}
static INLINE void t8_field_range_ADC_MODE_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ADC_MODE_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADC_MODE_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADC_MODE_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADC_MODE_set", stop_bit, 7 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADC_MODE_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000004 bits 19:12) bits 0:7 use field ADC_MODE of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000004 bits 19:12) bits 0:7 use field ADC_MODE of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
        t8_reg_PCIE3_CFG_2_field_set( b_ptr,
                                      h_ptr,
                                      id,
                                      subfield_mask << (PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_MODE_OFF + subfield_offset),
                                      PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_MODE_OFF + subfield_offset,
                                      value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ADC_MODE_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ADC_MODE_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADC_MODE_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADC_MODE_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADC_MODE_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000004 bits 19:12) bits 0:7 use field ADC_MODE of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    reg_value = t8_reg_PCIE3_CFG_2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_MODE_MSK)
                  >> PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_MODE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_MODE_MSK, PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_MODE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADC_MODE_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ADC_BIST_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADC_BIST_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_BIST_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADC_BIST_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADC_BIST_set", id, value );

    /* (0x00000004 bits 11) field ADC_BIST of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    t8_reg_PCIE3_CFG_2_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_BIST_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_BIST_OFF,
                                  value);
}

static INLINE UINT32 t8_field_ADC_BIST_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADC_BIST_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_BIST_get", id, 2);
    /* (0x00000004 bits 11) field ADC_BIST of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    reg_value = t8_reg_PCIE3_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_BIST_MSK) >> PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_BIST_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADC_BIST_get", id, value );

    return value;
}
static INLINE void t8_field_ADC_DLB_EN_set( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADC_DLB_EN_set( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_DLB_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADC_DLB_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADC_DLB_EN_set", id, value );

    /* (0x00000004 bits 10) field ADC_DLB_EN of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    t8_reg_PCIE3_CFG_2_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_DLB_EN_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_DLB_EN_OFF,
                                  value);
}

static INLINE UINT32 t8_field_ADC_DLB_EN_get( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADC_DLB_EN_get( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_DLB_EN_get", id, 2);
    /* (0x00000004 bits 10) field ADC_DLB_EN of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    reg_value = t8_reg_PCIE3_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_DLB_EN_MSK) >> PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_DLB_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADC_DLB_EN_get", id, value );

    return value;
}
static INLINE void t8_field_ADC_DAC_ENB_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADC_DAC_ENB_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_DAC_ENB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADC_DAC_ENB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADC_DAC_ENB_set", id, value );

    /* (0x00000004 bits 9) field ADC_DAC_ENB of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    t8_reg_PCIE3_CFG_2_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_DAC_ENB_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_DAC_ENB_OFF,
                                  value);
}

static INLINE UINT32 t8_field_ADC_DAC_ENB_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADC_DAC_ENB_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_DAC_ENB_get", id, 2);
    /* (0x00000004 bits 9) field ADC_DAC_ENB of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    reg_value = t8_reg_PCIE3_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_DAC_ENB_MSK) >> PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_DAC_ENB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADC_DAC_ENB_get", id, value );

    return value;
}
static INLINE void t8_field_RXCM_ENB_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_RXCM_ENB_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RXCM_ENB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_RXCM_ENB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_RXCM_ENB_set", id, value );

    /* (0x00000004 bits 8) field RXCM_ENB of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    t8_reg_PCIE3_CFG_2_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_RXCM_ENB_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_RXCM_ENB_OFF,
                                  value);
}

static INLINE UINT32 t8_field_RXCM_ENB_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_RXCM_ENB_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RXCM_ENB_get", id, 2);
    /* (0x00000004 bits 8) field RXCM_ENB of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    reg_value = t8_reg_PCIE3_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_2_BIT_RXCM_ENB_MSK) >> PM20_82_24_REG_PCIE3_CFG_2_BIT_RXCM_ENB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_RXCM_ENB_get", id, value );

    return value;
}
static INLINE void t8_field_ADC_ATMSB_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADC_ATMSB_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_ATMSB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADC_ATMSB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADC_ATMSB_set", id, value );

    /* (0x00000004 bits 5) field ADC_ATMSB of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    t8_reg_PCIE3_CFG_2_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_ATMSB_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_ATMSB_OFF,
                                  value);
}

static INLINE UINT32 t8_field_ADC_ATMSB_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADC_ATMSB_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_ATMSB_get", id, 2);
    /* (0x00000004 bits 5) field ADC_ATMSB of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    reg_value = t8_reg_PCIE3_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_ATMSB_MSK) >> PM20_82_24_REG_PCIE3_CFG_2_BIT_ADC_ATMSB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADC_ATMSB_get", id, value );

    return value;
}
static INLINE void t8_field_RX_ATMSB_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_RX_ATMSB_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RX_ATMSB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_RX_ATMSB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_RX_ATMSB_set", id, value );

    /* (0x00000004 bits 3) field RX_ATMSB of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    t8_reg_PCIE3_CFG_2_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_RX_ATMSB_MSK,
                                  PM20_82_24_REG_PCIE3_CFG_2_BIT_RX_ATMSB_OFF,
                                  value);
}

static INLINE UINT32 t8_field_RX_ATMSB_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_RX_ATMSB_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RX_ATMSB_get", id, 2);
    /* (0x00000004 bits 3) field RX_ATMSB of register PMC_PM20_82_24_REG_PCIE3_CFG_2 */
    reg_value = t8_reg_PCIE3_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PCIE3_CFG_2_BIT_RX_ATMSB_MSK) >> PM20_82_24_REG_PCIE3_CFG_2_BIT_RX_ATMSB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_RX_ATMSB_get", id, value );

    return value;
}
static INLINE void t8_field_CM_MODN_B_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CM_MODN_B_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CM_MODN_B_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CM_MODN_B_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CM_MODN_B_set", id, value );

    /* (0x0000000c bits 26) field CM_MODN_B of register PMC_PM20_82_24_REG_TX_CNTR_CFG_1 */
    t8_reg_TX_CNTR_CFG_1_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_TX_CNTR_CFG_1_BIT_CM_MODN_B_MSK,
                                    PM20_82_24_REG_TX_CNTR_CFG_1_BIT_CM_MODN_B_OFF,
                                    value);
}

static INLINE UINT32 t8_field_CM_MODN_B_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CM_MODN_B_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CM_MODN_B_get", id, 2);
    /* (0x0000000c bits 26) field CM_MODN_B of register PMC_PM20_82_24_REG_TX_CNTR_CFG_1 */
    reg_value = t8_reg_TX_CNTR_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_1_BIT_CM_MODN_B_MSK) >> PM20_82_24_REG_TX_CNTR_CFG_1_BIT_CM_MODN_B_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CM_MODN_B_get", id, value );

    return value;
}
static INLINE void t8_field_CM_MODP_B_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CM_MODP_B_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CM_MODP_B_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CM_MODP_B_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CM_MODP_B_set", id, value );

    /* (0x0000000c bits 25) field CM_MODP_B of register PMC_PM20_82_24_REG_TX_CNTR_CFG_1 */
    t8_reg_TX_CNTR_CFG_1_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_TX_CNTR_CFG_1_BIT_CM_MODP_B_MSK,
                                    PM20_82_24_REG_TX_CNTR_CFG_1_BIT_CM_MODP_B_OFF,
                                    value);
}

static INLINE UINT32 t8_field_CM_MODP_B_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CM_MODP_B_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CM_MODP_B_get", id, 2);
    /* (0x0000000c bits 25) field CM_MODP_B of register PMC_PM20_82_24_REG_TX_CNTR_CFG_1 */
    reg_value = t8_reg_TX_CNTR_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_1_BIT_CM_MODP_B_MSK) >> PM20_82_24_REG_TX_CNTR_CFG_1_BIT_CM_MODP_B_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CM_MODP_B_get", id, value );

    return value;
}
static INLINE void t8_field_TX_ATMSB_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TX_ATMSB_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_ATMSB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TX_ATMSB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TX_ATMSB_set", id, value );

    /* (0x0000000c bits 24) field TX_ATMSB of register PMC_PM20_82_24_REG_TX_CNTR_CFG_1 */
    t8_reg_TX_CNTR_CFG_1_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_TX_CNTR_CFG_1_BIT_TX_ATMSB_MSK,
                                    PM20_82_24_REG_TX_CNTR_CFG_1_BIT_TX_ATMSB_OFF,
                                    value);
}

static INLINE UINT32 t8_field_TX_ATMSB_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TX_ATMSB_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_ATMSB_get", id, 2);
    /* (0x0000000c bits 24) field TX_ATMSB of register PMC_PM20_82_24_REG_TX_CNTR_CFG_1 */
    reg_value = t8_reg_TX_CNTR_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_1_BIT_TX_ATMSB_MSK) >> PM20_82_24_REG_TX_CNTR_CFG_1_BIT_TX_ATMSB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TX_ATMSB_get", id, value );

    return value;
}
static INLINE void t8_field_PISO_PRE2_MODE_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PISO_PRE2_MODE_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_PRE2_MODE_set", id, 2);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PISO_PRE2_MODE_set", value, 3);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PISO_PRE2_MODE_set", id, value );

    /* (0x00000010 bits 31:30) field PISO_PRE2_MODE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_2 */
    t8_reg_TX_CNTR_CFG_2_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE2_MODE_MSK,
                                    PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE2_MODE_OFF,
                                    value);
}

static INLINE UINT32 t8_field_PISO_PRE2_MODE_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PISO_PRE2_MODE_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_PRE2_MODE_get", id, 2);
    /* (0x00000010 bits 31:30) field PISO_PRE2_MODE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_2 */
    reg_value = t8_reg_TX_CNTR_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE2_MODE_MSK) >> PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE2_MODE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PISO_PRE2_MODE_get", id, value );

    return value;
}
static INLINE void t8_field_range_PISO_PRE2_MODE_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PISO_PRE2_MODE_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit,
                                                      UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PISO_PRE2_MODE_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PISO_PRE2_MODE_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PISO_PRE2_MODE_set", stop_bit, 1 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PISO_PRE2_MODE_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000010 bits 31:30) field PISO_PRE2_MODE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000010 bits 31:30) field PISO_PRE2_MODE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_2 */
        t8_reg_TX_CNTR_CFG_2_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        subfield_mask << (PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE2_MODE_OFF + subfield_offset),
                                        PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE2_MODE_OFF + subfield_offset,
                                        value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PISO_PRE2_MODE_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PISO_PRE2_MODE_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PISO_PRE2_MODE_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PISO_PRE2_MODE_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PISO_PRE2_MODE_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000010 bits 31:30) field PISO_PRE2_MODE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_2 */
    reg_value = t8_reg_TX_CNTR_CFG_2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE2_MODE_MSK)
                  >> PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE2_MODE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE2_MODE_MSK, PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE2_MODE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PISO_PRE2_MODE_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PISO_PRE2_ENABLE_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PISO_PRE2_ENABLE_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_PRE2_ENABLE_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PISO_PRE2_ENABLE_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PISO_PRE2_ENABLE_set", id, value );

    /* (0x00000010 bits 25) field PISO_PRE2_ENABLE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_2 */
    t8_reg_TX_CNTR_CFG_2_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE2_ENABLE_MSK,
                                    PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE2_ENABLE_OFF,
                                    value);
}

static INLINE UINT32 t8_field_PISO_PRE2_ENABLE_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PISO_PRE2_ENABLE_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_PRE2_ENABLE_get", id, 2);
    /* (0x00000010 bits 25) field PISO_PRE2_ENABLE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_2 */
    reg_value = t8_reg_TX_CNTR_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE2_ENABLE_MSK) >> PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE2_ENABLE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PISO_PRE2_ENABLE_get", id, value );

    return value;
}
static INLINE void t8_field_PISO_PRE1_ENABLE_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PISO_PRE1_ENABLE_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_PRE1_ENABLE_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PISO_PRE1_ENABLE_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PISO_PRE1_ENABLE_set", id, value );

    /* (0x00000010 bits 24) field PISO_PRE1_ENABLE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_2 */
    t8_reg_TX_CNTR_CFG_2_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE1_ENABLE_MSK,
                                    PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE1_ENABLE_OFF,
                                    value);
}

static INLINE UINT32 t8_field_PISO_PRE1_ENABLE_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PISO_PRE1_ENABLE_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_PRE1_ENABLE_get", id, 2);
    /* (0x00000010 bits 24) field PISO_PRE1_ENABLE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_2 */
    reg_value = t8_reg_TX_CNTR_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE1_ENABLE_MSK) >> PM20_82_24_REG_TX_CNTR_CFG_2_BIT_PISO_PRE1_ENABLE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PISO_PRE1_ENABLE_get", id, value );

    return value;
}
static INLINE void t8_field_TX_DER_CORE_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TX_DER_CORE_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_DER_CORE_set", id, 2);
    if (value > 31)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TX_DER_CORE_set", value, 31);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TX_DER_CORE_set", id, value );

    /* (0x00000014 bits 21:17) bits 0:4 use field TX_DER_CORE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_3 */
    t8_reg_TX_CNTR_CFG_3_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_TX_CNTR_CFG_3_BIT_TX_DER_CORE_MSK,
                                    PM20_82_24_REG_TX_CNTR_CFG_3_BIT_TX_DER_CORE_OFF,
                                    value);
}

static INLINE UINT32 t8_field_TX_DER_CORE_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TX_DER_CORE_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_DER_CORE_get", id, 2);
    /* (0x00000014 bits 21:17) bits 0:4 use field TX_DER_CORE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_3 */
    reg_value = t8_reg_TX_CNTR_CFG_3_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_3_BIT_TX_DER_CORE_MSK) >> PM20_82_24_REG_TX_CNTR_CFG_3_BIT_TX_DER_CORE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TX_DER_CORE_get", id, value );

    return value;
}
static INLINE void t8_field_range_TX_DER_CORE_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_TX_DER_CORE_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_TX_DER_CORE_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_TX_DER_CORE_set", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_TX_DER_CORE_set", stop_bit, 4 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_TX_DER_CORE_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000014 bits 21:17) bits 0:4 use field TX_DER_CORE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 4) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 4;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000014 bits 21:17) bits 0:4 use field TX_DER_CORE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_3 */
        t8_reg_TX_CNTR_CFG_3_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        subfield_mask << (PM20_82_24_REG_TX_CNTR_CFG_3_BIT_TX_DER_CORE_OFF + subfield_offset),
                                        PM20_82_24_REG_TX_CNTR_CFG_3_BIT_TX_DER_CORE_OFF + subfield_offset,
                                        value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_TX_DER_CORE_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_TX_DER_CORE_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_TX_DER_CORE_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_TX_DER_CORE_get", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_TX_DER_CORE_get", stop_bit, 4 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 4) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 4;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000014 bits 21:17) bits 0:4 use field TX_DER_CORE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_3 */
    reg_value = t8_reg_TX_CNTR_CFG_3_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_3_BIT_TX_DER_CORE_MSK)
                  >> PM20_82_24_REG_TX_CNTR_CFG_3_BIT_TX_DER_CORE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_TX_CNTR_CFG_3_BIT_TX_DER_CORE_MSK, PM20_82_24_REG_TX_CNTR_CFG_3_BIT_TX_DER_CORE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_TX_DER_CORE_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_TX_AMP_EMPH_EN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TX_AMP_EMPH_EN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_AMP_EMPH_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TX_AMP_EMPH_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TX_AMP_EMPH_EN_set", id, value );

    /* (0x00000018 bits 26) field TX_AMP_EMPH_EN of register PMC_PM20_82_24_REG_TX_CNTR_CFG_4 */
    t8_reg_TX_CNTR_CFG_4_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_TX_CNTR_CFG_4_BIT_TX_AMP_EMPH_EN_MSK,
                                    PM20_82_24_REG_TX_CNTR_CFG_4_BIT_TX_AMP_EMPH_EN_OFF,
                                    value);
}

static INLINE UINT32 t8_field_TX_AMP_EMPH_EN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TX_AMP_EMPH_EN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_AMP_EMPH_EN_get", id, 2);
    /* (0x00000018 bits 26) field TX_AMP_EMPH_EN of register PMC_PM20_82_24_REG_TX_CNTR_CFG_4 */
    reg_value = t8_reg_TX_CNTR_CFG_4_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_4_BIT_TX_AMP_EMPH_EN_MSK) >> PM20_82_24_REG_TX_CNTR_CFG_4_BIT_TX_AMP_EMPH_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TX_AMP_EMPH_EN_get", id, value );

    return value;
}
static INLINE void t8_field_RXDET_CANCEL_OVERRIDE_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_RXDET_CANCEL_OVERRIDE_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RXDET_CANCEL_OVERRIDE_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_RXDET_CANCEL_OVERRIDE_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_RXDET_CANCEL_OVERRIDE_set", id, value );

    /* (0x0000001c bits 31) field RXDET_CANCEL_OVERRIDE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_5 */
    t8_reg_TX_CNTR_CFG_5_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_TX_CNTR_CFG_5_BIT_RXDET_CANCEL_OVERRIDE_MSK,
                                    PM20_82_24_REG_TX_CNTR_CFG_5_BIT_RXDET_CANCEL_OVERRIDE_OFF,
                                    value);
}

static INLINE UINT32 t8_field_RXDET_CANCEL_OVERRIDE_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_RXDET_CANCEL_OVERRIDE_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RXDET_CANCEL_OVERRIDE_get", id, 2);
    /* (0x0000001c bits 31) field RXDET_CANCEL_OVERRIDE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_5 */
    reg_value = t8_reg_TX_CNTR_CFG_5_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_5_BIT_RXDET_CANCEL_OVERRIDE_MSK) >> PM20_82_24_REG_TX_CNTR_CFG_5_BIT_RXDET_CANCEL_OVERRIDE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_RXDET_CANCEL_OVERRIDE_get", id, value );

    return value;
}
static INLINE void t8_field_TX_CTRL_CMD_EN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TX_CTRL_CMD_EN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_CTRL_CMD_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TX_CTRL_CMD_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TX_CTRL_CMD_EN_set", id, value );

    /* (0x0000001c bits 17) field TX_CTRL_CMD_EN of register PMC_PM20_82_24_REG_TX_CNTR_CFG_5 */
    t8_reg_TX_CNTR_CFG_5_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_CTRL_CMD_EN_MSK,
                                    PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_CTRL_CMD_EN_OFF,
                                    value);
}

static INLINE UINT32 t8_field_TX_CTRL_CMD_EN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TX_CTRL_CMD_EN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_CTRL_CMD_EN_get", id, 2);
    /* (0x0000001c bits 17) field TX_CTRL_CMD_EN of register PMC_PM20_82_24_REG_TX_CNTR_CFG_5 */
    reg_value = t8_reg_TX_CNTR_CFG_5_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_CTRL_CMD_EN_MSK) >> PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_CTRL_CMD_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TX_CTRL_CMD_EN_get", id, value );

    return value;
}
static INLINE void t8_field_TX_EDGE_DELAY_SEL_CORE_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TX_EDGE_DELAY_SEL_CORE_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_EDGE_DELAY_SEL_CORE_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TX_EDGE_DELAY_SEL_CORE_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TX_EDGE_DELAY_SEL_CORE_set", id, value );

    /* (0x0000001c bits 16) field TX_EDGE_DELAY_SEL_CORE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_5 */
    t8_reg_TX_CNTR_CFG_5_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_EDGE_DELAY_SEL_CORE_MSK,
                                    PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_EDGE_DELAY_SEL_CORE_OFF,
                                    value);
}

static INLINE UINT32 t8_field_TX_EDGE_DELAY_SEL_CORE_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TX_EDGE_DELAY_SEL_CORE_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_EDGE_DELAY_SEL_CORE_get", id, 2);
    /* (0x0000001c bits 16) field TX_EDGE_DELAY_SEL_CORE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_5 */
    reg_value = t8_reg_TX_CNTR_CFG_5_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_EDGE_DELAY_SEL_CORE_MSK) >> PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_EDGE_DELAY_SEL_CORE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TX_EDGE_DELAY_SEL_CORE_get", id, value );

    return value;
}
static INLINE void t8_field_TX_CTRL_EDGE_CORE_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TX_CTRL_EDGE_CORE_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_CTRL_EDGE_CORE_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TX_CTRL_EDGE_CORE_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TX_CTRL_EDGE_CORE_set", id, value );

    /* (0x0000001c bits 15:0) bits 0:15 use field TX_CTRL_EDGE_CORE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_5 */
    t8_reg_TX_CNTR_CFG_5_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_CTRL_EDGE_CORE_MSK,
                                    PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_CTRL_EDGE_CORE_OFF,
                                    value);
}

static INLINE UINT32 t8_field_TX_CTRL_EDGE_CORE_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TX_CTRL_EDGE_CORE_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_CTRL_EDGE_CORE_get", id, 2);
    /* (0x0000001c bits 15:0) bits 0:15 use field TX_CTRL_EDGE_CORE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_5 */
    reg_value = t8_reg_TX_CNTR_CFG_5_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_CTRL_EDGE_CORE_MSK) >> PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_CTRL_EDGE_CORE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TX_CTRL_EDGE_CORE_get", id, value );

    return value;
}
static INLINE void t8_field_range_TX_CTRL_EDGE_CORE_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_TX_CTRL_EDGE_CORE_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_TX_CTRL_EDGE_CORE_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_TX_CTRL_EDGE_CORE_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_TX_CTRL_EDGE_CORE_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_TX_CTRL_EDGE_CORE_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000001c bits 15:0) bits 0:15 use field TX_CTRL_EDGE_CORE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000001c bits 15:0) bits 0:15 use field TX_CTRL_EDGE_CORE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_5 */
        t8_reg_TX_CNTR_CFG_5_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        subfield_mask << (PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_CTRL_EDGE_CORE_OFF + subfield_offset),
                                        PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_CTRL_EDGE_CORE_OFF + subfield_offset,
                                        value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_TX_CTRL_EDGE_CORE_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_TX_CTRL_EDGE_CORE_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_TX_CTRL_EDGE_CORE_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_TX_CTRL_EDGE_CORE_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_TX_CTRL_EDGE_CORE_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000001c bits 15:0) bits 0:15 use field TX_CTRL_EDGE_CORE of register PMC_PM20_82_24_REG_TX_CNTR_CFG_5 */
    reg_value = t8_reg_TX_CNTR_CFG_5_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_CTRL_EDGE_CORE_MSK)
                  >> PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_CTRL_EDGE_CORE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_CTRL_EDGE_CORE_MSK, PM20_82_24_REG_TX_CNTR_CFG_5_BIT_TX_CTRL_EDGE_CORE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_TX_CTRL_EDGE_CORE_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_TX_COUNTER_set( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TX_COUNTER_set( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_COUNTER_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TX_COUNTER_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TX_COUNTER_set", id, value );

    /* (0x00000020 bits 15:0) bits 0:15 use field TX_COUNTER of register PMC_PM20_82_24_REG_TX_CNTR_CFG_6 */
    t8_reg_TX_CNTR_CFG_6_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_TX_CNTR_CFG_6_BIT_TX_COUNTER_MSK,
                                    PM20_82_24_REG_TX_CNTR_CFG_6_BIT_TX_COUNTER_OFF,
                                    value);
}

static INLINE UINT32 t8_field_TX_COUNTER_get( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TX_COUNTER_get( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_COUNTER_get", id, 2);
    /* (0x00000020 bits 15:0) bits 0:15 use field TX_COUNTER of register PMC_PM20_82_24_REG_TX_CNTR_CFG_6 */
    reg_value = t8_reg_TX_CNTR_CFG_6_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_6_BIT_TX_COUNTER_MSK) >> PM20_82_24_REG_TX_CNTR_CFG_6_BIT_TX_COUNTER_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TX_COUNTER_get", id, value );

    return value;
}
static INLINE void t8_field_range_TX_COUNTER_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_TX_COUNTER_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_TX_COUNTER_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_TX_COUNTER_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_TX_COUNTER_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_TX_COUNTER_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000020 bits 15:0) bits 0:15 use field TX_COUNTER of register PMC_PM20_82_24_REG_TX_CNTR_CFG_6 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000020 bits 15:0) bits 0:15 use field TX_COUNTER of register PMC_PM20_82_24_REG_TX_CNTR_CFG_6 */
        t8_reg_TX_CNTR_CFG_6_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        subfield_mask << (PM20_82_24_REG_TX_CNTR_CFG_6_BIT_TX_COUNTER_OFF + subfield_offset),
                                        PM20_82_24_REG_TX_CNTR_CFG_6_BIT_TX_COUNTER_OFF + subfield_offset,
                                        value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_TX_COUNTER_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_TX_COUNTER_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_TX_COUNTER_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_TX_COUNTER_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_TX_COUNTER_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000020 bits 15:0) bits 0:15 use field TX_COUNTER of register PMC_PM20_82_24_REG_TX_CNTR_CFG_6 */
    reg_value = t8_reg_TX_CNTR_CFG_6_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_TX_CNTR_CFG_6_BIT_TX_COUNTER_MSK)
                  >> PM20_82_24_REG_TX_CNTR_CFG_6_BIT_TX_COUNTER_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_TX_CNTR_CFG_6_BIT_TX_COUNTER_MSK, PM20_82_24_REG_TX_CNTR_CFG_6_BIT_TX_COUNTER_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_TX_COUNTER_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_RX_TO_TX_LPBK_EN_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_RX_TO_TX_LPBK_EN_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RX_TO_TX_LPBK_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_RX_TO_TX_LPBK_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_RX_TO_TX_LPBK_EN_set", id, value );

    /* (0x00000028 bits 7) field RX_TO_TX_LPBK_EN of register PMC_PM20_82_24_REG_DIG_LPBK_CFG */
    t8_reg_DIG_LPBK_CFG_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_DIG_LPBK_CFG_BIT_RX_TO_TX_LPBK_EN_MSK,
                                   PM20_82_24_REG_DIG_LPBK_CFG_BIT_RX_TO_TX_LPBK_EN_OFF,
                                   value);
}

static INLINE UINT32 t8_field_RX_TO_TX_LPBK_EN_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_RX_TO_TX_LPBK_EN_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RX_TO_TX_LPBK_EN_get", id, 2);
    /* (0x00000028 bits 7) field RX_TO_TX_LPBK_EN of register PMC_PM20_82_24_REG_DIG_LPBK_CFG */
    reg_value = t8_reg_DIG_LPBK_CFG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIG_LPBK_CFG_BIT_RX_TO_TX_LPBK_EN_MSK) >> PM20_82_24_REG_DIG_LPBK_CFG_BIT_RX_TO_TX_LPBK_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_RX_TO_TX_LPBK_EN_get", id, value );

    return value;
}
static INLINE void t8_field_TX_TO_RX_LPBK_EN_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TX_TO_RX_LPBK_EN_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_TO_RX_LPBK_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TX_TO_RX_LPBK_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TX_TO_RX_LPBK_EN_set", id, value );

    /* (0x00000028 bits 3) field TX_TO_RX_LPBK_EN of register PMC_PM20_82_24_REG_DIG_LPBK_CFG */
    t8_reg_DIG_LPBK_CFG_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_DIG_LPBK_CFG_BIT_TX_TO_RX_LPBK_EN_MSK,
                                   PM20_82_24_REG_DIG_LPBK_CFG_BIT_TX_TO_RX_LPBK_EN_OFF,
                                   value);
}

static INLINE UINT32 t8_field_TX_TO_RX_LPBK_EN_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TX_TO_RX_LPBK_EN_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_TO_RX_LPBK_EN_get", id, 2);
    /* (0x00000028 bits 3) field TX_TO_RX_LPBK_EN of register PMC_PM20_82_24_REG_DIG_LPBK_CFG */
    reg_value = t8_reg_DIG_LPBK_CFG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIG_LPBK_CFG_BIT_TX_TO_RX_LPBK_EN_MSK) >> PM20_82_24_REG_DIG_LPBK_CFG_BIT_TX_TO_RX_LPBK_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TX_TO_RX_LPBK_EN_get", id, value );

    return value;
}
static INLINE void t8_field_TIME_REVERSE_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TIME_REVERSE_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TIME_REVERSE_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TIME_REVERSE_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TIME_REVERSE_set", id, value );

    /* (0x0000002c bits 6) field TIME_REVERSE of register PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG */
    t8_reg_ANALOG_SIPO_BIST_CFG_REG_field_set( b_ptr,
                                               h_ptr,
                                               id,
                                               PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_TIME_REVERSE_MSK,
                                               PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_TIME_REVERSE_OFF,
                                               value);
}

static INLINE UINT32 t8_field_TIME_REVERSE_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TIME_REVERSE_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TIME_REVERSE_get", id, 2);
    /* (0x0000002c bits 6) field TIME_REVERSE of register PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG */
    reg_value = t8_reg_ANALOG_SIPO_BIST_CFG_REG_read( b_ptr,
                                                      h_ptr,
                                                      id);
    value = (reg_value & PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_TIME_REVERSE_MSK) >> PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_TIME_REVERSE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TIME_REVERSE_get", id, value );

    return value;
}
static INLINE void t8_field_A_SIPO_BIST_SEL_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_A_SIPO_BIST_SEL_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_A_SIPO_BIST_SEL_set", id, 2);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_A_SIPO_BIST_SEL_set", value, 7);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_A_SIPO_BIST_SEL_set", id, value );

    /* (0x0000002c bits 3:1) bits 0:2 use field A_SIPO_BIST_SEL of register PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG */
    t8_reg_ANALOG_SIPO_BIST_CFG_REG_field_set( b_ptr,
                                               h_ptr,
                                               id,
                                               PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_A_SIPO_BIST_SEL_MSK,
                                               PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_A_SIPO_BIST_SEL_OFF,
                                               value);
}

static INLINE UINT32 t8_field_A_SIPO_BIST_SEL_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_A_SIPO_BIST_SEL_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_A_SIPO_BIST_SEL_get", id, 2);
    /* (0x0000002c bits 3:1) bits 0:2 use field A_SIPO_BIST_SEL of register PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG */
    reg_value = t8_reg_ANALOG_SIPO_BIST_CFG_REG_read( b_ptr,
                                                      h_ptr,
                                                      id);
    value = (reg_value & PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_A_SIPO_BIST_SEL_MSK) >> PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_A_SIPO_BIST_SEL_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_A_SIPO_BIST_SEL_get", id, value );

    return value;
}
static INLINE void t8_field_range_A_SIPO_BIST_SEL_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_A_SIPO_BIST_SEL_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_A_SIPO_BIST_SEL_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_A_SIPO_BIST_SEL_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_A_SIPO_BIST_SEL_set", stop_bit, 2 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_A_SIPO_BIST_SEL_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000002c bits 3:1) bits 0:2 use field A_SIPO_BIST_SEL of register PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000002c bits 3:1) bits 0:2 use field A_SIPO_BIST_SEL of register PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG */
        t8_reg_ANALOG_SIPO_BIST_CFG_REG_field_set( b_ptr,
                                                   h_ptr,
                                                   id,
                                                   subfield_mask << (PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_A_SIPO_BIST_SEL_OFF + subfield_offset),
                                                   PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_A_SIPO_BIST_SEL_OFF + subfield_offset,
                                                   value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_A_SIPO_BIST_SEL_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_A_SIPO_BIST_SEL_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_A_SIPO_BIST_SEL_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_A_SIPO_BIST_SEL_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_A_SIPO_BIST_SEL_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000002c bits 3:1) bits 0:2 use field A_SIPO_BIST_SEL of register PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG */
    reg_value = t8_reg_ANALOG_SIPO_BIST_CFG_REG_read( b_ptr,
                                                      h_ptr,
                                                      id);
    field_value = (reg_value & PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_A_SIPO_BIST_SEL_MSK)
                  >> PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_A_SIPO_BIST_SEL_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_A_SIPO_BIST_SEL_MSK, PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_A_SIPO_BIST_SEL_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_A_SIPO_BIST_SEL_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_A_SIPO_BIST_EN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_A_SIPO_BIST_EN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_A_SIPO_BIST_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_A_SIPO_BIST_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_A_SIPO_BIST_EN_set", id, value );

    /* (0x0000002c bits 0) field A_SIPO_BIST_EN of register PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG */
    t8_reg_ANALOG_SIPO_BIST_CFG_REG_field_set( b_ptr,
                                               h_ptr,
                                               id,
                                               PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_A_SIPO_BIST_EN_MSK,
                                               PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_A_SIPO_BIST_EN_OFF,
                                               value);
}

static INLINE UINT32 t8_field_A_SIPO_BIST_EN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_A_SIPO_BIST_EN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_A_SIPO_BIST_EN_get", id, 2);
    /* (0x0000002c bits 0) field A_SIPO_BIST_EN of register PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG */
    reg_value = t8_reg_ANALOG_SIPO_BIST_CFG_REG_read( b_ptr,
                                                      h_ptr,
                                                      id);
    value = (reg_value & PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_A_SIPO_BIST_EN_MSK) >> PM20_82_24_REG_ANALOG_SIPO_BIST_CFG_REG_BIT_A_SIPO_BIST_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_A_SIPO_BIST_EN_get", id, value );

    return value;
}
static INLINE void t8_field_GCOC_RAM_LS_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_GCOC_RAM_LS_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GCOC_RAM_LS_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_GCOC_RAM_LS_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_GCOC_RAM_LS_set", id, value );

    /* (0x00000030 bits 6) field GCOC_RAM_LS of register PMC_PM20_82_24_REG_OFFSET_RAM_CFG */
    t8_reg_OFFSET_RAM_CFG_field_set( b_ptr,
                                     h_ptr,
                                     id,
                                     PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_LS_MSK,
                                     PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_LS_OFF,
                                     value);
}

static INLINE UINT32 t8_field_GCOC_RAM_LS_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_GCOC_RAM_LS_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GCOC_RAM_LS_get", id, 2);
    /* (0x00000030 bits 6) field GCOC_RAM_LS of register PMC_PM20_82_24_REG_OFFSET_RAM_CFG */
    reg_value = t8_reg_OFFSET_RAM_CFG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_LS_MSK) >> PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_LS_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_GCOC_RAM_LS_get", id, value );

    return value;
}
static INLINE void t8_field_GCOC_RAM_SD_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_GCOC_RAM_SD_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GCOC_RAM_SD_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_GCOC_RAM_SD_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_GCOC_RAM_SD_set", id, value );

    /* (0x00000030 bits 4) field GCOC_RAM_SD of register PMC_PM20_82_24_REG_OFFSET_RAM_CFG */
    t8_reg_OFFSET_RAM_CFG_field_set( b_ptr,
                                     h_ptr,
                                     id,
                                     PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_SD_MSK,
                                     PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_SD_OFF,
                                     value);
}

static INLINE UINT32 t8_field_GCOC_RAM_SD_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_GCOC_RAM_SD_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GCOC_RAM_SD_get", id, 2);
    /* (0x00000030 bits 4) field GCOC_RAM_SD of register PMC_PM20_82_24_REG_OFFSET_RAM_CFG */
    reg_value = t8_reg_OFFSET_RAM_CFG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_SD_MSK) >> PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_SD_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_GCOC_RAM_SD_get", id, value );

    return value;
}
static INLINE void t8_field_GCOC_RAM_DS_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_GCOC_RAM_DS_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GCOC_RAM_DS_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_GCOC_RAM_DS_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_GCOC_RAM_DS_set", id, value );

    /* (0x00000030 bits 3) field GCOC_RAM_DS of register PMC_PM20_82_24_REG_OFFSET_RAM_CFG */
    t8_reg_OFFSET_RAM_CFG_field_set( b_ptr,
                                     h_ptr,
                                     id,
                                     PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_DS_MSK,
                                     PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_DS_OFF,
                                     value);
}

static INLINE UINT32 t8_field_GCOC_RAM_DS_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_GCOC_RAM_DS_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GCOC_RAM_DS_get", id, 2);
    /* (0x00000030 bits 3) field GCOC_RAM_DS of register PMC_PM20_82_24_REG_OFFSET_RAM_CFG */
    reg_value = t8_reg_OFFSET_RAM_CFG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_DS_MSK) >> PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_DS_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_GCOC_RAM_DS_get", id, value );

    return value;
}
static INLINE void t8_field_GCOC_RAM_ERR_INJ_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_GCOC_RAM_ERR_INJ_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GCOC_RAM_ERR_INJ_set", id, 2);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_GCOC_RAM_ERR_INJ_set", value, 3);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_GCOC_RAM_ERR_INJ_set", id, value );

    /* (0x00000030 bits 2:1) field GCOC_RAM_ERR_INJ of register PMC_PM20_82_24_REG_OFFSET_RAM_CFG */
    t8_reg_OFFSET_RAM_CFG_field_set( b_ptr,
                                     h_ptr,
                                     id,
                                     PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_ERR_INJ_MSK,
                                     PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_ERR_INJ_OFF,
                                     value);
}

static INLINE UINT32 t8_field_GCOC_RAM_ERR_INJ_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_GCOC_RAM_ERR_INJ_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GCOC_RAM_ERR_INJ_get", id, 2);
    /* (0x00000030 bits 2:1) field GCOC_RAM_ERR_INJ of register PMC_PM20_82_24_REG_OFFSET_RAM_CFG */
    reg_value = t8_reg_OFFSET_RAM_CFG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_ERR_INJ_MSK) >> PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_ERR_INJ_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_GCOC_RAM_ERR_INJ_get", id, value );

    return value;
}
static INLINE void t8_field_range_GCOC_RAM_ERR_INJ_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_GCOC_RAM_ERR_INJ_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_GCOC_RAM_ERR_INJ_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_GCOC_RAM_ERR_INJ_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_GCOC_RAM_ERR_INJ_set", stop_bit, 1 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_GCOC_RAM_ERR_INJ_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000030 bits 2:1) field GCOC_RAM_ERR_INJ of register PMC_PM20_82_24_REG_OFFSET_RAM_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000030 bits 2:1) field GCOC_RAM_ERR_INJ of register PMC_PM20_82_24_REG_OFFSET_RAM_CFG */
        t8_reg_OFFSET_RAM_CFG_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         subfield_mask << (PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_ERR_INJ_OFF + subfield_offset),
                                         PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_ERR_INJ_OFF + subfield_offset,
                                         value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_GCOC_RAM_ERR_INJ_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_GCOC_RAM_ERR_INJ_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_GCOC_RAM_ERR_INJ_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_GCOC_RAM_ERR_INJ_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_GCOC_RAM_ERR_INJ_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000030 bits 2:1) field GCOC_RAM_ERR_INJ of register PMC_PM20_82_24_REG_OFFSET_RAM_CFG */
    reg_value = t8_reg_OFFSET_RAM_CFG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_ERR_INJ_MSK)
                  >> PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_ERR_INJ_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_ERR_INJ_MSK, PM20_82_24_REG_OFFSET_RAM_CFG_BIT_GCOC_RAM_ERR_INJ_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_GCOC_RAM_ERR_INJ_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_LOCK_PRECISION_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_LOCK_PRECISION_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LOCK_PRECISION_set", id, 2);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_LOCK_PRECISION_set", value, 15);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_LOCK_PRECISION_set", id, value );

    /* (0x00000034 bits 15:12) field LOCK_PRECISION of register PMC_PM20_82_24_REG_PLL_CNFG_REG1 */
    t8_reg_PLL_CNFG_REG1_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_PLL_CNFG_REG1_BIT_LOCK_PRECISION_MSK,
                                    PM20_82_24_REG_PLL_CNFG_REG1_BIT_LOCK_PRECISION_OFF,
                                    value);
}

static INLINE UINT32 t8_field_LOCK_PRECISION_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_LOCK_PRECISION_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LOCK_PRECISION_get", id, 2);
    /* (0x00000034 bits 15:12) field LOCK_PRECISION of register PMC_PM20_82_24_REG_PLL_CNFG_REG1 */
    reg_value = t8_reg_PLL_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PLL_CNFG_REG1_BIT_LOCK_PRECISION_MSK) >> PM20_82_24_REG_PLL_CNFG_REG1_BIT_LOCK_PRECISION_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_LOCK_PRECISION_get", id, value );

    return value;
}
static INLINE void t8_field_range_LOCK_PRECISION_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_LOCK_PRECISION_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit,
                                                      UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_LOCK_PRECISION_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_LOCK_PRECISION_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_LOCK_PRECISION_set", stop_bit, 3 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_LOCK_PRECISION_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000034 bits 15:12) field LOCK_PRECISION of register PMC_PM20_82_24_REG_PLL_CNFG_REG1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000034 bits 15:12) field LOCK_PRECISION of register PMC_PM20_82_24_REG_PLL_CNFG_REG1 */
        t8_reg_PLL_CNFG_REG1_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        subfield_mask << (PM20_82_24_REG_PLL_CNFG_REG1_BIT_LOCK_PRECISION_OFF + subfield_offset),
                                        PM20_82_24_REG_PLL_CNFG_REG1_BIT_LOCK_PRECISION_OFF + subfield_offset,
                                        value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_LOCK_PRECISION_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_LOCK_PRECISION_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_LOCK_PRECISION_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_LOCK_PRECISION_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_LOCK_PRECISION_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000034 bits 15:12) field LOCK_PRECISION of register PMC_PM20_82_24_REG_PLL_CNFG_REG1 */
    reg_value = t8_reg_PLL_CNFG_REG1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PLL_CNFG_REG1_BIT_LOCK_PRECISION_MSK)
                  >> PM20_82_24_REG_PLL_CNFG_REG1_BIT_LOCK_PRECISION_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PLL_CNFG_REG1_BIT_LOCK_PRECISION_MSK, PM20_82_24_REG_PLL_CNFG_REG1_BIT_LOCK_PRECISION_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_LOCK_PRECISION_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_LOAD_CLK_CNTRS_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_LOAD_CLK_CNTRS_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LOAD_CLK_CNTRS_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_LOAD_CLK_CNTRS_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_LOAD_CLK_CNTRS_set", id, value );

    /* (0x00000034 bits 4) field LOAD_CLK_CNTRS of register PMC_PM20_82_24_REG_PLL_CNFG_REG1 */
    t8_reg_PLL_CNFG_REG1_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_PLL_CNFG_REG1_BIT_LOAD_CLK_CNTRS_MSK,
                                    PM20_82_24_REG_PLL_CNFG_REG1_BIT_LOAD_CLK_CNTRS_OFF,
                                    value);
}

static INLINE UINT32 t8_field_LOAD_CLK_CNTRS_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_LOAD_CLK_CNTRS_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LOAD_CLK_CNTRS_get", id, 2);
    /* (0x00000034 bits 4) field LOAD_CLK_CNTRS of register PMC_PM20_82_24_REG_PLL_CNFG_REG1 */
    reg_value = t8_reg_PLL_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PLL_CNFG_REG1_BIT_LOAD_CLK_CNTRS_MSK) >> PM20_82_24_REG_PLL_CNFG_REG1_BIT_LOAD_CLK_CNTRS_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_LOAD_CLK_CNTRS_get", id, value );

    return value;
}
static INLINE void t8_field_RESET_HISTORY_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_RESET_HISTORY_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RESET_HISTORY_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_RESET_HISTORY_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_RESET_HISTORY_set", id, value );

    /* (0x00000034 bits 2) field RESET_HISTORY of register PMC_PM20_82_24_REG_PLL_CNFG_REG1 */
    t8_reg_PLL_CNFG_REG1_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_PLL_CNFG_REG1_BIT_RESET_HISTORY_MSK,
                                    PM20_82_24_REG_PLL_CNFG_REG1_BIT_RESET_HISTORY_OFF,
                                    value);
}

static INLINE UINT32 t8_field_RESET_HISTORY_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_RESET_HISTORY_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RESET_HISTORY_get", id, 2);
    /* (0x00000034 bits 2) field RESET_HISTORY of register PMC_PM20_82_24_REG_PLL_CNFG_REG1 */
    reg_value = t8_reg_PLL_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PLL_CNFG_REG1_BIT_RESET_HISTORY_MSK) >> PM20_82_24_REG_PLL_CNFG_REG1_BIT_RESET_HISTORY_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_RESET_HISTORY_get", id, value );

    return value;
}
static INLINE void t8_field_ADCOC_BIST_EN_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADCOC_BIST_EN_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_BIST_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADCOC_BIST_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADCOC_BIST_EN_set", id, value );

    /* (0x00000038 bits 31) field ADCOC_BIST_EN of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    t8_reg_ADC_OC_CFG_1_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_BIST_EN_MSK,
                                   PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_BIST_EN_OFF,
                                   value);
}

static INLINE UINT32 t8_field_ADCOC_BIST_EN_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_BIST_EN_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_BIST_EN_get", id, 2);
    /* (0x00000038 bits 31) field ADCOC_BIST_EN of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    reg_value = t8_reg_ADC_OC_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_BIST_EN_MSK) >> PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_BIST_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_BIST_EN_get", id, value );

    return value;
}
static INLINE void t8_field_ADCOC_RD_OVR_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADCOC_RD_OVR_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_RD_OVR_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADCOC_RD_OVR_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADCOC_RD_OVR_set", id, value );

    /* (0x00000038 bits 30) field ADCOC_RD_OVR of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    t8_reg_ADC_OC_CFG_1_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_RD_OVR_MSK,
                                   PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_RD_OVR_OFF,
                                   value);
}

static INLINE UINT32 t8_field_ADCOC_RD_OVR_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_RD_OVR_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_RD_OVR_get", id, 2);
    /* (0x00000038 bits 30) field ADCOC_RD_OVR of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    reg_value = t8_reg_ADC_OC_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_RD_OVR_MSK) >> PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_RD_OVR_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_RD_OVR_get", id, value );

    return value;
}
static INLINE void t8_field_ADCOC_OFFSET_EN_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADCOC_OFFSET_EN_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_OFFSET_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADCOC_OFFSET_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADCOC_OFFSET_EN_set", id, value );

    /* (0x00000038 bits 29) field ADCOC_OFFSET_EN of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    t8_reg_ADC_OC_CFG_1_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_OFFSET_EN_MSK,
                                   PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_OFFSET_EN_OFF,
                                   value);
}

static INLINE UINT32 t8_field_ADCOC_OFFSET_EN_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_OFFSET_EN_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_OFFSET_EN_get", id, 2);
    /* (0x00000038 bits 29) field ADCOC_OFFSET_EN of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    reg_value = t8_reg_ADC_OC_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_OFFSET_EN_MSK) >> PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_OFFSET_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_OFFSET_EN_get", id, value );

    return value;
}
static INLINE void t8_field_ADCOC_CALIB_PROG_EN_set( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADCOC_CALIB_PROG_EN_set( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_CALIB_PROG_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADCOC_CALIB_PROG_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADCOC_CALIB_PROG_EN_set", id, value );

    /* (0x00000038 bits 28) field ADCOC_CALIB_PROG_EN of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    t8_reg_ADC_OC_CFG_1_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_CALIB_PROG_EN_MSK,
                                   PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_CALIB_PROG_EN_OFF,
                                   value);
}

static INLINE UINT32 t8_field_ADCOC_CALIB_PROG_EN_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_CALIB_PROG_EN_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_CALIB_PROG_EN_get", id, 2);
    /* (0x00000038 bits 28) field ADCOC_CALIB_PROG_EN of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    reg_value = t8_reg_ADC_OC_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_CALIB_PROG_EN_MSK) >> PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_CALIB_PROG_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_CALIB_PROG_EN_get", id, value );

    return value;
}
static INLINE void t8_field_ADCOC_ACC_DELAY_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADCOC_ACC_DELAY_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_ACC_DELAY_set", id, 2);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADCOC_ACC_DELAY_set", value, 15);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADCOC_ACC_DELAY_set", id, value );

    /* (0x00000038 bits 27:24) bits 0:3 use field ADCOC_ACC_DELAY of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    t8_reg_ADC_OC_CFG_1_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_ACC_DELAY_MSK,
                                   PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_ACC_DELAY_OFF,
                                   value);
}

static INLINE UINT32 t8_field_ADCOC_ACC_DELAY_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_ACC_DELAY_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_ACC_DELAY_get", id, 2);
    /* (0x00000038 bits 27:24) bits 0:3 use field ADCOC_ACC_DELAY of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    reg_value = t8_reg_ADC_OC_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_ACC_DELAY_MSK) >> PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_ACC_DELAY_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_ACC_DELAY_get", id, value );

    return value;
}
static INLINE void t8_field_range_ADCOC_ACC_DELAY_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ADCOC_ACC_DELAY_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADCOC_ACC_DELAY_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADCOC_ACC_DELAY_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADCOC_ACC_DELAY_set", stop_bit, 3 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADCOC_ACC_DELAY_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000038 bits 27:24) bits 0:3 use field ADCOC_ACC_DELAY of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000038 bits 27:24) bits 0:3 use field ADCOC_ACC_DELAY of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
        t8_reg_ADC_OC_CFG_1_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       subfield_mask << (PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_ACC_DELAY_OFF + subfield_offset),
                                       PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_ACC_DELAY_OFF + subfield_offset,
                                       value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ADCOC_ACC_DELAY_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ADCOC_ACC_DELAY_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADCOC_ACC_DELAY_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADCOC_ACC_DELAY_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADCOC_ACC_DELAY_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000038 bits 27:24) bits 0:3 use field ADCOC_ACC_DELAY of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    reg_value = t8_reg_ADC_OC_CFG_1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_ACC_DELAY_MSK)
                  >> PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_ACC_DELAY_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_ACC_DELAY_MSK, PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_ACC_DELAY_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADCOC_ACC_DELAY_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ADCOC_DAC_DELAY_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADCOC_DAC_DELAY_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_DAC_DELAY_set", id, 2);
    if (value > 1023)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADCOC_DAC_DELAY_set", value, 1023);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADCOC_DAC_DELAY_set", id, value );

    /* (0x00000038 bits 23:14) bits 0:9 use field ADCOC_DAC_DELAY of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    t8_reg_ADC_OC_CFG_1_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_DAC_DELAY_MSK,
                                   PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_DAC_DELAY_OFF,
                                   value);
}

static INLINE UINT32 t8_field_ADCOC_DAC_DELAY_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_DAC_DELAY_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_DAC_DELAY_get", id, 2);
    /* (0x00000038 bits 23:14) bits 0:9 use field ADCOC_DAC_DELAY of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    reg_value = t8_reg_ADC_OC_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_DAC_DELAY_MSK) >> PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_DAC_DELAY_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_DAC_DELAY_get", id, value );

    return value;
}
static INLINE void t8_field_range_ADCOC_DAC_DELAY_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ADCOC_DAC_DELAY_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADCOC_DAC_DELAY_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADCOC_DAC_DELAY_set", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADCOC_DAC_DELAY_set", stop_bit, 9 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADCOC_DAC_DELAY_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000038 bits 23:14) bits 0:9 use field ADCOC_DAC_DELAY of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 9) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 9;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000038 bits 23:14) bits 0:9 use field ADCOC_DAC_DELAY of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
        t8_reg_ADC_OC_CFG_1_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       subfield_mask << (PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_DAC_DELAY_OFF + subfield_offset),
                                       PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_DAC_DELAY_OFF + subfield_offset,
                                       value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ADCOC_DAC_DELAY_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ADCOC_DAC_DELAY_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADCOC_DAC_DELAY_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADCOC_DAC_DELAY_get", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADCOC_DAC_DELAY_get", stop_bit, 9 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 9) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 9;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000038 bits 23:14) bits 0:9 use field ADCOC_DAC_DELAY of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    reg_value = t8_reg_ADC_OC_CFG_1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_DAC_DELAY_MSK)
                  >> PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_DAC_DELAY_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_DAC_DELAY_MSK, PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_DAC_DELAY_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADCOC_DAC_DELAY_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ADCOC_N_ACCUM_CYCLES_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADCOC_N_ACCUM_CYCLES_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_N_ACCUM_CYCLES_set", id, 2);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADCOC_N_ACCUM_CYCLES_set", value, 511);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADCOC_N_ACCUM_CYCLES_set", id, value );

    /* (0x00000038 bits 8:0) bits 0:8 use field ADCOC_N_ACCUM_CYCLES of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    t8_reg_ADC_OC_CFG_1_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_N_ACCUM_CYCLES_MSK,
                                   PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_N_ACCUM_CYCLES_OFF,
                                   value);
}

static INLINE UINT32 t8_field_ADCOC_N_ACCUM_CYCLES_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_N_ACCUM_CYCLES_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_N_ACCUM_CYCLES_get", id, 2);
    /* (0x00000038 bits 8:0) bits 0:8 use field ADCOC_N_ACCUM_CYCLES of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    reg_value = t8_reg_ADC_OC_CFG_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_N_ACCUM_CYCLES_MSK) >> PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_N_ACCUM_CYCLES_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_N_ACCUM_CYCLES_get", id, value );

    return value;
}
static INLINE void t8_field_range_ADCOC_N_ACCUM_CYCLES_set( t8_buffer_t *b_ptr,
                                                            t8_handle_t *h_ptr,
                                                            UINT32 id,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ADCOC_N_ACCUM_CYCLES_set( t8_buffer_t *b_ptr,
                                                            t8_handle_t *h_ptr,
                                                            UINT32 id,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADCOC_N_ACCUM_CYCLES_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADCOC_N_ACCUM_CYCLES_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADCOC_N_ACCUM_CYCLES_set", stop_bit, 8 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADCOC_N_ACCUM_CYCLES_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000038 bits 8:0) bits 0:8 use field ADCOC_N_ACCUM_CYCLES of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000038 bits 8:0) bits 0:8 use field ADCOC_N_ACCUM_CYCLES of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
        t8_reg_ADC_OC_CFG_1_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       subfield_mask << (PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_N_ACCUM_CYCLES_OFF + subfield_offset),
                                       PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_N_ACCUM_CYCLES_OFF + subfield_offset,
                                       value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ADCOC_N_ACCUM_CYCLES_get( t8_buffer_t *b_ptr,
                                                              t8_handle_t *h_ptr,
                                                              UINT32 id,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ADCOC_N_ACCUM_CYCLES_get( t8_buffer_t *b_ptr,
                                                              t8_handle_t *h_ptr,
                                                              UINT32 id,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADCOC_N_ACCUM_CYCLES_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADCOC_N_ACCUM_CYCLES_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADCOC_N_ACCUM_CYCLES_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000038 bits 8:0) bits 0:8 use field ADCOC_N_ACCUM_CYCLES of register PMC_PM20_82_24_REG_ADC_OC_CFG_1 */
    reg_value = t8_reg_ADC_OC_CFG_1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_N_ACCUM_CYCLES_MSK)
                  >> PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_N_ACCUM_CYCLES_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_N_ACCUM_CYCLES_MSK, PM20_82_24_REG_ADC_OC_CFG_1_BIT_ADCOC_N_ACCUM_CYCLES_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADCOC_N_ACCUM_CYCLES_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ADCOC_LINEAR_STEP_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADCOC_LINEAR_STEP_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_LINEAR_STEP_set", id, 2);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADCOC_LINEAR_STEP_set", value, 15);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADCOC_LINEAR_STEP_set", id, value );

    /* (0x0000003c bits 31:28) bits 0:3 use field ADCOC_LINEAR_STEP of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    t8_reg_ADC_OC_CFG_2_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_LINEAR_STEP_MSK,
                                   PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_LINEAR_STEP_OFF,
                                   value);
}

static INLINE UINT32 t8_field_ADCOC_LINEAR_STEP_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_LINEAR_STEP_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_LINEAR_STEP_get", id, 2);
    /* (0x0000003c bits 31:28) bits 0:3 use field ADCOC_LINEAR_STEP of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    reg_value = t8_reg_ADC_OC_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_LINEAR_STEP_MSK) >> PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_LINEAR_STEP_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_LINEAR_STEP_get", id, value );

    return value;
}
static INLINE void t8_field_range_ADCOC_LINEAR_STEP_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ADCOC_LINEAR_STEP_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADCOC_LINEAR_STEP_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADCOC_LINEAR_STEP_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADCOC_LINEAR_STEP_set", stop_bit, 3 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADCOC_LINEAR_STEP_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000003c bits 31:28) bits 0:3 use field ADCOC_LINEAR_STEP of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000003c bits 31:28) bits 0:3 use field ADCOC_LINEAR_STEP of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
        t8_reg_ADC_OC_CFG_2_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       subfield_mask << (PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_LINEAR_STEP_OFF + subfield_offset),
                                       PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_LINEAR_STEP_OFF + subfield_offset,
                                       value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ADCOC_LINEAR_STEP_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ADCOC_LINEAR_STEP_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADCOC_LINEAR_STEP_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADCOC_LINEAR_STEP_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADCOC_LINEAR_STEP_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000003c bits 31:28) bits 0:3 use field ADCOC_LINEAR_STEP of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    reg_value = t8_reg_ADC_OC_CFG_2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_LINEAR_STEP_MSK)
                  >> PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_LINEAR_STEP_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_LINEAR_STEP_MSK, PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_LINEAR_STEP_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADCOC_LINEAR_STEP_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ADCOC_CAL_DELAY_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADCOC_CAL_DELAY_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_CAL_DELAY_set", id, 2);
    if (value > 1023)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADCOC_CAL_DELAY_set", value, 1023);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADCOC_CAL_DELAY_set", id, value );

    /* (0x0000003c bits 27:18) bits 0:9 use field ADCOC_CAL_DELAY of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    t8_reg_ADC_OC_CFG_2_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_CAL_DELAY_MSK,
                                   PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_CAL_DELAY_OFF,
                                   value);
}

static INLINE UINT32 t8_field_ADCOC_CAL_DELAY_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_CAL_DELAY_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_CAL_DELAY_get", id, 2);
    /* (0x0000003c bits 27:18) bits 0:9 use field ADCOC_CAL_DELAY of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    reg_value = t8_reg_ADC_OC_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_CAL_DELAY_MSK) >> PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_CAL_DELAY_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_CAL_DELAY_get", id, value );

    return value;
}
static INLINE void t8_field_range_ADCOC_CAL_DELAY_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ADCOC_CAL_DELAY_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADCOC_CAL_DELAY_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADCOC_CAL_DELAY_set", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADCOC_CAL_DELAY_set", stop_bit, 9 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADCOC_CAL_DELAY_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000003c bits 27:18) bits 0:9 use field ADCOC_CAL_DELAY of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 9) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 9;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000003c bits 27:18) bits 0:9 use field ADCOC_CAL_DELAY of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
        t8_reg_ADC_OC_CFG_2_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       subfield_mask << (PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_CAL_DELAY_OFF + subfield_offset),
                                       PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_CAL_DELAY_OFF + subfield_offset,
                                       value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ADCOC_CAL_DELAY_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ADCOC_CAL_DELAY_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADCOC_CAL_DELAY_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADCOC_CAL_DELAY_get", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADCOC_CAL_DELAY_get", stop_bit, 9 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 9) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 9;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000003c bits 27:18) bits 0:9 use field ADCOC_CAL_DELAY of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    reg_value = t8_reg_ADC_OC_CFG_2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_CAL_DELAY_MSK)
                  >> PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_CAL_DELAY_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_CAL_DELAY_MSK, PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_CAL_DELAY_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADCOC_CAL_DELAY_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ADCOC_MABC_INT_OVR_EN_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADCOC_MABC_INT_OVR_EN_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_MABC_INT_OVR_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADCOC_MABC_INT_OVR_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADCOC_MABC_INT_OVR_EN_set", id, value );

    /* (0x0000003c bits 17) field ADCOC_MABC_INT_OVR_EN of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    t8_reg_ADC_OC_CFG_2_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_MABC_INT_OVR_EN_MSK,
                                   PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_MABC_INT_OVR_EN_OFF,
                                   value);
}

static INLINE UINT32 t8_field_ADCOC_MABC_INT_OVR_EN_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_MABC_INT_OVR_EN_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_MABC_INT_OVR_EN_get", id, 2);
    /* (0x0000003c bits 17) field ADCOC_MABC_INT_OVR_EN of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    reg_value = t8_reg_ADC_OC_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_MABC_INT_OVR_EN_MSK) >> PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_MABC_INT_OVR_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_MABC_INT_OVR_EN_get", id, value );

    return value;
}
static INLINE void t8_field_ADCOC_ADC_WR_OVR_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADCOC_ADC_WR_OVR_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_ADC_WR_OVR_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADCOC_ADC_WR_OVR_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADCOC_ADC_WR_OVR_set", id, value );

    /* (0x0000003c bits 16) field ADCOC_ADC_WR_OVR of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    t8_reg_ADC_OC_CFG_2_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_WR_OVR_MSK,
                                   PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_WR_OVR_OFF,
                                   value);
}

static INLINE UINT32 t8_field_ADCOC_ADC_WR_OVR_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_ADC_WR_OVR_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_ADC_WR_OVR_get", id, 2);
    /* (0x0000003c bits 16) field ADCOC_ADC_WR_OVR of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    reg_value = t8_reg_ADC_OC_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_WR_OVR_MSK) >> PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_WR_OVR_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_ADC_WR_OVR_get", id, value );

    return value;
}
static INLINE void t8_field_ADCOC_ADC_A_OVR_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADCOC_ADC_A_OVR_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_ADC_A_OVR_set", id, 2);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADCOC_ADC_A_OVR_set", value, 255);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADCOC_ADC_A_OVR_set", id, value );

    /* (0x0000003c bits 15:8) bits 0:7 use field ADCOC_ADC_A_OVR of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    t8_reg_ADC_OC_CFG_2_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_A_OVR_MSK,
                                   PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_A_OVR_OFF,
                                   value);
}

static INLINE UINT32 t8_field_ADCOC_ADC_A_OVR_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_ADC_A_OVR_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_ADC_A_OVR_get", id, 2);
    /* (0x0000003c bits 15:8) bits 0:7 use field ADCOC_ADC_A_OVR of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    reg_value = t8_reg_ADC_OC_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_A_OVR_MSK) >> PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_A_OVR_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_ADC_A_OVR_get", id, value );

    return value;
}
static INLINE void t8_field_range_ADCOC_ADC_A_OVR_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ADCOC_ADC_A_OVR_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADCOC_ADC_A_OVR_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADCOC_ADC_A_OVR_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADCOC_ADC_A_OVR_set", stop_bit, 7 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADCOC_ADC_A_OVR_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000003c bits 15:8) bits 0:7 use field ADCOC_ADC_A_OVR of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000003c bits 15:8) bits 0:7 use field ADCOC_ADC_A_OVR of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
        t8_reg_ADC_OC_CFG_2_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       subfield_mask << (PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_A_OVR_OFF + subfield_offset),
                                       PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_A_OVR_OFF + subfield_offset,
                                       value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ADCOC_ADC_A_OVR_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ADCOC_ADC_A_OVR_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADCOC_ADC_A_OVR_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADCOC_ADC_A_OVR_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADCOC_ADC_A_OVR_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000003c bits 15:8) bits 0:7 use field ADCOC_ADC_A_OVR of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    reg_value = t8_reg_ADC_OC_CFG_2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_A_OVR_MSK)
                  >> PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_A_OVR_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_A_OVR_MSK, PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_A_OVR_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADCOC_ADC_A_OVR_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ADCOC_ADC_D_OVR_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADCOC_ADC_D_OVR_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_ADC_D_OVR_set", id, 2);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADCOC_ADC_D_OVR_set", value, 255);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADCOC_ADC_D_OVR_set", id, value );

    /* (0x0000003c bits 7:0) bits 0:7 use field ADCOC_ADC_D_OVR of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    t8_reg_ADC_OC_CFG_2_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_D_OVR_MSK,
                                   PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_D_OVR_OFF,
                                   value);
}

static INLINE UINT32 t8_field_ADCOC_ADC_D_OVR_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_ADC_D_OVR_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_ADC_D_OVR_get", id, 2);
    /* (0x0000003c bits 7:0) bits 0:7 use field ADCOC_ADC_D_OVR of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    reg_value = t8_reg_ADC_OC_CFG_2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_D_OVR_MSK) >> PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_D_OVR_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_ADC_D_OVR_get", id, value );

    return value;
}
static INLINE void t8_field_range_ADCOC_ADC_D_OVR_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ADCOC_ADC_D_OVR_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADCOC_ADC_D_OVR_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADCOC_ADC_D_OVR_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADCOC_ADC_D_OVR_set", stop_bit, 7 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADCOC_ADC_D_OVR_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000003c bits 7:0) bits 0:7 use field ADCOC_ADC_D_OVR of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000003c bits 7:0) bits 0:7 use field ADCOC_ADC_D_OVR of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
        t8_reg_ADC_OC_CFG_2_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       subfield_mask << (PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_D_OVR_OFF + subfield_offset),
                                       PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_D_OVR_OFF + subfield_offset,
                                       value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ADCOC_ADC_D_OVR_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ADCOC_ADC_D_OVR_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADCOC_ADC_D_OVR_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADCOC_ADC_D_OVR_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADCOC_ADC_D_OVR_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000003c bits 7:0) bits 0:7 use field ADCOC_ADC_D_OVR of register PMC_PM20_82_24_REG_ADC_OC_CFG_2 */
    reg_value = t8_reg_ADC_OC_CFG_2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_D_OVR_MSK)
                  >> PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_D_OVR_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_D_OVR_MSK, PM20_82_24_REG_ADC_OC_CFG_2_BIT_ADCOC_ADC_D_OVR_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADCOC_ADC_D_OVR_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_THR_MAP31_0_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_THR_MAP31_0_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_THR_MAP31_0_set", id, 2);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_THR_MAP31_0_set", id, value );

    /* (0x00000040 bits 31:0) bits 0:31 use field THR_MAP31_0 of register PMC_PM20_82_24_REG_ADC_OC_REGISTER3 */
    t8_reg_ADC_OC_REGISTER3_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_ADC_OC_REGISTER3_BIT_THR_MAP31_0_MSK,
                                       PM20_82_24_REG_ADC_OC_REGISTER3_BIT_THR_MAP31_0_OFF,
                                       value);
}

static INLINE UINT32 t8_field_THR_MAP31_0_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_THR_MAP31_0_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_THR_MAP31_0_get", id, 2);
    /* (0x00000040 bits 31:0) bits 0:31 use field THR_MAP31_0 of register PMC_PM20_82_24_REG_ADC_OC_REGISTER3 */
    reg_value = t8_reg_ADC_OC_REGISTER3_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_REGISTER3_BIT_THR_MAP31_0_MSK) >> PM20_82_24_REG_ADC_OC_REGISTER3_BIT_THR_MAP31_0_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_THR_MAP31_0_get", id, value );

    return value;
}
static INLINE void t8_field_range_THR_MAP31_0_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_THR_MAP31_0_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_THR_MAP31_0_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_THR_MAP31_0_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_THR_MAP31_0_set", stop_bit, 31 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_THR_MAP31_0_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000040 bits 31:0) bits 0:31 use field THR_MAP31_0 of register PMC_PM20_82_24_REG_ADC_OC_REGISTER3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000040 bits 31:0) bits 0:31 use field THR_MAP31_0 of register PMC_PM20_82_24_REG_ADC_OC_REGISTER3 */
        t8_reg_ADC_OC_REGISTER3_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           subfield_mask << (PM20_82_24_REG_ADC_OC_REGISTER3_BIT_THR_MAP31_0_OFF + subfield_offset),
                                           PM20_82_24_REG_ADC_OC_REGISTER3_BIT_THR_MAP31_0_OFF + subfield_offset,
                                           value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_THR_MAP31_0_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_THR_MAP31_0_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_THR_MAP31_0_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_THR_MAP31_0_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_THR_MAP31_0_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000040 bits 31:0) bits 0:31 use field THR_MAP31_0 of register PMC_PM20_82_24_REG_ADC_OC_REGISTER3 */
    reg_value = t8_reg_ADC_OC_REGISTER3_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ADC_OC_REGISTER3_BIT_THR_MAP31_0_MSK)
                  >> PM20_82_24_REG_ADC_OC_REGISTER3_BIT_THR_MAP31_0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ADC_OC_REGISTER3_BIT_THR_MAP31_0_MSK, PM20_82_24_REG_ADC_OC_REGISTER3_BIT_THR_MAP31_0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_THR_MAP31_0_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_DSM_DENOM_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DSM_DENOM_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DSM_DENOM_set", id, 2);
    if (value > 16383)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DSM_DENOM_set", value, 16383);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DSM_DENOM_set", id, value );

    /* (0x00000048 bits 29:16) field DSM_DENOM of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG1 */
    t8_reg_PMM_WRAP_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_DENOM_MSK,
                                         PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_DENOM_OFF,
                                         value);
}

static INLINE UINT32 t8_field_DSM_DENOM_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DSM_DENOM_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DSM_DENOM_get", id, 2);
    /* (0x00000048 bits 29:16) field DSM_DENOM of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG1 */
    reg_value = t8_reg_PMM_WRAP_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_DENOM_MSK) >> PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_DENOM_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DSM_DENOM_get", id, value );

    return value;
}
static INLINE void t8_field_range_DSM_DENOM_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 start_bit,
                                                 UINT32 stop_bit,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_DSM_DENOM_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 start_bit,
                                                 UINT32 stop_bit,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_DSM_DENOM_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_DSM_DENOM_set", stop_bit, start_bit );
    if (stop_bit > 13) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_DSM_DENOM_set", stop_bit, 13 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_DSM_DENOM_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000048 bits 29:16) field DSM_DENOM of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 13) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 13;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000048 bits 29:16) field DSM_DENOM of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG1 */
        t8_reg_PMM_WRAP_CNFG_REG1_field_set( b_ptr,
                                             h_ptr,
                                             id,
                                             subfield_mask << (PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_DENOM_OFF + subfield_offset),
                                             PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_DENOM_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_DSM_DENOM_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_DSM_DENOM_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_DSM_DENOM_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_DSM_DENOM_get", stop_bit, start_bit );
    if (stop_bit > 13) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_DSM_DENOM_get", stop_bit, 13 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 13) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 13;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000048 bits 29:16) field DSM_DENOM of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG1 */
    reg_value = t8_reg_PMM_WRAP_CNFG_REG1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_DENOM_MSK)
                  >> PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_DENOM_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_DENOM_MSK, PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_DENOM_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_DSM_DENOM_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_DSM_TYPE_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DSM_TYPE_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DSM_TYPE_set", id, 2);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DSM_TYPE_set", value, 3);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DSM_TYPE_set", id, value );

    /* (0x00000048 bits 1:0) field DSM_TYPE of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG1 */
    t8_reg_PMM_WRAP_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_TYPE_MSK,
                                         PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_TYPE_OFF,
                                         value);
}

static INLINE UINT32 t8_field_DSM_TYPE_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DSM_TYPE_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DSM_TYPE_get", id, 2);
    /* (0x00000048 bits 1:0) field DSM_TYPE of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG1 */
    reg_value = t8_reg_PMM_WRAP_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_TYPE_MSK) >> PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_TYPE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DSM_TYPE_get", id, value );

    return value;
}
static INLINE void t8_field_range_DSM_TYPE_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_DSM_TYPE_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_DSM_TYPE_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_DSM_TYPE_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_DSM_TYPE_set", stop_bit, 1 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_DSM_TYPE_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000048 bits 1:0) field DSM_TYPE of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000048 bits 1:0) field DSM_TYPE of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG1 */
        t8_reg_PMM_WRAP_CNFG_REG1_field_set( b_ptr,
                                             h_ptr,
                                             id,
                                             subfield_mask << (PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_TYPE_OFF + subfield_offset),
                                             PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_TYPE_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_DSM_TYPE_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_DSM_TYPE_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_DSM_TYPE_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_DSM_TYPE_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_DSM_TYPE_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000048 bits 1:0) field DSM_TYPE of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG1 */
    reg_value = t8_reg_PMM_WRAP_CNFG_REG1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_TYPE_MSK)
                  >> PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_TYPE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_TYPE_MSK, PM20_82_24_REG_PMM_WRAP_CNFG_REG1_BIT_DSM_TYPE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_DSM_TYPE_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PMM_WRAP_EN_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PMM_WRAP_EN_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PMM_WRAP_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PMM_WRAP_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PMM_WRAP_EN_set", id, value );

    /* (0x0000004c bits 31) field PMM_WRAP_EN of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2 */
    t8_reg_PMM_WRAP_CNFG_REG2_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PMM_WRAP_EN_MSK,
                                         PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PMM_WRAP_EN_OFF,
                                         value);
}

static INLINE UINT32 t8_field_PMM_WRAP_EN_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PMM_WRAP_EN_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PMM_WRAP_EN_get", id, 2);
    /* (0x0000004c bits 31) field PMM_WRAP_EN of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2 */
    reg_value = t8_reg_PMM_WRAP_CNFG_REG2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PMM_WRAP_EN_MSK) >> PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PMM_WRAP_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PMM_WRAP_EN_get", id, value );

    return value;
}
static INLINE void t8_field_PKT_SIZE_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PKT_SIZE_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PKT_SIZE_set", id, 2);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PKT_SIZE_set", value, 511);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PKT_SIZE_set", id, value );

    /* (0x0000004c bits 24:16) field PKT_SIZE of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2 */
    t8_reg_PMM_WRAP_CNFG_REG2_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_SIZE_MSK,
                                         PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_SIZE_OFF,
                                         value);
}

static INLINE UINT32 t8_field_PKT_SIZE_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PKT_SIZE_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PKT_SIZE_get", id, 2);
    /* (0x0000004c bits 24:16) field PKT_SIZE of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2 */
    reg_value = t8_reg_PMM_WRAP_CNFG_REG2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_SIZE_MSK) >> PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_SIZE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PKT_SIZE_get", id, value );

    return value;
}
static INLINE void t8_field_range_PKT_SIZE_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PKT_SIZE_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PKT_SIZE_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PKT_SIZE_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PKT_SIZE_set", stop_bit, 8 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PKT_SIZE_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000004c bits 24:16) field PKT_SIZE of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000004c bits 24:16) field PKT_SIZE of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2 */
        t8_reg_PMM_WRAP_CNFG_REG2_field_set( b_ptr,
                                             h_ptr,
                                             id,
                                             subfield_mask << (PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_SIZE_OFF + subfield_offset),
                                             PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_SIZE_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PKT_SIZE_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PKT_SIZE_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PKT_SIZE_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PKT_SIZE_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PKT_SIZE_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000004c bits 24:16) field PKT_SIZE of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2 */
    reg_value = t8_reg_PMM_WRAP_CNFG_REG2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_SIZE_MSK)
                  >> PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_SIZE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_SIZE_MSK, PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_SIZE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PKT_SIZE_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PKT_PERIOD_set( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PKT_PERIOD_set( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PKT_PERIOD_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PKT_PERIOD_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PKT_PERIOD_set", id, value );

    /* (0x0000004c bits 15:0) field PKT_PERIOD of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2 */
    t8_reg_PMM_WRAP_CNFG_REG2_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_PERIOD_MSK,
                                         PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_PERIOD_OFF,
                                         value);
}

static INLINE UINT32 t8_field_PKT_PERIOD_get( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PKT_PERIOD_get( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PKT_PERIOD_get", id, 2);
    /* (0x0000004c bits 15:0) field PKT_PERIOD of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2 */
    reg_value = t8_reg_PMM_WRAP_CNFG_REG2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_PERIOD_MSK) >> PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_PERIOD_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PKT_PERIOD_get", id, value );

    return value;
}
static INLINE void t8_field_range_PKT_PERIOD_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PKT_PERIOD_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PKT_PERIOD_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PKT_PERIOD_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PKT_PERIOD_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PKT_PERIOD_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000004c bits 15:0) field PKT_PERIOD of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000004c bits 15:0) field PKT_PERIOD of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2 */
        t8_reg_PMM_WRAP_CNFG_REG2_field_set( b_ptr,
                                             h_ptr,
                                             id,
                                             subfield_mask << (PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_PERIOD_OFF + subfield_offset),
                                             PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_PERIOD_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PKT_PERIOD_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PKT_PERIOD_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PKT_PERIOD_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PKT_PERIOD_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PKT_PERIOD_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000004c bits 15:0) field PKT_PERIOD of register PMC_PM20_82_24_REG_PMM_WRAP_CNFG_REG2 */
    reg_value = t8_reg_PMM_WRAP_CNFG_REG2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_PERIOD_MSK)
                  >> PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_PERIOD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_PERIOD_MSK, PM20_82_24_REG_PMM_WRAP_CNFG_REG2_BIT_PKT_PERIOD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PKT_PERIOD_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_SIPO_DIV_RATIO_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_SIPO_DIV_RATIO_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_SIPO_DIV_RATIO_set", id, 2);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_SIPO_DIV_RATIO_set", value, 3);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_SIPO_DIV_RATIO_set", id, value );

    /* (0x00000050 bits 2:1) field SIPO_DIV_RATIO of register PMC_PM20_82_24_REG_SIPO_CNFG_REG */
    t8_reg_SIPO_CNFG_REG_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_SIPO_CNFG_REG_BIT_SIPO_DIV_RATIO_MSK,
                                    PM20_82_24_REG_SIPO_CNFG_REG_BIT_SIPO_DIV_RATIO_OFF,
                                    value);
}

static INLINE UINT32 t8_field_SIPO_DIV_RATIO_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_SIPO_DIV_RATIO_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_SIPO_DIV_RATIO_get", id, 2);
    /* (0x00000050 bits 2:1) field SIPO_DIV_RATIO of register PMC_PM20_82_24_REG_SIPO_CNFG_REG */
    reg_value = t8_reg_SIPO_CNFG_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_SIPO_CNFG_REG_BIT_SIPO_DIV_RATIO_MSK) >> PM20_82_24_REG_SIPO_CNFG_REG_BIT_SIPO_DIV_RATIO_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_SIPO_DIV_RATIO_get", id, value );

    return value;
}
static INLINE void t8_field_range_SIPO_DIV_RATIO_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_SIPO_DIV_RATIO_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit,
                                                      UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_SIPO_DIV_RATIO_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_SIPO_DIV_RATIO_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_SIPO_DIV_RATIO_set", stop_bit, 1 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_SIPO_DIV_RATIO_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000050 bits 2:1) field SIPO_DIV_RATIO of register PMC_PM20_82_24_REG_SIPO_CNFG_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000050 bits 2:1) field SIPO_DIV_RATIO of register PMC_PM20_82_24_REG_SIPO_CNFG_REG */
        t8_reg_SIPO_CNFG_REG_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        subfield_mask << (PM20_82_24_REG_SIPO_CNFG_REG_BIT_SIPO_DIV_RATIO_OFF + subfield_offset),
                                        PM20_82_24_REG_SIPO_CNFG_REG_BIT_SIPO_DIV_RATIO_OFF + subfield_offset,
                                        value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_SIPO_DIV_RATIO_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_SIPO_DIV_RATIO_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_SIPO_DIV_RATIO_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_SIPO_DIV_RATIO_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_SIPO_DIV_RATIO_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000050 bits 2:1) field SIPO_DIV_RATIO of register PMC_PM20_82_24_REG_SIPO_CNFG_REG */
    reg_value = t8_reg_SIPO_CNFG_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_SIPO_CNFG_REG_BIT_SIPO_DIV_RATIO_MSK)
                  >> PM20_82_24_REG_SIPO_CNFG_REG_BIT_SIPO_DIV_RATIO_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_SIPO_CNFG_REG_BIT_SIPO_DIV_RATIO_MSK, PM20_82_24_REG_SIPO_CNFG_REG_BIT_SIPO_DIV_RATIO_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_SIPO_DIV_RATIO_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_SIPO_BUS_WIDTH_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_SIPO_BUS_WIDTH_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_SIPO_BUS_WIDTH_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_SIPO_BUS_WIDTH_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_SIPO_BUS_WIDTH_set", id, value );

    /* (0x00000050 bits 0) field SIPO_BUS_WIDTH of register PMC_PM20_82_24_REG_SIPO_CNFG_REG */
    t8_reg_SIPO_CNFG_REG_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_SIPO_CNFG_REG_BIT_SIPO_BUS_WIDTH_MSK,
                                    PM20_82_24_REG_SIPO_CNFG_REG_BIT_SIPO_BUS_WIDTH_OFF,
                                    value);
}

static INLINE UINT32 t8_field_SIPO_BUS_WIDTH_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_SIPO_BUS_WIDTH_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_SIPO_BUS_WIDTH_get", id, 2);
    /* (0x00000050 bits 0) field SIPO_BUS_WIDTH of register PMC_PM20_82_24_REG_SIPO_CNFG_REG */
    reg_value = t8_reg_SIPO_CNFG_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_SIPO_CNFG_REG_BIT_SIPO_BUS_WIDTH_MSK) >> PM20_82_24_REG_SIPO_CNFG_REG_BIT_SIPO_BUS_WIDTH_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_SIPO_BUS_WIDTH_get", id, value );

    return value;
}
static INLINE void t8_field_PISO_DIV_RATIO_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PISO_DIV_RATIO_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_DIV_RATIO_set", id, 2);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PISO_DIV_RATIO_set", value, 3);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PISO_DIV_RATIO_set", id, value );

    /* (0x00000054 bits 2:1) field PISO_DIV_RATIO of register PMC_PM20_82_24_REG_PISO_CNFG_REG */
    t8_reg_PISO_CNFG_REG_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_PISO_CNFG_REG_BIT_PISO_DIV_RATIO_MSK,
                                    PM20_82_24_REG_PISO_CNFG_REG_BIT_PISO_DIV_RATIO_OFF,
                                    value);
}

static INLINE UINT32 t8_field_PISO_DIV_RATIO_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PISO_DIV_RATIO_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_DIV_RATIO_get", id, 2);
    /* (0x00000054 bits 2:1) field PISO_DIV_RATIO of register PMC_PM20_82_24_REG_PISO_CNFG_REG */
    reg_value = t8_reg_PISO_CNFG_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PISO_CNFG_REG_BIT_PISO_DIV_RATIO_MSK) >> PM20_82_24_REG_PISO_CNFG_REG_BIT_PISO_DIV_RATIO_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PISO_DIV_RATIO_get", id, value );

    return value;
}
static INLINE void t8_field_range_PISO_DIV_RATIO_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PISO_DIV_RATIO_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit,
                                                      UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PISO_DIV_RATIO_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PISO_DIV_RATIO_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PISO_DIV_RATIO_set", stop_bit, 1 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PISO_DIV_RATIO_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000054 bits 2:1) field PISO_DIV_RATIO of register PMC_PM20_82_24_REG_PISO_CNFG_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000054 bits 2:1) field PISO_DIV_RATIO of register PMC_PM20_82_24_REG_PISO_CNFG_REG */
        t8_reg_PISO_CNFG_REG_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        subfield_mask << (PM20_82_24_REG_PISO_CNFG_REG_BIT_PISO_DIV_RATIO_OFF + subfield_offset),
                                        PM20_82_24_REG_PISO_CNFG_REG_BIT_PISO_DIV_RATIO_OFF + subfield_offset,
                                        value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PISO_DIV_RATIO_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PISO_DIV_RATIO_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PISO_DIV_RATIO_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PISO_DIV_RATIO_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PISO_DIV_RATIO_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000054 bits 2:1) field PISO_DIV_RATIO of register PMC_PM20_82_24_REG_PISO_CNFG_REG */
    reg_value = t8_reg_PISO_CNFG_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PISO_CNFG_REG_BIT_PISO_DIV_RATIO_MSK)
                  >> PM20_82_24_REG_PISO_CNFG_REG_BIT_PISO_DIV_RATIO_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PISO_CNFG_REG_BIT_PISO_DIV_RATIO_MSK, PM20_82_24_REG_PISO_CNFG_REG_BIT_PISO_DIV_RATIO_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PISO_DIV_RATIO_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PISO_BUS_WIDTH_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PISO_BUS_WIDTH_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_BUS_WIDTH_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PISO_BUS_WIDTH_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PISO_BUS_WIDTH_set", id, value );

    /* (0x00000054 bits 0) field PISO_BUS_WIDTH of register PMC_PM20_82_24_REG_PISO_CNFG_REG */
    t8_reg_PISO_CNFG_REG_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_PISO_CNFG_REG_BIT_PISO_BUS_WIDTH_MSK,
                                    PM20_82_24_REG_PISO_CNFG_REG_BIT_PISO_BUS_WIDTH_OFF,
                                    value);
}

static INLINE UINT32 t8_field_PISO_BUS_WIDTH_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PISO_BUS_WIDTH_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_BUS_WIDTH_get", id, 2);
    /* (0x00000054 bits 0) field PISO_BUS_WIDTH of register PMC_PM20_82_24_REG_PISO_CNFG_REG */
    reg_value = t8_reg_PISO_CNFG_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PISO_CNFG_REG_BIT_PISO_BUS_WIDTH_MSK) >> PM20_82_24_REG_PISO_CNFG_REG_BIT_PISO_BUS_WIDTH_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PISO_BUS_WIDTH_get", id, value );

    return value;
}
static INLINE void t8_field_PCBI_TX_DPENI1_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PCBI_TX_DPENI1_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PCBI_TX_DPENI1_set", id, 2);
    if (value > 63)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PCBI_TX_DPENI1_set", value, 63);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PCBI_TX_DPENI1_set", id, value );

    /* (0x00000058 bits 31:26) bits 0:5 use field PCBI_TX_DPENI1 of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_1 */
    t8_reg_TX_CNTRL_OVERRIDE_1_field_set( b_ptr,
                                          h_ptr,
                                          id,
                                          PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI1_MSK,
                                          PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI1_OFF,
                                          value);
}

static INLINE UINT32 t8_field_PCBI_TX_DPENI1_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PCBI_TX_DPENI1_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PCBI_TX_DPENI1_get", id, 2);
    /* (0x00000058 bits 31:26) bits 0:5 use field PCBI_TX_DPENI1 of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_1 */
    reg_value = t8_reg_TX_CNTRL_OVERRIDE_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI1_MSK) >> PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI1_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PCBI_TX_DPENI1_get", id, value );

    return value;
}
static INLINE void t8_field_range_PCBI_TX_DPENI1_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PCBI_TX_DPENI1_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit,
                                                      UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PCBI_TX_DPENI1_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PCBI_TX_DPENI1_set", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PCBI_TX_DPENI1_set", stop_bit, 5 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PCBI_TX_DPENI1_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000058 bits 31:26) bits 0:5 use field PCBI_TX_DPENI1 of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 5) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 5;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000058 bits 31:26) bits 0:5 use field PCBI_TX_DPENI1 of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_1 */
        t8_reg_TX_CNTRL_OVERRIDE_1_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              subfield_mask << (PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI1_OFF + subfield_offset),
                                              PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI1_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PCBI_TX_DPENI1_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PCBI_TX_DPENI1_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PCBI_TX_DPENI1_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PCBI_TX_DPENI1_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PCBI_TX_DPENI1_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000058 bits 31:26) bits 0:5 use field PCBI_TX_DPENI1 of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_1 */
    reg_value = t8_reg_TX_CNTRL_OVERRIDE_1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI1_MSK)
                  >> PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI1_MSK, PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PCBI_TX_DPENI1_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PCBI_TX_DPENI2_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PCBI_TX_DPENI2_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PCBI_TX_DPENI2_set", id, 2);
    if (value > 63)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PCBI_TX_DPENI2_set", value, 63);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PCBI_TX_DPENI2_set", id, value );

    /* (0x00000058 bits 25:20) bits 0:5 use field PCBI_TX_DPENI2 of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_1 */
    t8_reg_TX_CNTRL_OVERRIDE_1_field_set( b_ptr,
                                          h_ptr,
                                          id,
                                          PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI2_MSK,
                                          PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI2_OFF,
                                          value);
}

static INLINE UINT32 t8_field_PCBI_TX_DPENI2_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PCBI_TX_DPENI2_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PCBI_TX_DPENI2_get", id, 2);
    /* (0x00000058 bits 25:20) bits 0:5 use field PCBI_TX_DPENI2 of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_1 */
    reg_value = t8_reg_TX_CNTRL_OVERRIDE_1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI2_MSK) >> PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI2_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PCBI_TX_DPENI2_get", id, value );

    return value;
}
static INLINE void t8_field_range_PCBI_TX_DPENI2_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PCBI_TX_DPENI2_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit,
                                                      UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PCBI_TX_DPENI2_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PCBI_TX_DPENI2_set", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PCBI_TX_DPENI2_set", stop_bit, 5 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PCBI_TX_DPENI2_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000058 bits 25:20) bits 0:5 use field PCBI_TX_DPENI2 of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 5) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 5;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000058 bits 25:20) bits 0:5 use field PCBI_TX_DPENI2 of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_1 */
        t8_reg_TX_CNTRL_OVERRIDE_1_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              subfield_mask << (PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI2_OFF + subfield_offset),
                                              PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI2_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PCBI_TX_DPENI2_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PCBI_TX_DPENI2_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PCBI_TX_DPENI2_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PCBI_TX_DPENI2_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PCBI_TX_DPENI2_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000058 bits 25:20) bits 0:5 use field PCBI_TX_DPENI2 of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_1 */
    reg_value = t8_reg_TX_CNTRL_OVERRIDE_1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI2_MSK)
                  >> PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI2_MSK, PM20_82_24_REG_TX_CNTRL_OVERRIDE_1_BIT_PCBI_TX_DPENI2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PCBI_TX_DPENI2_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_TX_WIZARD_EN_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TX_WIZARD_EN_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_WIZARD_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TX_WIZARD_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TX_WIZARD_EN_set", id, value );

    /* (0x00000068 bits 19) field TX_WIZARD_EN of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_REG_5 */
    t8_reg_TX_CNTRL_OVERRIDE_REG_5_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              PM20_82_24_REG_TX_CNTRL_OVERRIDE_REG_5_BIT_TX_WIZARD_EN_MSK,
                                              PM20_82_24_REG_TX_CNTRL_OVERRIDE_REG_5_BIT_TX_WIZARD_EN_OFF,
                                              value);
}

static INLINE UINT32 t8_field_TX_WIZARD_EN_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TX_WIZARD_EN_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_WIZARD_EN_get", id, 2);
    /* (0x00000068 bits 19) field TX_WIZARD_EN of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_REG_5 */
    reg_value = t8_reg_TX_CNTRL_OVERRIDE_REG_5_read( b_ptr,
                                                     h_ptr,
                                                     id);
    value = (reg_value & PM20_82_24_REG_TX_CNTRL_OVERRIDE_REG_5_BIT_TX_WIZARD_EN_MSK) >> PM20_82_24_REG_TX_CNTRL_OVERRIDE_REG_5_BIT_TX_WIZARD_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TX_WIZARD_EN_get", id, value );

    return value;
}
static INLINE void t8_field_CM_CLK_DIV_FACT_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CM_CLK_DIV_FACT_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CM_CLK_DIV_FACT_set", id, 2);
    if (value > 127)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CM_CLK_DIV_FACT_set", value, 127);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CM_CLK_DIV_FACT_set", id, value );

    /* (0x0000006c bits 31:25) bits 0:6 use field CM_CLK_DIV_FACT of register PMC_PM20_82_24_REG_CLK_DIV_FACT */
    t8_reg_CLK_DIV_FACT_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_CLK_DIV_FACT_BIT_CM_CLK_DIV_FACT_MSK,
                                   PM20_82_24_REG_CLK_DIV_FACT_BIT_CM_CLK_DIV_FACT_OFF,
                                   value);
}

static INLINE UINT32 t8_field_CM_CLK_DIV_FACT_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CM_CLK_DIV_FACT_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CM_CLK_DIV_FACT_get", id, 2);
    /* (0x0000006c bits 31:25) bits 0:6 use field CM_CLK_DIV_FACT of register PMC_PM20_82_24_REG_CLK_DIV_FACT */
    reg_value = t8_reg_CLK_DIV_FACT_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_CLK_DIV_FACT_BIT_CM_CLK_DIV_FACT_MSK) >> PM20_82_24_REG_CLK_DIV_FACT_BIT_CM_CLK_DIV_FACT_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CM_CLK_DIV_FACT_get", id, value );

    return value;
}
static INLINE void t8_field_range_CM_CLK_DIV_FACT_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_CM_CLK_DIV_FACT_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CM_CLK_DIV_FACT_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CM_CLK_DIV_FACT_set", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CM_CLK_DIV_FACT_set", stop_bit, 6 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CM_CLK_DIV_FACT_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000006c bits 31:25) bits 0:6 use field CM_CLK_DIV_FACT of register PMC_PM20_82_24_REG_CLK_DIV_FACT */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 6) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 6;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000006c bits 31:25) bits 0:6 use field CM_CLK_DIV_FACT of register PMC_PM20_82_24_REG_CLK_DIV_FACT */
        t8_reg_CLK_DIV_FACT_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       subfield_mask << (PM20_82_24_REG_CLK_DIV_FACT_BIT_CM_CLK_DIV_FACT_OFF + subfield_offset),
                                       PM20_82_24_REG_CLK_DIV_FACT_BIT_CM_CLK_DIV_FACT_OFF + subfield_offset,
                                       value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_CM_CLK_DIV_FACT_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_CM_CLK_DIV_FACT_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CM_CLK_DIV_FACT_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CM_CLK_DIV_FACT_get", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CM_CLK_DIV_FACT_get", stop_bit, 6 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 6) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 6;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000006c bits 31:25) bits 0:6 use field CM_CLK_DIV_FACT of register PMC_PM20_82_24_REG_CLK_DIV_FACT */
    reg_value = t8_reg_CLK_DIV_FACT_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_CLK_DIV_FACT_BIT_CM_CLK_DIV_FACT_MSK)
                  >> PM20_82_24_REG_CLK_DIV_FACT_BIT_CM_CLK_DIV_FACT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_CLK_DIV_FACT_BIT_CM_CLK_DIV_FACT_MSK, PM20_82_24_REG_CLK_DIV_FACT_BIT_CM_CLK_DIV_FACT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CM_CLK_DIV_FACT_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ADC_CLK_DIV_FACT_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADC_CLK_DIV_FACT_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_CLK_DIV_FACT_set", id, 2);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADC_CLK_DIV_FACT_set", value, 15);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADC_CLK_DIV_FACT_set", id, value );

    /* (0x0000006c bits 23:20) bits 0:3 use field ADC_CLK_DIV_FACT of register PMC_PM20_82_24_REG_CLK_DIV_FACT */
    t8_reg_CLK_DIV_FACT_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_CLK_DIV_FACT_BIT_ADC_CLK_DIV_FACT_MSK,
                                   PM20_82_24_REG_CLK_DIV_FACT_BIT_ADC_CLK_DIV_FACT_OFF,
                                   value);
}

static INLINE UINT32 t8_field_ADC_CLK_DIV_FACT_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADC_CLK_DIV_FACT_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_CLK_DIV_FACT_get", id, 2);
    /* (0x0000006c bits 23:20) bits 0:3 use field ADC_CLK_DIV_FACT of register PMC_PM20_82_24_REG_CLK_DIV_FACT */
    reg_value = t8_reg_CLK_DIV_FACT_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_CLK_DIV_FACT_BIT_ADC_CLK_DIV_FACT_MSK) >> PM20_82_24_REG_CLK_DIV_FACT_BIT_ADC_CLK_DIV_FACT_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADC_CLK_DIV_FACT_get", id, value );

    return value;
}
static INLINE void t8_field_range_ADC_CLK_DIV_FACT_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ADC_CLK_DIV_FACT_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADC_CLK_DIV_FACT_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADC_CLK_DIV_FACT_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADC_CLK_DIV_FACT_set", stop_bit, 3 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADC_CLK_DIV_FACT_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000006c bits 23:20) bits 0:3 use field ADC_CLK_DIV_FACT of register PMC_PM20_82_24_REG_CLK_DIV_FACT */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000006c bits 23:20) bits 0:3 use field ADC_CLK_DIV_FACT of register PMC_PM20_82_24_REG_CLK_DIV_FACT */
        t8_reg_CLK_DIV_FACT_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       subfield_mask << (PM20_82_24_REG_CLK_DIV_FACT_BIT_ADC_CLK_DIV_FACT_OFF + subfield_offset),
                                       PM20_82_24_REG_CLK_DIV_FACT_BIT_ADC_CLK_DIV_FACT_OFF + subfield_offset,
                                       value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ADC_CLK_DIV_FACT_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ADC_CLK_DIV_FACT_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADC_CLK_DIV_FACT_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADC_CLK_DIV_FACT_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADC_CLK_DIV_FACT_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000006c bits 23:20) bits 0:3 use field ADC_CLK_DIV_FACT of register PMC_PM20_82_24_REG_CLK_DIV_FACT */
    reg_value = t8_reg_CLK_DIV_FACT_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_CLK_DIV_FACT_BIT_ADC_CLK_DIV_FACT_MSK)
                  >> PM20_82_24_REG_CLK_DIV_FACT_BIT_ADC_CLK_DIV_FACT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_CLK_DIV_FACT_BIT_ADC_CLK_DIV_FACT_MSK, PM20_82_24_REG_CLK_DIV_FACT_BIT_ADC_CLK_DIV_FACT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADC_CLK_DIV_FACT_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_CLK800_DIV_FACT_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CLK800_DIV_FACT_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CLK800_DIV_FACT_set", id, 2);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CLK800_DIV_FACT_set", value, 15);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CLK800_DIV_FACT_set", id, value );

    /* (0x0000006c bits 19:16) bits 0:3 use field CLK800_DIV_FACT of register PMC_PM20_82_24_REG_CLK_DIV_FACT */
    t8_reg_CLK_DIV_FACT_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   PM20_82_24_REG_CLK_DIV_FACT_BIT_CLK800_DIV_FACT_MSK,
                                   PM20_82_24_REG_CLK_DIV_FACT_BIT_CLK800_DIV_FACT_OFF,
                                   value);
}

static INLINE UINT32 t8_field_CLK800_DIV_FACT_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CLK800_DIV_FACT_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CLK800_DIV_FACT_get", id, 2);
    /* (0x0000006c bits 19:16) bits 0:3 use field CLK800_DIV_FACT of register PMC_PM20_82_24_REG_CLK_DIV_FACT */
    reg_value = t8_reg_CLK_DIV_FACT_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_CLK_DIV_FACT_BIT_CLK800_DIV_FACT_MSK) >> PM20_82_24_REG_CLK_DIV_FACT_BIT_CLK800_DIV_FACT_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CLK800_DIV_FACT_get", id, value );

    return value;
}
static INLINE void t8_field_range_CLK800_DIV_FACT_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_CLK800_DIV_FACT_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CLK800_DIV_FACT_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CLK800_DIV_FACT_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CLK800_DIV_FACT_set", stop_bit, 3 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CLK800_DIV_FACT_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000006c bits 19:16) bits 0:3 use field CLK800_DIV_FACT of register PMC_PM20_82_24_REG_CLK_DIV_FACT */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000006c bits 19:16) bits 0:3 use field CLK800_DIV_FACT of register PMC_PM20_82_24_REG_CLK_DIV_FACT */
        t8_reg_CLK_DIV_FACT_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       subfield_mask << (PM20_82_24_REG_CLK_DIV_FACT_BIT_CLK800_DIV_FACT_OFF + subfield_offset),
                                       PM20_82_24_REG_CLK_DIV_FACT_BIT_CLK800_DIV_FACT_OFF + subfield_offset,
                                       value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_CLK800_DIV_FACT_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_CLK800_DIV_FACT_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CLK800_DIV_FACT_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CLK800_DIV_FACT_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CLK800_DIV_FACT_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000006c bits 19:16) bits 0:3 use field CLK800_DIV_FACT of register PMC_PM20_82_24_REG_CLK_DIV_FACT */
    reg_value = t8_reg_CLK_DIV_FACT_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_CLK_DIV_FACT_BIT_CLK800_DIV_FACT_MSK)
                  >> PM20_82_24_REG_CLK_DIV_FACT_BIT_CLK800_DIV_FACT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_CLK_DIV_FACT_BIT_CLK800_DIV_FACT_MSK, PM20_82_24_REG_CLK_DIV_FACT_BIT_CLK800_DIV_FACT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CLK800_DIV_FACT_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PCBI_TX_DENI_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PCBI_TX_DENI_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PCBI_TX_DENI_set", id, 2);
    if (value > 131071)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PCBI_TX_DENI_set", value, 131071);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PCBI_TX_DENI_set", id, value );

    /* (0x00000070 bits 31:15) field PCBI_TX_DENI of register PMC_PM20_82_24_REG_DEGLITCHER_EN */
    t8_reg_DEGLITCHER_EN_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_DEGLITCHER_EN_BIT_PCBI_TX_DENI_MSK,
                                    PM20_82_24_REG_DEGLITCHER_EN_BIT_PCBI_TX_DENI_OFF,
                                    value);
}

static INLINE UINT32 t8_field_PCBI_TX_DENI_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PCBI_TX_DENI_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PCBI_TX_DENI_get", id, 2);
    /* (0x00000070 bits 31:15) field PCBI_TX_DENI of register PMC_PM20_82_24_REG_DEGLITCHER_EN */
    reg_value = t8_reg_DEGLITCHER_EN_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DEGLITCHER_EN_BIT_PCBI_TX_DENI_MSK) >> PM20_82_24_REG_DEGLITCHER_EN_BIT_PCBI_TX_DENI_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PCBI_TX_DENI_get", id, value );

    return value;
}
static INLINE void t8_field_range_PCBI_TX_DENI_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PCBI_TX_DENI_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PCBI_TX_DENI_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PCBI_TX_DENI_set", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PCBI_TX_DENI_set", stop_bit, 16 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PCBI_TX_DENI_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000070 bits 31:15) field PCBI_TX_DENI of register PMC_PM20_82_24_REG_DEGLITCHER_EN */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 16) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 16;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000070 bits 31:15) field PCBI_TX_DENI of register PMC_PM20_82_24_REG_DEGLITCHER_EN */
        t8_reg_DEGLITCHER_EN_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        subfield_mask << (PM20_82_24_REG_DEGLITCHER_EN_BIT_PCBI_TX_DENI_OFF + subfield_offset),
                                        PM20_82_24_REG_DEGLITCHER_EN_BIT_PCBI_TX_DENI_OFF + subfield_offset,
                                        value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PCBI_TX_DENI_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PCBI_TX_DENI_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PCBI_TX_DENI_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PCBI_TX_DENI_get", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PCBI_TX_DENI_get", stop_bit, 16 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 16) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 16;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000070 bits 31:15) field PCBI_TX_DENI of register PMC_PM20_82_24_REG_DEGLITCHER_EN */
    reg_value = t8_reg_DEGLITCHER_EN_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_DEGLITCHER_EN_BIT_PCBI_TX_DENI_MSK)
                  >> PM20_82_24_REG_DEGLITCHER_EN_BIT_PCBI_TX_DENI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_DEGLITCHER_EN_BIT_PCBI_TX_DENI_MSK, PM20_82_24_REG_DEGLITCHER_EN_BIT_PCBI_TX_DENI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PCBI_TX_DENI_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_TPCOUT_DEGLITCH_EN_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TPCOUT_DEGLITCH_EN_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TPCOUT_DEGLITCH_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TPCOUT_DEGLITCH_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TPCOUT_DEGLITCH_EN_set", id, value );

    /* (0x00000070 bits 2) field TPCOUT_DEGLITCH_EN of register PMC_PM20_82_24_REG_DEGLITCHER_EN */
    t8_reg_DEGLITCHER_EN_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_DEGLITCHER_EN_BIT_TPCOUT_DEGLITCH_EN_MSK,
                                    PM20_82_24_REG_DEGLITCHER_EN_BIT_TPCOUT_DEGLITCH_EN_OFF,
                                    value);
}

static INLINE UINT32 t8_field_TPCOUT_DEGLITCH_EN_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TPCOUT_DEGLITCH_EN_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TPCOUT_DEGLITCH_EN_get", id, 2);
    /* (0x00000070 bits 2) field TPCOUT_DEGLITCH_EN of register PMC_PM20_82_24_REG_DEGLITCHER_EN */
    reg_value = t8_reg_DEGLITCHER_EN_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DEGLITCHER_EN_BIT_TPCOUT_DEGLITCH_EN_MSK) >> PM20_82_24_REG_DEGLITCHER_EN_BIT_TPCOUT_DEGLITCH_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TPCOUT_DEGLITCH_EN_get", id, value );

    return value;
}
static INLINE void t8_field_BADJ_CLK_DEGLITCH_EN_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_BADJ_CLK_DEGLITCH_EN_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_BADJ_CLK_DEGLITCH_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_BADJ_CLK_DEGLITCH_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_BADJ_CLK_DEGLITCH_EN_set", id, value );

    /* (0x00000070 bits 1) field BADJ_CLK_DEGLITCH_EN of register PMC_PM20_82_24_REG_DEGLITCHER_EN */
    t8_reg_DEGLITCHER_EN_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_DEGLITCHER_EN_BIT_BADJ_CLK_DEGLITCH_EN_MSK,
                                    PM20_82_24_REG_DEGLITCHER_EN_BIT_BADJ_CLK_DEGLITCH_EN_OFF,
                                    value);
}

static INLINE UINT32 t8_field_BADJ_CLK_DEGLITCH_EN_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_BADJ_CLK_DEGLITCH_EN_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_BADJ_CLK_DEGLITCH_EN_get", id, 2);
    /* (0x00000070 bits 1) field BADJ_CLK_DEGLITCH_EN of register PMC_PM20_82_24_REG_DEGLITCHER_EN */
    reg_value = t8_reg_DEGLITCHER_EN_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DEGLITCHER_EN_BIT_BADJ_CLK_DEGLITCH_EN_MSK) >> PM20_82_24_REG_DEGLITCHER_EN_BIT_BADJ_CLK_DEGLITCH_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_BADJ_CLK_DEGLITCH_EN_get", id, value );

    return value;
}
static INLINE void t8_field_ADC_CLK_DEGLITCH_EN_set( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADC_CLK_DEGLITCH_EN_set( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_CLK_DEGLITCH_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADC_CLK_DEGLITCH_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADC_CLK_DEGLITCH_EN_set", id, value );

    /* (0x00000070 bits 0) field ADC_CLK_DEGLITCH_EN of register PMC_PM20_82_24_REG_DEGLITCHER_EN */
    t8_reg_DEGLITCHER_EN_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_DEGLITCHER_EN_BIT_ADC_CLK_DEGLITCH_EN_MSK,
                                    PM20_82_24_REG_DEGLITCHER_EN_BIT_ADC_CLK_DEGLITCH_EN_OFF,
                                    value);
}

static INLINE UINT32 t8_field_ADC_CLK_DEGLITCH_EN_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADC_CLK_DEGLITCH_EN_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_CLK_DEGLITCH_EN_get", id, 2);
    /* (0x00000070 bits 0) field ADC_CLK_DEGLITCH_EN of register PMC_PM20_82_24_REG_DEGLITCHER_EN */
    reg_value = t8_reg_DEGLITCHER_EN_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DEGLITCHER_EN_BIT_ADC_CLK_DEGLITCH_EN_MSK) >> PM20_82_24_REG_DEGLITCHER_EN_BIT_ADC_CLK_DEGLITCH_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADC_CLK_DEGLITCH_EN_get", id, value );

    return value;
}
static INLINE void t8_field_GLBL_DIGITAL_RSTB_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_GLBL_DIGITAL_RSTB_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GLBL_DIGITAL_RSTB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_GLBL_DIGITAL_RSTB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_GLBL_DIGITAL_RSTB_set", id, value );

    /* (0x00000074 bits 31) field GLBL_DIGITAL_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    t8_reg_DIGITAL_RSTB_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_GLBL_DIGITAL_RSTB_MSK,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_GLBL_DIGITAL_RSTB_OFF,
                                       value);
}

static INLINE UINT32 t8_field_GLBL_DIGITAL_RSTB_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_GLBL_DIGITAL_RSTB_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GLBL_DIGITAL_RSTB_get", id, 2);
    /* (0x00000074 bits 31) field GLBL_DIGITAL_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    reg_value = t8_reg_DIGITAL_RSTB_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_GLBL_DIGITAL_RSTB_MSK) >> PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_GLBL_DIGITAL_RSTB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_GLBL_DIGITAL_RSTB_get", id, value );

    return value;
}
static INLINE void t8_field_PCBI_FIFO_HW_RESET_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PCBI_FIFO_HW_RESET_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PCBI_FIFO_HW_RESET_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PCBI_FIFO_HW_RESET_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PCBI_FIFO_HW_RESET_set", id, value );

    /* (0x00000074 bits 15) field PCBI_FIFO_HW_RESET of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    t8_reg_DIGITAL_RSTB_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PCBI_FIFO_HW_RESET_MSK,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PCBI_FIFO_HW_RESET_OFF,
                                       value);
}

static INLINE UINT32 t8_field_PCBI_FIFO_HW_RESET_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PCBI_FIFO_HW_RESET_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PCBI_FIFO_HW_RESET_get", id, 2);
    /* (0x00000074 bits 15) field PCBI_FIFO_HW_RESET of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    reg_value = t8_reg_DIGITAL_RSTB_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PCBI_FIFO_HW_RESET_MSK) >> PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PCBI_FIFO_HW_RESET_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PCBI_FIFO_HW_RESET_get", id, value );

    return value;
}
static INLINE void t8_field_MON_RSTB_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_MON_RSTB_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_MON_RSTB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_MON_RSTB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_MON_RSTB_set", id, value );

    /* (0x00000074 bits 12) field MON_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    t8_reg_DIGITAL_RSTB_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_MON_RSTB_MSK,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_MON_RSTB_OFF,
                                       value);
}

static INLINE UINT32 t8_field_MON_RSTB_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_MON_RSTB_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_MON_RSTB_get", id, 2);
    /* (0x00000074 bits 12) field MON_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    reg_value = t8_reg_DIGITAL_RSTB_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_MON_RSTB_MSK) >> PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_MON_RSTB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_MON_RSTB_get", id, value );

    return value;
}
static INLINE void t8_field_GEN_RSTB_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_GEN_RSTB_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GEN_RSTB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_GEN_RSTB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_GEN_RSTB_set", id, value );

    /* (0x00000074 bits 11) field GEN_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    t8_reg_DIGITAL_RSTB_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_GEN_RSTB_MSK,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_GEN_RSTB_OFF,
                                       value);
}

static INLINE UINT32 t8_field_GEN_RSTB_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_GEN_RSTB_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GEN_RSTB_get", id, 2);
    /* (0x00000074 bits 11) field GEN_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    reg_value = t8_reg_DIGITAL_RSTB_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_GEN_RSTB_MSK) >> PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_GEN_RSTB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_GEN_RSTB_get", id, value );

    return value;
}
static INLINE void t8_field_PISO_RSTB_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PISO_RSTB_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_RSTB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PISO_RSTB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PISO_RSTB_set", id, value );

    /* (0x00000074 bits 10) field PISO_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    t8_reg_DIGITAL_RSTB_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PISO_RSTB_MSK,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PISO_RSTB_OFF,
                                       value);
}

static INLINE UINT32 t8_field_PISO_RSTB_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PISO_RSTB_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PISO_RSTB_get", id, 2);
    /* (0x00000074 bits 10) field PISO_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    reg_value = t8_reg_DIGITAL_RSTB_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PISO_RSTB_MSK) >> PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PISO_RSTB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PISO_RSTB_get", id, value );

    return value;
}
static INLINE void t8_field_SIPO_RSTB_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_SIPO_RSTB_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_SIPO_RSTB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_SIPO_RSTB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_SIPO_RSTB_set", id, value );

    /* (0x00000074 bits 9) field SIPO_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    t8_reg_DIGITAL_RSTB_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_SIPO_RSTB_MSK,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_SIPO_RSTB_OFF,
                                       value);
}

static INLINE UINT32 t8_field_SIPO_RSTB_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_SIPO_RSTB_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_SIPO_RSTB_get", id, 2);
    /* (0x00000074 bits 9) field SIPO_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    reg_value = t8_reg_DIGITAL_RSTB_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_SIPO_RSTB_MSK) >> PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_SIPO_RSTB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_SIPO_RSTB_get", id, value );

    return value;
}
static INLINE void t8_field_DLOS_RSTB_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DLOS_RSTB_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DLOS_RSTB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DLOS_RSTB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DLOS_RSTB_set", id, value );

    /* (0x00000074 bits 8) field DLOS_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    t8_reg_DIGITAL_RSTB_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_DLOS_RSTB_MSK,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_DLOS_RSTB_OFF,
                                       value);
}

static INLINE UINT32 t8_field_DLOS_RSTB_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DLOS_RSTB_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DLOS_RSTB_get", id, 2);
    /* (0x00000074 bits 8) field DLOS_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    reg_value = t8_reg_DIGITAL_RSTB_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_DLOS_RSTB_MSK) >> PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_DLOS_RSTB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DLOS_RSTB_get", id, value );

    return value;
}
static INLINE void t8_field_PLL_LOCK_DET_RSTB_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PLL_LOCK_DET_RSTB_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLL_LOCK_DET_RSTB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PLL_LOCK_DET_RSTB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PLL_LOCK_DET_RSTB_set", id, value );

    /* (0x00000074 bits 7) field PLL_LOCK_DET_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    t8_reg_DIGITAL_RSTB_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PLL_LOCK_DET_RSTB_MSK,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PLL_LOCK_DET_RSTB_OFF,
                                       value);
}

static INLINE UINT32 t8_field_PLL_LOCK_DET_RSTB_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PLL_LOCK_DET_RSTB_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLL_LOCK_DET_RSTB_get", id, 2);
    /* (0x00000074 bits 7) field PLL_LOCK_DET_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    reg_value = t8_reg_DIGITAL_RSTB_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PLL_LOCK_DET_RSTB_MSK) >> PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PLL_LOCK_DET_RSTB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PLL_LOCK_DET_RSTB_get", id, value );

    return value;
}
static INLINE void t8_field_MDSP_RSTB_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_MDSP_RSTB_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_MDSP_RSTB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_MDSP_RSTB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_MDSP_RSTB_set", id, value );

    /* (0x00000074 bits 6) field MDSP_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    t8_reg_DIGITAL_RSTB_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_MDSP_RSTB_MSK,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_MDSP_RSTB_OFF,
                                       value);
}

static INLINE UINT32 t8_field_MDSP_RSTB_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_MDSP_RSTB_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_MDSP_RSTB_get", id, 2);
    /* (0x00000074 bits 6) field MDSP_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    reg_value = t8_reg_DIGITAL_RSTB_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_MDSP_RSTB_MSK) >> PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_MDSP_RSTB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_MDSP_RSTB_get", id, value );

    return value;
}
static INLINE void t8_field_DIAGNOSTICS_RSTB_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DIAGNOSTICS_RSTB_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DIAGNOSTICS_RSTB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DIAGNOSTICS_RSTB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DIAGNOSTICS_RSTB_set", id, value );

    /* (0x00000074 bits 5) field DIAGNOSTICS_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    t8_reg_DIGITAL_RSTB_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_DIAGNOSTICS_RSTB_MSK,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_DIAGNOSTICS_RSTB_OFF,
                                       value);
}

static INLINE UINT32 t8_field_DIAGNOSTICS_RSTB_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DIAGNOSTICS_RSTB_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DIAGNOSTICS_RSTB_get", id, 2);
    /* (0x00000074 bits 5) field DIAGNOSTICS_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    reg_value = t8_reg_DIGITAL_RSTB_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_DIAGNOSTICS_RSTB_MSK) >> PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_DIAGNOSTICS_RSTB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DIAGNOSTICS_RSTB_get", id, value );

    return value;
}
static INLINE void t8_field_SIPO_BIST_RSTB_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_SIPO_BIST_RSTB_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_SIPO_BIST_RSTB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_SIPO_BIST_RSTB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_SIPO_BIST_RSTB_set", id, value );

    /* (0x00000074 bits 4) field SIPO_BIST_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    t8_reg_DIGITAL_RSTB_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_SIPO_BIST_RSTB_MSK,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_SIPO_BIST_RSTB_OFF,
                                       value);
}

static INLINE UINT32 t8_field_SIPO_BIST_RSTB_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_SIPO_BIST_RSTB_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_SIPO_BIST_RSTB_get", id, 2);
    /* (0x00000074 bits 4) field SIPO_BIST_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    reg_value = t8_reg_DIGITAL_RSTB_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_SIPO_BIST_RSTB_MSK) >> PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_SIPO_BIST_RSTB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_SIPO_BIST_RSTB_get", id, value );

    return value;
}
static INLINE void t8_field_GCOC_RSTB_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_GCOC_RSTB_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GCOC_RSTB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_GCOC_RSTB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_GCOC_RSTB_set", id, value );

    /* (0x00000074 bits 3) field GCOC_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    t8_reg_DIGITAL_RSTB_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_GCOC_RSTB_MSK,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_GCOC_RSTB_OFF,
                                       value);
}

static INLINE UINT32 t8_field_GCOC_RSTB_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_GCOC_RSTB_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GCOC_RSTB_get", id, 2);
    /* (0x00000074 bits 3) field GCOC_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    reg_value = t8_reg_DIGITAL_RSTB_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_GCOC_RSTB_MSK) >> PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_GCOC_RSTB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_GCOC_RSTB_get", id, value );

    return value;
}
static INLINE void t8_field_LPBK_DESKEW_FIFO_RSTB_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_LPBK_DESKEW_FIFO_RSTB_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LPBK_DESKEW_FIFO_RSTB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_LPBK_DESKEW_FIFO_RSTB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_LPBK_DESKEW_FIFO_RSTB_set", id, value );

    /* (0x00000074 bits 2) field LPBK_DESKEW_FIFO_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    t8_reg_DIGITAL_RSTB_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_LPBK_DESKEW_FIFO_RSTB_MSK,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_LPBK_DESKEW_FIFO_RSTB_OFF,
                                       value);
}

static INLINE UINT32 t8_field_LPBK_DESKEW_FIFO_RSTB_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_LPBK_DESKEW_FIFO_RSTB_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LPBK_DESKEW_FIFO_RSTB_get", id, 2);
    /* (0x00000074 bits 2) field LPBK_DESKEW_FIFO_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    reg_value = t8_reg_DIGITAL_RSTB_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_LPBK_DESKEW_FIFO_RSTB_MSK) >> PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_LPBK_DESKEW_FIFO_RSTB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_LPBK_DESKEW_FIFO_RSTB_get", id, value );

    return value;
}
static INLINE void t8_field_DESKEW_FIFO_RSTB_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DESKEW_FIFO_RSTB_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DESKEW_FIFO_RSTB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DESKEW_FIFO_RSTB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DESKEW_FIFO_RSTB_set", id, value );

    /* (0x00000074 bits 1) field DESKEW_FIFO_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    t8_reg_DIGITAL_RSTB_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_DESKEW_FIFO_RSTB_MSK,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_DESKEW_FIFO_RSTB_OFF,
                                       value);
}

static INLINE UINT32 t8_field_DESKEW_FIFO_RSTB_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DESKEW_FIFO_RSTB_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DESKEW_FIFO_RSTB_get", id, 2);
    /* (0x00000074 bits 1) field DESKEW_FIFO_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    reg_value = t8_reg_DIGITAL_RSTB_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_DESKEW_FIFO_RSTB_MSK) >> PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_DESKEW_FIFO_RSTB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DESKEW_FIFO_RSTB_get", id, value );

    return value;
}
static INLINE void t8_field_PMM_WRAP_RSTB_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PMM_WRAP_RSTB_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PMM_WRAP_RSTB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PMM_WRAP_RSTB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PMM_WRAP_RSTB_set", id, value );

    /* (0x00000074 bits 0) field PMM_WRAP_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    t8_reg_DIGITAL_RSTB_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PMM_WRAP_RSTB_MSK,
                                       PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PMM_WRAP_RSTB_OFF,
                                       value);
}

static INLINE UINT32 t8_field_PMM_WRAP_RSTB_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PMM_WRAP_RSTB_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PMM_WRAP_RSTB_get", id, 2);
    /* (0x00000074 bits 0) field PMM_WRAP_RSTB of register PMC_PM20_82_24_REG_DIGITAL_RSTB_REG */
    reg_value = t8_reg_DIGITAL_RSTB_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PMM_WRAP_RSTB_MSK) >> PM20_82_24_REG_DIGITAL_RSTB_REG_BIT_PMM_WRAP_RSTB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PMM_WRAP_RSTB_get", id, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_0_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_0_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_0_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_0_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_0_set", id, value );

    /* (0x00000084 bits 15:0) field PRIM_LUT_INDEX_0 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_0_REG */
    t8_reg_PRIM_LUT_INDEX_0_REG_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_0_REG_BIT_PRIM_LUT_INDEX_0_MSK,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_0_REG_BIT_PRIM_LUT_INDEX_0_OFF,
                                           value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_0_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_0_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_0_get", id, 2);
    /* (0x00000084 bits 15:0) field PRIM_LUT_INDEX_0 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_0_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_0_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_0_REG_BIT_PRIM_LUT_INDEX_0_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_0_REG_BIT_PRIM_LUT_INDEX_0_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_0_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_0_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_0_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_0_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_0_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_0_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_0_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000084 bits 15:0) field PRIM_LUT_INDEX_0 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_0_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000084 bits 15:0) field PRIM_LUT_INDEX_0 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_0_REG */
        t8_reg_PRIM_LUT_INDEX_0_REG_field_set( b_ptr,
                                               h_ptr,
                                               id,
                                               subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_0_REG_BIT_PRIM_LUT_INDEX_0_OFF + subfield_offset),
                                               PM20_82_24_REG_PRIM_LUT_INDEX_0_REG_BIT_PRIM_LUT_INDEX_0_OFF + subfield_offset,
                                               value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_0_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_0_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_0_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_0_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_0_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000084 bits 15:0) field PRIM_LUT_INDEX_0 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_0_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_0_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_0_REG_BIT_PRIM_LUT_INDEX_0_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_0_REG_BIT_PRIM_LUT_INDEX_0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_0_REG_BIT_PRIM_LUT_INDEX_0_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_0_REG_BIT_PRIM_LUT_INDEX_0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_0_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_1_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_1_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_1_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_1_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_1_set", id, value );

    /* (0x00000088 bits 15:0) field PRIM_LUT_INDEX_1 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_1_REG */
    t8_reg_PRIM_LUT_INDEX_1_REG_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_1_REG_BIT_PRIM_LUT_INDEX_1_MSK,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_1_REG_BIT_PRIM_LUT_INDEX_1_OFF,
                                           value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_1_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_1_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_1_get", id, 2);
    /* (0x00000088 bits 15:0) field PRIM_LUT_INDEX_1 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_1_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_1_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_1_REG_BIT_PRIM_LUT_INDEX_1_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_1_REG_BIT_PRIM_LUT_INDEX_1_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_1_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_1_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_1_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_1_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_1_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_1_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_1_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000088 bits 15:0) field PRIM_LUT_INDEX_1 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_1_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000088 bits 15:0) field PRIM_LUT_INDEX_1 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_1_REG */
        t8_reg_PRIM_LUT_INDEX_1_REG_field_set( b_ptr,
                                               h_ptr,
                                               id,
                                               subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_1_REG_BIT_PRIM_LUT_INDEX_1_OFF + subfield_offset),
                                               PM20_82_24_REG_PRIM_LUT_INDEX_1_REG_BIT_PRIM_LUT_INDEX_1_OFF + subfield_offset,
                                               value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_1_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_1_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_1_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_1_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_1_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000088 bits 15:0) field PRIM_LUT_INDEX_1 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_1_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_1_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_1_REG_BIT_PRIM_LUT_INDEX_1_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_1_REG_BIT_PRIM_LUT_INDEX_1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_1_REG_BIT_PRIM_LUT_INDEX_1_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_1_REG_BIT_PRIM_LUT_INDEX_1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_1_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_2_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_2_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_2_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_2_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_2_set", id, value );

    /* (0x0000008c bits 15:0) field PRIM_LUT_INDEX_2 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_2_REG */
    t8_reg_PRIM_LUT_INDEX_2_REG_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_2_REG_BIT_PRIM_LUT_INDEX_2_MSK,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_2_REG_BIT_PRIM_LUT_INDEX_2_OFF,
                                           value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_2_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_2_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_2_get", id, 2);
    /* (0x0000008c bits 15:0) field PRIM_LUT_INDEX_2 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_2_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_2_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_2_REG_BIT_PRIM_LUT_INDEX_2_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_2_REG_BIT_PRIM_LUT_INDEX_2_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_2_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_2_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_2_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_2_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_2_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_2_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_2_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000008c bits 15:0) field PRIM_LUT_INDEX_2 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_2_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000008c bits 15:0) field PRIM_LUT_INDEX_2 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_2_REG */
        t8_reg_PRIM_LUT_INDEX_2_REG_field_set( b_ptr,
                                               h_ptr,
                                               id,
                                               subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_2_REG_BIT_PRIM_LUT_INDEX_2_OFF + subfield_offset),
                                               PM20_82_24_REG_PRIM_LUT_INDEX_2_REG_BIT_PRIM_LUT_INDEX_2_OFF + subfield_offset,
                                               value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_2_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_2_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_2_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_2_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_2_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000008c bits 15:0) field PRIM_LUT_INDEX_2 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_2_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_2_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_2_REG_BIT_PRIM_LUT_INDEX_2_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_2_REG_BIT_PRIM_LUT_INDEX_2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_2_REG_BIT_PRIM_LUT_INDEX_2_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_2_REG_BIT_PRIM_LUT_INDEX_2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_2_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_3_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_3_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_3_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_3_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_3_set", id, value );

    /* (0x00000090 bits 15:0) field PRIM_LUT_INDEX_3 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_3_REG */
    t8_reg_PRIM_LUT_INDEX_3_REG_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_3_REG_BIT_PRIM_LUT_INDEX_3_MSK,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_3_REG_BIT_PRIM_LUT_INDEX_3_OFF,
                                           value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_3_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_3_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_3_get", id, 2);
    /* (0x00000090 bits 15:0) field PRIM_LUT_INDEX_3 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_3_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_3_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_3_REG_BIT_PRIM_LUT_INDEX_3_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_3_REG_BIT_PRIM_LUT_INDEX_3_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_3_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_3_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_3_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_3_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_3_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_3_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_3_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000090 bits 15:0) field PRIM_LUT_INDEX_3 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_3_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000090 bits 15:0) field PRIM_LUT_INDEX_3 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_3_REG */
        t8_reg_PRIM_LUT_INDEX_3_REG_field_set( b_ptr,
                                               h_ptr,
                                               id,
                                               subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_3_REG_BIT_PRIM_LUT_INDEX_3_OFF + subfield_offset),
                                               PM20_82_24_REG_PRIM_LUT_INDEX_3_REG_BIT_PRIM_LUT_INDEX_3_OFF + subfield_offset,
                                               value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_3_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_3_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_3_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_3_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_3_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000090 bits 15:0) field PRIM_LUT_INDEX_3 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_3_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_3_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_3_REG_BIT_PRIM_LUT_INDEX_3_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_3_REG_BIT_PRIM_LUT_INDEX_3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_3_REG_BIT_PRIM_LUT_INDEX_3_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_3_REG_BIT_PRIM_LUT_INDEX_3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_3_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_4_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_4_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_4_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_4_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_4_set", id, value );

    /* (0x00000094 bits 15:0) field PRIM_LUT_INDEX_4 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_4_REG */
    t8_reg_PRIM_LUT_INDEX_4_REG_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_4_REG_BIT_PRIM_LUT_INDEX_4_MSK,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_4_REG_BIT_PRIM_LUT_INDEX_4_OFF,
                                           value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_4_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_4_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_4_get", id, 2);
    /* (0x00000094 bits 15:0) field PRIM_LUT_INDEX_4 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_4_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_4_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_4_REG_BIT_PRIM_LUT_INDEX_4_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_4_REG_BIT_PRIM_LUT_INDEX_4_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_4_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_4_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_4_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_4_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_4_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_4_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_4_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000094 bits 15:0) field PRIM_LUT_INDEX_4 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_4_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000094 bits 15:0) field PRIM_LUT_INDEX_4 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_4_REG */
        t8_reg_PRIM_LUT_INDEX_4_REG_field_set( b_ptr,
                                               h_ptr,
                                               id,
                                               subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_4_REG_BIT_PRIM_LUT_INDEX_4_OFF + subfield_offset),
                                               PM20_82_24_REG_PRIM_LUT_INDEX_4_REG_BIT_PRIM_LUT_INDEX_4_OFF + subfield_offset,
                                               value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_4_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_4_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_4_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_4_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_4_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000094 bits 15:0) field PRIM_LUT_INDEX_4 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_4_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_4_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_4_REG_BIT_PRIM_LUT_INDEX_4_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_4_REG_BIT_PRIM_LUT_INDEX_4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_4_REG_BIT_PRIM_LUT_INDEX_4_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_4_REG_BIT_PRIM_LUT_INDEX_4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_4_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_5_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_5_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_5_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_5_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_5_set", id, value );

    /* (0x00000098 bits 15:0) field PRIM_LUT_INDEX_5 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_5_REG */
    t8_reg_PRIM_LUT_INDEX_5_REG_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_5_REG_BIT_PRIM_LUT_INDEX_5_MSK,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_5_REG_BIT_PRIM_LUT_INDEX_5_OFF,
                                           value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_5_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_5_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_5_get", id, 2);
    /* (0x00000098 bits 15:0) field PRIM_LUT_INDEX_5 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_5_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_5_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_5_REG_BIT_PRIM_LUT_INDEX_5_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_5_REG_BIT_PRIM_LUT_INDEX_5_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_5_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_5_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_5_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_5_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_5_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_5_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_5_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000098 bits 15:0) field PRIM_LUT_INDEX_5 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_5_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000098 bits 15:0) field PRIM_LUT_INDEX_5 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_5_REG */
        t8_reg_PRIM_LUT_INDEX_5_REG_field_set( b_ptr,
                                               h_ptr,
                                               id,
                                               subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_5_REG_BIT_PRIM_LUT_INDEX_5_OFF + subfield_offset),
                                               PM20_82_24_REG_PRIM_LUT_INDEX_5_REG_BIT_PRIM_LUT_INDEX_5_OFF + subfield_offset,
                                               value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_5_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_5_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_5_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_5_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_5_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000098 bits 15:0) field PRIM_LUT_INDEX_5 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_5_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_5_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_5_REG_BIT_PRIM_LUT_INDEX_5_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_5_REG_BIT_PRIM_LUT_INDEX_5_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_5_REG_BIT_PRIM_LUT_INDEX_5_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_5_REG_BIT_PRIM_LUT_INDEX_5_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_5_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_6_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_6_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_6_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_6_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_6_set", id, value );

    /* (0x0000009c bits 15:0) field PRIM_LUT_INDEX_6 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_6_REG */
    t8_reg_PRIM_LUT_INDEX_6_REG_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_6_REG_BIT_PRIM_LUT_INDEX_6_MSK,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_6_REG_BIT_PRIM_LUT_INDEX_6_OFF,
                                           value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_6_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_6_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_6_get", id, 2);
    /* (0x0000009c bits 15:0) field PRIM_LUT_INDEX_6 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_6_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_6_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_6_REG_BIT_PRIM_LUT_INDEX_6_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_6_REG_BIT_PRIM_LUT_INDEX_6_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_6_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_6_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_6_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_6_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_6_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_6_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_6_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000009c bits 15:0) field PRIM_LUT_INDEX_6 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_6_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000009c bits 15:0) field PRIM_LUT_INDEX_6 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_6_REG */
        t8_reg_PRIM_LUT_INDEX_6_REG_field_set( b_ptr,
                                               h_ptr,
                                               id,
                                               subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_6_REG_BIT_PRIM_LUT_INDEX_6_OFF + subfield_offset),
                                               PM20_82_24_REG_PRIM_LUT_INDEX_6_REG_BIT_PRIM_LUT_INDEX_6_OFF + subfield_offset,
                                               value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_6_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_6_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_6_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_6_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_6_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000009c bits 15:0) field PRIM_LUT_INDEX_6 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_6_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_6_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_6_REG_BIT_PRIM_LUT_INDEX_6_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_6_REG_BIT_PRIM_LUT_INDEX_6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_6_REG_BIT_PRIM_LUT_INDEX_6_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_6_REG_BIT_PRIM_LUT_INDEX_6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_6_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_7_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_7_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_7_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_7_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_7_set", id, value );

    /* (0x00000100 bits 15:0) field PRIM_LUT_INDEX_7 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_7_REG */
    t8_reg_PRIM_LUT_INDEX_7_REG_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_7_REG_BIT_PRIM_LUT_INDEX_7_MSK,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_7_REG_BIT_PRIM_LUT_INDEX_7_OFF,
                                           value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_7_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_7_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_7_get", id, 2);
    /* (0x00000100 bits 15:0) field PRIM_LUT_INDEX_7 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_7_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_7_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_7_REG_BIT_PRIM_LUT_INDEX_7_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_7_REG_BIT_PRIM_LUT_INDEX_7_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_7_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_7_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_7_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_7_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_7_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_7_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_7_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000100 bits 15:0) field PRIM_LUT_INDEX_7 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_7_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000100 bits 15:0) field PRIM_LUT_INDEX_7 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_7_REG */
        t8_reg_PRIM_LUT_INDEX_7_REG_field_set( b_ptr,
                                               h_ptr,
                                               id,
                                               subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_7_REG_BIT_PRIM_LUT_INDEX_7_OFF + subfield_offset),
                                               PM20_82_24_REG_PRIM_LUT_INDEX_7_REG_BIT_PRIM_LUT_INDEX_7_OFF + subfield_offset,
                                               value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_7_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_7_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_7_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_7_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_7_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000100 bits 15:0) field PRIM_LUT_INDEX_7 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_7_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_7_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_7_REG_BIT_PRIM_LUT_INDEX_7_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_7_REG_BIT_PRIM_LUT_INDEX_7_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_7_REG_BIT_PRIM_LUT_INDEX_7_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_7_REG_BIT_PRIM_LUT_INDEX_7_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_7_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_8_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_8_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_8_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_8_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_8_set", id, value );

    /* (0x00000104 bits 15:0) field PRIM_LUT_INDEX_8 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_8_REG */
    t8_reg_PRIM_LUT_INDEX_8_REG_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_8_REG_BIT_PRIM_LUT_INDEX_8_MSK,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_8_REG_BIT_PRIM_LUT_INDEX_8_OFF,
                                           value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_8_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_8_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_8_get", id, 2);
    /* (0x00000104 bits 15:0) field PRIM_LUT_INDEX_8 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_8_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_8_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_8_REG_BIT_PRIM_LUT_INDEX_8_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_8_REG_BIT_PRIM_LUT_INDEX_8_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_8_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_8_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_8_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_8_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_8_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_8_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_8_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000104 bits 15:0) field PRIM_LUT_INDEX_8 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_8_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000104 bits 15:0) field PRIM_LUT_INDEX_8 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_8_REG */
        t8_reg_PRIM_LUT_INDEX_8_REG_field_set( b_ptr,
                                               h_ptr,
                                               id,
                                               subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_8_REG_BIT_PRIM_LUT_INDEX_8_OFF + subfield_offset),
                                               PM20_82_24_REG_PRIM_LUT_INDEX_8_REG_BIT_PRIM_LUT_INDEX_8_OFF + subfield_offset,
                                               value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_8_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_8_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_8_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_8_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_8_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000104 bits 15:0) field PRIM_LUT_INDEX_8 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_8_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_8_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_8_REG_BIT_PRIM_LUT_INDEX_8_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_8_REG_BIT_PRIM_LUT_INDEX_8_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_8_REG_BIT_PRIM_LUT_INDEX_8_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_8_REG_BIT_PRIM_LUT_INDEX_8_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_8_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_9_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_9_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_9_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_9_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_9_set", id, value );

    /* (0x00000108 bits 15:0) field PRIM_LUT_INDEX_9 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_9_REG */
    t8_reg_PRIM_LUT_INDEX_9_REG_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_9_REG_BIT_PRIM_LUT_INDEX_9_MSK,
                                           PM20_82_24_REG_PRIM_LUT_INDEX_9_REG_BIT_PRIM_LUT_INDEX_9_OFF,
                                           value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_9_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_9_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_9_get", id, 2);
    /* (0x00000108 bits 15:0) field PRIM_LUT_INDEX_9 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_9_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_9_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_9_REG_BIT_PRIM_LUT_INDEX_9_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_9_REG_BIT_PRIM_LUT_INDEX_9_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_9_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_9_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_9_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_9_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_9_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_9_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_9_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000108 bits 15:0) field PRIM_LUT_INDEX_9 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_9_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000108 bits 15:0) field PRIM_LUT_INDEX_9 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_9_REG */
        t8_reg_PRIM_LUT_INDEX_9_REG_field_set( b_ptr,
                                               h_ptr,
                                               id,
                                               subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_9_REG_BIT_PRIM_LUT_INDEX_9_OFF + subfield_offset),
                                               PM20_82_24_REG_PRIM_LUT_INDEX_9_REG_BIT_PRIM_LUT_INDEX_9_OFF + subfield_offset,
                                               value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_9_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_9_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_9_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_9_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_9_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000108 bits 15:0) field PRIM_LUT_INDEX_9 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_9_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_9_REG_read( b_ptr,
                                                  h_ptr,
                                                  id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_9_REG_BIT_PRIM_LUT_INDEX_9_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_9_REG_BIT_PRIM_LUT_INDEX_9_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_9_REG_BIT_PRIM_LUT_INDEX_9_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_9_REG_BIT_PRIM_LUT_INDEX_9_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_9_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_10_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_10_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_10_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_10_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_10_set", id, value );

    /* (0x0000010c bits 15:0) field PRIM_LUT_INDEX_10 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_10_REG */
    t8_reg_PRIM_LUT_INDEX_10_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_10_REG_BIT_PRIM_LUT_INDEX_10_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_10_REG_BIT_PRIM_LUT_INDEX_10_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_10_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_10_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_10_get", id, 2);
    /* (0x0000010c bits 15:0) field PRIM_LUT_INDEX_10 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_10_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_10_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_10_REG_BIT_PRIM_LUT_INDEX_10_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_10_REG_BIT_PRIM_LUT_INDEX_10_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_10_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_10_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_10_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_10_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_10_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_10_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_10_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000010c bits 15:0) field PRIM_LUT_INDEX_10 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_10_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000010c bits 15:0) field PRIM_LUT_INDEX_10 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_10_REG */
        t8_reg_PRIM_LUT_INDEX_10_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_10_REG_BIT_PRIM_LUT_INDEX_10_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_10_REG_BIT_PRIM_LUT_INDEX_10_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_10_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_10_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_10_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_10_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_10_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000010c bits 15:0) field PRIM_LUT_INDEX_10 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_10_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_10_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_10_REG_BIT_PRIM_LUT_INDEX_10_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_10_REG_BIT_PRIM_LUT_INDEX_10_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_10_REG_BIT_PRIM_LUT_INDEX_10_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_10_REG_BIT_PRIM_LUT_INDEX_10_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_10_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_11_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_11_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_11_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_11_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_11_set", id, value );

    /* (0x00000110 bits 15:0) field PRIM_LUT_INDEX_11 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_11_REG */
    t8_reg_PRIM_LUT_INDEX_11_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_11_REG_BIT_PRIM_LUT_INDEX_11_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_11_REG_BIT_PRIM_LUT_INDEX_11_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_11_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_11_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_11_get", id, 2);
    /* (0x00000110 bits 15:0) field PRIM_LUT_INDEX_11 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_11_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_11_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_11_REG_BIT_PRIM_LUT_INDEX_11_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_11_REG_BIT_PRIM_LUT_INDEX_11_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_11_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_11_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_11_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_11_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_11_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_11_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_11_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000110 bits 15:0) field PRIM_LUT_INDEX_11 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_11_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000110 bits 15:0) field PRIM_LUT_INDEX_11 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_11_REG */
        t8_reg_PRIM_LUT_INDEX_11_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_11_REG_BIT_PRIM_LUT_INDEX_11_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_11_REG_BIT_PRIM_LUT_INDEX_11_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_11_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_11_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_11_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_11_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_11_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000110 bits 15:0) field PRIM_LUT_INDEX_11 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_11_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_11_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_11_REG_BIT_PRIM_LUT_INDEX_11_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_11_REG_BIT_PRIM_LUT_INDEX_11_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_11_REG_BIT_PRIM_LUT_INDEX_11_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_11_REG_BIT_PRIM_LUT_INDEX_11_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_11_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_12_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_12_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_12_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_12_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_12_set", id, value );

    /* (0x00000114 bits 15:0) field PRIM_LUT_INDEX_12 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_12_REG */
    t8_reg_PRIM_LUT_INDEX_12_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_12_REG_BIT_PRIM_LUT_INDEX_12_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_12_REG_BIT_PRIM_LUT_INDEX_12_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_12_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_12_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_12_get", id, 2);
    /* (0x00000114 bits 15:0) field PRIM_LUT_INDEX_12 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_12_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_12_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_12_REG_BIT_PRIM_LUT_INDEX_12_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_12_REG_BIT_PRIM_LUT_INDEX_12_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_12_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_12_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_12_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_12_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_12_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_12_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_12_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000114 bits 15:0) field PRIM_LUT_INDEX_12 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_12_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000114 bits 15:0) field PRIM_LUT_INDEX_12 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_12_REG */
        t8_reg_PRIM_LUT_INDEX_12_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_12_REG_BIT_PRIM_LUT_INDEX_12_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_12_REG_BIT_PRIM_LUT_INDEX_12_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_12_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_12_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_12_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_12_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_12_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000114 bits 15:0) field PRIM_LUT_INDEX_12 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_12_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_12_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_12_REG_BIT_PRIM_LUT_INDEX_12_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_12_REG_BIT_PRIM_LUT_INDEX_12_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_12_REG_BIT_PRIM_LUT_INDEX_12_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_12_REG_BIT_PRIM_LUT_INDEX_12_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_12_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_13_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_13_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_13_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_13_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_13_set", id, value );

    /* (0x00000118 bits 15:0) field PRIM_LUT_INDEX_13 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_13_REG */
    t8_reg_PRIM_LUT_INDEX_13_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_13_REG_BIT_PRIM_LUT_INDEX_13_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_13_REG_BIT_PRIM_LUT_INDEX_13_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_13_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_13_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_13_get", id, 2);
    /* (0x00000118 bits 15:0) field PRIM_LUT_INDEX_13 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_13_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_13_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_13_REG_BIT_PRIM_LUT_INDEX_13_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_13_REG_BIT_PRIM_LUT_INDEX_13_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_13_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_13_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_13_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_13_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_13_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_13_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_13_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000118 bits 15:0) field PRIM_LUT_INDEX_13 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_13_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000118 bits 15:0) field PRIM_LUT_INDEX_13 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_13_REG */
        t8_reg_PRIM_LUT_INDEX_13_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_13_REG_BIT_PRIM_LUT_INDEX_13_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_13_REG_BIT_PRIM_LUT_INDEX_13_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_13_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_13_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_13_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_13_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_13_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000118 bits 15:0) field PRIM_LUT_INDEX_13 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_13_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_13_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_13_REG_BIT_PRIM_LUT_INDEX_13_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_13_REG_BIT_PRIM_LUT_INDEX_13_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_13_REG_BIT_PRIM_LUT_INDEX_13_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_13_REG_BIT_PRIM_LUT_INDEX_13_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_13_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_14_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_14_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_14_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_14_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_14_set", id, value );

    /* (0x0000011c bits 15:0) field PRIM_LUT_INDEX_14 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_14_REG */
    t8_reg_PRIM_LUT_INDEX_14_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_14_REG_BIT_PRIM_LUT_INDEX_14_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_14_REG_BIT_PRIM_LUT_INDEX_14_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_14_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_14_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_14_get", id, 2);
    /* (0x0000011c bits 15:0) field PRIM_LUT_INDEX_14 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_14_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_14_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_14_REG_BIT_PRIM_LUT_INDEX_14_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_14_REG_BIT_PRIM_LUT_INDEX_14_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_14_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_14_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_14_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_14_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_14_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_14_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_14_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000011c bits 15:0) field PRIM_LUT_INDEX_14 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_14_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000011c bits 15:0) field PRIM_LUT_INDEX_14 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_14_REG */
        t8_reg_PRIM_LUT_INDEX_14_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_14_REG_BIT_PRIM_LUT_INDEX_14_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_14_REG_BIT_PRIM_LUT_INDEX_14_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_14_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_14_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_14_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_14_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_14_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000011c bits 15:0) field PRIM_LUT_INDEX_14 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_14_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_14_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_14_REG_BIT_PRIM_LUT_INDEX_14_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_14_REG_BIT_PRIM_LUT_INDEX_14_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_14_REG_BIT_PRIM_LUT_INDEX_14_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_14_REG_BIT_PRIM_LUT_INDEX_14_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_14_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_15_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_15_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_15_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_15_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_15_set", id, value );

    /* (0x00000120 bits 15:0) field PRIM_LUT_INDEX_15 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_15_REG */
    t8_reg_PRIM_LUT_INDEX_15_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_15_REG_BIT_PRIM_LUT_INDEX_15_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_15_REG_BIT_PRIM_LUT_INDEX_15_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_15_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_15_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_15_get", id, 2);
    /* (0x00000120 bits 15:0) field PRIM_LUT_INDEX_15 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_15_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_15_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_15_REG_BIT_PRIM_LUT_INDEX_15_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_15_REG_BIT_PRIM_LUT_INDEX_15_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_15_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_15_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_15_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_15_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_15_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_15_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_15_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000120 bits 15:0) field PRIM_LUT_INDEX_15 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_15_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000120 bits 15:0) field PRIM_LUT_INDEX_15 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_15_REG */
        t8_reg_PRIM_LUT_INDEX_15_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_15_REG_BIT_PRIM_LUT_INDEX_15_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_15_REG_BIT_PRIM_LUT_INDEX_15_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_15_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_15_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_15_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_15_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_15_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000120 bits 15:0) field PRIM_LUT_INDEX_15 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_15_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_15_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_15_REG_BIT_PRIM_LUT_INDEX_15_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_15_REG_BIT_PRIM_LUT_INDEX_15_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_15_REG_BIT_PRIM_LUT_INDEX_15_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_15_REG_BIT_PRIM_LUT_INDEX_15_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_15_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_16_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_16_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_16_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_16_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_16_set", id, value );

    /* (0x00000124 bits 15:0) field PRIM_LUT_INDEX_16 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_16_REG */
    t8_reg_PRIM_LUT_INDEX_16_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_16_REG_BIT_PRIM_LUT_INDEX_16_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_16_REG_BIT_PRIM_LUT_INDEX_16_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_16_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_16_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_16_get", id, 2);
    /* (0x00000124 bits 15:0) field PRIM_LUT_INDEX_16 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_16_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_16_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_16_REG_BIT_PRIM_LUT_INDEX_16_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_16_REG_BIT_PRIM_LUT_INDEX_16_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_16_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_16_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_16_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_16_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_16_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_16_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_16_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000124 bits 15:0) field PRIM_LUT_INDEX_16 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_16_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000124 bits 15:0) field PRIM_LUT_INDEX_16 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_16_REG */
        t8_reg_PRIM_LUT_INDEX_16_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_16_REG_BIT_PRIM_LUT_INDEX_16_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_16_REG_BIT_PRIM_LUT_INDEX_16_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_16_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_16_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_16_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_16_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_16_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000124 bits 15:0) field PRIM_LUT_INDEX_16 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_16_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_16_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_16_REG_BIT_PRIM_LUT_INDEX_16_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_16_REG_BIT_PRIM_LUT_INDEX_16_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_16_REG_BIT_PRIM_LUT_INDEX_16_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_16_REG_BIT_PRIM_LUT_INDEX_16_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_16_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_17_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_17_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_17_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_17_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_17_set", id, value );

    /* (0x00000128 bits 15:0) field PRIM_LUT_INDEX_17 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_17_REG */
    t8_reg_PRIM_LUT_INDEX_17_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_17_REG_BIT_PRIM_LUT_INDEX_17_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_17_REG_BIT_PRIM_LUT_INDEX_17_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_17_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_17_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_17_get", id, 2);
    /* (0x00000128 bits 15:0) field PRIM_LUT_INDEX_17 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_17_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_17_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_17_REG_BIT_PRIM_LUT_INDEX_17_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_17_REG_BIT_PRIM_LUT_INDEX_17_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_17_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_17_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_17_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_17_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_17_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_17_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_17_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000128 bits 15:0) field PRIM_LUT_INDEX_17 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_17_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000128 bits 15:0) field PRIM_LUT_INDEX_17 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_17_REG */
        t8_reg_PRIM_LUT_INDEX_17_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_17_REG_BIT_PRIM_LUT_INDEX_17_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_17_REG_BIT_PRIM_LUT_INDEX_17_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_17_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_17_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_17_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_17_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_17_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000128 bits 15:0) field PRIM_LUT_INDEX_17 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_17_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_17_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_17_REG_BIT_PRIM_LUT_INDEX_17_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_17_REG_BIT_PRIM_LUT_INDEX_17_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_17_REG_BIT_PRIM_LUT_INDEX_17_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_17_REG_BIT_PRIM_LUT_INDEX_17_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_17_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_18_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_18_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_18_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_18_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_18_set", id, value );

    /* (0x0000012c bits 15:0) field PRIM_LUT_INDEX_18 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_18_REG */
    t8_reg_PRIM_LUT_INDEX_18_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_18_REG_BIT_PRIM_LUT_INDEX_18_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_18_REG_BIT_PRIM_LUT_INDEX_18_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_18_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_18_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_18_get", id, 2);
    /* (0x0000012c bits 15:0) field PRIM_LUT_INDEX_18 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_18_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_18_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_18_REG_BIT_PRIM_LUT_INDEX_18_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_18_REG_BIT_PRIM_LUT_INDEX_18_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_18_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_18_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_18_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_18_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_18_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_18_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_18_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000012c bits 15:0) field PRIM_LUT_INDEX_18 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_18_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000012c bits 15:0) field PRIM_LUT_INDEX_18 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_18_REG */
        t8_reg_PRIM_LUT_INDEX_18_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_18_REG_BIT_PRIM_LUT_INDEX_18_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_18_REG_BIT_PRIM_LUT_INDEX_18_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_18_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_18_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_18_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_18_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_18_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000012c bits 15:0) field PRIM_LUT_INDEX_18 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_18_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_18_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_18_REG_BIT_PRIM_LUT_INDEX_18_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_18_REG_BIT_PRIM_LUT_INDEX_18_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_18_REG_BIT_PRIM_LUT_INDEX_18_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_18_REG_BIT_PRIM_LUT_INDEX_18_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_18_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_19_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_19_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_19_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_19_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_19_set", id, value );

    /* (0x00000130 bits 15:0) field PRIM_LUT_INDEX_19 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_19_REG */
    t8_reg_PRIM_LUT_INDEX_19_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_19_REG_BIT_PRIM_LUT_INDEX_19_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_19_REG_BIT_PRIM_LUT_INDEX_19_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_19_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_19_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_19_get", id, 2);
    /* (0x00000130 bits 15:0) field PRIM_LUT_INDEX_19 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_19_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_19_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_19_REG_BIT_PRIM_LUT_INDEX_19_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_19_REG_BIT_PRIM_LUT_INDEX_19_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_19_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_19_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_19_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_19_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_19_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_19_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_19_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000130 bits 15:0) field PRIM_LUT_INDEX_19 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_19_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000130 bits 15:0) field PRIM_LUT_INDEX_19 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_19_REG */
        t8_reg_PRIM_LUT_INDEX_19_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_19_REG_BIT_PRIM_LUT_INDEX_19_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_19_REG_BIT_PRIM_LUT_INDEX_19_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_19_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_19_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_19_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_19_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_19_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000130 bits 15:0) field PRIM_LUT_INDEX_19 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_19_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_19_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_19_REG_BIT_PRIM_LUT_INDEX_19_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_19_REG_BIT_PRIM_LUT_INDEX_19_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_19_REG_BIT_PRIM_LUT_INDEX_19_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_19_REG_BIT_PRIM_LUT_INDEX_19_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_19_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_20_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_20_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_20_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_20_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_20_set", id, value );

    /* (0x00000134 bits 15:0) field PRIM_LUT_INDEX_20 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_20_REG */
    t8_reg_PRIM_LUT_INDEX_20_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_20_REG_BIT_PRIM_LUT_INDEX_20_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_20_REG_BIT_PRIM_LUT_INDEX_20_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_20_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_20_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_20_get", id, 2);
    /* (0x00000134 bits 15:0) field PRIM_LUT_INDEX_20 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_20_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_20_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_20_REG_BIT_PRIM_LUT_INDEX_20_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_20_REG_BIT_PRIM_LUT_INDEX_20_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_20_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_20_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_20_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_20_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_20_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_20_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_20_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000134 bits 15:0) field PRIM_LUT_INDEX_20 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_20_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000134 bits 15:0) field PRIM_LUT_INDEX_20 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_20_REG */
        t8_reg_PRIM_LUT_INDEX_20_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_20_REG_BIT_PRIM_LUT_INDEX_20_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_20_REG_BIT_PRIM_LUT_INDEX_20_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_20_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_20_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_20_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_20_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_20_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000134 bits 15:0) field PRIM_LUT_INDEX_20 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_20_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_20_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_20_REG_BIT_PRIM_LUT_INDEX_20_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_20_REG_BIT_PRIM_LUT_INDEX_20_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_20_REG_BIT_PRIM_LUT_INDEX_20_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_20_REG_BIT_PRIM_LUT_INDEX_20_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_20_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_21_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_21_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_21_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_21_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_21_set", id, value );

    /* (0x00000138 bits 15:0) field PRIM_LUT_INDEX_21 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_21_REG */
    t8_reg_PRIM_LUT_INDEX_21_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_21_REG_BIT_PRIM_LUT_INDEX_21_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_21_REG_BIT_PRIM_LUT_INDEX_21_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_21_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_21_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_21_get", id, 2);
    /* (0x00000138 bits 15:0) field PRIM_LUT_INDEX_21 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_21_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_21_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_21_REG_BIT_PRIM_LUT_INDEX_21_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_21_REG_BIT_PRIM_LUT_INDEX_21_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_21_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_21_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_21_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_21_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_21_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_21_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_21_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000138 bits 15:0) field PRIM_LUT_INDEX_21 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_21_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000138 bits 15:0) field PRIM_LUT_INDEX_21 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_21_REG */
        t8_reg_PRIM_LUT_INDEX_21_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_21_REG_BIT_PRIM_LUT_INDEX_21_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_21_REG_BIT_PRIM_LUT_INDEX_21_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_21_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_21_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_21_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_21_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_21_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000138 bits 15:0) field PRIM_LUT_INDEX_21 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_21_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_21_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_21_REG_BIT_PRIM_LUT_INDEX_21_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_21_REG_BIT_PRIM_LUT_INDEX_21_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_21_REG_BIT_PRIM_LUT_INDEX_21_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_21_REG_BIT_PRIM_LUT_INDEX_21_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_21_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_22_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_22_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_22_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_22_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_22_set", id, value );

    /* (0x0000013c bits 15:0) field PRIM_LUT_INDEX_22 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_22_REG */
    t8_reg_PRIM_LUT_INDEX_22_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_22_REG_BIT_PRIM_LUT_INDEX_22_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_22_REG_BIT_PRIM_LUT_INDEX_22_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_22_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_22_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_22_get", id, 2);
    /* (0x0000013c bits 15:0) field PRIM_LUT_INDEX_22 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_22_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_22_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_22_REG_BIT_PRIM_LUT_INDEX_22_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_22_REG_BIT_PRIM_LUT_INDEX_22_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_22_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_22_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_22_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_22_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_22_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_22_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_22_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000013c bits 15:0) field PRIM_LUT_INDEX_22 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_22_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000013c bits 15:0) field PRIM_LUT_INDEX_22 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_22_REG */
        t8_reg_PRIM_LUT_INDEX_22_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_22_REG_BIT_PRIM_LUT_INDEX_22_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_22_REG_BIT_PRIM_LUT_INDEX_22_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_22_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_22_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_22_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_22_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_22_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000013c bits 15:0) field PRIM_LUT_INDEX_22 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_22_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_22_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_22_REG_BIT_PRIM_LUT_INDEX_22_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_22_REG_BIT_PRIM_LUT_INDEX_22_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_22_REG_BIT_PRIM_LUT_INDEX_22_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_22_REG_BIT_PRIM_LUT_INDEX_22_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_22_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_23_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_23_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_23_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_23_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_23_set", id, value );

    /* (0x00000140 bits 15:0) field PRIM_LUT_INDEX_23 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_23_REG */
    t8_reg_PRIM_LUT_INDEX_23_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_23_REG_BIT_PRIM_LUT_INDEX_23_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_23_REG_BIT_PRIM_LUT_INDEX_23_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_23_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_23_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_23_get", id, 2);
    /* (0x00000140 bits 15:0) field PRIM_LUT_INDEX_23 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_23_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_23_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_23_REG_BIT_PRIM_LUT_INDEX_23_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_23_REG_BIT_PRIM_LUT_INDEX_23_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_23_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_23_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_23_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_23_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_23_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_23_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_23_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000140 bits 15:0) field PRIM_LUT_INDEX_23 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_23_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000140 bits 15:0) field PRIM_LUT_INDEX_23 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_23_REG */
        t8_reg_PRIM_LUT_INDEX_23_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_23_REG_BIT_PRIM_LUT_INDEX_23_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_23_REG_BIT_PRIM_LUT_INDEX_23_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_23_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_23_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_23_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_23_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_23_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000140 bits 15:0) field PRIM_LUT_INDEX_23 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_23_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_23_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_23_REG_BIT_PRIM_LUT_INDEX_23_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_23_REG_BIT_PRIM_LUT_INDEX_23_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_23_REG_BIT_PRIM_LUT_INDEX_23_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_23_REG_BIT_PRIM_LUT_INDEX_23_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_23_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_24_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_24_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_24_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_24_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_24_set", id, value );

    /* (0x00000144 bits 15:0) field PRIM_LUT_INDEX_24 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_24_REG */
    t8_reg_PRIM_LUT_INDEX_24_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_24_REG_BIT_PRIM_LUT_INDEX_24_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_24_REG_BIT_PRIM_LUT_INDEX_24_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_24_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_24_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_24_get", id, 2);
    /* (0x00000144 bits 15:0) field PRIM_LUT_INDEX_24 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_24_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_24_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_24_REG_BIT_PRIM_LUT_INDEX_24_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_24_REG_BIT_PRIM_LUT_INDEX_24_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_24_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_24_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_24_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_24_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_24_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_24_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_24_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000144 bits 15:0) field PRIM_LUT_INDEX_24 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_24_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000144 bits 15:0) field PRIM_LUT_INDEX_24 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_24_REG */
        t8_reg_PRIM_LUT_INDEX_24_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_24_REG_BIT_PRIM_LUT_INDEX_24_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_24_REG_BIT_PRIM_LUT_INDEX_24_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_24_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_24_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_24_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_24_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_24_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000144 bits 15:0) field PRIM_LUT_INDEX_24 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_24_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_24_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_24_REG_BIT_PRIM_LUT_INDEX_24_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_24_REG_BIT_PRIM_LUT_INDEX_24_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_24_REG_BIT_PRIM_LUT_INDEX_24_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_24_REG_BIT_PRIM_LUT_INDEX_24_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_24_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_25_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_25_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_25_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_25_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_25_set", id, value );

    /* (0x00000148 bits 15:0) field PRIM_LUT_INDEX_25 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_25_REG */
    t8_reg_PRIM_LUT_INDEX_25_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_25_REG_BIT_PRIM_LUT_INDEX_25_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_25_REG_BIT_PRIM_LUT_INDEX_25_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_25_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_25_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_25_get", id, 2);
    /* (0x00000148 bits 15:0) field PRIM_LUT_INDEX_25 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_25_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_25_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_25_REG_BIT_PRIM_LUT_INDEX_25_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_25_REG_BIT_PRIM_LUT_INDEX_25_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_25_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_25_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_25_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_25_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_25_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_25_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_25_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000148 bits 15:0) field PRIM_LUT_INDEX_25 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_25_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000148 bits 15:0) field PRIM_LUT_INDEX_25 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_25_REG */
        t8_reg_PRIM_LUT_INDEX_25_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_25_REG_BIT_PRIM_LUT_INDEX_25_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_25_REG_BIT_PRIM_LUT_INDEX_25_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_25_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_25_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_25_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_25_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_25_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000148 bits 15:0) field PRIM_LUT_INDEX_25 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_25_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_25_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_25_REG_BIT_PRIM_LUT_INDEX_25_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_25_REG_BIT_PRIM_LUT_INDEX_25_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_25_REG_BIT_PRIM_LUT_INDEX_25_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_25_REG_BIT_PRIM_LUT_INDEX_25_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_25_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_26_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_26_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_26_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_26_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_26_set", id, value );

    /* (0x0000014c bits 15:0) field PRIM_LUT_INDEX_26 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_26_REG */
    t8_reg_PRIM_LUT_INDEX_26_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_26_REG_BIT_PRIM_LUT_INDEX_26_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_26_REG_BIT_PRIM_LUT_INDEX_26_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_26_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_26_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_26_get", id, 2);
    /* (0x0000014c bits 15:0) field PRIM_LUT_INDEX_26 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_26_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_26_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_26_REG_BIT_PRIM_LUT_INDEX_26_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_26_REG_BIT_PRIM_LUT_INDEX_26_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_26_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_26_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_26_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_26_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_26_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_26_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_26_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000014c bits 15:0) field PRIM_LUT_INDEX_26 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_26_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000014c bits 15:0) field PRIM_LUT_INDEX_26 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_26_REG */
        t8_reg_PRIM_LUT_INDEX_26_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_26_REG_BIT_PRIM_LUT_INDEX_26_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_26_REG_BIT_PRIM_LUT_INDEX_26_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_26_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_26_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_26_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_26_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_26_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000014c bits 15:0) field PRIM_LUT_INDEX_26 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_26_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_26_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_26_REG_BIT_PRIM_LUT_INDEX_26_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_26_REG_BIT_PRIM_LUT_INDEX_26_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_26_REG_BIT_PRIM_LUT_INDEX_26_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_26_REG_BIT_PRIM_LUT_INDEX_26_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_26_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_27_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_27_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_27_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_27_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_27_set", id, value );

    /* (0x00000150 bits 15:0) field PRIM_LUT_INDEX_27 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_27_REG */
    t8_reg_PRIM_LUT_INDEX_27_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_27_REG_BIT_PRIM_LUT_INDEX_27_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_27_REG_BIT_PRIM_LUT_INDEX_27_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_27_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_27_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_27_get", id, 2);
    /* (0x00000150 bits 15:0) field PRIM_LUT_INDEX_27 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_27_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_27_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_27_REG_BIT_PRIM_LUT_INDEX_27_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_27_REG_BIT_PRIM_LUT_INDEX_27_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_27_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_27_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_27_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_27_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_27_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_27_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_27_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000150 bits 15:0) field PRIM_LUT_INDEX_27 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_27_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000150 bits 15:0) field PRIM_LUT_INDEX_27 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_27_REG */
        t8_reg_PRIM_LUT_INDEX_27_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_27_REG_BIT_PRIM_LUT_INDEX_27_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_27_REG_BIT_PRIM_LUT_INDEX_27_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_27_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_27_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_27_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_27_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_27_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000150 bits 15:0) field PRIM_LUT_INDEX_27 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_27_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_27_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_27_REG_BIT_PRIM_LUT_INDEX_27_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_27_REG_BIT_PRIM_LUT_INDEX_27_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_27_REG_BIT_PRIM_LUT_INDEX_27_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_27_REG_BIT_PRIM_LUT_INDEX_27_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_27_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_28_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_28_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_28_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_28_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_28_set", id, value );

    /* (0x00000154 bits 15:0) field PRIM_LUT_INDEX_28 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_28_REG */
    t8_reg_PRIM_LUT_INDEX_28_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_28_REG_BIT_PRIM_LUT_INDEX_28_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_28_REG_BIT_PRIM_LUT_INDEX_28_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_28_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_28_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_28_get", id, 2);
    /* (0x00000154 bits 15:0) field PRIM_LUT_INDEX_28 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_28_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_28_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_28_REG_BIT_PRIM_LUT_INDEX_28_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_28_REG_BIT_PRIM_LUT_INDEX_28_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_28_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_28_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_28_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_28_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_28_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_28_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_28_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000154 bits 15:0) field PRIM_LUT_INDEX_28 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_28_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000154 bits 15:0) field PRIM_LUT_INDEX_28 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_28_REG */
        t8_reg_PRIM_LUT_INDEX_28_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_28_REG_BIT_PRIM_LUT_INDEX_28_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_28_REG_BIT_PRIM_LUT_INDEX_28_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_28_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_28_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_28_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_28_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_28_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000154 bits 15:0) field PRIM_LUT_INDEX_28 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_28_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_28_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_28_REG_BIT_PRIM_LUT_INDEX_28_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_28_REG_BIT_PRIM_LUT_INDEX_28_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_28_REG_BIT_PRIM_LUT_INDEX_28_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_28_REG_BIT_PRIM_LUT_INDEX_28_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_28_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_29_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_29_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_29_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_29_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_29_set", id, value );

    /* (0x00000158 bits 15:0) field PRIM_LUT_INDEX_29 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_29_REG */
    t8_reg_PRIM_LUT_INDEX_29_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_29_REG_BIT_PRIM_LUT_INDEX_29_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_29_REG_BIT_PRIM_LUT_INDEX_29_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_29_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_29_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_29_get", id, 2);
    /* (0x00000158 bits 15:0) field PRIM_LUT_INDEX_29 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_29_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_29_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_29_REG_BIT_PRIM_LUT_INDEX_29_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_29_REG_BIT_PRIM_LUT_INDEX_29_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_29_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_29_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_29_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_29_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_29_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_29_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_29_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000158 bits 15:0) field PRIM_LUT_INDEX_29 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_29_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000158 bits 15:0) field PRIM_LUT_INDEX_29 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_29_REG */
        t8_reg_PRIM_LUT_INDEX_29_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_29_REG_BIT_PRIM_LUT_INDEX_29_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_29_REG_BIT_PRIM_LUT_INDEX_29_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_29_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_29_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_29_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_29_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_29_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000158 bits 15:0) field PRIM_LUT_INDEX_29 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_29_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_29_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_29_REG_BIT_PRIM_LUT_INDEX_29_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_29_REG_BIT_PRIM_LUT_INDEX_29_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_29_REG_BIT_PRIM_LUT_INDEX_29_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_29_REG_BIT_PRIM_LUT_INDEX_29_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_29_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_30_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_30_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_30_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_30_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_30_set", id, value );

    /* (0x0000015c bits 15:0) field PRIM_LUT_INDEX_30 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_30_REG */
    t8_reg_PRIM_LUT_INDEX_30_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_30_REG_BIT_PRIM_LUT_INDEX_30_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_30_REG_BIT_PRIM_LUT_INDEX_30_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_30_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_30_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_30_get", id, 2);
    /* (0x0000015c bits 15:0) field PRIM_LUT_INDEX_30 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_30_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_30_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_30_REG_BIT_PRIM_LUT_INDEX_30_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_30_REG_BIT_PRIM_LUT_INDEX_30_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_30_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_30_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_30_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_30_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_30_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_30_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_30_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000015c bits 15:0) field PRIM_LUT_INDEX_30 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_30_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000015c bits 15:0) field PRIM_LUT_INDEX_30 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_30_REG */
        t8_reg_PRIM_LUT_INDEX_30_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_30_REG_BIT_PRIM_LUT_INDEX_30_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_30_REG_BIT_PRIM_LUT_INDEX_30_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_30_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_30_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_30_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_30_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_30_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000015c bits 15:0) field PRIM_LUT_INDEX_30 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_30_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_30_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_30_REG_BIT_PRIM_LUT_INDEX_30_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_30_REG_BIT_PRIM_LUT_INDEX_30_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_30_REG_BIT_PRIM_LUT_INDEX_30_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_30_REG_BIT_PRIM_LUT_INDEX_30_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_30_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PRIM_LUT_INDEX_31_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PRIM_LUT_INDEX_31_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_31_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PRIM_LUT_INDEX_31_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_31_set", id, value );

    /* (0x00000160 bits 15:0) field PRIM_LUT_INDEX_31 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_31_REG */
    t8_reg_PRIM_LUT_INDEX_31_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_31_REG_BIT_PRIM_LUT_INDEX_31_MSK,
                                            PM20_82_24_REG_PRIM_LUT_INDEX_31_REG_BIT_PRIM_LUT_INDEX_31_OFF,
                                            value);
}

static INLINE UINT32 t8_field_PRIM_LUT_INDEX_31_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PRIM_LUT_INDEX_31_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PRIM_LUT_INDEX_31_get", id, 2);
    /* (0x00000160 bits 15:0) field PRIM_LUT_INDEX_31 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_31_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_31_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_31_REG_BIT_PRIM_LUT_INDEX_31_MSK) >> PM20_82_24_REG_PRIM_LUT_INDEX_31_REG_BIT_PRIM_LUT_INDEX_31_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PRIM_LUT_INDEX_31_get", id, value );

    return value;
}
static INLINE void t8_field_range_PRIM_LUT_INDEX_31_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PRIM_LUT_INDEX_31_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_31_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_31_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_31_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_31_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000160 bits 15:0) field PRIM_LUT_INDEX_31 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_31_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000160 bits 15:0) field PRIM_LUT_INDEX_31 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_31_REG */
        t8_reg_PRIM_LUT_INDEX_31_REG_field_set( b_ptr,
                                                h_ptr,
                                                id,
                                                subfield_mask << (PM20_82_24_REG_PRIM_LUT_INDEX_31_REG_BIT_PRIM_LUT_INDEX_31_OFF + subfield_offset),
                                                PM20_82_24_REG_PRIM_LUT_INDEX_31_REG_BIT_PRIM_LUT_INDEX_31_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_31_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PRIM_LUT_INDEX_31_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PRIM_LUT_INDEX_31_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PRIM_LUT_INDEX_31_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PRIM_LUT_INDEX_31_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000160 bits 15:0) field PRIM_LUT_INDEX_31 of register PMC_PM20_82_24_REG_PRIM_LUT_INDEX_31_REG */
    reg_value = t8_reg_PRIM_LUT_INDEX_31_REG_read( b_ptr,
                                                   h_ptr,
                                                   id);
    field_value = (reg_value & PM20_82_24_REG_PRIM_LUT_INDEX_31_REG_BIT_PRIM_LUT_INDEX_31_MSK)
                  >> PM20_82_24_REG_PRIM_LUT_INDEX_31_REG_BIT_PRIM_LUT_INDEX_31_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PRIM_LUT_INDEX_31_REG_BIT_PRIM_LUT_INDEX_31_MSK, PM20_82_24_REG_PRIM_LUT_INDEX_31_REG_BIT_PRIM_LUT_INDEX_31_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PRIM_LUT_INDEX_31_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ALT_LUT_INDEX_0_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ALT_LUT_INDEX_0_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_0_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ALT_LUT_INDEX_0_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_0_set", id, value );

    /* (0x00000164 bits 15:0) field ALT_LUT_INDEX_0 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_0_REG */
    t8_reg_ALT_LUT_INDEX_0_REG_field_set( b_ptr,
                                          h_ptr,
                                          id,
                                          PM20_82_24_REG_ALT_LUT_INDEX_0_REG_BIT_ALT_LUT_INDEX_0_MSK,
                                          PM20_82_24_REG_ALT_LUT_INDEX_0_REG_BIT_ALT_LUT_INDEX_0_OFF,
                                          value);
}

static INLINE UINT32 t8_field_ALT_LUT_INDEX_0_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ALT_LUT_INDEX_0_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_0_get", id, 2);
    /* (0x00000164 bits 15:0) field ALT_LUT_INDEX_0 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_0_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_0_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_0_REG_BIT_ALT_LUT_INDEX_0_MSK) >> PM20_82_24_REG_ALT_LUT_INDEX_0_REG_BIT_ALT_LUT_INDEX_0_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_0_get", id, value );

    return value;
}
static INLINE void t8_field_range_ALT_LUT_INDEX_0_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ALT_LUT_INDEX_0_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_0_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_0_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_0_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_0_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000164 bits 15:0) field ALT_LUT_INDEX_0 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_0_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000164 bits 15:0) field ALT_LUT_INDEX_0 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_0_REG */
        t8_reg_ALT_LUT_INDEX_0_REG_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              subfield_mask << (PM20_82_24_REG_ALT_LUT_INDEX_0_REG_BIT_ALT_LUT_INDEX_0_OFF + subfield_offset),
                                              PM20_82_24_REG_ALT_LUT_INDEX_0_REG_BIT_ALT_LUT_INDEX_0_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_0_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_0_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_0_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_0_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_0_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000164 bits 15:0) field ALT_LUT_INDEX_0 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_0_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_0_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_0_REG_BIT_ALT_LUT_INDEX_0_MSK)
                  >> PM20_82_24_REG_ALT_LUT_INDEX_0_REG_BIT_ALT_LUT_INDEX_0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ALT_LUT_INDEX_0_REG_BIT_ALT_LUT_INDEX_0_MSK, PM20_82_24_REG_ALT_LUT_INDEX_0_REG_BIT_ALT_LUT_INDEX_0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_0_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ALT_LUT_INDEX_1_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ALT_LUT_INDEX_1_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_1_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ALT_LUT_INDEX_1_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_1_set", id, value );

    /* (0x00000168 bits 15:0) field ALT_LUT_INDEX_1 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_1_REG */
    t8_reg_ALT_LUT_INDEX_1_REG_field_set( b_ptr,
                                          h_ptr,
                                          id,
                                          PM20_82_24_REG_ALT_LUT_INDEX_1_REG_BIT_ALT_LUT_INDEX_1_MSK,
                                          PM20_82_24_REG_ALT_LUT_INDEX_1_REG_BIT_ALT_LUT_INDEX_1_OFF,
                                          value);
}

static INLINE UINT32 t8_field_ALT_LUT_INDEX_1_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ALT_LUT_INDEX_1_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_1_get", id, 2);
    /* (0x00000168 bits 15:0) field ALT_LUT_INDEX_1 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_1_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_1_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_1_REG_BIT_ALT_LUT_INDEX_1_MSK) >> PM20_82_24_REG_ALT_LUT_INDEX_1_REG_BIT_ALT_LUT_INDEX_1_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_1_get", id, value );

    return value;
}
static INLINE void t8_field_range_ALT_LUT_INDEX_1_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ALT_LUT_INDEX_1_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_1_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_1_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_1_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_1_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000168 bits 15:0) field ALT_LUT_INDEX_1 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_1_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000168 bits 15:0) field ALT_LUT_INDEX_1 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_1_REG */
        t8_reg_ALT_LUT_INDEX_1_REG_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              subfield_mask << (PM20_82_24_REG_ALT_LUT_INDEX_1_REG_BIT_ALT_LUT_INDEX_1_OFF + subfield_offset),
                                              PM20_82_24_REG_ALT_LUT_INDEX_1_REG_BIT_ALT_LUT_INDEX_1_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_1_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_1_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_1_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_1_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_1_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000168 bits 15:0) field ALT_LUT_INDEX_1 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_1_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_1_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_1_REG_BIT_ALT_LUT_INDEX_1_MSK)
                  >> PM20_82_24_REG_ALT_LUT_INDEX_1_REG_BIT_ALT_LUT_INDEX_1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ALT_LUT_INDEX_1_REG_BIT_ALT_LUT_INDEX_1_MSK, PM20_82_24_REG_ALT_LUT_INDEX_1_REG_BIT_ALT_LUT_INDEX_1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_1_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ALT_LUT_INDEX_2_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ALT_LUT_INDEX_2_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_2_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ALT_LUT_INDEX_2_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_2_set", id, value );

    /* (0x0000016c bits 15:0) field ALT_LUT_INDEX_2 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_2_REG */
    t8_reg_ALT_LUT_INDEX_2_REG_field_set( b_ptr,
                                          h_ptr,
                                          id,
                                          PM20_82_24_REG_ALT_LUT_INDEX_2_REG_BIT_ALT_LUT_INDEX_2_MSK,
                                          PM20_82_24_REG_ALT_LUT_INDEX_2_REG_BIT_ALT_LUT_INDEX_2_OFF,
                                          value);
}

static INLINE UINT32 t8_field_ALT_LUT_INDEX_2_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ALT_LUT_INDEX_2_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_2_get", id, 2);
    /* (0x0000016c bits 15:0) field ALT_LUT_INDEX_2 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_2_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_2_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_2_REG_BIT_ALT_LUT_INDEX_2_MSK) >> PM20_82_24_REG_ALT_LUT_INDEX_2_REG_BIT_ALT_LUT_INDEX_2_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_2_get", id, value );

    return value;
}
static INLINE void t8_field_range_ALT_LUT_INDEX_2_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ALT_LUT_INDEX_2_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_2_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_2_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_2_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_2_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000016c bits 15:0) field ALT_LUT_INDEX_2 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_2_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000016c bits 15:0) field ALT_LUT_INDEX_2 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_2_REG */
        t8_reg_ALT_LUT_INDEX_2_REG_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              subfield_mask << (PM20_82_24_REG_ALT_LUT_INDEX_2_REG_BIT_ALT_LUT_INDEX_2_OFF + subfield_offset),
                                              PM20_82_24_REG_ALT_LUT_INDEX_2_REG_BIT_ALT_LUT_INDEX_2_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_2_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_2_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_2_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_2_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_2_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000016c bits 15:0) field ALT_LUT_INDEX_2 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_2_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_2_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_2_REG_BIT_ALT_LUT_INDEX_2_MSK)
                  >> PM20_82_24_REG_ALT_LUT_INDEX_2_REG_BIT_ALT_LUT_INDEX_2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ALT_LUT_INDEX_2_REG_BIT_ALT_LUT_INDEX_2_MSK, PM20_82_24_REG_ALT_LUT_INDEX_2_REG_BIT_ALT_LUT_INDEX_2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_2_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ALT_LUT_INDEX_3_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ALT_LUT_INDEX_3_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_3_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ALT_LUT_INDEX_3_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_3_set", id, value );

    /* (0x00000170 bits 15:0) field ALT_LUT_INDEX_3 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_3_REG */
    t8_reg_ALT_LUT_INDEX_3_REG_field_set( b_ptr,
                                          h_ptr,
                                          id,
                                          PM20_82_24_REG_ALT_LUT_INDEX_3_REG_BIT_ALT_LUT_INDEX_3_MSK,
                                          PM20_82_24_REG_ALT_LUT_INDEX_3_REG_BIT_ALT_LUT_INDEX_3_OFF,
                                          value);
}

static INLINE UINT32 t8_field_ALT_LUT_INDEX_3_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ALT_LUT_INDEX_3_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_3_get", id, 2);
    /* (0x00000170 bits 15:0) field ALT_LUT_INDEX_3 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_3_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_3_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_3_REG_BIT_ALT_LUT_INDEX_3_MSK) >> PM20_82_24_REG_ALT_LUT_INDEX_3_REG_BIT_ALT_LUT_INDEX_3_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_3_get", id, value );

    return value;
}
static INLINE void t8_field_range_ALT_LUT_INDEX_3_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ALT_LUT_INDEX_3_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_3_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_3_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_3_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_3_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000170 bits 15:0) field ALT_LUT_INDEX_3 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_3_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000170 bits 15:0) field ALT_LUT_INDEX_3 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_3_REG */
        t8_reg_ALT_LUT_INDEX_3_REG_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              subfield_mask << (PM20_82_24_REG_ALT_LUT_INDEX_3_REG_BIT_ALT_LUT_INDEX_3_OFF + subfield_offset),
                                              PM20_82_24_REG_ALT_LUT_INDEX_3_REG_BIT_ALT_LUT_INDEX_3_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_3_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_3_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_3_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_3_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_3_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000170 bits 15:0) field ALT_LUT_INDEX_3 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_3_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_3_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_3_REG_BIT_ALT_LUT_INDEX_3_MSK)
                  >> PM20_82_24_REG_ALT_LUT_INDEX_3_REG_BIT_ALT_LUT_INDEX_3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ALT_LUT_INDEX_3_REG_BIT_ALT_LUT_INDEX_3_MSK, PM20_82_24_REG_ALT_LUT_INDEX_3_REG_BIT_ALT_LUT_INDEX_3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_3_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ALT_LUT_INDEX_4_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ALT_LUT_INDEX_4_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_4_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ALT_LUT_INDEX_4_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_4_set", id, value );

    /* (0x00000174 bits 15:0) field ALT_LUT_INDEX_4 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_4_REG */
    t8_reg_ALT_LUT_INDEX_4_REG_field_set( b_ptr,
                                          h_ptr,
                                          id,
                                          PM20_82_24_REG_ALT_LUT_INDEX_4_REG_BIT_ALT_LUT_INDEX_4_MSK,
                                          PM20_82_24_REG_ALT_LUT_INDEX_4_REG_BIT_ALT_LUT_INDEX_4_OFF,
                                          value);
}

static INLINE UINT32 t8_field_ALT_LUT_INDEX_4_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ALT_LUT_INDEX_4_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_4_get", id, 2);
    /* (0x00000174 bits 15:0) field ALT_LUT_INDEX_4 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_4_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_4_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_4_REG_BIT_ALT_LUT_INDEX_4_MSK) >> PM20_82_24_REG_ALT_LUT_INDEX_4_REG_BIT_ALT_LUT_INDEX_4_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_4_get", id, value );

    return value;
}
static INLINE void t8_field_range_ALT_LUT_INDEX_4_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ALT_LUT_INDEX_4_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_4_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_4_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_4_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_4_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000174 bits 15:0) field ALT_LUT_INDEX_4 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_4_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000174 bits 15:0) field ALT_LUT_INDEX_4 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_4_REG */
        t8_reg_ALT_LUT_INDEX_4_REG_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              subfield_mask << (PM20_82_24_REG_ALT_LUT_INDEX_4_REG_BIT_ALT_LUT_INDEX_4_OFF + subfield_offset),
                                              PM20_82_24_REG_ALT_LUT_INDEX_4_REG_BIT_ALT_LUT_INDEX_4_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_4_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_4_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_4_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_4_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_4_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000174 bits 15:0) field ALT_LUT_INDEX_4 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_4_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_4_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_4_REG_BIT_ALT_LUT_INDEX_4_MSK)
                  >> PM20_82_24_REG_ALT_LUT_INDEX_4_REG_BIT_ALT_LUT_INDEX_4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ALT_LUT_INDEX_4_REG_BIT_ALT_LUT_INDEX_4_MSK, PM20_82_24_REG_ALT_LUT_INDEX_4_REG_BIT_ALT_LUT_INDEX_4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_4_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ALT_LUT_INDEX_5_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ALT_LUT_INDEX_5_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_5_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ALT_LUT_INDEX_5_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_5_set", id, value );

    /* (0x00000178 bits 15:0) field ALT_LUT_INDEX_5 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_5_REG */
    t8_reg_ALT_LUT_INDEX_5_REG_field_set( b_ptr,
                                          h_ptr,
                                          id,
                                          PM20_82_24_REG_ALT_LUT_INDEX_5_REG_BIT_ALT_LUT_INDEX_5_MSK,
                                          PM20_82_24_REG_ALT_LUT_INDEX_5_REG_BIT_ALT_LUT_INDEX_5_OFF,
                                          value);
}

static INLINE UINT32 t8_field_ALT_LUT_INDEX_5_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ALT_LUT_INDEX_5_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_5_get", id, 2);
    /* (0x00000178 bits 15:0) field ALT_LUT_INDEX_5 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_5_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_5_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_5_REG_BIT_ALT_LUT_INDEX_5_MSK) >> PM20_82_24_REG_ALT_LUT_INDEX_5_REG_BIT_ALT_LUT_INDEX_5_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_5_get", id, value );

    return value;
}
static INLINE void t8_field_range_ALT_LUT_INDEX_5_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ALT_LUT_INDEX_5_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_5_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_5_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_5_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_5_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000178 bits 15:0) field ALT_LUT_INDEX_5 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_5_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000178 bits 15:0) field ALT_LUT_INDEX_5 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_5_REG */
        t8_reg_ALT_LUT_INDEX_5_REG_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              subfield_mask << (PM20_82_24_REG_ALT_LUT_INDEX_5_REG_BIT_ALT_LUT_INDEX_5_OFF + subfield_offset),
                                              PM20_82_24_REG_ALT_LUT_INDEX_5_REG_BIT_ALT_LUT_INDEX_5_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_5_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_5_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_5_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_5_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_5_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000178 bits 15:0) field ALT_LUT_INDEX_5 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_5_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_5_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_5_REG_BIT_ALT_LUT_INDEX_5_MSK)
                  >> PM20_82_24_REG_ALT_LUT_INDEX_5_REG_BIT_ALT_LUT_INDEX_5_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ALT_LUT_INDEX_5_REG_BIT_ALT_LUT_INDEX_5_MSK, PM20_82_24_REG_ALT_LUT_INDEX_5_REG_BIT_ALT_LUT_INDEX_5_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_5_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ALT_LUT_INDEX_6_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ALT_LUT_INDEX_6_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_6_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ALT_LUT_INDEX_6_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_6_set", id, value );

    /* (0x0000017c bits 15:0) field ALT_LUT_INDEX_6 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_6_REG */
    t8_reg_ALT_LUT_INDEX_6_REG_field_set( b_ptr,
                                          h_ptr,
                                          id,
                                          PM20_82_24_REG_ALT_LUT_INDEX_6_REG_BIT_ALT_LUT_INDEX_6_MSK,
                                          PM20_82_24_REG_ALT_LUT_INDEX_6_REG_BIT_ALT_LUT_INDEX_6_OFF,
                                          value);
}

static INLINE UINT32 t8_field_ALT_LUT_INDEX_6_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ALT_LUT_INDEX_6_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_6_get", id, 2);
    /* (0x0000017c bits 15:0) field ALT_LUT_INDEX_6 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_6_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_6_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_6_REG_BIT_ALT_LUT_INDEX_6_MSK) >> PM20_82_24_REG_ALT_LUT_INDEX_6_REG_BIT_ALT_LUT_INDEX_6_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_6_get", id, value );

    return value;
}
static INLINE void t8_field_range_ALT_LUT_INDEX_6_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ALT_LUT_INDEX_6_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_6_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_6_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_6_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_6_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000017c bits 15:0) field ALT_LUT_INDEX_6 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_6_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000017c bits 15:0) field ALT_LUT_INDEX_6 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_6_REG */
        t8_reg_ALT_LUT_INDEX_6_REG_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              subfield_mask << (PM20_82_24_REG_ALT_LUT_INDEX_6_REG_BIT_ALT_LUT_INDEX_6_OFF + subfield_offset),
                                              PM20_82_24_REG_ALT_LUT_INDEX_6_REG_BIT_ALT_LUT_INDEX_6_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_6_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_6_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_6_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_6_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_6_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000017c bits 15:0) field ALT_LUT_INDEX_6 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_6_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_6_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_6_REG_BIT_ALT_LUT_INDEX_6_MSK)
                  >> PM20_82_24_REG_ALT_LUT_INDEX_6_REG_BIT_ALT_LUT_INDEX_6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ALT_LUT_INDEX_6_REG_BIT_ALT_LUT_INDEX_6_MSK, PM20_82_24_REG_ALT_LUT_INDEX_6_REG_BIT_ALT_LUT_INDEX_6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_6_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ALT_LUT_INDEX_7_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ALT_LUT_INDEX_7_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_7_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ALT_LUT_INDEX_7_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_7_set", id, value );

    /* (0x00000180 bits 15:0) field ALT_LUT_INDEX_7 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_7_REG */
    t8_reg_ALT_LUT_INDEX_7_REG_field_set( b_ptr,
                                          h_ptr,
                                          id,
                                          PM20_82_24_REG_ALT_LUT_INDEX_7_REG_BIT_ALT_LUT_INDEX_7_MSK,
                                          PM20_82_24_REG_ALT_LUT_INDEX_7_REG_BIT_ALT_LUT_INDEX_7_OFF,
                                          value);
}

static INLINE UINT32 t8_field_ALT_LUT_INDEX_7_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ALT_LUT_INDEX_7_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ALT_LUT_INDEX_7_get", id, 2);
    /* (0x00000180 bits 15:0) field ALT_LUT_INDEX_7 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_7_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_7_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_7_REG_BIT_ALT_LUT_INDEX_7_MSK) >> PM20_82_24_REG_ALT_LUT_INDEX_7_REG_BIT_ALT_LUT_INDEX_7_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ALT_LUT_INDEX_7_get", id, value );

    return value;
}
static INLINE void t8_field_range_ALT_LUT_INDEX_7_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ALT_LUT_INDEX_7_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_7_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_7_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_7_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_7_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000180 bits 15:0) field ALT_LUT_INDEX_7 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_7_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000180 bits 15:0) field ALT_LUT_INDEX_7 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_7_REG */
        t8_reg_ALT_LUT_INDEX_7_REG_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              subfield_mask << (PM20_82_24_REG_ALT_LUT_INDEX_7_REG_BIT_ALT_LUT_INDEX_7_OFF + subfield_offset),
                                              PM20_82_24_REG_ALT_LUT_INDEX_7_REG_BIT_ALT_LUT_INDEX_7_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_7_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ALT_LUT_INDEX_7_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ALT_LUT_INDEX_7_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ALT_LUT_INDEX_7_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ALT_LUT_INDEX_7_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000180 bits 15:0) field ALT_LUT_INDEX_7 of register PMC_PM20_82_24_REG_ALT_LUT_INDEX_7_REG */
    reg_value = t8_reg_ALT_LUT_INDEX_7_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ALT_LUT_INDEX_7_REG_BIT_ALT_LUT_INDEX_7_MSK)
                  >> PM20_82_24_REG_ALT_LUT_INDEX_7_REG_BIT_ALT_LUT_INDEX_7_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ALT_LUT_INDEX_7_REG_BIT_ALT_LUT_INDEX_7_MSK, PM20_82_24_REG_ALT_LUT_INDEX_7_REG_BIT_ALT_LUT_INDEX_7_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ALT_LUT_INDEX_7_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PLEN_set( t8_buffer_t *b_ptr,
                                      t8_handle_t *h_ptr,
                                      UINT32 id,
                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PLEN_set( t8_buffer_t *b_ptr,
                                      t8_handle_t *h_ptr,
                                      UINT32 id,
                                      UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLEN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PLEN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PLEN_set", id, value );

    /* (0x00000184 bits 24) field PLEN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    t8_reg_PGA_LUT_CTRL_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_PLEN_MSK,
                                       PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_PLEN_OFF,
                                       value);
}

static INLINE UINT32 t8_field_PLEN_get( t8_buffer_t *b_ptr,
                                        t8_handle_t *h_ptr,
                                        UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PLEN_get( t8_buffer_t *b_ptr,
                                        t8_handle_t *h_ptr,
                                        UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLEN_get", id, 2);
    /* (0x00000184 bits 24) field PLEN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    reg_value = t8_reg_PGA_LUT_CTRL_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_PLEN_MSK) >> PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_PLEN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PLEN_get", id, value );

    return value;
}
static INLINE void t8_field_CG_S2_IN_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CG_S2_IN_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CG_S2_IN_set", id, 2);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CG_S2_IN_set", value, 7);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CG_S2_IN_set", id, value );

    /* (0x00000184 bits 22:20) bits 0:2 use field CG_S2_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    t8_reg_PGA_LUT_CTRL_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S2_IN_MSK,
                                       PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S2_IN_OFF,
                                       value);
}

static INLINE UINT32 t8_field_CG_S2_IN_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CG_S2_IN_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CG_S2_IN_get", id, 2);
    /* (0x00000184 bits 22:20) bits 0:2 use field CG_S2_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    reg_value = t8_reg_PGA_LUT_CTRL_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S2_IN_MSK) >> PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S2_IN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CG_S2_IN_get", id, value );

    return value;
}
static INLINE void t8_field_range_CG_S2_IN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_CG_S2_IN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CG_S2_IN_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CG_S2_IN_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CG_S2_IN_set", stop_bit, 2 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CG_S2_IN_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000184 bits 22:20) bits 0:2 use field CG_S2_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000184 bits 22:20) bits 0:2 use field CG_S2_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
        t8_reg_PGA_LUT_CTRL_REG_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           subfield_mask << (PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S2_IN_OFF + subfield_offset),
                                           PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S2_IN_OFF + subfield_offset,
                                           value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_CG_S2_IN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_CG_S2_IN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CG_S2_IN_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CG_S2_IN_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CG_S2_IN_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000184 bits 22:20) bits 0:2 use field CG_S2_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    reg_value = t8_reg_PGA_LUT_CTRL_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S2_IN_MSK)
                  >> PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S2_IN_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S2_IN_MSK, PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S2_IN_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CG_S2_IN_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_CG_S1_IN_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CG_S1_IN_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CG_S1_IN_set", id, 2);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CG_S1_IN_set", value, 7);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CG_S1_IN_set", id, value );

    /* (0x00000184 bits 18:16) bits 0:2 use field CG_S1_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    t8_reg_PGA_LUT_CTRL_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S1_IN_MSK,
                                       PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S1_IN_OFF,
                                       value);
}

static INLINE UINT32 t8_field_CG_S1_IN_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CG_S1_IN_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CG_S1_IN_get", id, 2);
    /* (0x00000184 bits 18:16) bits 0:2 use field CG_S1_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    reg_value = t8_reg_PGA_LUT_CTRL_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S1_IN_MSK) >> PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S1_IN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CG_S1_IN_get", id, value );

    return value;
}
static INLINE void t8_field_range_CG_S1_IN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_CG_S1_IN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CG_S1_IN_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CG_S1_IN_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CG_S1_IN_set", stop_bit, 2 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CG_S1_IN_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000184 bits 18:16) bits 0:2 use field CG_S1_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000184 bits 18:16) bits 0:2 use field CG_S1_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
        t8_reg_PGA_LUT_CTRL_REG_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           subfield_mask << (PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S1_IN_OFF + subfield_offset),
                                           PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S1_IN_OFF + subfield_offset,
                                           value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_CG_S1_IN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_CG_S1_IN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CG_S1_IN_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CG_S1_IN_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CG_S1_IN_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000184 bits 18:16) bits 0:2 use field CG_S1_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    reg_value = t8_reg_PGA_LUT_CTRL_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S1_IN_MSK)
                  >> PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S1_IN_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S1_IN_MSK, PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_CG_S1_IN_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CG_S1_IN_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_RG_S2_IN_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_RG_S2_IN_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RG_S2_IN_set", id, 2);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_RG_S2_IN_set", value, 15);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_RG_S2_IN_set", id, value );

    /* (0x00000184 bits 15:12) bits 0:3 use field RG_S2_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    t8_reg_PGA_LUT_CTRL_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S2_IN_MSK,
                                       PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S2_IN_OFF,
                                       value);
}

static INLINE UINT32 t8_field_RG_S2_IN_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_RG_S2_IN_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RG_S2_IN_get", id, 2);
    /* (0x00000184 bits 15:12) bits 0:3 use field RG_S2_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    reg_value = t8_reg_PGA_LUT_CTRL_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S2_IN_MSK) >> PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S2_IN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_RG_S2_IN_get", id, value );

    return value;
}
static INLINE void t8_field_range_RG_S2_IN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_RG_S2_IN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_RG_S2_IN_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_RG_S2_IN_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_RG_S2_IN_set", stop_bit, 3 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_RG_S2_IN_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000184 bits 15:12) bits 0:3 use field RG_S2_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000184 bits 15:12) bits 0:3 use field RG_S2_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
        t8_reg_PGA_LUT_CTRL_REG_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           subfield_mask << (PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S2_IN_OFF + subfield_offset),
                                           PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S2_IN_OFF + subfield_offset,
                                           value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_RG_S2_IN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_RG_S2_IN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_RG_S2_IN_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_RG_S2_IN_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_RG_S2_IN_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000184 bits 15:12) bits 0:3 use field RG_S2_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    reg_value = t8_reg_PGA_LUT_CTRL_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S2_IN_MSK)
                  >> PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S2_IN_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S2_IN_MSK, PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S2_IN_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_RG_S2_IN_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_RG_S1_IN_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_RG_S1_IN_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RG_S1_IN_set", id, 2);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_RG_S1_IN_set", value, 15);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_RG_S1_IN_set", id, value );

    /* (0x00000184 bits 11:8) bits 0:3 use field RG_S1_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    t8_reg_PGA_LUT_CTRL_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S1_IN_MSK,
                                       PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S1_IN_OFF,
                                       value);
}

static INLINE UINT32 t8_field_RG_S1_IN_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_RG_S1_IN_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RG_S1_IN_get", id, 2);
    /* (0x00000184 bits 11:8) bits 0:3 use field RG_S1_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    reg_value = t8_reg_PGA_LUT_CTRL_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S1_IN_MSK) >> PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S1_IN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_RG_S1_IN_get", id, value );

    return value;
}
static INLINE void t8_field_range_RG_S1_IN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_RG_S1_IN_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_RG_S1_IN_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_RG_S1_IN_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_RG_S1_IN_set", stop_bit, 3 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_RG_S1_IN_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000184 bits 11:8) bits 0:3 use field RG_S1_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000184 bits 11:8) bits 0:3 use field RG_S1_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
        t8_reg_PGA_LUT_CTRL_REG_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           subfield_mask << (PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S1_IN_OFF + subfield_offset),
                                           PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S1_IN_OFF + subfield_offset,
                                           value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_RG_S1_IN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_RG_S1_IN_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_RG_S1_IN_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_RG_S1_IN_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_RG_S1_IN_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000184 bits 11:8) bits 0:3 use field RG_S1_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    reg_value = t8_reg_PGA_LUT_CTRL_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S1_IN_MSK)
                  >> PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S1_IN_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S1_IN_MSK, PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_RG_S1_IN_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_RG_S1_IN_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ATTENUATE_EN_IN_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ATTENUATE_EN_IN_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ATTENUATE_EN_IN_set", id, 2);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ATTENUATE_EN_IN_set", value, 3);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ATTENUATE_EN_IN_set", id, value );

    /* (0x00000184 bits 1:0) bits 0:1 use field ATTENUATE_EN_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    t8_reg_PGA_LUT_CTRL_REG_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_ATTENUATE_EN_IN_MSK,
                                       PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_ATTENUATE_EN_IN_OFF,
                                       value);
}

static INLINE UINT32 t8_field_ATTENUATE_EN_IN_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ATTENUATE_EN_IN_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ATTENUATE_EN_IN_get", id, 2);
    /* (0x00000184 bits 1:0) bits 0:1 use field ATTENUATE_EN_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    reg_value = t8_reg_PGA_LUT_CTRL_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_ATTENUATE_EN_IN_MSK) >> PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_ATTENUATE_EN_IN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ATTENUATE_EN_IN_get", id, value );

    return value;
}
static INLINE void t8_field_range_ATTENUATE_EN_IN_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_ATTENUATE_EN_IN_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ATTENUATE_EN_IN_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ATTENUATE_EN_IN_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ATTENUATE_EN_IN_set", stop_bit, 1 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ATTENUATE_EN_IN_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000184 bits 1:0) bits 0:1 use field ATTENUATE_EN_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000184 bits 1:0) bits 0:1 use field ATTENUATE_EN_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
        t8_reg_PGA_LUT_CTRL_REG_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           subfield_mask << (PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_ATTENUATE_EN_IN_OFF + subfield_offset),
                                           PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_ATTENUATE_EN_IN_OFF + subfield_offset,
                                           value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_ATTENUATE_EN_IN_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ATTENUATE_EN_IN_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ATTENUATE_EN_IN_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ATTENUATE_EN_IN_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ATTENUATE_EN_IN_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000184 bits 1:0) bits 0:1 use field ATTENUATE_EN_IN of register PMC_PM20_82_24_REG_PGA_LUT_CTRL_REG */
    reg_value = t8_reg_PGA_LUT_CTRL_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_ATTENUATE_EN_IN_MSK)
                  >> PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_ATTENUATE_EN_IN_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_ATTENUATE_EN_IN_MSK, PM20_82_24_REG_PGA_LUT_CTRL_REG_BIT_ATTENUATE_EN_IN_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ATTENUATE_EN_IN_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_CLK_CNT_MAX_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CLK_CNT_MAX_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CLK_CNT_MAX_set", id, 2);
    if (value > 1048575)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CLK_CNT_MAX_set", value, 1048575);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CLK_CNT_MAX_set", id, value );

    /* (0x00000188 bits 19:0) field CLK_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG2 */
    t8_reg_PLL_CNFG_REG2_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_PLL_CNFG_REG2_BIT_CLK_CNT_MAX_MSK,
                                    PM20_82_24_REG_PLL_CNFG_REG2_BIT_CLK_CNT_MAX_OFF,
                                    value);
}

static INLINE UINT32 t8_field_CLK_CNT_MAX_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CLK_CNT_MAX_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CLK_CNT_MAX_get", id, 2);
    /* (0x00000188 bits 19:0) field CLK_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG2 */
    reg_value = t8_reg_PLL_CNFG_REG2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PLL_CNFG_REG2_BIT_CLK_CNT_MAX_MSK) >> PM20_82_24_REG_PLL_CNFG_REG2_BIT_CLK_CNT_MAX_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CLK_CNT_MAX_get", id, value );

    return value;
}
static INLINE void t8_field_range_CLK_CNT_MAX_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_CLK_CNT_MAX_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CLK_CNT_MAX_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CLK_CNT_MAX_set", stop_bit, start_bit );
    if (stop_bit > 19) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CLK_CNT_MAX_set", stop_bit, 19 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CLK_CNT_MAX_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000188 bits 19:0) field CLK_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 19) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 19;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000188 bits 19:0) field CLK_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG2 */
        t8_reg_PLL_CNFG_REG2_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        subfield_mask << (PM20_82_24_REG_PLL_CNFG_REG2_BIT_CLK_CNT_MAX_OFF + subfield_offset),
                                        PM20_82_24_REG_PLL_CNFG_REG2_BIT_CLK_CNT_MAX_OFF + subfield_offset,
                                        value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_CLK_CNT_MAX_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_CLK_CNT_MAX_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CLK_CNT_MAX_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CLK_CNT_MAX_get", stop_bit, start_bit );
    if (stop_bit > 19) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CLK_CNT_MAX_get", stop_bit, 19 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 19) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 19;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000188 bits 19:0) field CLK_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG2 */
    reg_value = t8_reg_PLL_CNFG_REG2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PLL_CNFG_REG2_BIT_CLK_CNT_MAX_MSK)
                  >> PM20_82_24_REG_PLL_CNFG_REG2_BIT_CLK_CNT_MAX_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PLL_CNFG_REG2_BIT_CLK_CNT_MAX_MSK, PM20_82_24_REG_PLL_CNFG_REG2_BIT_CLK_CNT_MAX_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CLK_CNT_MAX_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_FAIL_CNT_MAX_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_FAIL_CNT_MAX_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_FAIL_CNT_MAX_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_FAIL_CNT_MAX_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_FAIL_CNT_MAX_set", id, value );

    /* (0x0000018c bits 31:16) field FAIL_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG4 */
    t8_reg_PLL_CNFG_REG4_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_PLL_CNFG_REG4_BIT_FAIL_CNT_MAX_MSK,
                                    PM20_82_24_REG_PLL_CNFG_REG4_BIT_FAIL_CNT_MAX_OFF,
                                    value);
}

static INLINE UINT32 t8_field_FAIL_CNT_MAX_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_FAIL_CNT_MAX_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_FAIL_CNT_MAX_get", id, 2);
    /* (0x0000018c bits 31:16) field FAIL_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG4 */
    reg_value = t8_reg_PLL_CNFG_REG4_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PLL_CNFG_REG4_BIT_FAIL_CNT_MAX_MSK) >> PM20_82_24_REG_PLL_CNFG_REG4_BIT_FAIL_CNT_MAX_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_FAIL_CNT_MAX_get", id, value );

    return value;
}
static INLINE void t8_field_range_FAIL_CNT_MAX_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_FAIL_CNT_MAX_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_FAIL_CNT_MAX_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_FAIL_CNT_MAX_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_FAIL_CNT_MAX_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_FAIL_CNT_MAX_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000018c bits 31:16) field FAIL_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000018c bits 31:16) field FAIL_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG4 */
        t8_reg_PLL_CNFG_REG4_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        subfield_mask << (PM20_82_24_REG_PLL_CNFG_REG4_BIT_FAIL_CNT_MAX_OFF + subfield_offset),
                                        PM20_82_24_REG_PLL_CNFG_REG4_BIT_FAIL_CNT_MAX_OFF + subfield_offset,
                                        value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_FAIL_CNT_MAX_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_FAIL_CNT_MAX_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_FAIL_CNT_MAX_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_FAIL_CNT_MAX_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_FAIL_CNT_MAX_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000018c bits 31:16) field FAIL_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG4 */
    reg_value = t8_reg_PLL_CNFG_REG4_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PLL_CNFG_REG4_BIT_FAIL_CNT_MAX_MSK)
                  >> PM20_82_24_REG_PLL_CNFG_REG4_BIT_FAIL_CNT_MAX_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PLL_CNFG_REG4_BIT_FAIL_CNT_MAX_MSK, PM20_82_24_REG_PLL_CNFG_REG4_BIT_FAIL_CNT_MAX_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_FAIL_CNT_MAX_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PASS_CNT_MAX_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PASS_CNT_MAX_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PASS_CNT_MAX_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PASS_CNT_MAX_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PASS_CNT_MAX_set", id, value );

    /* (0x0000018c bits 15:0) field PASS_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG4 */
    t8_reg_PLL_CNFG_REG4_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_PLL_CNFG_REG4_BIT_PASS_CNT_MAX_MSK,
                                    PM20_82_24_REG_PLL_CNFG_REG4_BIT_PASS_CNT_MAX_OFF,
                                    value);
}

static INLINE UINT32 t8_field_PASS_CNT_MAX_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PASS_CNT_MAX_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PASS_CNT_MAX_get", id, 2);
    /* (0x0000018c bits 15:0) field PASS_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG4 */
    reg_value = t8_reg_PLL_CNFG_REG4_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PLL_CNFG_REG4_BIT_PASS_CNT_MAX_MSK) >> PM20_82_24_REG_PLL_CNFG_REG4_BIT_PASS_CNT_MAX_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PASS_CNT_MAX_get", id, value );

    return value;
}
static INLINE void t8_field_range_PASS_CNT_MAX_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PASS_CNT_MAX_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PASS_CNT_MAX_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PASS_CNT_MAX_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PASS_CNT_MAX_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PASS_CNT_MAX_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000018c bits 15:0) field PASS_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000018c bits 15:0) field PASS_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG4 */
        t8_reg_PLL_CNFG_REG4_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        subfield_mask << (PM20_82_24_REG_PLL_CNFG_REG4_BIT_PASS_CNT_MAX_OFF + subfield_offset),
                                        PM20_82_24_REG_PLL_CNFG_REG4_BIT_PASS_CNT_MAX_OFF + subfield_offset,
                                        value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PASS_CNT_MAX_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PASS_CNT_MAX_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PASS_CNT_MAX_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PASS_CNT_MAX_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PASS_CNT_MAX_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000018c bits 15:0) field PASS_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG4 */
    reg_value = t8_reg_PLL_CNFG_REG4_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PLL_CNFG_REG4_BIT_PASS_CNT_MAX_MSK)
                  >> PM20_82_24_REG_PLL_CNFG_REG4_BIT_PASS_CNT_MAX_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PLL_CNFG_REG4_BIT_PASS_CNT_MAX_MSK, PM20_82_24_REG_PLL_CNFG_REG4_BIT_PASS_CNT_MAX_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PASS_CNT_MAX_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_LOCK_CNT_MAX_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_LOCK_CNT_MAX_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LOCK_CNT_MAX_set", id, 2);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_LOCK_CNT_MAX_set", value, 255);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_LOCK_CNT_MAX_set", id, value );

    /* (0x00000190 bits 7:0) field LOCK_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG6 */
    t8_reg_PLL_CNFG_REG6_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_PLL_CNFG_REG6_BIT_LOCK_CNT_MAX_MSK,
                                    PM20_82_24_REG_PLL_CNFG_REG6_BIT_LOCK_CNT_MAX_OFF,
                                    value);
}

static INLINE UINT32 t8_field_LOCK_CNT_MAX_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_LOCK_CNT_MAX_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LOCK_CNT_MAX_get", id, 2);
    /* (0x00000190 bits 7:0) field LOCK_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG6 */
    reg_value = t8_reg_PLL_CNFG_REG6_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PLL_CNFG_REG6_BIT_LOCK_CNT_MAX_MSK) >> PM20_82_24_REG_PLL_CNFG_REG6_BIT_LOCK_CNT_MAX_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_LOCK_CNT_MAX_get", id, value );

    return value;
}
static INLINE void t8_field_range_LOCK_CNT_MAX_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_LOCK_CNT_MAX_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_LOCK_CNT_MAX_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_LOCK_CNT_MAX_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_LOCK_CNT_MAX_set", stop_bit, 7 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_LOCK_CNT_MAX_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000190 bits 7:0) field LOCK_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG6 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000190 bits 7:0) field LOCK_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG6 */
        t8_reg_PLL_CNFG_REG6_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        subfield_mask << (PM20_82_24_REG_PLL_CNFG_REG6_BIT_LOCK_CNT_MAX_OFF + subfield_offset),
                                        PM20_82_24_REG_PLL_CNFG_REG6_BIT_LOCK_CNT_MAX_OFF + subfield_offset,
                                        value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_LOCK_CNT_MAX_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_LOCK_CNT_MAX_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_LOCK_CNT_MAX_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_LOCK_CNT_MAX_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_LOCK_CNT_MAX_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000190 bits 7:0) field LOCK_CNT_MAX of register PMC_PM20_82_24_REG_PLL_CNFG_REG6 */
    reg_value = t8_reg_PLL_CNFG_REG6_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PLL_CNFG_REG6_BIT_LOCK_CNT_MAX_MSK)
                  >> PM20_82_24_REG_PLL_CNFG_REG6_BIT_LOCK_CNT_MAX_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PLL_CNFG_REG6_BIT_LOCK_CNT_MAX_MSK, PM20_82_24_REG_PLL_CNFG_REG6_BIT_LOCK_CNT_MAX_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_LOCK_CNT_MAX_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ADD_DROP_HOLD_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADD_DROP_HOLD_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADD_DROP_HOLD_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADD_DROP_HOLD_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADD_DROP_HOLD_set", id, value );

    /* (0x00000198 bits 31) field ADD_DROP_HOLD of register PMC_PM20_82_24_REG_MDSP_CFG_REG1 */
    t8_reg_MDSP_CFG_REG1_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_MDSP_CFG_REG1_BIT_ADD_DROP_HOLD_MSK,
                                    PM20_82_24_REG_MDSP_CFG_REG1_BIT_ADD_DROP_HOLD_OFF,
                                    value);
}

static INLINE UINT32 t8_field_ADD_DROP_HOLD_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADD_DROP_HOLD_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADD_DROP_HOLD_get", id, 2);
    /* (0x00000198 bits 31) field ADD_DROP_HOLD of register PMC_PM20_82_24_REG_MDSP_CFG_REG1 */
    reg_value = t8_reg_MDSP_CFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_MDSP_CFG_REG1_BIT_ADD_DROP_HOLD_MSK) >> PM20_82_24_REG_MDSP_CFG_REG1_BIT_ADD_DROP_HOLD_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADD_DROP_HOLD_get", id, value );

    return value;
}
static INLINE void t8_field_TED_HOLD_OUTPUT_EN_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TED_HOLD_OUTPUT_EN_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TED_HOLD_OUTPUT_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TED_HOLD_OUTPUT_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TED_HOLD_OUTPUT_EN_set", id, value );

    /* (0x00000198 bits 4) field TED_HOLD_OUTPUT_EN of register PMC_PM20_82_24_REG_MDSP_CFG_REG1 */
    t8_reg_MDSP_CFG_REG1_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_MDSP_CFG_REG1_BIT_TED_HOLD_OUTPUT_EN_MSK,
                                    PM20_82_24_REG_MDSP_CFG_REG1_BIT_TED_HOLD_OUTPUT_EN_OFF,
                                    value);
}

static INLINE UINT32 t8_field_TED_HOLD_OUTPUT_EN_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TED_HOLD_OUTPUT_EN_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TED_HOLD_OUTPUT_EN_get", id, 2);
    /* (0x00000198 bits 4) field TED_HOLD_OUTPUT_EN of register PMC_PM20_82_24_REG_MDSP_CFG_REG1 */
    reg_value = t8_reg_MDSP_CFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_MDSP_CFG_REG1_BIT_TED_HOLD_OUTPUT_EN_MSK) >> PM20_82_24_REG_MDSP_CFG_REG1_BIT_TED_HOLD_OUTPUT_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TED_HOLD_OUTPUT_EN_get", id, value );

    return value;
}
static INLINE void t8_field_DFE_BYPASS_set( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DFE_BYPASS_set( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id,
                                            UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DFE_BYPASS_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DFE_BYPASS_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DFE_BYPASS_set", id, value );

    /* (0x00000198 bits 3) field DFE_BYPASS of register PMC_PM20_82_24_REG_MDSP_CFG_REG1 */
    t8_reg_MDSP_CFG_REG1_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_MDSP_CFG_REG1_BIT_DFE_BYPASS_MSK,
                                    PM20_82_24_REG_MDSP_CFG_REG1_BIT_DFE_BYPASS_OFF,
                                    value);
}

static INLINE UINT32 t8_field_DFE_BYPASS_get( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DFE_BYPASS_get( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DFE_BYPASS_get", id, 2);
    /* (0x00000198 bits 3) field DFE_BYPASS of register PMC_PM20_82_24_REG_MDSP_CFG_REG1 */
    reg_value = t8_reg_MDSP_CFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_MDSP_CFG_REG1_BIT_DFE_BYPASS_MSK) >> PM20_82_24_REG_MDSP_CFG_REG1_BIT_DFE_BYPASS_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DFE_BYPASS_get", id, value );

    return value;
}
static INLINE void t8_field_TED_MODE_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_TED_MODE_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TED_MODE_set", id, 2);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_TED_MODE_set", value, 3);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_TED_MODE_set", id, value );

    /* (0x00000198 bits 2:1) field TED_MODE of register PMC_PM20_82_24_REG_MDSP_CFG_REG1 */
    t8_reg_MDSP_CFG_REG1_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_MDSP_CFG_REG1_BIT_TED_MODE_MSK,
                                    PM20_82_24_REG_MDSP_CFG_REG1_BIT_TED_MODE_OFF,
                                    value);
}

static INLINE UINT32 t8_field_TED_MODE_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TED_MODE_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TED_MODE_get", id, 2);
    /* (0x00000198 bits 2:1) field TED_MODE of register PMC_PM20_82_24_REG_MDSP_CFG_REG1 */
    reg_value = t8_reg_MDSP_CFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_MDSP_CFG_REG1_BIT_TED_MODE_MSK) >> PM20_82_24_REG_MDSP_CFG_REG1_BIT_TED_MODE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TED_MODE_get", id, value );

    return value;
}
static INLINE void t8_field_range_TED_MODE_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_TED_MODE_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_TED_MODE_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_TED_MODE_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_TED_MODE_set", stop_bit, 1 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_TED_MODE_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000198 bits 2:1) field TED_MODE of register PMC_PM20_82_24_REG_MDSP_CFG_REG1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000198 bits 2:1) field TED_MODE of register PMC_PM20_82_24_REG_MDSP_CFG_REG1 */
        t8_reg_MDSP_CFG_REG1_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        subfield_mask << (PM20_82_24_REG_MDSP_CFG_REG1_BIT_TED_MODE_OFF + subfield_offset),
                                        PM20_82_24_REG_MDSP_CFG_REG1_BIT_TED_MODE_OFF + subfield_offset,
                                        value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_TED_MODE_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_TED_MODE_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_TED_MODE_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_TED_MODE_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_TED_MODE_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000198 bits 2:1) field TED_MODE of register PMC_PM20_82_24_REG_MDSP_CFG_REG1 */
    reg_value = t8_reg_MDSP_CFG_REG1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_MDSP_CFG_REG1_BIT_TED_MODE_MSK)
                  >> PM20_82_24_REG_MDSP_CFG_REG1_BIT_TED_MODE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_MDSP_CFG_REG1_BIT_TED_MODE_MSK, PM20_82_24_REG_MDSP_CFG_REG1_BIT_TED_MODE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_TED_MODE_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_DLB_ENB_set( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id,
                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DLB_ENB_set( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id,
                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DLB_ENB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DLB_ENB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DLB_ENB_set", id, value );

    /* (0x00000198 bits 0) field DLB_ENB of register PMC_PM20_82_24_REG_MDSP_CFG_REG1 */
    t8_reg_MDSP_CFG_REG1_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_MDSP_CFG_REG1_BIT_DLB_ENB_MSK,
                                    PM20_82_24_REG_MDSP_CFG_REG1_BIT_DLB_ENB_OFF,
                                    value);
}

static INLINE UINT32 t8_field_DLB_ENB_get( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DLB_ENB_get( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DLB_ENB_get", id, 2);
    /* (0x00000198 bits 0) field DLB_ENB of register PMC_PM20_82_24_REG_MDSP_CFG_REG1 */
    reg_value = t8_reg_MDSP_CFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_MDSP_CFG_REG1_BIT_DLB_ENB_MSK) >> PM20_82_24_REG_MDSP_CFG_REG1_BIT_DLB_ENB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DLB_ENB_get", id, value );

    return value;
}
static INLINE void t8_field_LF_CLAMP_MIN_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_LF_CLAMP_MIN_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LF_CLAMP_MIN_set", id, 2);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_LF_CLAMP_MIN_set", value, 255);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_LF_CLAMP_MIN_set", id, value );

    /* (0x0000019c bits 15:8) field LF_CLAMP_MIN of register PMC_PM20_82_24_REG_MDSP_CFG_REG2 */
    t8_reg_MDSP_CFG_REG2_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MIN_MSK,
                                    PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MIN_OFF,
                                    value);
}

static INLINE UINT32 t8_field_LF_CLAMP_MIN_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_LF_CLAMP_MIN_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LF_CLAMP_MIN_get", id, 2);
    /* (0x0000019c bits 15:8) field LF_CLAMP_MIN of register PMC_PM20_82_24_REG_MDSP_CFG_REG2 */
    reg_value = t8_reg_MDSP_CFG_REG2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MIN_MSK) >> PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MIN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_LF_CLAMP_MIN_get", id, value );

    return value;
}
static INLINE void t8_field_range_LF_CLAMP_MIN_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_LF_CLAMP_MIN_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_LF_CLAMP_MIN_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_LF_CLAMP_MIN_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_LF_CLAMP_MIN_set", stop_bit, 7 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_LF_CLAMP_MIN_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000019c bits 15:8) field LF_CLAMP_MIN of register PMC_PM20_82_24_REG_MDSP_CFG_REG2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000019c bits 15:8) field LF_CLAMP_MIN of register PMC_PM20_82_24_REG_MDSP_CFG_REG2 */
        t8_reg_MDSP_CFG_REG2_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        subfield_mask << (PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MIN_OFF + subfield_offset),
                                        PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MIN_OFF + subfield_offset,
                                        value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_LF_CLAMP_MIN_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_LF_CLAMP_MIN_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_LF_CLAMP_MIN_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_LF_CLAMP_MIN_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_LF_CLAMP_MIN_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000019c bits 15:8) field LF_CLAMP_MIN of register PMC_PM20_82_24_REG_MDSP_CFG_REG2 */
    reg_value = t8_reg_MDSP_CFG_REG2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MIN_MSK)
                  >> PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MIN_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MIN_MSK, PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MIN_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_LF_CLAMP_MIN_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_LF_CLAMP_MAX_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_LF_CLAMP_MAX_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LF_CLAMP_MAX_set", id, 2);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_LF_CLAMP_MAX_set", value, 255);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_LF_CLAMP_MAX_set", id, value );

    /* (0x0000019c bits 7:0) field LF_CLAMP_MAX of register PMC_PM20_82_24_REG_MDSP_CFG_REG2 */
    t8_reg_MDSP_CFG_REG2_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MAX_MSK,
                                    PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MAX_OFF,
                                    value);
}

static INLINE UINT32 t8_field_LF_CLAMP_MAX_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_LF_CLAMP_MAX_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LF_CLAMP_MAX_get", id, 2);
    /* (0x0000019c bits 7:0) field LF_CLAMP_MAX of register PMC_PM20_82_24_REG_MDSP_CFG_REG2 */
    reg_value = t8_reg_MDSP_CFG_REG2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MAX_MSK) >> PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MAX_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_LF_CLAMP_MAX_get", id, value );

    return value;
}
static INLINE void t8_field_range_LF_CLAMP_MAX_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_LF_CLAMP_MAX_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_LF_CLAMP_MAX_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_LF_CLAMP_MAX_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_LF_CLAMP_MAX_set", stop_bit, 7 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_LF_CLAMP_MAX_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000019c bits 7:0) field LF_CLAMP_MAX of register PMC_PM20_82_24_REG_MDSP_CFG_REG2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000019c bits 7:0) field LF_CLAMP_MAX of register PMC_PM20_82_24_REG_MDSP_CFG_REG2 */
        t8_reg_MDSP_CFG_REG2_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        subfield_mask << (PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MAX_OFF + subfield_offset),
                                        PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MAX_OFF + subfield_offset,
                                        value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_LF_CLAMP_MAX_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_LF_CLAMP_MAX_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_LF_CLAMP_MAX_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_LF_CLAMP_MAX_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_LF_CLAMP_MAX_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000019c bits 7:0) field LF_CLAMP_MAX of register PMC_PM20_82_24_REG_MDSP_CFG_REG2 */
    reg_value = t8_reg_MDSP_CFG_REG2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MAX_MSK)
                  >> PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MAX_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MAX_MSK, PM20_82_24_REG_MDSP_CFG_REG2_BIT_LF_CLAMP_MAX_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_LF_CLAMP_MAX_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PGA_ATMSB_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PGA_ATMSB_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PGA_ATMSB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PGA_ATMSB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PGA_ATMSB_set", id, value );

    /* (0x00000204 bits 7) field PGA_ATMSB of register PMC_PM20_82_24_REG_PGA_CFG_REG */
    t8_reg_PGA_CFG_REG_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PGA_CFG_REG_BIT_PGA_ATMSB_MSK,
                                  PM20_82_24_REG_PGA_CFG_REG_BIT_PGA_ATMSB_OFF,
                                  value);
}

static INLINE UINT32 t8_field_PGA_ATMSB_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PGA_ATMSB_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PGA_ATMSB_get", id, 2);
    /* (0x00000204 bits 7) field PGA_ATMSB of register PMC_PM20_82_24_REG_PGA_CFG_REG */
    reg_value = t8_reg_PGA_CFG_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PGA_CFG_REG_BIT_PGA_ATMSB_MSK) >> PM20_82_24_REG_PGA_CFG_REG_BIT_PGA_ATMSB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PGA_ATMSB_get", id, value );

    return value;
}
static INLINE void t8_field_PGA_CMFILT_ENB_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PGA_CMFILT_ENB_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PGA_CMFILT_ENB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PGA_CMFILT_ENB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PGA_CMFILT_ENB_set", id, value );

    /* (0x00000204 bits 6) field PGA_CMFILT_ENB of register PMC_PM20_82_24_REG_PGA_CFG_REG */
    t8_reg_PGA_CFG_REG_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PGA_CFG_REG_BIT_PGA_CMFILT_ENB_MSK,
                                  PM20_82_24_REG_PGA_CFG_REG_BIT_PGA_CMFILT_ENB_OFF,
                                  value);
}

static INLINE UINT32 t8_field_PGA_CMFILT_ENB_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PGA_CMFILT_ENB_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PGA_CMFILT_ENB_get", id, 2);
    /* (0x00000204 bits 6) field PGA_CMFILT_ENB of register PMC_PM20_82_24_REG_PGA_CFG_REG */
    reg_value = t8_reg_PGA_CFG_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PGA_CFG_REG_BIT_PGA_CMFILT_ENB_MSK) >> PM20_82_24_REG_PGA_CFG_REG_BIT_PGA_CMFILT_ENB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PGA_CMFILT_ENB_get", id, value );

    return value;
}
static INLINE void t8_field_PGA_ATTENUATE_FORCE_OFF_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PGA_ATTENUATE_FORCE_OFF_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PGA_ATTENUATE_FORCE_OFF_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PGA_ATTENUATE_FORCE_OFF_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PGA_ATTENUATE_FORCE_OFF_set", id, value );

    /* (0x00000204 bits 1) field PGA_ATTENUATE_FORCE_OFF of register PMC_PM20_82_24_REG_PGA_CFG_REG */
    t8_reg_PGA_CFG_REG_field_set( b_ptr,
                                  h_ptr,
                                  id,
                                  PM20_82_24_REG_PGA_CFG_REG_BIT_PGA_ATTENUATE_FORCE_OFF_MSK,
                                  PM20_82_24_REG_PGA_CFG_REG_BIT_PGA_ATTENUATE_FORCE_OFF_OFF,
                                  value);
}

static INLINE UINT32 t8_field_PGA_ATTENUATE_FORCE_OFF_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PGA_ATTENUATE_FORCE_OFF_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PGA_ATTENUATE_FORCE_OFF_get", id, 2);
    /* (0x00000204 bits 1) field PGA_ATTENUATE_FORCE_OFF of register PMC_PM20_82_24_REG_PGA_CFG_REG */
    reg_value = t8_reg_PGA_CFG_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PGA_CFG_REG_BIT_PGA_ATTENUATE_FORCE_OFF_MSK) >> PM20_82_24_REG_PGA_CFG_REG_BIT_PGA_ATTENUATE_FORCE_OFF_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PGA_ATTENUATE_FORCE_OFF_get", id, value );

    return value;
}
static INLINE void t8_field_VHIST_CNT_TIM_LIMIT_39_32_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_VHIST_CNT_TIM_LIMIT_39_32_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_CNT_TIM_LIMIT_39_32_set", id, 2);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_VHIST_CNT_TIM_LIMIT_39_32_set", value, 255);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_VHIST_CNT_TIM_LIMIT_39_32_set", id, value );

    /* (0x00000208 bits 31:24) field VHIST_CNT_TIM_LIMIT_39_32 of register PMC_PM20_82_24_REG_DIAG_CNFG_REG1 */
    t8_reg_DIAG_CNFG_REG1_field_set( b_ptr,
                                     h_ptr,
                                     id,
                                     PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CNT_TIM_LIMIT_39_32_MSK,
                                     PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CNT_TIM_LIMIT_39_32_OFF,
                                     value);
}

static INLINE UINT32 t8_field_VHIST_CNT_TIM_LIMIT_39_32_get( t8_buffer_t *b_ptr,
                                                             t8_handle_t *h_ptr,
                                                             UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_VHIST_CNT_TIM_LIMIT_39_32_get( t8_buffer_t *b_ptr,
                                                             t8_handle_t *h_ptr,
                                                             UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_CNT_TIM_LIMIT_39_32_get", id, 2);
    /* (0x00000208 bits 31:24) field VHIST_CNT_TIM_LIMIT_39_32 of register PMC_PM20_82_24_REG_DIAG_CNFG_REG1 */
    reg_value = t8_reg_DIAG_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CNT_TIM_LIMIT_39_32_MSK) >> PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CNT_TIM_LIMIT_39_32_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_VHIST_CNT_TIM_LIMIT_39_32_get", id, value );

    return value;
}
static INLINE void t8_field_range_VHIST_CNT_TIM_LIMIT_39_32_set( t8_buffer_t *b_ptr,
                                                                 t8_handle_t *h_ptr,
                                                                 UINT32 id,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_VHIST_CNT_TIM_LIMIT_39_32_set( t8_buffer_t *b_ptr,
                                                                 t8_handle_t *h_ptr,
                                                                 UINT32 id,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_VHIST_CNT_TIM_LIMIT_39_32_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_VHIST_CNT_TIM_LIMIT_39_32_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_VHIST_CNT_TIM_LIMIT_39_32_set", stop_bit, 7 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_VHIST_CNT_TIM_LIMIT_39_32_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000208 bits 31:24) field VHIST_CNT_TIM_LIMIT_39_32 of register PMC_PM20_82_24_REG_DIAG_CNFG_REG1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000208 bits 31:24) field VHIST_CNT_TIM_LIMIT_39_32 of register PMC_PM20_82_24_REG_DIAG_CNFG_REG1 */
        t8_reg_DIAG_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         subfield_mask << (PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CNT_TIM_LIMIT_39_32_OFF + subfield_offset),
                                         PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CNT_TIM_LIMIT_39_32_OFF + subfield_offset,
                                         value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_VHIST_CNT_TIM_LIMIT_39_32_get( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_VHIST_CNT_TIM_LIMIT_39_32_get( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_VHIST_CNT_TIM_LIMIT_39_32_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_VHIST_CNT_TIM_LIMIT_39_32_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_VHIST_CNT_TIM_LIMIT_39_32_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000208 bits 31:24) field VHIST_CNT_TIM_LIMIT_39_32 of register PMC_PM20_82_24_REG_DIAG_CNFG_REG1 */
    reg_value = t8_reg_DIAG_CNFG_REG1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CNT_TIM_LIMIT_39_32_MSK)
                  >> PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CNT_TIM_LIMIT_39_32_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CNT_TIM_LIMIT_39_32_MSK, PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CNT_TIM_LIMIT_39_32_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_VHIST_CNT_TIM_LIMIT_39_32_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_VHIST_TITAN_TARGET_AMP_WR_EN_set( t8_buffer_t *b_ptr,
                                                              t8_handle_t *h_ptr,
                                                              UINT32 id,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_VHIST_TITAN_TARGET_AMP_WR_EN_set( t8_buffer_t *b_ptr,
                                                              t8_handle_t *h_ptr,
                                                              UINT32 id,
                                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_TITAN_TARGET_AMP_WR_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_VHIST_TITAN_TARGET_AMP_WR_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_VHIST_TITAN_TARGET_AMP_WR_EN_set", id, value );

    /* (0x00000208 bits 3) field VHIST_TITAN_TARGET_AMP_WR_EN of register PMC_PM20_82_24_REG_DIAG_CNFG_REG1 */
    t8_reg_DIAG_CNFG_REG1_field_set( b_ptr,
                                     h_ptr,
                                     id,
                                     PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_TITAN_TARGET_AMP_WR_EN_MSK,
                                     PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_TITAN_TARGET_AMP_WR_EN_OFF,
                                     value);
}

static INLINE UINT32 t8_field_VHIST_TITAN_TARGET_AMP_WR_EN_get( t8_buffer_t *b_ptr,
                                                                t8_handle_t *h_ptr,
                                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_VHIST_TITAN_TARGET_AMP_WR_EN_get( t8_buffer_t *b_ptr,
                                                                t8_handle_t *h_ptr,
                                                                UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_TITAN_TARGET_AMP_WR_EN_get", id, 2);
    /* (0x00000208 bits 3) field VHIST_TITAN_TARGET_AMP_WR_EN of register PMC_PM20_82_24_REG_DIAG_CNFG_REG1 */
    reg_value = t8_reg_DIAG_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_TITAN_TARGET_AMP_WR_EN_MSK) >> PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_TITAN_TARGET_AMP_WR_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_VHIST_TITAN_TARGET_AMP_WR_EN_get", id, value );

    return value;
}
static INLINE void t8_field_VHIST_PERBIN_VALUE_RD_ENB_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_VHIST_PERBIN_VALUE_RD_ENB_set( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_PERBIN_VALUE_RD_ENB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_VHIST_PERBIN_VALUE_RD_ENB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_VHIST_PERBIN_VALUE_RD_ENB_set", id, value );

    /* (0x00000208 bits 2) field VHIST_PERBIN_VALUE_RD_ENB of register PMC_PM20_82_24_REG_DIAG_CNFG_REG1 */
    t8_reg_DIAG_CNFG_REG1_field_set( b_ptr,
                                     h_ptr,
                                     id,
                                     PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_PERBIN_VALUE_RD_ENB_MSK,
                                     PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_PERBIN_VALUE_RD_ENB_OFF,
                                     value);
}

static INLINE UINT32 t8_field_VHIST_PERBIN_VALUE_RD_ENB_get( t8_buffer_t *b_ptr,
                                                             t8_handle_t *h_ptr,
                                                             UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_VHIST_PERBIN_VALUE_RD_ENB_get( t8_buffer_t *b_ptr,
                                                             t8_handle_t *h_ptr,
                                                             UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_PERBIN_VALUE_RD_ENB_get", id, 2);
    /* (0x00000208 bits 2) field VHIST_PERBIN_VALUE_RD_ENB of register PMC_PM20_82_24_REG_DIAG_CNFG_REG1 */
    reg_value = t8_reg_DIAG_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_PERBIN_VALUE_RD_ENB_MSK) >> PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_PERBIN_VALUE_RD_ENB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_VHIST_PERBIN_VALUE_RD_ENB_get", id, value );

    return value;
}
static INLINE void t8_field_VHIST_CAPT_START_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_VHIST_CAPT_START_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_CAPT_START_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_VHIST_CAPT_START_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_VHIST_CAPT_START_set", id, value );

    /* (0x00000208 bits 1) field VHIST_CAPT_START of register PMC_PM20_82_24_REG_DIAG_CNFG_REG1 */
    t8_reg_DIAG_CNFG_REG1_field_set( b_ptr,
                                     h_ptr,
                                     id,
                                     PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CAPT_START_MSK,
                                     PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CAPT_START_OFF,
                                     value);
}

static INLINE UINT32 t8_field_VHIST_CAPT_START_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_VHIST_CAPT_START_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_CAPT_START_get", id, 2);
    /* (0x00000208 bits 1) field VHIST_CAPT_START of register PMC_PM20_82_24_REG_DIAG_CNFG_REG1 */
    reg_value = t8_reg_DIAG_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CAPT_START_MSK) >> PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CAPT_START_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_VHIST_CAPT_START_get", id, value );

    return value;
}
static INLINE void t8_field_VHIST_CAPT_ENB_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_VHIST_CAPT_ENB_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_CAPT_ENB_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_VHIST_CAPT_ENB_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_VHIST_CAPT_ENB_set", id, value );

    /* (0x00000208 bits 0) field VHIST_CAPT_ENB of register PMC_PM20_82_24_REG_DIAG_CNFG_REG1 */
    t8_reg_DIAG_CNFG_REG1_field_set( b_ptr,
                                     h_ptr,
                                     id,
                                     PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CAPT_ENB_MSK,
                                     PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CAPT_ENB_OFF,
                                     value);
}

static INLINE UINT32 t8_field_VHIST_CAPT_ENB_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_VHIST_CAPT_ENB_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_CAPT_ENB_get", id, 2);
    /* (0x00000208 bits 0) field VHIST_CAPT_ENB of register PMC_PM20_82_24_REG_DIAG_CNFG_REG1 */
    reg_value = t8_reg_DIAG_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CAPT_ENB_MSK) >> PM20_82_24_REG_DIAG_CNFG_REG1_BIT_VHIST_CAPT_ENB_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_VHIST_CAPT_ENB_get", id, value );

    return value;
}
static INLINE void t8_field_VHIST_CNT_TIM_LIMIT_31_0_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_VHIST_CNT_TIM_LIMIT_31_0_set( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_CNT_TIM_LIMIT_31_0_set", id, 2);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_VHIST_CNT_TIM_LIMIT_31_0_set", id, value );

    /* (0x0000020c bits 31:0) field VHIST_CNT_TIM_LIMIT_31_0 of register PMC_PM20_82_24_REG_DIAG_CNFG_REG2 */
    t8_reg_DIAG_CNFG_REG2_field_set( b_ptr,
                                     h_ptr,
                                     id,
                                     PM20_82_24_REG_DIAG_CNFG_REG2_BIT_VHIST_CNT_TIM_LIMIT_31_0_MSK,
                                     PM20_82_24_REG_DIAG_CNFG_REG2_BIT_VHIST_CNT_TIM_LIMIT_31_0_OFF,
                                     value);
}

static INLINE UINT32 t8_field_VHIST_CNT_TIM_LIMIT_31_0_get( t8_buffer_t *b_ptr,
                                                            t8_handle_t *h_ptr,
                                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_VHIST_CNT_TIM_LIMIT_31_0_get( t8_buffer_t *b_ptr,
                                                            t8_handle_t *h_ptr,
                                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_CNT_TIM_LIMIT_31_0_get", id, 2);
    /* (0x0000020c bits 31:0) field VHIST_CNT_TIM_LIMIT_31_0 of register PMC_PM20_82_24_REG_DIAG_CNFG_REG2 */
    reg_value = t8_reg_DIAG_CNFG_REG2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIAG_CNFG_REG2_BIT_VHIST_CNT_TIM_LIMIT_31_0_MSK) >> PM20_82_24_REG_DIAG_CNFG_REG2_BIT_VHIST_CNT_TIM_LIMIT_31_0_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_VHIST_CNT_TIM_LIMIT_31_0_get", id, value );

    return value;
}
static INLINE void t8_field_range_VHIST_CNT_TIM_LIMIT_31_0_set( t8_buffer_t *b_ptr,
                                                                t8_handle_t *h_ptr,
                                                                UINT32 id,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_VHIST_CNT_TIM_LIMIT_31_0_set( t8_buffer_t *b_ptr,
                                                                t8_handle_t *h_ptr,
                                                                UINT32 id,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_VHIST_CNT_TIM_LIMIT_31_0_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_VHIST_CNT_TIM_LIMIT_31_0_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_VHIST_CNT_TIM_LIMIT_31_0_set", stop_bit, 31 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_VHIST_CNT_TIM_LIMIT_31_0_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000020c bits 31:0) field VHIST_CNT_TIM_LIMIT_31_0 of register PMC_PM20_82_24_REG_DIAG_CNFG_REG2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000020c bits 31:0) field VHIST_CNT_TIM_LIMIT_31_0 of register PMC_PM20_82_24_REG_DIAG_CNFG_REG2 */
        t8_reg_DIAG_CNFG_REG2_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         subfield_mask << (PM20_82_24_REG_DIAG_CNFG_REG2_BIT_VHIST_CNT_TIM_LIMIT_31_0_OFF + subfield_offset),
                                         PM20_82_24_REG_DIAG_CNFG_REG2_BIT_VHIST_CNT_TIM_LIMIT_31_0_OFF + subfield_offset,
                                         value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_VHIST_CNT_TIM_LIMIT_31_0_get( t8_buffer_t *b_ptr,
                                                                  t8_handle_t *h_ptr,
                                                                  UINT32 id,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_VHIST_CNT_TIM_LIMIT_31_0_get( t8_buffer_t *b_ptr,
                                                                  t8_handle_t *h_ptr,
                                                                  UINT32 id,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_VHIST_CNT_TIM_LIMIT_31_0_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_VHIST_CNT_TIM_LIMIT_31_0_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_VHIST_CNT_TIM_LIMIT_31_0_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000020c bits 31:0) field VHIST_CNT_TIM_LIMIT_31_0 of register PMC_PM20_82_24_REG_DIAG_CNFG_REG2 */
    reg_value = t8_reg_DIAG_CNFG_REG2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_DIAG_CNFG_REG2_BIT_VHIST_CNT_TIM_LIMIT_31_0_MSK)
                  >> PM20_82_24_REG_DIAG_CNFG_REG2_BIT_VHIST_CNT_TIM_LIMIT_31_0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_DIAG_CNFG_REG2_BIT_VHIST_CNT_TIM_LIMIT_31_0_MSK, PM20_82_24_REG_DIAG_CNFG_REG2_BIT_VHIST_CNT_TIM_LIMIT_31_0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_VHIST_CNT_TIM_LIMIT_31_0_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_OFFSET_RAM_QUADRANT_SEL_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_OFFSET_RAM_QUADRANT_SEL_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_OFFSET_RAM_QUADRANT_SEL_set", id, 2);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_OFFSET_RAM_QUADRANT_SEL_set", value, 3);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_OFFSET_RAM_QUADRANT_SEL_set", id, value );

    /* (0x00000218 bits 1:0) field OFFSET_RAM_QUADRANT_SEL of register PMC_PM20_82_24_REG_OFFSET_RAM_CNFG_REG */
    t8_reg_OFFSET_RAM_CNFG_REG_field_set( b_ptr,
                                          h_ptr,
                                          id,
                                          PM20_82_24_REG_OFFSET_RAM_CNFG_REG_BIT_OFFSET_RAM_QUADRANT_SEL_MSK,
                                          PM20_82_24_REG_OFFSET_RAM_CNFG_REG_BIT_OFFSET_RAM_QUADRANT_SEL_OFF,
                                          value);
}

static INLINE UINT32 t8_field_OFFSET_RAM_QUADRANT_SEL_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_OFFSET_RAM_QUADRANT_SEL_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_OFFSET_RAM_QUADRANT_SEL_get", id, 2);
    /* (0x00000218 bits 1:0) field OFFSET_RAM_QUADRANT_SEL of register PMC_PM20_82_24_REG_OFFSET_RAM_CNFG_REG */
    reg_value = t8_reg_OFFSET_RAM_CNFG_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_OFFSET_RAM_CNFG_REG_BIT_OFFSET_RAM_QUADRANT_SEL_MSK) >> PM20_82_24_REG_OFFSET_RAM_CNFG_REG_BIT_OFFSET_RAM_QUADRANT_SEL_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_OFFSET_RAM_QUADRANT_SEL_get", id, value );

    return value;
}
static INLINE void t8_field_range_OFFSET_RAM_QUADRANT_SEL_set( t8_buffer_t *b_ptr,
                                                               t8_handle_t *h_ptr,
                                                               UINT32 id,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_OFFSET_RAM_QUADRANT_SEL_set( t8_buffer_t *b_ptr,
                                                               t8_handle_t *h_ptr,
                                                               UINT32 id,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_OFFSET_RAM_QUADRANT_SEL_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_OFFSET_RAM_QUADRANT_SEL_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_OFFSET_RAM_QUADRANT_SEL_set", stop_bit, 1 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_OFFSET_RAM_QUADRANT_SEL_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000218 bits 1:0) field OFFSET_RAM_QUADRANT_SEL of register PMC_PM20_82_24_REG_OFFSET_RAM_CNFG_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000218 bits 1:0) field OFFSET_RAM_QUADRANT_SEL of register PMC_PM20_82_24_REG_OFFSET_RAM_CNFG_REG */
        t8_reg_OFFSET_RAM_CNFG_REG_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              subfield_mask << (PM20_82_24_REG_OFFSET_RAM_CNFG_REG_BIT_OFFSET_RAM_QUADRANT_SEL_OFF + subfield_offset),
                                              PM20_82_24_REG_OFFSET_RAM_CNFG_REG_BIT_OFFSET_RAM_QUADRANT_SEL_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_OFFSET_RAM_QUADRANT_SEL_get( t8_buffer_t *b_ptr,
                                                                 t8_handle_t *h_ptr,
                                                                 UINT32 id,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_OFFSET_RAM_QUADRANT_SEL_get( t8_buffer_t *b_ptr,
                                                                 t8_handle_t *h_ptr,
                                                                 UINT32 id,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_OFFSET_RAM_QUADRANT_SEL_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_OFFSET_RAM_QUADRANT_SEL_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_OFFSET_RAM_QUADRANT_SEL_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000218 bits 1:0) field OFFSET_RAM_QUADRANT_SEL of register PMC_PM20_82_24_REG_OFFSET_RAM_CNFG_REG */
    reg_value = t8_reg_OFFSET_RAM_CNFG_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_OFFSET_RAM_CNFG_REG_BIT_OFFSET_RAM_QUADRANT_SEL_MSK)
                  >> PM20_82_24_REG_OFFSET_RAM_CNFG_REG_BIT_OFFSET_RAM_QUADRANT_SEL_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_OFFSET_RAM_CNFG_REG_BIT_OFFSET_RAM_QUADRANT_SEL_MSK, PM20_82_24_REG_OFFSET_RAM_CNFG_REG_BIT_OFFSET_RAM_QUADRANT_SEL_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_OFFSET_RAM_QUADRANT_SEL_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_RD_PTR_SYNC_VAL_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_RD_PTR_SYNC_VAL_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RD_PTR_SYNC_VAL_set", id, 2);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_RD_PTR_SYNC_VAL_set", value, 7);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_RD_PTR_SYNC_VAL_set", id, value );

    /* (0x0000021c bits 31:29) bits 0:2 use field RD_PTR_SYNC_VAL of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
    t8_reg_DIG_LPBK_CTRL_REG_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_RD_PTR_SYNC_VAL_MSK,
                                        PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_RD_PTR_SYNC_VAL_OFF,
                                        value);
}

static INLINE UINT32 t8_field_RD_PTR_SYNC_VAL_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_RD_PTR_SYNC_VAL_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_RD_PTR_SYNC_VAL_get", id, 2);
    /* (0x0000021c bits 31:29) bits 0:2 use field RD_PTR_SYNC_VAL of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
    reg_value = t8_reg_DIG_LPBK_CTRL_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_RD_PTR_SYNC_VAL_MSK) >> PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_RD_PTR_SYNC_VAL_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_RD_PTR_SYNC_VAL_get", id, value );

    return value;
}
static INLINE void t8_field_range_RD_PTR_SYNC_VAL_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_RD_PTR_SYNC_VAL_set( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_RD_PTR_SYNC_VAL_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_RD_PTR_SYNC_VAL_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_RD_PTR_SYNC_VAL_set", stop_bit, 2 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_RD_PTR_SYNC_VAL_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000021c bits 31:29) bits 0:2 use field RD_PTR_SYNC_VAL of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000021c bits 31:29) bits 0:2 use field RD_PTR_SYNC_VAL of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
        t8_reg_DIG_LPBK_CTRL_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            subfield_mask << (PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_RD_PTR_SYNC_VAL_OFF + subfield_offset),
                                            PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_RD_PTR_SYNC_VAL_OFF + subfield_offset,
                                            value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_RD_PTR_SYNC_VAL_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_RD_PTR_SYNC_VAL_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_RD_PTR_SYNC_VAL_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_RD_PTR_SYNC_VAL_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_RD_PTR_SYNC_VAL_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000021c bits 31:29) bits 0:2 use field RD_PTR_SYNC_VAL of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
    reg_value = t8_reg_DIG_LPBK_CTRL_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_RD_PTR_SYNC_VAL_MSK)
                  >> PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_RD_PTR_SYNC_VAL_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_RD_PTR_SYNC_VAL_MSK, PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_RD_PTR_SYNC_VAL_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_RD_PTR_SYNC_VAL_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_DESKEW_RD_PTR_SYNC_VAL_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DESKEW_RD_PTR_SYNC_VAL_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DESKEW_RD_PTR_SYNC_VAL_set", id, 2);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DESKEW_RD_PTR_SYNC_VAL_set", value, 7);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DESKEW_RD_PTR_SYNC_VAL_set", id, value );

    /* (0x0000021c bits 28:26) bits 0:2 use field DESKEW_RD_PTR_SYNC_VAL of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
    t8_reg_DIG_LPBK_CTRL_REG_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DESKEW_RD_PTR_SYNC_VAL_MSK,
                                        PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DESKEW_RD_PTR_SYNC_VAL_OFF,
                                        value);
}

static INLINE UINT32 t8_field_DESKEW_RD_PTR_SYNC_VAL_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DESKEW_RD_PTR_SYNC_VAL_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DESKEW_RD_PTR_SYNC_VAL_get", id, 2);
    /* (0x0000021c bits 28:26) bits 0:2 use field DESKEW_RD_PTR_SYNC_VAL of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
    reg_value = t8_reg_DIG_LPBK_CTRL_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DESKEW_RD_PTR_SYNC_VAL_MSK) >> PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DESKEW_RD_PTR_SYNC_VAL_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DESKEW_RD_PTR_SYNC_VAL_get", id, value );

    return value;
}
static INLINE void t8_field_range_DESKEW_RD_PTR_SYNC_VAL_set( t8_buffer_t *b_ptr,
                                                              t8_handle_t *h_ptr,
                                                              UINT32 id,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_DESKEW_RD_PTR_SYNC_VAL_set( t8_buffer_t *b_ptr,
                                                              t8_handle_t *h_ptr,
                                                              UINT32 id,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_DESKEW_RD_PTR_SYNC_VAL_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_DESKEW_RD_PTR_SYNC_VAL_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_DESKEW_RD_PTR_SYNC_VAL_set", stop_bit, 2 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_DESKEW_RD_PTR_SYNC_VAL_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000021c bits 28:26) bits 0:2 use field DESKEW_RD_PTR_SYNC_VAL of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000021c bits 28:26) bits 0:2 use field DESKEW_RD_PTR_SYNC_VAL of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
        t8_reg_DIG_LPBK_CTRL_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            subfield_mask << (PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DESKEW_RD_PTR_SYNC_VAL_OFF + subfield_offset),
                                            PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DESKEW_RD_PTR_SYNC_VAL_OFF + subfield_offset,
                                            value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_DESKEW_RD_PTR_SYNC_VAL_get( t8_buffer_t *b_ptr,
                                                                t8_handle_t *h_ptr,
                                                                UINT32 id,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_DESKEW_RD_PTR_SYNC_VAL_get( t8_buffer_t *b_ptr,
                                                                t8_handle_t *h_ptr,
                                                                UINT32 id,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_DESKEW_RD_PTR_SYNC_VAL_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_DESKEW_RD_PTR_SYNC_VAL_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_DESKEW_RD_PTR_SYNC_VAL_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000021c bits 28:26) bits 0:2 use field DESKEW_RD_PTR_SYNC_VAL of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
    reg_value = t8_reg_DIG_LPBK_CTRL_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DESKEW_RD_PTR_SYNC_VAL_MSK)
                  >> PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DESKEW_RD_PTR_SYNC_VAL_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DESKEW_RD_PTR_SYNC_VAL_MSK, PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DESKEW_RD_PTR_SYNC_VAL_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_DESKEW_RD_PTR_SYNC_VAL_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_DESKEW_FIFO_SYNC_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DESKEW_FIFO_SYNC_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DESKEW_FIFO_SYNC_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DESKEW_FIFO_SYNC_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DESKEW_FIFO_SYNC_set", id, value );

    /* (0x0000021c bits 2) field DESKEW_FIFO_SYNC of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
    t8_reg_DIG_LPBK_CTRL_REG_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DESKEW_FIFO_SYNC_MSK,
                                        PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DESKEW_FIFO_SYNC_OFF,
                                        value);
}

static INLINE UINT32 t8_field_DESKEW_FIFO_SYNC_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DESKEW_FIFO_SYNC_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DESKEW_FIFO_SYNC_get", id, 2);
    /* (0x0000021c bits 2) field DESKEW_FIFO_SYNC of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
    reg_value = t8_reg_DIG_LPBK_CTRL_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DESKEW_FIFO_SYNC_MSK) >> PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DESKEW_FIFO_SYNC_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DESKEW_FIFO_SYNC_get", id, value );

    return value;
}
static INLINE void t8_field_PLL_LOCK_DET_SW_RST_set( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PLL_LOCK_DET_SW_RST_set( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLL_LOCK_DET_SW_RST_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PLL_LOCK_DET_SW_RST_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PLL_LOCK_DET_SW_RST_set", id, value );

    /* (0x0000021c bits 1) field PLL_LOCK_DET_SW_RST of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
    t8_reg_DIG_LPBK_CTRL_REG_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_PLL_LOCK_DET_SW_RST_MSK,
                                        PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_PLL_LOCK_DET_SW_RST_OFF,
                                        value);
}

static INLINE UINT32 t8_field_PLL_LOCK_DET_SW_RST_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PLL_LOCK_DET_SW_RST_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLL_LOCK_DET_SW_RST_get", id, 2);
    /* (0x0000021c bits 1) field PLL_LOCK_DET_SW_RST of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
    reg_value = t8_reg_DIG_LPBK_CTRL_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_PLL_LOCK_DET_SW_RST_MSK) >> PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_PLL_LOCK_DET_SW_RST_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PLL_LOCK_DET_SW_RST_get", id, value );

    return value;
}
static INLINE void t8_field_DIG_LPBK_SYNC_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DIG_LPBK_SYNC_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DIG_LPBK_SYNC_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DIG_LPBK_SYNC_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DIG_LPBK_SYNC_set", id, value );

    /* (0x0000021c bits 0) field DIG_LPBK_SYNC of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
    t8_reg_DIG_LPBK_CTRL_REG_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DIG_LPBK_SYNC_MSK,
                                        PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DIG_LPBK_SYNC_OFF,
                                        value);
}

static INLINE UINT32 t8_field_DIG_LPBK_SYNC_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DIG_LPBK_SYNC_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DIG_LPBK_SYNC_get", id, 2);
    /* (0x0000021c bits 0) field DIG_LPBK_SYNC of register PMC_PM20_82_24_REG_DIG_LPBK_CTRL_REG */
    reg_value = t8_reg_DIG_LPBK_CTRL_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DIG_LPBK_SYNC_MSK) >> PM20_82_24_REG_DIG_LPBK_CTRL_REG_BIT_DIG_LPBK_SYNC_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DIG_LPBK_SYNC_get", id, value );

    return value;
}
static INLINE void t8_field_THR_MAP63_32_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_THR_MAP63_32_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_THR_MAP63_32_set", id, 2);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_THR_MAP63_32_set", id, value );

    /* (0x00000220 bits 31:0) bits 0:31 use field THR_MAP63_32 of register PMC_PM20_82_24_REG_ADC_OC_REGISTER4 */
    t8_reg_ADC_OC_REGISTER4_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_ADC_OC_REGISTER4_BIT_THR_MAP63_32_MSK,
                                       PM20_82_24_REG_ADC_OC_REGISTER4_BIT_THR_MAP63_32_OFF,
                                       value);
}

static INLINE UINT32 t8_field_THR_MAP63_32_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_THR_MAP63_32_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_THR_MAP63_32_get", id, 2);
    /* (0x00000220 bits 31:0) bits 0:31 use field THR_MAP63_32 of register PMC_PM20_82_24_REG_ADC_OC_REGISTER4 */
    reg_value = t8_reg_ADC_OC_REGISTER4_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_REGISTER4_BIT_THR_MAP63_32_MSK) >> PM20_82_24_REG_ADC_OC_REGISTER4_BIT_THR_MAP63_32_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_THR_MAP63_32_get", id, value );

    return value;
}
static INLINE void t8_field_range_THR_MAP63_32_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_THR_MAP63_32_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_THR_MAP63_32_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_THR_MAP63_32_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_THR_MAP63_32_set", stop_bit, 31 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_THR_MAP63_32_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000220 bits 31:0) bits 0:31 use field THR_MAP63_32 of register PMC_PM20_82_24_REG_ADC_OC_REGISTER4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000220 bits 31:0) bits 0:31 use field THR_MAP63_32 of register PMC_PM20_82_24_REG_ADC_OC_REGISTER4 */
        t8_reg_ADC_OC_REGISTER4_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           subfield_mask << (PM20_82_24_REG_ADC_OC_REGISTER4_BIT_THR_MAP63_32_OFF + subfield_offset),
                                           PM20_82_24_REG_ADC_OC_REGISTER4_BIT_THR_MAP63_32_OFF + subfield_offset,
                                           value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_THR_MAP63_32_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_THR_MAP63_32_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_THR_MAP63_32_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_THR_MAP63_32_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_THR_MAP63_32_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000220 bits 31:0) bits 0:31 use field THR_MAP63_32 of register PMC_PM20_82_24_REG_ADC_OC_REGISTER4 */
    reg_value = t8_reg_ADC_OC_REGISTER4_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ADC_OC_REGISTER4_BIT_THR_MAP63_32_MSK)
                  >> PM20_82_24_REG_ADC_OC_REGISTER4_BIT_THR_MAP63_32_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ADC_OC_REGISTER4_BIT_THR_MAP63_32_MSK, PM20_82_24_REG_ADC_OC_REGISTER4_BIT_THR_MAP63_32_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_THR_MAP63_32_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_MAX_THRESHOLD_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_MAX_THRESHOLD_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_MAX_THRESHOLD_set", id, 2);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_MAX_THRESHOLD_set", value, 255);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_MAX_THRESHOLD_set", id, value );

    /* (0x00000224 bits 31:24) bits 0:7 use field MAX_THRESHOLD of register PMC_PM20_82_24_REG_ADC_OC_REGISTER5 */
    t8_reg_ADC_OC_REGISTER5_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MAX_THRESHOLD_MSK,
                                       PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MAX_THRESHOLD_OFF,
                                       value);
}

static INLINE UINT32 t8_field_MAX_THRESHOLD_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_MAX_THRESHOLD_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_MAX_THRESHOLD_get", id, 2);
    /* (0x00000224 bits 31:24) bits 0:7 use field MAX_THRESHOLD of register PMC_PM20_82_24_REG_ADC_OC_REGISTER5 */
    reg_value = t8_reg_ADC_OC_REGISTER5_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MAX_THRESHOLD_MSK) >> PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MAX_THRESHOLD_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_MAX_THRESHOLD_get", id, value );

    return value;
}
static INLINE void t8_field_range_MAX_THRESHOLD_set( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_MAX_THRESHOLD_set( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit,
                                                     UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_MAX_THRESHOLD_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_MAX_THRESHOLD_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_MAX_THRESHOLD_set", stop_bit, 7 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_MAX_THRESHOLD_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000224 bits 31:24) bits 0:7 use field MAX_THRESHOLD of register PMC_PM20_82_24_REG_ADC_OC_REGISTER5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000224 bits 31:24) bits 0:7 use field MAX_THRESHOLD of register PMC_PM20_82_24_REG_ADC_OC_REGISTER5 */
        t8_reg_ADC_OC_REGISTER5_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           subfield_mask << (PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MAX_THRESHOLD_OFF + subfield_offset),
                                           PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MAX_THRESHOLD_OFF + subfield_offset,
                                           value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_MAX_THRESHOLD_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_MAX_THRESHOLD_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_MAX_THRESHOLD_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_MAX_THRESHOLD_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_MAX_THRESHOLD_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000224 bits 31:24) bits 0:7 use field MAX_THRESHOLD of register PMC_PM20_82_24_REG_ADC_OC_REGISTER5 */
    reg_value = t8_reg_ADC_OC_REGISTER5_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MAX_THRESHOLD_MSK)
                  >> PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MAX_THRESHOLD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MAX_THRESHOLD_MSK, PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MAX_THRESHOLD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_MAX_THRESHOLD_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_MIN_THRESHOLD_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_MIN_THRESHOLD_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_MIN_THRESHOLD_set", id, 2);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_MIN_THRESHOLD_set", value, 255);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_MIN_THRESHOLD_set", id, value );

    /* (0x00000224 bits 23:16) bits 0:7 use field MIN_THRESHOLD of register PMC_PM20_82_24_REG_ADC_OC_REGISTER5 */
    t8_reg_ADC_OC_REGISTER5_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MIN_THRESHOLD_MSK,
                                       PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MIN_THRESHOLD_OFF,
                                       value);
}

static INLINE UINT32 t8_field_MIN_THRESHOLD_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_MIN_THRESHOLD_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_MIN_THRESHOLD_get", id, 2);
    /* (0x00000224 bits 23:16) bits 0:7 use field MIN_THRESHOLD of register PMC_PM20_82_24_REG_ADC_OC_REGISTER5 */
    reg_value = t8_reg_ADC_OC_REGISTER5_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MIN_THRESHOLD_MSK) >> PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MIN_THRESHOLD_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_MIN_THRESHOLD_get", id, value );

    return value;
}
static INLINE void t8_field_range_MIN_THRESHOLD_set( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_MIN_THRESHOLD_set( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit,
                                                     UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_MIN_THRESHOLD_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_MIN_THRESHOLD_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_MIN_THRESHOLD_set", stop_bit, 7 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_MIN_THRESHOLD_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000224 bits 23:16) bits 0:7 use field MIN_THRESHOLD of register PMC_PM20_82_24_REG_ADC_OC_REGISTER5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000224 bits 23:16) bits 0:7 use field MIN_THRESHOLD of register PMC_PM20_82_24_REG_ADC_OC_REGISTER5 */
        t8_reg_ADC_OC_REGISTER5_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           subfield_mask << (PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MIN_THRESHOLD_OFF + subfield_offset),
                                           PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MIN_THRESHOLD_OFF + subfield_offset,
                                           value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_MIN_THRESHOLD_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_MIN_THRESHOLD_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_MIN_THRESHOLD_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_MIN_THRESHOLD_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_MIN_THRESHOLD_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000224 bits 23:16) bits 0:7 use field MIN_THRESHOLD of register PMC_PM20_82_24_REG_ADC_OC_REGISTER5 */
    reg_value = t8_reg_ADC_OC_REGISTER5_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MIN_THRESHOLD_MSK)
                  >> PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MIN_THRESHOLD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MIN_THRESHOLD_MSK, PM20_82_24_REG_ADC_OC_REGISTER5_BIT_MIN_THRESHOLD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_MIN_THRESHOLD_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_THR_MAP79_64_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_THR_MAP79_64_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_THR_MAP79_64_set", id, 2);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_THR_MAP79_64_set", value, 65535);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_THR_MAP79_64_set", id, value );

    /* (0x00000224 bits 15:0) bits 0:15 use field THR_MAP79_64 of register PMC_PM20_82_24_REG_ADC_OC_REGISTER5 */
    t8_reg_ADC_OC_REGISTER5_field_set( b_ptr,
                                       h_ptr,
                                       id,
                                       PM20_82_24_REG_ADC_OC_REGISTER5_BIT_THR_MAP79_64_MSK,
                                       PM20_82_24_REG_ADC_OC_REGISTER5_BIT_THR_MAP79_64_OFF,
                                       value);
}

static INLINE UINT32 t8_field_THR_MAP79_64_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_THR_MAP79_64_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_THR_MAP79_64_get", id, 2);
    /* (0x00000224 bits 15:0) bits 0:15 use field THR_MAP79_64 of register PMC_PM20_82_24_REG_ADC_OC_REGISTER5 */
    reg_value = t8_reg_ADC_OC_REGISTER5_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_REGISTER5_BIT_THR_MAP79_64_MSK) >> PM20_82_24_REG_ADC_OC_REGISTER5_BIT_THR_MAP79_64_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_THR_MAP79_64_get", id, value );

    return value;
}
static INLINE void t8_field_range_THR_MAP79_64_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_THR_MAP79_64_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit,
                                                    UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_THR_MAP79_64_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_THR_MAP79_64_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_THR_MAP79_64_set", stop_bit, 15 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_THR_MAP79_64_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000224 bits 15:0) bits 0:15 use field THR_MAP79_64 of register PMC_PM20_82_24_REG_ADC_OC_REGISTER5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000224 bits 15:0) bits 0:15 use field THR_MAP79_64 of register PMC_PM20_82_24_REG_ADC_OC_REGISTER5 */
        t8_reg_ADC_OC_REGISTER5_field_set( b_ptr,
                                           h_ptr,
                                           id,
                                           subfield_mask << (PM20_82_24_REG_ADC_OC_REGISTER5_BIT_THR_MAP79_64_OFF + subfield_offset),
                                           PM20_82_24_REG_ADC_OC_REGISTER5_BIT_THR_MAP79_64_OFF + subfield_offset,
                                           value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_THR_MAP79_64_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_THR_MAP79_64_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_THR_MAP79_64_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_THR_MAP79_64_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_THR_MAP79_64_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000224 bits 15:0) bits 0:15 use field THR_MAP79_64 of register PMC_PM20_82_24_REG_ADC_OC_REGISTER5 */
    reg_value = t8_reg_ADC_OC_REGISTER5_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ADC_OC_REGISTER5_BIT_THR_MAP79_64_MSK)
                  >> PM20_82_24_REG_ADC_OC_REGISTER5_BIT_THR_MAP79_64_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ADC_OC_REGISTER5_BIT_THR_MAP79_64_MSK, PM20_82_24_REG_ADC_OC_REGISTER5_BIT_THR_MAP79_64_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_THR_MAP79_64_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_OFFSET_set( t8_buffer_t *b_ptr,
                                        t8_handle_t *h_ptr,
                                        UINT32 id,
                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_OFFSET_set( t8_buffer_t *b_ptr,
                                        t8_handle_t *h_ptr,
                                        UINT32 id,
                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_OFFSET_set", id, 2);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_OFFSET_set", value, 15);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_OFFSET_set", id, value );

    /* (0x00000228 bits 7:4) bits 0:3 use field OFFSET of register PMC_PM20_82_24_REG_GCOC_MABC_CFG_REG */
    t8_reg_GCOC_MABC_CFG_REG_field_set( b_ptr,
                                        h_ptr,
                                        id,
                                        PM20_82_24_REG_GCOC_MABC_CFG_REG_BIT_OFFSET_MSK,
                                        PM20_82_24_REG_GCOC_MABC_CFG_REG_BIT_OFFSET_OFF,
                                        value);
}

static INLINE UINT32 t8_field_OFFSET_get( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_OFFSET_get( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_OFFSET_get", id, 2);
    /* (0x00000228 bits 7:4) bits 0:3 use field OFFSET of register PMC_PM20_82_24_REG_GCOC_MABC_CFG_REG */
    reg_value = t8_reg_GCOC_MABC_CFG_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_GCOC_MABC_CFG_REG_BIT_OFFSET_MSK) >> PM20_82_24_REG_GCOC_MABC_CFG_REG_BIT_OFFSET_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_OFFSET_get", id, value );

    return value;
}
static INLINE void t8_field_range_OFFSET_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 start_bit,
                                              UINT32 stop_bit,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_OFFSET_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 start_bit,
                                              UINT32 stop_bit,
                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_OFFSET_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_OFFSET_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_OFFSET_set", stop_bit, 3 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_OFFSET_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000228 bits 7:4) bits 0:3 use field OFFSET of register PMC_PM20_82_24_REG_GCOC_MABC_CFG_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000228 bits 7:4) bits 0:3 use field OFFSET of register PMC_PM20_82_24_REG_GCOC_MABC_CFG_REG */
        t8_reg_GCOC_MABC_CFG_REG_field_set( b_ptr,
                                            h_ptr,
                                            id,
                                            subfield_mask << (PM20_82_24_REG_GCOC_MABC_CFG_REG_BIT_OFFSET_OFF + subfield_offset),
                                            PM20_82_24_REG_GCOC_MABC_CFG_REG_BIT_OFFSET_OFF + subfield_offset,
                                            value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_OFFSET_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_OFFSET_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_OFFSET_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_OFFSET_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_OFFSET_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000228 bits 7:4) bits 0:3 use field OFFSET of register PMC_PM20_82_24_REG_GCOC_MABC_CFG_REG */
    reg_value = t8_reg_GCOC_MABC_CFG_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_GCOC_MABC_CFG_REG_BIT_OFFSET_MSK)
                  >> PM20_82_24_REG_GCOC_MABC_CFG_REG_BIT_OFFSET_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_GCOC_MABC_CFG_REG_BIT_OFFSET_MSK, PM20_82_24_REG_GCOC_MABC_CFG_REG_BIT_OFFSET_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_OFFSET_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_DLOS_OVR_EN_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DLOS_OVR_EN_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DLOS_OVR_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DLOS_OVR_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DLOS_OVR_EN_set", id, value );

    /* (0x00000230 bits 18) field DLOS_OVR_EN of register PMC_PM20_82_24_REG_DLOS_CFG */
    t8_reg_DLOS_CFG_field_set( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_DLOS_CFG_BIT_DLOS_OVR_EN_MSK,
                               PM20_82_24_REG_DLOS_CFG_BIT_DLOS_OVR_EN_OFF,
                               value);
}

static INLINE UINT32 t8_field_DLOS_OVR_EN_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DLOS_OVR_EN_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DLOS_OVR_EN_get", id, 2);
    /* (0x00000230 bits 18) field DLOS_OVR_EN of register PMC_PM20_82_24_REG_DLOS_CFG */
    reg_value = t8_reg_DLOS_CFG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DLOS_CFG_BIT_DLOS_OVR_EN_MSK) >> PM20_82_24_REG_DLOS_CFG_BIT_DLOS_OVR_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DLOS_OVR_EN_get", id, value );

    return value;
}
static INLINE void t8_field_DLOS_OVR_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DLOS_OVR_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DLOS_OVR_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DLOS_OVR_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DLOS_OVR_set", id, value );

    /* (0x00000230 bits 17) field DLOS_OVR of register PMC_PM20_82_24_REG_DLOS_CFG */
    t8_reg_DLOS_CFG_field_set( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_DLOS_CFG_BIT_DLOS_OVR_MSK,
                               PM20_82_24_REG_DLOS_CFG_BIT_DLOS_OVR_OFF,
                               value);
}

static INLINE UINT32 t8_field_DLOS_OVR_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DLOS_OVR_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DLOS_OVR_get", id, 2);
    /* (0x00000230 bits 17) field DLOS_OVR of register PMC_PM20_82_24_REG_DLOS_CFG */
    reg_value = t8_reg_DLOS_CFG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DLOS_CFG_BIT_DLOS_OVR_MSK) >> PM20_82_24_REG_DLOS_CFG_BIT_DLOS_OVR_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DLOS_OVR_get", id, value );

    return value;
}
static INLINE void t8_field_LOS_ACC_CNT_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_LOS_ACC_CNT_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LOS_ACC_CNT_set", id, 2);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_LOS_ACC_CNT_set", value, 15);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_LOS_ACC_CNT_set", id, value );

    /* (0x00000230 bits 16:13) bits 0:3 use field LOS_ACC_CNT of register PMC_PM20_82_24_REG_DLOS_CFG */
    t8_reg_DLOS_CFG_field_set( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_DLOS_CFG_BIT_LOS_ACC_CNT_MSK,
                               PM20_82_24_REG_DLOS_CFG_BIT_LOS_ACC_CNT_OFF,
                               value);
}

static INLINE UINT32 t8_field_LOS_ACC_CNT_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_LOS_ACC_CNT_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LOS_ACC_CNT_get", id, 2);
    /* (0x00000230 bits 16:13) bits 0:3 use field LOS_ACC_CNT of register PMC_PM20_82_24_REG_DLOS_CFG */
    reg_value = t8_reg_DLOS_CFG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DLOS_CFG_BIT_LOS_ACC_CNT_MSK) >> PM20_82_24_REG_DLOS_CFG_BIT_LOS_ACC_CNT_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_LOS_ACC_CNT_get", id, value );

    return value;
}
static INLINE void t8_field_range_LOS_ACC_CNT_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_LOS_ACC_CNT_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_LOS_ACC_CNT_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_LOS_ACC_CNT_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_LOS_ACC_CNT_set", stop_bit, 3 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_LOS_ACC_CNT_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000230 bits 16:13) bits 0:3 use field LOS_ACC_CNT of register PMC_PM20_82_24_REG_DLOS_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000230 bits 16:13) bits 0:3 use field LOS_ACC_CNT of register PMC_PM20_82_24_REG_DLOS_CFG */
        t8_reg_DLOS_CFG_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   subfield_mask << (PM20_82_24_REG_DLOS_CFG_BIT_LOS_ACC_CNT_OFF + subfield_offset),
                                   PM20_82_24_REG_DLOS_CFG_BIT_LOS_ACC_CNT_OFF + subfield_offset,
                                   value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_LOS_ACC_CNT_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_LOS_ACC_CNT_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_LOS_ACC_CNT_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_LOS_ACC_CNT_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_LOS_ACC_CNT_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000230 bits 16:13) bits 0:3 use field LOS_ACC_CNT of register PMC_PM20_82_24_REG_DLOS_CFG */
    reg_value = t8_reg_DLOS_CFG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_DLOS_CFG_BIT_LOS_ACC_CNT_MSK)
                  >> PM20_82_24_REG_DLOS_CFG_BIT_LOS_ACC_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_DLOS_CFG_BIT_LOS_ACC_CNT_MSK, PM20_82_24_REG_DLOS_CFG_BIT_LOS_ACC_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_LOS_ACC_CNT_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_LOS_LIMIT_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_LOS_LIMIT_set( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id,
                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LOS_LIMIT_set", id, 2);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_LOS_LIMIT_set", value, 255);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_LOS_LIMIT_set", id, value );

    /* (0x00000230 bits 12:5) bits 0:7 use field LOS_LIMIT of register PMC_PM20_82_24_REG_DLOS_CFG */
    t8_reg_DLOS_CFG_field_set( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_DLOS_CFG_BIT_LOS_LIMIT_MSK,
                               PM20_82_24_REG_DLOS_CFG_BIT_LOS_LIMIT_OFF,
                               value);
}

static INLINE UINT32 t8_field_LOS_LIMIT_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_LOS_LIMIT_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_LOS_LIMIT_get", id, 2);
    /* (0x00000230 bits 12:5) bits 0:7 use field LOS_LIMIT of register PMC_PM20_82_24_REG_DLOS_CFG */
    reg_value = t8_reg_DLOS_CFG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DLOS_CFG_BIT_LOS_LIMIT_MSK) >> PM20_82_24_REG_DLOS_CFG_BIT_LOS_LIMIT_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_LOS_LIMIT_get", id, value );

    return value;
}
static INLINE void t8_field_range_LOS_LIMIT_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 start_bit,
                                                 UINT32 stop_bit,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_LOS_LIMIT_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 start_bit,
                                                 UINT32 stop_bit,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_LOS_LIMIT_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_LOS_LIMIT_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_LOS_LIMIT_set", stop_bit, 7 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_LOS_LIMIT_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000230 bits 12:5) bits 0:7 use field LOS_LIMIT of register PMC_PM20_82_24_REG_DLOS_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000230 bits 12:5) bits 0:7 use field LOS_LIMIT of register PMC_PM20_82_24_REG_DLOS_CFG */
        t8_reg_DLOS_CFG_field_set( b_ptr,
                                   h_ptr,
                                   id,
                                   subfield_mask << (PM20_82_24_REG_DLOS_CFG_BIT_LOS_LIMIT_OFF + subfield_offset),
                                   PM20_82_24_REG_DLOS_CFG_BIT_LOS_LIMIT_OFF + subfield_offset,
                                   value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_LOS_LIMIT_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_LOS_LIMIT_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_LOS_LIMIT_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_LOS_LIMIT_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_LOS_LIMIT_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000230 bits 12:5) bits 0:7 use field LOS_LIMIT of register PMC_PM20_82_24_REG_DLOS_CFG */
    reg_value = t8_reg_DLOS_CFG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_DLOS_CFG_BIT_LOS_LIMIT_MSK)
                  >> PM20_82_24_REG_DLOS_CFG_BIT_LOS_LIMIT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_DLOS_CFG_BIT_LOS_LIMIT_MSK, PM20_82_24_REG_DLOS_CFG_BIT_LOS_LIMIT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_LOS_LIMIT_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_ONE_COMP_EN_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ONE_COMP_EN_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ONE_COMP_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ONE_COMP_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ONE_COMP_EN_set", id, value );

    /* (0x00000230 bits 0) field ONE_COMP_EN of register PMC_PM20_82_24_REG_DLOS_CFG */
    t8_reg_DLOS_CFG_field_set( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_DLOS_CFG_BIT_ONE_COMP_EN_MSK,
                               PM20_82_24_REG_DLOS_CFG_BIT_ONE_COMP_EN_OFF,
                               value);
}

static INLINE UINT32 t8_field_ONE_COMP_EN_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ONE_COMP_EN_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ONE_COMP_EN_get", id, 2);
    /* (0x00000230 bits 0) field ONE_COMP_EN of register PMC_PM20_82_24_REG_DLOS_CFG */
    reg_value = t8_reg_DLOS_CFG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DLOS_CFG_BIT_ONE_COMP_EN_MSK) >> PM20_82_24_REG_DLOS_CFG_BIT_ONE_COMP_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ONE_COMP_EN_get", id, value );

    return value;
}
static INLINE void t8_field_GEN_USR_PAT_39_32_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_GEN_USR_PAT_39_32_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GEN_USR_PAT_39_32_set", id, 2);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_GEN_USR_PAT_39_32_set", value, 255);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_GEN_USR_PAT_39_32_set", id, value );

    /* (0x00000234 bits 31:24) field GEN_USR_PAT_39_32 of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    t8_reg_PATT_GEN_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_USR_PAT_39_32_MSK,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_USR_PAT_39_32_OFF,
                                         value);
}

static INLINE UINT32 t8_field_GEN_USR_PAT_39_32_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_GEN_USR_PAT_39_32_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GEN_USR_PAT_39_32_get", id, 2);
    /* (0x00000234 bits 31:24) field GEN_USR_PAT_39_32 of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    reg_value = t8_reg_PATT_GEN_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_USR_PAT_39_32_MSK) >> PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_USR_PAT_39_32_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_GEN_USR_PAT_39_32_get", id, value );

    return value;
}
static INLINE void t8_field_range_GEN_USR_PAT_39_32_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_GEN_USR_PAT_39_32_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_GEN_USR_PAT_39_32_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_GEN_USR_PAT_39_32_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_GEN_USR_PAT_39_32_set", stop_bit, 7 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_GEN_USR_PAT_39_32_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000234 bits 31:24) field GEN_USR_PAT_39_32 of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000234 bits 31:24) field GEN_USR_PAT_39_32 of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
        t8_reg_PATT_GEN_CNFG_REG1_field_set( b_ptr,
                                             h_ptr,
                                             id,
                                             subfield_mask << (PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_USR_PAT_39_32_OFF + subfield_offset),
                                             PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_USR_PAT_39_32_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_GEN_USR_PAT_39_32_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_GEN_USR_PAT_39_32_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_GEN_USR_PAT_39_32_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_GEN_USR_PAT_39_32_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_GEN_USR_PAT_39_32_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000234 bits 31:24) field GEN_USR_PAT_39_32 of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    reg_value = t8_reg_PATT_GEN_CNFG_REG1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_USR_PAT_39_32_MSK)
                  >> PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_USR_PAT_39_32_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_USR_PAT_39_32_MSK, PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_USR_PAT_39_32_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_GEN_USR_PAT_39_32_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PATT_BUS_WIDTH_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PATT_BUS_WIDTH_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PATT_BUS_WIDTH_set", id, 2);
    if (value > 63)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PATT_BUS_WIDTH_set", value, 63);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PATT_BUS_WIDTH_set", id, value );

    /* (0x00000234 bits 14:9) field PATT_BUS_WIDTH of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    t8_reg_PATT_GEN_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_PATT_BUS_WIDTH_MSK,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_PATT_BUS_WIDTH_OFF,
                                         value);
}

static INLINE UINT32 t8_field_PATT_BUS_WIDTH_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PATT_BUS_WIDTH_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PATT_BUS_WIDTH_get", id, 2);
    /* (0x00000234 bits 14:9) field PATT_BUS_WIDTH of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    reg_value = t8_reg_PATT_GEN_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_PATT_BUS_WIDTH_MSK) >> PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_PATT_BUS_WIDTH_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PATT_BUS_WIDTH_get", id, value );

    return value;
}
static INLINE void t8_field_range_PATT_BUS_WIDTH_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PATT_BUS_WIDTH_set( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id,
                                                      UINT32 start_bit,
                                                      UINT32 stop_bit,
                                                      UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PATT_BUS_WIDTH_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PATT_BUS_WIDTH_set", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PATT_BUS_WIDTH_set", stop_bit, 5 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PATT_BUS_WIDTH_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000234 bits 14:9) field PATT_BUS_WIDTH of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 5) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 5;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000234 bits 14:9) field PATT_BUS_WIDTH of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
        t8_reg_PATT_GEN_CNFG_REG1_field_set( b_ptr,
                                             h_ptr,
                                             id,
                                             subfield_mask << (PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_PATT_BUS_WIDTH_OFF + subfield_offset),
                                             PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_PATT_BUS_WIDTH_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PATT_BUS_WIDTH_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PATT_BUS_WIDTH_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PATT_BUS_WIDTH_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PATT_BUS_WIDTH_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PATT_BUS_WIDTH_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000234 bits 14:9) field PATT_BUS_WIDTH of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    reg_value = t8_reg_PATT_GEN_CNFG_REG1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_PATT_BUS_WIDTH_MSK)
                  >> PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_PATT_BUS_WIDTH_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_PATT_BUS_WIDTH_MSK, PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_PATT_BUS_WIDTH_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PATT_BUS_WIDTH_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_GEN_ERR_INJ_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_GEN_ERR_INJ_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GEN_ERR_INJ_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_GEN_ERR_INJ_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_GEN_ERR_INJ_set", id, value );

    /* (0x00000234 bits 8) field GEN_ERR_INJ of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    t8_reg_PATT_GEN_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_ERR_INJ_MSK,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_ERR_INJ_OFF,
                                         value);
}

static INLINE UINT32 t8_field_GEN_ERR_INJ_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_GEN_ERR_INJ_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GEN_ERR_INJ_get", id, 2);
    /* (0x00000234 bits 8) field GEN_ERR_INJ of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    reg_value = t8_reg_PATT_GEN_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_ERR_INJ_MSK) >> PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_ERR_INJ_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_GEN_ERR_INJ_get", id, value );

    return value;
}
static INLINE void t8_field_GEN_INV_set( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id,
                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_GEN_INV_set( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id,
                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GEN_INV_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_GEN_INV_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_GEN_INV_set", id, value );

    /* (0x00000234 bits 7) field GEN_INV of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    t8_reg_PATT_GEN_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_INV_MSK,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_INV_OFF,
                                         value);
}

static INLINE UINT32 t8_field_GEN_INV_get( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_GEN_INV_get( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GEN_INV_get", id, 2);
    /* (0x00000234 bits 7) field GEN_INV of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    reg_value = t8_reg_PATT_GEN_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_INV_MSK) >> PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_INV_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_GEN_INV_get", id, value );

    return value;
}
static INLINE void t8_field_GEN_MODE_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_GEN_MODE_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GEN_MODE_set", id, 2);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_GEN_MODE_set", value, 15);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_GEN_MODE_set", id, value );

    /* (0x00000234 bits 6:3) field GEN_MODE of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    t8_reg_PATT_GEN_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_MODE_MSK,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_MODE_OFF,
                                         value);
}

static INLINE UINT32 t8_field_GEN_MODE_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_GEN_MODE_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GEN_MODE_get", id, 2);
    /* (0x00000234 bits 6:3) field GEN_MODE of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    reg_value = t8_reg_PATT_GEN_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_MODE_MSK) >> PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_MODE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_GEN_MODE_get", id, value );

    return value;
}
static INLINE void t8_field_range_GEN_MODE_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_GEN_MODE_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_GEN_MODE_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_GEN_MODE_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_GEN_MODE_set", stop_bit, 3 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_GEN_MODE_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000234 bits 6:3) field GEN_MODE of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000234 bits 6:3) field GEN_MODE of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
        t8_reg_PATT_GEN_CNFG_REG1_field_set( b_ptr,
                                             h_ptr,
                                             id,
                                             subfield_mask << (PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_MODE_OFF + subfield_offset),
                                             PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_MODE_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_GEN_MODE_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_GEN_MODE_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_GEN_MODE_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_GEN_MODE_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_GEN_MODE_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000234 bits 6:3) field GEN_MODE of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    reg_value = t8_reg_PATT_GEN_CNFG_REG1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_MODE_MSK)
                  >> PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_MODE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_MODE_MSK, PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_MODE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_GEN_MODE_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_INV_TX_DATA_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_INV_TX_DATA_set( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id,
                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_INV_TX_DATA_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_INV_TX_DATA_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_INV_TX_DATA_set", id, value );

    /* (0x00000234 bits 2) field INV_TX_DATA of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    t8_reg_PATT_GEN_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_INV_TX_DATA_MSK,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_INV_TX_DATA_OFF,
                                         value);
}

static INLINE UINT32 t8_field_INV_TX_DATA_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_INV_TX_DATA_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_INV_TX_DATA_get", id, 2);
    /* (0x00000234 bits 2) field INV_TX_DATA of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    reg_value = t8_reg_PATT_GEN_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_INV_TX_DATA_MSK) >> PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_INV_TX_DATA_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_INV_TX_DATA_get", id, value );

    return value;
}
static INLINE void t8_field_PATT_GEN_SEL_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PATT_GEN_SEL_set( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id,
                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PATT_GEN_SEL_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PATT_GEN_SEL_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PATT_GEN_SEL_set", id, value );

    /* (0x00000234 bits 1) field PATT_GEN_SEL of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    t8_reg_PATT_GEN_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_PATT_GEN_SEL_MSK,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_PATT_GEN_SEL_OFF,
                                         value);
}

static INLINE UINT32 t8_field_PATT_GEN_SEL_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PATT_GEN_SEL_get( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PATT_GEN_SEL_get", id, 2);
    /* (0x00000234 bits 1) field PATT_GEN_SEL of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    reg_value = t8_reg_PATT_GEN_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_PATT_GEN_SEL_MSK) >> PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_PATT_GEN_SEL_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PATT_GEN_SEL_get", id, value );

    return value;
}
static INLINE void t8_field_GEN_EN_set( t8_buffer_t *b_ptr,
                                        t8_handle_t *h_ptr,
                                        UINT32 id,
                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_GEN_EN_set( t8_buffer_t *b_ptr,
                                        t8_handle_t *h_ptr,
                                        UINT32 id,
                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GEN_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_GEN_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_GEN_EN_set", id, value );

    /* (0x00000234 bits 0) field GEN_EN of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    t8_reg_PATT_GEN_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_EN_MSK,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_EN_OFF,
                                         value);
}

static INLINE UINT32 t8_field_GEN_EN_get( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_GEN_EN_get( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GEN_EN_get", id, 2);
    /* (0x00000234 bits 0) field GEN_EN of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG1 */
    reg_value = t8_reg_PATT_GEN_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_EN_MSK) >> PM20_82_24_REG_PATT_GEN_CNFG_REG1_BIT_GEN_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_GEN_EN_get", id, value );

    return value;
}
static INLINE void t8_field_GEN_USR_PAT_31_0_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_GEN_USR_PAT_31_0_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GEN_USR_PAT_31_0_set", id, 2);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_GEN_USR_PAT_31_0_set", id, value );

    /* (0x00000238 bits 31:0) field GEN_USR_PAT_31_0 of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG2 */
    t8_reg_PATT_GEN_CNFG_REG2_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG2_BIT_GEN_USR_PAT_31_0_MSK,
                                         PM20_82_24_REG_PATT_GEN_CNFG_REG2_BIT_GEN_USR_PAT_31_0_OFF,
                                         value);
}

static INLINE UINT32 t8_field_GEN_USR_PAT_31_0_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_GEN_USR_PAT_31_0_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_GEN_USR_PAT_31_0_get", id, 2);
    /* (0x00000238 bits 31:0) field GEN_USR_PAT_31_0 of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG2 */
    reg_value = t8_reg_PATT_GEN_CNFG_REG2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PATT_GEN_CNFG_REG2_BIT_GEN_USR_PAT_31_0_MSK) >> PM20_82_24_REG_PATT_GEN_CNFG_REG2_BIT_GEN_USR_PAT_31_0_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_GEN_USR_PAT_31_0_get", id, value );

    return value;
}
static INLINE void t8_field_range_GEN_USR_PAT_31_0_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_GEN_USR_PAT_31_0_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_GEN_USR_PAT_31_0_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_GEN_USR_PAT_31_0_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_GEN_USR_PAT_31_0_set", stop_bit, 31 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_GEN_USR_PAT_31_0_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000238 bits 31:0) field GEN_USR_PAT_31_0 of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000238 bits 31:0) field GEN_USR_PAT_31_0 of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG2 */
        t8_reg_PATT_GEN_CNFG_REG2_field_set( b_ptr,
                                             h_ptr,
                                             id,
                                             subfield_mask << (PM20_82_24_REG_PATT_GEN_CNFG_REG2_BIT_GEN_USR_PAT_31_0_OFF + subfield_offset),
                                             PM20_82_24_REG_PATT_GEN_CNFG_REG2_BIT_GEN_USR_PAT_31_0_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_GEN_USR_PAT_31_0_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_GEN_USR_PAT_31_0_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_GEN_USR_PAT_31_0_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_GEN_USR_PAT_31_0_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_GEN_USR_PAT_31_0_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000238 bits 31:0) field GEN_USR_PAT_31_0 of register PMC_PM20_82_24_REG_PATT_GEN_CNFG_REG2 */
    reg_value = t8_reg_PATT_GEN_CNFG_REG2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PATT_GEN_CNFG_REG2_BIT_GEN_USR_PAT_31_0_MSK)
                  >> PM20_82_24_REG_PATT_GEN_CNFG_REG2_BIT_GEN_USR_PAT_31_0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PATT_GEN_CNFG_REG2_BIT_GEN_USR_PAT_31_0_MSK, PM20_82_24_REG_PATT_GEN_CNFG_REG2_BIT_GEN_USR_PAT_31_0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_GEN_USR_PAT_31_0_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_CHK_USR_PAT_39_32_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CHK_USR_PAT_39_32_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CHK_USR_PAT_39_32_set", id, 2);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CHK_USR_PAT_39_32_set", value, 255);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CHK_USR_PAT_39_32_set", id, value );

    /* (0x0000023c bits 31:24) field CHK_USR_PAT_39_32 of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
    t8_reg_PATT_CHK_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_USR_PAT_39_32_MSK,
                                         PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_USR_PAT_39_32_OFF,
                                         value);
}

static INLINE UINT32 t8_field_CHK_USR_PAT_39_32_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CHK_USR_PAT_39_32_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CHK_USR_PAT_39_32_get", id, 2);
    /* (0x0000023c bits 31:24) field CHK_USR_PAT_39_32 of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
    reg_value = t8_reg_PATT_CHK_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_USR_PAT_39_32_MSK) >> PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_USR_PAT_39_32_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CHK_USR_PAT_39_32_get", id, value );

    return value;
}
static INLINE void t8_field_range_CHK_USR_PAT_39_32_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_CHK_USR_PAT_39_32_set( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CHK_USR_PAT_39_32_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CHK_USR_PAT_39_32_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CHK_USR_PAT_39_32_set", stop_bit, 7 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CHK_USR_PAT_39_32_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000023c bits 31:24) field CHK_USR_PAT_39_32 of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000023c bits 31:24) field CHK_USR_PAT_39_32 of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
        t8_reg_PATT_CHK_CNFG_REG1_field_set( b_ptr,
                                             h_ptr,
                                             id,
                                             subfield_mask << (PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_USR_PAT_39_32_OFF + subfield_offset),
                                             PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_USR_PAT_39_32_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_CHK_USR_PAT_39_32_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_CHK_USR_PAT_39_32_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CHK_USR_PAT_39_32_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CHK_USR_PAT_39_32_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CHK_USR_PAT_39_32_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000023c bits 31:24) field CHK_USR_PAT_39_32 of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
    reg_value = t8_reg_PATT_CHK_CNFG_REG1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_USR_PAT_39_32_MSK)
                  >> PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_USR_PAT_39_32_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_USR_PAT_39_32_MSK, PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_USR_PAT_39_32_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CHK_USR_PAT_39_32_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_CHK_READ_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CHK_READ_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CHK_READ_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CHK_READ_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CHK_READ_set", id, value );

    /* (0x0000023c bits 8) field CHK_READ of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
    t8_reg_PATT_CHK_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_READ_MSK,
                                         PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_READ_OFF,
                                         value);
}

static INLINE UINT32 t8_field_CHK_READ_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CHK_READ_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CHK_READ_get", id, 2);
    /* (0x0000023c bits 8) field CHK_READ of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
    reg_value = t8_reg_PATT_CHK_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_READ_MSK) >> PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_READ_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CHK_READ_get", id, value );

    return value;
}
static INLINE void t8_field_CHK_INV_set( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id,
                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CHK_INV_set( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id,
                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CHK_INV_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CHK_INV_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CHK_INV_set", id, value );

    /* (0x0000023c bits 7) field CHK_INV of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
    t8_reg_PATT_CHK_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_INV_MSK,
                                         PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_INV_OFF,
                                         value);
}

static INLINE UINT32 t8_field_CHK_INV_get( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CHK_INV_get( t8_buffer_t *b_ptr,
                                           t8_handle_t *h_ptr,
                                           UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CHK_INV_get", id, 2);
    /* (0x0000023c bits 7) field CHK_INV of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
    reg_value = t8_reg_PATT_CHK_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_INV_MSK) >> PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_INV_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CHK_INV_get", id, value );

    return value;
}
static INLINE void t8_field_CHK_MODE_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CHK_MODE_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CHK_MODE_set", id, 2);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CHK_MODE_set", value, 15);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CHK_MODE_set", id, value );

    /* (0x0000023c bits 6:3) field CHK_MODE of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
    t8_reg_PATT_CHK_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_MODE_MSK,
                                         PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_MODE_OFF,
                                         value);
}

static INLINE UINT32 t8_field_CHK_MODE_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CHK_MODE_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CHK_MODE_get", id, 2);
    /* (0x0000023c bits 6:3) field CHK_MODE of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
    reg_value = t8_reg_PATT_CHK_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_MODE_MSK) >> PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_MODE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CHK_MODE_get", id, value );

    return value;
}
static INLINE void t8_field_range_CHK_MODE_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_CHK_MODE_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 start_bit,
                                                UINT32 stop_bit,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CHK_MODE_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CHK_MODE_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CHK_MODE_set", stop_bit, 3 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CHK_MODE_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000023c bits 6:3) field CHK_MODE of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000023c bits 6:3) field CHK_MODE of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
        t8_reg_PATT_CHK_CNFG_REG1_field_set( b_ptr,
                                             h_ptr,
                                             id,
                                             subfield_mask << (PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_MODE_OFF + subfield_offset),
                                             PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_MODE_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_CHK_MODE_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_CHK_MODE_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 start_bit,
                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CHK_MODE_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CHK_MODE_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CHK_MODE_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000023c bits 6:3) field CHK_MODE of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
    reg_value = t8_reg_PATT_CHK_CNFG_REG1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_MODE_MSK)
                  >> PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_MODE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_MODE_MSK, PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_MODE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CHK_MODE_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_CHK_EN_set( t8_buffer_t *b_ptr,
                                        t8_handle_t *h_ptr,
                                        UINT32 id,
                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CHK_EN_set( t8_buffer_t *b_ptr,
                                        t8_handle_t *h_ptr,
                                        UINT32 id,
                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CHK_EN_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CHK_EN_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CHK_EN_set", id, value );

    /* (0x0000023c bits 0) field CHK_EN of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
    t8_reg_PATT_CHK_CNFG_REG1_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_EN_MSK,
                                         PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_EN_OFF,
                                         value);
}

static INLINE UINT32 t8_field_CHK_EN_get( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CHK_EN_get( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CHK_EN_get", id, 2);
    /* (0x0000023c bits 0) field CHK_EN of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG1 */
    reg_value = t8_reg_PATT_CHK_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_EN_MSK) >> PM20_82_24_REG_PATT_CHK_CNFG_REG1_BIT_CHK_EN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CHK_EN_get", id, value );

    return value;
}
static INLINE void t8_field_CHK_USR_PAT_31_0_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CHK_USR_PAT_31_0_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CHK_USR_PAT_31_0_set", id, 2);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CHK_USR_PAT_31_0_set", id, value );

    /* (0x00000240 bits 31:0) field CHK_USR_PAT_31_0 of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG2 */
    t8_reg_PATT_CHK_CNFG_REG2_field_set( b_ptr,
                                         h_ptr,
                                         id,
                                         PM20_82_24_REG_PATT_CHK_CNFG_REG2_BIT_CHK_USR_PAT_31_0_MSK,
                                         PM20_82_24_REG_PATT_CHK_CNFG_REG2_BIT_CHK_USR_PAT_31_0_OFF,
                                         value);
}

static INLINE UINT32 t8_field_CHK_USR_PAT_31_0_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CHK_USR_PAT_31_0_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CHK_USR_PAT_31_0_get", id, 2);
    /* (0x00000240 bits 31:0) field CHK_USR_PAT_31_0 of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG2 */
    reg_value = t8_reg_PATT_CHK_CNFG_REG2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PATT_CHK_CNFG_REG2_BIT_CHK_USR_PAT_31_0_MSK) >> PM20_82_24_REG_PATT_CHK_CNFG_REG2_BIT_CHK_USR_PAT_31_0_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CHK_USR_PAT_31_0_get", id, value );

    return value;
}
static INLINE void t8_field_range_CHK_USR_PAT_31_0_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_CHK_USR_PAT_31_0_set( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CHK_USR_PAT_31_0_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CHK_USR_PAT_31_0_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CHK_USR_PAT_31_0_set", stop_bit, 31 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CHK_USR_PAT_31_0_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000240 bits 31:0) field CHK_USR_PAT_31_0 of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000240 bits 31:0) field CHK_USR_PAT_31_0 of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG2 */
        t8_reg_PATT_CHK_CNFG_REG2_field_set( b_ptr,
                                             h_ptr,
                                             id,
                                             subfield_mask << (PM20_82_24_REG_PATT_CHK_CNFG_REG2_BIT_CHK_USR_PAT_31_0_OFF + subfield_offset),
                                             PM20_82_24_REG_PATT_CHK_CNFG_REG2_BIT_CHK_USR_PAT_31_0_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_CHK_USR_PAT_31_0_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_CHK_USR_PAT_31_0_get( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CHK_USR_PAT_31_0_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CHK_USR_PAT_31_0_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CHK_USR_PAT_31_0_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000240 bits 31:0) field CHK_USR_PAT_31_0 of register PMC_PM20_82_24_REG_PATT_CHK_CNFG_REG2 */
    reg_value = t8_reg_PATT_CHK_CNFG_REG2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PATT_CHK_CNFG_REG2_BIT_CHK_USR_PAT_31_0_MSK)
                  >> PM20_82_24_REG_PATT_CHK_CNFG_REG2_BIT_CHK_USR_PAT_31_0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PATT_CHK_CNFG_REG2_BIT_CHK_USR_PAT_31_0_MSK, PM20_82_24_REG_PATT_CHK_CNFG_REG2_BIT_CHK_USR_PAT_31_0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CHK_USR_PAT_31_0_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE void t8_field_PCBI_TX_PSELI_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PCBI_TX_PSELI_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PCBI_TX_PSELI_set", id, 2);
    if (value > 131071)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PCBI_TX_PSELI_set", value, 131071);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PCBI_TX_PSELI_set", id, value );

    /* (0x00000248 bits 16:0) bits 0:16 use field PCBI_TX_PSELI of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_5 */
    t8_reg_TX_CNTRL_OVERRIDE_5_field_set( b_ptr,
                                          h_ptr,
                                          id,
                                          PM20_82_24_REG_TX_CNTRL_OVERRIDE_5_BIT_PCBI_TX_PSELI_MSK,
                                          PM20_82_24_REG_TX_CNTRL_OVERRIDE_5_BIT_PCBI_TX_PSELI_OFF,
                                          value);
}

static INLINE UINT32 t8_field_PCBI_TX_PSELI_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PCBI_TX_PSELI_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PCBI_TX_PSELI_get", id, 2);
    /* (0x00000248 bits 16:0) bits 0:16 use field PCBI_TX_PSELI of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_5 */
    reg_value = t8_reg_TX_CNTRL_OVERRIDE_5_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTRL_OVERRIDE_5_BIT_PCBI_TX_PSELI_MSK) >> PM20_82_24_REG_TX_CNTRL_OVERRIDE_5_BIT_PCBI_TX_PSELI_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PCBI_TX_PSELI_get", id, value );

    return value;
}
static INLINE void t8_field_range_PCBI_TX_PSELI_set( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_range_PCBI_TX_PSELI_set( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit,
                                                     UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PCBI_TX_PSELI_set", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PCBI_TX_PSELI_set", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PCBI_TX_PSELI_set", stop_bit, 16 );
    IOLOG( "%s <= id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PCBI_TX_PSELI_set", id, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000248 bits 16:0) bits 0:16 use field PCBI_TX_PSELI of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 16) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 16;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000248 bits 16:0) bits 0:16 use field PCBI_TX_PSELI of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_5 */
        t8_reg_TX_CNTRL_OVERRIDE_5_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              subfield_mask << (PM20_82_24_REG_TX_CNTRL_OVERRIDE_5_BIT_PCBI_TX_PSELI_OFF + subfield_offset),
                                              PM20_82_24_REG_TX_CNTRL_OVERRIDE_5_BIT_PCBI_TX_PSELI_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 t8_field_range_PCBI_TX_PSELI_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PCBI_TX_PSELI_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PCBI_TX_PSELI_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PCBI_TX_PSELI_get", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PCBI_TX_PSELI_get", stop_bit, 16 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 16) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 16;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000248 bits 16:0) bits 0:16 use field PCBI_TX_PSELI of register PMC_PM20_82_24_REG_TX_CNTRL_OVERRIDE_5 */
    reg_value = t8_reg_TX_CNTRL_OVERRIDE_5_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_TX_CNTRL_OVERRIDE_5_BIT_PCBI_TX_PSELI_MSK)
                  >> PM20_82_24_REG_TX_CNTRL_OVERRIDE_5_BIT_PCBI_TX_PSELI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_TX_CNTRL_OVERRIDE_5_BIT_PCBI_TX_PSELI_MSK, PM20_82_24_REG_TX_CNTRL_OVERRIDE_5_BIT_PCBI_TX_PSELI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PCBI_TX_PSELI_get", id, start_bit, stop_bit, value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset config_edge
 * ==================================================================================
 */
static INLINE void t8_field_PPM_OFF_RD_REQ_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PPM_OFF_RD_REQ_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PPM_OFF_RD_REQ_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PPM_OFF_RD_REQ_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PPM_OFF_RD_REQ_set", id, value );

    /* (0x00000034 bits 0) field PPM_OFF_RD_REQ of register PMC_PM20_82_24_REG_PLL_CNFG_REG1 */
    t8_reg_PLL_CNFG_REG1_field_set( b_ptr,
                                    h_ptr,
                                    id,
                                    PM20_82_24_REG_PLL_CNFG_REG1_BIT_PPM_OFF_RD_REQ_MSK,
                                    PM20_82_24_REG_PLL_CNFG_REG1_BIT_PPM_OFF_RD_REQ_OFF,
                                    value);
}

static INLINE UINT32 t8_field_PPM_OFF_RD_REQ_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PPM_OFF_RD_REQ_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PPM_OFF_RD_REQ_get", id, 2);
    /* (0x00000034 bits 0) field PPM_OFF_RD_REQ of register PMC_PM20_82_24_REG_PLL_CNFG_REG1 */
    reg_value = t8_reg_PLL_CNFG_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PLL_CNFG_REG1_BIT_PPM_OFF_RD_REQ_MSK) >> PM20_82_24_REG_PLL_CNFG_REG1_BIT_PPM_OFF_RD_REQ_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PPM_OFF_RD_REQ_get", id, value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_active_rising
 * ==================================================================================
 */
static INLINE void t8_field_CALIB_PASS_I19_set_to_clear( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CALIB_PASS_I19_set_to_clear( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CALIB_PASS_I19_set_to_clear", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CALIB_PASS_I19_set_to_clear", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CALIB_PASS_I19_set_to_clear", id, value );

    /* (0x0000007c bits 19) field CALIB_PASS_I19 of register PMC_PM20_82_24_REG_INT_REG */
    t8_reg_INT_REG_action_on_write_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              PM20_82_24_REG_INT_REG_BIT_CALIB_PASS_I19_MSK,
                                              PM20_82_24_REG_INT_REG_BIT_CALIB_PASS_I19_OFF,
                                              value);
}

static INLINE UINT32 t8_field_CALIB_PASS_I19_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CALIB_PASS_I19_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CALIB_PASS_I19_get", id, 2);
    /* (0x0000007c bits 19) field CALIB_PASS_I19 of register PMC_PM20_82_24_REG_INT_REG */
    reg_value = t8_reg_INT_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_INT_REG_BIT_CALIB_PASS_I19_MSK) >> PM20_82_24_REG_INT_REG_BIT_CALIB_PASS_I19_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CALIB_PASS_I19_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_CALIB_PASS_I19_poll( t8_buffer_t *b_ptr,
                                                                 t8_handle_t *h_ptr,
                                                                 UINT32 id,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_CALIB_PASS_I19_poll( t8_buffer_t *b_ptr,
                                                                 t8_handle_t *h_ptr,
                                                                 UINT32 id,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_CALIB_PASS_I19_poll", id, value );

    /* (0x0000007c bits 19) field CALIB_PASS_I19 of register PMC_PM20_82_24_REG_INT_REG */
    return t8_reg_INT_REG_poll( b_ptr,
                                h_ptr,
                                id,
                                PM20_82_24_REG_INT_REG_BIT_CALIB_PASS_I19_MSK,
                                (value<<PM20_82_24_REG_INT_REG_BIT_CALIB_PASS_I19_OFF),
                                cmp,
                                max_count,
                                num_failed_polls,
                                delay_between_polls_in_microseconds);
}

static INLINE void t8_field_PATT_MON_ERR_I18_set_to_clear( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PATT_MON_ERR_I18_set_to_clear( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PATT_MON_ERR_I18_set_to_clear", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PATT_MON_ERR_I18_set_to_clear", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PATT_MON_ERR_I18_set_to_clear", id, value );

    /* (0x0000007c bits 18) field PATT_MON_ERR_I18 of register PMC_PM20_82_24_REG_INT_REG */
    t8_reg_INT_REG_action_on_write_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              PM20_82_24_REG_INT_REG_BIT_PATT_MON_ERR_I18_MSK,
                                              PM20_82_24_REG_INT_REG_BIT_PATT_MON_ERR_I18_OFF,
                                              value);
}

static INLINE UINT32 t8_field_PATT_MON_ERR_I18_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PATT_MON_ERR_I18_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PATT_MON_ERR_I18_get", id, 2);
    /* (0x0000007c bits 18) field PATT_MON_ERR_I18 of register PMC_PM20_82_24_REG_INT_REG */
    reg_value = t8_reg_INT_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_INT_REG_BIT_PATT_MON_ERR_I18_MSK) >> PM20_82_24_REG_INT_REG_BIT_PATT_MON_ERR_I18_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PATT_MON_ERR_I18_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_PATT_MON_ERR_I18_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_PATT_MON_ERR_I18_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_PATT_MON_ERR_I18_poll", id, value );

    /* (0x0000007c bits 18) field PATT_MON_ERR_I18 of register PMC_PM20_82_24_REG_INT_REG */
    return t8_reg_INT_REG_poll( b_ptr,
                                h_ptr,
                                id,
                                PM20_82_24_REG_INT_REG_BIT_PATT_MON_ERR_I18_MSK,
                                (value<<PM20_82_24_REG_INT_REG_BIT_PATT_MON_ERR_I18_OFF),
                                cmp,
                                max_count,
                                num_failed_polls,
                                delay_between_polls_in_microseconds);
}

static INLINE void t8_field_ADC_BIST_ERR_I17_set_to_clear( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADC_BIST_ERR_I17_set_to_clear( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_BIST_ERR_I17_set_to_clear", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADC_BIST_ERR_I17_set_to_clear", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADC_BIST_ERR_I17_set_to_clear", id, value );

    /* (0x0000007c bits 17) field ADC_BIST_ERR_I17 of register PMC_PM20_82_24_REG_INT_REG */
    t8_reg_INT_REG_action_on_write_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              PM20_82_24_REG_INT_REG_BIT_ADC_BIST_ERR_I17_MSK,
                                              PM20_82_24_REG_INT_REG_BIT_ADC_BIST_ERR_I17_OFF,
                                              value);
}

static INLINE UINT32 t8_field_ADC_BIST_ERR_I17_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADC_BIST_ERR_I17_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_BIST_ERR_I17_get", id, 2);
    /* (0x0000007c bits 17) field ADC_BIST_ERR_I17 of register PMC_PM20_82_24_REG_INT_REG */
    reg_value = t8_reg_INT_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_INT_REG_BIT_ADC_BIST_ERR_I17_MSK) >> PM20_82_24_REG_INT_REG_BIT_ADC_BIST_ERR_I17_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADC_BIST_ERR_I17_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_ADC_BIST_ERR_I17_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_ADC_BIST_ERR_I17_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_ADC_BIST_ERR_I17_poll", id, value );

    /* (0x0000007c bits 17) field ADC_BIST_ERR_I17 of register PMC_PM20_82_24_REG_INT_REG */
    return t8_reg_INT_REG_poll( b_ptr,
                                h_ptr,
                                id,
                                PM20_82_24_REG_INT_REG_BIT_ADC_BIST_ERR_I17_MSK,
                                (value<<PM20_82_24_REG_INT_REG_BIT_ADC_BIST_ERR_I17_OFF),
                                cmp,
                                max_count,
                                num_failed_polls,
                                delay_between_polls_in_microseconds);
}

static INLINE void t8_field_ADC_BIST_DONE_I16_set_to_clear( t8_buffer_t *b_ptr,
                                                            t8_handle_t *h_ptr,
                                                            UINT32 id,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADC_BIST_DONE_I16_set_to_clear( t8_buffer_t *b_ptr,
                                                            t8_handle_t *h_ptr,
                                                            UINT32 id,
                                                            UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_BIST_DONE_I16_set_to_clear", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADC_BIST_DONE_I16_set_to_clear", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADC_BIST_DONE_I16_set_to_clear", id, value );

    /* (0x0000007c bits 16) field ADC_BIST_DONE_I16 of register PMC_PM20_82_24_REG_INT_REG */
    t8_reg_INT_REG_action_on_write_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              PM20_82_24_REG_INT_REG_BIT_ADC_BIST_DONE_I16_MSK,
                                              PM20_82_24_REG_INT_REG_BIT_ADC_BIST_DONE_I16_OFF,
                                              value);
}

static INLINE UINT32 t8_field_ADC_BIST_DONE_I16_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADC_BIST_DONE_I16_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_BIST_DONE_I16_get", id, 2);
    /* (0x0000007c bits 16) field ADC_BIST_DONE_I16 of register PMC_PM20_82_24_REG_INT_REG */
    reg_value = t8_reg_INT_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_INT_REG_BIT_ADC_BIST_DONE_I16_MSK) >> PM20_82_24_REG_INT_REG_BIT_ADC_BIST_DONE_I16_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADC_BIST_DONE_I16_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_ADC_BIST_DONE_I16_poll( t8_buffer_t *b_ptr,
                                                                    t8_handle_t *h_ptr,
                                                                    UINT32 id,
                                                                    UINT32 value,
                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                    UINT32 max_count,
                                                                    UINT32 *num_failed_polls,
                                                                    UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_ADC_BIST_DONE_I16_poll( t8_buffer_t *b_ptr,
                                                                    t8_handle_t *h_ptr,
                                                                    UINT32 id,
                                                                    UINT32 value,
                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                    UINT32 max_count,
                                                                    UINT32 *num_failed_polls,
                                                                    UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_ADC_BIST_DONE_I16_poll", id, value );

    /* (0x0000007c bits 16) field ADC_BIST_DONE_I16 of register PMC_PM20_82_24_REG_INT_REG */
    return t8_reg_INT_REG_poll( b_ptr,
                                h_ptr,
                                id,
                                PM20_82_24_REG_INT_REG_BIT_ADC_BIST_DONE_I16_MSK,
                                (value<<PM20_82_24_REG_INT_REG_BIT_ADC_BIST_DONE_I16_OFF),
                                cmp,
                                max_count,
                                num_failed_polls,
                                delay_between_polls_in_microseconds);
}

static INLINE void t8_field_ADCOC_FSM_ERR_I15_set_to_clear( t8_buffer_t *b_ptr,
                                                            t8_handle_t *h_ptr,
                                                            UINT32 id,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADCOC_FSM_ERR_I15_set_to_clear( t8_buffer_t *b_ptr,
                                                            t8_handle_t *h_ptr,
                                                            UINT32 id,
                                                            UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_FSM_ERR_I15_set_to_clear", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADCOC_FSM_ERR_I15_set_to_clear", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADCOC_FSM_ERR_I15_set_to_clear", id, value );

    /* (0x0000007c bits 15) field ADCOC_FSM_ERR_I15 of register PMC_PM20_82_24_REG_INT_REG */
    t8_reg_INT_REG_action_on_write_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              PM20_82_24_REG_INT_REG_BIT_ADCOC_FSM_ERR_I15_MSK,
                                              PM20_82_24_REG_INT_REG_BIT_ADCOC_FSM_ERR_I15_OFF,
                                              value);
}

static INLINE UINT32 t8_field_ADCOC_FSM_ERR_I15_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_FSM_ERR_I15_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_FSM_ERR_I15_get", id, 2);
    /* (0x0000007c bits 15) field ADCOC_FSM_ERR_I15 of register PMC_PM20_82_24_REG_INT_REG */
    reg_value = t8_reg_INT_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_INT_REG_BIT_ADCOC_FSM_ERR_I15_MSK) >> PM20_82_24_REG_INT_REG_BIT_ADCOC_FSM_ERR_I15_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_FSM_ERR_I15_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_ADCOC_FSM_ERR_I15_poll( t8_buffer_t *b_ptr,
                                                                    t8_handle_t *h_ptr,
                                                                    UINT32 id,
                                                                    UINT32 value,
                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                    UINT32 max_count,
                                                                    UINT32 *num_failed_polls,
                                                                    UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_ADCOC_FSM_ERR_I15_poll( t8_buffer_t *b_ptr,
                                                                    t8_handle_t *h_ptr,
                                                                    UINT32 id,
                                                                    UINT32 value,
                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                    UINT32 max_count,
                                                                    UINT32 *num_failed_polls,
                                                                    UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_ADCOC_FSM_ERR_I15_poll", id, value );

    /* (0x0000007c bits 15) field ADCOC_FSM_ERR_I15 of register PMC_PM20_82_24_REG_INT_REG */
    return t8_reg_INT_REG_poll( b_ptr,
                                h_ptr,
                                id,
                                PM20_82_24_REG_INT_REG_BIT_ADCOC_FSM_ERR_I15_MSK,
                                (value<<PM20_82_24_REG_INT_REG_BIT_ADCOC_FSM_ERR_I15_OFF),
                                cmp,
                                max_count,
                                num_failed_polls,
                                delay_between_polls_in_microseconds);
}

static INLINE void t8_field_DLOS_I14_set_to_clear( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DLOS_I14_set_to_clear( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DLOS_I14_set_to_clear", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DLOS_I14_set_to_clear", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DLOS_I14_set_to_clear", id, value );

    /* (0x0000007c bits 14) field DLOS_I14 of register PMC_PM20_82_24_REG_INT_REG */
    t8_reg_INT_REG_action_on_write_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              PM20_82_24_REG_INT_REG_BIT_DLOS_I14_MSK,
                                              PM20_82_24_REG_INT_REG_BIT_DLOS_I14_OFF,
                                              value);
}

static INLINE UINT32 t8_field_DLOS_I14_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DLOS_I14_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DLOS_I14_get", id, 2);
    /* (0x0000007c bits 14) field DLOS_I14 of register PMC_PM20_82_24_REG_INT_REG */
    reg_value = t8_reg_INT_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_INT_REG_BIT_DLOS_I14_MSK) >> PM20_82_24_REG_INT_REG_BIT_DLOS_I14_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DLOS_I14_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_DLOS_I14_poll( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value,
                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                           UINT32 max_count,
                                                           UINT32 *num_failed_polls,
                                                           UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_DLOS_I14_poll( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value,
                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                           UINT32 max_count,
                                                           UINT32 *num_failed_polls,
                                                           UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_DLOS_I14_poll", id, value );

    /* (0x0000007c bits 14) field DLOS_I14 of register PMC_PM20_82_24_REG_INT_REG */
    return t8_reg_INT_REG_poll( b_ptr,
                                h_ptr,
                                id,
                                PM20_82_24_REG_INT_REG_BIT_DLOS_I14_MSK,
                                (value<<PM20_82_24_REG_INT_REG_BIT_DLOS_I14_OFF),
                                cmp,
                                max_count,
                                num_failed_polls,
                                delay_between_polls_in_microseconds);
}

static INLINE void t8_field_DIV_CLK_DEAD_I9_set_to_clear( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DIV_CLK_DEAD_I9_set_to_clear( t8_buffer_t *b_ptr,
                                                          t8_handle_t *h_ptr,
                                                          UINT32 id,
                                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DIV_CLK_DEAD_I9_set_to_clear", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DIV_CLK_DEAD_I9_set_to_clear", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DIV_CLK_DEAD_I9_set_to_clear", id, value );

    /* (0x0000007c bits 9) field DIV_CLK_DEAD_I9 of register PMC_PM20_82_24_REG_INT_REG */
    t8_reg_INT_REG_action_on_write_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              PM20_82_24_REG_INT_REG_BIT_DIV_CLK_DEAD_I9_MSK,
                                              PM20_82_24_REG_INT_REG_BIT_DIV_CLK_DEAD_I9_OFF,
                                              value);
}

static INLINE UINT32 t8_field_DIV_CLK_DEAD_I9_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DIV_CLK_DEAD_I9_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DIV_CLK_DEAD_I9_get", id, 2);
    /* (0x0000007c bits 9) field DIV_CLK_DEAD_I9 of register PMC_PM20_82_24_REG_INT_REG */
    reg_value = t8_reg_INT_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_INT_REG_BIT_DIV_CLK_DEAD_I9_MSK) >> PM20_82_24_REG_INT_REG_BIT_DIV_CLK_DEAD_I9_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DIV_CLK_DEAD_I9_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_DIV_CLK_DEAD_I9_poll( t8_buffer_t *b_ptr,
                                                                  t8_handle_t *h_ptr,
                                                                  UINT32 id,
                                                                  UINT32 value,
                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                  UINT32 max_count,
                                                                  UINT32 *num_failed_polls,
                                                                  UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_DIV_CLK_DEAD_I9_poll( t8_buffer_t *b_ptr,
                                                                  t8_handle_t *h_ptr,
                                                                  UINT32 id,
                                                                  UINT32 value,
                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                  UINT32 max_count,
                                                                  UINT32 *num_failed_polls,
                                                                  UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_DIV_CLK_DEAD_I9_poll", id, value );

    /* (0x0000007c bits 9) field DIV_CLK_DEAD_I9 of register PMC_PM20_82_24_REG_INT_REG */
    return t8_reg_INT_REG_poll( b_ptr,
                                h_ptr,
                                id,
                                PM20_82_24_REG_INT_REG_BIT_DIV_CLK_DEAD_I9_MSK,
                                (value<<PM20_82_24_REG_INT_REG_BIT_DIV_CLK_DEAD_I9_OFF),
                                cmp,
                                max_count,
                                num_failed_polls,
                                delay_between_polls_in_microseconds);
}

static INLINE void t8_field_IN_RANGEN_FAILS_I7_set_to_clear( t8_buffer_t *b_ptr,
                                                             t8_handle_t *h_ptr,
                                                             UINT32 id,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_IN_RANGEN_FAILS_I7_set_to_clear( t8_buffer_t *b_ptr,
                                                             t8_handle_t *h_ptr,
                                                             UINT32 id,
                                                             UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_IN_RANGEN_FAILS_I7_set_to_clear", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_IN_RANGEN_FAILS_I7_set_to_clear", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_IN_RANGEN_FAILS_I7_set_to_clear", id, value );

    /* (0x0000007c bits 7) field IN_RANGEN_FAILS_I7 of register PMC_PM20_82_24_REG_INT_REG */
    t8_reg_INT_REG_action_on_write_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              PM20_82_24_REG_INT_REG_BIT_IN_RANGEN_FAILS_I7_MSK,
                                              PM20_82_24_REG_INT_REG_BIT_IN_RANGEN_FAILS_I7_OFF,
                                              value);
}

static INLINE UINT32 t8_field_IN_RANGEN_FAILS_I7_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_IN_RANGEN_FAILS_I7_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_IN_RANGEN_FAILS_I7_get", id, 2);
    /* (0x0000007c bits 7) field IN_RANGEN_FAILS_I7 of register PMC_PM20_82_24_REG_INT_REG */
    reg_value = t8_reg_INT_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_INT_REG_BIT_IN_RANGEN_FAILS_I7_MSK) >> PM20_82_24_REG_INT_REG_BIT_IN_RANGEN_FAILS_I7_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_IN_RANGEN_FAILS_I7_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_IN_RANGEN_FAILS_I7_poll( t8_buffer_t *b_ptr,
                                                                     t8_handle_t *h_ptr,
                                                                     UINT32 id,
                                                                     UINT32 value,
                                                                     PMC_POLL_COMPARISON_TYPE cmp,
                                                                     UINT32 max_count,
                                                                     UINT32 *num_failed_polls,
                                                                     UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_IN_RANGEN_FAILS_I7_poll( t8_buffer_t *b_ptr,
                                                                     t8_handle_t *h_ptr,
                                                                     UINT32 id,
                                                                     UINT32 value,
                                                                     PMC_POLL_COMPARISON_TYPE cmp,
                                                                     UINT32 max_count,
                                                                     UINT32 *num_failed_polls,
                                                                     UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_IN_RANGEN_FAILS_I7_poll", id, value );

    /* (0x0000007c bits 7) field IN_RANGEN_FAILS_I7 of register PMC_PM20_82_24_REG_INT_REG */
    return t8_reg_INT_REG_poll( b_ptr,
                                h_ptr,
                                id,
                                PM20_82_24_REG_INT_REG_BIT_IN_RANGEN_FAILS_I7_MSK,
                                (value<<PM20_82_24_REG_INT_REG_BIT_IN_RANGEN_FAILS_I7_OFF),
                                cmp,
                                max_count,
                                num_failed_polls,
                                delay_between_polls_in_microseconds);
}

static INLINE void t8_field_IN_RANGEN_PASSES_I6_set_to_clear( t8_buffer_t *b_ptr,
                                                              t8_handle_t *h_ptr,
                                                              UINT32 id,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_IN_RANGEN_PASSES_I6_set_to_clear( t8_buffer_t *b_ptr,
                                                              t8_handle_t *h_ptr,
                                                              UINT32 id,
                                                              UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_IN_RANGEN_PASSES_I6_set_to_clear", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_IN_RANGEN_PASSES_I6_set_to_clear", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_IN_RANGEN_PASSES_I6_set_to_clear", id, value );

    /* (0x0000007c bits 6) field IN_RANGEN_PASSES_I6 of register PMC_PM20_82_24_REG_INT_REG */
    t8_reg_INT_REG_action_on_write_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              PM20_82_24_REG_INT_REG_BIT_IN_RANGEN_PASSES_I6_MSK,
                                              PM20_82_24_REG_INT_REG_BIT_IN_RANGEN_PASSES_I6_OFF,
                                              value);
}

static INLINE UINT32 t8_field_IN_RANGEN_PASSES_I6_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_IN_RANGEN_PASSES_I6_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_IN_RANGEN_PASSES_I6_get", id, 2);
    /* (0x0000007c bits 6) field IN_RANGEN_PASSES_I6 of register PMC_PM20_82_24_REG_INT_REG */
    reg_value = t8_reg_INT_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_INT_REG_BIT_IN_RANGEN_PASSES_I6_MSK) >> PM20_82_24_REG_INT_REG_BIT_IN_RANGEN_PASSES_I6_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_IN_RANGEN_PASSES_I6_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_IN_RANGEN_PASSES_I6_poll( t8_buffer_t *b_ptr,
                                                                      t8_handle_t *h_ptr,
                                                                      UINT32 id,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_IN_RANGEN_PASSES_I6_poll( t8_buffer_t *b_ptr,
                                                                      t8_handle_t *h_ptr,
                                                                      UINT32 id,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_IN_RANGEN_PASSES_I6_poll", id, value );

    /* (0x0000007c bits 6) field IN_RANGEN_PASSES_I6 of register PMC_PM20_82_24_REG_INT_REG */
    return t8_reg_INT_REG_poll( b_ptr,
                                h_ptr,
                                id,
                                PM20_82_24_REG_INT_REG_BIT_IN_RANGEN_PASSES_I6_MSK,
                                (value<<PM20_82_24_REG_INT_REG_BIT_IN_RANGEN_PASSES_I6_OFF),
                                cmp,
                                max_count,
                                num_failed_polls,
                                delay_between_polls_in_microseconds);
}

static INLINE void t8_field_PLL_LOCK_GAIN_I5_set_to_clear( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PLL_LOCK_GAIN_I5_set_to_clear( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLL_LOCK_GAIN_I5_set_to_clear", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PLL_LOCK_GAIN_I5_set_to_clear", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PLL_LOCK_GAIN_I5_set_to_clear", id, value );

    /* (0x0000007c bits 5) field PLL_LOCK_GAIN_I5 of register PMC_PM20_82_24_REG_INT_REG */
    t8_reg_INT_REG_action_on_write_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              PM20_82_24_REG_INT_REG_BIT_PLL_LOCK_GAIN_I5_MSK,
                                              PM20_82_24_REG_INT_REG_BIT_PLL_LOCK_GAIN_I5_OFF,
                                              value);
}

static INLINE UINT32 t8_field_PLL_LOCK_GAIN_I5_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PLL_LOCK_GAIN_I5_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLL_LOCK_GAIN_I5_get", id, 2);
    /* (0x0000007c bits 5) field PLL_LOCK_GAIN_I5 of register PMC_PM20_82_24_REG_INT_REG */
    reg_value = t8_reg_INT_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_INT_REG_BIT_PLL_LOCK_GAIN_I5_MSK) >> PM20_82_24_REG_INT_REG_BIT_PLL_LOCK_GAIN_I5_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PLL_LOCK_GAIN_I5_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_PLL_LOCK_GAIN_I5_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_PLL_LOCK_GAIN_I5_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_PLL_LOCK_GAIN_I5_poll", id, value );

    /* (0x0000007c bits 5) field PLL_LOCK_GAIN_I5 of register PMC_PM20_82_24_REG_INT_REG */
    return t8_reg_INT_REG_poll( b_ptr,
                                h_ptr,
                                id,
                                PM20_82_24_REG_INT_REG_BIT_PLL_LOCK_GAIN_I5_MSK,
                                (value<<PM20_82_24_REG_INT_REG_BIT_PLL_LOCK_GAIN_I5_OFF),
                                cmp,
                                max_count,
                                num_failed_polls,
                                delay_between_polls_in_microseconds);
}

static INLINE void t8_field_PROG_REF_DONE_I4_set_to_clear( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PROG_REF_DONE_I4_set_to_clear( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PROG_REF_DONE_I4_set_to_clear", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PROG_REF_DONE_I4_set_to_clear", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PROG_REF_DONE_I4_set_to_clear", id, value );

    /* (0x0000007c bits 4) field PROG_REF_DONE_I4 of register PMC_PM20_82_24_REG_INT_REG */
    t8_reg_INT_REG_action_on_write_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              PM20_82_24_REG_INT_REG_BIT_PROG_REF_DONE_I4_MSK,
                                              PM20_82_24_REG_INT_REG_BIT_PROG_REF_DONE_I4_OFF,
                                              value);
}

static INLINE UINT32 t8_field_PROG_REF_DONE_I4_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PROG_REF_DONE_I4_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PROG_REF_DONE_I4_get", id, 2);
    /* (0x0000007c bits 4) field PROG_REF_DONE_I4 of register PMC_PM20_82_24_REG_INT_REG */
    reg_value = t8_reg_INT_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_INT_REG_BIT_PROG_REF_DONE_I4_MSK) >> PM20_82_24_REG_INT_REG_BIT_PROG_REF_DONE_I4_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PROG_REF_DONE_I4_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_PROG_REF_DONE_I4_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_PROG_REF_DONE_I4_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_PROG_REF_DONE_I4_poll", id, value );

    /* (0x0000007c bits 4) field PROG_REF_DONE_I4 of register PMC_PM20_82_24_REG_INT_REG */
    return t8_reg_INT_REG_poll( b_ptr,
                                h_ptr,
                                id,
                                PM20_82_24_REG_INT_REG_BIT_PROG_REF_DONE_I4_MSK,
                                (value<<PM20_82_24_REG_INT_REG_BIT_PROG_REF_DONE_I4_OFF),
                                cmp,
                                max_count,
                                num_failed_polls,
                                delay_between_polls_in_microseconds);
}

static INLINE void t8_field_CALIB_DONE_I3_set_to_clear( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CALIB_DONE_I3_set_to_clear( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CALIB_DONE_I3_set_to_clear", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CALIB_DONE_I3_set_to_clear", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CALIB_DONE_I3_set_to_clear", id, value );

    /* (0x0000007c bits 3) field CALIB_DONE_I3 of register PMC_PM20_82_24_REG_INT_REG */
    t8_reg_INT_REG_action_on_write_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              PM20_82_24_REG_INT_REG_BIT_CALIB_DONE_I3_MSK,
                                              PM20_82_24_REG_INT_REG_BIT_CALIB_DONE_I3_OFF,
                                              value);
}

static INLINE UINT32 t8_field_CALIB_DONE_I3_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CALIB_DONE_I3_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CALIB_DONE_I3_get", id, 2);
    /* (0x0000007c bits 3) field CALIB_DONE_I3 of register PMC_PM20_82_24_REG_INT_REG */
    reg_value = t8_reg_INT_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_INT_REG_BIT_CALIB_DONE_I3_MSK) >> PM20_82_24_REG_INT_REG_BIT_CALIB_DONE_I3_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CALIB_DONE_I3_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_CALIB_DONE_I3_poll( t8_buffer_t *b_ptr,
                                                                t8_handle_t *h_ptr,
                                                                UINT32 id,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_CALIB_DONE_I3_poll( t8_buffer_t *b_ptr,
                                                                t8_handle_t *h_ptr,
                                                                UINT32 id,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_CALIB_DONE_I3_poll", id, value );

    /* (0x0000007c bits 3) field CALIB_DONE_I3 of register PMC_PM20_82_24_REG_INT_REG */
    return t8_reg_INT_REG_poll( b_ptr,
                                h_ptr,
                                id,
                                PM20_82_24_REG_INT_REG_BIT_CALIB_DONE_I3_MSK,
                                (value<<PM20_82_24_REG_INT_REG_BIT_CALIB_DONE_I3_OFF),
                                cmp,
                                max_count,
                                num_failed_polls,
                                delay_between_polls_in_microseconds);
}

static INLINE void t8_field_PLL_LOCK_LOSS_I0_set_to_clear( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PLL_LOCK_LOSS_I0_set_to_clear( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLL_LOCK_LOSS_I0_set_to_clear", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PLL_LOCK_LOSS_I0_set_to_clear", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PLL_LOCK_LOSS_I0_set_to_clear", id, value );

    /* (0x0000007c bits 0) field PLL_LOCK_LOSS_I0 of register PMC_PM20_82_24_REG_INT_REG */
    t8_reg_INT_REG_action_on_write_field_set( b_ptr,
                                              h_ptr,
                                              id,
                                              PM20_82_24_REG_INT_REG_BIT_PLL_LOCK_LOSS_I0_MSK,
                                              PM20_82_24_REG_INT_REG_BIT_PLL_LOCK_LOSS_I0_OFF,
                                              value);
}

static INLINE UINT32 t8_field_PLL_LOCK_LOSS_I0_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PLL_LOCK_LOSS_I0_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLL_LOCK_LOSS_I0_get", id, 2);
    /* (0x0000007c bits 0) field PLL_LOCK_LOSS_I0 of register PMC_PM20_82_24_REG_INT_REG */
    reg_value = t8_reg_INT_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_INT_REG_BIT_PLL_LOCK_LOSS_I0_MSK) >> PM20_82_24_REG_INT_REG_BIT_PLL_LOCK_LOSS_I0_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PLL_LOCK_LOSS_I0_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_PLL_LOCK_LOSS_I0_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_PLL_LOCK_LOSS_I0_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_PLL_LOCK_LOSS_I0_poll", id, value );

    /* (0x0000007c bits 0) field PLL_LOCK_LOSS_I0 of register PMC_PM20_82_24_REG_INT_REG */
    return t8_reg_INT_REG_poll( b_ptr,
                                h_ptr,
                                id,
                                PM20_82_24_REG_INT_REG_BIT_PLL_LOCK_LOSS_I0_MSK,
                                (value<<PM20_82_24_REG_INT_REG_BIT_PLL_LOCK_LOSS_I0_OFF),
                                cmp,
                                max_count,
                                num_failed_polls,
                                delay_between_polls_in_microseconds);
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_enable
 * ==================================================================================
 */
static INLINE void t8_field_CALIB_PASS_E19_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CALIB_PASS_E19_set( t8_buffer_t *b_ptr,
                                                t8_handle_t *h_ptr,
                                                UINT32 id,
                                                UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CALIB_PASS_E19_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CALIB_PASS_E19_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CALIB_PASS_E19_set", id, value );

    /* (0x00000078 bits 19) field CALIB_PASS_E19 of register PMC_PM20_82_24_REG_IE_REG */
    t8_reg_IE_REG_field_set( b_ptr,
                             h_ptr,
                             id,
                             PM20_82_24_REG_IE_REG_BIT_CALIB_PASS_E19_MSK,
                             PM20_82_24_REG_IE_REG_BIT_CALIB_PASS_E19_OFF,
                             value);
}

static INLINE UINT32 t8_field_CALIB_PASS_E19_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CALIB_PASS_E19_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CALIB_PASS_E19_get", id, 2);
    /* (0x00000078 bits 19) field CALIB_PASS_E19 of register PMC_PM20_82_24_REG_IE_REG */
    reg_value = t8_reg_IE_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IE_REG_BIT_CALIB_PASS_E19_MSK) >> PM20_82_24_REG_IE_REG_BIT_CALIB_PASS_E19_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CALIB_PASS_E19_get", id, value );

    return value;
}
static INLINE void t8_field_PATT_MON_ERR_E18_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PATT_MON_ERR_E18_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PATT_MON_ERR_E18_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PATT_MON_ERR_E18_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PATT_MON_ERR_E18_set", id, value );

    /* (0x00000078 bits 18) field PATT_MON_ERR_E18 of register PMC_PM20_82_24_REG_IE_REG */
    t8_reg_IE_REG_field_set( b_ptr,
                             h_ptr,
                             id,
                             PM20_82_24_REG_IE_REG_BIT_PATT_MON_ERR_E18_MSK,
                             PM20_82_24_REG_IE_REG_BIT_PATT_MON_ERR_E18_OFF,
                             value);
}

static INLINE UINT32 t8_field_PATT_MON_ERR_E18_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PATT_MON_ERR_E18_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PATT_MON_ERR_E18_get", id, 2);
    /* (0x00000078 bits 18) field PATT_MON_ERR_E18 of register PMC_PM20_82_24_REG_IE_REG */
    reg_value = t8_reg_IE_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IE_REG_BIT_PATT_MON_ERR_E18_MSK) >> PM20_82_24_REG_IE_REG_BIT_PATT_MON_ERR_E18_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PATT_MON_ERR_E18_get", id, value );

    return value;
}
static INLINE void t8_field_ADC_BIST_ERR_E17_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADC_BIST_ERR_E17_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_BIST_ERR_E17_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADC_BIST_ERR_E17_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADC_BIST_ERR_E17_set", id, value );

    /* (0x00000078 bits 17) field ADC_BIST_ERR_E17 of register PMC_PM20_82_24_REG_IE_REG */
    t8_reg_IE_REG_field_set( b_ptr,
                             h_ptr,
                             id,
                             PM20_82_24_REG_IE_REG_BIT_ADC_BIST_ERR_E17_MSK,
                             PM20_82_24_REG_IE_REG_BIT_ADC_BIST_ERR_E17_OFF,
                             value);
}

static INLINE UINT32 t8_field_ADC_BIST_ERR_E17_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADC_BIST_ERR_E17_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_BIST_ERR_E17_get", id, 2);
    /* (0x00000078 bits 17) field ADC_BIST_ERR_E17 of register PMC_PM20_82_24_REG_IE_REG */
    reg_value = t8_reg_IE_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IE_REG_BIT_ADC_BIST_ERR_E17_MSK) >> PM20_82_24_REG_IE_REG_BIT_ADC_BIST_ERR_E17_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADC_BIST_ERR_E17_get", id, value );

    return value;
}
static INLINE void t8_field_ADC_BIST_DONE_E16_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADC_BIST_DONE_E16_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_BIST_DONE_E16_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADC_BIST_DONE_E16_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADC_BIST_DONE_E16_set", id, value );

    /* (0x00000078 bits 16) field ADC_BIST_DONE_E16 of register PMC_PM20_82_24_REG_IE_REG */
    t8_reg_IE_REG_field_set( b_ptr,
                             h_ptr,
                             id,
                             PM20_82_24_REG_IE_REG_BIT_ADC_BIST_DONE_E16_MSK,
                             PM20_82_24_REG_IE_REG_BIT_ADC_BIST_DONE_E16_OFF,
                             value);
}

static INLINE UINT32 t8_field_ADC_BIST_DONE_E16_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADC_BIST_DONE_E16_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_BIST_DONE_E16_get", id, 2);
    /* (0x00000078 bits 16) field ADC_BIST_DONE_E16 of register PMC_PM20_82_24_REG_IE_REG */
    reg_value = t8_reg_IE_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IE_REG_BIT_ADC_BIST_DONE_E16_MSK) >> PM20_82_24_REG_IE_REG_BIT_ADC_BIST_DONE_E16_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADC_BIST_DONE_E16_get", id, value );

    return value;
}
static INLINE void t8_field_ADCOC_FSM_ERR_E15_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_ADCOC_FSM_ERR_E15_set( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id,
                                                   UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_FSM_ERR_E15_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_ADCOC_FSM_ERR_E15_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_ADCOC_FSM_ERR_E15_set", id, value );

    /* (0x00000078 bits 15) field ADCOC_FSM_ERR_E15 of register PMC_PM20_82_24_REG_IE_REG */
    t8_reg_IE_REG_field_set( b_ptr,
                             h_ptr,
                             id,
                             PM20_82_24_REG_IE_REG_BIT_ADCOC_FSM_ERR_E15_MSK,
                             PM20_82_24_REG_IE_REG_BIT_ADCOC_FSM_ERR_E15_OFF,
                             value);
}

static INLINE UINT32 t8_field_ADCOC_FSM_ERR_E15_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_FSM_ERR_E15_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_FSM_ERR_E15_get", id, 2);
    /* (0x00000078 bits 15) field ADCOC_FSM_ERR_E15 of register PMC_PM20_82_24_REG_IE_REG */
    reg_value = t8_reg_IE_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IE_REG_BIT_ADCOC_FSM_ERR_E15_MSK) >> PM20_82_24_REG_IE_REG_BIT_ADCOC_FSM_ERR_E15_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_FSM_ERR_E15_get", id, value );

    return value;
}
static INLINE void t8_field_DLOS_E14_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DLOS_E14_set( t8_buffer_t *b_ptr,
                                          t8_handle_t *h_ptr,
                                          UINT32 id,
                                          UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DLOS_E14_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DLOS_E14_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DLOS_E14_set", id, value );

    /* (0x00000078 bits 14) field DLOS_E14 of register PMC_PM20_82_24_REG_IE_REG */
    t8_reg_IE_REG_field_set( b_ptr,
                             h_ptr,
                             id,
                             PM20_82_24_REG_IE_REG_BIT_DLOS_E14_MSK,
                             PM20_82_24_REG_IE_REG_BIT_DLOS_E14_OFF,
                             value);
}

static INLINE UINT32 t8_field_DLOS_E14_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DLOS_E14_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DLOS_E14_get", id, 2);
    /* (0x00000078 bits 14) field DLOS_E14 of register PMC_PM20_82_24_REG_IE_REG */
    reg_value = t8_reg_IE_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IE_REG_BIT_DLOS_E14_MSK) >> PM20_82_24_REG_IE_REG_BIT_DLOS_E14_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DLOS_E14_get", id, value );

    return value;
}
static INLINE void t8_field_DIV_CLK_DEAD_E9_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_DIV_CLK_DEAD_E9_set( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id,
                                                 UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DIV_CLK_DEAD_E9_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_DIV_CLK_DEAD_E9_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_DIV_CLK_DEAD_E9_set", id, value );

    /* (0x00000078 bits 9) field DIV_CLK_DEAD_E9 of register PMC_PM20_82_24_REG_IE_REG */
    t8_reg_IE_REG_field_set( b_ptr,
                             h_ptr,
                             id,
                             PM20_82_24_REG_IE_REG_BIT_DIV_CLK_DEAD_E9_MSK,
                             PM20_82_24_REG_IE_REG_BIT_DIV_CLK_DEAD_E9_OFF,
                             value);
}

static INLINE UINT32 t8_field_DIV_CLK_DEAD_E9_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DIV_CLK_DEAD_E9_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DIV_CLK_DEAD_E9_get", id, 2);
    /* (0x00000078 bits 9) field DIV_CLK_DEAD_E9 of register PMC_PM20_82_24_REG_IE_REG */
    reg_value = t8_reg_IE_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IE_REG_BIT_DIV_CLK_DEAD_E9_MSK) >> PM20_82_24_REG_IE_REG_BIT_DIV_CLK_DEAD_E9_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DIV_CLK_DEAD_E9_get", id, value );

    return value;
}
static INLINE void t8_field_IN_RANGEN_FAILS_E7_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_IN_RANGEN_FAILS_E7_set( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_IN_RANGEN_FAILS_E7_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_IN_RANGEN_FAILS_E7_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_IN_RANGEN_FAILS_E7_set", id, value );

    /* (0x00000078 bits 7) field IN_RANGEN_FAILS_E7 of register PMC_PM20_82_24_REG_IE_REG */
    t8_reg_IE_REG_field_set( b_ptr,
                             h_ptr,
                             id,
                             PM20_82_24_REG_IE_REG_BIT_IN_RANGEN_FAILS_E7_MSK,
                             PM20_82_24_REG_IE_REG_BIT_IN_RANGEN_FAILS_E7_OFF,
                             value);
}

static INLINE UINT32 t8_field_IN_RANGEN_FAILS_E7_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_IN_RANGEN_FAILS_E7_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_IN_RANGEN_FAILS_E7_get", id, 2);
    /* (0x00000078 bits 7) field IN_RANGEN_FAILS_E7 of register PMC_PM20_82_24_REG_IE_REG */
    reg_value = t8_reg_IE_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IE_REG_BIT_IN_RANGEN_FAILS_E7_MSK) >> PM20_82_24_REG_IE_REG_BIT_IN_RANGEN_FAILS_E7_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_IN_RANGEN_FAILS_E7_get", id, value );

    return value;
}
static INLINE void t8_field_IN_RANGEN_PASSES_E6_set( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_IN_RANGEN_PASSES_E6_set( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_IN_RANGEN_PASSES_E6_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_IN_RANGEN_PASSES_E6_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_IN_RANGEN_PASSES_E6_set", id, value );

    /* (0x00000078 bits 6) field IN_RANGEN_PASSES_E6 of register PMC_PM20_82_24_REG_IE_REG */
    t8_reg_IE_REG_field_set( b_ptr,
                             h_ptr,
                             id,
                             PM20_82_24_REG_IE_REG_BIT_IN_RANGEN_PASSES_E6_MSK,
                             PM20_82_24_REG_IE_REG_BIT_IN_RANGEN_PASSES_E6_OFF,
                             value);
}

static INLINE UINT32 t8_field_IN_RANGEN_PASSES_E6_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_IN_RANGEN_PASSES_E6_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_IN_RANGEN_PASSES_E6_get", id, 2);
    /* (0x00000078 bits 6) field IN_RANGEN_PASSES_E6 of register PMC_PM20_82_24_REG_IE_REG */
    reg_value = t8_reg_IE_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IE_REG_BIT_IN_RANGEN_PASSES_E6_MSK) >> PM20_82_24_REG_IE_REG_BIT_IN_RANGEN_PASSES_E6_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_IN_RANGEN_PASSES_E6_get", id, value );

    return value;
}
static INLINE void t8_field_PLL_LOCK_GAIN_E5_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PLL_LOCK_GAIN_E5_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLL_LOCK_GAIN_E5_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PLL_LOCK_GAIN_E5_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PLL_LOCK_GAIN_E5_set", id, value );

    /* (0x00000078 bits 5) field PLL_LOCK_GAIN_E5 of register PMC_PM20_82_24_REG_IE_REG */
    t8_reg_IE_REG_field_set( b_ptr,
                             h_ptr,
                             id,
                             PM20_82_24_REG_IE_REG_BIT_PLL_LOCK_GAIN_E5_MSK,
                             PM20_82_24_REG_IE_REG_BIT_PLL_LOCK_GAIN_E5_OFF,
                             value);
}

static INLINE UINT32 t8_field_PLL_LOCK_GAIN_E5_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PLL_LOCK_GAIN_E5_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLL_LOCK_GAIN_E5_get", id, 2);
    /* (0x00000078 bits 5) field PLL_LOCK_GAIN_E5 of register PMC_PM20_82_24_REG_IE_REG */
    reg_value = t8_reg_IE_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IE_REG_BIT_PLL_LOCK_GAIN_E5_MSK) >> PM20_82_24_REG_IE_REG_BIT_PLL_LOCK_GAIN_E5_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PLL_LOCK_GAIN_E5_get", id, value );

    return value;
}
static INLINE void t8_field_PROG_REF_DONE_E4_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PROG_REF_DONE_E4_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PROG_REF_DONE_E4_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PROG_REF_DONE_E4_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PROG_REF_DONE_E4_set", id, value );

    /* (0x00000078 bits 4) field PROG_REF_DONE_E4 of register PMC_PM20_82_24_REG_IE_REG */
    t8_reg_IE_REG_field_set( b_ptr,
                             h_ptr,
                             id,
                             PM20_82_24_REG_IE_REG_BIT_PROG_REF_DONE_E4_MSK,
                             PM20_82_24_REG_IE_REG_BIT_PROG_REF_DONE_E4_OFF,
                             value);
}

static INLINE UINT32 t8_field_PROG_REF_DONE_E4_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PROG_REF_DONE_E4_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PROG_REF_DONE_E4_get", id, 2);
    /* (0x00000078 bits 4) field PROG_REF_DONE_E4 of register PMC_PM20_82_24_REG_IE_REG */
    reg_value = t8_reg_IE_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IE_REG_BIT_PROG_REF_DONE_E4_MSK) >> PM20_82_24_REG_IE_REG_BIT_PROG_REF_DONE_E4_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PROG_REF_DONE_E4_get", id, value );

    return value;
}
static INLINE void t8_field_CALIB_DONE_E3_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_CALIB_DONE_E3_set( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CALIB_DONE_E3_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_CALIB_DONE_E3_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_CALIB_DONE_E3_set", id, value );

    /* (0x00000078 bits 3) field CALIB_DONE_E3 of register PMC_PM20_82_24_REG_IE_REG */
    t8_reg_IE_REG_field_set( b_ptr,
                             h_ptr,
                             id,
                             PM20_82_24_REG_IE_REG_BIT_CALIB_DONE_E3_MSK,
                             PM20_82_24_REG_IE_REG_BIT_CALIB_DONE_E3_OFF,
                             value);
}

static INLINE UINT32 t8_field_CALIB_DONE_E3_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CALIB_DONE_E3_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CALIB_DONE_E3_get", id, 2);
    /* (0x00000078 bits 3) field CALIB_DONE_E3 of register PMC_PM20_82_24_REG_IE_REG */
    reg_value = t8_reg_IE_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IE_REG_BIT_CALIB_DONE_E3_MSK) >> PM20_82_24_REG_IE_REG_BIT_CALIB_DONE_E3_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CALIB_DONE_E3_get", id, value );

    return value;
}
static INLINE void t8_field_PLL_LOCK_LOSS_E0_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_field_PLL_LOCK_LOSS_E0_set( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id,
                                                  UINT32 value )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLL_LOCK_LOSS_E0_set", id, 2);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "t8_field_PLL_LOCK_LOSS_E0_set", value, 1);
    IOLOG( "%s <= id=%d 0x%08x", "t8_field_PLL_LOCK_LOSS_E0_set", id, value );

    /* (0x00000078 bits 0) field PLL_LOCK_LOSS_E0 of register PMC_PM20_82_24_REG_IE_REG */
    t8_reg_IE_REG_field_set( b_ptr,
                             h_ptr,
                             id,
                             PM20_82_24_REG_IE_REG_BIT_PLL_LOCK_LOSS_E0_MSK,
                             PM20_82_24_REG_IE_REG_BIT_PLL_LOCK_LOSS_E0_OFF,
                             value);
}

static INLINE UINT32 t8_field_PLL_LOCK_LOSS_E0_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PLL_LOCK_LOSS_E0_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLL_LOCK_LOSS_E0_get", id, 2);
    /* (0x00000078 bits 0) field PLL_LOCK_LOSS_E0 of register PMC_PM20_82_24_REG_IE_REG */
    reg_value = t8_reg_IE_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IE_REG_BIT_PLL_LOCK_LOSS_E0_MSK) >> PM20_82_24_REG_IE_REG_BIT_PLL_LOCK_LOSS_E0_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PLL_LOCK_LOSS_E0_get", id, value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_value
 * ==================================================================================
 */
static INLINE UINT32 t8_field_CALIB_PASS_V19_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CALIB_PASS_V19_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CALIB_PASS_V19_get", id, 2);
    /* (0x00000080 bits 19) field CALIB_PASS_V19 of register PMC_PM20_82_24_REG_IV_REG */
    reg_value = t8_reg_IV_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IV_REG_BIT_CALIB_PASS_V19_MSK) >> PM20_82_24_REG_IV_REG_BIT_CALIB_PASS_V19_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CALIB_PASS_V19_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_CALIB_PASS_V19_poll( t8_buffer_t *b_ptr,
                                                                 t8_handle_t *h_ptr,
                                                                 UINT32 id,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_CALIB_PASS_V19_poll( t8_buffer_t *b_ptr,
                                                                 t8_handle_t *h_ptr,
                                                                 UINT32 id,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_CALIB_PASS_V19_poll", id, value );

    /* (0x00000080 bits 19) field CALIB_PASS_V19 of register PMC_PM20_82_24_REG_IV_REG */
    return t8_reg_IV_REG_poll( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_IV_REG_BIT_CALIB_PASS_V19_MSK,
                               (value<<PM20_82_24_REG_IV_REG_BIT_CALIB_PASS_V19_OFF),
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);
}

static INLINE UINT32 t8_field_PATT_MON_ERR_V18_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PATT_MON_ERR_V18_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PATT_MON_ERR_V18_get", id, 2);
    /* (0x00000080 bits 18) field PATT_MON_ERR_V18 of register PMC_PM20_82_24_REG_IV_REG */
    reg_value = t8_reg_IV_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IV_REG_BIT_PATT_MON_ERR_V18_MSK) >> PM20_82_24_REG_IV_REG_BIT_PATT_MON_ERR_V18_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PATT_MON_ERR_V18_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_PATT_MON_ERR_V18_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_PATT_MON_ERR_V18_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_PATT_MON_ERR_V18_poll", id, value );

    /* (0x00000080 bits 18) field PATT_MON_ERR_V18 of register PMC_PM20_82_24_REG_IV_REG */
    return t8_reg_IV_REG_poll( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_IV_REG_BIT_PATT_MON_ERR_V18_MSK,
                               (value<<PM20_82_24_REG_IV_REG_BIT_PATT_MON_ERR_V18_OFF),
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);
}

static INLINE UINT32 t8_field_ADC_BIST_ERR_V17_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADC_BIST_ERR_V17_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_BIST_ERR_V17_get", id, 2);
    /* (0x00000080 bits 17) field ADC_BIST_ERR_V17 of register PMC_PM20_82_24_REG_IV_REG */
    reg_value = t8_reg_IV_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IV_REG_BIT_ADC_BIST_ERR_V17_MSK) >> PM20_82_24_REG_IV_REG_BIT_ADC_BIST_ERR_V17_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADC_BIST_ERR_V17_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_ADC_BIST_ERR_V17_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_ADC_BIST_ERR_V17_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_ADC_BIST_ERR_V17_poll", id, value );

    /* (0x00000080 bits 17) field ADC_BIST_ERR_V17 of register PMC_PM20_82_24_REG_IV_REG */
    return t8_reg_IV_REG_poll( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_IV_REG_BIT_ADC_BIST_ERR_V17_MSK,
                               (value<<PM20_82_24_REG_IV_REG_BIT_ADC_BIST_ERR_V17_OFF),
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);
}

static INLINE UINT32 t8_field_ADC_BIST_DONE_V16_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADC_BIST_DONE_V16_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_BIST_DONE_V16_get", id, 2);
    /* (0x00000080 bits 16) field ADC_BIST_DONE_V16 of register PMC_PM20_82_24_REG_IV_REG */
    reg_value = t8_reg_IV_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IV_REG_BIT_ADC_BIST_DONE_V16_MSK) >> PM20_82_24_REG_IV_REG_BIT_ADC_BIST_DONE_V16_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADC_BIST_DONE_V16_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_ADC_BIST_DONE_V16_poll( t8_buffer_t *b_ptr,
                                                                    t8_handle_t *h_ptr,
                                                                    UINT32 id,
                                                                    UINT32 value,
                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                    UINT32 max_count,
                                                                    UINT32 *num_failed_polls,
                                                                    UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_ADC_BIST_DONE_V16_poll( t8_buffer_t *b_ptr,
                                                                    t8_handle_t *h_ptr,
                                                                    UINT32 id,
                                                                    UINT32 value,
                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                    UINT32 max_count,
                                                                    UINT32 *num_failed_polls,
                                                                    UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_ADC_BIST_DONE_V16_poll", id, value );

    /* (0x00000080 bits 16) field ADC_BIST_DONE_V16 of register PMC_PM20_82_24_REG_IV_REG */
    return t8_reg_IV_REG_poll( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_IV_REG_BIT_ADC_BIST_DONE_V16_MSK,
                               (value<<PM20_82_24_REG_IV_REG_BIT_ADC_BIST_DONE_V16_OFF),
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);
}

static INLINE UINT32 t8_field_ADCOC_FSM_ERR_V15_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_FSM_ERR_V15_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_FSM_ERR_V15_get", id, 2);
    /* (0x00000080 bits 15) field ADCOC_FSM_ERR_V15 of register PMC_PM20_82_24_REG_IV_REG */
    reg_value = t8_reg_IV_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IV_REG_BIT_ADCOC_FSM_ERR_V15_MSK) >> PM20_82_24_REG_IV_REG_BIT_ADCOC_FSM_ERR_V15_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_FSM_ERR_V15_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_ADCOC_FSM_ERR_V15_poll( t8_buffer_t *b_ptr,
                                                                    t8_handle_t *h_ptr,
                                                                    UINT32 id,
                                                                    UINT32 value,
                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                    UINT32 max_count,
                                                                    UINT32 *num_failed_polls,
                                                                    UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_ADCOC_FSM_ERR_V15_poll( t8_buffer_t *b_ptr,
                                                                    t8_handle_t *h_ptr,
                                                                    UINT32 id,
                                                                    UINT32 value,
                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                    UINT32 max_count,
                                                                    UINT32 *num_failed_polls,
                                                                    UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_ADCOC_FSM_ERR_V15_poll", id, value );

    /* (0x00000080 bits 15) field ADCOC_FSM_ERR_V15 of register PMC_PM20_82_24_REG_IV_REG */
    return t8_reg_IV_REG_poll( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_IV_REG_BIT_ADCOC_FSM_ERR_V15_MSK,
                               (value<<PM20_82_24_REG_IV_REG_BIT_ADCOC_FSM_ERR_V15_OFF),
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);
}

static INLINE UINT32 t8_field_DLOS_V14_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DLOS_V14_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DLOS_V14_get", id, 2);
    /* (0x00000080 bits 14) field DLOS_V14 of register PMC_PM20_82_24_REG_IV_REG */
    reg_value = t8_reg_IV_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IV_REG_BIT_DLOS_V14_MSK) >> PM20_82_24_REG_IV_REG_BIT_DLOS_V14_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DLOS_V14_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_DLOS_V14_poll( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value,
                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                           UINT32 max_count,
                                                           UINT32 *num_failed_polls,
                                                           UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_DLOS_V14_poll( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id,
                                                           UINT32 value,
                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                           UINT32 max_count,
                                                           UINT32 *num_failed_polls,
                                                           UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_DLOS_V14_poll", id, value );

    /* (0x00000080 bits 14) field DLOS_V14 of register PMC_PM20_82_24_REG_IV_REG */
    return t8_reg_IV_REG_poll( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_IV_REG_BIT_DLOS_V14_MSK,
                               (value<<PM20_82_24_REG_IV_REG_BIT_DLOS_V14_OFF),
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);
}

static INLINE UINT32 t8_field_DIV_CLK_DEAD_V9_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_DIV_CLK_DEAD_V9_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_DIV_CLK_DEAD_V9_get", id, 2);
    /* (0x00000080 bits 9) field DIV_CLK_DEAD_V9 of register PMC_PM20_82_24_REG_IV_REG */
    reg_value = t8_reg_IV_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IV_REG_BIT_DIV_CLK_DEAD_V9_MSK) >> PM20_82_24_REG_IV_REG_BIT_DIV_CLK_DEAD_V9_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_DIV_CLK_DEAD_V9_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_DIV_CLK_DEAD_V9_poll( t8_buffer_t *b_ptr,
                                                                  t8_handle_t *h_ptr,
                                                                  UINT32 id,
                                                                  UINT32 value,
                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                  UINT32 max_count,
                                                                  UINT32 *num_failed_polls,
                                                                  UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_DIV_CLK_DEAD_V9_poll( t8_buffer_t *b_ptr,
                                                                  t8_handle_t *h_ptr,
                                                                  UINT32 id,
                                                                  UINT32 value,
                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                  UINT32 max_count,
                                                                  UINT32 *num_failed_polls,
                                                                  UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_DIV_CLK_DEAD_V9_poll", id, value );

    /* (0x00000080 bits 9) field DIV_CLK_DEAD_V9 of register PMC_PM20_82_24_REG_IV_REG */
    return t8_reg_IV_REG_poll( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_IV_REG_BIT_DIV_CLK_DEAD_V9_MSK,
                               (value<<PM20_82_24_REG_IV_REG_BIT_DIV_CLK_DEAD_V9_OFF),
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);
}

static INLINE UINT32 t8_field_IN_RANGEN_FAILS_V7_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_IN_RANGEN_FAILS_V7_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_IN_RANGEN_FAILS_V7_get", id, 2);
    /* (0x00000080 bits 7) field IN_RANGEN_FAILS_V7 of register PMC_PM20_82_24_REG_IV_REG */
    reg_value = t8_reg_IV_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IV_REG_BIT_IN_RANGEN_FAILS_V7_MSK) >> PM20_82_24_REG_IV_REG_BIT_IN_RANGEN_FAILS_V7_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_IN_RANGEN_FAILS_V7_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_IN_RANGEN_FAILS_V7_poll( t8_buffer_t *b_ptr,
                                                                     t8_handle_t *h_ptr,
                                                                     UINT32 id,
                                                                     UINT32 value,
                                                                     PMC_POLL_COMPARISON_TYPE cmp,
                                                                     UINT32 max_count,
                                                                     UINT32 *num_failed_polls,
                                                                     UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_IN_RANGEN_FAILS_V7_poll( t8_buffer_t *b_ptr,
                                                                     t8_handle_t *h_ptr,
                                                                     UINT32 id,
                                                                     UINT32 value,
                                                                     PMC_POLL_COMPARISON_TYPE cmp,
                                                                     UINT32 max_count,
                                                                     UINT32 *num_failed_polls,
                                                                     UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_IN_RANGEN_FAILS_V7_poll", id, value );

    /* (0x00000080 bits 7) field IN_RANGEN_FAILS_V7 of register PMC_PM20_82_24_REG_IV_REG */
    return t8_reg_IV_REG_poll( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_IV_REG_BIT_IN_RANGEN_FAILS_V7_MSK,
                               (value<<PM20_82_24_REG_IV_REG_BIT_IN_RANGEN_FAILS_V7_OFF),
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);
}

static INLINE UINT32 t8_field_IN_RANGEN_PASSES_V6_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_IN_RANGEN_PASSES_V6_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_IN_RANGEN_PASSES_V6_get", id, 2);
    /* (0x00000080 bits 6) field IN_RANGEN_PASSES_V6 of register PMC_PM20_82_24_REG_IV_REG */
    reg_value = t8_reg_IV_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IV_REG_BIT_IN_RANGEN_PASSES_V6_MSK) >> PM20_82_24_REG_IV_REG_BIT_IN_RANGEN_PASSES_V6_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_IN_RANGEN_PASSES_V6_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_IN_RANGEN_PASSES_V6_poll( t8_buffer_t *b_ptr,
                                                                      t8_handle_t *h_ptr,
                                                                      UINT32 id,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_IN_RANGEN_PASSES_V6_poll( t8_buffer_t *b_ptr,
                                                                      t8_handle_t *h_ptr,
                                                                      UINT32 id,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_IN_RANGEN_PASSES_V6_poll", id, value );

    /* (0x00000080 bits 6) field IN_RANGEN_PASSES_V6 of register PMC_PM20_82_24_REG_IV_REG */
    return t8_reg_IV_REG_poll( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_IV_REG_BIT_IN_RANGEN_PASSES_V6_MSK,
                               (value<<PM20_82_24_REG_IV_REG_BIT_IN_RANGEN_PASSES_V6_OFF),
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);
}

static INLINE UINT32 t8_field_PLL_LOCK_GAIN_V5_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PLL_LOCK_GAIN_V5_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLL_LOCK_GAIN_V5_get", id, 2);
    /* (0x00000080 bits 5) field PLL_LOCK_GAIN_V5 of register PMC_PM20_82_24_REG_IV_REG */
    reg_value = t8_reg_IV_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IV_REG_BIT_PLL_LOCK_GAIN_V5_MSK) >> PM20_82_24_REG_IV_REG_BIT_PLL_LOCK_GAIN_V5_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PLL_LOCK_GAIN_V5_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_PLL_LOCK_GAIN_V5_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_PLL_LOCK_GAIN_V5_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_PLL_LOCK_GAIN_V5_poll", id, value );

    /* (0x00000080 bits 5) field PLL_LOCK_GAIN_V5 of register PMC_PM20_82_24_REG_IV_REG */
    return t8_reg_IV_REG_poll( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_IV_REG_BIT_PLL_LOCK_GAIN_V5_MSK,
                               (value<<PM20_82_24_REG_IV_REG_BIT_PLL_LOCK_GAIN_V5_OFF),
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);
}

static INLINE UINT32 t8_field_PROG_REF_DONE_V4_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PROG_REF_DONE_V4_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PROG_REF_DONE_V4_get", id, 2);
    /* (0x00000080 bits 4) field PROG_REF_DONE_V4 of register PMC_PM20_82_24_REG_IV_REG */
    reg_value = t8_reg_IV_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IV_REG_BIT_PROG_REF_DONE_V4_MSK) >> PM20_82_24_REG_IV_REG_BIT_PROG_REF_DONE_V4_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PROG_REF_DONE_V4_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_PROG_REF_DONE_V4_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_PROG_REF_DONE_V4_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_PROG_REF_DONE_V4_poll", id, value );

    /* (0x00000080 bits 4) field PROG_REF_DONE_V4 of register PMC_PM20_82_24_REG_IV_REG */
    return t8_reg_IV_REG_poll( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_IV_REG_BIT_PROG_REF_DONE_V4_MSK,
                               (value<<PM20_82_24_REG_IV_REG_BIT_PROG_REF_DONE_V4_OFF),
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);
}

static INLINE UINT32 t8_field_CALIB_DONE_V3_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CALIB_DONE_V3_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CALIB_DONE_V3_get", id, 2);
    /* (0x00000080 bits 3) field CALIB_DONE_V3 of register PMC_PM20_82_24_REG_IV_REG */
    reg_value = t8_reg_IV_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IV_REG_BIT_CALIB_DONE_V3_MSK) >> PM20_82_24_REG_IV_REG_BIT_CALIB_DONE_V3_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CALIB_DONE_V3_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_CALIB_DONE_V3_poll( t8_buffer_t *b_ptr,
                                                                t8_handle_t *h_ptr,
                                                                UINT32 id,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_CALIB_DONE_V3_poll( t8_buffer_t *b_ptr,
                                                                t8_handle_t *h_ptr,
                                                                UINT32 id,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_CALIB_DONE_V3_poll", id, value );

    /* (0x00000080 bits 3) field CALIB_DONE_V3 of register PMC_PM20_82_24_REG_IV_REG */
    return t8_reg_IV_REG_poll( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_IV_REG_BIT_CALIB_DONE_V3_MSK,
                               (value<<PM20_82_24_REG_IV_REG_BIT_CALIB_DONE_V3_OFF),
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);
}

static INLINE UINT32 t8_field_PLL_LOCK_LOSS_V0_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PLL_LOCK_LOSS_V0_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PLL_LOCK_LOSS_V0_get", id, 2);
    /* (0x00000080 bits 0) field PLL_LOCK_LOSS_V0 of register PMC_PM20_82_24_REG_IV_REG */
    reg_value = t8_reg_IV_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_IV_REG_BIT_PLL_LOCK_LOSS_V0_MSK) >> PM20_82_24_REG_IV_REG_BIT_PLL_LOCK_LOSS_V0_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PLL_LOCK_LOSS_V0_get", id, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE t8_field_PLL_LOCK_LOSS_V0_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE t8_field_PLL_LOCK_LOSS_V0_poll( t8_buffer_t *b_ptr,
                                                                   t8_handle_t *h_ptr,
                                                                   UINT32 id,
                                                                   UINT32 value,
                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                   UINT32 max_count,
                                                                   UINT32 *num_failed_polls,
                                                                   UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  id=%d 0x%08x", "t8_field_PLL_LOCK_LOSS_V0_poll", id, value );

    /* (0x00000080 bits 0) field PLL_LOCK_LOSS_V0 of register PMC_PM20_82_24_REG_IV_REG */
    return t8_reg_IV_REG_poll( b_ptr,
                               h_ptr,
                               id,
                               PM20_82_24_REG_IV_REG_BIT_PLL_LOCK_LOSS_V0_MSK,
                               (value<<PM20_82_24_REG_IV_REG_BIT_PLL_LOCK_LOSS_V0_OFF),
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset ram_N_burstsize96
 * ==================================================================================
 */
static INLINE void t8_lfield_PM20_82_24_MTSB0_OFFSET_RAM_REG_set( t8_buffer_t *b_ptr,
                                                                  t8_handle_t *h_ptr,
                                                                  UINT32 id,
                                                                  UINT32 value[96] ) ALWAYS_INLINE;
static INLINE void t8_lfield_PM20_82_24_MTSB0_OFFSET_RAM_REG_set( t8_buffer_t *b_ptr,
                                                                  t8_handle_t *h_ptr,
                                                                  UINT32 id,
                                                                  UINT32 value[96] )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_lfield_PM20_82_24_MTSB0_OFFSET_RAM_REG_set", id, 2);
    IOLOG( "%s  id=%d", "t8_lfield_PM20_82_24_MTSB0_OFFSET_RAM_REG_set", id);
    t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_burst_write( b_ptr,
                                                         h_ptr,
                                                         id,
                                                         0,
                                                         96,
                                                         value);
}

static INLINE void t8_lfield_PM20_82_24_MTSB0_OFFSET_RAM_REG_get( t8_buffer_t *b_ptr,
                                                                  t8_handle_t *h_ptr,
                                                                  UINT32 id,
                                                                  UINT32 value[96] ) ALWAYS_INLINE;
static INLINE void t8_lfield_PM20_82_24_MTSB0_OFFSET_RAM_REG_get( t8_buffer_t *b_ptr,
                                                                  t8_handle_t *h_ptr,
                                                                  UINT32 id,
                                                                  UINT32 value[96] )
{
    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_lfield_PM20_82_24_MTSB0_OFFSET_RAM_REG_get", id, 2);
    IOLOG( "%s  id=%d", "t8_lfield_PM20_82_24_MTSB0_OFFSET_RAM_REG_get", id);
    t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_burst_read( b_ptr,
                                                        h_ptr,
                                                        id,
                                                        0,
                                                        96,
                                                        (UINT32 *)value);
}

static INLINE void t8_lfield_range_PM20_82_24_MTSB0_OFFSET_RAM_REG_set( t8_buffer_t *b_ptr,
                                                                        t8_handle_t *h_ptr,
                                                                        UINT32 id,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void t8_lfield_range_PM20_82_24_MTSB0_OFFSET_RAM_REG_set( t8_buffer_t *b_ptr,
                                                                        t8_handle_t *h_ptr,
                                                                        UINT32 id,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_lfield_range_PM20_82_24_MTSB0_OFFSET_RAM_REG_set", id, 2);
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "t8_lfield_range_PM20_82_24_MTSB0_OFFSET_RAM_REG_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d value=0x%08x", "t8_lfield_range_PM20_82_24_MTSB0_OFFSET_RAM_REG_set", id, start_bit, stop_bit, value);
    t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_field_set( b_ptr,
                                                       h_ptr,
                                                       id,
                                                       word_number,
                                                       mask,
                                                       field_ofs,
                                                       value);
}

static INLINE UINT32 t8_lfield_range_PM20_82_24_MTSB0_OFFSET_RAM_REG_get( t8_buffer_t *b_ptr,
                                                                          t8_handle_t *h_ptr,
                                                                          UINT32 id,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 t8_lfield_range_PM20_82_24_MTSB0_OFFSET_RAM_REG_get( t8_buffer_t *b_ptr,
                                                                          t8_handle_t *h_ptr,
                                                                          UINT32 id,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_lfield_range_PM20_82_24_MTSB0_OFFSET_RAM_REG_get", id, 2);
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "t8_lfield_range_PM20_82_24_MTSB0_OFFSET_RAM_REG_get", start_bit, stop_bit );
    }
    reg_value = t8_reg_PM20_82_24_OFFSET_RAM_REG0_array_read( b_ptr,
                                                              h_ptr,
                                                              id,
                                                              word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d value=0x%08x", "t8_lfield_range_PM20_82_24_MTSB0_OFFSET_RAM_REG_get", id, start_bit, stop_bit, value );
    return value;
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset status
 * ==================================================================================
 */
static INLINE UINT32 t8_field_BIST_SYNC_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_BIST_SYNC_get( t8_buffer_t *b_ptr,
                                             t8_handle_t *h_ptr,
                                             UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_BIST_SYNC_get", id, 2);
    /* (0x00000008 bits 1) field BIST_SYNC of register PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_STATUS_REG */
    reg_value = t8_reg_ANALOG_SIPO_BIST_STATUS_REG_read( b_ptr,
                                                         h_ptr,
                                                         id);
    value = (reg_value & PM20_82_24_REG_ANALOG_SIPO_BIST_STATUS_REG_BIT_BIST_SYNC_MSK) >> PM20_82_24_REG_ANALOG_SIPO_BIST_STATUS_REG_BIT_BIST_SYNC_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_BIST_SYNC_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_BIST_ERR_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_BIST_ERR_get( t8_buffer_t *b_ptr,
                                            t8_handle_t *h_ptr,
                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_BIST_ERR_get", id, 2);
    /* (0x00000008 bits 0) field BIST_ERR of register PMC_PM20_82_24_REG_ANALOG_SIPO_BIST_STATUS_REG */
    reg_value = t8_reg_ANALOG_SIPO_BIST_STATUS_REG_read( b_ptr,
                                                         h_ptr,
                                                         id);
    value = (reg_value & PM20_82_24_REG_ANALOG_SIPO_BIST_STATUS_REG_BIT_BIST_ERR_MSK) >> PM20_82_24_REG_ANALOG_SIPO_BIST_STATUS_REG_BIT_BIST_ERR_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_BIST_ERR_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_TX_CODE_COUNT_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TX_CODE_COUNT_get( t8_buffer_t *b_ptr,
                                                 t8_handle_t *h_ptr,
                                                 UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_CODE_COUNT_get", id, 2);
    /* (0x00000024 bits 15:0) bits 0:15 use field TX_CODE_COUNT of register PMC_PM20_82_24_REG_TX_CNTR_STA */
    reg_value = t8_reg_TX_CNTR_STA_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CNTR_STA_BIT_TX_CODE_COUNT_MSK) >> PM20_82_24_REG_TX_CNTR_STA_BIT_TX_CODE_COUNT_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TX_CODE_COUNT_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_range_TX_CODE_COUNT_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_TX_CODE_COUNT_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_TX_CODE_COUNT_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_TX_CODE_COUNT_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_TX_CODE_COUNT_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000024 bits 15:0) bits 0:15 use field TX_CODE_COUNT of register PMC_PM20_82_24_REG_TX_CNTR_STA */
    reg_value = t8_reg_TX_CNTR_STA_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_TX_CNTR_STA_BIT_TX_CODE_COUNT_MSK)
                  >> PM20_82_24_REG_TX_CNTR_STA_BIT_TX_CODE_COUNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_TX_CNTR_STA_BIT_TX_CODE_COUNT_MSK, PM20_82_24_REG_TX_CNTR_STA_BIT_TX_CODE_COUNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_TX_CODE_COUNT_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 t8_field_ADC_Q_get( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADC_Q_get( t8_buffer_t *b_ptr,
                                         t8_handle_t *h_ptr,
                                         UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADC_Q_get", id, 2);
    /* (0x00000044 bits 9:2) bits 0:7 use field ADC_Q of register PMC_PM20_82_24_REG_ADC_OC_STS */
    reg_value = t8_reg_ADC_OC_STS_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_STS_BIT_ADC_Q_MSK) >> PM20_82_24_REG_ADC_OC_STS_BIT_ADC_Q_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADC_Q_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_range_ADC_Q_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 start_bit,
                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_ADC_Q_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id,
                                               UINT32 start_bit,
                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_ADC_Q_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_ADC_Q_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_ADC_Q_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000044 bits 9:2) bits 0:7 use field ADC_Q of register PMC_PM20_82_24_REG_ADC_OC_STS */
    reg_value = t8_reg_ADC_OC_STS_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_ADC_OC_STS_BIT_ADC_Q_MSK)
                  >> PM20_82_24_REG_ADC_OC_STS_BIT_ADC_Q_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_ADC_OC_STS_BIT_ADC_Q_MSK, PM20_82_24_REG_ADC_OC_STS_BIT_ADC_Q_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_ADC_Q_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 t8_field_ADCOC_PROG_REF_DONE_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_PROG_REF_DONE_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_PROG_REF_DONE_get", id, 2);
    /* (0x00000044 bits 1) field ADCOC_PROG_REF_DONE of register PMC_PM20_82_24_REG_ADC_OC_STS */
    reg_value = t8_reg_ADC_OC_STS_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_STS_BIT_ADCOC_PROG_REF_DONE_MSK) >> PM20_82_24_REG_ADC_OC_STS_BIT_ADCOC_PROG_REF_DONE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_PROG_REF_DONE_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_ADCOC_CALIB_DONE_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_ADCOC_CALIB_DONE_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_ADCOC_CALIB_DONE_get", id, 2);
    /* (0x00000044 bits 0) field ADCOC_CALIB_DONE of register PMC_PM20_82_24_REG_ADC_OC_STS */
    reg_value = t8_reg_ADC_OC_STS_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_ADC_OC_STS_BIT_ADCOC_CALIB_DONE_MSK) >> PM20_82_24_REG_ADC_OC_STS_BIT_ADCOC_CALIB_DONE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_ADCOC_CALIB_DONE_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_TX_SUM_OUT_get( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_TX_SUM_OUT_get( t8_buffer_t *b_ptr,
                                              t8_handle_t *h_ptr,
                                              UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_TX_SUM_OUT_get", id, 2);
    /* (0x000000a0 bits 15:0) field TX_SUM_OUT of register PMC_PM20_82_24_REG_TX_CTRL_STS_REG1 */
    reg_value = t8_reg_TX_CTRL_STS_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_TX_CTRL_STS_REG1_BIT_TX_SUM_OUT_MSK) >> PM20_82_24_REG_TX_CTRL_STS_REG1_BIT_TX_SUM_OUT_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_TX_SUM_OUT_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_range_TX_SUM_OUT_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_TX_SUM_OUT_get( t8_buffer_t *b_ptr,
                                                    t8_handle_t *h_ptr,
                                                    UINT32 id,
                                                    UINT32 start_bit,
                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_TX_SUM_OUT_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_TX_SUM_OUT_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_TX_SUM_OUT_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000a0 bits 15:0) field TX_SUM_OUT of register PMC_PM20_82_24_REG_TX_CTRL_STS_REG1 */
    reg_value = t8_reg_TX_CTRL_STS_REG1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_TX_CTRL_STS_REG1_BIT_TX_SUM_OUT_MSK)
                  >> PM20_82_24_REG_TX_CTRL_STS_REG1_BIT_TX_SUM_OUT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_TX_CTRL_STS_REG1_BIT_TX_SUM_OUT_MSK, PM20_82_24_REG_TX_CTRL_STS_REG1_BIT_TX_SUM_OUT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_TX_SUM_OUT_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 t8_field_PPM_OFF_RD_SIGN_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PPM_OFF_RD_SIGN_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PPM_OFF_RD_SIGN_get", id, 2);
    /* (0x00000194 bits 31) field PPM_OFF_RD_SIGN of register PMC_PM20_82_24_REG_PLL_STS_REG */
    reg_value = t8_reg_PLL_STS_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PLL_STS_REG_BIT_PPM_OFF_RD_SIGN_MSK) >> PM20_82_24_REG_PLL_STS_REG_BIT_PPM_OFF_RD_SIGN_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PPM_OFF_RD_SIGN_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_PPM_OFF_RD_VAL_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_PPM_OFF_RD_VAL_get( t8_buffer_t *b_ptr,
                                                  t8_handle_t *h_ptr,
                                                  UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_PPM_OFF_RD_VAL_get", id, 2);
    /* (0x00000194 bits 20:0) field PPM_OFF_RD_VAL of register PMC_PM20_82_24_REG_PLL_STS_REG */
    reg_value = t8_reg_PLL_STS_REG_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_PLL_STS_REG_BIT_PPM_OFF_RD_VAL_MSK) >> PM20_82_24_REG_PLL_STS_REG_BIT_PPM_OFF_RD_VAL_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_PPM_OFF_RD_VAL_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_range_PPM_OFF_RD_VAL_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_PPM_OFF_RD_VAL_get( t8_buffer_t *b_ptr,
                                                        t8_handle_t *h_ptr,
                                                        UINT32 id,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_PPM_OFF_RD_VAL_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_PPM_OFF_RD_VAL_get", stop_bit, start_bit );
    if (stop_bit > 20) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_PPM_OFF_RD_VAL_get", stop_bit, 20 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 20) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 20;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000194 bits 20:0) field PPM_OFF_RD_VAL of register PMC_PM20_82_24_REG_PLL_STS_REG */
    reg_value = t8_reg_PLL_STS_REG_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_PLL_STS_REG_BIT_PPM_OFF_RD_VAL_MSK)
                  >> PM20_82_24_REG_PLL_STS_REG_BIT_PPM_OFF_RD_VAL_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PLL_STS_REG_BIT_PPM_OFF_RD_VAL_MSK, PM20_82_24_REG_PLL_STS_REG_BIT_PPM_OFF_RD_VAL_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_PPM_OFF_RD_VAL_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 t8_field_VHIST_PERBIN_VALUE_39_32_get( t8_buffer_t *b_ptr,
                                                            t8_handle_t *h_ptr,
                                                            UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_VHIST_PERBIN_VALUE_39_32_get( t8_buffer_t *b_ptr,
                                                            t8_handle_t *h_ptr,
                                                            UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_PERBIN_VALUE_39_32_get", id, 2);
    /* (0x00000210 bits 31:24) field VHIST_PERBIN_VALUE_39_32 of register PMC_PM20_82_24_REG_DIAG_STATUS_REG1 */
    reg_value = t8_reg_DIAG_STATUS_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_PERBIN_VALUE_39_32_MSK) >> PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_PERBIN_VALUE_39_32_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_VHIST_PERBIN_VALUE_39_32_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_range_VHIST_PERBIN_VALUE_39_32_get( t8_buffer_t *b_ptr,
                                                                  t8_handle_t *h_ptr,
                                                                  UINT32 id,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_VHIST_PERBIN_VALUE_39_32_get( t8_buffer_t *b_ptr,
                                                                  t8_handle_t *h_ptr,
                                                                  UINT32 id,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_VHIST_PERBIN_VALUE_39_32_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_VHIST_PERBIN_VALUE_39_32_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_VHIST_PERBIN_VALUE_39_32_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000210 bits 31:24) field VHIST_PERBIN_VALUE_39_32 of register PMC_PM20_82_24_REG_DIAG_STATUS_REG1 */
    reg_value = t8_reg_DIAG_STATUS_REG1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_PERBIN_VALUE_39_32_MSK)
                  >> PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_PERBIN_VALUE_39_32_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_PERBIN_VALUE_39_32_MSK, PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_PERBIN_VALUE_39_32_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_VHIST_PERBIN_VALUE_39_32_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 t8_field_VHIST_READBACK_ADDR_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_VHIST_READBACK_ADDR_get( t8_buffer_t *b_ptr,
                                                       t8_handle_t *h_ptr,
                                                       UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_READBACK_ADDR_get", id, 2);
    /* (0x00000210 bits 15:10) field VHIST_READBACK_ADDR of register PMC_PM20_82_24_REG_DIAG_STATUS_REG1 */
    reg_value = t8_reg_DIAG_STATUS_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_READBACK_ADDR_MSK) >> PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_READBACK_ADDR_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_VHIST_READBACK_ADDR_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_range_VHIST_READBACK_ADDR_get( t8_buffer_t *b_ptr,
                                                             t8_handle_t *h_ptr,
                                                             UINT32 id,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_VHIST_READBACK_ADDR_get( t8_buffer_t *b_ptr,
                                                             t8_handle_t *h_ptr,
                                                             UINT32 id,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_VHIST_READBACK_ADDR_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_VHIST_READBACK_ADDR_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_VHIST_READBACK_ADDR_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000210 bits 15:10) field VHIST_READBACK_ADDR of register PMC_PM20_82_24_REG_DIAG_STATUS_REG1 */
    reg_value = t8_reg_DIAG_STATUS_REG1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_READBACK_ADDR_MSK)
                  >> PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_READBACK_ADDR_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_READBACK_ADDR_MSK, PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_READBACK_ADDR_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_VHIST_READBACK_ADDR_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 t8_field_VHIST_FSM_STATE_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_VHIST_FSM_STATE_get( t8_buffer_t *b_ptr,
                                                   t8_handle_t *h_ptr,
                                                   UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_FSM_STATE_get", id, 2);
    /* (0x00000210 bits 7:5) field VHIST_FSM_STATE of register PMC_PM20_82_24_REG_DIAG_STATUS_REG1 */
    reg_value = t8_reg_DIAG_STATUS_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_FSM_STATE_MSK) >> PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_FSM_STATE_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_VHIST_FSM_STATE_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_range_VHIST_FSM_STATE_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_VHIST_FSM_STATE_get( t8_buffer_t *b_ptr,
                                                         t8_handle_t *h_ptr,
                                                         UINT32 id,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_VHIST_FSM_STATE_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_VHIST_FSM_STATE_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_VHIST_FSM_STATE_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000210 bits 7:5) field VHIST_FSM_STATE of register PMC_PM20_82_24_REG_DIAG_STATUS_REG1 */
    reg_value = t8_reg_DIAG_STATUS_REG1_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_FSM_STATE_MSK)
                  >> PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_FSM_STATE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_FSM_STATE_MSK, PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_FSM_STATE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_VHIST_FSM_STATE_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 t8_field_VHIST_PERBIN_VALUE_OVFL_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_VHIST_PERBIN_VALUE_OVFL_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_PERBIN_VALUE_OVFL_get", id, 2);
    /* (0x00000210 bits 1) field VHIST_PERBIN_VALUE_OVFL of register PMC_PM20_82_24_REG_DIAG_STATUS_REG1 */
    reg_value = t8_reg_DIAG_STATUS_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_PERBIN_VALUE_OVFL_MSK) >> PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_PERBIN_VALUE_OVFL_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_VHIST_PERBIN_VALUE_OVFL_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_VHIST_CAPT_RUNNING_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_VHIST_CAPT_RUNNING_get( t8_buffer_t *b_ptr,
                                                      t8_handle_t *h_ptr,
                                                      UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_CAPT_RUNNING_get", id, 2);
    /* (0x00000210 bits 0) field VHIST_CAPT_RUNNING of register PMC_PM20_82_24_REG_DIAG_STATUS_REG1 */
    reg_value = t8_reg_DIAG_STATUS_REG1_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_CAPT_RUNNING_MSK) >> PM20_82_24_REG_DIAG_STATUS_REG1_BIT_VHIST_CAPT_RUNNING_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_VHIST_CAPT_RUNNING_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_VHIST_PERBIN_VALUE_31_0_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_VHIST_PERBIN_VALUE_31_0_get( t8_buffer_t *b_ptr,
                                                           t8_handle_t *h_ptr,
                                                           UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_VHIST_PERBIN_VALUE_31_0_get", id, 2);
    /* (0x00000214 bits 31:0) field VHIST_PERBIN_VALUE_31_0 of register PMC_PM20_82_24_REG_DIAG_STATUS_REG2 */
    reg_value = t8_reg_DIAG_STATUS_REG2_read(  b_ptr, h_ptr, id);
    value = (reg_value & PM20_82_24_REG_DIAG_STATUS_REG2_BIT_VHIST_PERBIN_VALUE_31_0_MSK) >> PM20_82_24_REG_DIAG_STATUS_REG2_BIT_VHIST_PERBIN_VALUE_31_0_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_VHIST_PERBIN_VALUE_31_0_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_range_VHIST_PERBIN_VALUE_31_0_get( t8_buffer_t *b_ptr,
                                                                 t8_handle_t *h_ptr,
                                                                 UINT32 id,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_VHIST_PERBIN_VALUE_31_0_get( t8_buffer_t *b_ptr,
                                                                 t8_handle_t *h_ptr,
                                                                 UINT32 id,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_VHIST_PERBIN_VALUE_31_0_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_VHIST_PERBIN_VALUE_31_0_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_VHIST_PERBIN_VALUE_31_0_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000214 bits 31:0) field VHIST_PERBIN_VALUE_31_0 of register PMC_PM20_82_24_REG_DIAG_STATUS_REG2 */
    reg_value = t8_reg_DIAG_STATUS_REG2_read(  b_ptr, h_ptr, id);
    field_value = (reg_value & PM20_82_24_REG_DIAG_STATUS_REG2_BIT_VHIST_PERBIN_VALUE_31_0_MSK)
                  >> PM20_82_24_REG_DIAG_STATUS_REG2_BIT_VHIST_PERBIN_VALUE_31_0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_DIAG_STATUS_REG2_BIT_VHIST_PERBIN_VALUE_31_0_MSK, PM20_82_24_REG_DIAG_STATUS_REG2_BIT_VHIST_PERBIN_VALUE_31_0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_VHIST_PERBIN_VALUE_31_0_get", id, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 t8_field_CHK_ERR_CNT_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_CHK_ERR_CNT_get( t8_buffer_t *b_ptr,
                                               t8_handle_t *h_ptr,
                                               UINT32 id )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_CHK_ERR_CNT_get", id, 2);
    /* (0x00000244 bits 31:0) field CHK_ERR_CNT of register PMC_PM20_82_24_REG_PATT_CHK_STATUS_REG1 */
    reg_value = t8_reg_PATT_CHK_STATUS_REG1_read( b_ptr,
                                                  h_ptr,
                                                  id);
    value = (reg_value & PM20_82_24_REG_PATT_CHK_STATUS_REG1_BIT_CHK_ERR_CNT_MSK) >> PM20_82_24_REG_PATT_CHK_STATUS_REG1_BIT_CHK_ERR_CNT_OFF;
    IOLOG( "%s -> id=%d 0x%08x", "t8_field_CHK_ERR_CNT_get", id, value );

    return value;
}
static INLINE UINT32 t8_field_range_CHK_ERR_CNT_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 t8_field_range_CHK_ERR_CNT_get( t8_buffer_t *b_ptr,
                                                     t8_handle_t *h_ptr,
                                                     UINT32 id,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (id > 2)
        IO_RANGE_CHECK("%s id is %d but max is %d", "t8_field_range_CHK_ERR_CNT_get", id, 2);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "t8_field_range_CHK_ERR_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "t8_field_range_CHK_ERR_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000244 bits 31:0) field CHK_ERR_CNT of register PMC_PM20_82_24_REG_PATT_CHK_STATUS_REG1 */
    reg_value = t8_reg_PATT_CHK_STATUS_REG1_read( b_ptr,
                                                  h_ptr,
                                                  id);
    field_value = (reg_value & PM20_82_24_REG_PATT_CHK_STATUS_REG1_BIT_CHK_ERR_CNT_MSK)
                  >> PM20_82_24_REG_PATT_CHK_STATUS_REG1_BIT_CHK_ERR_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PM20_82_24_REG_PATT_CHK_STATUS_REG1_BIT_CHK_ERR_CNT_MSK, PM20_82_24_REG_PATT_CHK_STATUS_REG1_BIT_CHK_ERR_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> id=%d start_bit=%d stop_bit=%d 0x%08x", "t8_field_range_CHK_ERR_CNT_get", id, start_bit, stop_bit, value );

    return value;
}

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _T8_IO_INLINE_H */
