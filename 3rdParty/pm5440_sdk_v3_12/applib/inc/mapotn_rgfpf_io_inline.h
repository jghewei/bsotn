/******************************************************************************
 *   COPYRIGHT (C) 2013 PMC-SIERRA, INC. ALL RIGHTS RESERVED.
 * --------------------------------------------------------------------------
 *  This software embodies materials and concepts which are proprietary and
 *  confidential to PMC-Sierra, Inc.
 *  PMC-Sierra distributes this software to its customers pursuant to the
 *  terms and conditions of the Software License Agreement
 *  contained in the text file software.lic that is distributed along with
 *  the software. This software can only be utilized if all
 *  terms and conditions of the Software License Agreement are
 *  accepted. If there are any questions, concerns, or if the
 *  Software License Agreement text file, software.lic, is missing please
 *  contact PMC-Sierra for assistance.
 * -------------------------------------------------------------------------
 *   DESCRIPTION:
 *     contains the inline implementation of all the field accessor functions
 *     and register accessor functions for the mapotn_rgfpf block
 *****************************************************************************/
#ifndef _MAPOTN_RGFPF_IO_INLINE_H
#define _MAPOTN_RGFPF_IO_INLINE_H

#include "mapotn_loc.h"
#include "mapotn_rgfpf_regs.h"

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define MAPOTN_RGFPF_IO_VERSION 2

/*
 * ==================================================================================
 *  tsb level structure and access functions for mapotn_rgfpf
 * ==================================================================================
 */
/* if logging is disabled then so is IO_LOGGING */
#ifndef NO_IO_LOGGING
# ifdef LOGGING_DISABLED
#  define NO_IO_LOGGING
# endif
#endif

/* log messages in the generated files log the caller's file/line/function instead of itself.*/
#ifndef IOLOG
# ifdef NO_IO_LOGGING
#  define IOLOG(...)
# else
#  define IOLOG(...) LOG( __VA_ARGS__)
# endif
#endif
#ifndef IO_RANGE_CHECK
# ifdef NO_IO_LOGGING
#  define IO_RANGE_CHECK(...)
# else
#  define IO_RANGE_CHECK(...) LOG( "** range check ** " __VA_ARGS__)
# endif
#endif
#ifndef IOLOG_DATA
# ifdef NO_IO_LOGGING
#  define IOLOG_DATA(...)
# else
#  define IOLOG_DATA(...) LOG_DATA( __VA_ARGS__)
# endif
#endif
typedef struct {
    coalesce_buffer_t coalesce_handle[1]; /* only used if register coalescing is enabled */
    mapotn_handle_t * h_ptr;
    pmc_sys_handle_t * sys_handle;
    PMC_VAR_CONST UINT32 base_address;
    /* maybe eventually need to add some fields here per io handle */
} mapotn_rgfpf_buffer_t;
static INLINE void mapotn_rgfpf_buffer_init( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_buffer_init( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    b_ptr->h_ptr                    = h_ptr;
    b_ptr->sys_handle               = ((pmc_handle_t *)h_ptr)->sys_handle;
    *(UINT32 *)&b_ptr->base_address = ((pmc_handle_t *)h_ptr)->base_address;
    /* currently this just checks that the previous function remembered to flush. */
    l1sys_init( b_ptr->coalesce_handle, b_ptr->sys_handle );
    IOLOG( "%s", "mapotn_rgfpf_buffer_init");
    
}

/* flush any changed fields to the register file and invalidate the read cache. */
static INLINE void mapotn_rgfpf_buffer_flush( mapotn_rgfpf_buffer_t *b_ptr ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_buffer_flush( mapotn_rgfpf_buffer_t *b_ptr )
{
    IOLOG( "mapotn_rgfpf_buffer_flush" );
    l1sys_flush( b_ptr->coalesce_handle );
}
static INLINE UINT32 mapotn_rgfpf_reg_read( mapotn_rgfpf_buffer_t *b_ptr,
                                            mapotn_handle_t *h_ptr,
                                            UINT32 mem_type,
                                            UINT32 reg ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_read( mapotn_rgfpf_buffer_t *b_ptr,
                                            mapotn_handle_t *h_ptr,
                                            UINT32 mem_type,
                                            UINT32 reg )
{
    UINT32 value;
    if (b_ptr != NULL)
        value = l1sys_reg_read( b_ptr->coalesce_handle,
                                mem_type,
                                b_ptr->base_address,
                                reg);
    else
        value = l2sys_reg_read( ((pmc_handle_t *)h_ptr)->sys_handle,
                                mem_type,
                                ((pmc_handle_t *)h_ptr)->base_address + reg);
    return value;
}
static INLINE void mapotn_rgfpf_reg_write( mapotn_rgfpf_buffer_t *b_ptr,
                                           mapotn_handle_t *h_ptr,
                                           UINT32 mem_type,
                                           UINT32 reg,
                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_write( mapotn_rgfpf_buffer_t *b_ptr,
                                           mapotn_handle_t *h_ptr,
                                           UINT32 mem_type,
                                           UINT32 reg,
                                           UINT32 value )
{
    if (b_ptr != NULL)
        l1sys_reg_write( b_ptr->coalesce_handle,
                         mem_type,
                         b_ptr->base_address,
                         reg,
                         value);
    else
        l2sys_reg_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                         mem_type,
                         ((pmc_handle_t *)h_ptr)->base_address + reg,
                         value);
}

static INLINE void mapotn_rgfpf_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                           mapotn_handle_t *h_ptr,
                                           UINT32 mem_type,
                                           UINT32 reg,
                                           UINT32 mask,
                                           UINT32 unused_mask,
                                           UINT32 ofs,
                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                           mapotn_handle_t *h_ptr,
                                           UINT32 mem_type,
                                           UINT32 reg,
                                           UINT32 mask,
                                           UINT32 unused_mask,
                                           UINT32 ofs,
                                           UINT32 value )
{
    if (b_ptr != NULL)
        l1sys_field_set2( b_ptr->coalesce_handle,
                          mem_type,
                          b_ptr->base_address,
                          reg,
                          mask,
                          unused_mask,
                          ofs,
                          value);
    else
    {
        if ((mask | unused_mask) == 0xffffffff)
        {
            l2sys_reg_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                             mem_type,
                             ((pmc_handle_t *)h_ptr)->base_address + reg,
                             value<<ofs);
        }
        else
        {
            l2sys_reg_read_modify_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                                         mem_type,
                                         ((pmc_handle_t *)h_ptr)->base_address + reg,
                                         mask,
                                         value<<ofs);
        }
    }
}

static INLINE void mapotn_rgfpf_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 mem_type,
                                                           UINT32 reg,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 mem_type,
                                                           UINT32 reg,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    if (b_ptr != NULL)
        l1sys_action_on_write_field_set( b_ptr->coalesce_handle,
                                         mem_type,
                                         b_ptr->base_address,
                                         reg,
                                         mask,
                                         ofs,
                                         value);
    else
        l2sys_reg_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                         mem_type,
                         ((pmc_handle_t *)h_ptr)->base_address + reg,
                         value<<ofs);
}

static INLINE void mapotn_rgfpf_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                            mapotn_handle_t *h_ptr,
                                            UINT32 mem_type,
                                            UINT32 reg,
                                            UINT32 len,
                                            UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                            mapotn_handle_t *h_ptr,
                                            UINT32 mem_type,
                                            UINT32 reg,
                                            UINT32 len,
                                            UINT32 *value )
{
    if (b_ptr != NULL)
        l1sys_burst_read( b_ptr->coalesce_handle,
                          mem_type,
                          b_ptr->base_address,
                          reg,
                          len,
                          value);
    else
        l2sys_burst_read( ((pmc_handle_t *)h_ptr)->sys_handle,
                          mem_type,
                          ((pmc_handle_t *)h_ptr)->base_address + reg,
                          len,
                          value);
}

static INLINE void mapotn_rgfpf_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                             mapotn_handle_t *h_ptr,
                                             UINT32 mem_type,
                                             UINT32 reg,
                                             UINT32 len,
                                             UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                             mapotn_handle_t *h_ptr,
                                             UINT32 mem_type,
                                             UINT32 reg,
                                             UINT32 len,
                                             UINT32 *value )
{
    if (b_ptr != NULL)
        l1sys_burst_write( b_ptr->coalesce_handle,
                           mem_type,
                           b_ptr->base_address,
                           reg,
                           len,
                           value);
    else
        l2sys_burst_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                           mem_type,
                           ((pmc_handle_t *)h_ptr)->base_address + reg,
                           len,
                           value);
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 mem_type,
                                                      UINT32 reg,
                                                      UINT32 mask,
                                                      UINT32 value,
                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                      UINT32 max_count,
                                                      UINT32 *num_failed_polls,
                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 mem_type,
                                                      UINT32 reg,
                                                      UINT32 mask,
                                                      UINT32 value,
                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                      UINT32 max_count,
                                                      UINT32 *num_failed_polls,
                                                      UINT32 delay_between_polls_in_microseconds )
{
    if (b_ptr != NULL)
        return l1sys_poll( b_ptr->coalesce_handle,
                           mem_type,
                           b_ptr->base_address,
                           reg,
                           mask,
                           value,
                           cmp,
                           max_count,
                           num_failed_polls,
                           delay_between_polls_in_microseconds);
    else
        return l2sys_poll( ((pmc_handle_t *)h_ptr)->sys_handle,
                           mem_type,
                           ((pmc_handle_t *)h_ptr)->base_address + reg,
                           mask,
                           value,
                           cmp,
                           max_count,
                           num_failed_polls,
                           delay_between_polls_in_microseconds);
}

/*
 * ==================================================================================
 *  register access functions for mapotn_rgfpf
 * ==================================================================================
 */

static INLINE void mapotn_rgfpf_reg_GENERAL_CONFIGURATION_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GENERAL_CONFIGURATION_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_GENERAL_CONFIGURATION_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_GENERAL_CONFIGURATION,
                            value);
}

static INLINE void mapotn_rgfpf_reg_GENERAL_CONFIGURATION_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 mask,
                                                                     UINT32 ofs,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GENERAL_CONFIGURATION_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 mask,
                                                                     UINT32 ofs,
                                                                     UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GENERAL_CONFIGURATION_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_GENERAL_CONFIGURATION,
                            mask,
                            PMC_RGFPF96_CORE_REG_GENERAL_CONFIGURATION_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_GENERAL_CONFIGURATION_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GENERAL_CONFIGURATION_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_CONFIG,
                                       PMC_RGFPF96_CORE_REG_GENERAL_CONFIGURATION);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GENERAL_CONFIGURATION_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_LSB_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_LSB_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_LSB_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB,
                            value);
}

static INLINE void mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_LSB_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 mask,
                                                                           UINT32 ofs,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_LSB_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 mask,
                                                                           UINT32 ofs,
                                                                           UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_LSB_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB,
                            mask,
                            PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_LSB_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_LSB_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_CONFIG,
                                       PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_LSB_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_MSB_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_MSB_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_MSB_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB,
                            value);
}

static INLINE void mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_MSB_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 mask,
                                                                           UINT32 ofs,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_MSB_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 mask,
                                                                           UINT32 ofs,
                                                                           UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_MSB_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB,
                            mask,
                            PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_MSB_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_MSB_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_CONFIG,
                                       PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_MSB_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_ORDERED_SET_UPI_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_ORDERED_SET_UPI_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_ORDERED_SET_UPI_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_ORDERED_SET_UPI,
                            value);
}

static INLINE void mapotn_rgfpf_reg_ORDERED_SET_UPI_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 mask,
                                                               UINT32 ofs,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_ORDERED_SET_UPI_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 mask,
                                                               UINT32 ofs,
                                                               UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_ORDERED_SET_UPI_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_ORDERED_SET_UPI,
                            mask,
                            PMC_RGFPF96_CORE_REG_ORDERED_SET_UPI_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_ORDERED_SET_UPI_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_ORDERED_SET_UPI_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_CONFIG,
                                       PMC_RGFPF96_CORE_REG_ORDERED_SET_UPI);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_ORDERED_SET_UPI_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE,
                            value);
}

static INLINE void mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 mask,
                                                                     UINT32 ofs,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 mask,
                                                                     UINT32 ofs,
                                                                     UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE,
                            mask,
                            PMC_RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_CONFIG,
                                       PMC_RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_CPU_FIFO_RPT_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_FIFO_RPT_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_CPU_FIFO_RPT_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT,
                            value);
}

static INLINE void mapotn_rgfpf_reg_CPU_FIFO_RPT_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_FIFO_RPT_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_CPU_FIFO_RPT_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT,
                            mask,
                            PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_CPU_FIFO_RPT_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CPU_FIFO_RPT_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_CONFIG,
                                       PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_CPU_FIFO_RPT_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 ofs,
                                                                               UINT32 len,
                                                                               UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 ofs,
                                                                               UINT32 len,
                                                                               UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_CONFIG,
                              PMC_RGFPF96_CORE_REG_AUTO_FLOW_CTRL_REGISTER(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_AUTO_FLOW_CTRL_REGISTER(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_AUTO_FLOW_CTRL_REGISTER_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 ofs,
                                                                              UINT32 len,
                                                                              UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 ofs,
                                                                              UINT32 len,
                                                                              UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_CONFIG,
                             PMC_RGFPF96_CORE_REG_AUTO_FLOW_CTRL_REGISTER(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_CONFIG,
                                       PMC_RGFPF96_CORE_REG_AUTO_FLOW_CTRL_REGISTER(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 ofs,
                                                                          UINT32 len,
                                                                          UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 ofs,
                                                                          UINT32 len,
                                                                          UINT32 *value )
{
    if (len + ofs > 6)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_burst_write", ofs, len, 6 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_burst_write", 6, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_CONFIG,
                              PMC_RGFPF96_CORE_REG_CPB_ZONE_THRESHOLD(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 N,
                                                                        UINT32 mask,
                                                                        UINT32 ofs,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 N,
                                                                        UINT32 mask,
                                                                        UINT32 ofs,
                                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_CPB_ZONE_THRESHOLD(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_CPB_ZONE_THRESHOLD_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 ofs,
                                                                         UINT32 len,
                                                                         UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 ofs,
                                                                         UINT32 len,
                                                                         UINT32 *value )
{
    if (len + ofs > 6)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_burst_read", ofs, len, 6 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_CONFIG,
                             PMC_RGFPF96_CORE_REG_CPB_ZONE_THRESHOLD(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_burst_read", 6, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_CONFIG,
                                       PMC_RGFPF96_CORE_REG_CPB_ZONE_THRESHOLD(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_CHANNEL_RESET_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CHANNEL_RESET_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_CHANNEL_RESET_array_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_CHANNEL_RESET(N),
                            value);
}

static INLINE void mapotn_rgfpf_reg_CHANNEL_RESET_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32 mask,
                                                                   UINT32 ofs,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CHANNEL_RESET_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32 mask,
                                                                   UINT32 ofs,
                                                                   UINT32 value )
{
    IOLOG( "%s <- N=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_CHANNEL_RESET_array_field_set", N, mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_CHANNEL_RESET(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_CHANNEL_RESET_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_CHANNEL_RESET_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CHANNEL_RESET_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_CONFIG,
                                       PMC_RGFPF96_CORE_REG_CHANNEL_RESET(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_CHANNEL_RESET_array_read", reg_value, N);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4(N),
                            value);
}

static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32  N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32  N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- N=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_field_set", N, mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_CONFIG,
                            PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_CONFIG,
                                       PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_read", reg_value, N);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_PMON_LATCH_CONTROL_REGISTER_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PMON_LATCH_CONTROL_REGISTER_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_PMON_LATCH_CONTROL_REGISTER_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_PMON_LATCH_CONTROL_REGISTER,
                            value);
}

static INLINE void mapotn_rgfpf_reg_PMON_LATCH_CONTROL_REGISTER_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 mask,
                                                                           UINT32 ofs,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PMON_LATCH_CONTROL_REGISTER_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 mask,
                                                                           UINT32 ofs,
                                                                           UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_PMON_LATCH_CONTROL_REGISTER_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_PMON_LATCH_CONTROL_REGISTER,
                            mask,
                            PMC_RGFPF96_CORE_REG_PMON_LATCH_CONTROL_REGISTER_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_PMON_LATCH_CONTROL_REGISTER_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_PMON_LATCH_CONTROL_REGISTER_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_PMON_LATCH_CONTROL_REGISTER);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_PMON_LATCH_CONTROL_REGISTER_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_TRIG_PAUSE_CAP_REGISTER_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_TRIG_PAUSE_CAP_REGISTER_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_TRIG_PAUSE_CAP_REGISTER_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_TRIG_PAUSE_CAP_REGISTER,
                            value);
}

static INLINE void mapotn_rgfpf_reg_TRIG_PAUSE_CAP_REGISTER_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 mask,
                                                                       UINT32 ofs,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_TRIG_PAUSE_CAP_REGISTER_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 mask,
                                                                       UINT32 ofs,
                                                                       UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_TRIG_PAUSE_CAP_REGISTER_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_TRIG_PAUSE_CAP_REGISTER,
                            mask,
                            PMC_RGFPF96_CORE_REG_TRIG_PAUSE_CAP_REGISTER_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_TRIG_PAUSE_CAP_REGISTER_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_TRIG_PAUSE_CAP_REGISTER_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_TRIG_PAUSE_CAP_REGISTER);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_TRIG_PAUSE_CAP_REGISTER_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS,
                            value);
}

static INLINE void mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS,
                            mask,
                            PMC_RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_PTI_UPI_MIS_STATUS_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PTI_UPI_MIS_STATUS_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_PTI_UPI_MIS_STATUS_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS,
                            value);
}

static INLINE void mapotn_rgfpf_reg_PTI_UPI_MIS_STATUS_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 mask,
                                                                  UINT32 ofs,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PTI_UPI_MIS_STATUS_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 mask,
                                                                  UINT32 ofs,
                                                                  UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_PTI_UPI_MIS_STATUS_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS,
                            mask,
                            PMC_RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_PTI_UPI_MIS_STATUS_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_PTI_UPI_MIS_STATUS_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_PTI_UPI_MIS_STATUS_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 ofs,
                                                                              UINT32 len,
                                                                              UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 ofs,
                                                                              UINT32 len,
                                                                              UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_DCSF_DEASSERT_REGISTER(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 N,
                                                                            UINT32 mask,
                                                                            UINT32 ofs,
                                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 N,
                                                                            UINT32 mask,
                                                                            UINT32 ofs,
                                                                            UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_DCSF_DEASSERT_REGISTER(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_DCSF_DEASSERT_REGISTER_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 ofs,
                                                                             UINT32 len,
                                                                             UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 ofs,
                                                                             UINT32 len,
                                                                             UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_DCSF_DEASSERT_REGISTER(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_DCSF_DEASSERT_REGISTER(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_CSF_STATUS_AV_INTR_ENABLE_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CSF_STATUS_AV_INTR_ENABLE_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_CSF_STATUS_AV_INTR_ENABLE_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_CSF_STATUS_AV_INTR_ENABLE,
                            value);
}

static INLINE void mapotn_rgfpf_reg_CSF_STATUS_AV_INTR_ENABLE_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 mask,
                                                                         UINT32 ofs,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CSF_STATUS_AV_INTR_ENABLE_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 mask,
                                                                         UINT32 ofs,
                                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_CSF_STATUS_AV_INTR_ENABLE_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_CSF_STATUS_AV_INTR_ENABLE,
                            mask,
                            PMC_RGFPF96_CORE_REG_CSF_STATUS_AV_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_CSF_STATUS_AV_INTR_ENABLE_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CSF_STATUS_AV_INTR_ENABLE_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_CSF_STATUS_AV_INTR_ENABLE);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_CSF_STATUS_AV_INTR_ENABLE_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_CSF_STATUS_FIFO_OF_INTR_ENABLE_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CSF_STATUS_FIFO_OF_INTR_ENABLE_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_CSF_STATUS_FIFO_OF_INTR_ENABLE_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_CSF_STATUS_FIFO_OF_INTR_ENABLE,
                            value);
}

static INLINE void mapotn_rgfpf_reg_CSF_STATUS_FIFO_OF_INTR_ENABLE_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 mask,
                                                                              UINT32 ofs,
                                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CSF_STATUS_FIFO_OF_INTR_ENABLE_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 mask,
                                                                              UINT32 ofs,
                                                                              UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_CSF_STATUS_FIFO_OF_INTR_ENABLE_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_CSF_STATUS_FIFO_OF_INTR_ENABLE,
                            mask,
                            PMC_RGFPF96_CORE_REG_CSF_STATUS_FIFO_OF_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_CSF_STATUS_FIFO_OF_INTR_ENABLE_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CSF_STATUS_FIFO_OF_INTR_ENABLE_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_CSF_STATUS_FIFO_OF_INTR_ENABLE);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_CSF_STATUS_FIFO_OF_INTR_ENABLE_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_PMON_TRANSFER_INTR_ENABLE_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PMON_TRANSFER_INTR_ENABLE_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_PMON_TRANSFER_INTR_ENABLE_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE,
                            value);
}

static INLINE void mapotn_rgfpf_reg_PMON_TRANSFER_INTR_ENABLE_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 mask,
                                                                         UINT32 ofs,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PMON_TRANSFER_INTR_ENABLE_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 mask,
                                                                         UINT32 ofs,
                                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_PMON_TRANSFER_INTR_ENABLE_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE,
                            mask,
                            PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_PMON_TRANSFER_INTR_ENABLE_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_PMON_TRANSFER_INTR_ENABLE_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_PMON_TRANSFER_INTR_ENABLE_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_ENABLE_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_ENABLE_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_ENABLE_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE,
                            value);
}

static INLINE void mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_ENABLE_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 mask,
                                                                          UINT32 ofs,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_ENABLE_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 mask,
                                                                          UINT32 ofs,
                                                                          UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_ENABLE_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE,
                            mask,
                            PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_ENABLE_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_ENABLE_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_ENABLE_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_RCOH_STAT_TRANSFR_DONE_EN_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_RCOH_STAT_TRANSFR_DONE_EN_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_RCOH_STAT_TRANSFR_DONE_EN_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_RCOH_STAT_TRANSFR_DONE_EN,
                            value);
}

static INLINE void mapotn_rgfpf_reg_RCOH_STAT_TRANSFR_DONE_EN_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 mask,
                                                                         UINT32 ofs,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_RCOH_STAT_TRANSFR_DONE_EN_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 mask,
                                                                         UINT32 ofs,
                                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_RCOH_STAT_TRANSFR_DONE_EN_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_RCOH_STAT_TRANSFR_DONE_EN,
                            mask,
                            PMC_RGFPF96_CORE_REG_RCOH_STAT_TRANSFR_DONE_EN_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_RCOH_STAT_TRANSFR_DONE_EN_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_RCOH_STAT_TRANSFR_DONE_EN_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_RCOH_STAT_TRANSFR_DONE_EN);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_RCOH_STAT_TRANSFR_DONE_EN_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32  M,
                                                                                UINT32 ofs,
                                                                                UINT32 len,
                                                                                UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32  M,
                                                                                UINT32 ofs,
                                                                                UINT32 len,
                                                                                UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words M=%d ofs=%d len=%d", "mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_burst_write", 3, M, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_INTR_ENABLE(ofs,M),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32  M,
                                                                              UINT32 N,
                                                                              UINT32 mask,
                                                                              UINT32 ofs,
                                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32  M,
                                                                              UINT32 N,
                                                                              UINT32 mask,
                                                                              UINT32 ofs,
                                                                              UINT32 value )
{
    IOLOG( "%s <- M=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_field_set", M, mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_INTR_ENABLE(N,M),
                            mask,
                            PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32  M,
                                                                               UINT32 ofs,
                                                                               UINT32 len,
                                                                               UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32  M,
                                                                               UINT32 ofs,
                                                                               UINT32 len,
                                                                               UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_INTR_ENABLE(ofs,M),
                             len,
                             value);

    IOLOG( "%s of %d words M=%d ofs=%d len=%d", "mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_burst_read", 3, M, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32  M,
                                                                           UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32  M,
                                                                           UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_INTR_ENABLE(N,M));

    IOLOG( "%s -> 0x%08x; M=%d", "mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_read", reg_value, M);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 ofs,
                                                                            UINT32 len,
                                                                            UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 ofs,
                                                                            UINT32 len,
                                                                            UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_IN_SFAIL_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 N,
                                                                          UINT32 mask,
                                                                          UINT32 ofs,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 N,
                                                                          UINT32 mask,
                                                                          UINT32 ofs,
                                                                          UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_IN_SFAIL_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_IN_SFAIL_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 ofs,
                                                                           UINT32 len,
                                                                           UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 ofs,
                                                                           UINT32 len,
                                                                           UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_IN_SFAIL_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_IN_SFAIL_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 ofs,
                                                                                         UINT32 len,
                                                                                         UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 ofs,
                                                                                         UINT32 len,
                                                                                         UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_LOSS_FRME_DELINEATION_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32 N,
                                                                                       UINT32 mask,
                                                                                       UINT32 ofs,
                                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32 N,
                                                                                       UINT32 mask,
                                                                                       UINT32 ofs,
                                                                                       UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_LOSS_FRME_DELINEATION_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_LOSS_FRME_DELINEATION_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 ofs,
                                                                                        UINT32 len,
                                                                                        UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 ofs,
                                                                                        UINT32 len,
                                                                                        UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_LOSS_FRME_DELINEATION_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_LOSS_FRME_DELINEATION_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_IDLE_FRAME_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 N,
                                                                                UINT32 mask,
                                                                                UINT32 ofs,
                                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 N,
                                                                                UINT32 mask,
                                                                                UINT32 ofs,
                                                                                UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_IDLE_FRAME_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_IDLE_FRAME_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_IDLE_FRAME_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_IDLE_FRAME_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                              mapotn_handle_t *h_ptr,
                                                                                              UINT32 ofs,
                                                                                              UINT32 len,
                                                                                              UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                              mapotn_handle_t *h_ptr,
                                                                                              UINT32 ofs,
                                                                                              UINT32 len,
                                                                                              UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                            mapotn_handle_t *h_ptr,
                                                                                            UINT32 N,
                                                                                            UINT32 mask,
                                                                                            UINT32 ofs,
                                                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                            mapotn_handle_t *h_ptr,
                                                                                            UINT32 N,
                                                                                            UINT32 mask,
                                                                                            UINT32 ofs,
                                                                                            UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                             mapotn_handle_t *h_ptr,
                                                                                             UINT32 ofs,
                                                                                             UINT32 len,
                                                                                             UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                             mapotn_handle_t *h_ptr,
                                                                                             UINT32 ofs,
                                                                                             UINT32 len,
                                                                                             UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 ofs,
                                                                               UINT32 len,
                                                                               UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 ofs,
                                                                               UINT32 len,
                                                                               UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_UNPACK_DROP_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_UNPACK_DROP_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_UNPACK_DROP_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 ofs,
                                                                              UINT32 len,
                                                                              UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 ofs,
                                                                              UINT32 len,
                                                                              UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_UNPACK_DROP_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_UNPACK_DROP_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 ofs,
                                                                                                UINT32 len,
                                                                                                UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 ofs,
                                                                                                UINT32 len,
                                                                                                UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                              mapotn_handle_t *h_ptr,
                                                                                              UINT32 N,
                                                                                              UINT32 mask,
                                                                                              UINT32 ofs,
                                                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                              mapotn_handle_t *h_ptr,
                                                                                              UINT32 N,
                                                                                              UINT32 mask,
                                                                                              UINT32 ofs,
                                                                                              UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                               mapotn_handle_t *h_ptr,
                                                                                               UINT32 ofs,
                                                                                               UINT32 len,
                                                                                               UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                               mapotn_handle_t *h_ptr,
                                                                                               UINT32 ofs,
                                                                                               UINT32 len,
                                                                                               UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 ofs,
                                                                                   UINT32 len,
                                                                                   UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 ofs,
                                                                                   UINT32 len,
                                                                                   UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CCHEC_ERROR_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_CCHEC_ERROR_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_CCHEC_ERROR_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_CCHEC_ERROR_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_CCHEC_ERROR_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 ofs,
                                                                                   UINT32 len,
                                                                                   UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 ofs,
                                                                                   UINT32 len,
                                                                                   UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_UTHEC_ERROR_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_UTHEC_ERROR_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_UTHEC_ERROR_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_UTHEC_ERROR_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_UTHEC_ERROR_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 ofs,
                                                                                   UINT32 len,
                                                                                   UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 ofs,
                                                                                   UINT32 len,
                                                                                   UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CTHEC_ERROR_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_CTHEC_ERROR_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_CTHEC_ERROR_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_CTHEC_ERROR_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_CTHEC_ERROR_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 ofs,
                                                                                                UINT32 len,
                                                                                                UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 ofs,
                                                                                                UINT32 len,
                                                                                                UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                              mapotn_handle_t *h_ptr,
                                                                                              UINT32 N,
                                                                                              UINT32 mask,
                                                                                              UINT32 ofs,
                                                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                              mapotn_handle_t *h_ptr,
                                                                                              UINT32 N,
                                                                                              UINT32 mask,
                                                                                              UINT32 ofs,
                                                                                              UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                               mapotn_handle_t *h_ptr,
                                                                                               UINT32 ofs,
                                                                                               UINT32 len,
                                                                                               UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                               mapotn_handle_t *h_ptr,
                                                                                               UINT32 ofs,
                                                                                               UINT32 len,
                                                                                               UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 ofs,
                                                                                   UINT32 len,
                                                                                   UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 ofs,
                                                                                   UINT32 len,
                                                                                   UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CEHEC_ERROR_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_CEHEC_ERROR_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_CEHEC_ERROR_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_CEHEC_ERROR_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_CEHEC_ERROR_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                          mapotn_handle_t *h_ptr,
                                                                                          UINT32 ofs,
                                                                                          UINT32 len,
                                                                                          UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                          mapotn_handle_t *h_ptr,
                                                                                          UINT32 ofs,
                                                                                          UINT32 len,
                                                                                          UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 N,
                                                                                        UINT32 mask,
                                                                                        UINT32 ofs,
                                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 N,
                                                                                        UINT32 mask,
                                                                                        UINT32 ofs,
                                                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 ofs,
                                                                                         UINT32 len,
                                                                                         UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 ofs,
                                                                                         UINT32 len,
                                                                                         UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                     mapotn_handle_t *h_ptr,
                                                                                     UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                     mapotn_handle_t *h_ptr,
                                                                                     UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32 ofs,
                                                                                       UINT32 len,
                                                                                       UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32 ofs,
                                                                                       UINT32 len,
                                                                                       UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                     mapotn_handle_t *h_ptr,
                                                                                     UINT32 N,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                     mapotn_handle_t *h_ptr,
                                                                                     UINT32 N,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 ofs,
                                                                                      UINT32 len,
                                                                                      UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 ofs,
                                                                                      UINT32 len,
                                                                                      UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                              mapotn_handle_t *h_ptr,
                                                                                              UINT32 ofs,
                                                                                              UINT32 len,
                                                                                              UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                              mapotn_handle_t *h_ptr,
                                                                                              UINT32 ofs,
                                                                                              UINT32 len,
                                                                                              UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                            mapotn_handle_t *h_ptr,
                                                                                            UINT32 N,
                                                                                            UINT32 mask,
                                                                                            UINT32 ofs,
                                                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                            mapotn_handle_t *h_ptr,
                                                                                            UINT32 N,
                                                                                            UINT32 mask,
                                                                                            UINT32 ofs,
                                                                                            UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                             mapotn_handle_t *h_ptr,
                                                                                             UINT32 ofs,
                                                                                             UINT32 len,
                                                                                             UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                             mapotn_handle_t *h_ptr,
                                                                                             UINT32 ofs,
                                                                                             UINT32 len,
                                                                                             UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 ofs,
                                                                           UINT32 len,
                                                                           UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 ofs,
                                                                           UINT32 len,
                                                                           UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CSF_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 N,
                                                                         UINT32 mask,
                                                                         UINT32 ofs,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 N,
                                                                         UINT32 mask,
                                                                         UINT32 ofs,
                                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_CSF_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_CSF_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 ofs,
                                                                          UINT32 len,
                                                                          UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 ofs,
                                                                          UINT32 len,
                                                                          UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_CSF_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_CSF_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                     mapotn_handle_t *h_ptr,
                                                                                     UINT32 ofs,
                                                                                     UINT32 len,
                                                                                     UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                     mapotn_handle_t *h_ptr,
                                                                                     UINT32 ofs,
                                                                                     UINT32 len,
                                                                                     UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_DROPPED_FRAME_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 N,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 N,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_DROPPED_FRAME_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_DROPPED_FRAME_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 ofs,
                                                                                    UINT32 len,
                                                                                    UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 ofs,
                                                                                    UINT32 len,
                                                                                    UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_DROPPED_FRAME_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_DROPPED_FRAME_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 ofs,
                                                                                         UINT32 len,
                                                                                         UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 ofs,
                                                                                         UINT32 len,
                                                                                         UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CLIENT_DATA_FRAME_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32 N,
                                                                                       UINT32 mask,
                                                                                       UINT32 ofs,
                                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32 N,
                                                                                       UINT32 mask,
                                                                                       UINT32 ofs,
                                                                                       UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_CLIENT_DATA_FRAME_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 ofs,
                                                                                        UINT32 len,
                                                                                        UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 ofs,
                                                                                        UINT32 len,
                                                                                        UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_CLIENT_DATA_FRAME_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_CLIENT_DATA_FRAME_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 ofs,
                                                                         UINT32 len,
                                                                         UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 ofs,
                                                                         UINT32 len,
                                                                         UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_PAUSE_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 N,
                                                                       UINT32 mask,
                                                                       UINT32 ofs,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 N,
                                                                       UINT32 mask,
                                                                       UINT32 ofs,
                                                                       UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_PAUSE_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_PAUSE_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 ofs,
                                                                        UINT32 len,
                                                                        UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 ofs,
                                                                        UINT32 len,
                                                                        UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_PAUSE_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_PAUSE_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_MAX_FL_VIOALT_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 N,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 N,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_MAX_FL_VIOALT_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_MAX_FL_VIOALT_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 ofs,
                                                                                UINT32 len,
                                                                                UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 ofs,
                                                                                UINT32 len,
                                                                                UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_MAX_FL_VIOALT_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_MAX_FL_VIOALT_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_MIN_FL_VIOALT_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 N,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 N,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_MIN_FL_VIOALT_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_MIN_FL_VIOALT_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 ofs,
                                                                                UINT32 len,
                                                                                UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 ofs,
                                                                                UINT32 len,
                                                                                UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_MIN_FL_VIOALT_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_MIN_FL_VIOALT_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 ofs,
                                                                               UINT32 len,
                                                                               UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 ofs,
                                                                               UINT32 len,
                                                                               UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_PAYLOAD_FCS_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_PAYLOAD_FCS_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_PAYLOAD_FCS_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 ofs,
                                                                              UINT32 len,
                                                                              UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 ofs,
                                                                              UINT32 len,
                                                                              UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_PAYLOAD_FCS_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_PAYLOAD_FCS_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_DOWNSTRM_FRAME_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 N,
                                                                                UINT32 mask,
                                                                                UINT32 ofs,
                                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 N,
                                                                                UINT32 mask,
                                                                                UINT32 ofs,
                                                                                UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_DOWNSTRM_FRAME_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_DOWNSTRM_FRAME_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_DOWNSTRM_FRAME_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_DOWNSTRM_FRAME_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 ofs,
                                                                                    UINT32 len,
                                                                                    UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 ofs,
                                                                                    UINT32 len,
                                                                                    UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_CPU_FIFO_DATA_AV_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 N,
                                                                                  UINT32 mask,
                                                                                  UINT32 ofs,
                                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 N,
                                                                                  UINT32 mask,
                                                                                  UINT32 ofs,
                                                                                  UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_CPU_FIFO_DATA_AV_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_CPU_FIFO_DATA_AV_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 ofs,
                                                                                   UINT32 len,
                                                                                   UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 ofs,
                                                                                   UINT32 len,
                                                                                   UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_CPU_FIFO_DATA_AV_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_CPU_FIFO_DATA_AV_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                          mapotn_handle_t *h_ptr,
                                                                                          UINT32 ofs,
                                                                                          UINT32 len,
                                                                                          UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                          mapotn_handle_t *h_ptr,
                                                                                          UINT32 ofs,
                                                                                          UINT32 len,
                                                                                          UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 N,
                                                                                        UINT32 mask,
                                                                                        UINT32 ofs,
                                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 N,
                                                                                        UINT32 mask,
                                                                                        UINT32 ofs,
                                                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 ofs,
                                                                                         UINT32 len,
                                                                                         UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 ofs,
                                                                                         UINT32 len,
                                                                                         UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                     mapotn_handle_t *h_ptr,
                                                                                     UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                     mapotn_handle_t *h_ptr,
                                                                                     UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_SSF_SF_INT_EN_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 ofs,
                                                                     UINT32 len,
                                                                     UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_SSF_SF_INT_EN_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 ofs,
                                                                     UINT32 len,
                                                                     UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_SSF_SF_INT_EN_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_SSF_SF_INT_EN_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_SSF_SF_INT_EN(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_SSF_SF_INT_EN_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 N,
                                                                   UINT32 mask,
                                                                   UINT32 ofs,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_SSF_SF_INT_EN_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 N,
                                                                   UINT32 mask,
                                                                   UINT32 ofs,
                                                                   UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_SSF_SF_INT_EN_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_SSF_SF_INT_EN(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_SSF_SF_INT_EN_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_SSF_SF_INT_EN_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 ofs,
                                                                    UINT32 len,
                                                                    UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_SSF_SF_INT_EN_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 ofs,
                                                                    UINT32 len,
                                                                    UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_SSF_SF_INT_EN_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_SSF_SF_INT_EN(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_SSF_SF_INT_EN_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_SSF_SF_INT_EN_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_SSF_SF_INT_EN_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_SSF_SF_INT_EN(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_SSF_SF_INT_EN_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 ofs,
                                                                       UINT32 len,
                                                                       UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 ofs,
                                                                       UINT32 len,
                                                                       UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_HAO_STAT_INT_EN(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 N,
                                                                     UINT32 mask,
                                                                     UINT32 ofs,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 N,
                                                                     UINT32 mask,
                                                                     UINT32 ofs,
                                                                     UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_HAO_STAT_INT_EN(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_HAO_STAT_INT_EN_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 ofs,
                                                                      UINT32 len,
                                                                      UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 ofs,
                                                                      UINT32 len,
                                                                      UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_HAO_STAT_INT_EN(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_HAO_STAT_INT_EN(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_DPLM_INT_EN_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 ofs,
                                                                   UINT32 len,
                                                                   UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DPLM_INT_EN_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 ofs,
                                                                   UINT32 len,
                                                                   UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_DPLM_INT_EN_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_DPLM_INT_EN_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_DPLM_INT_EN(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_DPLM_INT_EN_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 N,
                                                                 UINT32 mask,
                                                                 UINT32 ofs,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DPLM_INT_EN_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 N,
                                                                 UINT32 mask,
                                                                 UINT32 ofs,
                                                                 UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_DPLM_INT_EN_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_DPLM_INT_EN(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_DPLM_INT_EN_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_DPLM_INT_EN_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 ofs,
                                                                  UINT32 len,
                                                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DPLM_INT_EN_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 ofs,
                                                                  UINT32 len,
                                                                  UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_DPLM_INT_EN_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_DPLM_INT_EN(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_DPLM_INT_EN_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_DPLM_INT_EN_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_DPLM_INT_EN_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_DPLM_INT_EN(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_DPLM_INT_EN_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 ofs,
                                                                      UINT32 len,
                                                                      UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 ofs,
                                                                      UINT32 len,
                                                                      UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_OPU_CSF_INT_EN(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 N,
                                                                    UINT32 mask,
                                                                    UINT32 ofs,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 N,
                                                                    UINT32 mask,
                                                                    UINT32 ofs,
                                                                    UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_OPU_CSF_INT_EN(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_OPU_CSF_INT_EN_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE void mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 ofs,
                                                                     UINT32 len,
                                                                     UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 ofs,
                                                                     UINT32 len,
                                                                     UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_OPU_CSF_INT_EN(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_OPU_CSF_INT_EN(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_CSF_ST_AV_INTR_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CSF_ST_AV_INTR_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_CSF_ST_AV_INTR_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_CSF_ST_AV_INTR,
                            value);
}

static INLINE void mapotn_rgfpf_reg_CSF_ST_AV_INTR_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 mask,
                                                                              UINT32 ofs,
                                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CSF_ST_AV_INTR_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 mask,
                                                                              UINT32 ofs,
                                                                              UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_CSF_ST_AV_INTR_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_CSF_ST_AV_INTR,
                                            mask,
                                            ofs,
                                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_CSF_ST_AV_INTR_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CSF_ST_AV_INTR_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_CSF_ST_AV_INTR);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_CSF_ST_AV_INTR_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_CSF_ST_AV_INTR_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 mask,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_CSF_ST_AV_INTR_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 mask,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_CSF_ST_AV_INTR_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_CSF_ST_AV_INTR,
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_CSF_ST_FIFO_OF_INTR_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CSF_ST_FIFO_OF_INTR_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_CSF_ST_FIFO_OF_INTR_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_CSF_ST_FIFO_OF_INTR,
                            value);
}

static INLINE void mapotn_rgfpf_reg_CSF_ST_FIFO_OF_INTR_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CSF_ST_FIFO_OF_INTR_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_CSF_ST_FIFO_OF_INTR_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_CSF_ST_FIFO_OF_INTR,
                                            mask,
                                            ofs,
                                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_CSF_ST_FIFO_OF_INTR_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CSF_ST_FIFO_OF_INTR_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_CSF_ST_FIFO_OF_INTR);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_CSF_ST_FIFO_OF_INTR_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_CSF_ST_FIFO_OF_INTR_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 mask,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_CSF_ST_FIFO_OF_INTR_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 mask,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_CSF_ST_FIFO_OF_INTR_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_CSF_ST_FIFO_OF_INTR,
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_PMON_TRANSFER_INTR_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PMON_TRANSFER_INTR_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_PMON_TRANSFER_INTR_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR,
                            value);
}

static INLINE void mapotn_rgfpf_reg_PMON_TRANSFER_INTR_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 mask,
                                                                                  UINT32 ofs,
                                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PMON_TRANSFER_INTR_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 mask,
                                                                                  UINT32 ofs,
                                                                                  UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_PMON_TRANSFER_INTR_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR,
                                            mask,
                                            ofs,
                                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_PMON_TRANSFER_INTR_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_PMON_TRANSFER_INTR_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_PMON_TRANSFER_INTR_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_PMON_TRANSFER_INTR_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 mask,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_PMON_TRANSFER_INTR_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 mask,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_PMON_TRANSFER_INTR_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR,
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR,
                            value);
}

static INLINE void mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR,
                                            mask,
                                            ofs,
                                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 mask,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 mask,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR,
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_RCOH_STAT_TRANSFER_DONE_INT_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_RCOH_STAT_TRANSFER_DONE_INT_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_RCOH_STAT_TRANSFER_DONE_INT_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_RCOH_STAT_TRANSFER_DONE_INT,
                            value);
}

static INLINE void mapotn_rgfpf_reg_RCOH_STAT_TRANSFER_DONE_INT_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 mask,
                                                                                           UINT32 ofs,
                                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_RCOH_STAT_TRANSFER_DONE_INT_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 mask,
                                                                                           UINT32 ofs,
                                                                                           UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_RCOH_STAT_TRANSFER_DONE_INT_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_RCOH_STAT_TRANSFER_DONE_INT,
                                            mask,
                                            ofs,
                                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_RCOH_STAT_TRANSFER_DONE_INT_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_RCOH_STAT_TRANSFER_DONE_INT_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_RCOH_STAT_TRANSFER_DONE_INT);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_RCOH_STAT_TRANSFER_DONE_INT_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_RCOH_STAT_TRANSFER_DONE_INT_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 mask,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_RCOH_STAT_TRANSFER_DONE_INT_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 mask,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_RCOH_STAT_TRANSFER_DONE_INT_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_RCOH_STAT_TRANSFER_DONE_INT,
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  M,
                                                                         UINT32 ofs,
                                                                         UINT32 len,
                                                                         UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  M,
                                                                         UINT32 ofs,
                                                                         UINT32 len,
                                                                         UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words M=%d ofs=%d len=%d", "mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_burst_write", 3, M, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_INTR(ofs,M),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32  M,
                                                                                       UINT32 N,
                                                                                       UINT32 mask,
                                                                                       UINT32 ofs,
                                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32  M,
                                                                                       UINT32 N,
                                                                                       UINT32 mask,
                                                                                       UINT32 ofs,
                                                                                       UINT32 value )
{
    IOLOG( "%s <- M=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_action_on_write_field_set", M, mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_INTR(N,M),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  M,
                                                                        UINT32 ofs,
                                                                        UINT32 len,
                                                                        UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  M,
                                                                        UINT32 ofs,
                                                                        UINT32 len,
                                                                        UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_INTR(ofs,M),
                             len,
                             value);

    IOLOG( "%s of %d words M=%d ofs=%d len=%d", "mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_burst_read", 3, M, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  M,
                                                                    UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  M,
                                                                    UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_INTR(N,M));

    IOLOG( "%s -> 0x%08x; M=%d", "mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_read", reg_value, M);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32  M,
                                                                                  UINT32 N,
                                                                                  UINT32 mask,
                                                                                  UINT32 value,
                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                  UINT32 max_count,
                                                                                  UINT32 *num_failed_polls,
                                                                                  UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32  M,
                                                                                  UINT32 N,
                                                                                  UINT32 mask,
                                                                                  UINT32 value,
                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                  UINT32 max_count,
                                                                                  UINT32 *num_failed_polls,
                                                                                  UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_INTR(N,M),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_IN_SFAIL_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 ofs,
                                                                     UINT32 len,
                                                                     UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_IN_SFAIL_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 ofs,
                                                                     UINT32 len,
                                                                     UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_IN_SFAIL_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_IN_SFAIL_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_IN_SFAIL_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_IN_SFAIL_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 N,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_IN_SFAIL_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 N,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_IN_SFAIL_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_IN_SFAIL_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_IN_SFAIL_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 ofs,
                                                                    UINT32 len,
                                                                    UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_IN_SFAIL_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 ofs,
                                                                    UINT32 len,
                                                                    UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_IN_SFAIL_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_IN_SFAIL_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_IN_SFAIL_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_IN_SFAIL_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_IN_SFAIL_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_IN_SFAIL_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_IN_SFAIL_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_IN_SFAIL_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N,
                                                                              UINT32 mask,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_IN_SFAIL_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N,
                                                                              UINT32 mask,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_IN_SFAIL_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_IN_SFAIL_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_LOSS_FRME_DELINEATION_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 N,
                                                                                                UINT32 mask,
                                                                                                UINT32 ofs,
                                                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 N,
                                                                                                UINT32 mask,
                                                                                                UINT32 ofs,
                                                                                                UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_LOSS_FRME_DELINEATION_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_LOSS_FRME_DELINEATION_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_LOSS_FRME_DELINEATION_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N,
                                                                                           UINT32 mask,
                                                                                           UINT32 value,
                                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                                           UINT32 max_count,
                                                                                           UINT32 *num_failed_polls,
                                                                                           UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N,
                                                                                           UINT32 mask,
                                                                                           UINT32 value,
                                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                                           UINT32 max_count,
                                                                                           UINT32 *num_failed_polls,
                                                                                           UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_LOSS_FRME_DELINEATION_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 ofs,
                                                                           UINT32 len,
                                                                           UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 ofs,
                                                                           UINT32 len,
                                                                           UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_IDLE_FRAME_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 N,
                                                                                         UINT32 mask,
                                                                                         UINT32 ofs,
                                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 N,
                                                                                         UINT32 mask,
                                                                                         UINT32 ofs,
                                                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_GFP_IDLE_FRAME_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 ofs,
                                                                          UINT32 len,
                                                                          UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 ofs,
                                                                          UINT32 len,
                                                                          UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_IDLE_FRAME_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_IDLE_FRAME_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N,
                                                                                    UINT32 mask,
                                                                                    UINT32 value,
                                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                                    UINT32 max_count,
                                                                                    UINT32 *num_failed_polls,
                                                                                    UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N,
                                                                                    UINT32 mask,
                                                                                    UINT32 value,
                                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                                    UINT32 max_count,
                                                                                    UINT32 *num_failed_polls,
                                                                                    UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_IDLE_FRAME_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32 ofs,
                                                                                       UINT32 len,
                                                                                       UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32 ofs,
                                                                                       UINT32 len,
                                                                                       UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_NON_IDLE_CONTROL_FRAME_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                     mapotn_handle_t *h_ptr,
                                                                                                     UINT32 N,
                                                                                                     UINT32 mask,
                                                                                                     UINT32 ofs,
                                                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                     mapotn_handle_t *h_ptr,
                                                                                                     UINT32 N,
                                                                                                     UINT32 mask,
                                                                                                     UINT32 ofs,
                                                                                                     UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_GFP_NON_IDLE_CONTROL_FRAME_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 ofs,
                                                                                      UINT32 len,
                                                                                      UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 ofs,
                                                                                      UINT32 len,
                                                                                      UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_NON_IDLE_CONTROL_FRAME_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_NON_IDLE_CONTROL_FRAME_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 N,
                                                                                                UINT32 mask,
                                                                                                UINT32 value,
                                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                UINT32 max_count,
                                                                                                UINT32 *num_failed_polls,
                                                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 N,
                                                                                                UINT32 mask,
                                                                                                UINT32 value,
                                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                UINT32 max_count,
                                                                                                UINT32 *num_failed_polls,
                                                                                                UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_NON_IDLE_CONTROL_FRAME_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 ofs,
                                                                        UINT32 len,
                                                                        UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 ofs,
                                                                        UINT32 len,
                                                                        UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_UNPACK_DROP_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 N,
                                                                                      UINT32 mask,
                                                                                      UINT32 ofs,
                                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 N,
                                                                                      UINT32 mask,
                                                                                      UINT32 ofs,
                                                                                      UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_UNPACK_DROP_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 ofs,
                                                                       UINT32 len,
                                                                       UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 ofs,
                                                                       UINT32 len,
                                                                       UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_UNPACK_DROP_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_UNPACK_DROP_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_UNPACK_DROP_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 ofs,
                                                                            UINT32 len,
                                                                            UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 ofs,
                                                                            UINT32 len,
                                                                            UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_UCHEC_ERROR_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                          mapotn_handle_t *h_ptr,
                                                                                          UINT32 N,
                                                                                          UINT32 mask,
                                                                                          UINT32 ofs,
                                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                          mapotn_handle_t *h_ptr,
                                                                                          UINT32 N,
                                                                                          UINT32 mask,
                                                                                          UINT32 ofs,
                                                                                          UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_GFP_UCHEC_ERROR_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 ofs,
                                                                           UINT32 len,
                                                                           UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 ofs,
                                                                           UINT32 len,
                                                                           UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_UCHEC_ERROR_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_UCHEC_ERROR_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                     mapotn_handle_t *h_ptr,
                                                                                     UINT32 N,
                                                                                     UINT32 mask,
                                                                                     UINT32 value,
                                                                                     PMC_POLL_COMPARISON_TYPE cmp,
                                                                                     UINT32 max_count,
                                                                                     UINT32 *num_failed_polls,
                                                                                     UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                     mapotn_handle_t *h_ptr,
                                                                                     UINT32 N,
                                                                                     UINT32 mask,
                                                                                     UINT32 value,
                                                                                     PMC_POLL_COMPARISON_TYPE cmp,
                                                                                     UINT32 max_count,
                                                                                     UINT32 *num_failed_polls,
                                                                                     UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_UCHEC_ERROR_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CCHEC_ERROR_ERROR_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 N,
                                                                                                UINT32 mask,
                                                                                                UINT32 ofs,
                                                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 N,
                                                                                                UINT32 mask,
                                                                                                UINT32 ofs,
                                                                                                UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_GFP_CCHEC_ERROR_ERROR_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_CCHEC_ERROR_ERROR_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_CCHEC_ERROR_ERROR_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N,
                                                                                           UINT32 mask,
                                                                                           UINT32 value,
                                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                                           UINT32 max_count,
                                                                                           UINT32 *num_failed_polls,
                                                                                           UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N,
                                                                                           UINT32 mask,
                                                                                           UINT32 value,
                                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                                           UINT32 max_count,
                                                                                           UINT32 *num_failed_polls,
                                                                                           UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CCHEC_ERROR_ERROR_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 ofs,
                                                                                         UINT32 len,
                                                                                         UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 ofs,
                                                                                         UINT32 len,
                                                                                         UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_THEC_ERROR_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                       mapotn_handle_t *h_ptr,
                                                                                                       UINT32 N,
                                                                                                       UINT32 mask,
                                                                                                       UINT32 ofs,
                                                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                       mapotn_handle_t *h_ptr,
                                                                                                       UINT32 N,
                                                                                                       UINT32 mask,
                                                                                                       UINT32 ofs,
                                                                                                       UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_THEC_ERROR_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 ofs,
                                                                                        UINT32 len,
                                                                                        UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 ofs,
                                                                                        UINT32 len,
                                                                                        UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_THEC_ERROR_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_THEC_ERROR_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                  mapotn_handle_t *h_ptr,
                                                                                                  UINT32 N,
                                                                                                  UINT32 mask,
                                                                                                  UINT32 value,
                                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                  UINT32 max_count,
                                                                                                  UINT32 *num_failed_polls,
                                                                                                  UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                  mapotn_handle_t *h_ptr,
                                                                                                  UINT32 N,
                                                                                                  UINT32 mask,
                                                                                                  UINT32 value,
                                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                  UINT32 max_count,
                                                                                                  UINT32 *num_failed_polls,
                                                                                                  UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_THEC_ERROR_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 ofs,
                                                                            UINT32 len,
                                                                            UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 ofs,
                                                                            UINT32 len,
                                                                            UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CTHEC_ERROR_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                          mapotn_handle_t *h_ptr,
                                                                                          UINT32 N,
                                                                                          UINT32 mask,
                                                                                          UINT32 ofs,
                                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                          mapotn_handle_t *h_ptr,
                                                                                          UINT32 N,
                                                                                          UINT32 mask,
                                                                                          UINT32 ofs,
                                                                                          UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_GFP_CTHEC_ERROR_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 ofs,
                                                                           UINT32 len,
                                                                           UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 ofs,
                                                                           UINT32 len,
                                                                           UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_CTHEC_ERROR_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_CTHEC_ERROR_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                     mapotn_handle_t *h_ptr,
                                                                                     UINT32 N,
                                                                                     UINT32 mask,
                                                                                     UINT32 value,
                                                                                     PMC_POLL_COMPARISON_TYPE cmp,
                                                                                     UINT32 max_count,
                                                                                     UINT32 *num_failed_polls,
                                                                                     UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                     mapotn_handle_t *h_ptr,
                                                                                     UINT32 N,
                                                                                     UINT32 mask,
                                                                                     UINT32 value,
                                                                                     PMC_POLL_COMPARISON_TYPE cmp,
                                                                                     UINT32 max_count,
                                                                                     UINT32 *num_failed_polls,
                                                                                     UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CTHEC_ERROR_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 ofs,
                                                                                         UINT32 len,
                                                                                         UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 ofs,
                                                                                         UINT32 len,
                                                                                         UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_EHEC_ERROR_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                       mapotn_handle_t *h_ptr,
                                                                                                       UINT32 N,
                                                                                                       UINT32 mask,
                                                                                                       UINT32 ofs,
                                                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                       mapotn_handle_t *h_ptr,
                                                                                                       UINT32 N,
                                                                                                       UINT32 mask,
                                                                                                       UINT32 ofs,
                                                                                                       UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_EHEC_ERROR_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 ofs,
                                                                                        UINT32 len,
                                                                                        UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 ofs,
                                                                                        UINT32 len,
                                                                                        UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_EHEC_ERROR_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_EHEC_ERROR_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                  mapotn_handle_t *h_ptr,
                                                                                                  UINT32 N,
                                                                                                  UINT32 mask,
                                                                                                  UINT32 value,
                                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                  UINT32 max_count,
                                                                                                  UINT32 *num_failed_polls,
                                                                                                  UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                  mapotn_handle_t *h_ptr,
                                                                                                  UINT32 N,
                                                                                                  UINT32 mask,
                                                                                                  UINT32 value,
                                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                  UINT32 max_count,
                                                                                                  UINT32 *num_failed_polls,
                                                                                                  UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_UNCORRECTABLE_EHEC_ERROR_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CEHEC_ERROR_ERROR_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 N,
                                                                                                UINT32 mask,
                                                                                                UINT32 ofs,
                                                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 N,
                                                                                                UINT32 mask,
                                                                                                UINT32 ofs,
                                                                                                UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_GFP_CEHEC_ERROR_ERROR_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_CEHEC_ERROR_ERROR_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_CEHEC_ERROR_ERROR_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N,
                                                                                           UINT32 mask,
                                                                                           UINT32 value,
                                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                                           UINT32 max_count,
                                                                                           UINT32 *num_failed_polls,
                                                                                           UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N,
                                                                                           UINT32 mask,
                                                                                           UINT32 value,
                                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                                           UINT32 max_count,
                                                                                           UINT32 *num_failed_polls,
                                                                                           UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CEHEC_ERROR_ERROR_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 ofs,
                                                                                   UINT32 len,
                                                                                   UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 ofs,
                                                                                   UINT32 len,
                                                                                   UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_EXI_MISMATCH_ERROR_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                 mapotn_handle_t *h_ptr,
                                                                                                 UINT32 N,
                                                                                                 UINT32 mask,
                                                                                                 UINT32 ofs,
                                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                 mapotn_handle_t *h_ptr,
                                                                                                 UINT32 N,
                                                                                                 UINT32 mask,
                                                                                                 UINT32 ofs,
                                                                                                 UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_GFP_EXI_MISMATCH_ERROR_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_EXI_MISMATCH_ERROR_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_EXI_MISMATCH_ERROR_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                            mapotn_handle_t *h_ptr,
                                                                                            UINT32 N,
                                                                                            UINT32 mask,
                                                                                            UINT32 value,
                                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                                            UINT32 max_count,
                                                                                            UINT32 *num_failed_polls,
                                                                                            UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                            mapotn_handle_t *h_ptr,
                                                                                            UINT32 N,
                                                                                            UINT32 mask,
                                                                                            UINT32 value,
                                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                                            UINT32 max_count,
                                                                                            UINT32 *num_failed_polls,
                                                                                            UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_EXI_MISMATCH_ERROR_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 ofs,
                                                                                UINT32 len,
                                                                                UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 ofs,
                                                                                UINT32 len,
                                                                                UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_PTI_UPI_MSM_ERR_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                              mapotn_handle_t *h_ptr,
                                                                                              UINT32 N,
                                                                                              UINT32 mask,
                                                                                              UINT32 ofs,
                                                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                              mapotn_handle_t *h_ptr,
                                                                                              UINT32 N,
                                                                                              UINT32 mask,
                                                                                              UINT32 ofs,
                                                                                              UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_GFP_PTI_UPI_MSM_ERR_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 ofs,
                                                                               UINT32 len,
                                                                               UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 ofs,
                                                                               UINT32 len,
                                                                               UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_PTI_UPI_MSM_ERR_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_PTI_UPI_MSM_ERR_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 N,
                                                                                         UINT32 mask,
                                                                                         UINT32 value,
                                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                                         UINT32 max_count,
                                                                                         UINT32 *num_failed_polls,
                                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                         mapotn_handle_t *h_ptr,
                                                                                         UINT32 N,
                                                                                         UINT32 mask,
                                                                                         UINT32 value,
                                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                                         UINT32 max_count,
                                                                                         UINT32 *num_failed_polls,
                                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_PTI_UPI_MSM_ERR_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32 ofs,
                                                                                       UINT32 len,
                                                                                       UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32 ofs,
                                                                                       UINT32 len,
                                                                                       UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_GENERIC_MISMATCH_ERROR_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                     mapotn_handle_t *h_ptr,
                                                                                                     UINT32 N,
                                                                                                     UINT32 mask,
                                                                                                     UINT32 ofs,
                                                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                     mapotn_handle_t *h_ptr,
                                                                                                     UINT32 N,
                                                                                                     UINT32 mask,
                                                                                                     UINT32 ofs,
                                                                                                     UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_GFP_GENERIC_MISMATCH_ERROR_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 ofs,
                                                                                      UINT32 len,
                                                                                      UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 ofs,
                                                                                      UINT32 len,
                                                                                      UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_GENERIC_MISMATCH_ERROR_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_GENERIC_MISMATCH_ERROR_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 N,
                                                                                                UINT32 mask,
                                                                                                UINT32 value,
                                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                UINT32 max_count,
                                                                                                UINT32 *num_failed_polls,
                                                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 N,
                                                                                                UINT32 mask,
                                                                                                UINT32 value,
                                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                UINT32 max_count,
                                                                                                UINT32 *num_failed_polls,
                                                                                                UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_GENERIC_MISMATCH_ERROR_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_CSF_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 ofs,
                                                                    UINT32 len,
                                                                    UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CSF_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 ofs,
                                                                    UINT32 len,
                                                                    UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CSF_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CSF_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CSF_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CSF_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 N,
                                                                                  UINT32 mask,
                                                                                  UINT32 ofs,
                                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CSF_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 N,
                                                                                  UINT32 mask,
                                                                                  UINT32 ofs,
                                                                                  UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_CSF_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_GFP_CSF_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CSF_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 ofs,
                                                                   UINT32 len,
                                                                   UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CSF_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 ofs,
                                                                   UINT32 len,
                                                                   UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CSF_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_CSF_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CSF_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CSF_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CSF_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_CSF_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_CSF_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_CSF_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N,
                                                                             UINT32 mask,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_CSF_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N,
                                                                             UINT32 mask,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_CSF_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CSF_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 ofs,
                                                                              UINT32 len,
                                                                              UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 ofs,
                                                                              UINT32 len,
                                                                              UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_DROPPED_FRAME_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                            mapotn_handle_t *h_ptr,
                                                                                            UINT32 N,
                                                                                            UINT32 mask,
                                                                                            UINT32 ofs,
                                                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                            mapotn_handle_t *h_ptr,
                                                                                            UINT32 N,
                                                                                            UINT32 mask,
                                                                                            UINT32 ofs,
                                                                                            UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_GFP_DROPPED_FRAME_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 ofs,
                                                                             UINT32 len,
                                                                             UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 ofs,
                                                                             UINT32 len,
                                                                             UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_DROPPED_FRAME_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_DROPPED_FRAME_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32 N,
                                                                                       UINT32 mask,
                                                                                       UINT32 value,
                                                                                       PMC_POLL_COMPARISON_TYPE cmp,
                                                                                       UINT32 max_count,
                                                                                       UINT32 *num_failed_polls,
                                                                                       UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32 N,
                                                                                       UINT32 mask,
                                                                                       UINT32 value,
                                                                                       PMC_POLL_COMPARISON_TYPE cmp,
                                                                                       UINT32 max_count,
                                                                                       UINT32 *num_failed_polls,
                                                                                       UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_DROPPED_FRAME_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CLIENT_DATA_FRAME_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 N,
                                                                                                UINT32 mask,
                                                                                                UINT32 ofs,
                                                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 N,
                                                                                                UINT32 mask,
                                                                                                UINT32 ofs,
                                                                                                UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_GFP_CLIENT_DATA_FRAME_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 ofs,
                                                                                 UINT32 len,
                                                                                 UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_CLIENT_DATA_FRAME_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_CLIENT_DATA_FRAME_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N,
                                                                                           UINT32 mask,
                                                                                           UINT32 value,
                                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                                           UINT32 max_count,
                                                                                           UINT32 *num_failed_polls,
                                                                                           UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N,
                                                                                           UINT32 mask,
                                                                                           UINT32 value,
                                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                                           UINT32 max_count,
                                                                                           UINT32 *num_failed_polls,
                                                                                           UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CLIENT_DATA_FRAME_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_PAUSE_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 ofs,
                                                                  UINT32 len,
                                                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PAUSE_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 ofs,
                                                                  UINT32 len,
                                                                  UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_PAUSE_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_PAUSE_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_PAUSE_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_PAUSE_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 N,
                                                                                UINT32 mask,
                                                                                UINT32 ofs,
                                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PAUSE_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 N,
                                                                                UINT32 mask,
                                                                                UINT32 ofs,
                                                                                UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_PAUSE_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_PAUSE_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_PAUSE_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 ofs,
                                                                 UINT32 len,
                                                                 UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PAUSE_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 ofs,
                                                                 UINT32 len,
                                                                 UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_PAUSE_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_PAUSE_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_PAUSE_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_PAUSE_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_PAUSE_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_PAUSE_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_PAUSE_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_PAUSE_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 N,
                                                                           UINT32 mask,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_PAUSE_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 N,
                                                                           UINT32 mask,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_PAUSE_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_PAUSE_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 ofs,
                                                                                           UINT32 len,
                                                                                           UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 ofs,
                                                                                           UINT32 len,
                                                                                           UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                         mapotn_handle_t *h_ptr,
                                                                                                         UINT32 N,
                                                                                                         UINT32 mask,
                                                                                                         UINT32 ofs,
                                                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                         mapotn_handle_t *h_ptr,
                                                                                                         UINT32 N,
                                                                                                         UINT32 mask,
                                                                                                         UINT32 ofs,
                                                                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                          mapotn_handle_t *h_ptr,
                                                                                          UINT32 ofs,
                                                                                          UINT32 len,
                                                                                          UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                          mapotn_handle_t *h_ptr,
                                                                                          UINT32 ofs,
                                                                                          UINT32 len,
                                                                                          UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                    mapotn_handle_t *h_ptr,
                                                                                                    UINT32 N,
                                                                                                    UINT32 mask,
                                                                                                    UINT32 value,
                                                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                    UINT32 max_count,
                                                                                                    UINT32 *num_failed_polls,
                                                                                                    UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                    mapotn_handle_t *h_ptr,
                                                                                                    UINT32 N,
                                                                                                    UINT32 mask,
                                                                                                    UINT32 value,
                                                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                    UINT32 max_count,
                                                                                                    UINT32 *num_failed_polls,
                                                                                                    UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 ofs,
                                                                                           UINT32 len,
                                                                                           UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 ofs,
                                                                                           UINT32 len,
                                                                                           UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_MINIMUM_FRAME_LENGTH_VIOLATION_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                         mapotn_handle_t *h_ptr,
                                                                                                         UINT32 N,
                                                                                                         UINT32 mask,
                                                                                                         UINT32 ofs,
                                                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                         mapotn_handle_t *h_ptr,
                                                                                                         UINT32 N,
                                                                                                         UINT32 mask,
                                                                                                         UINT32 ofs,
                                                                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_MINIMUM_FRAME_LENGTH_VIOLATION_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                          mapotn_handle_t *h_ptr,
                                                                                          UINT32 ofs,
                                                                                          UINT32 len,
                                                                                          UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                          mapotn_handle_t *h_ptr,
                                                                                          UINT32 ofs,
                                                                                          UINT32 len,
                                                                                          UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_MINIMUM_FRAME_LENGTH_VIOLATION_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_MINIMUM_FRAME_LENGTH_VIOLATION_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                    mapotn_handle_t *h_ptr,
                                                                                                    UINT32 N,
                                                                                                    UINT32 mask,
                                                                                                    UINT32 value,
                                                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                    UINT32 max_count,
                                                                                                    UINT32 *num_failed_polls,
                                                                                                    UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                    mapotn_handle_t *h_ptr,
                                                                                                    UINT32 N,
                                                                                                    UINT32 mask,
                                                                                                    UINT32 value,
                                                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                    UINT32 max_count,
                                                                                                    UINT32 *num_failed_polls,
                                                                                                    UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_MINIMUM_FRAME_LENGTH_VIOLATION_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 ofs,
                                                                        UINT32 len,
                                                                        UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 ofs,
                                                                        UINT32 len,
                                                                        UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_PAYLOAD_FCS_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 N,
                                                                                      UINT32 mask,
                                                                                      UINT32 ofs,
                                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 N,
                                                                                      UINT32 mask,
                                                                                      UINT32 ofs,
                                                                                      UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_PAYLOAD_FCS_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 ofs,
                                                                       UINT32 len,
                                                                       UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 ofs,
                                                                       UINT32 len,
                                                                       UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_PAYLOAD_FCS_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_PAYLOAD_FCS_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_PAYLOAD_FCS_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 ofs,
                                                                             UINT32 len,
                                                                             UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 ofs,
                                                                             UINT32 len,
                                                                             UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_DOWNSTREAM_FRAME_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N,
                                                                                           UINT32 mask,
                                                                                           UINT32 ofs,
                                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N,
                                                                                           UINT32 mask,
                                                                                           UINT32 ofs,
                                                                                           UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_DOWNSTREAM_FRAME_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 ofs,
                                                                            UINT32 len,
                                                                            UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 ofs,
                                                                            UINT32 len,
                                                                            UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_DOWNSTREAM_FRAME_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_DOWNSTREAM_FRAME_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 N,
                                                                                      UINT32 mask,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 N,
                                                                                      UINT32 mask,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_DOWNSTREAM_FRAME_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 ofs,
                                                                             UINT32 len,
                                                                             UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 ofs,
                                                                             UINT32 len,
                                                                             UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_CPU_FIFO_DATA_AV_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N,
                                                                                           UINT32 mask,
                                                                                           UINT32 ofs,
                                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                           mapotn_handle_t *h_ptr,
                                                                                           UINT32 N,
                                                                                           UINT32 mask,
                                                                                           UINT32 ofs,
                                                                                           UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_CPU_FIFO_DATA_AV_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 ofs,
                                                                            UINT32 len,
                                                                            UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 ofs,
                                                                            UINT32 len,
                                                                            UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_CPU_FIFO_DATA_AV_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_CPU_FIFO_DATA_AV_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 N,
                                                                                      UINT32 mask,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 N,
                                                                                      UINT32 mask,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_CPU_FIFO_DATA_AV_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 ofs,
                                                                                   UINT32 len,
                                                                                   UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 ofs,
                                                                                   UINT32 len,
                                                                                   UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_OVERFLOW_INTR(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                 mapotn_handle_t *h_ptr,
                                                                                                 UINT32 N,
                                                                                                 UINT32 mask,
                                                                                                 UINT32 ofs,
                                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                 mapotn_handle_t *h_ptr,
                                                                                                 UINT32 N,
                                                                                                 UINT32 mask,
                                                                                                 UINT32 ofs,
                                                                                                 UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_OVERFLOW_INTR(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 ofs,
                                                                                  UINT32 len,
                                                                                  UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_OVERFLOW_INTR(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_OVERFLOW_INTR(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                            mapotn_handle_t *h_ptr,
                                                                                            UINT32 N,
                                                                                            UINT32 mask,
                                                                                            UINT32 value,
                                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                                            UINT32 max_count,
                                                                                            UINT32 *num_failed_polls,
                                                                                            UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                            mapotn_handle_t *h_ptr,
                                                                                            UINT32 N,
                                                                                            UINT32 mask,
                                                                                            UINT32 value,
                                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                                            UINT32 max_count,
                                                                                            UINT32 *num_failed_polls,
                                                                                            UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_OVERFLOW_INTR(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 ofs,
                                                                      UINT32 len,
                                                                      UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 ofs,
                                                                      UINT32 len,
                                                                      UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_SSF_SF_RCVDINT(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N,
                                                                                    UINT32 mask,
                                                                                    UINT32 ofs,
                                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N,
                                                                                    UINT32 mask,
                                                                                    UINT32 ofs,
                                                                                    UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_SSF_SF_RCVDINT(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 ofs,
                                                                     UINT32 len,
                                                                     UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 ofs,
                                                                     UINT32 len,
                                                                     UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_SSF_SF_RCVDINT(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_SSF_SF_RCVDINT(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 N,
                                                                               UINT32 mask,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 N,
                                                                               UINT32 mask,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_SSF_SF_RCVDINT(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_HAO_STAT_INT_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 ofs,
                                                                    UINT32 len,
                                                                    UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_HAO_STAT_INT_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 ofs,
                                                                    UINT32 len,
                                                                    UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_HAO_STAT_INT_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_HAO_STAT_INT_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_HAO_STAT_INT(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_HAO_STAT_INT_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 N,
                                                                                  UINT32 mask,
                                                                                  UINT32 ofs,
                                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_HAO_STAT_INT_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 N,
                                                                                  UINT32 mask,
                                                                                  UINT32 ofs,
                                                                                  UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_HAO_STAT_INT_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_HAO_STAT_INT(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_HAO_STAT_INT_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 ofs,
                                                                   UINT32 len,
                                                                   UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_HAO_STAT_INT_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 ofs,
                                                                   UINT32 len,
                                                                   UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_HAO_STAT_INT_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_HAO_STAT_INT(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_HAO_STAT_INT_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_HAO_STAT_INT_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_HAO_STAT_INT_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_HAO_STAT_INT(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_HAO_STAT_INT_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_HAO_STAT_INT_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N,
                                                                             UINT32 mask,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_HAO_STAT_INT_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N,
                                                                             UINT32 mask,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_HAO_STAT_INT_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_HAO_STAT_INT(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_DPLM_INT_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 ofs,
                                                                UINT32 len,
                                                                UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DPLM_INT_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 ofs,
                                                                UINT32 len,
                                                                UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_DPLM_INT_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_DPLM_INT_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_DPLM_INT(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_DPLM_INT_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N,
                                                                              UINT32 mask,
                                                                              UINT32 ofs,
                                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DPLM_INT_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 N,
                                                                              UINT32 mask,
                                                                              UINT32 ofs,
                                                                              UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_DPLM_INT_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_DPLM_INT(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_DPLM_INT_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 ofs,
                                                               UINT32 len,
                                                               UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DPLM_INT_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 ofs,
                                                               UINT32 len,
                                                               UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_DPLM_INT_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_DPLM_INT(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_DPLM_INT_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_DPLM_INT_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_DPLM_INT_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_DPLM_INT(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_DPLM_INT_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_DPLM_INT_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 N,
                                                                         UINT32 mask,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_DPLM_INT_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 N,
                                                                         UINT32 mask,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_DPLM_INT_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_DPLM_INT(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_OPU_CSF_INT_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 ofs,
                                                                   UINT32 len,
                                                                   UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_OPU_CSF_INT_array_burst_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 ofs,
                                                                   UINT32 len,
                                                                   UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst write beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_OPU_CSF_INT_array_burst_write", ofs, len, 3 );
    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_OPU_CSF_INT_array_burst_write", 3, ofs, len);
    mapotn_rgfpf_burst_write( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_OPU_CSF_INT(ofs),
                              len,
                              value);

}

static INLINE void mapotn_rgfpf_reg_OPU_CSF_INT_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_OPU_CSF_INT_array_action_on_write_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_OPU_CSF_INT_array_action_on_write_field_set", mask, ofs, value );
    mapotn_rgfpf_action_on_write_field_set( b_ptr,
                                            h_ptr,
                                            MEM_TYPE_STATUS,
                                            PMC_RGFPF96_CORE_REG_OPU_CSF_INT(N),
                                            mask,
                                            ofs,
                                            value);

}

static INLINE void mapotn_rgfpf_reg_OPU_CSF_INT_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 ofs,
                                                                  UINT32 len,
                                                                  UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_OPU_CSF_INT_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 ofs,
                                                                  UINT32 len,
                                                                  UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_OPU_CSF_INT_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_OPU_CSF_INT(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_OPU_CSF_INT_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_OPU_CSF_INT_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_OPU_CSF_INT_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_OPU_CSF_INT(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_OPU_CSF_INT_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_OPU_CSF_INT_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 N,
                                                                            UINT32 mask,
                                                                            UINT32 value,
                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                            UINT32 max_count,
                                                                            UINT32 *num_failed_polls,
                                                                            UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_OPU_CSF_INT_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 N,
                                                                            UINT32 mask,
                                                                            UINT32 value,
                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                            UINT32 max_count,
                                                                            UINT32 *num_failed_polls,
                                                                            UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_OPU_CSF_INT_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_OPU_CSF_INT(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 ofs,
                                                                                                UINT32 len,
                                                                                                UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 ofs,
                                                                                                UINT32 len,
                                                                                                UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                            mapotn_handle_t *h_ptr,
                                                                                            UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                            mapotn_handle_t *h_ptr,
                                                                                            UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                          mapotn_handle_t *h_ptr,
                                                                                                          UINT32 N,
                                                                                                          UINT32 mask,
                                                                                                          UINT32 value,
                                                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                          UINT32 max_count,
                                                                                                          UINT32 *num_failed_polls,
                                                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                          mapotn_handle_t *h_ptr,
                                                                                                          UINT32 N,
                                                                                                          UINT32 mask,
                                                                                                          UINT32 value,
                                                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                          UINT32 max_count,
                                                                                                          UINT32 *num_failed_polls,
                                                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_FRAMER_IDLE_INTERRUPT_VALUE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 ofs,
                                                                                      UINT32 len,
                                                                                      UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_FRAMER_IDLE_INTERRUPT_VALUE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 ofs,
                                                                                      UINT32 len,
                                                                                      UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_FRAMER_IDLE_INTERRUPT_VALUE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_FRAMER_IDLE_INTERRUPT_VALUE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_FRAMER_IDLE_INTERRUPT_VALUE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_FRAMER_IDLE_INTERRUPT_VALUE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_FRAMER_IDLE_INTERRUPT_VALUE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_FRAMER_IDLE_INTERRUPT_VALUE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_FRAMER_IDLE_INTERRUPT_VALUE_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_FRAMER_IDLE_INTERRUPT_VALUE_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 N,
                                                                                                UINT32 mask,
                                                                                                UINT32 value,
                                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                UINT32 max_count,
                                                                                                UINT32 *num_failed_polls,
                                                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_FRAMER_IDLE_INTERRUPT_VALUE_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                mapotn_handle_t *h_ptr,
                                                                                                UINT32 N,
                                                                                                UINT32 mask,
                                                                                                UINT32 value,
                                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                UINT32 max_count,
                                                                                                UINT32 *num_failed_polls,
                                                                                                UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_FRAMER_IDLE_INTERRUPT_VALUE_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_FRAMER_IDLE_INTERRUPT_VALUE(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_CSF_INTERRUPT_VALUE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 ofs,
                                                                              UINT32 len,
                                                                              UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CSF_INTERRUPT_VALUE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 ofs,
                                                                              UINT32 len,
                                                                              UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_CSF_INTERRUPT_VALUE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_CSF_INTERRUPT_VALUE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_CSF_INTERRUPT_VALUE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CSF_INTERRUPT_VALUE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CSF_INTERRUPT_VALUE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_CSF_INTERRUPT_VALUE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_CSF_INTERRUPT_VALUE_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_CSF_INTERRUPT_VALUE_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 N,
                                                                                        UINT32 mask,
                                                                                        UINT32 value,
                                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                                        UINT32 max_count,
                                                                                        UINT32 *num_failed_polls,
                                                                                        UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_CSF_INTERRUPT_VALUE_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 N,
                                                                                        UINT32 mask,
                                                                                        UINT32 value,
                                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                                        UINT32 max_count,
                                                                                        UINT32 *num_failed_polls,
                                                                                        UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_CSF_INTERRUPT_VALUE_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_CSF_INTERRUPT_VALUE(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_VALUE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 ofs,
                                                                                        UINT32 len,
                                                                                        UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_VALUE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                        mapotn_handle_t *h_ptr,
                                                                                        UINT32 ofs,
                                                                                        UINT32 len,
                                                                                        UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_VALUE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_EXI_MISMATCH_ERROR_INTR_VALUE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_VALUE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_VALUE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_VALUE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_EXI_MISMATCH_ERROR_INTR_VALUE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_VALUE_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_VALUE_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                  mapotn_handle_t *h_ptr,
                                                                                                  UINT32 N,
                                                                                                  UINT32 mask,
                                                                                                  UINT32 value,
                                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                  UINT32 max_count,
                                                                                                  UINT32 *num_failed_polls,
                                                                                                  UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_VALUE_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                                  mapotn_handle_t *h_ptr,
                                                                                                  UINT32 N,
                                                                                                  UINT32 mask,
                                                                                                  UINT32 value,
                                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                  UINT32 max_count,
                                                                                                  UINT32 *num_failed_polls,
                                                                                                  UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_VALUE_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_EXI_MISMATCH_ERROR_INTR_VALUE(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_VALUE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                     mapotn_handle_t *h_ptr,
                                                                                     UINT32 ofs,
                                                                                     UINT32 len,
                                                                                     UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_VALUE_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                     mapotn_handle_t *h_ptr,
                                                                                     UINT32 ofs,
                                                                                     UINT32 len,
                                                                                     UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_VALUE_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_GFP_PTI_UPI_MSM_ERR_INTR_VALUE(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_VALUE_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_VALUE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_VALUE_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_PTI_UPI_MSM_ERR_INTR_VALUE(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_VALUE_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_VALUE_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                               mapotn_handle_t *h_ptr,
                                                                                               UINT32 N,
                                                                                               UINT32 mask,
                                                                                               UINT32 value,
                                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                                               UINT32 max_count,
                                                                                               UINT32 *num_failed_polls,
                                                                                               UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_VALUE_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                               mapotn_handle_t *h_ptr,
                                                                                               UINT32 N,
                                                                                               UINT32 mask,
                                                                                               UINT32 value,
                                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                                               UINT32 max_count,
                                                                                               UINT32 *num_failed_polls,
                                                                                               UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_VALUE_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_GFP_PTI_UPI_MSM_ERR_INTR_VALUE(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_IN_SFAIL_INT_VAL_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 ofs,
                                                                       UINT32 len,
                                                                       UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_IN_SFAIL_INT_VAL_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 ofs,
                                                                       UINT32 len,
                                                                       UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_IN_SFAIL_INT_VAL_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_IN_SFAIL_INT_VAL(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_IN_SFAIL_INT_VAL_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_IN_SFAIL_INT_VAL_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_IN_SFAIL_INT_VAL_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_IN_SFAIL_INT_VAL(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_IN_SFAIL_INT_VAL_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_IN_SFAIL_INT_VAL_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_IN_SFAIL_INT_VAL_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 N,
                                                                                 UINT32 mask,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_IN_SFAIL_INT_VAL_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_IN_SFAIL_INT_VAL(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_SSF_SF_RCVD_INT_VAL_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 ofs,
                                                                          UINT32 len,
                                                                          UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_SSF_SF_RCVD_INT_VAL_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 ofs,
                                                                          UINT32 len,
                                                                          UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_SSF_SF_RCVD_INT_VAL_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_SSF_SF_RCVD_INT_VAL(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_SSF_SF_RCVD_INT_VAL_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_SSF_SF_RCVD_INT_VAL_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_SSF_SF_RCVD_INT_VAL_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_SSF_SF_RCVD_INT_VAL(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_SSF_SF_RCVD_INT_VAL_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_SSF_SF_RCVD_INT_VAL_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N,
                                                                                    UINT32 mask,
                                                                                    UINT32 value,
                                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                                    UINT32 max_count,
                                                                                    UINT32 *num_failed_polls,
                                                                                    UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_SSF_SF_RCVD_INT_VAL_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 N,
                                                                                    UINT32 mask,
                                                                                    UINT32 value,
                                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                                    UINT32 max_count,
                                                                                    UINT32 *num_failed_polls,
                                                                                    UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_SSF_SF_RCVD_INT_VAL_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_SSF_SF_RCVD_INT_VAL(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_DPLM_INT_VAL_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 ofs,
                                                                   UINT32 len,
                                                                   UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_DPLM_INT_VAL_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 ofs,
                                                                   UINT32 len,
                                                                   UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_DPLM_INT_VAL_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_DPLM_INT_VAL(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_DPLM_INT_VAL_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_DPLM_INT_VAL_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_DPLM_INT_VAL_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_DPLM_INT_VAL(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_DPLM_INT_VAL_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_DPLM_INT_VAL_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N,
                                                                             UINT32 mask,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_DPLM_INT_VAL_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 N,
                                                                             UINT32 mask,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_DPLM_INT_VAL_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_DPLM_INT_VAL(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_OPU_CSF_INT_VAL_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 ofs,
                                                                      UINT32 len,
                                                                      UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_OPU_CSF_INT_VAL_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 ofs,
                                                                      UINT32 len,
                                                                      UINT32 *value )
{
    if (len + ofs > 3)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_OPU_CSF_INT_VAL_array_burst_read", ofs, len, 3 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_OPU_CSF_INT_VAL(ofs),
                             len,
                             value);

    IOLOG( "%s of %d words ofs=%d len=%d", "mapotn_rgfpf_reg_OPU_CSF_INT_VAL_array_burst_read", 3, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_OPU_CSF_INT_VAL_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_OPU_CSF_INT_VAL_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_OPU_CSF_INT_VAL(N));

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_OPU_CSF_INT_VAL_array_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_OPU_CSF_INT_VAL_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 N,
                                                                                UINT32 mask,
                                                                                UINT32 value,
                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                UINT32 max_count,
                                                                                UINT32 *num_failed_polls,
                                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_reg_OPU_CSF_INT_VAL_array_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32 N,
                                                                                UINT32 mask,
                                                                                UINT32 value,
                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                UINT32 max_count,
                                                                                UINT32 *num_failed_polls,
                                                                                UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "mapotn_rgfpf_reg_OPU_CSF_INT_VAL_array_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return mapotn_rgfpf_poll( b_ptr,
                              h_ptr,
                              MEM_TYPE_STATUS,
                              PMC_RGFPF96_CORE_REG_OPU_CSF_INT_VAL(N),
                              mask,
                              value,
                              cmp,
                              max_count,
                              num_failed_polls,
                              delay_between_polls_in_microseconds);

}


static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_CNT_PMON_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32  M,
                                                                            UINT32 ofs,
                                                                            UINT32 len,
                                                                            UINT32 *value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_CNT_PMON_array_burst_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32  M,
                                                                            UINT32 ofs,
                                                                            UINT32 len,
                                                                            UINT32 *value )
{
    if (len + ofs > 7)
        IO_RANGE_CHECK("%s burst read beyond max (ofs:%d + len:%d) > %d", "mapotn_rgfpf_reg_FRM_LEN_STAT_CNT_PMON_array_burst_read", ofs, len, 7 );
    mapotn_rgfpf_burst_read( b_ptr,
                             h_ptr,
                             MEM_TYPE_STATUS,
                             PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_CNT_PMON(ofs,M),
                             len,
                             value);

    IOLOG( "%s of %d words M=%d ofs=%d len=%d", "mapotn_rgfpf_reg_FRM_LEN_STAT_CNT_PMON_array_burst_read", 7, M, ofs, len);
}

static INLINE UINT32 mapotn_rgfpf_reg_FRM_LEN_STAT_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  M,
                                                                        UINT32 N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_FRM_LEN_STAT_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  M,
                                                                        UINT32 N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_CNT_PMON(N,M));

    IOLOG( "%s -> 0x%08x; M=%d", "mapotn_rgfpf_reg_FRM_LEN_STAT_CNT_PMON_array_read", reg_value, M);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  N,
                                                                        UINT32  M,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  N,
                                                                        UINT32  M,
                                                                        UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0(N,M),
                            value);
}

static INLINE void mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32  N,
                                                                            UINT32  M,
                                                                            UINT32 mask,
                                                                            UINT32 ofs,
                                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32  N,
                                                                            UINT32  M,
                                                                            UINT32 mask,
                                                                            UINT32 ofs,
                                                                            UINT32 value )
{
    IOLOG( "%s <- N=%d M=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set", N, M, mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0(N,M),
                            mask,
                            PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  N,
                                                                         UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  N,
                                                                         UINT32  M )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0(N,M));

    IOLOG( "%s -> 0x%08x; N=%d M=%d", "mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read", reg_value, N, M);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  N,
                                                                        UINT32  M,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  N,
                                                                        UINT32  M,
                                                                        UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1(N,M),
                            value);
}

static INLINE void mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32  N,
                                                                            UINT32  M,
                                                                            UINT32 mask,
                                                                            UINT32 ofs,
                                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32  N,
                                                                            UINT32  M,
                                                                            UINT32 mask,
                                                                            UINT32 ofs,
                                                                            UINT32 value )
{
    IOLOG( "%s <- N=%d M=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_field_set", N, M, mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1(N,M),
                            mask,
                            PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  N,
                                                                         UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  N,
                                                                         UINT32  M )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1(N,M));

    IOLOG( "%s -> 0x%08x; N=%d M=%d", "mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_read", reg_value, N, M);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32  M,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32  M,
                                                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG(N,M),
                            value);
}

static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32  N,
                                                                                 UINT32  M,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32  N,
                                                                                 UINT32  M,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- N=%d M=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_field_set", N, M, mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG(N,M),
                            mask,
                            PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32  N,
                                                                              UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32  N,
                                                                              UINT32  M )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG(N,M));

    IOLOG( "%s -> 0x%08x; N=%d M=%d", "mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_read", reg_value, N, M);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0(N),
                            value);
}

static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32  N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32  N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- N=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_field_set", N, mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_read", reg_value, N);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1(N),
                            value);
}

static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32  N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32  N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- N=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set", N, mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read", reg_value, N);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2(N),
                            value);
}

static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32  N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32  N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- N=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set", N, mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read", reg_value, N);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3(N),
                            value);
}

static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32  N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32  N,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- N=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_field_set", N, mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_read", reg_value, N);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32  N,
                                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32  N,
                                                                                  UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION(N),
                            value);
}

static INLINE void mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32  N,
                                                                                      UINT32 mask,
                                                                                      UINT32 ofs,
                                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32  N,
                                                                                      UINT32 mask,
                                                                                      UINT32 ofs,
                                                                                      UINT32 value )
{
    IOLOG( "%s <- N=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_field_set", N, mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_read", reg_value, N);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32  N,
                                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32  N,
                                                                            UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET(N),
                            value);
}

static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32  N,
                                                                                UINT32 mask,
                                                                                UINT32 ofs,
                                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                mapotn_handle_t *h_ptr,
                                                                                UINT32  N,
                                                                                UINT32 mask,
                                                                                UINT32 ofs,
                                                                                UINT32 value )
{
    IOLOG( "%s <- N=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_field_set", N, mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_CPU_DATA_FIFO_DATA_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CPU_DATA_FIFO_DATA_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_CPU_DATA_FIFO_DATA_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_PAUSE_TIME_REG_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_PAUSE_TIME_REG_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_PAUSE_TIME_REG(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_PAUSE_TIME_REG_array_read", reg_value, N);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_0_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  N,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_0_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  N,
                                                                         UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_0_array_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0(N),
                            value);
}

static INLINE void mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_0_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_0_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value )
{
    IOLOG( "%s <- N=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_0_array_field_set", N, mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_0_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_0_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_0_array_read", reg_value, N);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_1_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  N,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_1_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  N,
                                                                         UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_1_array_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1(N),
                            value);
}

static INLINE void mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_1_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_1_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value )
{
    IOLOG( "%s <- N=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_1_array_field_set", N, mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_1_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_1_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_1_array_read", reg_value, N);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_2_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  N,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_2_array_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  N,
                                                                         UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_2_array_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2(N),
                            value);
}

static INLINE void mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_2_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_2_array_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value )
{
    IOLOG( "%s <- N=%d mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_2_array_field_set", N, mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2(N),
                            mask,
                            PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_2_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_2_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_2_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_RX_BYTE_CNT_PMON_LSB_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_RX_BYTE_CNT_PMON_LSB_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_LSB(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_RX_BYTE_CNT_PMON_LSB_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_RX_BYTE_CNT_PMON_MSB_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_RX_BYTE_CNT_PMON_MSB_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_MSB(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_RX_BYTE_CNT_PMON_MSB_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_RX_FRM_CNT_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_RX_FRM_CNT_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_RX_FRM_CNT(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_RX_FRM_CNT_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_IDLE_FRM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_IDLE_FRM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_IDLE_FRM_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_IDLE_FRM_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_CTRL_FRM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CTRL_FRM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_CTRL_FRM_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_CTRL_FRM_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_ERR_CHEC_CNT_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_ERR_CHEC_CNT_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_ERR_CHEC_CNT(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_ERR_CHEC_CNT_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_SINGL_ERR_CORR_CHEC_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_SINGL_ERR_CORR_CHEC_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_SINGL_ERR_CORR_CHEC_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_SINGL_ERR_CORR_CHEC_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_UNPACK_DROP_FRM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_UNPACK_DROP_FRM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_UNPACK_DROP_FRM_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_UNPACK_DROP_FRM_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_ERR_THEC_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_ERR_THEC_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_ERR_THEC_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_ERR_THEC_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_SINGL_ERR_CORR_TE_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_SINGL_ERR_CORR_TE_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_SINGL_ERR_CORR_TE_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_SINGL_ERR_CORR_TE_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_FILTER_DROP_FRM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_FILTER_DROP_FRM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_FILTER_DROP_FRM_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_FILTER_DROP_FRM_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_DEXM_EHEC_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_DEXM_EHEC_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_DEXM_EHEC_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_DEXM_EHEC_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_DUPM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_DUPM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_DUPM_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_DUPM_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_DGEM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_DGEM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_DGEM_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_DGEM_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_CSF_FRM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CSF_FRM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_CSF_FRM_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_CSF_FRM_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_ERR_FCS_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_ERR_FCS_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_ERR_FCS_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_ERR_FCS_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_PAUSE_FRM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_PAUSE_FRM_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_PAUSE_FRM_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_PAUSE_FRM_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_CPU_OVF_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CPU_OVF_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_CPU_OVF_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_CPU_OVF_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_EGRESS_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_EGRESS_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_EGRESS_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_EGRESS_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_UNPACK_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_UNPACK_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_UNPACK_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_UNPACK_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_MINFL_CHK_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_MINFL_CHK_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_MINFL_CHK_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_MINFL_CHK_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_MAXFL_CHK_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_MAXFL_CHK_CNT_PMON_array_read( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_MAXFL_CHK_CNT_PMON(N));

    IOLOG( "%s -> 0x%08x; N=%d", "mapotn_rgfpf_reg_MAXFL_CHK_CNT_PMON_array_read", reg_value, N);
    return reg_value;
}

static INLINE UINT32 mapotn_rgfpf_reg_CSF_STATUS_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_CSF_STATUS_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_CSF_STATUS);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_CSF_STATUS_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_MUTEX_CPU_DATA_FIFO_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MUTEX_CPU_DATA_FIFO_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_MUTEX_CPU_DATA_FIFO_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_MUTEX_CPU_DATA_FIFO,
                            value);
}

static INLINE void mapotn_rgfpf_reg_MUTEX_CPU_DATA_FIFO_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 mask,
                                                                   UINT32 ofs,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MUTEX_CPU_DATA_FIFO_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 mask,
                                                                   UINT32 ofs,
                                                                   UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_MUTEX_CPU_DATA_FIFO_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_MUTEX_CPU_DATA_FIFO,
                            mask,
                            PMC_RGFPF96_CORE_REG_MUTEX_CPU_DATA_FIFO_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_MUTEX_CPU_DATA_FIFO_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_MUTEX_CPU_DATA_FIFO_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_MUTEX_CPU_DATA_FIFO);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_MUTEX_CPU_DATA_FIFO_read", reg_value);
    return reg_value;
}

static INLINE void mapotn_rgfpf_reg_MUTEX_CSF_STATUS_FIFO_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MUTEX_CSF_STATUS_FIFO_write( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "mapotn_rgfpf_reg_MUTEX_CSF_STATUS_FIFO_write", value );
    mapotn_rgfpf_reg_write( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_MUTEX_CSF_STATUS_FIFO,
                            value);
}

static INLINE void mapotn_rgfpf_reg_MUTEX_CSF_STATUS_FIFO_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 mask,
                                                                     UINT32 ofs,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_reg_MUTEX_CSF_STATUS_FIFO_field_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 mask,
                                                                     UINT32 ofs,
                                                                     UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "mapotn_rgfpf_reg_MUTEX_CSF_STATUS_FIFO_field_set", mask, ofs, value );
    mapotn_rgfpf_field_set( b_ptr,
                            h_ptr,
                            MEM_TYPE_STATUS,
                            PMC_RGFPF96_CORE_REG_MUTEX_CSF_STATUS_FIFO,
                            mask,
                            PMC_RGFPF96_CORE_REG_MUTEX_CSF_STATUS_FIFO_UNUSED_MASK,
                            ofs,
                            value);

}

static INLINE UINT32 mapotn_rgfpf_reg_MUTEX_CSF_STATUS_FIFO_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_reg_MUTEX_CSF_STATUS_FIFO_read( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = mapotn_rgfpf_reg_read( b_ptr,
                                       h_ptr,
                                       MEM_TYPE_STATUS,
                                       PMC_RGFPF96_CORE_REG_MUTEX_CSF_STATUS_FIFO);

    IOLOG( "%s -> 0x%08x;", "mapotn_rgfpf_reg_MUTEX_CSF_STATUS_FIFO_read", reg_value);
    return reg_value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset config
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_field_UNPACK_AFIFO_CLR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_UNPACK_AFIFO_CLR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_UNPACK_AFIFO_CLR_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_UNPACK_AFIFO_CLR_set", value );

    /* (0x00030000 bits 24) field UNPACK_AFIFO_CLR of register PMC_RGFPF96_CORE_REG_GENERAL_CONFIGURATION */
    mapotn_rgfpf_reg_GENERAL_CONFIGURATION_field_set( b_ptr,
                                                      h_ptr,
                                                      RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_UNPACK_AFIFO_CLR_MSK,
                                                      RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_UNPACK_AFIFO_CLR_OFF,
                                                      value);
}

static INLINE UINT32 mapotn_rgfpf_field_UNPACK_AFIFO_CLR_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_UNPACK_AFIFO_CLR_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030000 bits 24) field UNPACK_AFIFO_CLR of register PMC_RGFPF96_CORE_REG_GENERAL_CONFIGURATION */
    reg_value = mapotn_rgfpf_reg_GENERAL_CONFIGURATION_read( b_ptr,
                                                             h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_UNPACK_AFIFO_CLR_MSK) >> RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_UNPACK_AFIFO_CLR_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_UNPACK_AFIFO_CLR_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_CSF_FIFO_CLR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CSF_FIFO_CLR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CSF_FIFO_CLR_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_CSF_FIFO_CLR_set", value );

    /* (0x00030000 bits 16) field CSF_FIFO_CLR of register PMC_RGFPF96_CORE_REG_GENERAL_CONFIGURATION */
    mapotn_rgfpf_reg_GENERAL_CONFIGURATION_field_set( b_ptr,
                                                      h_ptr,
                                                      RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_CSF_FIFO_CLR_MSK,
                                                      RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_CSF_FIFO_CLR_OFF,
                                                      value);
}

static INLINE UINT32 mapotn_rgfpf_field_CSF_FIFO_CLR_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CSF_FIFO_CLR_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030000 bits 16) field CSF_FIFO_CLR of register PMC_RGFPF96_CORE_REG_GENERAL_CONFIGURATION */
    reg_value = mapotn_rgfpf_reg_GENERAL_CONFIGURATION_read( b_ptr,
                                                             h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_CSF_FIFO_CLR_MSK) >> RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_CSF_FIFO_CLR_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_CSF_FIFO_CLR_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_CSF_ST_I_TRSHLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CSF_ST_I_TRSHLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value )
{
    if (value > 127)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CSF_ST_I_TRSHLD_set", value, 127);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_CSF_ST_I_TRSHLD_set", value );

    /* (0x00030000 bits 14:8) field CSF_ST_I_TRSHLD of register PMC_RGFPF96_CORE_REG_GENERAL_CONFIGURATION */
    mapotn_rgfpf_reg_GENERAL_CONFIGURATION_field_set( b_ptr,
                                                      h_ptr,
                                                      RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_CSF_ST_I_TRSHLD_MSK,
                                                      RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_CSF_ST_I_TRSHLD_OFF,
                                                      value);
}

static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_I_TRSHLD_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_I_TRSHLD_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030000 bits 14:8) field CSF_ST_I_TRSHLD of register PMC_RGFPF96_CORE_REG_GENERAL_CONFIGURATION */
    reg_value = mapotn_rgfpf_reg_GENERAL_CONFIGURATION_read( b_ptr,
                                                             h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_CSF_ST_I_TRSHLD_MSK) >> RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_CSF_ST_I_TRSHLD_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_CSF_ST_I_TRSHLD_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_CSF_ST_I_TRSHLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_CSF_ST_I_TRSHLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_CSF_ST_I_TRSHLD_set", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_CSF_ST_I_TRSHLD_set", stop_bit, 6 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_CSF_ST_I_TRSHLD_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00030000 bits 14:8) field CSF_ST_I_TRSHLD of register PMC_RGFPF96_CORE_REG_GENERAL_CONFIGURATION */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 6) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 6;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00030000 bits 14:8) field CSF_ST_I_TRSHLD of register PMC_RGFPF96_CORE_REG_GENERAL_CONFIGURATION */
        mapotn_rgfpf_reg_GENERAL_CONFIGURATION_field_set( b_ptr,
                                                          h_ptr,
                                                          subfield_mask << (RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_CSF_ST_I_TRSHLD_OFF + subfield_offset),
                                                          RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_CSF_ST_I_TRSHLD_OFF + subfield_offset,
                                                          value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_CSF_ST_I_TRSHLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_CSF_ST_I_TRSHLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_CSF_ST_I_TRSHLD_get", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_CSF_ST_I_TRSHLD_get", stop_bit, 6 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 6) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 6;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00030000 bits 14:8) field CSF_ST_I_TRSHLD of register PMC_RGFPF96_CORE_REG_GENERAL_CONFIGURATION */
    reg_value = mapotn_rgfpf_reg_GENERAL_CONFIGURATION_read( b_ptr,
                                                             h_ptr);
    field_value = (reg_value & RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_CSF_ST_I_TRSHLD_MSK)
                  >> RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_CSF_ST_I_TRSHLD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_CSF_ST_I_TRSHLD_MSK, RGFPF96_CORE_REG_GENERAL_CONFIGURATION_BIT_CSF_ST_I_TRSHLD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_CSF_ST_I_TRSHLD_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_MAC_DA_LSB_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_MAC_DA_LSB_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_MAC_DA_LSB_set", value );

    /* (0x00030184 bits 31:0) field MAC_DA_LSB of register PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB */
    mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_LSB_field_set( b_ptr,
                                                            h_ptr,
                                                            RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB_BIT_MAC_DA_LSB_MSK,
                                                            RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB_BIT_MAC_DA_LSB_OFF,
                                                            value);
}

static INLINE UINT32 mapotn_rgfpf_field_MAC_DA_LSB_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_MAC_DA_LSB_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030184 bits 31:0) field MAC_DA_LSB of register PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB */
    reg_value = mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_LSB_read( b_ptr,
                                                                   h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB_BIT_MAC_DA_LSB_MSK) >> RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB_BIT_MAC_DA_LSB_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_MAC_DA_LSB_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_MAC_DA_LSB_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_MAC_DA_LSB_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MAC_DA_LSB_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MAC_DA_LSB_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MAC_DA_LSB_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00030184 bits 31:0) field MAC_DA_LSB of register PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00030184 bits 31:0) field MAC_DA_LSB of register PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB */
        mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_LSB_field_set( b_ptr,
                                                                h_ptr,
                                                                subfield_mask << (RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB_BIT_MAC_DA_LSB_OFF + subfield_offset),
                                                                RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB_BIT_MAC_DA_LSB_OFF + subfield_offset,
                                                                value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_MAC_DA_LSB_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_MAC_DA_LSB_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MAC_DA_LSB_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MAC_DA_LSB_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00030184 bits 31:0) field MAC_DA_LSB of register PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB */
    reg_value = mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_LSB_read( b_ptr,
                                                                   h_ptr);
    field_value = (reg_value & RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB_BIT_MAC_DA_LSB_MSK)
                  >> RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB_BIT_MAC_DA_LSB_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB_BIT_MAC_DA_LSB_MSK, RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_LSB_BIT_MAC_DA_LSB_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MAC_DA_LSB_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_MAC_DA_MSB_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_MAC_DA_MSB_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_MAC_DA_MSB_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_MAC_DA_MSB_set", value );

    /* (0x00030188 bits 15:0) field MAC_DA_MSB of register PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB */
    mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_MSB_field_set( b_ptr,
                                                            h_ptr,
                                                            RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB_BIT_MAC_DA_MSB_MSK,
                                                            RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB_BIT_MAC_DA_MSB_OFF,
                                                            value);
}

static INLINE UINT32 mapotn_rgfpf_field_MAC_DA_MSB_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_MAC_DA_MSB_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030188 bits 15:0) field MAC_DA_MSB of register PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB */
    reg_value = mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_MSB_read( b_ptr,
                                                                   h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB_BIT_MAC_DA_MSB_MSK) >> RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB_BIT_MAC_DA_MSB_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_MAC_DA_MSB_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_MAC_DA_MSB_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_MAC_DA_MSB_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MAC_DA_MSB_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MAC_DA_MSB_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MAC_DA_MSB_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00030188 bits 15:0) field MAC_DA_MSB of register PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00030188 bits 15:0) field MAC_DA_MSB of register PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB */
        mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_MSB_field_set( b_ptr,
                                                                h_ptr,
                                                                subfield_mask << (RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB_BIT_MAC_DA_MSB_OFF + subfield_offset),
                                                                RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB_BIT_MAC_DA_MSB_OFF + subfield_offset,
                                                                value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_MAC_DA_MSB_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_MAC_DA_MSB_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MAC_DA_MSB_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MAC_DA_MSB_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00030188 bits 15:0) field MAC_DA_MSB of register PMC_RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB */
    reg_value = mapotn_rgfpf_reg_MAC_DESTINATION_ADDRESS_MSB_read( b_ptr,
                                                                   h_ptr);
    field_value = (reg_value & RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB_BIT_MAC_DA_MSB_MSK)
                  >> RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB_BIT_MAC_DA_MSB_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB_BIT_MAC_DA_MSB_MSK, RGFPF96_CORE_REG_MAC_DESTINATION_ADDRESS_MSB_BIT_MAC_DA_MSB_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MAC_DA_MSB_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_ORD_SET_UPI_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_ORD_SET_UPI_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32 value )
{
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_ORD_SET_UPI_set", value, 255);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_ORD_SET_UPI_set", value );

    /* (0x0003018c bits 7:0) field ORD_SET_UPI of register PMC_RGFPF96_CORE_REG_ORDERED_SET_UPI */
    mapotn_rgfpf_reg_ORDERED_SET_UPI_field_set( b_ptr,
                                                h_ptr,
                                                RGFPF96_CORE_REG_ORDERED_SET_UPI_BIT_ORD_SET_UPI_MSK,
                                                RGFPF96_CORE_REG_ORDERED_SET_UPI_BIT_ORD_SET_UPI_OFF,
                                                value);
}

static INLINE UINT32 mapotn_rgfpf_field_ORD_SET_UPI_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_ORD_SET_UPI_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0003018c bits 7:0) field ORD_SET_UPI of register PMC_RGFPF96_CORE_REG_ORDERED_SET_UPI */
    reg_value = mapotn_rgfpf_reg_ORDERED_SET_UPI_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_ORDERED_SET_UPI_BIT_ORD_SET_UPI_MSK) >> RGFPF96_CORE_REG_ORDERED_SET_UPI_BIT_ORD_SET_UPI_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_ORD_SET_UPI_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_ORD_SET_UPI_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_ORD_SET_UPI_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_ORD_SET_UPI_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_ORD_SET_UPI_set", stop_bit, 7 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_ORD_SET_UPI_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0003018c bits 7:0) field ORD_SET_UPI of register PMC_RGFPF96_CORE_REG_ORDERED_SET_UPI */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0003018c bits 7:0) field ORD_SET_UPI of register PMC_RGFPF96_CORE_REG_ORDERED_SET_UPI */
        mapotn_rgfpf_reg_ORDERED_SET_UPI_field_set( b_ptr,
                                                    h_ptr,
                                                    subfield_mask << (RGFPF96_CORE_REG_ORDERED_SET_UPI_BIT_ORD_SET_UPI_OFF + subfield_offset),
                                                    RGFPF96_CORE_REG_ORDERED_SET_UPI_BIT_ORD_SET_UPI_OFF + subfield_offset,
                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_ORD_SET_UPI_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_ORD_SET_UPI_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_ORD_SET_UPI_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_ORD_SET_UPI_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0003018c bits 7:0) field ORD_SET_UPI of register PMC_RGFPF96_CORE_REG_ORDERED_SET_UPI */
    reg_value = mapotn_rgfpf_reg_ORDERED_SET_UPI_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & RGFPF96_CORE_REG_ORDERED_SET_UPI_BIT_ORD_SET_UPI_MSK)
                  >> RGFPF96_CORE_REG_ORDERED_SET_UPI_BIT_ORD_SET_UPI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_ORDERED_SET_UPI_BIT_ORD_SET_UPI_MSK, RGFPF96_CORE_REG_ORDERED_SET_UPI_BIT_ORD_SET_UPI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_ORD_SET_UPI_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_DUPM_CAP_CHID_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_DUPM_CAP_CHID_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 127)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_DUPM_CAP_CHID_set", value, 127);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_DUPM_CAP_CHID_set", value );

    /* (0x000301c4 bits 14:8) field DUPM_CAP_CHID of register PMC_RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE */
    mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_field_set( b_ptr,
                                                      h_ptr,
                                                      RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DUPM_CAP_CHID_MSK,
                                                      RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DUPM_CAP_CHID_OFF,
                                                      value);
}

static INLINE UINT32 mapotn_rgfpf_field_DUPM_CAP_CHID_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DUPM_CAP_CHID_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301c4 bits 14:8) field DUPM_CAP_CHID of register PMC_RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE */
    reg_value = mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_read( b_ptr,
                                                             h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DUPM_CAP_CHID_MSK) >> RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DUPM_CAP_CHID_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_DUPM_CAP_CHID_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_DUPM_CAP_CHID_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_DUPM_CAP_CHID_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_DUPM_CAP_CHID_set", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_DUPM_CAP_CHID_set", stop_bit, 6 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_DUPM_CAP_CHID_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000301c4 bits 14:8) field DUPM_CAP_CHID of register PMC_RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 6) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 6;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000301c4 bits 14:8) field DUPM_CAP_CHID of register PMC_RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE */
        mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_field_set( b_ptr,
                                                          h_ptr,
                                                          subfield_mask << (RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DUPM_CAP_CHID_OFF + subfield_offset),
                                                          RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DUPM_CAP_CHID_OFF + subfield_offset,
                                                          value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_DUPM_CAP_CHID_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_DUPM_CAP_CHID_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_DUPM_CAP_CHID_get", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_DUPM_CAP_CHID_get", stop_bit, 6 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 6) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 6;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000301c4 bits 14:8) field DUPM_CAP_CHID of register PMC_RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE */
    reg_value = mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_read( b_ptr,
                                                             h_ptr);
    field_value = (reg_value & RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DUPM_CAP_CHID_MSK)
                  >> RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DUPM_CAP_CHID_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DUPM_CAP_CHID_MSK, RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DUPM_CAP_CHID_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_DUPM_CAP_CHID_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_DEXM_CAP_CHID_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_DEXM_CAP_CHID_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 127)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_DEXM_CAP_CHID_set", value, 127);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_DEXM_CAP_CHID_set", value );

    /* (0x000301c4 bits 6:0) field DEXM_CAP_CHID of register PMC_RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE */
    mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_field_set( b_ptr,
                                                      h_ptr,
                                                      RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DEXM_CAP_CHID_MSK,
                                                      RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DEXM_CAP_CHID_OFF,
                                                      value);
}

static INLINE UINT32 mapotn_rgfpf_field_DEXM_CAP_CHID_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DEXM_CAP_CHID_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301c4 bits 6:0) field DEXM_CAP_CHID of register PMC_RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE */
    reg_value = mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_read( b_ptr,
                                                             h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DEXM_CAP_CHID_MSK) >> RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DEXM_CAP_CHID_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_DEXM_CAP_CHID_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_DEXM_CAP_CHID_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_DEXM_CAP_CHID_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_DEXM_CAP_CHID_set", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_DEXM_CAP_CHID_set", stop_bit, 6 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_DEXM_CAP_CHID_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000301c4 bits 6:0) field DEXM_CAP_CHID of register PMC_RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 6) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 6;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000301c4 bits 6:0) field DEXM_CAP_CHID of register PMC_RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE */
        mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_field_set( b_ptr,
                                                          h_ptr,
                                                          subfield_mask << (RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DEXM_CAP_CHID_OFF + subfield_offset),
                                                          RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DEXM_CAP_CHID_OFF + subfield_offset,
                                                          value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_DEXM_CAP_CHID_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_DEXM_CAP_CHID_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_DEXM_CAP_CHID_get", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_DEXM_CAP_CHID_get", stop_bit, 6 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 6) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 6;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000301c4 bits 6:0) field DEXM_CAP_CHID of register PMC_RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE */
    reg_value = mapotn_rgfpf_reg_CHID_MISMATCH_CAPTURE_read( b_ptr,
                                                             h_ptr);
    field_value = (reg_value & RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DEXM_CAP_CHID_MSK)
                  >> RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DEXM_CAP_CHID_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DEXM_CAP_CHID_MSK, RGFPF96_CORE_REG_CHID_MISMATCH_CAPTURE_BIT_DEXM_CAP_CHID_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_DEXM_CAP_CHID_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_WR_RPT_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_WR_RPT_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32 value )
{
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_WR_RPT_THRLD_set", value, 511);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_WR_RPT_THRLD_set", value );

    /* (0x000301cc bits 24:16) field WR_RPT_THRLD of register PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT */
    mapotn_rgfpf_reg_CPU_FIFO_RPT_field_set( b_ptr,
                                             h_ptr,
                                             RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_WR_RPT_THRLD_MSK,
                                             RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_WR_RPT_THRLD_OFF,
                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_WR_RPT_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_WR_RPT_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301cc bits 24:16) field WR_RPT_THRLD of register PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT */
    reg_value = mapotn_rgfpf_reg_CPU_FIFO_RPT_read(  b_ptr, h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_WR_RPT_THRLD_MSK) >> RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_WR_RPT_THRLD_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_WR_RPT_THRLD_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_WR_RPT_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_WR_RPT_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_WR_RPT_THRLD_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_WR_RPT_THRLD_set", stop_bit, 8 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_WR_RPT_THRLD_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000301cc bits 24:16) field WR_RPT_THRLD of register PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000301cc bits 24:16) field WR_RPT_THRLD of register PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT */
        mapotn_rgfpf_reg_CPU_FIFO_RPT_field_set( b_ptr,
                                                 h_ptr,
                                                 subfield_mask << (RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_WR_RPT_THRLD_OFF + subfield_offset),
                                                 RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_WR_RPT_THRLD_OFF + subfield_offset,
                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_WR_RPT_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_WR_RPT_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_WR_RPT_THRLD_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_WR_RPT_THRLD_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000301cc bits 24:16) field WR_RPT_THRLD of register PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT */
    reg_value = mapotn_rgfpf_reg_CPU_FIFO_RPT_read(  b_ptr, h_ptr);
    field_value = (reg_value & RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_WR_RPT_THRLD_MSK)
                  >> RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_WR_RPT_THRLD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_WR_RPT_THRLD_MSK, RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_WR_RPT_THRLD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_WR_RPT_THRLD_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_RD_RPT_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_RD_RPT_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32 value )
{
    if (value > 31)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_RD_RPT_THRLD_set", value, 31);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_RD_RPT_THRLD_set", value );

    /* (0x000301cc bits 12:8) field RD_RPT_THRLD of register PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT */
    mapotn_rgfpf_reg_CPU_FIFO_RPT_field_set( b_ptr,
                                             h_ptr,
                                             RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_RD_RPT_THRLD_MSK,
                                             RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_RD_RPT_THRLD_OFF,
                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_RD_RPT_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_RD_RPT_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301cc bits 12:8) field RD_RPT_THRLD of register PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT */
    reg_value = mapotn_rgfpf_reg_CPU_FIFO_RPT_read(  b_ptr, h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_RD_RPT_THRLD_MSK) >> RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_RD_RPT_THRLD_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_RD_RPT_THRLD_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_RD_RPT_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_RD_RPT_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_RD_RPT_THRLD_set", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_RD_RPT_THRLD_set", stop_bit, 4 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_RD_RPT_THRLD_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000301cc bits 12:8) field RD_RPT_THRLD of register PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 4) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 4;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000301cc bits 12:8) field RD_RPT_THRLD of register PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT */
        mapotn_rgfpf_reg_CPU_FIFO_RPT_field_set( b_ptr,
                                                 h_ptr,
                                                 subfield_mask << (RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_RD_RPT_THRLD_OFF + subfield_offset),
                                                 RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_RD_RPT_THRLD_OFF + subfield_offset,
                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_RD_RPT_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_RD_RPT_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_RD_RPT_THRLD_get", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_RD_RPT_THRLD_get", stop_bit, 4 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 4) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 4;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000301cc bits 12:8) field RD_RPT_THRLD of register PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT */
    reg_value = mapotn_rgfpf_reg_CPU_FIFO_RPT_read(  b_ptr, h_ptr);
    field_value = (reg_value & RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_RD_RPT_THRLD_MSK)
                  >> RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_RD_RPT_THRLD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_RD_RPT_THRLD_MSK, RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_RD_RPT_THRLD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_RD_RPT_THRLD_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_WR_RPT_FIFOCLR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_WR_RPT_FIFOCLR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_WR_RPT_FIFOCLR_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_WR_RPT_FIFOCLR_set", value );

    /* (0x000301cc bits 1) field WR_RPT_FIFOCLR of register PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT */
    mapotn_rgfpf_reg_CPU_FIFO_RPT_field_set( b_ptr,
                                             h_ptr,
                                             RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_WR_RPT_FIFOCLR_MSK,
                                             RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_WR_RPT_FIFOCLR_OFF,
                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_WR_RPT_FIFOCLR_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_WR_RPT_FIFOCLR_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301cc bits 1) field WR_RPT_FIFOCLR of register PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT */
    reg_value = mapotn_rgfpf_reg_CPU_FIFO_RPT_read(  b_ptr, h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_WR_RPT_FIFOCLR_MSK) >> RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_WR_RPT_FIFOCLR_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_WR_RPT_FIFOCLR_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_RD_RPT_FIFOCLR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_RD_RPT_FIFOCLR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_RD_RPT_FIFOCLR_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_RD_RPT_FIFOCLR_set", value );

    /* (0x000301cc bits 0) field RD_RPT_FIFOCLR of register PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT */
    mapotn_rgfpf_reg_CPU_FIFO_RPT_field_set( b_ptr,
                                             h_ptr,
                                             RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_RD_RPT_FIFOCLR_MSK,
                                             RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_RD_RPT_FIFOCLR_OFF,
                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_RD_RPT_FIFOCLR_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_RD_RPT_FIFOCLR_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301cc bits 0) field RD_RPT_FIFOCLR of register PMC_RGFPF96_CORE_REG_CPU_FIFO_RPT */
    reg_value = mapotn_rgfpf_reg_CPU_FIFO_RPT_read(  b_ptr, h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_RD_RPT_FIFOCLR_MSK) >> RGFPF96_CORE_REG_CPU_FIFO_RPT_BIT_RD_RPT_FIFOCLR_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_RD_RPT_FIFOCLR_get", value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset config_N_burstsize3
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_lfield_AUTO_FLOW_CTRL_EN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_AUTO_FLOW_CTRL_EN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_AUTO_FLOW_CTRL_EN_set");
    mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_burst_write( b_ptr,
                                                                h_ptr,
                                                                0,
                                                                3,
                                                                value);
}

static INLINE void mapotn_rgfpf_lfield_AUTO_FLOW_CTRL_EN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_AUTO_FLOW_CTRL_EN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_AUTO_FLOW_CTRL_EN_get");
    mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_burst_read( b_ptr,
                                                               h_ptr,
                                                               0,
                                                               3,
                                                               (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_AUTO_FLOW_CTRL_EN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_AUTO_FLOW_CTRL_EN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_AUTO_FLOW_CTRL_EN_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_AUTO_FLOW_CTRL_EN_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_field_set( b_ptr,
                                                              h_ptr,
                                                              word_number,
                                                              mask,
                                                              field_ofs,
                                                              value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_AUTO_FLOW_CTRL_EN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_AUTO_FLOW_CTRL_EN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_AUTO_FLOW_CTRL_EN_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_AUTO_FLOW_CTRL_REGISTER_array_read( b_ptr,
                                                                     h_ptr,
                                                                     word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_AUTO_FLOW_CTRL_EN_get", start_bit, stop_bit, value );
    return value;
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset config_N_burstsize6
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_lfield_CPB_ZONE_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value[6] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CPB_ZONE_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value[6] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CPB_ZONE_THRLD_set");
    mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_burst_write( b_ptr,
                                                           h_ptr,
                                                           0,
                                                           6,
                                                           value);
}

static INLINE void mapotn_rgfpf_lfield_CPB_ZONE_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value[6] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CPB_ZONE_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value[6] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CPB_ZONE_THRLD_get");
    mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_burst_read( b_ptr,
                                                          h_ptr,
                                                          0,
                                                          6,
                                                          (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_CPB_ZONE_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_CPB_ZONE_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CPB_ZONE_THRLD_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CPB_ZONE_THRLD_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_field_set( b_ptr,
                                                         h_ptr,
                                                         word_number,
                                                         mask,
                                                         field_ofs,
                                                         value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CPB_ZONE_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CPB_ZONE_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CPB_ZONE_THRLD_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_CPB_ZONE_THRESHOLD_array_read( b_ptr,
                                                                h_ptr,
                                                                word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CPB_ZONE_THRLD_get", start_bit, stop_bit, value );
    return value;
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset config_N_size96
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_field_CHN_RST_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CHN_RST_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N,
                                                   UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CHN_RST_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CHN_RST_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_CHN_RST_set", N, value );

    /* ((0x00030004 + (N) * 0x4) bits 0) field CHN_RST of register PMC_RGFPF96_CORE_REG_CHANNEL_RESET index N=0..95 */
    mapotn_rgfpf_reg_CHANNEL_RESET_array_field_set( b_ptr,
                                                    h_ptr,
                                                    N,
                                                    RGFPF96_CORE_REG_CHANNEL_RESET_BIT_CHN_RST_MSK,
                                                    RGFPF96_CORE_REG_CHANNEL_RESET_BIT_CHN_RST_OFF,
                                                    value);
}

static INLINE UINT32 mapotn_rgfpf_field_CHN_RST_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CHN_RST_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CHN_RST_get", N, 95);
    /* ((0x00030004 + (N) * 0x4) bits 0) field CHN_RST of register PMC_RGFPF96_CORE_REG_CHANNEL_RESET index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CHANNEL_RESET_array_read( b_ptr,
                                                           h_ptr,
                                                           N);
    value = (reg_value & RGFPF96_CORE_REG_CHANNEL_RESET_BIT_CHN_RST_MSK) >> RGFPF96_CORE_REG_CHANNEL_RESET_BIT_CHN_RST_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CHN_RST_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_UNPACK_XOFF_THRLD2_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_UNPACK_XOFF_THRLD2_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UNPACK_XOFF_THRLD2_set", N, 95);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_UNPACK_XOFF_THRLD2_set", value, 511);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_UNPACK_XOFF_THRLD2_set", N, value );

    /* ((0x00031010 + (N) * 0x100) bits 24:16) field UNPACK_XOFF_THRLD2 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD2_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD2_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_UNPACK_XOFF_THRLD2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_UNPACK_XOFF_THRLD2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UNPACK_XOFF_THRLD2_get", N, 95);
    /* ((0x00031010 + (N) * 0x100) bits 24:16) field UNPACK_XOFF_THRLD2 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD2_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD2_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_UNPACK_XOFF_THRLD2_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD2_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD2_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD2_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD2_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD2_set", stop_bit, 8 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD2_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031010 + (N) * 0x100) bits 24:16) field UNPACK_XOFF_THRLD2 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031010 + (N) * 0x100) bits 24:16) field UNPACK_XOFF_THRLD2 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD2_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD2_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32  N,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32  N,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD2_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD2_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD2_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031010 + (N) * 0x100) bits 24:16) field UNPACK_XOFF_THRLD2 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD2_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD2_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD2_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_EGRESS_XOFF_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_EGRESS_XOFF_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EGRESS_XOFF_THRLD_set", N, 95);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_EGRESS_XOFF_THRLD_set", value, 255);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_EGRESS_XOFF_THRLD_set", N, value );

    /* ((0x00031010 + (N) * 0x100) bits 15:8) field EGRESS_XOFF_THRLD of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_EGRESS_XOFF_THRLD_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_EGRESS_XOFF_THRLD_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_EGRESS_XOFF_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_EGRESS_XOFF_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EGRESS_XOFF_THRLD_get", N, 95);
    /* ((0x00031010 + (N) * 0x100) bits 15:8) field EGRESS_XOFF_THRLD of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_EGRESS_XOFF_THRLD_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_EGRESS_XOFF_THRLD_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_EGRESS_XOFF_THRLD_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_EGRESS_XOFF_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_EGRESS_XOFF_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EGRESS_XOFF_THRLD_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EGRESS_XOFF_THRLD_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EGRESS_XOFF_THRLD_set", stop_bit, 7 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EGRESS_XOFF_THRLD_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031010 + (N) * 0x100) bits 15:8) field EGRESS_XOFF_THRLD of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031010 + (N) * 0x100) bits 15:8) field EGRESS_XOFF_THRLD of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_EGRESS_XOFF_THRLD_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_EGRESS_XOFF_THRLD_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_EGRESS_XOFF_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_EGRESS_XOFF_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EGRESS_XOFF_THRLD_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EGRESS_XOFF_THRLD_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EGRESS_XOFF_THRLD_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031010 + (N) * 0x100) bits 15:8) field EGRESS_XOFF_THRLD of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_EGRESS_XOFF_THRLD_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_EGRESS_XOFF_THRLD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_EGRESS_XOFF_THRLD_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_EGRESS_XOFF_THRLD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EGRESS_XOFF_THRLD_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_UNPACK_XOFF_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_UNPACK_XOFF_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UNPACK_XOFF_THRLD_set", N, 95);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_UNPACK_XOFF_THRLD_set", value, 255);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_UNPACK_XOFF_THRLD_set", N, value );

    /* ((0x00031010 + (N) * 0x100) bits 7:0) field UNPACK_XOFF_THRLD of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_UNPACK_XOFF_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_UNPACK_XOFF_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UNPACK_XOFF_THRLD_get", N, 95);
    /* ((0x00031010 + (N) * 0x100) bits 7:0) field UNPACK_XOFF_THRLD of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_UNPACK_XOFF_THRLD_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD_set", stop_bit, 7 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031010 + (N) * 0x100) bits 7:0) field UNPACK_XOFF_THRLD of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031010 + (N) * 0x100) bits 7:0) field UNPACK_XOFF_THRLD of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031010 + (N) * 0x100) bits 7:0) field UNPACK_XOFF_THRLD of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_4_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_4_BIT_UNPACK_XOFF_THRLD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UNPACK_XOFF_THRLD_get", N, start_bit, stop_bit, value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset config_edge
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_field_PMON_LATCH_TRIG_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PMON_LATCH_TRIG_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PMON_LATCH_TRIG_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_PMON_LATCH_TRIG_set", value );

    /* (0x00030190 bits 0) field PMON_LATCH_TRIG of register PMC_RGFPF96_CORE_REG_PMON_LATCH_CONTROL_REGISTER */
    mapotn_rgfpf_reg_PMON_LATCH_CONTROL_REGISTER_field_set( b_ptr,
                                                            h_ptr,
                                                            RGFPF96_CORE_REG_PMON_LATCH_CONTROL_REGISTER_BIT_PMON_LATCH_TRIG_MSK,
                                                            RGFPF96_CORE_REG_PMON_LATCH_CONTROL_REGISTER_BIT_PMON_LATCH_TRIG_OFF,
                                                            value);
}

static INLINE UINT32 mapotn_rgfpf_field_PMON_LATCH_TRIG_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PMON_LATCH_TRIG_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030190 bits 0) field PMON_LATCH_TRIG of register PMC_RGFPF96_CORE_REG_PMON_LATCH_CONTROL_REGISTER */
    reg_value = mapotn_rgfpf_reg_PMON_LATCH_CONTROL_REGISTER_read( b_ptr,
                                                                   h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_PMON_LATCH_CONTROL_REGISTER_BIT_PMON_LATCH_TRIG_MSK) >> RGFPF96_CORE_REG_PMON_LATCH_CONTROL_REGISTER_BIT_PMON_LATCH_TRIG_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_PMON_LATCH_TRIG_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PAUSE_CAP_TRIG_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PAUSE_CAP_TRIG_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PAUSE_CAP_TRIG_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_PAUSE_CAP_TRIG_set", value );

    /* (0x00030194 bits 0) field PAUSE_CAP_TRIG of register PMC_RGFPF96_CORE_REG_TRIG_PAUSE_CAP_REGISTER */
    mapotn_rgfpf_reg_TRIG_PAUSE_CAP_REGISTER_field_set( b_ptr,
                                                        h_ptr,
                                                        RGFPF96_CORE_REG_TRIG_PAUSE_CAP_REGISTER_BIT_PAUSE_CAP_TRIG_MSK,
                                                        RGFPF96_CORE_REG_TRIG_PAUSE_CAP_REGISTER_BIT_PAUSE_CAP_TRIG_OFF,
                                                        value);
}

static INLINE UINT32 mapotn_rgfpf_field_PAUSE_CAP_TRIG_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PAUSE_CAP_TRIG_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030194 bits 0) field PAUSE_CAP_TRIG of register PMC_RGFPF96_CORE_REG_TRIG_PAUSE_CAP_REGISTER */
    reg_value = mapotn_rgfpf_reg_TRIG_PAUSE_CAP_REGISTER_read( b_ptr,
                                                               h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_TRIG_PAUSE_CAP_REGISTER_BIT_PAUSE_CAP_TRIG_MSK) >> RGFPF96_CORE_REG_TRIG_PAUSE_CAP_REGISTER_BIT_PAUSE_CAP_TRIG_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_PAUSE_CAP_TRIG_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_DEXM_STATUS_REG_FREE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_DEXM_STATUS_REG_FREE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_DEXM_STATUS_REG_FREE_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_DEXM_STATUS_REG_FREE_set", value );

    /* (0x000301bc bits 0) field DEXM_STATUS_REG_FREE of register PMC_RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS */
    mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_field_set( b_ptr,
                                                              h_ptr,
                                                              RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_STATUS_REG_FREE_MSK,
                                                              RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_STATUS_REG_FREE_OFF,
                                                              value);
}

static INLINE UINT32 mapotn_rgfpf_field_DEXM_STATUS_REG_FREE_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DEXM_STATUS_REG_FREE_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301bc bits 0) field DEXM_STATUS_REG_FREE of register PMC_RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS */
    reg_value = mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_read( b_ptr,
                                                                     h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_STATUS_REG_FREE_MSK) >> RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_STATUS_REG_FREE_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_DEXM_STATUS_REG_FREE_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_DUPM_STATUS_REG_FREE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_DUPM_STATUS_REG_FREE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_DUPM_STATUS_REG_FREE_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_DUPM_STATUS_REG_FREE_set", value );

    /* (0x000301c0 bits 0) field DUPM_STATUS_REG_FREE of register PMC_RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS */
    mapotn_rgfpf_reg_PTI_UPI_MIS_STATUS_field_set( b_ptr,
                                                   h_ptr,
                                                   RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_STATUS_REG_FREE_MSK,
                                                   RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_STATUS_REG_FREE_OFF,
                                                   value);
}

static INLINE UINT32 mapotn_rgfpf_field_DUPM_STATUS_REG_FREE_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DUPM_STATUS_REG_FREE_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301c0 bits 0) field DUPM_STATUS_REG_FREE of register PMC_RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS */
    reg_value = mapotn_rgfpf_reg_PTI_UPI_MIS_STATUS_read( b_ptr,
                                                          h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_STATUS_REG_FREE_MSK) >> RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_STATUS_REG_FREE_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_DUPM_STATUS_REG_FREE_get", value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset config_edge_N_burstsize3
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_lfield_DCSF_DEASSERT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DCSF_DEASSERT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DCSF_DEASSERT_set");
    mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_burst_write( b_ptr,
                                                               h_ptr,
                                                               0,
                                                               3,
                                                               value);
}

static INLINE void mapotn_rgfpf_lfield_DCSF_DEASSERT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DCSF_DEASSERT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DCSF_DEASSERT_get");
    mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_burst_read( b_ptr,
                                                              h_ptr,
                                                              0,
                                                              3,
                                                              (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_DCSF_DEASSERT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_DCSF_DEASSERT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DCSF_DEASSERT_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DCSF_DEASSERT_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_field_set( b_ptr,
                                                             h_ptr,
                                                             word_number,
                                                             mask,
                                                             field_ofs,
                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_DCSF_DEASSERT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_DCSF_DEASSERT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DCSF_DEASSERT_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_DCSF_DEASSERT_REGISTER_array_read( b_ptr,
                                                                    h_ptr,
                                                                    word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DCSF_DEASSERT_get", start_bit, stop_bit, value );
    return value;
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_enable
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_field_CSF_ST_AV_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CSF_ST_AV_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CSF_ST_AV_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_CSF_ST_AV_E_set", value );

    /* (0x000302a8 bits 0) field CSF_ST_AV_E of register PMC_RGFPF96_CORE_REG_CSF_STATUS_AV_INTR_ENABLE */
    mapotn_rgfpf_reg_CSF_STATUS_AV_INTR_ENABLE_field_set( b_ptr,
                                                          h_ptr,
                                                          RGFPF96_CORE_REG_CSF_STATUS_AV_INTR_ENABLE_BIT_CSF_ST_AV_E_MSK,
                                                          RGFPF96_CORE_REG_CSF_STATUS_AV_INTR_ENABLE_BIT_CSF_ST_AV_E_OFF,
                                                          value);
}

static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_AV_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_AV_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000302a8 bits 0) field CSF_ST_AV_E of register PMC_RGFPF96_CORE_REG_CSF_STATUS_AV_INTR_ENABLE */
    reg_value = mapotn_rgfpf_reg_CSF_STATUS_AV_INTR_ENABLE_read( b_ptr,
                                                                 h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_CSF_STATUS_AV_INTR_ENABLE_BIT_CSF_ST_AV_E_MSK) >> RGFPF96_CORE_REG_CSF_STATUS_AV_INTR_ENABLE_BIT_CSF_ST_AV_E_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_CSF_ST_AV_E_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_CSF_ST_FIFO_OF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CSF_ST_FIFO_OF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CSF_ST_FIFO_OF_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_CSF_ST_FIFO_OF_E_set", value );

    /* (0x000302ac bits 0) field CSF_ST_FIFO_OF_E of register PMC_RGFPF96_CORE_REG_CSF_STATUS_FIFO_OF_INTR_ENABLE */
    mapotn_rgfpf_reg_CSF_STATUS_FIFO_OF_INTR_ENABLE_field_set( b_ptr,
                                                               h_ptr,
                                                               RGFPF96_CORE_REG_CSF_STATUS_FIFO_OF_INTR_ENABLE_BIT_CSF_ST_FIFO_OF_E_MSK,
                                                               RGFPF96_CORE_REG_CSF_STATUS_FIFO_OF_INTR_ENABLE_BIT_CSF_ST_FIFO_OF_E_OFF,
                                                               value);
}

static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_FIFO_OF_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_FIFO_OF_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000302ac bits 0) field CSF_ST_FIFO_OF_E of register PMC_RGFPF96_CORE_REG_CSF_STATUS_FIFO_OF_INTR_ENABLE */
    reg_value = mapotn_rgfpf_reg_CSF_STATUS_FIFO_OF_INTR_ENABLE_read( b_ptr,
                                                                      h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_CSF_STATUS_FIFO_OF_INTR_ENABLE_BIT_CSF_ST_FIFO_OF_E_MSK) >> RGFPF96_CORE_REG_CSF_STATUS_FIFO_OF_INTR_ENABLE_BIT_CSF_ST_FIFO_OF_E_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_CSF_ST_FIFO_OF_E_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PMON_TRFR_END_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PMON_TRFR_END_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PMON_TRFR_END_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_PMON_TRFR_END_E_set", value );

    /* (0x00030370 bits 1) field PMON_TRFR_END_E of register PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE */
    mapotn_rgfpf_reg_PMON_TRANSFER_INTR_ENABLE_field_set( b_ptr,
                                                          h_ptr,
                                                          RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE_BIT_PMON_TRFR_END_E_MSK,
                                                          RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE_BIT_PMON_TRFR_END_E_OFF,
                                                          value);
}

static INLINE UINT32 mapotn_rgfpf_field_PMON_TRFR_END_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PMON_TRFR_END_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030370 bits 1) field PMON_TRFR_END_E of register PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE */
    reg_value = mapotn_rgfpf_reg_PMON_TRANSFER_INTR_ENABLE_read( b_ptr,
                                                                 h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE_BIT_PMON_TRFR_END_E_MSK) >> RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE_BIT_PMON_TRFR_END_E_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_PMON_TRFR_END_E_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PMON_TRFR_START_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PMON_TRFR_START_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PMON_TRFR_START_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_PMON_TRFR_START_E_set", value );

    /* (0x00030370 bits 0) field PMON_TRFR_START_E of register PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE */
    mapotn_rgfpf_reg_PMON_TRANSFER_INTR_ENABLE_field_set( b_ptr,
                                                          h_ptr,
                                                          RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE_BIT_PMON_TRFR_START_E_MSK,
                                                          RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE_BIT_PMON_TRFR_START_E_OFF,
                                                          value);
}

static INLINE UINT32 mapotn_rgfpf_field_PMON_TRFR_START_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PMON_TRFR_START_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030370 bits 0) field PMON_TRFR_START_E of register PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE */
    reg_value = mapotn_rgfpf_reg_PMON_TRANSFER_INTR_ENABLE_read( b_ptr,
                                                                 h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE_BIT_PMON_TRFR_START_E_MSK) >> RGFPF96_CORE_REG_PMON_TRANSFER_INTR_ENABLE_BIT_PMON_TRFR_START_E_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_PMON_TRFR_START_E_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_E_set", value );

    /* (0x00030374 bits 2) field CPU_WRRPT_AFIFO_OVF_E of register PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE */
    mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_ENABLE_field_set( b_ptr,
                                                           h_ptr,
                                                           RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE_BIT_CPU_WRRPT_AFIFO_OVF_E_MSK,
                                                           RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE_BIT_CPU_WRRPT_AFIFO_OVF_E_OFF,
                                                           value);
}

static INLINE UINT32 mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030374 bits 2) field CPU_WRRPT_AFIFO_OVF_E of register PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE */
    reg_value = mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_ENABLE_read( b_ptr,
                                                                  h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE_BIT_CPU_WRRPT_AFIFO_OVF_E_MSK) >> RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE_BIT_CPU_WRRPT_AFIFO_OVF_E_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_E_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_E_set", value );

    /* (0x00030374 bits 1) field CPU_RDRPT_AFIFO_OVF_E of register PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE */
    mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_ENABLE_field_set( b_ptr,
                                                           h_ptr,
                                                           RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE_BIT_CPU_RDRPT_AFIFO_OVF_E_MSK,
                                                           RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE_BIT_CPU_RDRPT_AFIFO_OVF_E_OFF,
                                                           value);
}

static INLINE UINT32 mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030374 bits 1) field CPU_RDRPT_AFIFO_OVF_E of register PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE */
    reg_value = mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_ENABLE_read( b_ptr,
                                                                  h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE_BIT_CPU_RDRPT_AFIFO_OVF_E_MSK) >> RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE_BIT_CPU_RDRPT_AFIFO_OVF_E_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_E_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_UNPACK_AFIFO_OVF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_UNPACK_AFIFO_OVF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_UNPACK_AFIFO_OVF_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_UNPACK_AFIFO_OVF_E_set", value );

    /* (0x00030374 bits 0) field UNPACK_AFIFO_OVF_E of register PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE */
    mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_ENABLE_field_set( b_ptr,
                                                           h_ptr,
                                                           RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE_BIT_UNPACK_AFIFO_OVF_E_MSK,
                                                           RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE_BIT_UNPACK_AFIFO_OVF_E_OFF,
                                                           value);
}

static INLINE UINT32 mapotn_rgfpf_field_UNPACK_AFIFO_OVF_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_UNPACK_AFIFO_OVF_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030374 bits 0) field UNPACK_AFIFO_OVF_E of register PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE */
    reg_value = mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_ENABLE_read( b_ptr,
                                                                  h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE_BIT_UNPACK_AFIFO_OVF_E_MSK) >> RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_ENABLE_BIT_UNPACK_AFIFO_OVF_E_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_UNPACK_AFIFO_OVF_E_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_E_set", value );

    /* (0x000303b8 bits 0) field RCOH_TRNSFR_SHDW_DNE_E of register PMC_RGFPF96_CORE_REG_RCOH_STAT_TRANSFR_DONE_EN */
    mapotn_rgfpf_reg_RCOH_STAT_TRANSFR_DONE_EN_field_set( b_ptr,
                                                          h_ptr,
                                                          RGFPF96_CORE_REG_RCOH_STAT_TRANSFR_DONE_EN_BIT_RCOH_TRNSFR_SHDW_DNE_E_MSK,
                                                          RGFPF96_CORE_REG_RCOH_STAT_TRANSFR_DONE_EN_BIT_RCOH_TRNSFR_SHDW_DNE_E_OFF,
                                                          value);
}

static INLINE UINT32 mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_E_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000303b8 bits 0) field RCOH_TRNSFR_SHDW_DNE_E of register PMC_RGFPF96_CORE_REG_RCOH_STAT_TRANSFR_DONE_EN */
    reg_value = mapotn_rgfpf_reg_RCOH_STAT_TRANSFR_DONE_EN_read( b_ptr,
                                                                 h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_RCOH_STAT_TRANSFR_DONE_EN_BIT_RCOH_TRNSFR_SHDW_DNE_E_MSK) >> RGFPF96_CORE_REG_RCOH_STAT_TRANSFR_DONE_EN_BIT_RCOH_TRNSFR_SHDW_DNE_E_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_E_get", value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_enable_M_size7__N_burstsize3
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  M,
                                                                UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  M,
                                                                UINT32 value[3] )
{
    if (M > 6)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_E_set", M, 6);
    IOLOG( "%s  M=%d", "mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_E_set", M);
    mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_burst_write( b_ptr,
                                                                 h_ptr,
                                                                 M,
                                                                 0,
                                                                 3,
                                                                 value);
}

static INLINE void mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  M,
                                                                UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  M,
                                                                UINT32 value[3] )
{
    if (M > 6)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_E_get", M, 6);
    IOLOG( "%s  M=%d", "mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_E_get", M);
    mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_burst_read( b_ptr,
                                                                h_ptr,
                                                                M,
                                                                0,
                                                                3,
                                                                (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32  M,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit,
                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32  M,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit,
                                                                      UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    if (M > 6)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_E_set", M, 6);
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> M=%d start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_E_set", M, start_bit, stop_bit, value);
    mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_field_set( b_ptr,
                                                               h_ptr,
                                                               M,
                                                               word_number,
                                                               mask,
                                                               field_ofs,
                                                               value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  M,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  M,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    if (M > 6)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_E_get", M, 6);
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_ENABLE_array_read( b_ptr,
                                                                      h_ptr,
                                                                      M,
                                                                      word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> M=%d start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_E_get", M, start_bit, stop_bit, value );
    return value;
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_enable_N_burstsize3
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_lfield_IN_SFAIL_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_IN_SFAIL_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_IN_SFAIL_E_set");
    mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_burst_write( b_ptr,
                                                             h_ptr,
                                                             0,
                                                             3,
                                                             value);
}

static INLINE void mapotn_rgfpf_lfield_IN_SFAIL_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_IN_SFAIL_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_IN_SFAIL_E_get");
    mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_burst_read( b_ptr,
                                                            h_ptr,
                                                            0,
                                                            3,
                                                            (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_IN_SFAIL_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_IN_SFAIL_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_IN_SFAIL_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_IN_SFAIL_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_field_set( b_ptr,
                                                           h_ptr,
                                                           word_number,
                                                           mask,
                                                           field_ofs,
                                                           value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_IN_SFAIL_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_IN_SFAIL_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_IN_SFAIL_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_IN_SFAIL_INTR_ENABLE_array_read( b_ptr,
                                                                  h_ptr,
                                                                  word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_IN_SFAIL_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_LOFD_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_LOFD_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_LOFD_E_set");
    mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_burst_write( b_ptr,
                                                                          h_ptr,
                                                                          0,
                                                                          3,
                                                                          value);
}

static INLINE void mapotn_rgfpf_lfield_LOFD_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_LOFD_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_LOFD_E_get");
    mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_burst_read( b_ptr,
                                                                         h_ptr,
                                                                         0,
                                                                         3,
                                                                         (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_LOFD_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_LOFD_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_LOFD_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_LOFD_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_field_set( b_ptr,
                                                                        h_ptr,
                                                                        word_number,
                                                                        mask,
                                                                        field_ofs,
                                                                        value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_LOFD_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_LOFD_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_LOFD_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_ENABLE_array_read( b_ptr,
                                                                               h_ptr,
                                                                               word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_LOFD_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_IDLE_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_IDLE_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_IDLE_E_set");
    mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_burst_write( b_ptr,
                                                                   h_ptr,
                                                                   0,
                                                                   3,
                                                                   value);
}

static INLINE void mapotn_rgfpf_lfield_IDLE_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_IDLE_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_IDLE_E_get");
    mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_burst_read( b_ptr,
                                                                  h_ptr,
                                                                  0,
                                                                  3,
                                                                  (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_IDLE_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_IDLE_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_IDLE_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_IDLE_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_field_set( b_ptr,
                                                                 h_ptr,
                                                                 word_number,
                                                                 mask,
                                                                 field_ofs,
                                                                 value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_IDLE_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_IDLE_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_IDLE_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_ENABLE_array_read( b_ptr,
                                                                        h_ptr,
                                                                        word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_IDLE_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_CTRLFRM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CTRLFRM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CTRLFRM_E_set");
    mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_burst_write( b_ptr,
                                                                               h_ptr,
                                                                               0,
                                                                               3,
                                                                               value);
}

static INLINE void mapotn_rgfpf_lfield_CTRLFRM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CTRLFRM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CTRLFRM_E_get");
    mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_burst_read( b_ptr,
                                                                              h_ptr,
                                                                              0,
                                                                              3,
                                                                              (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_CTRLFRM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_CTRLFRM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CTRLFRM_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CTRLFRM_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_field_set( b_ptr,
                                                                             h_ptr,
                                                                             word_number,
                                                                             mask,
                                                                             field_ofs,
                                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CTRLFRM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CTRLFRM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CTRLFRM_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_ENABLE_array_read( b_ptr,
                                                                                    h_ptr,
                                                                                    word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CTRLFRM_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_UNPACK_FIFO_DROP_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UNPACK_FIFO_DROP_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UNPACK_FIFO_DROP_E_set");
    mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_burst_write( b_ptr,
                                                                h_ptr,
                                                                0,
                                                                3,
                                                                value);
}

static INLINE void mapotn_rgfpf_lfield_UNPACK_FIFO_DROP_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UNPACK_FIFO_DROP_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UNPACK_FIFO_DROP_E_get");
    mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_burst_read( b_ptr,
                                                               h_ptr,
                                                               0,
                                                               3,
                                                               (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_field_set( b_ptr,
                                                              h_ptr,
                                                              word_number,
                                                              mask,
                                                              field_ofs,
                                                              value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_UNPACK_DROP_INTR_ENABLE_array_read( b_ptr,
                                                                     h_ptr,
                                                                     word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_UCHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UCHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UCHEC_E_set");
    mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_burst_write( b_ptr,
                                                                                 h_ptr,
                                                                                 0,
                                                                                 3,
                                                                                 value);
}

static INLINE void mapotn_rgfpf_lfield_UCHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UCHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UCHEC_E_get");
    mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_burst_read( b_ptr,
                                                                                h_ptr,
                                                                                0,
                                                                                3,
                                                                                (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_UCHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_UCHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UCHEC_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UCHEC_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_field_set( b_ptr,
                                                                               h_ptr,
                                                                               word_number,
                                                                               mask,
                                                                               field_ofs,
                                                                               value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_UCHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_UCHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UCHEC_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_UNCORRECTABLE_CHEC_ERROR_INTR_ENABLE_array_read( b_ptr,
                                                                                      h_ptr,
                                                                                      word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UCHEC_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_CCHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CCHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CCHEC_E_set");
    mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_burst_write( b_ptr,
                                                                    h_ptr,
                                                                    0,
                                                                    3,
                                                                    value);
}

static INLINE void mapotn_rgfpf_lfield_CCHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CCHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CCHEC_E_get");
    mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_burst_read( b_ptr,
                                                                   h_ptr,
                                                                   0,
                                                                   3,
                                                                   (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_CCHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_CCHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CCHEC_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CCHEC_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  word_number,
                                                                  mask,
                                                                  field_ofs,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CCHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CCHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CCHEC_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_CCHEC_ERROR_INTR_ENABLE_array_read( b_ptr,
                                                                         h_ptr,
                                                                         word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CCHEC_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_UTHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UTHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UTHEC_E_set");
    mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_burst_write( b_ptr,
                                                                    h_ptr,
                                                                    0,
                                                                    3,
                                                                    value);
}

static INLINE void mapotn_rgfpf_lfield_UTHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UTHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UTHEC_E_get");
    mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_burst_read( b_ptr,
                                                                   h_ptr,
                                                                   0,
                                                                   3,
                                                                   (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_UTHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_UTHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UTHEC_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UTHEC_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  word_number,
                                                                  mask,
                                                                  field_ofs,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_UTHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_UTHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UTHEC_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_UTHEC_ERROR_INTR_ENABLE_array_read( b_ptr,
                                                                         h_ptr,
                                                                         word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UTHEC_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_CTHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CTHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CTHEC_E_set");
    mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_burst_write( b_ptr,
                                                                    h_ptr,
                                                                    0,
                                                                    3,
                                                                    value);
}

static INLINE void mapotn_rgfpf_lfield_CTHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CTHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CTHEC_E_get");
    mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_burst_read( b_ptr,
                                                                   h_ptr,
                                                                   0,
                                                                   3,
                                                                   (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_CTHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_CTHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CTHEC_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CTHEC_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  word_number,
                                                                  mask,
                                                                  field_ofs,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CTHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CTHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CTHEC_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_ENABLE_array_read( b_ptr,
                                                                         h_ptr,
                                                                         word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CTHEC_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_UEHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UEHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UEHEC_E_set");
    mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_burst_write( b_ptr,
                                                                                 h_ptr,
                                                                                 0,
                                                                                 3,
                                                                                 value);
}

static INLINE void mapotn_rgfpf_lfield_UEHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UEHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UEHEC_E_get");
    mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_burst_read( b_ptr,
                                                                                h_ptr,
                                                                                0,
                                                                                3,
                                                                                (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_UEHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_UEHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UEHEC_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UEHEC_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_field_set( b_ptr,
                                                                               h_ptr,
                                                                               word_number,
                                                                               mask,
                                                                               field_ofs,
                                                                               value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_UEHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_UEHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UEHEC_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_ENABLE_array_read( b_ptr,
                                                                                      h_ptr,
                                                                                      word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UEHEC_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_CEHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CEHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CEHEC_E_set");
    mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_burst_write( b_ptr,
                                                                    h_ptr,
                                                                    0,
                                                                    3,
                                                                    value);
}

static INLINE void mapotn_rgfpf_lfield_CEHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CEHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CEHEC_E_get");
    mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_burst_read( b_ptr,
                                                                   h_ptr,
                                                                   0,
                                                                   3,
                                                                   (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_CEHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_CEHEC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CEHEC_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CEHEC_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  word_number,
                                                                  mask,
                                                                  field_ofs,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CEHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CEHEC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CEHEC_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_CEHEC_ERROR_INTR_ENABLE_array_read( b_ptr,
                                                                         h_ptr,
                                                                         word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CEHEC_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_EXI_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_EXI_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_EXI_E_set");
    mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_burst_write( b_ptr,
                                                                           h_ptr,
                                                                           0,
                                                                           3,
                                                                           value);
}

static INLINE void mapotn_rgfpf_lfield_EXI_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_EXI_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_EXI_E_get");
    mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_burst_read( b_ptr,
                                                                          h_ptr,
                                                                          0,
                                                                          3,
                                                                          (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_EXI_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_EXI_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_EXI_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_EXI_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_field_set( b_ptr,
                                                                         h_ptr,
                                                                         word_number,
                                                                         mask,
                                                                         field_ofs,
                                                                         value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_EXI_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_EXI_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_EXI_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_ENABLE_array_read( b_ptr,
                                                                                h_ptr,
                                                                                word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_EXI_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_PTI_UPI_MSMCH_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_PTI_UPI_MSMCH_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_PTI_UPI_MSMCH_E_set");
    mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_burst_write( b_ptr,
                                                                        h_ptr,
                                                                        0,
                                                                        3,
                                                                        value);
}

static INLINE void mapotn_rgfpf_lfield_PTI_UPI_MSMCH_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_PTI_UPI_MSMCH_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_PTI_UPI_MSMCH_E_get");
    mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_burst_read( b_ptr,
                                                                       h_ptr,
                                                                       0,
                                                                       3,
                                                                       (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      word_number,
                                                                      mask,
                                                                      field_ofs,
                                                                      value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_ENABLE_array_read( b_ptr,
                                                                             h_ptr,
                                                                             word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_GENERIC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_GENERIC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_GENERIC_E_set");
    mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_burst_write( b_ptr,
                                                                               h_ptr,
                                                                               0,
                                                                               3,
                                                                               value);
}

static INLINE void mapotn_rgfpf_lfield_GENERIC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_GENERIC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_GENERIC_E_get");
    mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_burst_read( b_ptr,
                                                                              h_ptr,
                                                                              0,
                                                                              3,
                                                                              (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_GENERIC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_GENERIC_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_GENERIC_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_GENERIC_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_field_set( b_ptr,
                                                                             h_ptr,
                                                                             word_number,
                                                                             mask,
                                                                             field_ofs,
                                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_GENERIC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_GENERIC_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_GENERIC_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_ENABLE_array_read( b_ptr,
                                                                                    h_ptr,
                                                                                    word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_GENERIC_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_CSF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CSF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CSF_E_set");
    mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_burst_write( b_ptr,
                                                            h_ptr,
                                                            0,
                                                            3,
                                                            value);
}

static INLINE void mapotn_rgfpf_lfield_CSF_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CSF_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CSF_E_get");
    mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_burst_read( b_ptr,
                                                           h_ptr,
                                                           0,
                                                           3,
                                                           (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_CSF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_CSF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CSF_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CSF_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_field_set( b_ptr,
                                                          h_ptr,
                                                          word_number,
                                                          mask,
                                                          field_ofs,
                                                          value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CSF_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CSF_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CSF_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_CSF_INTR_ENABLE_array_read( b_ptr,
                                                                 h_ptr,
                                                                 word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CSF_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_DROP_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DROP_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DROP_E_set");
    mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_burst_write( b_ptr,
                                                                      h_ptr,
                                                                      0,
                                                                      3,
                                                                      value);
}

static INLINE void mapotn_rgfpf_lfield_DROP_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DROP_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DROP_E_get");
    mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_burst_read( b_ptr,
                                                                     h_ptr,
                                                                     0,
                                                                     3,
                                                                     (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_DROP_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_DROP_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DROP_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DROP_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_field_set( b_ptr,
                                                                    h_ptr,
                                                                    word_number,
                                                                    mask,
                                                                    field_ofs,
                                                                    value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_DROP_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_DROP_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DROP_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_ENABLE_array_read( b_ptr,
                                                                           h_ptr,
                                                                           word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DROP_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_DATAFRM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DATAFRM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DATAFRM_E_set");
    mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_burst_write( b_ptr,
                                                                          h_ptr,
                                                                          0,
                                                                          3,
                                                                          value);
}

static INLINE void mapotn_rgfpf_lfield_DATAFRM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DATAFRM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DATAFRM_E_get");
    mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_burst_read( b_ptr,
                                                                         h_ptr,
                                                                         0,
                                                                         3,
                                                                         (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_DATAFRM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_DATAFRM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DATAFRM_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DATAFRM_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_field_set( b_ptr,
                                                                        h_ptr,
                                                                        word_number,
                                                                        mask,
                                                                        field_ofs,
                                                                        value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_DATAFRM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_DATAFRM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DATAFRM_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_ENABLE_array_read( b_ptr,
                                                                               h_ptr,
                                                                               word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DATAFRM_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_PAUSE_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_PAUSE_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_PAUSE_E_set");
    mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_burst_write( b_ptr,
                                                          h_ptr,
                                                          0,
                                                          3,
                                                          value);
}

static INLINE void mapotn_rgfpf_lfield_PAUSE_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_PAUSE_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_PAUSE_E_get");
    mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_burst_read( b_ptr,
                                                         h_ptr,
                                                         0,
                                                         3,
                                                         (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_PAUSE_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_PAUSE_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PAUSE_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_PAUSE_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_field_set( b_ptr,
                                                        h_ptr,
                                                        word_number,
                                                        mask,
                                                        field_ofs,
                                                        value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_PAUSE_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_PAUSE_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PAUSE_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_PAUSE_INTR_ENABLE_array_read( b_ptr,
                                                               h_ptr,
                                                               word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_PAUSE_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_MAX_FRM_LEN_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_MAX_FRM_LEN_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_MAX_FRM_LEN_E_set");
    mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_burst_write( b_ptr,
                                                                  h_ptr,
                                                                  0,
                                                                  3,
                                                                  value);
}

static INLINE void mapotn_rgfpf_lfield_MAX_FRM_LEN_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_MAX_FRM_LEN_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_MAX_FRM_LEN_E_get");
    mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_burst_read( b_ptr,
                                                                 h_ptr,
                                                                 0,
                                                                 3,
                                                                 (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_MAX_FRM_LEN_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_MAX_FRM_LEN_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_MAX_FRM_LEN_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_MAX_FRM_LEN_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_field_set( b_ptr,
                                                                h_ptr,
                                                                word_number,
                                                                mask,
                                                                field_ofs,
                                                                value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_MAX_FRM_LEN_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_MAX_FRM_LEN_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_MAX_FRM_LEN_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_MAX_FL_VIOALT_INTR_ENABLE_array_read( b_ptr,
                                                                       h_ptr,
                                                                       word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_MAX_FRM_LEN_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_MIN_FRM_LEN_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_MIN_FRM_LEN_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_MIN_FRM_LEN_E_set");
    mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_burst_write( b_ptr,
                                                                  h_ptr,
                                                                  0,
                                                                  3,
                                                                  value);
}

static INLINE void mapotn_rgfpf_lfield_MIN_FRM_LEN_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_MIN_FRM_LEN_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_MIN_FRM_LEN_E_get");
    mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_burst_read( b_ptr,
                                                                 h_ptr,
                                                                 0,
                                                                 3,
                                                                 (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_MIN_FRM_LEN_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_MIN_FRM_LEN_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_MIN_FRM_LEN_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_MIN_FRM_LEN_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_field_set( b_ptr,
                                                                h_ptr,
                                                                word_number,
                                                                mask,
                                                                field_ofs,
                                                                value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_MIN_FRM_LEN_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_MIN_FRM_LEN_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_MIN_FRM_LEN_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_MIN_FL_VIOALT_INTR_ENABLE_array_read( b_ptr,
                                                                       h_ptr,
                                                                       word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_MIN_FRM_LEN_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_PFCSE_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_PFCSE_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_PFCSE_E_set");
    mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_burst_write( b_ptr,
                                                                h_ptr,
                                                                0,
                                                                3,
                                                                value);
}

static INLINE void mapotn_rgfpf_lfield_PFCSE_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_PFCSE_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_PFCSE_E_get");
    mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_burst_read( b_ptr,
                                                               h_ptr,
                                                               0,
                                                               3,
                                                               (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_PFCSE_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_PFCSE_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PFCSE_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_PFCSE_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_field_set( b_ptr,
                                                              h_ptr,
                                                              word_number,
                                                              mask,
                                                              field_ofs,
                                                              value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_PFCSE_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_PFCSE_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PFCSE_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_ENABLE_array_read( b_ptr,
                                                                     h_ptr,
                                                                     word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_PFCSE_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_DWNSTRM_FRM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DWNSTRM_FRM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DWNSTRM_FRM_E_set");
    mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_burst_write( b_ptr,
                                                                   h_ptr,
                                                                   0,
                                                                   3,
                                                                   value);
}

static INLINE void mapotn_rgfpf_lfield_DWNSTRM_FRM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DWNSTRM_FRM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DWNSTRM_FRM_E_get");
    mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_burst_read( b_ptr,
                                                                  h_ptr,
                                                                  0,
                                                                  3,
                                                                  (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_DWNSTRM_FRM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_DWNSTRM_FRM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DWNSTRM_FRM_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DWNSTRM_FRM_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_field_set( b_ptr,
                                                                 h_ptr,
                                                                 word_number,
                                                                 mask,
                                                                 field_ofs,
                                                                 value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_DWNSTRM_FRM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_DWNSTRM_FRM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DWNSTRM_FRM_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_DOWNSTRM_FRAME_INTR_ENABLE_array_read( b_ptr,
                                                                        h_ptr,
                                                                        word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DWNSTRM_FRM_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_DATA_AV_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_DATA_AV_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CPU_FIFO_DATA_AV_E_set");
    mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_burst_write( b_ptr,
                                                                     h_ptr,
                                                                     0,
                                                                     3,
                                                                     value);
}

static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_DATA_AV_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_DATA_AV_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CPU_FIFO_DATA_AV_E_get");
    mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_burst_read( b_ptr,
                                                                    h_ptr,
                                                                    0,
                                                                    3,
                                                                    (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_field_set( b_ptr,
                                                                   h_ptr,
                                                                   word_number,
                                                                   mask,
                                                                   field_ofs,
                                                                   value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_ENABLE_array_read( b_ptr,
                                                                          h_ptr,
                                                                          word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_OVF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_OVF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CPU_FIFO_OVF_E_set");
    mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_burst_write( b_ptr,
                                                                           h_ptr,
                                                                           0,
                                                                           3,
                                                                           value);
}

static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_OVF_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_OVF_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CPU_FIFO_OVF_E_get");
    mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_burst_read( b_ptr,
                                                                          h_ptr,
                                                                          0,
                                                                          3,
                                                                          (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_field_set( b_ptr,
                                                                         h_ptr,
                                                                         word_number,
                                                                         mask,
                                                                         field_ofs,
                                                                         value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_ENABLE_array_read( b_ptr,
                                                                                h_ptr,
                                                                                word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_SSF_SF_RCVD_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_SSF_SF_RCVD_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_SSF_SF_RCVD_E_set");
    mapotn_rgfpf_reg_SSF_SF_INT_EN_array_burst_write( b_ptr,
                                                      h_ptr,
                                                      0,
                                                      3,
                                                      value);
}

static INLINE void mapotn_rgfpf_lfield_SSF_SF_RCVD_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_SSF_SF_RCVD_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_SSF_SF_RCVD_E_get");
    mapotn_rgfpf_reg_SSF_SF_INT_EN_array_burst_read( b_ptr,
                                                     h_ptr,
                                                     0,
                                                     3,
                                                     (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_SSF_SF_RCVD_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_SSF_SF_RCVD_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_SSF_SF_RCVD_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_SSF_SF_RCVD_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_SSF_SF_INT_EN_array_field_set( b_ptr,
                                                    h_ptr,
                                                    word_number,
                                                    mask,
                                                    field_ofs,
                                                    value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_SSF_SF_RCVD_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_SSF_SF_RCVD_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_SSF_SF_RCVD_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_SSF_SF_INT_EN_array_read( b_ptr,
                                                           h_ptr,
                                                           word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_SSF_SF_RCVD_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_HAO_STATUS_AVL_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_HAO_STATUS_AVL_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_HAO_STATUS_AVL_E_set");
    mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_burst_write( b_ptr,
                                                        h_ptr,
                                                        0,
                                                        3,
                                                        value);
}

static INLINE void mapotn_rgfpf_lfield_HAO_STATUS_AVL_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_HAO_STATUS_AVL_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_HAO_STATUS_AVL_E_get");
    mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_burst_read( b_ptr,
                                                       h_ptr,
                                                       0,
                                                       3,
                                                       (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_field_set( b_ptr,
                                                      h_ptr,
                                                      word_number,
                                                      mask,
                                                      field_ofs,
                                                      value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_HAO_STAT_INT_EN_array_read( b_ptr,
                                                             h_ptr,
                                                             word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_DPLM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DPLM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DPLM_E_set");
    mapotn_rgfpf_reg_DPLM_INT_EN_array_burst_write( b_ptr,
                                                    h_ptr,
                                                    0,
                                                    3,
                                                    value);
}

static INLINE void mapotn_rgfpf_lfield_DPLM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DPLM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DPLM_E_get");
    mapotn_rgfpf_reg_DPLM_INT_EN_array_burst_read( b_ptr,
                                                   h_ptr,
                                                   0,
                                                   3,
                                                   (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_DPLM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_DPLM_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DPLM_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DPLM_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_DPLM_INT_EN_array_field_set( b_ptr,
                                                  h_ptr,
                                                  word_number,
                                                  mask,
                                                  field_ofs,
                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_DPLM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_DPLM_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DPLM_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_DPLM_INT_EN_array_read( b_ptr,
                                                         h_ptr,
                                                         word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DPLM_E_get", start_bit, stop_bit, value );
    return value;
}

static INLINE void mapotn_rgfpf_lfield_OPU_CSF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_OPU_CSF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_OPU_CSF_E_set");
    mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_burst_write( b_ptr,
                                                       h_ptr,
                                                       0,
                                                       3,
                                                       value);
}

static INLINE void mapotn_rgfpf_lfield_OPU_CSF_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_OPU_CSF_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_OPU_CSF_E_get");
    mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_burst_read( b_ptr,
                                                      h_ptr,
                                                      0,
                                                      3,
                                                      (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_OPU_CSF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_OPU_CSF_E_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_OPU_CSF_E_set", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_OPU_CSF_E_set", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_field_set( b_ptr,
                                                     h_ptr,
                                                     word_number,
                                                     mask,
                                                     field_ofs,
                                                     value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_OPU_CSF_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_OPU_CSF_E_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_OPU_CSF_E_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_OPU_CSF_INT_EN_array_read( b_ptr,
                                                            h_ptr,
                                                            word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_OPU_CSF_E_get", start_bit, stop_bit, value );
    return value;
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_sync
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_field_CSF_ST_AV_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CSF_ST_AV_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CSF_ST_AV_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_CSF_ST_AV_I_set_to_clear", value );

    /* (0x0003047c bits 0) field CSF_ST_AV_I of register PMC_RGFPF96_CORE_REG_CSF_ST_AV_INTR */
    mapotn_rgfpf_reg_CSF_ST_AV_INTR_action_on_write_field_set( b_ptr,
                                                               h_ptr,
                                                               RGFPF96_CORE_REG_CSF_ST_AV_INTR_BIT_CSF_ST_AV_I_MSK,
                                                               RGFPF96_CORE_REG_CSF_ST_AV_INTR_BIT_CSF_ST_AV_I_OFF,
                                                               value);
}

static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_AV_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_AV_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0003047c bits 0) field CSF_ST_AV_I of register PMC_RGFPF96_CORE_REG_CSF_ST_AV_INTR */
    reg_value = mapotn_rgfpf_reg_CSF_ST_AV_INTR_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_CSF_ST_AV_INTR_BIT_CSF_ST_AV_I_MSK) >> RGFPF96_CORE_REG_CSF_ST_AV_INTR_BIT_CSF_ST_AV_I_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_CSF_ST_AV_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_CSF_ST_AV_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 value,
                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                        UINT32 max_count,
                                                                        UINT32 *num_failed_polls,
                                                                        UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_CSF_ST_AV_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 value,
                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                        UINT32 max_count,
                                                                        UINT32 *num_failed_polls,
                                                                        UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "mapotn_rgfpf_field_CSF_ST_AV_I_poll", value );

    /* (0x0003047c bits 0) field CSF_ST_AV_I of register PMC_RGFPF96_CORE_REG_CSF_ST_AV_INTR */
    return mapotn_rgfpf_reg_CSF_ST_AV_INTR_poll( b_ptr,
                                                 h_ptr,
                                                 RGFPF96_CORE_REG_CSF_ST_AV_INTR_BIT_CSF_ST_AV_I_MSK,
                                                 (value<<RGFPF96_CORE_REG_CSF_ST_AV_INTR_BIT_CSF_ST_AV_I_OFF),
                                                 cmp,
                                                 max_count,
                                                 num_failed_polls,
                                                 delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_field_CSF_ST_FIFO_OF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CSF_ST_FIFO_OF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CSF_ST_FIFO_OF_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_CSF_ST_FIFO_OF_I_set_to_clear", value );

    /* (0x00030480 bits 0) field CSF_ST_FIFO_OF_I of register PMC_RGFPF96_CORE_REG_CSF_ST_FIFO_OF_INTR */
    mapotn_rgfpf_reg_CSF_ST_FIFO_OF_INTR_action_on_write_field_set( b_ptr,
                                                                    h_ptr,
                                                                    RGFPF96_CORE_REG_CSF_ST_FIFO_OF_INTR_BIT_CSF_ST_FIFO_OF_I_MSK,
                                                                    RGFPF96_CORE_REG_CSF_ST_FIFO_OF_INTR_BIT_CSF_ST_FIFO_OF_I_OFF,
                                                                    value);
}

static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_FIFO_OF_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_FIFO_OF_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030480 bits 0) field CSF_ST_FIFO_OF_I of register PMC_RGFPF96_CORE_REG_CSF_ST_FIFO_OF_INTR */
    reg_value = mapotn_rgfpf_reg_CSF_ST_FIFO_OF_INTR_read( b_ptr,
                                                           h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_CSF_ST_FIFO_OF_INTR_BIT_CSF_ST_FIFO_OF_I_MSK) >> RGFPF96_CORE_REG_CSF_ST_FIFO_OF_INTR_BIT_CSF_ST_FIFO_OF_I_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_CSF_ST_FIFO_OF_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_CSF_ST_FIFO_OF_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_CSF_ST_FIFO_OF_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "mapotn_rgfpf_field_CSF_ST_FIFO_OF_I_poll", value );

    /* (0x00030480 bits 0) field CSF_ST_FIFO_OF_I of register PMC_RGFPF96_CORE_REG_CSF_ST_FIFO_OF_INTR */
    return mapotn_rgfpf_reg_CSF_ST_FIFO_OF_INTR_poll( b_ptr,
                                                      h_ptr,
                                                      RGFPF96_CORE_REG_CSF_ST_FIFO_OF_INTR_BIT_CSF_ST_FIFO_OF_I_MSK,
                                                      (value<<RGFPF96_CORE_REG_CSF_ST_FIFO_OF_INTR_BIT_CSF_ST_FIFO_OF_I_OFF),
                                                      cmp,
                                                      max_count,
                                                      num_failed_polls,
                                                      delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_field_PMON_TRFR_END_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PMON_TRFR_END_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PMON_TRFR_END_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_PMON_TRFR_END_I_set_to_clear", value );

    /* (0x00030544 bits 1) field PMON_TRFR_END_I of register PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR */
    mapotn_rgfpf_reg_PMON_TRANSFER_INTR_action_on_write_field_set( b_ptr,
                                                                   h_ptr,
                                                                   RGFPF96_CORE_REG_PMON_TRANSFER_INTR_BIT_PMON_TRFR_END_I_MSK,
                                                                   RGFPF96_CORE_REG_PMON_TRANSFER_INTR_BIT_PMON_TRFR_END_I_OFF,
                                                                   value);
}

static INLINE UINT32 mapotn_rgfpf_field_PMON_TRFR_END_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PMON_TRFR_END_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030544 bits 1) field PMON_TRFR_END_I of register PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR */
    reg_value = mapotn_rgfpf_reg_PMON_TRANSFER_INTR_read( b_ptr,
                                                          h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_PMON_TRANSFER_INTR_BIT_PMON_TRFR_END_I_MSK) >> RGFPF96_CORE_REG_PMON_TRANSFER_INTR_BIT_PMON_TRFR_END_I_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_PMON_TRFR_END_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_PMON_TRFR_END_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 value,
                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                            UINT32 max_count,
                                                                            UINT32 *num_failed_polls,
                                                                            UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_PMON_TRFR_END_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 value,
                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                            UINT32 max_count,
                                                                            UINT32 *num_failed_polls,
                                                                            UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "mapotn_rgfpf_field_PMON_TRFR_END_I_poll", value );

    /* (0x00030544 bits 1) field PMON_TRFR_END_I of register PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR */
    return mapotn_rgfpf_reg_PMON_TRANSFER_INTR_poll( b_ptr,
                                                     h_ptr,
                                                     RGFPF96_CORE_REG_PMON_TRANSFER_INTR_BIT_PMON_TRFR_END_I_MSK,
                                                     (value<<RGFPF96_CORE_REG_PMON_TRANSFER_INTR_BIT_PMON_TRFR_END_I_OFF),
                                                     cmp,
                                                     max_count,
                                                     num_failed_polls,
                                                     delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_field_PMON_TRFR_START_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PMON_TRFR_START_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PMON_TRFR_START_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_PMON_TRFR_START_I_set_to_clear", value );

    /* (0x00030544 bits 0) field PMON_TRFR_START_I of register PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR */
    mapotn_rgfpf_reg_PMON_TRANSFER_INTR_action_on_write_field_set( b_ptr,
                                                                   h_ptr,
                                                                   RGFPF96_CORE_REG_PMON_TRANSFER_INTR_BIT_PMON_TRFR_START_I_MSK,
                                                                   RGFPF96_CORE_REG_PMON_TRANSFER_INTR_BIT_PMON_TRFR_START_I_OFF,
                                                                   value);
}

static INLINE UINT32 mapotn_rgfpf_field_PMON_TRFR_START_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PMON_TRFR_START_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030544 bits 0) field PMON_TRFR_START_I of register PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR */
    reg_value = mapotn_rgfpf_reg_PMON_TRANSFER_INTR_read( b_ptr,
                                                          h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_PMON_TRANSFER_INTR_BIT_PMON_TRFR_START_I_MSK) >> RGFPF96_CORE_REG_PMON_TRANSFER_INTR_BIT_PMON_TRFR_START_I_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_PMON_TRFR_START_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_PMON_TRFR_START_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_PMON_TRFR_START_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "mapotn_rgfpf_field_PMON_TRFR_START_I_poll", value );

    /* (0x00030544 bits 0) field PMON_TRFR_START_I of register PMC_RGFPF96_CORE_REG_PMON_TRANSFER_INTR */
    return mapotn_rgfpf_reg_PMON_TRANSFER_INTR_poll( b_ptr,
                                                     h_ptr,
                                                     RGFPF96_CORE_REG_PMON_TRANSFER_INTR_BIT_PMON_TRFR_START_I_MSK,
                                                     (value<<RGFPF96_CORE_REG_PMON_TRANSFER_INTR_BIT_PMON_TRFR_START_I_OFF),
                                                     cmp,
                                                     max_count,
                                                     num_failed_polls,
                                                     delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_I_set_to_clear", value );

    /* (0x00030548 bits 2) field CPU_WRRPT_AFIFO_OVF_I of register PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR */
    mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_action_on_write_field_set( b_ptr,
                                                                    h_ptr,
                                                                    RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_CPU_WRRPT_AFIFO_OVF_I_MSK,
                                                                    RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_CPU_WRRPT_AFIFO_OVF_I_OFF,
                                                                    value);
}

static INLINE UINT32 mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030548 bits 2) field CPU_WRRPT_AFIFO_OVF_I of register PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR */
    reg_value = mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_read( b_ptr,
                                                           h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_CPU_WRRPT_AFIFO_OVF_I_MSK) >> RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_CPU_WRRPT_AFIFO_OVF_I_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 value,
                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                  UINT32 max_count,
                                                                                  UINT32 *num_failed_polls,
                                                                                  UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 value,
                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                  UINT32 max_count,
                                                                                  UINT32 *num_failed_polls,
                                                                                  UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "mapotn_rgfpf_field_CPU_WRRPT_AFIFO_OVF_I_poll", value );

    /* (0x00030548 bits 2) field CPU_WRRPT_AFIFO_OVF_I of register PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR */
    return mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_poll( b_ptr,
                                                      h_ptr,
                                                      RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_CPU_WRRPT_AFIFO_OVF_I_MSK,
                                                      (value<<RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_CPU_WRRPT_AFIFO_OVF_I_OFF),
                                                      cmp,
                                                      max_count,
                                                      num_failed_polls,
                                                      delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_I_set_to_clear", value );

    /* (0x00030548 bits 1) field CPU_RDRPT_AFIFO_OVF_I of register PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR */
    mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_action_on_write_field_set( b_ptr,
                                                                    h_ptr,
                                                                    RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_CPU_RDRPT_AFIFO_OVF_I_MSK,
                                                                    RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_CPU_RDRPT_AFIFO_OVF_I_OFF,
                                                                    value);
}

static INLINE UINT32 mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030548 bits 1) field CPU_RDRPT_AFIFO_OVF_I of register PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR */
    reg_value = mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_read( b_ptr,
                                                           h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_CPU_RDRPT_AFIFO_OVF_I_MSK) >> RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_CPU_RDRPT_AFIFO_OVF_I_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 value,
                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                  UINT32 max_count,
                                                                                  UINT32 *num_failed_polls,
                                                                                  UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 value,
                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                  UINT32 max_count,
                                                                                  UINT32 *num_failed_polls,
                                                                                  UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "mapotn_rgfpf_field_CPU_RDRPT_AFIFO_OVF_I_poll", value );

    /* (0x00030548 bits 1) field CPU_RDRPT_AFIFO_OVF_I of register PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR */
    return mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_poll( b_ptr,
                                                      h_ptr,
                                                      RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_CPU_RDRPT_AFIFO_OVF_I_MSK,
                                                      (value<<RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_CPU_RDRPT_AFIFO_OVF_I_OFF),
                                                      cmp,
                                                      max_count,
                                                      num_failed_polls,
                                                      delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_field_UNPACK_AFIFO_OVF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_UNPACK_AFIFO_OVF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_UNPACK_AFIFO_OVF_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_UNPACK_AFIFO_OVF_I_set_to_clear", value );

    /* (0x00030548 bits 0) field UNPACK_AFIFO_OVF_I of register PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR */
    mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_action_on_write_field_set( b_ptr,
                                                                    h_ptr,
                                                                    RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_UNPACK_AFIFO_OVF_I_MSK,
                                                                    RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_UNPACK_AFIFO_OVF_I_OFF,
                                                                    value);
}

static INLINE UINT32 mapotn_rgfpf_field_UNPACK_AFIFO_OVF_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_UNPACK_AFIFO_OVF_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030548 bits 0) field UNPACK_AFIFO_OVF_I of register PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR */
    reg_value = mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_read( b_ptr,
                                                           h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_UNPACK_AFIFO_OVF_I_MSK) >> RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_UNPACK_AFIFO_OVF_I_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_UNPACK_AFIFO_OVF_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_UNPACK_AFIFO_OVF_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_UNPACK_AFIFO_OVF_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "mapotn_rgfpf_field_UNPACK_AFIFO_OVF_I_poll", value );

    /* (0x00030548 bits 0) field UNPACK_AFIFO_OVF_I of register PMC_RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR */
    return mapotn_rgfpf_reg_ASYNC_FIFO_OVF_INTR_poll( b_ptr,
                                                      h_ptr,
                                                      RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_UNPACK_AFIFO_OVF_I_MSK,
                                                      (value<<RGFPF96_CORE_REG_ASYNC_FIFO_OVF_INTR_BIT_UNPACK_AFIFO_OVF_I_OFF),
                                                      cmp,
                                                      max_count,
                                                      num_failed_polls,
                                                      delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_I_set_to_clear", value );

    /* (0x0003058c bits 0) field RCOH_TRNSFR_SHDW_DNE_I of register PMC_RGFPF96_CORE_REG_RCOH_STAT_TRANSFER_DONE_INT */
    mapotn_rgfpf_reg_RCOH_STAT_TRANSFER_DONE_INT_action_on_write_field_set( b_ptr,
                                                                            h_ptr,
                                                                            RGFPF96_CORE_REG_RCOH_STAT_TRANSFER_DONE_INT_BIT_RCOH_TRNSFR_SHDW_DNE_I_MSK,
                                                                            RGFPF96_CORE_REG_RCOH_STAT_TRANSFER_DONE_INT_BIT_RCOH_TRNSFR_SHDW_DNE_I_OFF,
                                                                            value);
}

static INLINE UINT32 mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_I_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0003058c bits 0) field RCOH_TRNSFR_SHDW_DNE_I of register PMC_RGFPF96_CORE_REG_RCOH_STAT_TRANSFER_DONE_INT */
    reg_value = mapotn_rgfpf_reg_RCOH_STAT_TRANSFER_DONE_INT_read( b_ptr,
                                                                   h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_RCOH_STAT_TRANSFER_DONE_INT_BIT_RCOH_TRNSFR_SHDW_DNE_I_MSK) >> RGFPF96_CORE_REG_RCOH_STAT_TRANSFER_DONE_INT_BIT_RCOH_TRNSFR_SHDW_DNE_I_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 value,
                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                   UINT32 max_count,
                                                                                   UINT32 *num_failed_polls,
                                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 value,
                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                   UINT32 max_count,
                                                                                   UINT32 *num_failed_polls,
                                                                                   UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "mapotn_rgfpf_field_RCOH_TRNSFR_SHDW_DNE_I_poll", value );

    /* (0x0003058c bits 0) field RCOH_TRNSFR_SHDW_DNE_I of register PMC_RGFPF96_CORE_REG_RCOH_STAT_TRANSFER_DONE_INT */
    return mapotn_rgfpf_reg_RCOH_STAT_TRANSFER_DONE_INT_poll( b_ptr,
                                                              h_ptr,
                                                              RGFPF96_CORE_REG_RCOH_STAT_TRANSFER_DONE_INT_BIT_RCOH_TRNSFR_SHDW_DNE_I_MSK,
                                                              (value<<RGFPF96_CORE_REG_RCOH_STAT_TRANSFER_DONE_INT_BIT_RCOH_TRNSFR_SHDW_DNE_I_OFF),
                                                              cmp,
                                                              max_count,
                                                              num_failed_polls,
                                                              delay_between_polls_in_microseconds);
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_sync_M_size7__N_burstsize3
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  M,
                                                                         UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  M,
                                                                         UINT32 value[3] )
{
    if (M > 6)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_I_set_to_clear", M, 6);
    IOLOG( "%s  M=%d", "mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_I_set_to_clear", M);
    mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_burst_write( b_ptr,
                                                          h_ptr,
                                                          M,
                                                          0,
                                                          3,
                                                          value);
}

static INLINE void mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  M,
                                                                UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  M,
                                                                UINT32 value[3] )
{
    if (M > 6)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_I_get", M, 6);
    IOLOG( "%s  M=%d", "mapotn_rgfpf_lfield_FRM_LEN_STAT_INTR_I_get", M);
    mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_burst_read( b_ptr,
                                                         h_ptr,
                                                         M,
                                                         0,
                                                         3,
                                                         (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32  M,
                                                                               UINT32 start_bit,
                                                                               UINT32 stop_bit,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                               mapotn_handle_t *h_ptr,
                                                                               UINT32  M,
                                                                               UINT32 start_bit,
                                                                               UINT32 stop_bit,
                                                                               UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    if (M > 6)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_I_set_to_clear", M, 6);
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> M=%d start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_I_set_to_clear", M, start_bit, stop_bit, value);
    mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_action_on_write_field_set( b_ptr,
                                                                        h_ptr,
                                                                        M,
                                                                        word_number,
                                                                        mask,
                                                                        field_ofs,
                                                                        value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  M,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  M,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    if (M > 6)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_I_get", M, 6);
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_read( b_ptr,
                                                               h_ptr,
                                                               M,
                                                               word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> M=%d start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_I_get", M, start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32  M,
                                                                                       UINT32 start_bit,
                                                                                       UINT32 stop_bit,
                                                                                       UINT32 value,
                                                                                       PMC_POLL_COMPARISON_TYPE cmp,
                                                                                       UINT32 max_count,
                                                                                       UINT32 *num_failed_polls,
                                                                                       UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                       mapotn_handle_t *h_ptr,
                                                                                       UINT32  M,
                                                                                       UINT32 start_bit,
                                                                                       UINT32 stop_bit,
                                                                                       UINT32 value,
                                                                                       PMC_POLL_COMPARISON_TYPE cmp,
                                                                                       UINT32 max_count,
                                                                                       UINT32 *num_failed_polls,
                                                                                       UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    if (M > 6)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_I_poll", M, 6);
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> M=%d start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_FRM_LEN_STAT_INTR_I_set_to_clear", M, start_bit, stop_bit);
    return mapotn_rgfpf_reg_FRM_LEN_STAT_INTR_array_poll( b_ptr,
                                                          h_ptr,
                                                          M,
                                                          word_number,
                                                          mask,
                                                          ( value << field_ofs),
                                                          cmp,
                                                          max_count,
                                                          num_failed_polls,
                                                          delay_between_polls_in_microseconds);
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_sync_N_burstsize3
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_lfield_IN_SFAIL_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_IN_SFAIL_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_IN_SFAIL_I_set_to_clear");
    mapotn_rgfpf_reg_IN_SFAIL_INTR_array_burst_write( b_ptr,
                                                      h_ptr,
                                                      0,
                                                      3,
                                                      value);
}

static INLINE void mapotn_rgfpf_lfield_IN_SFAIL_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_IN_SFAIL_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_IN_SFAIL_I_get");
    mapotn_rgfpf_reg_IN_SFAIL_INTR_array_burst_read( b_ptr,
                                                     h_ptr,
                                                     0,
                                                     3,
                                                     (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_IN_SFAIL_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit,
                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_IN_SFAIL_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit,
                                                                      UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_IN_SFAIL_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_IN_SFAIL_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_IN_SFAIL_INTR_array_action_on_write_field_set( b_ptr,
                                                                    h_ptr,
                                                                    word_number,
                                                                    mask,
                                                                    field_ofs,
                                                                    value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_IN_SFAIL_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_IN_SFAIL_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_IN_SFAIL_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_IN_SFAIL_INTR_array_read( b_ptr,
                                                           h_ptr,
                                                           word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_IN_SFAIL_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_IN_SFAIL_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_IN_SFAIL_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_IN_SFAIL_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_IN_SFAIL_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_IN_SFAIL_INTR_array_poll( b_ptr,
                                                      h_ptr,
                                                      word_number,
                                                      mask,
                                                      ( value << field_ofs),
                                                      cmp,
                                                      max_count,
                                                      num_failed_polls,
                                                      delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_LOFD_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_LOFD_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_LOFD_I_set_to_clear");
    mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_burst_write( b_ptr,
                                                                   h_ptr,
                                                                   0,
                                                                   3,
                                                                   value);
}

static INLINE void mapotn_rgfpf_lfield_LOFD_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_LOFD_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_LOFD_I_get");
    mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_burst_read( b_ptr,
                                                                  h_ptr,
                                                                  0,
                                                                  3,
                                                                  (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_LOFD_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_LOFD_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_LOFD_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_LOFD_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_action_on_write_field_set( b_ptr,
                                                                                 h_ptr,
                                                                                 word_number,
                                                                                 mask,
                                                                                 field_ofs,
                                                                                 value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_LOFD_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_LOFD_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_LOFD_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_read( b_ptr,
                                                                        h_ptr,
                                                                        word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_LOFD_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_LOFD_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_LOFD_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_LOFD_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_LOFD_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_LOSS_FRME_DELINEATION_INTR_array_poll( b_ptr,
                                                                   h_ptr,
                                                                   word_number,
                                                                   mask,
                                                                   ( value << field_ofs),
                                                                   cmp,
                                                                   max_count,
                                                                   num_failed_polls,
                                                                   delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_IDLE_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_IDLE_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_IDLE_I_set_to_clear");
    mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_burst_write( b_ptr,
                                                            h_ptr,
                                                            0,
                                                            3,
                                                            value);
}

static INLINE void mapotn_rgfpf_lfield_IDLE_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_IDLE_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_IDLE_I_get");
    mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_burst_read( b_ptr,
                                                           h_ptr,
                                                           0,
                                                           3,
                                                           (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_IDLE_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_IDLE_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_IDLE_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_IDLE_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_action_on_write_field_set( b_ptr,
                                                                          h_ptr,
                                                                          word_number,
                                                                          mask,
                                                                          field_ofs,
                                                                          value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_IDLE_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_IDLE_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_IDLE_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_read( b_ptr,
                                                                 h_ptr,
                                                                 word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_IDLE_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_IDLE_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_IDLE_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_IDLE_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_IDLE_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_IDLE_FRAME_INTR_array_poll( b_ptr,
                                                            h_ptr,
                                                            word_number,
                                                            mask,
                                                            ( value << field_ofs),
                                                            cmp,
                                                            max_count,
                                                            num_failed_polls,
                                                            delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_CTRLFRM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CTRLFRM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CTRLFRM_I_set_to_clear");
    mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_burst_write( b_ptr,
                                                                        h_ptr,
                                                                        0,
                                                                        3,
                                                                        value);
}

static INLINE void mapotn_rgfpf_lfield_CTRLFRM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CTRLFRM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CTRLFRM_I_get");
    mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_burst_read( b_ptr,
                                                                       h_ptr,
                                                                       0,
                                                                       3,
                                                                       (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_CTRLFRM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_CTRLFRM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CTRLFRM_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CTRLFRM_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_action_on_write_field_set( b_ptr,
                                                                                      h_ptr,
                                                                                      word_number,
                                                                                      mask,
                                                                                      field_ofs,
                                                                                      value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CTRLFRM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CTRLFRM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CTRLFRM_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_read( b_ptr,
                                                                             h_ptr,
                                                                             word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CTRLFRM_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CTRLFRM_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 start_bit,
                                                                             UINT32 stop_bit,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CTRLFRM_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 start_bit,
                                                                             UINT32 stop_bit,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CTRLFRM_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_CTRLFRM_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_NON_IDLE_CONTROL_FRAME_INTR_array_poll( b_ptr,
                                                                        h_ptr,
                                                                        word_number,
                                                                        mask,
                                                                        ( value << field_ofs),
                                                                        cmp,
                                                                        max_count,
                                                                        num_failed_polls,
                                                                        delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_UNPACK_FIFO_DROP_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UNPACK_FIFO_DROP_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UNPACK_FIFO_DROP_I_set_to_clear");
    mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_burst_write( b_ptr,
                                                         h_ptr,
                                                         0,
                                                         3,
                                                         value);
}

static INLINE void mapotn_rgfpf_lfield_UNPACK_FIFO_DROP_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UNPACK_FIFO_DROP_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UNPACK_FIFO_DROP_I_get");
    mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_burst_read( b_ptr,
                                                        h_ptr,
                                                        0,
                                                        3,
                                                        (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit,
                                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit,
                                                                              UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_action_on_write_field_set( b_ptr,
                                                                       h_ptr,
                                                                       word_number,
                                                                       mask,
                                                                       field_ofs,
                                                                       value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_read( b_ptr,
                                                              h_ptr,
                                                              word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 start_bit,
                                                                                      UINT32 stop_bit,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 start_bit,
                                                                                      UINT32 stop_bit,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_UNPACK_FIFO_DROP_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_UNPACK_DROP_INTR_array_poll( b_ptr,
                                                         h_ptr,
                                                         word_number,
                                                         mask,
                                                         ( value << field_ofs),
                                                         cmp,
                                                         max_count,
                                                         num_failed_polls,
                                                         delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_UCHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UCHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UCHEC_I_set_to_clear");
    mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_burst_write( b_ptr,
                                                             h_ptr,
                                                             0,
                                                             3,
                                                             value);
}

static INLINE void mapotn_rgfpf_lfield_UCHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UCHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UCHEC_I_get");
    mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_burst_read( b_ptr,
                                                            h_ptr,
                                                            0,
                                                            3,
                                                            (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_UCHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_UCHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UCHEC_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UCHEC_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_action_on_write_field_set( b_ptr,
                                                                           h_ptr,
                                                                           word_number,
                                                                           mask,
                                                                           field_ofs,
                                                                           value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_UCHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_UCHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UCHEC_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_read( b_ptr,
                                                                  h_ptr,
                                                                  word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UCHEC_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_UCHEC_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_UCHEC_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UCHEC_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_UCHEC_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_UCHEC_ERROR_INTR_array_poll( b_ptr,
                                                             h_ptr,
                                                             word_number,
                                                             mask,
                                                             ( value << field_ofs),
                                                             cmp,
                                                             max_count,
                                                             num_failed_polls,
                                                             delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_CCHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CCHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CCHEC_I_set_to_clear");
    mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_burst_write( b_ptr,
                                                                   h_ptr,
                                                                   0,
                                                                   3,
                                                                   value);
}

static INLINE void mapotn_rgfpf_lfield_CCHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CCHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CCHEC_I_get");
    mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_burst_read( b_ptr,
                                                                  h_ptr,
                                                                  0,
                                                                  3,
                                                                  (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_CCHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_CCHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CCHEC_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CCHEC_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_action_on_write_field_set( b_ptr,
                                                                                 h_ptr,
                                                                                 word_number,
                                                                                 mask,
                                                                                 field_ofs,
                                                                                 value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CCHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CCHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CCHEC_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_read( b_ptr,
                                                                        h_ptr,
                                                                        word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CCHEC_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CCHEC_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CCHEC_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CCHEC_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_CCHEC_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_CCHEC_ERROR_ERROR_INTR_array_poll( b_ptr,
                                                                   h_ptr,
                                                                   word_number,
                                                                   mask,
                                                                   ( value << field_ofs),
                                                                   cmp,
                                                                   max_count,
                                                                   num_failed_polls,
                                                                   delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_UTHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UTHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UTHEC_I_set_to_clear");
    mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_burst_write( b_ptr,
                                                                          h_ptr,
                                                                          0,
                                                                          3,
                                                                          value);
}

static INLINE void mapotn_rgfpf_lfield_UTHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UTHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UTHEC_I_get");
    mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_burst_read( b_ptr,
                                                                         h_ptr,
                                                                         0,
                                                                         3,
                                                                         (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_UTHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_UTHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UTHEC_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UTHEC_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_action_on_write_field_set( b_ptr,
                                                                                        h_ptr,
                                                                                        word_number,
                                                                                        mask,
                                                                                        field_ofs,
                                                                                        value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_UTHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_UTHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UTHEC_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_read( b_ptr,
                                                                               h_ptr,
                                                                               word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UTHEC_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_UTHEC_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_UTHEC_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UTHEC_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_UTHEC_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_UNCORRECTABLE_THEC_ERROR_INTR_array_poll( b_ptr,
                                                                          h_ptr,
                                                                          word_number,
                                                                          mask,
                                                                          ( value << field_ofs),
                                                                          cmp,
                                                                          max_count,
                                                                          num_failed_polls,
                                                                          delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_CTHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CTHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CTHEC_I_set_to_clear");
    mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_burst_write( b_ptr,
                                                             h_ptr,
                                                             0,
                                                             3,
                                                             value);
}

static INLINE void mapotn_rgfpf_lfield_CTHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CTHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CTHEC_I_get");
    mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_burst_read( b_ptr,
                                                            h_ptr,
                                                            0,
                                                            3,
                                                            (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_CTHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_CTHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CTHEC_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CTHEC_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_action_on_write_field_set( b_ptr,
                                                                           h_ptr,
                                                                           word_number,
                                                                           mask,
                                                                           field_ofs,
                                                                           value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CTHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CTHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CTHEC_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_read( b_ptr,
                                                                  h_ptr,
                                                                  word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CTHEC_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CTHEC_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CTHEC_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CTHEC_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_CTHEC_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_CTHEC_ERROR_INTR_array_poll( b_ptr,
                                                             h_ptr,
                                                             word_number,
                                                             mask,
                                                             ( value << field_ofs),
                                                             cmp,
                                                             max_count,
                                                             num_failed_polls,
                                                             delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_UEHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UEHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UEHEC_I_set_to_clear");
    mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_burst_write( b_ptr,
                                                                          h_ptr,
                                                                          0,
                                                                          3,
                                                                          value);
}

static INLINE void mapotn_rgfpf_lfield_UEHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_UEHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_UEHEC_I_get");
    mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_burst_read( b_ptr,
                                                                         h_ptr,
                                                                         0,
                                                                         3,
                                                                         (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_UEHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_UEHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UEHEC_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UEHEC_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_action_on_write_field_set( b_ptr,
                                                                                        h_ptr,
                                                                                        word_number,
                                                                                        mask,
                                                                                        field_ofs,
                                                                                        value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_UEHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_UEHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UEHEC_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_read( b_ptr,
                                                                               h_ptr,
                                                                               word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_UEHEC_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_UEHEC_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_UEHEC_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_UEHEC_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_UEHEC_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_UNCORRECTABLE_EHEC_ERROR_INTR_array_poll( b_ptr,
                                                                          h_ptr,
                                                                          word_number,
                                                                          mask,
                                                                          ( value << field_ofs),
                                                                          cmp,
                                                                          max_count,
                                                                          num_failed_polls,
                                                                          delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_CEHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CEHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CEHEC_I_set_to_clear");
    mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_burst_write( b_ptr,
                                                                   h_ptr,
                                                                   0,
                                                                   3,
                                                                   value);
}

static INLINE void mapotn_rgfpf_lfield_CEHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CEHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CEHEC_I_get");
    mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_burst_read( b_ptr,
                                                                  h_ptr,
                                                                  0,
                                                                  3,
                                                                  (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_CEHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_CEHEC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CEHEC_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CEHEC_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_action_on_write_field_set( b_ptr,
                                                                                 h_ptr,
                                                                                 word_number,
                                                                                 mask,
                                                                                 field_ofs,
                                                                                 value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CEHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CEHEC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CEHEC_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_read( b_ptr,
                                                                        h_ptr,
                                                                        word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CEHEC_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CEHEC_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CEHEC_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CEHEC_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_CEHEC_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_CEHEC_ERROR_ERROR_INTR_array_poll( b_ptr,
                                                                   h_ptr,
                                                                   word_number,
                                                                   mask,
                                                                   ( value << field_ofs),
                                                                   cmp,
                                                                   max_count,
                                                                   num_failed_polls,
                                                                   delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_EXI_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_EXI_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_EXI_I_set_to_clear");
    mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_burst_write( b_ptr,
                                                                    h_ptr,
                                                                    0,
                                                                    3,
                                                                    value);
}

static INLINE void mapotn_rgfpf_lfield_EXI_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_EXI_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_EXI_I_get");
    mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_burst_read( b_ptr,
                                                                   h_ptr,
                                                                   0,
                                                                   3,
                                                                   (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_EXI_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_EXI_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_EXI_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_EXI_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_action_on_write_field_set( b_ptr,
                                                                                  h_ptr,
                                                                                  word_number,
                                                                                  mask,
                                                                                  field_ofs,
                                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_EXI_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_EXI_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_EXI_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_read( b_ptr,
                                                                         h_ptr,
                                                                         word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_EXI_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_EXI_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_EXI_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_EXI_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_EXI_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_array_poll( b_ptr,
                                                                    h_ptr,
                                                                    word_number,
                                                                    mask,
                                                                    ( value << field_ofs),
                                                                    cmp,
                                                                    max_count,
                                                                    num_failed_polls,
                                                                    delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_PTI_UPI_MSMCH_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_PTI_UPI_MSMCH_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_PTI_UPI_MSMCH_I_set_to_clear");
    mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_burst_write( b_ptr,
                                                                 h_ptr,
                                                                 0,
                                                                 3,
                                                                 value);
}

static INLINE void mapotn_rgfpf_lfield_PTI_UPI_MSMCH_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_PTI_UPI_MSMCH_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_PTI_UPI_MSMCH_I_get");
    mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_burst_read( b_ptr,
                                                                h_ptr,
                                                                0,
                                                                3,
                                                                (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_action_on_write_field_set( b_ptr,
                                                                               h_ptr,
                                                                               word_number,
                                                                               mask,
                                                                               field_ofs,
                                                                               value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_read( b_ptr,
                                                                      h_ptr,
                                                                      word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 start_bit,
                                                                                   UINT32 stop_bit,
                                                                                   UINT32 value,
                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                   UINT32 max_count,
                                                                                   UINT32 *num_failed_polls,
                                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 start_bit,
                                                                                   UINT32 stop_bit,
                                                                                   UINT32 value,
                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                   UINT32 max_count,
                                                                                   UINT32 *num_failed_polls,
                                                                                   UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_array_poll( b_ptr,
                                                                 h_ptr,
                                                                 word_number,
                                                                 mask,
                                                                 ( value << field_ofs),
                                                                 cmp,
                                                                 max_count,
                                                                 num_failed_polls,
                                                                 delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_GENERIC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_GENERIC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_GENERIC_I_set_to_clear");
    mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_burst_write( b_ptr,
                                                                        h_ptr,
                                                                        0,
                                                                        3,
                                                                        value);
}

static INLINE void mapotn_rgfpf_lfield_GENERIC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_GENERIC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_GENERIC_I_get");
    mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_burst_read( b_ptr,
                                                                       h_ptr,
                                                                       0,
                                                                       3,
                                                                       (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_GENERIC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_GENERIC_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_GENERIC_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_GENERIC_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_action_on_write_field_set( b_ptr,
                                                                                      h_ptr,
                                                                                      word_number,
                                                                                      mask,
                                                                                      field_ofs,
                                                                                      value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_GENERIC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_GENERIC_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_GENERIC_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_read( b_ptr,
                                                                             h_ptr,
                                                                             word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_GENERIC_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_GENERIC_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 start_bit,
                                                                             UINT32 stop_bit,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_GENERIC_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 start_bit,
                                                                             UINT32 stop_bit,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_GENERIC_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_GENERIC_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_GENERIC_MISMATCH_ERROR_INTR_array_poll( b_ptr,
                                                                        h_ptr,
                                                                        word_number,
                                                                        mask,
                                                                        ( value << field_ofs),
                                                                        cmp,
                                                                        max_count,
                                                                        num_failed_polls,
                                                                        delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_CSF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CSF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CSF_I_set_to_clear");
    mapotn_rgfpf_reg_GFP_CSF_INTR_array_burst_write( b_ptr,
                                                     h_ptr,
                                                     0,
                                                     3,
                                                     value);
}

static INLINE void mapotn_rgfpf_lfield_CSF_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CSF_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CSF_I_get");
    mapotn_rgfpf_reg_GFP_CSF_INTR_array_burst_read( b_ptr,
                                                    h_ptr,
                                                    0,
                                                    3,
                                                    (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_CSF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_CSF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CSF_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CSF_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_CSF_INTR_array_action_on_write_field_set( b_ptr,
                                                                   h_ptr,
                                                                   word_number,
                                                                   mask,
                                                                   field_ofs,
                                                                   value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CSF_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CSF_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CSF_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_CSF_INTR_array_read( b_ptr,
                                                          h_ptr,
                                                          word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CSF_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CSF_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CSF_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CSF_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_CSF_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_CSF_INTR_array_poll( b_ptr,
                                                     h_ptr,
                                                     word_number,
                                                     mask,
                                                     ( value << field_ofs),
                                                     cmp,
                                                     max_count,
                                                     num_failed_polls,
                                                     delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_DROP_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DROP_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DROP_I_set_to_clear");
    mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_burst_write( b_ptr,
                                                               h_ptr,
                                                               0,
                                                               3,
                                                               value);
}

static INLINE void mapotn_rgfpf_lfield_DROP_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DROP_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DROP_I_get");
    mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_burst_read( b_ptr,
                                                              h_ptr,
                                                              0,
                                                              3,
                                                              (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_DROP_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_DROP_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DROP_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DROP_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_action_on_write_field_set( b_ptr,
                                                                             h_ptr,
                                                                             word_number,
                                                                             mask,
                                                                             field_ofs,
                                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_DROP_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_DROP_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DROP_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_read( b_ptr,
                                                                    h_ptr,
                                                                    word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DROP_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_DROP_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_DROP_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DROP_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_DROP_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_DROPPED_FRAME_INTR_array_poll( b_ptr,
                                                               h_ptr,
                                                               word_number,
                                                               mask,
                                                               ( value << field_ofs),
                                                               cmp,
                                                               max_count,
                                                               num_failed_polls,
                                                               delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_DATAFRM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DATAFRM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DATAFRM_I_set_to_clear");
    mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_burst_write( b_ptr,
                                                                   h_ptr,
                                                                   0,
                                                                   3,
                                                                   value);
}

static INLINE void mapotn_rgfpf_lfield_DATAFRM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DATAFRM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DATAFRM_I_get");
    mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_burst_read( b_ptr,
                                                                  h_ptr,
                                                                  0,
                                                                  3,
                                                                  (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_DATAFRM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_DATAFRM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DATAFRM_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DATAFRM_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_action_on_write_field_set( b_ptr,
                                                                                 h_ptr,
                                                                                 word_number,
                                                                                 mask,
                                                                                 field_ofs,
                                                                                 value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_DATAFRM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_DATAFRM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DATAFRM_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_read( b_ptr,
                                                                        h_ptr,
                                                                        word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DATAFRM_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_DATAFRM_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 start_bit,
                                                                             UINT32 stop_bit,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_DATAFRM_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 start_bit,
                                                                             UINT32 stop_bit,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DATAFRM_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_DATAFRM_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_CLIENT_DATA_FRAME_INTR_array_poll( b_ptr,
                                                                   h_ptr,
                                                                   word_number,
                                                                   mask,
                                                                   ( value << field_ofs),
                                                                   cmp,
                                                                   max_count,
                                                                   num_failed_polls,
                                                                   delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_PAUSE_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_PAUSE_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_PAUSE_I_set_to_clear");
    mapotn_rgfpf_reg_PAUSE_INTR_array_burst_write( b_ptr,
                                                   h_ptr,
                                                   0,
                                                   3,
                                                   value);
}

static INLINE void mapotn_rgfpf_lfield_PAUSE_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_PAUSE_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_PAUSE_I_get");
    mapotn_rgfpf_reg_PAUSE_INTR_array_burst_read( b_ptr,
                                                  h_ptr,
                                                  0,
                                                  3,
                                                  (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_PAUSE_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_PAUSE_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PAUSE_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_PAUSE_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_PAUSE_INTR_array_action_on_write_field_set( b_ptr,
                                                                 h_ptr,
                                                                 word_number,
                                                                 mask,
                                                                 field_ofs,
                                                                 value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_PAUSE_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_PAUSE_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PAUSE_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_PAUSE_INTR_array_read( b_ptr,
                                                        h_ptr,
                                                        word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_PAUSE_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_PAUSE_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_PAUSE_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PAUSE_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_PAUSE_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_PAUSE_INTR_array_poll( b_ptr,
                                                   h_ptr,
                                                   word_number,
                                                   mask,
                                                   ( value << field_ofs),
                                                   cmp,
                                                   max_count,
                                                   num_failed_polls,
                                                   delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_MAX_FRM_LEN_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_MAX_FRM_LEN_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_MAX_FRM_LEN_I_set_to_clear");
    mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_write( b_ptr,
                                                                            h_ptr,
                                                                            0,
                                                                            3,
                                                                            value);
}

static INLINE void mapotn_rgfpf_lfield_MAX_FRM_LEN_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_MAX_FRM_LEN_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_MAX_FRM_LEN_I_get");
    mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_read( b_ptr,
                                                                           h_ptr,
                                                                           0,
                                                                           3,
                                                                           (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_MAX_FRM_LEN_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_MAX_FRM_LEN_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_MAX_FRM_LEN_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_MAX_FRM_LEN_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_action_on_write_field_set( b_ptr,
                                                                                          h_ptr,
                                                                                          word_number,
                                                                                          mask,
                                                                                          field_ofs,
                                                                                          value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_MAX_FRM_LEN_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_MAX_FRM_LEN_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_MAX_FRM_LEN_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_read( b_ptr,
                                                                                 h_ptr,
                                                                                 word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_MAX_FRM_LEN_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_MAX_FRM_LEN_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 start_bit,
                                                                                 UINT32 stop_bit,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_MAX_FRM_LEN_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 start_bit,
                                                                                 UINT32 stop_bit,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_MAX_FRM_LEN_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_MAX_FRM_LEN_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_MAXIMUM_FRAME_LENGTH_VIOLATION_INTR_array_poll( b_ptr,
                                                                            h_ptr,
                                                                            word_number,
                                                                            mask,
                                                                            ( value << field_ofs),
                                                                            cmp,
                                                                            max_count,
                                                                            num_failed_polls,
                                                                            delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_MIN_FRM_LEN_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_MIN_FRM_LEN_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_MIN_FRM_LEN_I_set_to_clear");
    mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_write( b_ptr,
                                                                            h_ptr,
                                                                            0,
                                                                            3,
                                                                            value);
}

static INLINE void mapotn_rgfpf_lfield_MIN_FRM_LEN_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_MIN_FRM_LEN_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_MIN_FRM_LEN_I_get");
    mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_burst_read( b_ptr,
                                                                           h_ptr,
                                                                           0,
                                                                           3,
                                                                           (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_MIN_FRM_LEN_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_MIN_FRM_LEN_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_MIN_FRM_LEN_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_MIN_FRM_LEN_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_action_on_write_field_set( b_ptr,
                                                                                          h_ptr,
                                                                                          word_number,
                                                                                          mask,
                                                                                          field_ofs,
                                                                                          value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_MIN_FRM_LEN_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_MIN_FRM_LEN_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_MIN_FRM_LEN_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_read( b_ptr,
                                                                                 h_ptr,
                                                                                 word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_MIN_FRM_LEN_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_MIN_FRM_LEN_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 start_bit,
                                                                                 UINT32 stop_bit,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_MIN_FRM_LEN_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 start_bit,
                                                                                 UINT32 stop_bit,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_MIN_FRM_LEN_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_MIN_FRM_LEN_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_MINIMUM_FRAME_LENGTH_VIOLATION_INTR_array_poll( b_ptr,
                                                                            h_ptr,
                                                                            word_number,
                                                                            mask,
                                                                            ( value << field_ofs),
                                                                            cmp,
                                                                            max_count,
                                                                            num_failed_polls,
                                                                            delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_PFCSE_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_PFCSE_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_PFCSE_I_set_to_clear");
    mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_burst_write( b_ptr,
                                                         h_ptr,
                                                         0,
                                                         3,
                                                         value);
}

static INLINE void mapotn_rgfpf_lfield_PFCSE_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_PFCSE_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_PFCSE_I_get");
    mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_burst_read( b_ptr,
                                                        h_ptr,
                                                        0,
                                                        3,
                                                        (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_PFCSE_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_PFCSE_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PFCSE_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_PFCSE_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_action_on_write_field_set( b_ptr,
                                                                       h_ptr,
                                                                       word_number,
                                                                       mask,
                                                                       field_ofs,
                                                                       value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_PFCSE_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_PFCSE_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PFCSE_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_read( b_ptr,
                                                              h_ptr,
                                                              word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_PFCSE_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_PFCSE_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_PFCSE_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value,
                                                                           PMC_POLL_COMPARISON_TYPE cmp,
                                                                           UINT32 max_count,
                                                                           UINT32 *num_failed_polls,
                                                                           UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PFCSE_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_PFCSE_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_PAYLOAD_FCS_INTR_array_poll( b_ptr,
                                                         h_ptr,
                                                         word_number,
                                                         mask,
                                                         ( value << field_ofs),
                                                         cmp,
                                                         max_count,
                                                         num_failed_polls,
                                                         delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_DWNSTRM_FRM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DWNSTRM_FRM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DWNSTRM_FRM_I_set_to_clear");
    mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_burst_write( b_ptr,
                                                              h_ptr,
                                                              0,
                                                              3,
                                                              value);
}

static INLINE void mapotn_rgfpf_lfield_DWNSTRM_FRM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DWNSTRM_FRM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DWNSTRM_FRM_I_get");
    mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_burst_read( b_ptr,
                                                             h_ptr,
                                                             0,
                                                             3,
                                                             (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_DWNSTRM_FRM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_DWNSTRM_FRM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DWNSTRM_FRM_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DWNSTRM_FRM_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_action_on_write_field_set( b_ptr,
                                                                            h_ptr,
                                                                            word_number,
                                                                            mask,
                                                                            field_ofs,
                                                                            value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_DWNSTRM_FRM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_DWNSTRM_FRM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DWNSTRM_FRM_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_read( b_ptr,
                                                                   h_ptr,
                                                                   word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DWNSTRM_FRM_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_DWNSTRM_FRM_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 start_bit,
                                                                                 UINT32 stop_bit,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_DWNSTRM_FRM_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 start_bit,
                                                                                 UINT32 stop_bit,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DWNSTRM_FRM_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_DWNSTRM_FRM_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_DOWNSTREAM_FRAME_INTR_array_poll( b_ptr,
                                                              h_ptr,
                                                              word_number,
                                                              mask,
                                                              ( value << field_ofs),
                                                              cmp,
                                                              max_count,
                                                              num_failed_polls,
                                                              delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_DATA_AV_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_DATA_AV_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CPU_FIFO_DATA_AV_I_set_to_clear");
    mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_burst_write( b_ptr,
                                                              h_ptr,
                                                              0,
                                                              3,
                                                              value);
}

static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_DATA_AV_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_DATA_AV_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CPU_FIFO_DATA_AV_I_get");
    mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_burst_read( b_ptr,
                                                             h_ptr,
                                                             0,
                                                             3,
                                                             (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit,
                                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit,
                                                                              UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_action_on_write_field_set( b_ptr,
                                                                            h_ptr,
                                                                            word_number,
                                                                            mask,
                                                                            field_ofs,
                                                                            value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_read( b_ptr,
                                                                   h_ptr,
                                                                   word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 start_bit,
                                                                                      UINT32 stop_bit,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                      mapotn_handle_t *h_ptr,
                                                                                      UINT32 start_bit,
                                                                                      UINT32 stop_bit,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_CPU_FIFO_DATA_AV_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_CPU_FIFO_DATA_AV_INTR_array_poll( b_ptr,
                                                              h_ptr,
                                                              word_number,
                                                              mask,
                                                              ( value << field_ofs),
                                                              cmp,
                                                              max_count,
                                                              num_failed_polls,
                                                              delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_OVF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_OVF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CPU_FIFO_OVF_I_set_to_clear");
    mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_burst_write( b_ptr,
                                                                    h_ptr,
                                                                    0,
                                                                    3,
                                                                    value);
}

static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_OVF_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CPU_FIFO_OVF_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CPU_FIFO_OVF_I_get");
    mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_burst_read( b_ptr,
                                                                   h_ptr,
                                                                   0,
                                                                   3,
                                                                   (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_action_on_write_field_set( b_ptr,
                                                                                  h_ptr,
                                                                                  word_number,
                                                                                  mask,
                                                                                  field_ofs,
                                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_read( b_ptr,
                                                                         h_ptr,
                                                                         word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 start_bit,
                                                                                  UINT32 stop_bit,
                                                                                  UINT32 value,
                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                  UINT32 max_count,
                                                                                  UINT32 *num_failed_polls,
                                                                                  UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                  mapotn_handle_t *h_ptr,
                                                                                  UINT32 start_bit,
                                                                                  UINT32 stop_bit,
                                                                                  UINT32 value,
                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                  UINT32 max_count,
                                                                                  UINT32 *num_failed_polls,
                                                                                  UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_CPU_FIFO_OVF_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_CPU_DATA_FIFO_OVERFLOW_INTR_array_poll( b_ptr,
                                                                    h_ptr,
                                                                    word_number,
                                                                    mask,
                                                                    ( value << field_ofs),
                                                                    cmp,
                                                                    max_count,
                                                                    num_failed_polls,
                                                                    delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_SSF_SF_RCVD_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_SSF_SF_RCVD_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_SSF_SF_RCVD_I_set_to_clear");
    mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_burst_write( b_ptr,
                                                       h_ptr,
                                                       0,
                                                       3,
                                                       value);
}

static INLINE void mapotn_rgfpf_lfield_SSF_SF_RCVD_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_SSF_SF_RCVD_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_SSF_SF_RCVD_I_get");
    mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_burst_read( b_ptr,
                                                      h_ptr,
                                                      0,
                                                      3,
                                                      (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_SSF_SF_RCVD_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_SSF_SF_RCVD_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_SSF_SF_RCVD_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_SSF_SF_RCVD_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_action_on_write_field_set( b_ptr,
                                                                     h_ptr,
                                                                     word_number,
                                                                     mask,
                                                                     field_ofs,
                                                                     value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_SSF_SF_RCVD_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_SSF_SF_RCVD_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_SSF_SF_RCVD_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_read( b_ptr,
                                                            h_ptr,
                                                            word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_SSF_SF_RCVD_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_SSF_SF_RCVD_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 start_bit,
                                                                                 UINT32 stop_bit,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_SSF_SF_RCVD_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 start_bit,
                                                                                 UINT32 stop_bit,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_SSF_SF_RCVD_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_SSF_SF_RCVD_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_SSF_SF_RCVDINT_array_poll( b_ptr,
                                                       h_ptr,
                                                       word_number,
                                                       mask,
                                                       ( value << field_ofs),
                                                       cmp,
                                                       max_count,
                                                       num_failed_polls,
                                                       delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_HAO_STATUS_AVL_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_HAO_STATUS_AVL_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_HAO_STATUS_AVL_I_set_to_clear");
    mapotn_rgfpf_reg_HAO_STAT_INT_array_burst_write( b_ptr,
                                                     h_ptr,
                                                     0,
                                                     3,
                                                     value);
}

static INLINE void mapotn_rgfpf_lfield_HAO_STATUS_AVL_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_HAO_STATUS_AVL_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_HAO_STATUS_AVL_I_get");
    mapotn_rgfpf_reg_HAO_STAT_INT_array_burst_read( b_ptr,
                                                    h_ptr,
                                                    0,
                                                    3,
                                                    (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit,
                                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                            mapotn_handle_t *h_ptr,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit,
                                                                            UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_HAO_STAT_INT_array_action_on_write_field_set( b_ptr,
                                                                   h_ptr,
                                                                   word_number,
                                                                   mask,
                                                                   field_ofs,
                                                                   value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_HAO_STAT_INT_array_read( b_ptr,
                                                          h_ptr,
                                                          word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 start_bit,
                                                                                    UINT32 stop_bit,
                                                                                    UINT32 value,
                                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                                    UINT32 max_count,
                                                                                    UINT32 *num_failed_polls,
                                                                                    UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                    mapotn_handle_t *h_ptr,
                                                                                    UINT32 start_bit,
                                                                                    UINT32 stop_bit,
                                                                                    UINT32 value,
                                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                                    UINT32 max_count,
                                                                                    UINT32 *num_failed_polls,
                                                                                    UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_HAO_STATUS_AVL_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_HAO_STAT_INT_array_poll( b_ptr,
                                                     h_ptr,
                                                     word_number,
                                                     mask,
                                                     ( value << field_ofs),
                                                     cmp,
                                                     max_count,
                                                     num_failed_polls,
                                                     delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_DPLM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DPLM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DPLM_I_set_to_clear");
    mapotn_rgfpf_reg_DPLM_INT_array_burst_write( b_ptr,
                                                 h_ptr,
                                                 0,
                                                 3,
                                                 value);
}

static INLINE void mapotn_rgfpf_lfield_DPLM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DPLM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DPLM_I_get");
    mapotn_rgfpf_reg_DPLM_INT_array_burst_read( b_ptr,
                                                h_ptr,
                                                0,
                                                3,
                                                (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_DPLM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_DPLM_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DPLM_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DPLM_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_DPLM_INT_array_action_on_write_field_set( b_ptr,
                                                               h_ptr,
                                                               word_number,
                                                               mask,
                                                               field_ofs,
                                                               value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_DPLM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_DPLM_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DPLM_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_DPLM_INT_array_read( b_ptr,
                                                      h_ptr,
                                                      word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DPLM_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_DPLM_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_DPLM_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DPLM_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_DPLM_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_DPLM_INT_array_poll( b_ptr,
                                                 h_ptr,
                                                 word_number,
                                                 mask,
                                                 ( value << field_ofs),
                                                 cmp,
                                                 max_count,
                                                 num_failed_polls,
                                                 delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_OPU_CSF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_OPU_CSF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_OPU_CSF_I_set_to_clear");
    mapotn_rgfpf_reg_OPU_CSF_INT_array_burst_write( b_ptr,
                                                    h_ptr,
                                                    0,
                                                    3,
                                                    value);
}

static INLINE void mapotn_rgfpf_lfield_OPU_CSF_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_OPU_CSF_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_OPU_CSF_I_get");
    mapotn_rgfpf_reg_OPU_CSF_INT_array_burst_read( b_ptr,
                                                   h_ptr,
                                                   0,
                                                   3,
                                                   (UINT32 *)value);
}

static INLINE void mapotn_rgfpf_lfield_range_OPU_CSF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_range_OPU_CSF_I_set_to_clear( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_OPU_CSF_I_set_to_clear", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_OPU_CSF_I_set_to_clear", start_bit, stop_bit, value);
    mapotn_rgfpf_reg_OPU_CSF_INT_array_action_on_write_field_set( b_ptr,
                                                                  h_ptr,
                                                                  word_number,
                                                                  mask,
                                                                  field_ofs,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_OPU_CSF_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_OPU_CSF_I_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_OPU_CSF_I_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_OPU_CSF_INT_array_read( b_ptr,
                                                         h_ptr,
                                                         word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_OPU_CSF_I_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_OPU_CSF_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 start_bit,
                                                                             UINT32 stop_bit,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_OPU_CSF_I_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 start_bit,
                                                                             UINT32 stop_bit,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_OPU_CSF_I_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_OPU_CSF_I_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_OPU_CSF_INT_array_poll( b_ptr,
                                                    h_ptr,
                                                    word_number,
                                                    mask,
                                                    ( value << field_ofs),
                                                    cmp,
                                                    max_count,
                                                    num_failed_polls,
                                                    delay_between_polls_in_microseconds);
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_value_N_burstsize3
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_lfield_LOFD_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_LOFD_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_LOFD_V_get");
    mapotn_rgfpf_reg_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE_array_burst_read( b_ptr,
                                                                                 h_ptr,
                                                                                 0,
                                                                                 3,
                                                                                 (UINT32 *)value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_LOFD_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_LOFD_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_LOFD_V_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE_array_read( b_ptr,
                                                                                       h_ptr,
                                                                                       word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_LOFD_V_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_LOFD_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_LOFD_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_LOFD_V_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_LOFD_V_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_LOSS_OF_FRAME_DELINEATION_INTERRUPT_VALUE_array_poll( b_ptr,
                                                                                  h_ptr,
                                                                                  word_number,
                                                                                  mask,
                                                                                  ( value << field_ofs),
                                                                                  cmp,
                                                                                  max_count,
                                                                                  num_failed_polls,
                                                                                  delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_IDLE_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_IDLE_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_IDLE_V_get");
    mapotn_rgfpf_reg_GFP_FRAMER_IDLE_INTERRUPT_VALUE_array_burst_read( b_ptr,
                                                                       h_ptr,
                                                                       0,
                                                                       3,
                                                                       (UINT32 *)value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_IDLE_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_IDLE_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_IDLE_V_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_FRAMER_IDLE_INTERRUPT_VALUE_array_read( b_ptr,
                                                                             h_ptr,
                                                                             word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_IDLE_V_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_IDLE_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_IDLE_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_IDLE_V_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_IDLE_V_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_FRAMER_IDLE_INTERRUPT_VALUE_array_poll( b_ptr,
                                                                        h_ptr,
                                                                        word_number,
                                                                        mask,
                                                                        ( value << field_ofs),
                                                                        cmp,
                                                                        max_count,
                                                                        num_failed_polls,
                                                                        delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_CSF_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_CSF_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_CSF_V_get");
    mapotn_rgfpf_reg_GFP_CSF_INTERRUPT_VALUE_array_burst_read( b_ptr,
                                                               h_ptr,
                                                               0,
                                                               3,
                                                               (UINT32 *)value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_CSF_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_CSF_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CSF_V_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_CSF_INTERRUPT_VALUE_array_read( b_ptr,
                                                                     h_ptr,
                                                                     word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_CSF_V_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CSF_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_CSF_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_CSF_V_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_CSF_V_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_CSF_INTERRUPT_VALUE_array_poll( b_ptr,
                                                                h_ptr,
                                                                word_number,
                                                                mask,
                                                                ( value << field_ofs),
                                                                cmp,
                                                                max_count,
                                                                num_failed_polls,
                                                                delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_EXI_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_EXI_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_EXI_V_get");
    mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_VALUE_array_burst_read( b_ptr,
                                                                         h_ptr,
                                                                         0,
                                                                         3,
                                                                         (UINT32 *)value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_EXI_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_EXI_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_EXI_V_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_VALUE_array_read( b_ptr,
                                                                               h_ptr,
                                                                               word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_EXI_V_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_EXI_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_EXI_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_EXI_V_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_EXI_V_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_EXI_MISMATCH_ERROR_INTR_VALUE_array_poll( b_ptr,
                                                                          h_ptr,
                                                                          word_number,
                                                                          mask,
                                                                          ( value << field_ofs),
                                                                          cmp,
                                                                          max_count,
                                                                          num_failed_polls,
                                                                          delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_PTI_UPI_MSMCH_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_PTI_UPI_MSMCH_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_PTI_UPI_MSMCH_V_get");
    mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_VALUE_array_burst_read( b_ptr,
                                                                      h_ptr,
                                                                      0,
                                                                      3,
                                                                      (UINT32 *)value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_V_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_VALUE_array_read( b_ptr,
                                                                            h_ptr,
                                                                            word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_V_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 start_bit,
                                                                                   UINT32 stop_bit,
                                                                                   UINT32 value,
                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                   UINT32 max_count,
                                                                                   UINT32 *num_failed_polls,
                                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                   mapotn_handle_t *h_ptr,
                                                                                   UINT32 start_bit,
                                                                                   UINT32 stop_bit,
                                                                                   UINT32 value,
                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                   UINT32 max_count,
                                                                                   UINT32 *num_failed_polls,
                                                                                   UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_V_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_PTI_UPI_MSMCH_V_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_GFP_PTI_UPI_MSM_ERR_INTR_VALUE_array_poll( b_ptr,
                                                                       h_ptr,
                                                                       word_number,
                                                                       mask,
                                                                       ( value << field_ofs),
                                                                       cmp,
                                                                       max_count,
                                                                       num_failed_polls,
                                                                       delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_IN_SFAIL_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_IN_SFAIL_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_IN_SFAIL_V_get");
    mapotn_rgfpf_reg_IN_SFAIL_INT_VAL_array_burst_read( b_ptr,
                                                        h_ptr,
                                                        0,
                                                        3,
                                                        (UINT32 *)value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_IN_SFAIL_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_IN_SFAIL_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_IN_SFAIL_V_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_IN_SFAIL_INT_VAL_array_read( b_ptr,
                                                              h_ptr,
                                                              word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_IN_SFAIL_V_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_IN_SFAIL_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_IN_SFAIL_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                              mapotn_handle_t *h_ptr,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_IN_SFAIL_V_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_IN_SFAIL_V_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_IN_SFAIL_INT_VAL_array_poll( b_ptr,
                                                         h_ptr,
                                                         word_number,
                                                         mask,
                                                         ( value << field_ofs),
                                                         cmp,
                                                         max_count,
                                                         num_failed_polls,
                                                         delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_SSF_SF_RCVD_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_SSF_SF_RCVD_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_SSF_SF_RCVD_V_get");
    mapotn_rgfpf_reg_SSF_SF_RCVD_INT_VAL_array_burst_read( b_ptr,
                                                           h_ptr,
                                                           0,
                                                           3,
                                                           (UINT32 *)value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_SSF_SF_RCVD_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_SSF_SF_RCVD_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_SSF_SF_RCVD_V_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_SSF_SF_RCVD_INT_VAL_array_read( b_ptr,
                                                                 h_ptr,
                                                                 word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_SSF_SF_RCVD_V_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_SSF_SF_RCVD_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 start_bit,
                                                                                 UINT32 stop_bit,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_SSF_SF_RCVD_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                                 mapotn_handle_t *h_ptr,
                                                                                 UINT32 start_bit,
                                                                                 UINT32 stop_bit,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_SSF_SF_RCVD_V_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_SSF_SF_RCVD_V_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_SSF_SF_RCVD_INT_VAL_array_poll( b_ptr,
                                                            h_ptr,
                                                            word_number,
                                                            mask,
                                                            ( value << field_ofs),
                                                            cmp,
                                                            max_count,
                                                            num_failed_polls,
                                                            delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_DPLM_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_DPLM_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_DPLM_V_get");
    mapotn_rgfpf_reg_DPLM_INT_VAL_array_burst_read( b_ptr,
                                                    h_ptr,
                                                    0,
                                                    3,
                                                    (UINT32 *)value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_DPLM_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_DPLM_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DPLM_V_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_DPLM_INT_VAL_array_read( b_ptr,
                                                          h_ptr,
                                                          word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_DPLM_V_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_DPLM_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_DPLM_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_DPLM_V_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_DPLM_V_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_DPLM_INT_VAL_array_poll( b_ptr,
                                                     h_ptr,
                                                     word_number,
                                                     mask,
                                                     ( value << field_ofs),
                                                     cmp,
                                                     max_count,
                                                     num_failed_polls,
                                                     delay_between_polls_in_microseconds);
}

static INLINE void mapotn_rgfpf_lfield_OPU_CSF_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_OPU_CSF_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32 value[3] )
{
    IOLOG( "%s ", "mapotn_rgfpf_lfield_OPU_CSF_V_get");
    mapotn_rgfpf_reg_OPU_CSF_INT_VAL_array_burst_read( b_ptr,
                                                       h_ptr,
                                                       0,
                                                       3,
                                                       (UINT32 *)value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_OPU_CSF_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_OPU_CSF_V_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_OPU_CSF_V_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_OPU_CSF_INT_VAL_array_read( b_ptr,
                                                             h_ptr,
                                                             word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_OPU_CSF_V_get", start_bit, stop_bit, value );
    return value;
}

static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_OPU_CSF_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 start_bit,
                                                                             UINT32 stop_bit,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE mapotn_rgfpf_lfield_range_OPU_CSF_V_poll( mapotn_rgfpf_buffer_t *b_ptr,
                                                                             mapotn_handle_t *h_ptr,
                                                                             UINT32 start_bit,
                                                                             UINT32 stop_bit,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds )
{
    UINT32 word_number;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits)) << field_ofs;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_OPU_CSF_V_poll", start_bit, stop_bit );
    }
    IOLOG( "%s -> start_bit=%d stop_bit=%d", "mapotn_rgfpf_lfield_range_OPU_CSF_V_set_to_clear", start_bit, stop_bit);
    return mapotn_rgfpf_reg_OPU_CSF_INT_VAL_array_poll( b_ptr,
                                                        h_ptr,
                                                        word_number,
                                                        mask,
                                                        ( value << field_ofs),
                                                        cmp,
                                                        max_count,
                                                        num_failed_polls,
                                                        delay_between_polls_in_microseconds);
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset ram_M_size96__N_burstsize7
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_lfield_FL_CHK_STAT_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  M,
                                                            UINT32 value[7] ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_lfield_FL_CHK_STAT_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  M,
                                                            UINT32 value[7] )
{
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_lfield_FL_CHK_STAT_CNT_get", M, 95);
    IOLOG( "%s  M=%d", "mapotn_rgfpf_lfield_FL_CHK_STAT_CNT_get", M);
    mapotn_rgfpf_reg_FRM_LEN_STAT_CNT_PMON_array_burst_read( b_ptr,
                                                             h_ptr,
                                                             M,
                                                             0,
                                                             7,
                                                             (UINT32 *)value);
}

static INLINE UINT32 mapotn_rgfpf_lfield_range_FL_CHK_STAT_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  M,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_lfield_range_FL_CHK_STAT_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  M,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value;
    UINT32 word_number;
    UINT32 reg_value;
    UINT32 field_ofs;
    UINT32 num_bits;
    UINT32 mask;

    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_lfield_range_FL_CHK_STAT_CNT_get", M, 95);
    num_bits = stop_bit - start_bit + 1;
    mask = (0xffffffff >> (32-num_bits));
    word_number = start_bit / 32;
    field_ofs = start_bit % 32;
    if (stop_bit / 32 != word_number) {
        IOLOG( "BUG: %s does not support ranges that span multiple registers -- fix code generator - start_bit=%d, stop_bit=%d", "mapotn_rgfpf_lfield_range_FL_CHK_STAT_CNT_get", start_bit, stop_bit );
    }
    reg_value = mapotn_rgfpf_reg_FRM_LEN_STAT_CNT_PMON_array_read( b_ptr,
                                                                   h_ptr,
                                                                   M,
                                                                   word_number);
    value = (reg_value >> field_ofs) & mask;
    IOLOG( "%s -> M=%d start_bit=%d stop_bit=%d value=0x%08x", "mapotn_rgfpf_lfield_range_FL_CHK_STAT_CNT_get", M, start_bit, stop_bit, value );
    return value;
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset ram_N_size10__M_size96
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_field_UPI_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N,
                                                     UINT32  M,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_UPI_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N,
                                                     UINT32  M,
                                                     UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UPI_VALUE_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_UPI_VALUE_set", M, 95);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_UPI_VALUE_set", value, 255);
    IOLOG( "%s <= N=%d M=%d 0x%08x", "mapotn_rgfpf_field_UPI_VALUE_set", N, M, value );

    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 31:24) field UPI_VALUE of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set( b_ptr,
                                                             h_ptr,
                                                             N,
                                                             M,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_VALUE_MSK,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_VALUE_OFF,
                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_UPI_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_UPI_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32  M )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UPI_VALUE_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_UPI_VALUE_get", M, 95);
    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 31:24) field UPI_VALUE of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_VALUE_MSK) >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_VALUE_OFF;
    IOLOG( "%s -> N=%d M=%d 0x%08x", "mapotn_rgfpf_field_UPI_VALUE_get", N, M, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_UPI_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32  M,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_UPI_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32  M,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UPI_VALUE_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_UPI_VALUE_set", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UPI_VALUE_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UPI_VALUE_set", stop_bit, 7 );
    IOLOG( "%s <= N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UPI_VALUE_set", N, M, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 31:24) field UPI_VALUE of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 31:24) field UPI_VALUE of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
        mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set( b_ptr,
                                                                 h_ptr,
                                                                 N,
                                                                 M,
                                                                 subfield_mask << (RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_VALUE_OFF + subfield_offset),
                                                                 RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_VALUE_OFF + subfield_offset,
                                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_UPI_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32  M,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_UPI_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32  M,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UPI_VALUE_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_UPI_VALUE_get", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UPI_VALUE_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UPI_VALUE_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 31:24) field UPI_VALUE of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    field_value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_VALUE_MSK)
                  >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_VALUE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_VALUE_MSK, RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_VALUE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UPI_VALUE_get", N, M, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PTI_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N,
                                                     UINT32  M,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PTI_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N,
                                                     UINT32  M,
                                                     UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PTI_VALUE_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_PTI_VALUE_set", M, 95);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PTI_VALUE_set", value, 7);
    IOLOG( "%s <= N=%d M=%d 0x%08x", "mapotn_rgfpf_field_PTI_VALUE_set", N, M, value );

    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 22:20) field PTI_VALUE of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set( b_ptr,
                                                             h_ptr,
                                                             N,
                                                             M,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_VALUE_MSK,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_VALUE_OFF,
                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_PTI_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PTI_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32  M )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PTI_VALUE_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_PTI_VALUE_get", M, 95);
    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 22:20) field PTI_VALUE of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_VALUE_MSK) >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_VALUE_OFF;
    IOLOG( "%s -> N=%d M=%d 0x%08x", "mapotn_rgfpf_field_PTI_VALUE_get", N, M, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_PTI_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32  M,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_PTI_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32  M,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_PTI_VALUE_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_PTI_VALUE_set", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_PTI_VALUE_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_PTI_VALUE_set", stop_bit, 2 );
    IOLOG( "%s <= N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_PTI_VALUE_set", N, M, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 22:20) field PTI_VALUE of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 22:20) field PTI_VALUE of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
        mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set( b_ptr,
                                                                 h_ptr,
                                                                 N,
                                                                 M,
                                                                 subfield_mask << (RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_VALUE_OFF + subfield_offset),
                                                                 RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_VALUE_OFF + subfield_offset,
                                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_PTI_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32  M,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_PTI_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32  M,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_PTI_VALUE_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_PTI_VALUE_get", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_PTI_VALUE_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_PTI_VALUE_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 22:20) field PTI_VALUE of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    field_value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_VALUE_MSK)
                  >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_VALUE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_VALUE_MSK, RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_VALUE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_PTI_VALUE_get", N, M, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_EXI_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N,
                                                     UINT32  M,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_EXI_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N,
                                                     UINT32  M,
                                                     UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EXI_VALUE_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_EXI_VALUE_set", M, 95);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_EXI_VALUE_set", value, 15);
    IOLOG( "%s <= N=%d M=%d 0x%08x", "mapotn_rgfpf_field_EXI_VALUE_set", N, M, value );

    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 19:16) field EXI_VALUE of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set( b_ptr,
                                                             h_ptr,
                                                             N,
                                                             M,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_VALUE_MSK,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_VALUE_OFF,
                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_EXI_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_EXI_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32  M )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EXI_VALUE_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_EXI_VALUE_get", M, 95);
    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 19:16) field EXI_VALUE of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_VALUE_MSK) >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_VALUE_OFF;
    IOLOG( "%s -> N=%d M=%d 0x%08x", "mapotn_rgfpf_field_EXI_VALUE_get", N, M, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_EXI_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32  M,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_EXI_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32  M,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EXI_VALUE_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_EXI_VALUE_set", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EXI_VALUE_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EXI_VALUE_set", stop_bit, 3 );
    IOLOG( "%s <= N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EXI_VALUE_set", N, M, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 19:16) field EXI_VALUE of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 19:16) field EXI_VALUE of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
        mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set( b_ptr,
                                                                 h_ptr,
                                                                 N,
                                                                 M,
                                                                 subfield_mask << (RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_VALUE_OFF + subfield_offset),
                                                                 RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_VALUE_OFF + subfield_offset,
                                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_EXI_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32  M,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_EXI_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32  M,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EXI_VALUE_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_EXI_VALUE_get", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EXI_VALUE_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EXI_VALUE_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 19:16) field EXI_VALUE of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    field_value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_VALUE_MSK)
                  >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_VALUE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_VALUE_MSK, RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_VALUE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EXI_VALUE_get", N, M, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_UPI_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32  M,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_UPI_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32  M,
                                                    UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UPI_MASK_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_UPI_MASK_set", M, 95);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_UPI_MASK_set", value, 255);
    IOLOG( "%s <= N=%d M=%d 0x%08x", "mapotn_rgfpf_field_UPI_MASK_set", N, M, value );

    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 15:8) field UPI_MASK of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set( b_ptr,
                                                             h_ptr,
                                                             N,
                                                             M,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_MASK_MSK,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_MASK_OFF,
                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_UPI_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_UPI_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32  M )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UPI_MASK_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_UPI_MASK_get", M, 95);
    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 15:8) field UPI_MASK of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_MASK_MSK) >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_MASK_OFF;
    IOLOG( "%s -> N=%d M=%d 0x%08x", "mapotn_rgfpf_field_UPI_MASK_get", N, M, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_UPI_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32  M,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_UPI_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32  M,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UPI_MASK_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_UPI_MASK_set", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UPI_MASK_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UPI_MASK_set", stop_bit, 7 );
    IOLOG( "%s <= N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UPI_MASK_set", N, M, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 15:8) field UPI_MASK of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 15:8) field UPI_MASK of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
        mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set( b_ptr,
                                                                 h_ptr,
                                                                 N,
                                                                 M,
                                                                 subfield_mask << (RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_MASK_OFF + subfield_offset),
                                                                 RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_MASK_OFF + subfield_offset,
                                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_UPI_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32  M,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_UPI_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32  M,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UPI_MASK_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_UPI_MASK_get", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UPI_MASK_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UPI_MASK_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 15:8) field UPI_MASK of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    field_value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_MASK_MSK)
                  >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_MASK_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_MASK_MSK, RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_UPI_MASK_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UPI_MASK_get", N, M, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PTI_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32  M,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PTI_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32  M,
                                                    UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PTI_MASK_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_PTI_MASK_set", M, 95);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PTI_MASK_set", value, 7);
    IOLOG( "%s <= N=%d M=%d 0x%08x", "mapotn_rgfpf_field_PTI_MASK_set", N, M, value );

    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 7:5) field PTI_MASK of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set( b_ptr,
                                                             h_ptr,
                                                             N,
                                                             M,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_MASK_MSK,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_MASK_OFF,
                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_PTI_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PTI_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32  M )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PTI_MASK_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_PTI_MASK_get", M, 95);
    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 7:5) field PTI_MASK of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_MASK_MSK) >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_MASK_OFF;
    IOLOG( "%s -> N=%d M=%d 0x%08x", "mapotn_rgfpf_field_PTI_MASK_get", N, M, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_PTI_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32  M,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_PTI_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32  M,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_PTI_MASK_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_PTI_MASK_set", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_PTI_MASK_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_PTI_MASK_set", stop_bit, 2 );
    IOLOG( "%s <= N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_PTI_MASK_set", N, M, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 7:5) field PTI_MASK of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 7:5) field PTI_MASK of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
        mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set( b_ptr,
                                                                 h_ptr,
                                                                 N,
                                                                 M,
                                                                 subfield_mask << (RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_MASK_OFF + subfield_offset),
                                                                 RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_MASK_OFF + subfield_offset,
                                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_PTI_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32  M,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_PTI_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32  M,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_PTI_MASK_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_PTI_MASK_get", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_PTI_MASK_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_PTI_MASK_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 7:5) field PTI_MASK of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    field_value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_MASK_MSK)
                  >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_MASK_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_MASK_MSK, RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_PTI_MASK_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_PTI_MASK_get", N, M, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_EXI_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32  M,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_EXI_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32  M,
                                                    UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EXI_MASK_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_EXI_MASK_set", M, 95);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_EXI_MASK_set", value, 15);
    IOLOG( "%s <= N=%d M=%d 0x%08x", "mapotn_rgfpf_field_EXI_MASK_set", N, M, value );

    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 4:1) field EXI_MASK of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set( b_ptr,
                                                             h_ptr,
                                                             N,
                                                             M,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_MASK_MSK,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_MASK_OFF,
                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_EXI_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_EXI_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32  M )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EXI_MASK_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_EXI_MASK_get", M, 95);
    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 4:1) field EXI_MASK of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_MASK_MSK) >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_MASK_OFF;
    IOLOG( "%s -> N=%d M=%d 0x%08x", "mapotn_rgfpf_field_EXI_MASK_get", N, M, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_EXI_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32  M,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_EXI_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32  M,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EXI_MASK_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_EXI_MASK_set", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EXI_MASK_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EXI_MASK_set", stop_bit, 3 );
    IOLOG( "%s <= N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EXI_MASK_set", N, M, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 4:1) field EXI_MASK of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 4:1) field EXI_MASK of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
        mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set( b_ptr,
                                                                 h_ptr,
                                                                 N,
                                                                 M,
                                                                 subfield_mask << (RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_MASK_OFF + subfield_offset),
                                                                 RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_MASK_OFF + subfield_offset,
                                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_EXI_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32  M,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_EXI_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32  M,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EXI_MASK_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_EXI_MASK_get", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EXI_MASK_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EXI_MASK_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 4:1) field EXI_MASK of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    field_value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_MASK_MSK)
                  >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_MASK_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_MASK_MSK, RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_EXI_MASK_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EXI_MASK_get", N, M, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_SELECT_GENERIC_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32  M,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_SELECT_GENERIC_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32  M,
                                                          UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_SELECT_GENERIC_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_SELECT_GENERIC_set", M, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_SELECT_GENERIC_set", value, 1);
    IOLOG( "%s <= N=%d M=%d 0x%08x", "mapotn_rgfpf_field_SELECT_GENERIC_set", N, M, value );

    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 0) field SELECT_GENERIC of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_field_set( b_ptr,
                                                             h_ptr,
                                                             N,
                                                             M,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_SELECT_GENERIC_MSK,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_SELECT_GENERIC_OFF,
                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_SELECT_GENERIC_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_SELECT_GENERIC_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32  M )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_SELECT_GENERIC_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_SELECT_GENERIC_get", M, 95);
    /* ((0x00031060 + (N) * 0x8 + (M) * 0x100) bits 0) field SELECT_GENERIC of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_0 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_0_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_SELECT_GENERIC_MSK) >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_0_BIT_SELECT_GENERIC_OFF;
    IOLOG( "%s -> N=%d M=%d 0x%08x", "mapotn_rgfpf_field_SELECT_GENERIC_get", N, M, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_MATCH_INDICATOR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32  M,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_MATCH_INDICATOR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32  M,
                                                           UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_MATCH_INDICATOR_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_MATCH_INDICATOR_set", M, 95);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_MATCH_INDICATOR_set", value, 15);
    IOLOG( "%s <= N=%d M=%d 0x%08x", "mapotn_rgfpf_field_MATCH_INDICATOR_set", N, M, value );

    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 16:13) field MATCH_INDICATOR of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_field_set( b_ptr,
                                                             h_ptr,
                                                             N,
                                                             M,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_MATCH_INDICATOR_MSK,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_MATCH_INDICATOR_OFF,
                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_MATCH_INDICATOR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_MATCH_INDICATOR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32  M )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_MATCH_INDICATOR_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_MATCH_INDICATOR_get", M, 95);
    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 16:13) field MATCH_INDICATOR of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_MATCH_INDICATOR_MSK) >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_MATCH_INDICATOR_OFF;
    IOLOG( "%s -> N=%d M=%d 0x%08x", "mapotn_rgfpf_field_MATCH_INDICATOR_get", N, M, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_MATCH_INDICATOR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32  M,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_MATCH_INDICATOR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32  M,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_MATCH_INDICATOR_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_MATCH_INDICATOR_set", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MATCH_INDICATOR_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MATCH_INDICATOR_set", stop_bit, 3 );
    IOLOG( "%s <= N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MATCH_INDICATOR_set", N, M, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 16:13) field MATCH_INDICATOR of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 16:13) field MATCH_INDICATOR of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
        mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_field_set( b_ptr,
                                                                 h_ptr,
                                                                 N,
                                                                 M,
                                                                 subfield_mask << (RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_MATCH_INDICATOR_OFF + subfield_offset),
                                                                 RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_MATCH_INDICATOR_OFF + subfield_offset,
                                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_MATCH_INDICATOR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32  M,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_MATCH_INDICATOR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32  M,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_MATCH_INDICATOR_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_MATCH_INDICATOR_get", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MATCH_INDICATOR_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MATCH_INDICATOR_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 16:13) field MATCH_INDICATOR of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    field_value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_MATCH_INDICATOR_MSK)
                  >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_MATCH_INDICATOR_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_MATCH_INDICATOR_MSK, RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_MATCH_INDICATOR_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MATCH_INDICATOR_get", N, M, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_NEXT_FILTER_OFFSET_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32  M,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_NEXT_FILTER_OFFSET_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32  M,
                                                              UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_NEXT_FILTER_OFFSET_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_NEXT_FILTER_OFFSET_set", M, 95);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_NEXT_FILTER_OFFSET_set", value, 15);
    IOLOG( "%s <= N=%d M=%d 0x%08x", "mapotn_rgfpf_field_NEXT_FILTER_OFFSET_set", N, M, value );

    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 12:9) field NEXT_FILTER_OFFSET of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_field_set( b_ptr,
                                                             h_ptr,
                                                             N,
                                                             M,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_NEXT_FILTER_OFFSET_MSK,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_NEXT_FILTER_OFFSET_OFF,
                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_NEXT_FILTER_OFFSET_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_NEXT_FILTER_OFFSET_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32  M )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_NEXT_FILTER_OFFSET_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_NEXT_FILTER_OFFSET_get", M, 95);
    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 12:9) field NEXT_FILTER_OFFSET of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_NEXT_FILTER_OFFSET_MSK) >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_NEXT_FILTER_OFFSET_OFF;
    IOLOG( "%s -> N=%d M=%d 0x%08x", "mapotn_rgfpf_field_NEXT_FILTER_OFFSET_get", N, M, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_NEXT_FILTER_OFFSET_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N,
                                                                    UINT32  M,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_NEXT_FILTER_OFFSET_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N,
                                                                    UINT32  M,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_NEXT_FILTER_OFFSET_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_NEXT_FILTER_OFFSET_set", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_NEXT_FILTER_OFFSET_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_NEXT_FILTER_OFFSET_set", stop_bit, 3 );
    IOLOG( "%s <= N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_NEXT_FILTER_OFFSET_set", N, M, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 12:9) field NEXT_FILTER_OFFSET of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 12:9) field NEXT_FILTER_OFFSET of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
        mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_field_set( b_ptr,
                                                                 h_ptr,
                                                                 N,
                                                                 M,
                                                                 subfield_mask << (RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_NEXT_FILTER_OFFSET_OFF + subfield_offset),
                                                                 RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_NEXT_FILTER_OFFSET_OFF + subfield_offset,
                                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_NEXT_FILTER_OFFSET_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32  N,
                                                                      UINT32  M,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_NEXT_FILTER_OFFSET_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32  N,
                                                                      UINT32  M,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_NEXT_FILTER_OFFSET_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_NEXT_FILTER_OFFSET_get", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_NEXT_FILTER_OFFSET_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_NEXT_FILTER_OFFSET_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 12:9) field NEXT_FILTER_OFFSET of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    field_value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_NEXT_FILTER_OFFSET_MSK)
                  >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_NEXT_FILTER_OFFSET_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_NEXT_FILTER_OFFSET_MSK, RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_NEXT_FILTER_OFFSET_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_NEXT_FILTER_OFFSET_get", N, M, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_CONTINUATION_OPERATOR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32  M,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CONTINUATION_OPERATOR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32  M,
                                                                 UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CONTINUATION_OPERATOR_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_CONTINUATION_OPERATOR_set", M, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CONTINUATION_OPERATOR_set", value, 1);
    IOLOG( "%s <= N=%d M=%d 0x%08x", "mapotn_rgfpf_field_CONTINUATION_OPERATOR_set", N, M, value );

    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 8) field CONTINUATION_OPERATOR of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_field_set( b_ptr,
                                                             h_ptr,
                                                             N,
                                                             M,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_CONTINUATION_OPERATOR_MSK,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_CONTINUATION_OPERATOR_OFF,
                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_CONTINUATION_OPERATOR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CONTINUATION_OPERATOR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32  M )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CONTINUATION_OPERATOR_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_CONTINUATION_OPERATOR_get", M, 95);
    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 8) field CONTINUATION_OPERATOR of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_CONTINUATION_OPERATOR_MSK) >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_CONTINUATION_OPERATOR_OFF;
    IOLOG( "%s -> N=%d M=%d 0x%08x", "mapotn_rgfpf_field_CONTINUATION_OPERATOR_get", N, M, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_ACTION_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32  N,
                                                  UINT32  M,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_ACTION_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                  mapotn_handle_t *h_ptr,
                                                  UINT32  N,
                                                  UINT32  M,
                                                  UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_ACTION_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_ACTION_set", M, 95);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_ACTION_set", value, 3);
    IOLOG( "%s <= N=%d M=%d 0x%08x", "mapotn_rgfpf_field_ACTION_set", N, M, value );

    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 7:6) field ACTION of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_field_set( b_ptr,
                                                             h_ptr,
                                                             N,
                                                             M,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_ACTION_MSK,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_ACTION_OFF,
                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_ACTION_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_ACTION_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32  M )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_ACTION_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_ACTION_get", M, 95);
    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 7:6) field ACTION of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_ACTION_MSK) >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_ACTION_OFF;
    IOLOG( "%s -> N=%d M=%d 0x%08x", "mapotn_rgfpf_field_ACTION_get", N, M, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_ACTION_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N,
                                                        UINT32  M,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_ACTION_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N,
                                                        UINT32  M,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_ACTION_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_ACTION_set", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_ACTION_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_ACTION_set", stop_bit, 1 );
    IOLOG( "%s <= N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_ACTION_set", N, M, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 7:6) field ACTION of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 7:6) field ACTION of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
        mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_field_set( b_ptr,
                                                                 h_ptr,
                                                                 N,
                                                                 M,
                                                                 subfield_mask << (RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_ACTION_OFF + subfield_offset),
                                                                 RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_ACTION_OFF + subfield_offset,
                                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_ACTION_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32  M,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_ACTION_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32  M,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_ACTION_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_ACTION_get", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_ACTION_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_ACTION_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 7:6) field ACTION of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    field_value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_ACTION_MSK)
                  >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_ACTION_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_ACTION_MSK, RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_ACTION_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_ACTION_get", N, M, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_COMPARE_OPERATOR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32  M,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_COMPARE_OPERATOR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32  M,
                                                            UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_COMPARE_OPERATOR_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_COMPARE_OPERATOR_set", M, 95);
    if (value > 63)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_COMPARE_OPERATOR_set", value, 63);
    IOLOG( "%s <= N=%d M=%d 0x%08x", "mapotn_rgfpf_field_COMPARE_OPERATOR_set", N, M, value );

    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 5:0) field COMPARE_OPERATOR of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_field_set( b_ptr,
                                                             h_ptr,
                                                             N,
                                                             M,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_COMPARE_OPERATOR_MSK,
                                                             RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_COMPARE_OPERATOR_OFF,
                                                             value);
}

static INLINE UINT32 mapotn_rgfpf_field_COMPARE_OPERATOR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_COMPARE_OPERATOR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32  M )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_COMPARE_OPERATOR_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_COMPARE_OPERATOR_get", M, 95);
    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 5:0) field COMPARE_OPERATOR of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_COMPARE_OPERATOR_MSK) >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_COMPARE_OPERATOR_OFF;
    IOLOG( "%s -> N=%d M=%d 0x%08x", "mapotn_rgfpf_field_COMPARE_OPERATOR_get", N, M, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_COMPARE_OPERATOR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N,
                                                                  UINT32  M,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_COMPARE_OPERATOR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N,
                                                                  UINT32  M,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_COMPARE_OPERATOR_set", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_COMPARE_OPERATOR_set", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_COMPARE_OPERATOR_set", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_COMPARE_OPERATOR_set", stop_bit, 5 );
    IOLOG( "%s <= N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_COMPARE_OPERATOR_set", N, M, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 5:0) field COMPARE_OPERATOR of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 5) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 5;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 5:0) field COMPARE_OPERATOR of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
        mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_field_set( b_ptr,
                                                                 h_ptr,
                                                                 N,
                                                                 M,
                                                                 subfield_mask << (RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_COMPARE_OPERATOR_OFF + subfield_offset),
                                                                 RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_COMPARE_OPERATOR_OFF + subfield_offset,
                                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_COMPARE_OPERATOR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N,
                                                                    UINT32  M,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_COMPARE_OPERATOR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N,
                                                                    UINT32  M,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 9)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_COMPARE_OPERATOR_get", N, 9);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_COMPARE_OPERATOR_get", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_COMPARE_OPERATOR_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_COMPARE_OPERATOR_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031064 + (N) * 0x8 + (M) * 0x100) bits 5:0) field COMPARE_OPERATOR of register PMC_RGFPF96_CORE_REG_FILTER_CONFIGURATION_1 index N=0..9 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_CONFIGURATION_1_array_read( b_ptr,
                                                                    h_ptr,
                                                                    N,
                                                                    M);
    field_value = (reg_value & RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_COMPARE_OPERATOR_MSK)
                  >> RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_COMPARE_OPERATOR_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_COMPARE_OPERATOR_MSK, RGFPF96_CORE_REG_FILTER_CONFIGURATION_1_BIT_COMPARE_OPERATOR_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_COMPARE_OPERATOR_get", N, M, start_bit, stop_bit, value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset ram_N_size7__M_size96
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_field_MINFL_TR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32  M,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_MINFL_TR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32  M,
                                                    UINT32 value )
{
    if (N > 6)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_MINFL_TR_set", N, 6);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_MINFL_TR_set", M, 95);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_MINFL_TR_set", value, 65535);
    IOLOG( "%s <= N=%d M=%d 0x%08x", "mapotn_rgfpf_field_MINFL_TR_set", N, M, value );

    /* ((0x00031020 + (N) * 0x4 + (M) * 0x100) bits 31:16) field MINFL_TR of register PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG index N=0..6 index M=0..95 */
    mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  M,
                                                                  RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MINFL_TR_MSK,
                                                                  RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MINFL_TR_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_MINFL_TR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_MINFL_TR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32  M )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 6)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_MINFL_TR_get", N, 6);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_MINFL_TR_get", M, 95);
    /* ((0x00031020 + (N) * 0x4 + (M) * 0x100) bits 31:16) field MINFL_TR of register PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG index N=0..6 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N,
                                                                         M);
    value = (reg_value & RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MINFL_TR_MSK) >> RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MINFL_TR_OFF;
    IOLOG( "%s -> N=%d M=%d 0x%08x", "mapotn_rgfpf_field_MINFL_TR_get", N, M, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_MINFL_TR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32  M,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_MINFL_TR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32  M,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    if (N > 6)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_MINFL_TR_set", N, 6);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_MINFL_TR_set", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MINFL_TR_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MINFL_TR_set", stop_bit, 15 );
    IOLOG( "%s <= N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MINFL_TR_set", N, M, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031020 + (N) * 0x4 + (M) * 0x100) bits 31:16) field MINFL_TR of register PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG index N=0..6 index M=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031020 + (N) * 0x4 + (M) * 0x100) bits 31:16) field MINFL_TR of register PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG index N=0..6 index M=0..95 */
        mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      M,
                                                                      subfield_mask << (RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MINFL_TR_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MINFL_TR_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_MINFL_TR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32  M,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_MINFL_TR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32  M,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 6)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_MINFL_TR_get", N, 6);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_MINFL_TR_get", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MINFL_TR_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MINFL_TR_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031020 + (N) * 0x4 + (M) * 0x100) bits 31:16) field MINFL_TR of register PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG index N=0..6 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N,
                                                                         M);
    field_value = (reg_value & RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MINFL_TR_MSK)
                  >> RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MINFL_TR_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MINFL_TR_MSK, RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MINFL_TR_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MINFL_TR_get", N, M, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_MAXFL_TR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32  M,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_MAXFL_TR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32  M,
                                                    UINT32 value )
{
    if (N > 6)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_MAXFL_TR_set", N, 6);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_MAXFL_TR_set", M, 95);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_MAXFL_TR_set", value, 65535);
    IOLOG( "%s <= N=%d M=%d 0x%08x", "mapotn_rgfpf_field_MAXFL_TR_set", N, M, value );

    /* ((0x00031020 + (N) * 0x4 + (M) * 0x100) bits 15:0) field MAXFL_TR of register PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG index N=0..6 index M=0..95 */
    mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  M,
                                                                  RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MAXFL_TR_MSK,
                                                                  RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MAXFL_TR_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_MAXFL_TR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32  M ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_MAXFL_TR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32  M )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 6)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_MAXFL_TR_get", N, 6);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_MAXFL_TR_get", M, 95);
    /* ((0x00031020 + (N) * 0x4 + (M) * 0x100) bits 15:0) field MAXFL_TR of register PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG index N=0..6 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N,
                                                                         M);
    value = (reg_value & RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MAXFL_TR_MSK) >> RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MAXFL_TR_OFF;
    IOLOG( "%s -> N=%d M=%d 0x%08x", "mapotn_rgfpf_field_MAXFL_TR_get", N, M, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_MAXFL_TR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32  M,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_MAXFL_TR_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32  M,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    if (N > 6)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_MAXFL_TR_set", N, 6);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_MAXFL_TR_set", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MAXFL_TR_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MAXFL_TR_set", stop_bit, 15 );
    IOLOG( "%s <= N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MAXFL_TR_set", N, M, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031020 + (N) * 0x4 + (M) * 0x100) bits 15:0) field MAXFL_TR of register PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG index N=0..6 index M=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031020 + (N) * 0x4 + (M) * 0x100) bits 15:0) field MAXFL_TR of register PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG index N=0..6 index M=0..95 */
        mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      M,
                                                                      subfield_mask << (RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MAXFL_TR_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MAXFL_TR_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_MAXFL_TR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32  M,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_MAXFL_TR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32  M,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 6)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_MAXFL_TR_get", N, 6);
    if (M > 95)
        IO_RANGE_CHECK("%s M is %d but max is %d", "mapotn_rgfpf_field_range_MAXFL_TR_get", M, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MAXFL_TR_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MAXFL_TR_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031020 + (N) * 0x4 + (M) * 0x100) bits 15:0) field MAXFL_TR of register PMC_RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG index N=0..6 index M=0..95 */
    reg_value = mapotn_rgfpf_reg_FRM_LEN_STAT_COUNTER_CONFIG_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N,
                                                                         M);
    field_value = (reg_value & RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MAXFL_TR_MSK)
                  >> RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MAXFL_TR_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MAXFL_TR_MSK, RGFPF96_CORE_REG_FRM_LEN_STAT_COUNTER_CONFIG_BIT_MAXFL_TR_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d M=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MAXFL_TR_get", N, M, start_bit, stop_bit, value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset ram_N_size96
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_field_SHUT_DATA_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_SHUT_DATA_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N,
                                                     UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_SHUT_DATA_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_SHUT_DATA_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_SHUT_DATA_set", N, value );

    /* ((0x00031000 + (N) * 0x100) bits 30) field SHUT_DATA of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_SHUT_DATA_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_SHUT_DATA_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_SHUT_DATA_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_SHUT_DATA_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_SHUT_DATA_get", N, 95);
    /* ((0x00031000 + (N) * 0x100) bits 30) field SHUT_DATA of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_SHUT_DATA_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_SHUT_DATA_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_SHUT_DATA_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_DATA_REV_IBIT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_DATA_REV_IBIT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N,
                                                         UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DATA_REV_IBIT_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_DATA_REV_IBIT_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_DATA_REV_IBIT_set", N, value );

    /* ((0x00031000 + (N) * 0x100) bits 29) field DATA_REV_IBIT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DATA_REV_IBIT_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DATA_REV_IBIT_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_DATA_REV_IBIT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DATA_REV_IBIT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DATA_REV_IBIT_get", N, 95);
    /* ((0x00031000 + (N) * 0x100) bits 29) field DATA_REV_IBIT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DATA_REV_IBIT_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DATA_REV_IBIT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_DATA_REV_IBIT_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_DC_BALANCE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_DC_BALANCE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DC_BALANCE_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_DC_BALANCE_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_DC_BALANCE_set", N, value );

    /* ((0x00031000 + (N) * 0x100) bits 28) field DC_BALANCE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DC_BALANCE_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DC_BALANCE_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_DC_BALANCE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DC_BALANCE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DC_BALANCE_get", N, 95);
    /* ((0x00031000 + (N) * 0x100) bits 28) field DC_BALANCE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DC_BALANCE_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DC_BALANCE_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_DC_BALANCE_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_CHEC_ECC_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CHEC_ECC_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CHEC_ECC_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CHEC_ECC_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_CHEC_ECC_set", N, value );

    /* ((0x00031000 + (N) * 0x100) bits 27) field CHEC_ECC of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_CHEC_ECC_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_CHEC_ECC_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_CHEC_ECC_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CHEC_ECC_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CHEC_ECC_get", N, 95);
    /* ((0x00031000 + (N) * 0x100) bits 27) field CHEC_ECC of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_CHEC_ECC_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_CHEC_ECC_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CHEC_ECC_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_DELTA_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                 mapotn_handle_t *h_ptr,
                                                 UINT32  N,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_DELTA_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                 mapotn_handle_t *h_ptr,
                                                 UINT32  N,
                                                 UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DELTA_set", N, 95);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_DELTA_set", value, 3);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_DELTA_set", N, value );

    /* ((0x00031000 + (N) * 0x100) bits 26:25) field DELTA of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DELTA_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DELTA_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_DELTA_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DELTA_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DELTA_get", N, 95);
    /* ((0x00031000 + (N) * 0x100) bits 26:25) field DELTA of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DELTA_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DELTA_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_DELTA_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_DELTA_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_DELTA_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_DELTA_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_DELTA_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_DELTA_set", stop_bit, 1 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_DELTA_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031000 + (N) * 0x100) bits 26:25) field DELTA of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031000 + (N) * 0x100) bits 26:25) field DELTA of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DELTA_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DELTA_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_DELTA_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_DELTA_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_DELTA_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_DELTA_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_DELTA_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031000 + (N) * 0x100) bits 26:25) field DELTA of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DELTA_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DELTA_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DELTA_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_DELTA_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_DELTA_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MAX_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MAX_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N,
                                                                  UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MAX_set", N, 95);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MAX_set", value, 255);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MAX_set", N, value );

    /* ((0x00031000 + (N) * 0x100) bits 23:16) field UNPACK_DROP_THRLD2_MAX of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MAX_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MAX_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MAX_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MAX_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MAX_get", N, 95);
    /* ((0x00031000 + (N) * 0x100) bits 23:16) field UNPACK_DROP_THRLD2_MAX of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MAX_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MAX_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MAX_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MAX_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  N,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MAX_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  N,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MAX_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MAX_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MAX_set", stop_bit, 7 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MAX_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031000 + (N) * 0x100) bits 23:16) field UNPACK_DROP_THRLD2_MAX of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031000 + (N) * 0x100) bits 23:16) field UNPACK_DROP_THRLD2_MAX of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MAX_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MAX_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MAX_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32  N,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MAX_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32  N,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MAX_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MAX_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MAX_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031000 + (N) * 0x100) bits 23:16) field UNPACK_DROP_THRLD2_MAX of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MAX_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MAX_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MAX_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MAX_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MAX_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MIN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MIN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N,
                                                                  UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MIN_set", N, 95);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MIN_set", value, 255);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MIN_set", N, value );

    /* ((0x00031000 + (N) * 0x100) bits 15:8) field UNPACK_DROP_THRLD2_MIN of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MIN_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MIN_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MIN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MIN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MIN_get", N, 95);
    /* ((0x00031000 + (N) * 0x100) bits 15:8) field UNPACK_DROP_THRLD2_MIN of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MIN_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MIN_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_UNPACK_DROP_THRLD2_MIN_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MIN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  N,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MIN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                        mapotn_handle_t *h_ptr,
                                                                        UINT32  N,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MIN_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MIN_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MIN_set", stop_bit, 7 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MIN_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031000 + (N) * 0x100) bits 15:8) field UNPACK_DROP_THRLD2_MIN of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031000 + (N) * 0x100) bits 15:8) field UNPACK_DROP_THRLD2_MIN of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MIN_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MIN_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MIN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32  N,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MIN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                          mapotn_handle_t *h_ptr,
                                                                          UINT32  N,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MIN_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MIN_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MIN_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031000 + (N) * 0x100) bits 15:8) field UNPACK_DROP_THRLD2_MIN of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MIN_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MIN_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MIN_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD2_MIN_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD2_MIN_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_UNPACK_DROP_THRLD1_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_UNPACK_DROP_THRLD1_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UNPACK_DROP_THRLD1_set", N, 95);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_UNPACK_DROP_THRLD1_set", value, 255);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_UNPACK_DROP_THRLD1_set", N, value );

    /* ((0x00031000 + (N) * 0x100) bits 7:0) field UNPACK_DROP_THRLD1 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD1_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD1_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_UNPACK_DROP_THRLD1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_UNPACK_DROP_THRLD1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UNPACK_DROP_THRLD1_get", N, 95);
    /* ((0x00031000 + (N) * 0x100) bits 7:0) field UNPACK_DROP_THRLD1 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD1_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD1_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_UNPACK_DROP_THRLD1_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_UNPACK_DROP_THRLD1_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_UNPACK_DROP_THRLD1_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD1_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD1_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD1_set", stop_bit, 7 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD1_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031000 + (N) * 0x100) bits 7:0) field UNPACK_DROP_THRLD1 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031000 + (N) * 0x100) bits 7:0) field UNPACK_DROP_THRLD1 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD1_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD1_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_UNPACK_DROP_THRLD1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32  N,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_UNPACK_DROP_THRLD1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                      mapotn_handle_t *h_ptr,
                                                                      UINT32  N,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD1_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD1_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD1_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031000 + (N) * 0x100) bits 7:0) field UNPACK_DROP_THRLD1 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_0_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD1_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD1_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_0_BIT_UNPACK_DROP_THRLD1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UNPACK_DROP_THRLD1_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PAUSE_MODE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PAUSE_MODE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PAUSE_MODE_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PAUSE_MODE_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_PAUSE_MODE_set", N, value );

    /* ((0x00031004 + (N) * 0x100) bits 30) field PAUSE_MODE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PAUSE_MODE_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PAUSE_MODE_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_PAUSE_MODE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PAUSE_MODE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PAUSE_MODE_get", N, 95);
    /* ((0x00031004 + (N) * 0x100) bits 30) field PAUSE_MODE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PAUSE_MODE_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PAUSE_MODE_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_PAUSE_MODE_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PAUSE_FILTER_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PAUSE_FILTER_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N,
                                                        UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PAUSE_FILTER_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PAUSE_FILTER_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_PAUSE_FILTER_set", N, value );

    /* ((0x00031004 + (N) * 0x100) bits 29) field PAUSE_FILTER of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PAUSE_FILTER_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PAUSE_FILTER_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_PAUSE_FILTER_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PAUSE_FILTER_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PAUSE_FILTER_get", N, 95);
    /* ((0x00031004 + (N) * 0x100) bits 29) field PAUSE_FILTER of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PAUSE_FILTER_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PAUSE_FILTER_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_PAUSE_FILTER_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PAUSE_ENABLE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PAUSE_ENABLE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N,
                                                        UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PAUSE_ENABLE_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PAUSE_ENABLE_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_PAUSE_ENABLE_set", N, value );

    /* ((0x00031004 + (N) * 0x100) bits 28) field PAUSE_ENABLE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PAUSE_ENABLE_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PAUSE_ENABLE_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_PAUSE_ENABLE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PAUSE_ENABLE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PAUSE_ENABLE_get", N, 95);
    /* ((0x00031004 + (N) * 0x100) bits 28) field PAUSE_ENABLE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PAUSE_ENABLE_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PAUSE_ENABLE_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_PAUSE_ENABLE_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PREAMBLE_SFD_MODE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PREAMBLE_SFD_MODE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PREAMBLE_SFD_MODE_set", N, 95);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PREAMBLE_SFD_MODE_set", value, 3);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_PREAMBLE_SFD_MODE_set", N, value );

    /* ((0x00031004 + (N) * 0x100) bits 27:26) field PREAMBLE_SFD_MODE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PREAMBLE_SFD_MODE_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PREAMBLE_SFD_MODE_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_PREAMBLE_SFD_MODE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PREAMBLE_SFD_MODE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PREAMBLE_SFD_MODE_get", N, 95);
    /* ((0x00031004 + (N) * 0x100) bits 27:26) field PREAMBLE_SFD_MODE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PREAMBLE_SFD_MODE_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PREAMBLE_SFD_MODE_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_PREAMBLE_SFD_MODE_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_PREAMBLE_SFD_MODE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_PREAMBLE_SFD_MODE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_PREAMBLE_SFD_MODE_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_PREAMBLE_SFD_MODE_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_PREAMBLE_SFD_MODE_set", stop_bit, 1 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_PREAMBLE_SFD_MODE_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031004 + (N) * 0x100) bits 27:26) field PREAMBLE_SFD_MODE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031004 + (N) * 0x100) bits 27:26) field PREAMBLE_SFD_MODE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PREAMBLE_SFD_MODE_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PREAMBLE_SFD_MODE_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_PREAMBLE_SFD_MODE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_PREAMBLE_SFD_MODE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_PREAMBLE_SFD_MODE_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_PREAMBLE_SFD_MODE_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_PREAMBLE_SFD_MODE_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031004 + (N) * 0x100) bits 27:26) field PREAMBLE_SFD_MODE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PREAMBLE_SFD_MODE_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PREAMBLE_SFD_MODE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PREAMBLE_SFD_MODE_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_PREAMBLE_SFD_MODE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_PREAMBLE_SFD_MODE_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_EXI_LENGTH2_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_EXI_LENGTH2_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EXI_LENGTH2_set", N, 95);
    if (value > 63)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_EXI_LENGTH2_set", value, 63);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_EXI_LENGTH2_set", N, value );

    /* ((0x00031004 + (N) * 0x100) bits 25:20) field EXI_LENGTH2 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH2_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH2_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_EXI_LENGTH2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_EXI_LENGTH2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EXI_LENGTH2_get", N, 95);
    /* ((0x00031004 + (N) * 0x100) bits 25:20) field EXI_LENGTH2 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH2_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH2_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_EXI_LENGTH2_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_EXI_LENGTH2_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_EXI_LENGTH2_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EXI_LENGTH2_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EXI_LENGTH2_set", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EXI_LENGTH2_set", stop_bit, 5 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EXI_LENGTH2_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031004 + (N) * 0x100) bits 25:20) field EXI_LENGTH2 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 5) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 5;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031004 + (N) * 0x100) bits 25:20) field EXI_LENGTH2 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH2_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH2_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_EXI_LENGTH2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_EXI_LENGTH2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EXI_LENGTH2_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EXI_LENGTH2_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EXI_LENGTH2_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031004 + (N) * 0x100) bits 25:20) field EXI_LENGTH2 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH2_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH2_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EXI_LENGTH2_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_EXI_VALUE2_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_EXI_VALUE2_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EXI_VALUE2_set", N, 95);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_EXI_VALUE2_set", value, 15);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_EXI_VALUE2_set", N, value );

    /* ((0x00031004 + (N) * 0x100) bits 19:16) field EXI_VALUE2 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE2_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE2_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_EXI_VALUE2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_EXI_VALUE2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EXI_VALUE2_get", N, 95);
    /* ((0x00031004 + (N) * 0x100) bits 19:16) field EXI_VALUE2 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE2_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE2_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_EXI_VALUE2_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_EXI_VALUE2_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_EXI_VALUE2_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EXI_VALUE2_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EXI_VALUE2_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EXI_VALUE2_set", stop_bit, 3 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EXI_VALUE2_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031004 + (N) * 0x100) bits 19:16) field EXI_VALUE2 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031004 + (N) * 0x100) bits 19:16) field EXI_VALUE2 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE2_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE2_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_EXI_VALUE2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_EXI_VALUE2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EXI_VALUE2_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EXI_VALUE2_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EXI_VALUE2_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031004 + (N) * 0x100) bits 19:16) field EXI_VALUE2 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE2_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE2_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EXI_VALUE2_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_EXI_LENGTH1_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_EXI_LENGTH1_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EXI_LENGTH1_set", N, 95);
    if (value > 63)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_EXI_LENGTH1_set", value, 63);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_EXI_LENGTH1_set", N, value );

    /* ((0x00031004 + (N) * 0x100) bits 15:10) field EXI_LENGTH1 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH1_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH1_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_EXI_LENGTH1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_EXI_LENGTH1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EXI_LENGTH1_get", N, 95);
    /* ((0x00031004 + (N) * 0x100) bits 15:10) field EXI_LENGTH1 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH1_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH1_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_EXI_LENGTH1_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_EXI_LENGTH1_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_EXI_LENGTH1_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EXI_LENGTH1_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EXI_LENGTH1_set", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EXI_LENGTH1_set", stop_bit, 5 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EXI_LENGTH1_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031004 + (N) * 0x100) bits 15:10) field EXI_LENGTH1 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 5) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 5;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031004 + (N) * 0x100) bits 15:10) field EXI_LENGTH1 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH1_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH1_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_EXI_LENGTH1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_EXI_LENGTH1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EXI_LENGTH1_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EXI_LENGTH1_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EXI_LENGTH1_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031004 + (N) * 0x100) bits 15:10) field EXI_LENGTH1 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH1_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH1_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_LENGTH1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EXI_LENGTH1_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_EXI_VALUE1_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_EXI_VALUE1_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EXI_VALUE1_set", N, 95);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_EXI_VALUE1_set", value, 15);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_EXI_VALUE1_set", N, value );

    /* ((0x00031004 + (N) * 0x100) bits 9:6) field EXI_VALUE1 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE1_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE1_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_EXI_VALUE1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_EXI_VALUE1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EXI_VALUE1_get", N, 95);
    /* ((0x00031004 + (N) * 0x100) bits 9:6) field EXI_VALUE1 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE1_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE1_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_EXI_VALUE1_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_EXI_VALUE1_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_EXI_VALUE1_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EXI_VALUE1_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EXI_VALUE1_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EXI_VALUE1_set", stop_bit, 3 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EXI_VALUE1_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031004 + (N) * 0x100) bits 9:6) field EXI_VALUE1 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031004 + (N) * 0x100) bits 9:6) field EXI_VALUE1 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE1_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE1_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_EXI_VALUE1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_EXI_VALUE1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EXI_VALUE1_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EXI_VALUE1_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EXI_VALUE1_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031004 + (N) * 0x100) bits 9:6) field EXI_VALUE1 of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE1_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE1_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EXI_VALUE1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EXI_VALUE1_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_EHEC_ECC_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_EHEC_ECC_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EHEC_ECC_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_EHEC_ECC_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_EHEC_ECC_set", N, value );

    /* ((0x00031004 + (N) * 0x100) bits 5) field EHEC_ECC of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EHEC_ECC_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EHEC_ECC_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_EHEC_ECC_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_EHEC_ECC_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EHEC_ECC_get", N, 95);
    /* ((0x00031004 + (N) * 0x100) bits 5) field EHEC_ECC of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EHEC_ECC_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EHEC_ECC_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_EHEC_ECC_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_EHEC_CHK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_EHEC_CHK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EHEC_CHK_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_EHEC_CHK_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_EHEC_CHK_set", N, value );

    /* ((0x00031004 + (N) * 0x100) bits 4) field EHEC_CHK of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EHEC_CHK_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EHEC_CHK_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_EHEC_CHK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_EHEC_CHK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EHEC_CHK_get", N, 95);
    /* ((0x00031004 + (N) * 0x100) bits 4) field EHEC_CHK of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EHEC_CHK_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_EHEC_CHK_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_EHEC_CHK_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_THEC_ECC_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_THEC_ECC_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_THEC_ECC_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_THEC_ECC_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_THEC_ECC_set", N, value );

    /* ((0x00031004 + (N) * 0x100) bits 3) field THEC_ECC of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_THEC_ECC_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_THEC_ECC_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_THEC_ECC_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_THEC_ECC_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_THEC_ECC_get", N, 95);
    /* ((0x00031004 + (N) * 0x100) bits 3) field THEC_ECC of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_THEC_ECC_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_THEC_ECC_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_THEC_ECC_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_THEC_CHK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_THEC_CHK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_THEC_CHK_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_THEC_CHK_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_THEC_CHK_set", N, value );

    /* ((0x00031004 + (N) * 0x100) bits 2) field THEC_CHK of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_THEC_CHK_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_THEC_CHK_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_THEC_CHK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_THEC_CHK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_THEC_CHK_get", N, 95);
    /* ((0x00031004 + (N) * 0x100) bits 2) field THEC_CHK of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_THEC_CHK_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_THEC_CHK_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_THEC_CHK_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_DESCRMBL_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_DESCRMBL_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DESCRMBL_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_DESCRMBL_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_DESCRMBL_set", N, value );

    /* ((0x00031004 + (N) * 0x100) bits 1) field DESCRMBL of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_DESCRMBL_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_DESCRMBL_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_DESCRMBL_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DESCRMBL_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DESCRMBL_get", N, 95);
    /* ((0x00031004 + (N) * 0x100) bits 1) field DESCRMBL of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_1_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_DESCRMBL_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_1_BIT_DESCRMBL_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_DESCRMBL_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_CPU_ONLY1BUF_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CPU_ONLY1BUF_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N,
                                                        UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_ONLY1BUF_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CPU_ONLY1BUF_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_CPU_ONLY1BUF_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 30) field CPU_ONLY1BUF of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CPU_ONLY1BUF_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CPU_ONLY1BUF_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_CPU_ONLY1BUF_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_ONLY1BUF_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_ONLY1BUF_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 30) field CPU_ONLY1BUF of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CPU_ONLY1BUF_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CPU_ONLY1BUF_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CPU_ONLY1BUF_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_DATA_REV_OBIT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_DATA_REV_OBIT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N,
                                                         UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DATA_REV_OBIT_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_DATA_REV_OBIT_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_DATA_REV_OBIT_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 29) field DATA_REV_OBIT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_DATA_REV_OBIT_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_DATA_REV_OBIT_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_DATA_REV_OBIT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DATA_REV_OBIT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DATA_REV_OBIT_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 29) field DATA_REV_OBIT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_DATA_REV_OBIT_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_DATA_REV_OBIT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_DATA_REV_OBIT_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_EGRESS_FCS_DISCARD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_EGRESS_FCS_DISCARD_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EGRESS_FCS_DISCARD_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_EGRESS_FCS_DISCARD_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_EGRESS_FCS_DISCARD_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 28) field EGRESS_FCS_DISCARD of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_FCS_DISCARD_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_FCS_DISCARD_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_EGRESS_FCS_DISCARD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_EGRESS_FCS_DISCARD_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EGRESS_FCS_DISCARD_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 28) field EGRESS_FCS_DISCARD of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_FCS_DISCARD_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_FCS_DISCARD_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_EGRESS_FCS_DISCARD_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_FC1200_TRAFFIC_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_FC1200_TRAFFIC_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_FC1200_TRAFFIC_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_FC1200_TRAFFIC_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_FC1200_TRAFFIC_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 27) field FC1200_TRAFFIC of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_FC1200_TRAFFIC_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_FC1200_TRAFFIC_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_FC1200_TRAFFIC_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_FC1200_TRAFFIC_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_FC1200_TRAFFIC_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 27) field FC1200_TRAFFIC of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_FC1200_TRAFFIC_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_FC1200_TRAFFIC_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_FC1200_TRAFFIC_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_EGRESS_FORMAT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_EGRESS_FORMAT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N,
                                                         UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EGRESS_FORMAT_set", N, 95);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_EGRESS_FORMAT_set", value, 3);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_EGRESS_FORMAT_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 26:25) field EGRESS_FORMAT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_FORMAT_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_FORMAT_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_EGRESS_FORMAT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_EGRESS_FORMAT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EGRESS_FORMAT_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 26:25) field EGRESS_FORMAT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_FORMAT_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_FORMAT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_EGRESS_FORMAT_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_EGRESS_FORMAT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_EGRESS_FORMAT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EGRESS_FORMAT_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EGRESS_FORMAT_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EGRESS_FORMAT_set", stop_bit, 1 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EGRESS_FORMAT_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031008 + (N) * 0x100) bits 26:25) field EGRESS_FORMAT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031008 + (N) * 0x100) bits 26:25) field EGRESS_FORMAT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_FORMAT_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_FORMAT_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_EGRESS_FORMAT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_EGRESS_FORMAT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EGRESS_FORMAT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EGRESS_FORMAT_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EGRESS_FORMAT_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031008 + (N) * 0x100) bits 26:25) field EGRESS_FORMAT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_FORMAT_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_FORMAT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_FORMAT_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_FORMAT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EGRESS_FORMAT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_CPU_FIFO_FORMAT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CPU_FIFO_FORMAT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_FIFO_FORMAT_set", N, 95);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CPU_FIFO_FORMAT_set", value, 3);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_CPU_FIFO_FORMAT_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 24:23) field CPU_FIFO_FORMAT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CPU_FIFO_FORMAT_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CPU_FIFO_FORMAT_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_CPU_FIFO_FORMAT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_FIFO_FORMAT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_FIFO_FORMAT_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 24:23) field CPU_FIFO_FORMAT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CPU_FIFO_FORMAT_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CPU_FIFO_FORMAT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CPU_FIFO_FORMAT_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_CPU_FIFO_FORMAT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_CPU_FIFO_FORMAT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_CPU_FIFO_FORMAT_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_CPU_FIFO_FORMAT_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_CPU_FIFO_FORMAT_set", stop_bit, 1 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_CPU_FIFO_FORMAT_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031008 + (N) * 0x100) bits 24:23) field CPU_FIFO_FORMAT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031008 + (N) * 0x100) bits 24:23) field CPU_FIFO_FORMAT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CPU_FIFO_FORMAT_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CPU_FIFO_FORMAT_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_CPU_FIFO_FORMAT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_CPU_FIFO_FORMAT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_CPU_FIFO_FORMAT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_CPU_FIFO_FORMAT_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_CPU_FIFO_FORMAT_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031008 + (N) * 0x100) bits 24:23) field CPU_FIFO_FORMAT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CPU_FIFO_FORMAT_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CPU_FIFO_FORMAT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CPU_FIFO_FORMAT_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CPU_FIFO_FORMAT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_CPU_FIFO_FORMAT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_EGRESS_EFCS_STRIP_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_EGRESS_EFCS_STRIP_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EGRESS_EFCS_STRIP_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_EGRESS_EFCS_STRIP_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_EGRESS_EFCS_STRIP_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 20) field EGRESS_EFCS_STRIP of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_EFCS_STRIP_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_EFCS_STRIP_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_EGRESS_EFCS_STRIP_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_EGRESS_EFCS_STRIP_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EGRESS_EFCS_STRIP_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 20) field EGRESS_EFCS_STRIP of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_EFCS_STRIP_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_EFCS_STRIP_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_EGRESS_EFCS_STRIP_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_EGRESS_PFCS_STRIP_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_EGRESS_PFCS_STRIP_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EGRESS_PFCS_STRIP_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_EGRESS_PFCS_STRIP_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_EGRESS_PFCS_STRIP_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 19) field EGRESS_PFCS_STRIP of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_PFCS_STRIP_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_PFCS_STRIP_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_EGRESS_PFCS_STRIP_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_EGRESS_PFCS_STRIP_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EGRESS_PFCS_STRIP_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 19) field EGRESS_PFCS_STRIP of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_PFCS_STRIP_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_EGRESS_PFCS_STRIP_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_EGRESS_PFCS_STRIP_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_CNT_UDF_FCS_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CNT_UDF_FCS_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CNT_UDF_FCS_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CNT_UDF_FCS_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_CNT_UDF_FCS_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 18) field CNT_UDF_FCS of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CNT_UDF_FCS_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CNT_UDF_FCS_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_CNT_UDF_FCS_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CNT_UDF_FCS_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CNT_UDF_FCS_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 18) field CNT_UDF_FCS of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CNT_UDF_FCS_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_CNT_UDF_FCS_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CNT_UDF_FCS_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_GFP_FCS_CHK_MODE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_GFP_FCS_CHK_MODE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_GFP_FCS_CHK_MODE_set", N, 95);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_GFP_FCS_CHK_MODE_set", value, 3);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_GFP_FCS_CHK_MODE_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 17:16) field GFP_FCS_CHK_MODE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_GFP_FCS_CHK_MODE_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_GFP_FCS_CHK_MODE_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_GFP_FCS_CHK_MODE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_GFP_FCS_CHK_MODE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_GFP_FCS_CHK_MODE_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 17:16) field GFP_FCS_CHK_MODE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_GFP_FCS_CHK_MODE_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_GFP_FCS_CHK_MODE_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_GFP_FCS_CHK_MODE_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_GFP_FCS_CHK_MODE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_GFP_FCS_CHK_MODE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_GFP_FCS_CHK_MODE_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_GFP_FCS_CHK_MODE_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_GFP_FCS_CHK_MODE_set", stop_bit, 1 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_GFP_FCS_CHK_MODE_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031008 + (N) * 0x100) bits 17:16) field GFP_FCS_CHK_MODE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031008 + (N) * 0x100) bits 17:16) field GFP_FCS_CHK_MODE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_GFP_FCS_CHK_MODE_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_GFP_FCS_CHK_MODE_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_GFP_FCS_CHK_MODE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_GFP_FCS_CHK_MODE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                    mapotn_handle_t *h_ptr,
                                                                    UINT32  N,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_GFP_FCS_CHK_MODE_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_GFP_FCS_CHK_MODE_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_GFP_FCS_CHK_MODE_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031008 + (N) * 0x100) bits 17:16) field GFP_FCS_CHK_MODE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_GFP_FCS_CHK_MODE_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_GFP_FCS_CHK_MODE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_GFP_FCS_CHK_MODE_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_GFP_FCS_CHK_MODE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_GFP_FCS_CHK_MODE_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PFCS_REV_FCSBYTE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PFCS_REV_FCSBYTE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N,
                                                            UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PFCS_REV_FCSBYTE_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PFCS_REV_FCSBYTE_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_PFCS_REV_FCSBYTE_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 15) field PFCS_REV_FCSBYTE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_REV_FCSBYTE_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_REV_FCSBYTE_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_PFCS_REV_FCSBYTE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PFCS_REV_FCSBYTE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PFCS_REV_FCSBYTE_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 15) field PFCS_REV_FCSBYTE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_REV_FCSBYTE_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_REV_FCSBYTE_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_PFCS_REV_FCSBYTE_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PFCS_REV_FCSBIT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PFCS_REV_FCSBIT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PFCS_REV_FCSBIT_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PFCS_REV_FCSBIT_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_PFCS_REV_FCSBIT_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 14) field PFCS_REV_FCSBIT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_REV_FCSBIT_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_REV_FCSBIT_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_PFCS_REV_FCSBIT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PFCS_REV_FCSBIT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PFCS_REV_FCSBIT_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 14) field PFCS_REV_FCSBIT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_REV_FCSBIT_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_REV_FCSBIT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_PFCS_REV_FCSBIT_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PFCS_REV_PLDBIT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PFCS_REV_PLDBIT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PFCS_REV_PLDBIT_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PFCS_REV_PLDBIT_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_PFCS_REV_PLDBIT_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 13) field PFCS_REV_PLDBIT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_REV_PLDBIT_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_REV_PLDBIT_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_PFCS_REV_PLDBIT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PFCS_REV_PLDBIT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PFCS_REV_PLDBIT_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 13) field PFCS_REV_PLDBIT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_REV_PLDBIT_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_REV_PLDBIT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_PFCS_REV_PLDBIT_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PFCS_INV_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PFCS_INV_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                    mapotn_handle_t *h_ptr,
                                                    UINT32  N,
                                                    UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PFCS_INV_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PFCS_INV_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_PFCS_INV_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 12) field PFCS_INV of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_INV_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_INV_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_PFCS_INV_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PFCS_INV_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PFCS_INV_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 12) field PFCS_INV of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_INV_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_INV_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_PFCS_INV_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PFCS_INIT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PFCS_INIT_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N,
                                                     UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PFCS_INIT_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PFCS_INIT_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_PFCS_INIT_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 11) field PFCS_INIT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_INIT_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_INIT_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_PFCS_INIT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PFCS_INIT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PFCS_INIT_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 11) field PFCS_INIT of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_INIT_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PFCS_INIT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_PFCS_INIT_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PAUSE_UPI_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PAUSE_UPI_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N,
                                                     UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PAUSE_UPI_set", N, 95);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PAUSE_UPI_set", value, 255);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_PAUSE_UPI_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 10:3) field PAUSE_UPI of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_UPI_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_UPI_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_PAUSE_UPI_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PAUSE_UPI_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PAUSE_UPI_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 10:3) field PAUSE_UPI of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_UPI_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_UPI_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_PAUSE_UPI_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_PAUSE_UPI_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_PAUSE_UPI_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_PAUSE_UPI_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_PAUSE_UPI_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_PAUSE_UPI_set", stop_bit, 7 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_PAUSE_UPI_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031008 + (N) * 0x100) bits 10:3) field PAUSE_UPI of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031008 + (N) * 0x100) bits 10:3) field PAUSE_UPI of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_UPI_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_UPI_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_PAUSE_UPI_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_PAUSE_UPI_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_PAUSE_UPI_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_PAUSE_UPI_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_PAUSE_UPI_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031008 + (N) * 0x100) bits 10:3) field PAUSE_UPI of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_UPI_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_UPI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_UPI_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_UPI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_PAUSE_UPI_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_PAUSE_PTI_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_PAUSE_PTI_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N,
                                                     UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PAUSE_PTI_set", N, 95);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_PAUSE_PTI_set", value, 7);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_PAUSE_PTI_set", N, value );

    /* ((0x00031008 + (N) * 0x100) bits 2:0) field PAUSE_PTI of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_PTI_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_PTI_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_PAUSE_PTI_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PAUSE_PTI_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PAUSE_PTI_get", N, 95);
    /* ((0x00031008 + (N) * 0x100) bits 2:0) field PAUSE_PTI of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_PTI_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_PTI_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_PAUSE_PTI_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_PAUSE_PTI_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_PAUSE_PTI_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_PAUSE_PTI_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_PAUSE_PTI_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_PAUSE_PTI_set", stop_bit, 2 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_PAUSE_PTI_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031008 + (N) * 0x100) bits 2:0) field PAUSE_PTI of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031008 + (N) * 0x100) bits 2:0) field PAUSE_PTI of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
        mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_field_set( b_ptr,
                                                                      h_ptr,
                                                                      N,
                                                                      subfield_mask << (RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_PTI_OFF + subfield_offset),
                                                                      RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_PTI_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_PAUSE_PTI_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_PAUSE_PTI_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_PAUSE_PTI_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_PAUSE_PTI_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_PAUSE_PTI_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031008 + (N) * 0x100) bits 2:0) field PAUSE_PTI of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_2_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    field_value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_PTI_MSK)
                  >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_PTI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_PTI_MSK, RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_2_BIT_PAUSE_PTI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_PAUSE_PTI_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_I_SFAIL_PROPAGATE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_I_SFAIL_PROPAGATE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_I_SFAIL_PROPAGATE_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_I_SFAIL_PROPAGATE_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_I_SFAIL_PROPAGATE_set", N, value );

    /* ((0x0003100c + (N) * 0x100) bits 8) field I_SFAIL_PROPAGATE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_I_SFAIL_PROPAGATE_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_I_SFAIL_PROPAGATE_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_I_SFAIL_PROPAGATE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_I_SFAIL_PROPAGATE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_I_SFAIL_PROPAGATE_get", N, 95);
    /* ((0x0003100c + (N) * 0x100) bits 8) field I_SFAIL_PROPAGATE of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_I_SFAIL_PROPAGATE_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_I_SFAIL_PROPAGATE_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_I_SFAIL_PROPAGATE_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_DLFD_SFAIL_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_DLFD_SFAIL_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DLFD_SFAIL_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_DLFD_SFAIL_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_DLFD_SFAIL_set", N, value );

    /* ((0x0003100c + (N) * 0x100) bits 7) field DLFD_SFAIL of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DLFD_SFAIL_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DLFD_SFAIL_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_DLFD_SFAIL_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DLFD_SFAIL_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DLFD_SFAIL_get", N, 95);
    /* ((0x0003100c + (N) * 0x100) bits 7) field DLFD_SFAIL of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DLFD_SFAIL_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DLFD_SFAIL_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_DLFD_SFAIL_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_DEXM_SFAIL_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_DEXM_SFAIL_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                      mapotn_handle_t *h_ptr,
                                                      UINT32  N,
                                                      UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DEXM_SFAIL_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_DEXM_SFAIL_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_DEXM_SFAIL_set", N, value );

    /* ((0x0003100c + (N) * 0x100) bits 4) field DEXM_SFAIL of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DEXM_SFAIL_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DEXM_SFAIL_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_DEXM_SFAIL_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DEXM_SFAIL_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DEXM_SFAIL_get", N, 95);
    /* ((0x0003100c + (N) * 0x100) bits 4) field DEXM_SFAIL of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DEXM_SFAIL_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DEXM_SFAIL_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_DEXM_SFAIL_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_DLFD_EN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_DLFD_EN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N,
                                                   UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DLFD_EN_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_DLFD_EN_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_DLFD_EN_set", N, value );

    /* ((0x0003100c + (N) * 0x100) bits 3) field DLFD_EN of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DLFD_EN_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DLFD_EN_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_DLFD_EN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DLFD_EN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DLFD_EN_get", N, 95);
    /* ((0x0003100c + (N) * 0x100) bits 3) field DLFD_EN of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DLFD_EN_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DLFD_EN_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_DLFD_EN_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_DCSF_EN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_DCSF_EN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N,
                                                   UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DCSF_EN_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_DCSF_EN_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_DCSF_EN_set", N, value );

    /* ((0x0003100c + (N) * 0x100) bits 2) field DCSF_EN of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DCSF_EN_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DCSF_EN_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_DCSF_EN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DCSF_EN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DCSF_EN_get", N, 95);
    /* ((0x0003100c + (N) * 0x100) bits 2) field DCSF_EN of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DCSF_EN_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DCSF_EN_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_DCSF_EN_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_DUPM_EN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_DUPM_EN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N,
                                                   UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DUPM_EN_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_DUPM_EN_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_DUPM_EN_set", N, value );

    /* ((0x0003100c + (N) * 0x100) bits 1) field DUPM_EN of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DUPM_EN_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DUPM_EN_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_DUPM_EN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DUPM_EN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DUPM_EN_get", N, 95);
    /* ((0x0003100c + (N) * 0x100) bits 1) field DUPM_EN of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DUPM_EN_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DUPM_EN_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_DUPM_EN_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_DEXM_EN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_DEXM_EN_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N,
                                                   UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DEXM_EN_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_DEXM_EN_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_DEXM_EN_set", N, value );

    /* ((0x0003100c + (N) * 0x100) bits 0) field DEXM_EN of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3 index N=0..95 */
    mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DEXM_EN_MSK,
                                                                  RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DEXM_EN_OFF,
                                                                  value);
}

static INLINE UINT32 mapotn_rgfpf_field_DEXM_EN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DEXM_EN_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DEXM_EN_get", N, 95);
    /* ((0x0003100c + (N) * 0x100) bits 0) field DEXM_EN of register PMC_RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GFP_CHANNEL_CONFIGURATION_3_array_read( b_ptr,
                                                                         h_ptr,
                                                                         N);
    value = (reg_value & RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DEXM_EN_MSK) >> RGFPF96_CORE_REG_GFP_CHANNEL_CONFIGURATION_3_BIT_DEXM_EN_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_DEXM_EN_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_MAXFL_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                 mapotn_handle_t *h_ptr,
                                                 UINT32  N,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_MAXFL_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                 mapotn_handle_t *h_ptr,
                                                 UINT32  N,
                                                 UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_MAXFL_set", N, 95);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_MAXFL_set", value, 65535);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_MAXFL_set", N, value );

    /* ((0x0003103c + (N) * 0x100) bits 31:16) field MAXFL of register PMC_RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION index N=0..95 */
    mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_field_set( b_ptr,
                                                                       h_ptr,
                                                                       N,
                                                                       RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MAXFL_MSK,
                                                                       RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MAXFL_OFF,
                                                                       value);
}

static INLINE UINT32 mapotn_rgfpf_field_MAXFL_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_MAXFL_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_MAXFL_get", N, 95);
    /* ((0x0003103c + (N) * 0x100) bits 31:16) field MAXFL of register PMC_RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION index N=0..95 */
    reg_value = mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_read( b_ptr,
                                                                              h_ptr,
                                                                              N);
    value = (reg_value & RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MAXFL_MSK) >> RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MAXFL_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_MAXFL_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_MAXFL_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_MAXFL_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_MAXFL_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MAXFL_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MAXFL_set", stop_bit, 15 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MAXFL_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x0003103c + (N) * 0x100) bits 31:16) field MAXFL of register PMC_RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x0003103c + (N) * 0x100) bits 31:16) field MAXFL of register PMC_RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION index N=0..95 */
        mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_field_set( b_ptr,
                                                                           h_ptr,
                                                                           N,
                                                                           subfield_mask << (RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MAXFL_OFF + subfield_offset),
                                                                           RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MAXFL_OFF + subfield_offset,
                                                                           value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_MAXFL_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_MAXFL_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_MAXFL_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MAXFL_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MAXFL_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x0003103c + (N) * 0x100) bits 31:16) field MAXFL of register PMC_RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION index N=0..95 */
    reg_value = mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_read( b_ptr,
                                                                              h_ptr,
                                                                              N);
    field_value = (reg_value & RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MAXFL_MSK)
                  >> RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MAXFL_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MAXFL_MSK, RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MAXFL_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MAXFL_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_MINFL_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                 mapotn_handle_t *h_ptr,
                                                 UINT32  N,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_MINFL_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                 mapotn_handle_t *h_ptr,
                                                 UINT32  N,
                                                 UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_MINFL_set", N, 95);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_MINFL_set", value, 65535);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_MINFL_set", N, value );

    /* ((0x0003103c + (N) * 0x100) bits 15:0) field MINFL of register PMC_RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION index N=0..95 */
    mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_field_set( b_ptr,
                                                                       h_ptr,
                                                                       N,
                                                                       RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MINFL_MSK,
                                                                       RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MINFL_OFF,
                                                                       value);
}

static INLINE UINT32 mapotn_rgfpf_field_MINFL_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_MINFL_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_MINFL_get", N, 95);
    /* ((0x0003103c + (N) * 0x100) bits 15:0) field MINFL of register PMC_RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION index N=0..95 */
    reg_value = mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_read( b_ptr,
                                                                              h_ptr,
                                                                              N);
    value = (reg_value & RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MINFL_MSK) >> RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MINFL_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_MINFL_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_MINFL_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_MINFL_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_MINFL_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MINFL_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MINFL_set", stop_bit, 15 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MINFL_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x0003103c + (N) * 0x100) bits 15:0) field MINFL of register PMC_RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x0003103c + (N) * 0x100) bits 15:0) field MINFL of register PMC_RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION index N=0..95 */
        mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_field_set( b_ptr,
                                                                           h_ptr,
                                                                           N,
                                                                           subfield_mask << (RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MINFL_OFF + subfield_offset),
                                                                           RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MINFL_OFF + subfield_offset,
                                                                           value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_MINFL_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_MINFL_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_MINFL_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MINFL_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MINFL_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x0003103c + (N) * 0x100) bits 15:0) field MINFL of register PMC_RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION index N=0..95 */
    reg_value = mapotn_rgfpf_reg_FRAME_LENGTH_CHECK_CONFIGURATION_array_read( b_ptr,
                                                                              h_ptr,
                                                                              N);
    field_value = (reg_value & RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MINFL_MSK)
                  >> RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MINFL_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MINFL_MSK, RGFPF96_CORE_REG_FRAME_LENGTH_CHECK_CONFIGURATION_BIT_MINFL_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MINFL_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_CPU_RST_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_CPU_RST_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                   mapotn_handle_t *h_ptr,
                                                   UINT32  N,
                                                   UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_RST_set", N, 95);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_CPU_RST_set", value, 1);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_CPU_RST_set", N, value );

    /* ((0x00031040 + (N) * 0x100) bits 31) field CPU_RST of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET index N=0..95 */
    mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_field_set( b_ptr,
                                                                 h_ptr,
                                                                 N,
                                                                 RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_RST_MSK,
                                                                 RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_RST_OFF,
                                                                 value);
}

static INLINE UINT32 mapotn_rgfpf_field_CPU_RST_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_RST_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                     mapotn_handle_t *h_ptr,
                                                     UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_RST_get", N, 95);
    /* ((0x00031040 + (N) * 0x100) bits 31) field CPU_RST of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_read( b_ptr,
                                                                        h_ptr,
                                                                        N);
    value = (reg_value & RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_RST_MSK) >> RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_RST_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CPU_RST_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_CPU_NUMBYTES_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_NUMBYTES_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_NUMBYTES_get", N, 95);
    /* ((0x00031040 + (N) * 0x100) bits 15:8) field CPU_NUMBYTES of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_read( b_ptr,
                                                                        h_ptr,
                                                                        N);
    value = (reg_value & RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_NUMBYTES_MSK) >> RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_NUMBYTES_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CPU_NUMBYTES_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_CPU_NUMBYTES_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_CPU_NUMBYTES_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_CPU_NUMBYTES_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_CPU_NUMBYTES_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_CPU_NUMBYTES_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031040 + (N) * 0x100) bits 15:8) field CPU_NUMBYTES of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_read( b_ptr,
                                                                        h_ptr,
                                                                        N);
    field_value = (reg_value & RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_NUMBYTES_MSK)
                  >> RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_NUMBYTES_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_NUMBYTES_MSK, RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_NUMBYTES_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_CPU_NUMBYTES_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_CPU_ERR_AV_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_ERR_AV_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_ERR_AV_get", N, 95);
    /* ((0x00031040 + (N) * 0x100) bits 3) field CPU_ERR_AV of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_read( b_ptr,
                                                                        h_ptr,
                                                                        N);
    value = (reg_value & RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_ERR_AV_MSK) >> RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_ERR_AV_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CPU_ERR_AV_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_CPU_EOF_AV_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_EOF_AV_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_EOF_AV_get", N, 95);
    /* ((0x00031040 + (N) * 0x100) bits 2) field CPU_EOF_AV of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_read( b_ptr,
                                                                        h_ptr,
                                                                        N);
    value = (reg_value & RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_EOF_AV_MSK) >> RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_EOF_AV_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CPU_EOF_AV_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_CPU_SOF_AV_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_SOF_AV_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_SOF_AV_get", N, 95);
    /* ((0x00031040 + (N) * 0x100) bits 1) field CPU_SOF_AV of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_read( b_ptr,
                                                                        h_ptr,
                                                                        N);
    value = (reg_value & RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_SOF_AV_MSK) >> RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_SOF_AV_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CPU_SOF_AV_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_CPU_DATA_AV_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_DATA_AV_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_DATA_AV_get", N, 95);
    /* ((0x00031040 + (N) * 0x100) bits 0) field CPU_DATA_AV of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_STATUS_RESET_array_read( b_ptr,
                                                                        h_ptr,
                                                                        N);
    value = (reg_value & RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_DATA_AV_MSK) >> RGFPF96_CORE_REG_CPU_DATA_FIFO_STATUS_RESET_BIT_CPU_DATA_AV_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CPU_DATA_AV_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_CPU_BYTE3_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_BYTE3_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_BYTE3_get", N, 95);
    /* ((0x00031044 + (N) * 0x100) bits 31:24) field CPU_BYTE3 of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_DATA_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    value = (reg_value & RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE3_MSK) >> RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE3_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CPU_BYTE3_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_CPU_BYTE3_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_CPU_BYTE3_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_CPU_BYTE3_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_CPU_BYTE3_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_CPU_BYTE3_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031044 + (N) * 0x100) bits 31:24) field CPU_BYTE3 of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_DATA_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    field_value = (reg_value & RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE3_MSK)
                  >> RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE3_MSK, RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_CPU_BYTE3_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_CPU_BYTE2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_BYTE2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_BYTE2_get", N, 95);
    /* ((0x00031044 + (N) * 0x100) bits 23:16) field CPU_BYTE2 of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_DATA_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    value = (reg_value & RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE2_MSK) >> RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE2_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CPU_BYTE2_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_CPU_BYTE2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_CPU_BYTE2_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_CPU_BYTE2_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_CPU_BYTE2_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_CPU_BYTE2_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031044 + (N) * 0x100) bits 23:16) field CPU_BYTE2 of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_DATA_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    field_value = (reg_value & RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE2_MSK)
                  >> RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE2_MSK, RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_CPU_BYTE2_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_CPU_BYTE1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_BYTE1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_BYTE1_get", N, 95);
    /* ((0x00031044 + (N) * 0x100) bits 15:8) field CPU_BYTE1 of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_DATA_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    value = (reg_value & RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE1_MSK) >> RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE1_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CPU_BYTE1_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_CPU_BYTE1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_CPU_BYTE1_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_CPU_BYTE1_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_CPU_BYTE1_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_CPU_BYTE1_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031044 + (N) * 0x100) bits 15:8) field CPU_BYTE1 of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_DATA_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    field_value = (reg_value & RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE1_MSK)
                  >> RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE1_MSK, RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_CPU_BYTE1_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_CPU_BYTE0_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_BYTE0_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                       mapotn_handle_t *h_ptr,
                                                       UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_BYTE0_get", N, 95);
    /* ((0x00031044 + (N) * 0x100) bits 7:0) field CPU_BYTE0 of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_DATA_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    value = (reg_value & RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE0_MSK) >> RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE0_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CPU_BYTE0_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_CPU_BYTE0_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_CPU_BYTE0_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_CPU_BYTE0_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_CPU_BYTE0_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_CPU_BYTE0_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031044 + (N) * 0x100) bits 7:0) field CPU_BYTE0 of register PMC_RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_DATA_FIFO_DATA_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    field_value = (reg_value & RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE0_MSK)
                  >> RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE0_MSK, RGFPF96_CORE_REG_CPU_DATA_FIFO_DATA_BIT_CPU_BYTE0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_CPU_BYTE0_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_PAUSE_TIME_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PAUSE_TIME_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PAUSE_TIME_get", N, 95);
    /* ((0x00031048 + (N) * 0x100) bits 15:0) field PAUSE_TIME of register PMC_RGFPF96_CORE_REG_PAUSE_TIME_REG index N=0..95 */
    reg_value = mapotn_rgfpf_reg_PAUSE_TIME_REG_array_read( b_ptr,
                                                            h_ptr,
                                                            N);
    value = (reg_value & RGFPF96_CORE_REG_PAUSE_TIME_REG_BIT_PAUSE_TIME_MSK) >> RGFPF96_CORE_REG_PAUSE_TIME_REG_BIT_PAUSE_TIME_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_PAUSE_TIME_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_PAUSE_TIME_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_PAUSE_TIME_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_PAUSE_TIME_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_PAUSE_TIME_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_PAUSE_TIME_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031048 + (N) * 0x100) bits 15:0) field PAUSE_TIME of register PMC_RGFPF96_CORE_REG_PAUSE_TIME_REG index N=0..95 */
    reg_value = mapotn_rgfpf_reg_PAUSE_TIME_REG_array_read( b_ptr,
                                                            h_ptr,
                                                            N);
    field_value = (reg_value & RGFPF96_CORE_REG_PAUSE_TIME_REG_BIT_PAUSE_TIME_MSK)
                  >> RGFPF96_CORE_REG_PAUSE_TIME_REG_BIT_PAUSE_TIME_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_PAUSE_TIME_REG_BIT_PAUSE_TIME_MSK, RGFPF96_CORE_REG_PAUSE_TIME_REG_BIT_PAUSE_TIME_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_PAUSE_TIME_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_GENERIC_OFFSET_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_GENERIC_OFFSET_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N,
                                                          UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_GENERIC_OFFSET_set", N, 95);
    if (value > 127)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_GENERIC_OFFSET_set", value, 127);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_GENERIC_OFFSET_set", N, value );

    /* ((0x0003104c + (N) * 0x100) bits 6:0) field GENERIC_OFFSET of register PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0 index N=0..95 */
    mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_0_array_field_set( b_ptr,
                                                              h_ptr,
                                                              N,
                                                              RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0_BIT_GENERIC_OFFSET_MSK,
                                                              RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0_BIT_GENERIC_OFFSET_OFF,
                                                              value);
}

static INLINE UINT32 mapotn_rgfpf_field_GENERIC_OFFSET_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_GENERIC_OFFSET_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_GENERIC_OFFSET_get", N, 95);
    /* ((0x0003104c + (N) * 0x100) bits 6:0) field GENERIC_OFFSET of register PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_0_array_read( b_ptr,
                                                                     h_ptr,
                                                                     N);
    value = (reg_value & RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0_BIT_GENERIC_OFFSET_MSK) >> RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0_BIT_GENERIC_OFFSET_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_GENERIC_OFFSET_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_GENERIC_OFFSET_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_GENERIC_OFFSET_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_GENERIC_OFFSET_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_GENERIC_OFFSET_set", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_GENERIC_OFFSET_set", stop_bit, 6 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_GENERIC_OFFSET_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x0003104c + (N) * 0x100) bits 6:0) field GENERIC_OFFSET of register PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 6) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 6;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x0003104c + (N) * 0x100) bits 6:0) field GENERIC_OFFSET of register PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0 index N=0..95 */
        mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_0_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  subfield_mask << (RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0_BIT_GENERIC_OFFSET_OFF + subfield_offset),
                                                                  RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0_BIT_GENERIC_OFFSET_OFF + subfield_offset,
                                                                  value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_GENERIC_OFFSET_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_GENERIC_OFFSET_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_GENERIC_OFFSET_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_GENERIC_OFFSET_get", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_GENERIC_OFFSET_get", stop_bit, 6 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 6) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 6;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x0003104c + (N) * 0x100) bits 6:0) field GENERIC_OFFSET of register PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_0_array_read( b_ptr,
                                                                     h_ptr,
                                                                     N);
    field_value = (reg_value & RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0_BIT_GENERIC_OFFSET_MSK)
                  >> RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0_BIT_GENERIC_OFFSET_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0_BIT_GENERIC_OFFSET_MSK, RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_0_BIT_GENERIC_OFFSET_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_GENERIC_OFFSET_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_GENERIC_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_GENERIC_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N,
                                                        UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_GENERIC_MASK_set", N, 95);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_GENERIC_MASK_set", N, value );

    /* ((0x00031050 + (N) * 0x100) bits 31:0) field GENERIC_MASK of register PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1 index N=0..95 */
    mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_1_array_field_set( b_ptr,
                                                              h_ptr,
                                                              N,
                                                              RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1_BIT_GENERIC_MASK_MSK,
                                                              RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1_BIT_GENERIC_MASK_OFF,
                                                              value);
}

static INLINE UINT32 mapotn_rgfpf_field_GENERIC_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_GENERIC_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_GENERIC_MASK_get", N, 95);
    /* ((0x00031050 + (N) * 0x100) bits 31:0) field GENERIC_MASK of register PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_1_array_read( b_ptr,
                                                                     h_ptr,
                                                                     N);
    value = (reg_value & RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1_BIT_GENERIC_MASK_MSK) >> RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1_BIT_GENERIC_MASK_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_GENERIC_MASK_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_GENERIC_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_GENERIC_MASK_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_GENERIC_MASK_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_GENERIC_MASK_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_GENERIC_MASK_set", stop_bit, 31 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_GENERIC_MASK_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031050 + (N) * 0x100) bits 31:0) field GENERIC_MASK of register PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031050 + (N) * 0x100) bits 31:0) field GENERIC_MASK of register PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1 index N=0..95 */
        mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_1_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  subfield_mask << (RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1_BIT_GENERIC_MASK_OFF + subfield_offset),
                                                                  RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1_BIT_GENERIC_MASK_OFF + subfield_offset,
                                                                  value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_GENERIC_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_GENERIC_MASK_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_GENERIC_MASK_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_GENERIC_MASK_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_GENERIC_MASK_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031050 + (N) * 0x100) bits 31:0) field GENERIC_MASK of register PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_1_array_read( b_ptr,
                                                                     h_ptr,
                                                                     N);
    field_value = (reg_value & RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1_BIT_GENERIC_MASK_MSK)
                  >> RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1_BIT_GENERIC_MASK_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1_BIT_GENERIC_MASK_MSK, RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_1_BIT_GENERIC_MASK_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_GENERIC_MASK_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_GENERIC_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_GENERIC_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N,
                                                         UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_GENERIC_VALUE_set", N, 95);
    IOLOG( "%s <= N=%d 0x%08x", "mapotn_rgfpf_field_GENERIC_VALUE_set", N, value );

    /* ((0x00031054 + (N) * 0x100) bits 31:0) field GENERIC_VALUE of register PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2 index N=0..95 */
    mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_2_array_field_set( b_ptr,
                                                              h_ptr,
                                                              N,
                                                              RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2_BIT_GENERIC_VALUE_MSK,
                                                              RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2_BIT_GENERIC_VALUE_OFF,
                                                              value);
}

static INLINE UINT32 mapotn_rgfpf_field_GENERIC_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_GENERIC_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_GENERIC_VALUE_get", N, 95);
    /* ((0x00031054 + (N) * 0x100) bits 31:0) field GENERIC_VALUE of register PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_2_array_read( b_ptr,
                                                                     h_ptr,
                                                                     N);
    value = (reg_value & RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2_BIT_GENERIC_VALUE_MSK) >> RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2_BIT_GENERIC_VALUE_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_GENERIC_VALUE_get", N, value );

    return value;
}
static INLINE void mapotn_rgfpf_field_range_GENERIC_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_range_GENERIC_VALUE_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_GENERIC_VALUE_set", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_GENERIC_VALUE_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_GENERIC_VALUE_set", stop_bit, 31 );
    IOLOG( "%s <= N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_GENERIC_VALUE_set", N, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* ((0x00031054 + (N) * 0x100) bits 31:0) field GENERIC_VALUE of register PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2 index N=0..95 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* ((0x00031054 + (N) * 0x100) bits 31:0) field GENERIC_VALUE of register PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2 index N=0..95 */
        mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_2_array_field_set( b_ptr,
                                                                  h_ptr,
                                                                  N,
                                                                  subfield_mask << (RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2_BIT_GENERIC_VALUE_OFF + subfield_offset),
                                                                  RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2_BIT_GENERIC_VALUE_OFF + subfield_offset,
                                                                  value >> subfield_shift);
    }
}

static INLINE UINT32 mapotn_rgfpf_field_range_GENERIC_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_GENERIC_VALUE_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_GENERIC_VALUE_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_GENERIC_VALUE_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_GENERIC_VALUE_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00031054 + (N) * 0x100) bits 31:0) field GENERIC_VALUE of register PMC_RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2 index N=0..95 */
    reg_value = mapotn_rgfpf_reg_GENERIC_FILTER_CONFIG_2_array_read( b_ptr,
                                                                     h_ptr,
                                                                     N);
    field_value = (reg_value & RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2_BIT_GENERIC_VALUE_MSK)
                  >> RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2_BIT_GENERIC_VALUE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2_BIT_GENERIC_VALUE_MSK, RGFPF96_CORE_REG_GENERIC_FILTER_CONFIG_2_BIT_GENERIC_VALUE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_GENERIC_VALUE_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_RX_BYTE_CNT_LSB_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_RX_BYTE_CNT_LSB_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_RX_BYTE_CNT_LSB_get", N, 95);
    /* ((0x00037000 + (N) * 0x80) bits 31:0) field RX_BYTE_CNT_LSB of register PMC_RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_LSB index N=0..95 */
    reg_value = mapotn_rgfpf_reg_RX_BYTE_CNT_PMON_LSB_array_read( b_ptr,
                                                                  h_ptr,
                                                                  N);
    value = (reg_value & RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_LSB_BIT_RX_BYTE_CNT_LSB_MSK) >> RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_LSB_BIT_RX_BYTE_CNT_LSB_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_RX_BYTE_CNT_LSB_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_RX_BYTE_CNT_LSB_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_RX_BYTE_CNT_LSB_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_RX_BYTE_CNT_LSB_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_RX_BYTE_CNT_LSB_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_RX_BYTE_CNT_LSB_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037000 + (N) * 0x80) bits 31:0) field RX_BYTE_CNT_LSB of register PMC_RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_LSB index N=0..95 */
    reg_value = mapotn_rgfpf_reg_RX_BYTE_CNT_PMON_LSB_array_read( b_ptr,
                                                                  h_ptr,
                                                                  N);
    field_value = (reg_value & RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_LSB_BIT_RX_BYTE_CNT_LSB_MSK)
                  >> RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_LSB_BIT_RX_BYTE_CNT_LSB_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_LSB_BIT_RX_BYTE_CNT_LSB_MSK, RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_LSB_BIT_RX_BYTE_CNT_LSB_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_RX_BYTE_CNT_LSB_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_RX_BYTE_CNT_MSB_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_RX_BYTE_CNT_MSB_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_RX_BYTE_CNT_MSB_get", N, 95);
    /* ((0x00037004 + (N) * 0x80) bits 7:0) field RX_BYTE_CNT_MSB of register PMC_RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_MSB index N=0..95 */
    reg_value = mapotn_rgfpf_reg_RX_BYTE_CNT_PMON_MSB_array_read( b_ptr,
                                                                  h_ptr,
                                                                  N);
    value = (reg_value & RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_MSB_BIT_RX_BYTE_CNT_MSB_MSK) >> RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_MSB_BIT_RX_BYTE_CNT_MSB_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_RX_BYTE_CNT_MSB_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_RX_BYTE_CNT_MSB_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_RX_BYTE_CNT_MSB_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_RX_BYTE_CNT_MSB_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_RX_BYTE_CNT_MSB_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_RX_BYTE_CNT_MSB_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037004 + (N) * 0x80) bits 7:0) field RX_BYTE_CNT_MSB of register PMC_RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_MSB index N=0..95 */
    reg_value = mapotn_rgfpf_reg_RX_BYTE_CNT_PMON_MSB_array_read( b_ptr,
                                                                  h_ptr,
                                                                  N);
    field_value = (reg_value & RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_MSB_BIT_RX_BYTE_CNT_MSB_MSK)
                  >> RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_MSB_BIT_RX_BYTE_CNT_MSB_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_MSB_BIT_RX_BYTE_CNT_MSB_MSK, RGFPF96_CORE_REG_RX_BYTE_CNT_PMON_MSB_BIT_RX_BYTE_CNT_MSB_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_RX_BYTE_CNT_MSB_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_RX_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_RX_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                        mapotn_handle_t *h_ptr,
                                                        UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_RX_FRM_CNT_get", N, 95);
    /* ((0x00037008 + (N) * 0x80) bits 31:0) field RX_FRM_CNT of register PMC_RGFPF96_CORE_REG_RX_FRM_CNT index N=0..95 */
    reg_value = mapotn_rgfpf_reg_RX_FRM_CNT_array_read( b_ptr,
                                                        h_ptr,
                                                        N);
    value = (reg_value & RGFPF96_CORE_REG_RX_FRM_CNT_BIT_RX_FRM_CNT_MSK) >> RGFPF96_CORE_REG_RX_FRM_CNT_BIT_RX_FRM_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_RX_FRM_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_RX_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_RX_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32  N,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_RX_FRM_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_RX_FRM_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_RX_FRM_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037008 + (N) * 0x80) bits 31:0) field RX_FRM_CNT of register PMC_RGFPF96_CORE_REG_RX_FRM_CNT index N=0..95 */
    reg_value = mapotn_rgfpf_reg_RX_FRM_CNT_array_read( b_ptr,
                                                        h_ptr,
                                                        N);
    field_value = (reg_value & RGFPF96_CORE_REG_RX_FRM_CNT_BIT_RX_FRM_CNT_MSK)
                  >> RGFPF96_CORE_REG_RX_FRM_CNT_BIT_RX_FRM_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_RX_FRM_CNT_BIT_RX_FRM_CNT_MSK, RGFPF96_CORE_REG_RX_FRM_CNT_BIT_RX_FRM_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_RX_FRM_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_IDLE_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_IDLE_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_IDLE_FRM_CNT_get", N, 95);
    /* ((0x0003700c + (N) * 0x80) bits 31:0) field IDLE_FRM_CNT of register PMC_RGFPF96_CORE_REG_IDLE_FRM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_IDLE_FRM_CNT_PMON_array_read( b_ptr,
                                                               h_ptr,
                                                               N);
    value = (reg_value & RGFPF96_CORE_REG_IDLE_FRM_CNT_PMON_BIT_IDLE_FRM_CNT_MSK) >> RGFPF96_CORE_REG_IDLE_FRM_CNT_PMON_BIT_IDLE_FRM_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_IDLE_FRM_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_IDLE_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_IDLE_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_IDLE_FRM_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_IDLE_FRM_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_IDLE_FRM_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x0003700c + (N) * 0x80) bits 31:0) field IDLE_FRM_CNT of register PMC_RGFPF96_CORE_REG_IDLE_FRM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_IDLE_FRM_CNT_PMON_array_read( b_ptr,
                                                               h_ptr,
                                                               N);
    field_value = (reg_value & RGFPF96_CORE_REG_IDLE_FRM_CNT_PMON_BIT_IDLE_FRM_CNT_MSK)
                  >> RGFPF96_CORE_REG_IDLE_FRM_CNT_PMON_BIT_IDLE_FRM_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_IDLE_FRM_CNT_PMON_BIT_IDLE_FRM_CNT_MSK, RGFPF96_CORE_REG_IDLE_FRM_CNT_PMON_BIT_IDLE_FRM_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_IDLE_FRM_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_CTRL_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CTRL_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CTRL_FRM_CNT_get", N, 95);
    /* ((0x00037010 + (N) * 0x80) bits 31:0) field CTRL_FRM_CNT of register PMC_RGFPF96_CORE_REG_CTRL_FRM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CTRL_FRM_CNT_PMON_array_read( b_ptr,
                                                               h_ptr,
                                                               N);
    value = (reg_value & RGFPF96_CORE_REG_CTRL_FRM_CNT_PMON_BIT_CTRL_FRM_CNT_MSK) >> RGFPF96_CORE_REG_CTRL_FRM_CNT_PMON_BIT_CTRL_FRM_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CTRL_FRM_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_CTRL_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_CTRL_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_CTRL_FRM_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_CTRL_FRM_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_CTRL_FRM_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037010 + (N) * 0x80) bits 31:0) field CTRL_FRM_CNT of register PMC_RGFPF96_CORE_REG_CTRL_FRM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CTRL_FRM_CNT_PMON_array_read( b_ptr,
                                                               h_ptr,
                                                               N);
    field_value = (reg_value & RGFPF96_CORE_REG_CTRL_FRM_CNT_PMON_BIT_CTRL_FRM_CNT_MSK)
                  >> RGFPF96_CORE_REG_CTRL_FRM_CNT_PMON_BIT_CTRL_FRM_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_CTRL_FRM_CNT_PMON_BIT_CTRL_FRM_CNT_MSK, RGFPF96_CORE_REG_CTRL_FRM_CNT_PMON_BIT_CTRL_FRM_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_CTRL_FRM_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_ERR_CHEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_ERR_CHEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_ERR_CHEC_CNT_get", N, 95);
    /* ((0x00037014 + (N) * 0x80) bits 31:0) field ERR_CHEC_CNT of register PMC_RGFPF96_CORE_REG_ERR_CHEC_CNT index N=0..95 */
    reg_value = mapotn_rgfpf_reg_ERR_CHEC_CNT_array_read( b_ptr,
                                                          h_ptr,
                                                          N);
    value = (reg_value & RGFPF96_CORE_REG_ERR_CHEC_CNT_BIT_ERR_CHEC_CNT_MSK) >> RGFPF96_CORE_REG_ERR_CHEC_CNT_BIT_ERR_CHEC_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_ERR_CHEC_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_ERR_CHEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_ERR_CHEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_ERR_CHEC_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_ERR_CHEC_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_ERR_CHEC_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037014 + (N) * 0x80) bits 31:0) field ERR_CHEC_CNT of register PMC_RGFPF96_CORE_REG_ERR_CHEC_CNT index N=0..95 */
    reg_value = mapotn_rgfpf_reg_ERR_CHEC_CNT_array_read( b_ptr,
                                                          h_ptr,
                                                          N);
    field_value = (reg_value & RGFPF96_CORE_REG_ERR_CHEC_CNT_BIT_ERR_CHEC_CNT_MSK)
                  >> RGFPF96_CORE_REG_ERR_CHEC_CNT_BIT_ERR_CHEC_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_ERR_CHEC_CNT_BIT_ERR_CHEC_CNT_MSK, RGFPF96_CORE_REG_ERR_CHEC_CNT_BIT_ERR_CHEC_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_ERR_CHEC_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_SINGL_ERR_CORR_CHEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_SINGL_ERR_CORR_CHEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                     mapotn_handle_t *h_ptr,
                                                                     UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_SINGL_ERR_CORR_CHEC_CNT_get", N, 95);
    /* ((0x00037018 + (N) * 0x80) bits 31:0) field SINGL_ERR_CORR_CHEC_CNT of register PMC_RGFPF96_CORE_REG_SINGL_ERR_CORR_CHEC_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_SINGL_ERR_CORR_CHEC_CNT_PMON_array_read( b_ptr,
                                                                          h_ptr,
                                                                          N);
    value = (reg_value & RGFPF96_CORE_REG_SINGL_ERR_CORR_CHEC_CNT_PMON_BIT_SINGL_ERR_CORR_CHEC_CNT_MSK) >> RGFPF96_CORE_REG_SINGL_ERR_CORR_CHEC_CNT_PMON_BIT_SINGL_ERR_CORR_CHEC_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_SINGL_ERR_CORR_CHEC_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_SINGL_ERR_CORR_CHEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32  N,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_SINGL_ERR_CORR_CHEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                           mapotn_handle_t *h_ptr,
                                                                           UINT32  N,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_SINGL_ERR_CORR_CHEC_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_SINGL_ERR_CORR_CHEC_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_SINGL_ERR_CORR_CHEC_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037018 + (N) * 0x80) bits 31:0) field SINGL_ERR_CORR_CHEC_CNT of register PMC_RGFPF96_CORE_REG_SINGL_ERR_CORR_CHEC_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_SINGL_ERR_CORR_CHEC_CNT_PMON_array_read( b_ptr,
                                                                          h_ptr,
                                                                          N);
    field_value = (reg_value & RGFPF96_CORE_REG_SINGL_ERR_CORR_CHEC_CNT_PMON_BIT_SINGL_ERR_CORR_CHEC_CNT_MSK)
                  >> RGFPF96_CORE_REG_SINGL_ERR_CORR_CHEC_CNT_PMON_BIT_SINGL_ERR_CORR_CHEC_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_SINGL_ERR_CORR_CHEC_CNT_PMON_BIT_SINGL_ERR_CORR_CHEC_CNT_MSK, RGFPF96_CORE_REG_SINGL_ERR_CORR_CHEC_CNT_PMON_BIT_SINGL_ERR_CORR_CHEC_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_SINGL_ERR_CORR_CHEC_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_UNPACK_DROP_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_UNPACK_DROP_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UNPACK_DROP_FRM_CNT_get", N, 95);
    /* ((0x0003701c + (N) * 0x80) bits 31:0) field UNPACK_DROP_FRM_CNT of register PMC_RGFPF96_CORE_REG_UNPACK_DROP_FRM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_UNPACK_DROP_FRM_CNT_PMON_array_read( b_ptr,
                                                                      h_ptr,
                                                                      N);
    value = (reg_value & RGFPF96_CORE_REG_UNPACK_DROP_FRM_CNT_PMON_BIT_UNPACK_DROP_FRM_CNT_MSK) >> RGFPF96_CORE_REG_UNPACK_DROP_FRM_CNT_PMON_BIT_UNPACK_DROP_FRM_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_UNPACK_DROP_FRM_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_UNPACK_DROP_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32  N,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_UNPACK_DROP_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32  N,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UNPACK_DROP_FRM_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UNPACK_DROP_FRM_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UNPACK_DROP_FRM_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x0003701c + (N) * 0x80) bits 31:0) field UNPACK_DROP_FRM_CNT of register PMC_RGFPF96_CORE_REG_UNPACK_DROP_FRM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_UNPACK_DROP_FRM_CNT_PMON_array_read( b_ptr,
                                                                      h_ptr,
                                                                      N);
    field_value = (reg_value & RGFPF96_CORE_REG_UNPACK_DROP_FRM_CNT_PMON_BIT_UNPACK_DROP_FRM_CNT_MSK)
                  >> RGFPF96_CORE_REG_UNPACK_DROP_FRM_CNT_PMON_BIT_UNPACK_DROP_FRM_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_UNPACK_DROP_FRM_CNT_PMON_BIT_UNPACK_DROP_FRM_CNT_MSK, RGFPF96_CORE_REG_UNPACK_DROP_FRM_CNT_PMON_BIT_UNPACK_DROP_FRM_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UNPACK_DROP_FRM_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_ERR_THEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_ERR_THEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_ERR_THEC_CNT_get", N, 95);
    /* ((0x00037020 + (N) * 0x80) bits 31:0) field ERR_THEC_CNT of register PMC_RGFPF96_CORE_REG_ERR_THEC_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_ERR_THEC_CNT_PMON_array_read( b_ptr,
                                                               h_ptr,
                                                               N);
    value = (reg_value & RGFPF96_CORE_REG_ERR_THEC_CNT_PMON_BIT_ERR_THEC_CNT_MSK) >> RGFPF96_CORE_REG_ERR_THEC_CNT_PMON_BIT_ERR_THEC_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_ERR_THEC_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_ERR_THEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_ERR_THEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_ERR_THEC_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_ERR_THEC_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_ERR_THEC_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037020 + (N) * 0x80) bits 31:0) field ERR_THEC_CNT of register PMC_RGFPF96_CORE_REG_ERR_THEC_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_ERR_THEC_CNT_PMON_array_read( b_ptr,
                                                               h_ptr,
                                                               N);
    field_value = (reg_value & RGFPF96_CORE_REG_ERR_THEC_CNT_PMON_BIT_ERR_THEC_CNT_MSK)
                  >> RGFPF96_CORE_REG_ERR_THEC_CNT_PMON_BIT_ERR_THEC_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_ERR_THEC_CNT_PMON_BIT_ERR_THEC_CNT_MSK, RGFPF96_CORE_REG_ERR_THEC_CNT_PMON_BIT_ERR_THEC_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_ERR_THEC_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_SINGL_ERR_CORR_TE_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_SINGL_ERR_CORR_TE_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                   mapotn_handle_t *h_ptr,
                                                                   UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_SINGL_ERR_CORR_TE_CNT_get", N, 95);
    /* ((0x00037024 + (N) * 0x80) bits 31:0) field SINGL_ERR_CORR_TE_CNT of register PMC_RGFPF96_CORE_REG_SINGL_ERR_CORR_TE_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_SINGL_ERR_CORR_TE_CNT_PMON_array_read( b_ptr,
                                                                        h_ptr,
                                                                        N);
    value = (reg_value & RGFPF96_CORE_REG_SINGL_ERR_CORR_TE_CNT_PMON_BIT_SINGL_ERR_CORR_TE_CNT_MSK) >> RGFPF96_CORE_REG_SINGL_ERR_CORR_TE_CNT_PMON_BIT_SINGL_ERR_CORR_TE_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_SINGL_ERR_CORR_TE_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_SINGL_ERR_CORR_TE_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  N,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_SINGL_ERR_CORR_TE_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                         mapotn_handle_t *h_ptr,
                                                                         UINT32  N,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_SINGL_ERR_CORR_TE_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_SINGL_ERR_CORR_TE_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_SINGL_ERR_CORR_TE_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037024 + (N) * 0x80) bits 31:0) field SINGL_ERR_CORR_TE_CNT of register PMC_RGFPF96_CORE_REG_SINGL_ERR_CORR_TE_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_SINGL_ERR_CORR_TE_CNT_PMON_array_read( b_ptr,
                                                                        h_ptr,
                                                                        N);
    field_value = (reg_value & RGFPF96_CORE_REG_SINGL_ERR_CORR_TE_CNT_PMON_BIT_SINGL_ERR_CORR_TE_CNT_MSK)
                  >> RGFPF96_CORE_REG_SINGL_ERR_CORR_TE_CNT_PMON_BIT_SINGL_ERR_CORR_TE_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_SINGL_ERR_CORR_TE_CNT_PMON_BIT_SINGL_ERR_CORR_TE_CNT_MSK, RGFPF96_CORE_REG_SINGL_ERR_CORR_TE_CNT_PMON_BIT_SINGL_ERR_CORR_TE_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_SINGL_ERR_CORR_TE_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_FILTER_DROP_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_FILTER_DROP_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_FILTER_DROP_FRM_CNT_get", N, 95);
    /* ((0x00037028 + (N) * 0x80) bits 31:0) field FILTER_DROP_FRM_CNT of register PMC_RGFPF96_CORE_REG_FILTER_DROP_FRM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_DROP_FRM_CNT_PMON_array_read( b_ptr,
                                                                      h_ptr,
                                                                      N);
    value = (reg_value & RGFPF96_CORE_REG_FILTER_DROP_FRM_CNT_PMON_BIT_FILTER_DROP_FRM_CNT_MSK) >> RGFPF96_CORE_REG_FILTER_DROP_FRM_CNT_PMON_BIT_FILTER_DROP_FRM_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_FILTER_DROP_FRM_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_FILTER_DROP_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32  N,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_FILTER_DROP_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                       mapotn_handle_t *h_ptr,
                                                                       UINT32  N,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_FILTER_DROP_FRM_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_FILTER_DROP_FRM_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_FILTER_DROP_FRM_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037028 + (N) * 0x80) bits 31:0) field FILTER_DROP_FRM_CNT of register PMC_RGFPF96_CORE_REG_FILTER_DROP_FRM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_FILTER_DROP_FRM_CNT_PMON_array_read( b_ptr,
                                                                      h_ptr,
                                                                      N);
    field_value = (reg_value & RGFPF96_CORE_REG_FILTER_DROP_FRM_CNT_PMON_BIT_FILTER_DROP_FRM_CNT_MSK)
                  >> RGFPF96_CORE_REG_FILTER_DROP_FRM_CNT_PMON_BIT_FILTER_DROP_FRM_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_FILTER_DROP_FRM_CNT_PMON_BIT_FILTER_DROP_FRM_CNT_MSK, RGFPF96_CORE_REG_FILTER_DROP_FRM_CNT_PMON_BIT_FILTER_DROP_FRM_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_FILTER_DROP_FRM_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_DEXM_EHEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DEXM_EHEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DEXM_EHEC_CNT_get", N, 95);
    /* ((0x0003702c + (N) * 0x80) bits 31:0) field DEXM_EHEC_CNT of register PMC_RGFPF96_CORE_REG_DEXM_EHEC_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_DEXM_EHEC_CNT_PMON_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    value = (reg_value & RGFPF96_CORE_REG_DEXM_EHEC_CNT_PMON_BIT_DEXM_EHEC_CNT_MSK) >> RGFPF96_CORE_REG_DEXM_EHEC_CNT_PMON_BIT_DEXM_EHEC_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_DEXM_EHEC_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_DEXM_EHEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_DEXM_EHEC_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_DEXM_EHEC_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_DEXM_EHEC_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_DEXM_EHEC_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x0003702c + (N) * 0x80) bits 31:0) field DEXM_EHEC_CNT of register PMC_RGFPF96_CORE_REG_DEXM_EHEC_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_DEXM_EHEC_CNT_PMON_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    field_value = (reg_value & RGFPF96_CORE_REG_DEXM_EHEC_CNT_PMON_BIT_DEXM_EHEC_CNT_MSK)
                  >> RGFPF96_CORE_REG_DEXM_EHEC_CNT_PMON_BIT_DEXM_EHEC_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_DEXM_EHEC_CNT_PMON_BIT_DEXM_EHEC_CNT_MSK, RGFPF96_CORE_REG_DEXM_EHEC_CNT_PMON_BIT_DEXM_EHEC_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_DEXM_EHEC_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_DUPM_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DUPM_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DUPM_FRM_CNT_get", N, 95);
    /* ((0x00037030 + (N) * 0x80) bits 31:0) field DUPM_FRM_CNT of register PMC_RGFPF96_CORE_REG_DUPM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_DUPM_CNT_PMON_array_read( b_ptr,
                                                           h_ptr,
                                                           N);
    value = (reg_value & RGFPF96_CORE_REG_DUPM_CNT_PMON_BIT_DUPM_FRM_CNT_MSK) >> RGFPF96_CORE_REG_DUPM_CNT_PMON_BIT_DUPM_FRM_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_DUPM_FRM_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_DUPM_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_DUPM_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_DUPM_FRM_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_DUPM_FRM_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_DUPM_FRM_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037030 + (N) * 0x80) bits 31:0) field DUPM_FRM_CNT of register PMC_RGFPF96_CORE_REG_DUPM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_DUPM_CNT_PMON_array_read( b_ptr,
                                                           h_ptr,
                                                           N);
    field_value = (reg_value & RGFPF96_CORE_REG_DUPM_CNT_PMON_BIT_DUPM_FRM_CNT_MSK)
                  >> RGFPF96_CORE_REG_DUPM_CNT_PMON_BIT_DUPM_FRM_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_DUPM_CNT_PMON_BIT_DUPM_FRM_CNT_MSK, RGFPF96_CORE_REG_DUPM_CNT_PMON_BIT_DUPM_FRM_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_DUPM_FRM_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_DGEM_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DGEM_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                          mapotn_handle_t *h_ptr,
                                                          UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_DGEM_FRM_CNT_get", N, 95);
    /* ((0x00037034 + (N) * 0x80) bits 31:0) field DGEM_FRM_CNT of register PMC_RGFPF96_CORE_REG_DGEM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_DGEM_CNT_PMON_array_read( b_ptr,
                                                           h_ptr,
                                                           N);
    value = (reg_value & RGFPF96_CORE_REG_DGEM_CNT_PMON_BIT_DGEM_FRM_CNT_MSK) >> RGFPF96_CORE_REG_DGEM_CNT_PMON_BIT_DGEM_FRM_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_DGEM_FRM_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_DGEM_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_DGEM_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32  N,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_DGEM_FRM_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_DGEM_FRM_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_DGEM_FRM_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037034 + (N) * 0x80) bits 31:0) field DGEM_FRM_CNT of register PMC_RGFPF96_CORE_REG_DGEM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_DGEM_CNT_PMON_array_read( b_ptr,
                                                           h_ptr,
                                                           N);
    field_value = (reg_value & RGFPF96_CORE_REG_DGEM_CNT_PMON_BIT_DGEM_FRM_CNT_MSK)
                  >> RGFPF96_CORE_REG_DGEM_CNT_PMON_BIT_DGEM_FRM_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_DGEM_CNT_PMON_BIT_DGEM_FRM_CNT_MSK, RGFPF96_CORE_REG_DGEM_CNT_PMON_BIT_DGEM_FRM_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_DGEM_FRM_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_CSF_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CSF_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CSF_FRM_CNT_get", N, 95);
    /* ((0x00037038 + (N) * 0x80) bits 7:0) field CSF_FRM_CNT of register PMC_RGFPF96_CORE_REG_CSF_FRM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CSF_FRM_CNT_PMON_array_read( b_ptr,
                                                              h_ptr,
                                                              N);
    value = (reg_value & RGFPF96_CORE_REG_CSF_FRM_CNT_PMON_BIT_CSF_FRM_CNT_MSK) >> RGFPF96_CORE_REG_CSF_FRM_CNT_PMON_BIT_CSF_FRM_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CSF_FRM_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_CSF_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_CSF_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_CSF_FRM_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_CSF_FRM_CNT_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_CSF_FRM_CNT_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037038 + (N) * 0x80) bits 7:0) field CSF_FRM_CNT of register PMC_RGFPF96_CORE_REG_CSF_FRM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CSF_FRM_CNT_PMON_array_read( b_ptr,
                                                              h_ptr,
                                                              N);
    field_value = (reg_value & RGFPF96_CORE_REG_CSF_FRM_CNT_PMON_BIT_CSF_FRM_CNT_MSK)
                  >> RGFPF96_CORE_REG_CSF_FRM_CNT_PMON_BIT_CSF_FRM_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_CSF_FRM_CNT_PMON_BIT_CSF_FRM_CNT_MSK, RGFPF96_CORE_REG_CSF_FRM_CNT_PMON_BIT_CSF_FRM_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_CSF_FRM_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_ERR_FCS_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_ERR_FCS_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_ERR_FCS_CNT_get", N, 95);
    /* ((0x0003703c + (N) * 0x80) bits 31:0) field ERR_FCS_CNT of register PMC_RGFPF96_CORE_REG_ERR_FCS_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_ERR_FCS_CNT_PMON_array_read( b_ptr,
                                                              h_ptr,
                                                              N);
    value = (reg_value & RGFPF96_CORE_REG_ERR_FCS_CNT_PMON_BIT_ERR_FCS_CNT_MSK) >> RGFPF96_CORE_REG_ERR_FCS_CNT_PMON_BIT_ERR_FCS_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_ERR_FCS_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_ERR_FCS_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_ERR_FCS_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_ERR_FCS_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_ERR_FCS_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_ERR_FCS_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x0003703c + (N) * 0x80) bits 31:0) field ERR_FCS_CNT of register PMC_RGFPF96_CORE_REG_ERR_FCS_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_ERR_FCS_CNT_PMON_array_read( b_ptr,
                                                              h_ptr,
                                                              N);
    field_value = (reg_value & RGFPF96_CORE_REG_ERR_FCS_CNT_PMON_BIT_ERR_FCS_CNT_MSK)
                  >> RGFPF96_CORE_REG_ERR_FCS_CNT_PMON_BIT_ERR_FCS_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_ERR_FCS_CNT_PMON_BIT_ERR_FCS_CNT_MSK, RGFPF96_CORE_REG_ERR_FCS_CNT_PMON_BIT_ERR_FCS_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_ERR_FCS_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_PAUSE_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_PAUSE_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_PAUSE_FRM_CNT_get", N, 95);
    /* ((0x00037040 + (N) * 0x80) bits 31:0) field PAUSE_FRM_CNT of register PMC_RGFPF96_CORE_REG_PAUSE_FRM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_PAUSE_FRM_CNT_PMON_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    value = (reg_value & RGFPF96_CORE_REG_PAUSE_FRM_CNT_PMON_BIT_PAUSE_FRM_CNT_MSK) >> RGFPF96_CORE_REG_PAUSE_FRM_CNT_PMON_BIT_PAUSE_FRM_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_PAUSE_FRM_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_PAUSE_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_PAUSE_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_PAUSE_FRM_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_PAUSE_FRM_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_PAUSE_FRM_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037040 + (N) * 0x80) bits 31:0) field PAUSE_FRM_CNT of register PMC_RGFPF96_CORE_REG_PAUSE_FRM_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_PAUSE_FRM_CNT_PMON_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    field_value = (reg_value & RGFPF96_CORE_REG_PAUSE_FRM_CNT_PMON_BIT_PAUSE_FRM_CNT_MSK)
                  >> RGFPF96_CORE_REG_PAUSE_FRM_CNT_PMON_BIT_PAUSE_FRM_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_PAUSE_FRM_CNT_PMON_BIT_PAUSE_FRM_CNT_MSK, RGFPF96_CORE_REG_PAUSE_FRM_CNT_PMON_BIT_PAUSE_FRM_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_PAUSE_FRM_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_CPU_OVF_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CPU_OVF_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                         mapotn_handle_t *h_ptr,
                                                         UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_CPU_OVF_CNT_get", N, 95);
    /* ((0x00037048 + (N) * 0x80) bits 31:0) field CPU_OVF_CNT of register PMC_RGFPF96_CORE_REG_CPU_OVF_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_OVF_CNT_PMON_array_read( b_ptr,
                                                              h_ptr,
                                                              N);
    value = (reg_value & RGFPF96_CORE_REG_CPU_OVF_CNT_PMON_BIT_CPU_OVF_CNT_MSK) >> RGFPF96_CORE_REG_CPU_OVF_CNT_PMON_BIT_CPU_OVF_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_CPU_OVF_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_CPU_OVF_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_CPU_OVF_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32  N,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_CPU_OVF_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_CPU_OVF_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_CPU_OVF_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037048 + (N) * 0x80) bits 31:0) field CPU_OVF_CNT of register PMC_RGFPF96_CORE_REG_CPU_OVF_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_CPU_OVF_CNT_PMON_array_read( b_ptr,
                                                              h_ptr,
                                                              N);
    field_value = (reg_value & RGFPF96_CORE_REG_CPU_OVF_CNT_PMON_BIT_CPU_OVF_CNT_MSK)
                  >> RGFPF96_CORE_REG_CPU_OVF_CNT_PMON_BIT_CPU_OVF_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_CPU_OVF_CNT_PMON_BIT_CPU_OVF_CNT_MSK, RGFPF96_CORE_REG_CPU_OVF_CNT_PMON_BIT_CPU_OVF_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_CPU_OVF_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_EGRESS_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_EGRESS_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_EGRESS_FRM_CNT_get", N, 95);
    /* ((0x0003704c + (N) * 0x80) bits 31:0) field EGRESS_FRM_CNT of register PMC_RGFPF96_CORE_REG_EGRESS_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_EGRESS_CNT_PMON_array_read( b_ptr,
                                                             h_ptr,
                                                             N);
    value = (reg_value & RGFPF96_CORE_REG_EGRESS_CNT_PMON_BIT_EGRESS_FRM_CNT_MSK) >> RGFPF96_CORE_REG_EGRESS_CNT_PMON_BIT_EGRESS_FRM_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_EGRESS_FRM_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_EGRESS_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_EGRESS_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_EGRESS_FRM_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_EGRESS_FRM_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_EGRESS_FRM_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x0003704c + (N) * 0x80) bits 31:0) field EGRESS_FRM_CNT of register PMC_RGFPF96_CORE_REG_EGRESS_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_EGRESS_CNT_PMON_array_read( b_ptr,
                                                             h_ptr,
                                                             N);
    field_value = (reg_value & RGFPF96_CORE_REG_EGRESS_CNT_PMON_BIT_EGRESS_FRM_CNT_MSK)
                  >> RGFPF96_CORE_REG_EGRESS_CNT_PMON_BIT_EGRESS_FRM_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_EGRESS_CNT_PMON_BIT_EGRESS_FRM_CNT_MSK, RGFPF96_CORE_REG_EGRESS_CNT_PMON_BIT_EGRESS_FRM_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_EGRESS_FRM_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_UNPACK_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_UNPACK_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_UNPACK_FRM_CNT_get", N, 95);
    /* ((0x00037050 + (N) * 0x80) bits 31:0) field UNPACK_FRM_CNT of register PMC_RGFPF96_CORE_REG_UNPACK_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_UNPACK_CNT_PMON_array_read( b_ptr,
                                                             h_ptr,
                                                             N);
    value = (reg_value & RGFPF96_CORE_REG_UNPACK_CNT_PMON_BIT_UNPACK_FRM_CNT_MSK) >> RGFPF96_CORE_REG_UNPACK_CNT_PMON_BIT_UNPACK_FRM_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_UNPACK_FRM_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_UNPACK_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_UNPACK_FRM_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                  mapotn_handle_t *h_ptr,
                                                                  UINT32  N,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_UNPACK_FRM_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_UNPACK_FRM_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_UNPACK_FRM_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037050 + (N) * 0x80) bits 31:0) field UNPACK_FRM_CNT of register PMC_RGFPF96_CORE_REG_UNPACK_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_UNPACK_CNT_PMON_array_read( b_ptr,
                                                             h_ptr,
                                                             N);
    field_value = (reg_value & RGFPF96_CORE_REG_UNPACK_CNT_PMON_BIT_UNPACK_FRM_CNT_MSK)
                  >> RGFPF96_CORE_REG_UNPACK_CNT_PMON_BIT_UNPACK_FRM_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_UNPACK_CNT_PMON_BIT_UNPACK_FRM_CNT_MSK, RGFPF96_CORE_REG_UNPACK_CNT_PMON_BIT_UNPACK_FRM_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_UNPACK_FRM_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_MINFL_CHK_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_MINFL_CHK_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_MINFL_CHK_CNT_get", N, 95);
    /* ((0x00037054 + (N) * 0x80) bits 31:0) field MINFL_CHK_CNT of register PMC_RGFPF96_CORE_REG_MINFL_CHK_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_MINFL_CHK_CNT_PMON_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    value = (reg_value & RGFPF96_CORE_REG_MINFL_CHK_CNT_PMON_BIT_MINFL_CHK_CNT_MSK) >> RGFPF96_CORE_REG_MINFL_CHK_CNT_PMON_BIT_MINFL_CHK_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_MINFL_CHK_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_MINFL_CHK_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_MINFL_CHK_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_MINFL_CHK_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MINFL_CHK_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MINFL_CHK_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037054 + (N) * 0x80) bits 31:0) field MINFL_CHK_CNT of register PMC_RGFPF96_CORE_REG_MINFL_CHK_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_MINFL_CHK_CNT_PMON_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    field_value = (reg_value & RGFPF96_CORE_REG_MINFL_CHK_CNT_PMON_BIT_MINFL_CHK_CNT_MSK)
                  >> RGFPF96_CORE_REG_MINFL_CHK_CNT_PMON_BIT_MINFL_CHK_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_MINFL_CHK_CNT_PMON_BIT_MINFL_CHK_CNT_MSK, RGFPF96_CORE_REG_MINFL_CHK_CNT_PMON_BIT_MINFL_CHK_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MINFL_CHK_CNT_get", N, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_MAXFL_CHK_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_MAXFL_CHK_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                           mapotn_handle_t *h_ptr,
                                                           UINT32  N )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_MAXFL_CHK_CNT_get", N, 95);
    /* ((0x00037058 + (N) * 0x80) bits 31:0) field MAXFL_CHK_CNT of register PMC_RGFPF96_CORE_REG_MAXFL_CHK_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_MAXFL_CHK_CNT_PMON_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    value = (reg_value & RGFPF96_CORE_REG_MAXFL_CHK_CNT_PMON_BIT_MAXFL_CHK_CNT_MSK) >> RGFPF96_CORE_REG_MAXFL_CHK_CNT_PMON_BIT_MAXFL_CHK_CNT_OFF;
    IOLOG( "%s -> N=%d 0x%08x", "mapotn_rgfpf_field_MAXFL_CHK_CNT_get", N, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_MAXFL_CHK_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_MAXFL_CHK_CNT_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                 mapotn_handle_t *h_ptr,
                                                                 UINT32  N,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (N > 95)
        IO_RANGE_CHECK("%s N is %d but max is %d", "mapotn_rgfpf_field_range_MAXFL_CHK_CNT_get", N, 95);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_MAXFL_CHK_CNT_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_MAXFL_CHK_CNT_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* ((0x00037058 + (N) * 0x80) bits 31:0) field MAXFL_CHK_CNT of register PMC_RGFPF96_CORE_REG_MAXFL_CHK_CNT_PMON index N=0..95 */
    reg_value = mapotn_rgfpf_reg_MAXFL_CHK_CNT_PMON_array_read( b_ptr,
                                                                h_ptr,
                                                                N);
    field_value = (reg_value & RGFPF96_CORE_REG_MAXFL_CHK_CNT_PMON_BIT_MAXFL_CHK_CNT_MSK)
                  >> RGFPF96_CORE_REG_MAXFL_CHK_CNT_PMON_BIT_MAXFL_CHK_CNT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_MAXFL_CHK_CNT_PMON_BIT_MAXFL_CHK_CNT_MSK, RGFPF96_CORE_REG_MAXFL_CHK_CNT_PMON_BIT_MAXFL_CHK_CNT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> N=%d start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_MAXFL_CHK_CNT_get", N, start_bit, stop_bit, value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset status
 * ==================================================================================
 */
static INLINE UINT32 mapotn_rgfpf_field_DEXM_TYPEHDR_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DEXM_TYPEHDR_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301bc bits 31:16) field DEXM_TYPEHDR of register PMC_RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS */
    reg_value = mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_read( b_ptr,
                                                                     h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_TYPEHDR_MSK) >> RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_TYPEHDR_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_DEXM_TYPEHDR_get", value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_DEXM_TYPEHDR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_DEXM_TYPEHDR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_DEXM_TYPEHDR_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_DEXM_TYPEHDR_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000301bc bits 31:16) field DEXM_TYPEHDR of register PMC_RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS */
    reg_value = mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_read( b_ptr,
                                                                     h_ptr);
    field_value = (reg_value & RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_TYPEHDR_MSK)
                  >> RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_TYPEHDR_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_TYPEHDR_MSK, RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_TYPEHDR_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_DEXM_TYPEHDR_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_DEXM_CID_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DEXM_CID_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301bc bits 15:8) field DEXM_CID of register PMC_RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS */
    reg_value = mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_read( b_ptr,
                                                                     h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_CID_MSK) >> RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_CID_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_DEXM_CID_get", value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_DEXM_CID_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_DEXM_CID_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                            mapotn_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_DEXM_CID_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_DEXM_CID_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000301bc bits 15:8) field DEXM_CID of register PMC_RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS */
    reg_value = mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_read( b_ptr,
                                                                     h_ptr);
    field_value = (reg_value & RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_CID_MSK)
                  >> RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_CID_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_CID_MSK, RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_CID_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_DEXM_CID_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_DEXM_CHID_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DEXM_CHID_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301bc bits 7:1) field DEXM_CHID of register PMC_RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS */
    reg_value = mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_read( b_ptr,
                                                                     h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_CHID_MSK) >> RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_CHID_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_DEXM_CHID_get", value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_DEXM_CHID_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_DEXM_CHID_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_DEXM_CHID_get", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_DEXM_CHID_get", stop_bit, 6 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 6) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 6;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000301bc bits 7:1) field DEXM_CHID of register PMC_RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS */
    reg_value = mapotn_rgfpf_reg_EXTENSION_HDR_MIS_FAIL_STATUS_read( b_ptr,
                                                                     h_ptr);
    field_value = (reg_value & RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_CHID_MSK)
                  >> RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_CHID_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_CHID_MSK, RGFPF96_CORE_REG_EXTENSION_HDR_MIS_FAIL_STATUS_BIT_DEXM_CHID_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_DEXM_CHID_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_DUPM_TYPEHDR_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DUPM_TYPEHDR_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301c0 bits 23:8) field DUPM_TYPEHDR of register PMC_RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS */
    reg_value = mapotn_rgfpf_reg_PTI_UPI_MIS_STATUS_read( b_ptr,
                                                          h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_TYPEHDR_MSK) >> RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_TYPEHDR_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_DUPM_TYPEHDR_get", value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_DUPM_TYPEHDR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_DUPM_TYPEHDR_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                                mapotn_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_DUPM_TYPEHDR_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_DUPM_TYPEHDR_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000301c0 bits 23:8) field DUPM_TYPEHDR of register PMC_RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS */
    reg_value = mapotn_rgfpf_reg_PTI_UPI_MIS_STATUS_read( b_ptr,
                                                          h_ptr);
    field_value = (reg_value & RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_TYPEHDR_MSK)
                  >> RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_TYPEHDR_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_TYPEHDR_MSK, RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_TYPEHDR_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_DUPM_TYPEHDR_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_DUPM_CHID_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_DUPM_CHID_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301c0 bits 7:1) field DUPM_CHID of register PMC_RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS */
    reg_value = mapotn_rgfpf_reg_PTI_UPI_MIS_STATUS_read( b_ptr,
                                                          h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_CHID_MSK) >> RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_CHID_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_DUPM_CHID_get", value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_DUPM_CHID_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_DUPM_CHID_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_DUPM_CHID_get", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_DUPM_CHID_get", stop_bit, 6 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 6) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 6;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000301c0 bits 7:1) field DUPM_CHID of register PMC_RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS */
    reg_value = mapotn_rgfpf_reg_PTI_UPI_MIS_STATUS_read( b_ptr,
                                                          h_ptr);
    field_value = (reg_value & RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_CHID_MSK)
                  >> RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_CHID_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_CHID_MSK, RGFPF96_CORE_REG_PTI_UPI_MIS_STATUS_BIT_DUPM_CHID_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_DUPM_CHID_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_CHID_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_CHID_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301c8 bits 15:9) field CSF_ST_CHID of register PMC_RGFPF96_CORE_REG_CSF_STATUS */
    reg_value = mapotn_rgfpf_reg_CSF_STATUS_read(  b_ptr, h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_CSF_STATUS_BIT_CSF_ST_CHID_MSK) >> RGFPF96_CORE_REG_CSF_STATUS_BIT_CSF_ST_CHID_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_CSF_ST_CHID_get", value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_CSF_ST_CHID_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_CSF_ST_CHID_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_CSF_ST_CHID_get", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_CSF_ST_CHID_get", stop_bit, 6 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 6) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 6;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000301c8 bits 15:9) field CSF_ST_CHID of register PMC_RGFPF96_CORE_REG_CSF_STATUS */
    reg_value = mapotn_rgfpf_reg_CSF_STATUS_read(  b_ptr, h_ptr);
    field_value = (reg_value & RGFPF96_CORE_REG_CSF_STATUS_BIT_CSF_ST_CHID_MSK)
                  >> RGFPF96_CORE_REG_CSF_STATUS_BIT_CSF_ST_CHID_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_CSF_STATUS_BIT_CSF_ST_CHID_MSK, RGFPF96_CORE_REG_CSF_STATUS_BIT_CSF_ST_CHID_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_CSF_ST_CHID_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_UPI_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_UPI_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301c8 bits 8:1) field CSF_ST_UPI of register PMC_RGFPF96_CORE_REG_CSF_STATUS */
    reg_value = mapotn_rgfpf_reg_CSF_STATUS_read(  b_ptr, h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_CSF_STATUS_BIT_CSF_ST_UPI_MSK) >> RGFPF96_CORE_REG_CSF_STATUS_BIT_CSF_ST_UPI_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_CSF_ST_UPI_get", value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_range_CSF_ST_UPI_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_range_CSF_ST_UPI_get( mapotn_rgfpf_buffer_t *b_ptr,
                                                              mapotn_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "mapotn_rgfpf_field_range_CSF_ST_UPI_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "mapotn_rgfpf_field_range_CSF_ST_UPI_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000301c8 bits 8:1) field CSF_ST_UPI of register PMC_RGFPF96_CORE_REG_CSF_STATUS */
    reg_value = mapotn_rgfpf_reg_CSF_STATUS_read(  b_ptr, h_ptr);
    field_value = (reg_value & RGFPF96_CORE_REG_CSF_STATUS_BIT_CSF_ST_UPI_MSK)
                  >> RGFPF96_CORE_REG_CSF_STATUS_BIT_CSF_ST_UPI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, RGFPF96_CORE_REG_CSF_STATUS_BIT_CSF_ST_UPI_MSK, RGFPF96_CORE_REG_CSF_STATUS_BIT_CSF_ST_UPI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "mapotn_rgfpf_field_range_CSF_ST_UPI_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_VALID_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_CSF_ST_VALID_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000301c8 bits 0) field CSF_ST_VALID of register PMC_RGFPF96_CORE_REG_CSF_STATUS */
    reg_value = mapotn_rgfpf_reg_CSF_STATUS_read(  b_ptr, h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_CSF_STATUS_BIT_CSF_ST_VALID_MSK) >> RGFPF96_CORE_REG_CSF_STATUS_BIT_CSF_ST_VALID_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_CSF_ST_VALID_get", value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset test_set
 * ==================================================================================
 */
static INLINE void mapotn_rgfpf_field_MTX_CPU_DATA_FIFO_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_MTX_CPU_DATA_FIFO_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                             mapotn_handle_t *h_ptr,
                                                             UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_MTX_CPU_DATA_FIFO_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_MTX_CPU_DATA_FIFO_set", value );

    /* (0x00030700 bits 0) field MTX_CPU_DATA_FIFO of register PMC_RGFPF96_CORE_REG_MUTEX_CPU_DATA_FIFO */
    mapotn_rgfpf_reg_MUTEX_CPU_DATA_FIFO_field_set( b_ptr,
                                                    h_ptr,
                                                    RGFPF96_CORE_REG_MUTEX_CPU_DATA_FIFO_BIT_MTX_CPU_DATA_FIFO_MSK,
                                                    RGFPF96_CORE_REG_MUTEX_CPU_DATA_FIFO_BIT_MTX_CPU_DATA_FIFO_OFF,
                                                    value);
}

static INLINE UINT32 mapotn_rgfpf_field_MTX_CPU_DATA_FIFO_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_MTX_CPU_DATA_FIFO_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030700 bits 0) field MTX_CPU_DATA_FIFO of register PMC_RGFPF96_CORE_REG_MUTEX_CPU_DATA_FIFO */
    reg_value = mapotn_rgfpf_reg_MUTEX_CPU_DATA_FIFO_read( b_ptr,
                                                           h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_MUTEX_CPU_DATA_FIFO_BIT_MTX_CPU_DATA_FIFO_MSK) >> RGFPF96_CORE_REG_MUTEX_CPU_DATA_FIFO_BIT_MTX_CPU_DATA_FIFO_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_MTX_CPU_DATA_FIFO_get", value );

    return value;
}
static INLINE void mapotn_rgfpf_field_MTX_CSF_STATUS_FIFO_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void mapotn_rgfpf_field_MTX_CSF_STATUS_FIFO_set( mapotn_rgfpf_buffer_t *b_ptr,
                                                               mapotn_handle_t *h_ptr,
                                                               UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "mapotn_rgfpf_field_MTX_CSF_STATUS_FIFO_set", value, 1);
    IOLOG( "%s <= 0x%08x", "mapotn_rgfpf_field_MTX_CSF_STATUS_FIFO_set", value );

    /* (0x00030880 bits 0) field MTX_CSF_STATUS_FIFO of register PMC_RGFPF96_CORE_REG_MUTEX_CSF_STATUS_FIFO */
    mapotn_rgfpf_reg_MUTEX_CSF_STATUS_FIFO_field_set( b_ptr,
                                                      h_ptr,
                                                      RGFPF96_CORE_REG_MUTEX_CSF_STATUS_FIFO_BIT_MTX_CSF_STATUS_FIFO_MSK,
                                                      RGFPF96_CORE_REG_MUTEX_CSF_STATUS_FIFO_BIT_MTX_CSF_STATUS_FIFO_OFF,
                                                      value);
}

static INLINE UINT32 mapotn_rgfpf_field_MTX_CSF_STATUS_FIFO_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 mapotn_rgfpf_field_MTX_CSF_STATUS_FIFO_get( mapotn_rgfpf_buffer_t *b_ptr, mapotn_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00030880 bits 0) field MTX_CSF_STATUS_FIFO of register PMC_RGFPF96_CORE_REG_MUTEX_CSF_STATUS_FIFO */
    reg_value = mapotn_rgfpf_reg_MUTEX_CSF_STATUS_FIFO_read( b_ptr,
                                                             h_ptr);
    value = (reg_value & RGFPF96_CORE_REG_MUTEX_CSF_STATUS_FIFO_BIT_MTX_CSF_STATUS_FIFO_MSK) >> RGFPF96_CORE_REG_MUTEX_CSF_STATUS_FIFO_BIT_MTX_CSF_STATUS_FIFO_OFF;
    IOLOG( "%s -> 0x%08x", "mapotn_rgfpf_field_MTX_CSF_STATUS_FIFO_get", value );

    return value;
}

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _MAPOTN_RGFPF_IO_INLINE_H */
